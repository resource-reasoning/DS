\subsection{cops}


\subsubsection{Code}
\renewcommand{\thelstlisting}{\arabic{lstlisting}}
\lstinputlisting{\RootPath/cops/pseudocode}

\subsubsection{Semantics the code}

Let \( \repl \in \Repls \) denotes the set of totally ordered replicates.
Each replicate can have multiple clients, and 
each clients can commit a sequence of either read-only transitions or single-write transactions.
To model these, we annotate the transaction identifier with replicate \( \repl \), client \( \cl \), 
local time of the replicate \( n \) and read-only transactions count \( n' \), \ie \( \txidCOPS{\repl}{\cl}{n}{n'} \).
Note that the \( (n, \repl, n') \) can be treated as a single number that \( n \) are the higher bits, 
\( \repl \) the middle bits and \( n' \) the lower bits.
There is a total order among transitions from the same replica and from the same client.
We extend version with the set of all versions it dependencies on, \( \dep \in \pset{\Keys \times \TxID} \).
The function \( \depOf{\ver} \) denotes the dependencies set of the version.
For readability, we annotate view with either a replica, \( \viREPL \), or a client, \( \viCL \).
The view environment is extended with replicas and their views, \( \viewFunCOPS : (\Repls \times \ClientID ) \parfinfun \Views \).
We give the following semantics to capture the behaviours of the code.

\begin{lstlisting}[caption={put},label={lst:simplified-put}]
// mixing the client API and system API
put(repl,k,v,ctx) {

    // Dependency for previous reads and writes
    deps = ctx_to_dep(ctx);(*\label{line:put-ctx-to-deps}*)

    atomic{
        // increase local time.
        inc(repl.local_time);(*\label{line:put-inc-local}*) 

        // appending local kv with a new version.
        list_isnert(repl.kv[k],(v, (local_time + id), deps));(*\label{line:put-update-kv}*)
    }

    // update dependency for writes
    ctx.writers += (k,(local_time + id),deps);(*\label{line:put-update-ctx}*)

    // put in the queue to sync with other replicas
    enqueue(k,v,(current_ver+id),(deps ++ vers));
}
\end{lstlisting}

The client always fetches the version with the maximum writer it can observed for each key,
Which is computed by \( \funcn{getMax} \) function. 
It is different from \( \snapshot \) as \( \snapshot \) fetches the latest version with respect to the position in the list.

\[
    \begin{rclarray}
        \func{getMax}{\mkvsCOPS, \viCL} & \defeq &
        \lambda \ke \ldotp \left( \max_\txid\Setcon{(\val, \txid, \T, \dep)}{\exsts{i} (\val, \txid, \T, \dep) = \mkvsCOPS(\ke, i) \land i \in \viCL(\ke)} \right)\projection{1}
    \end{rclarray}
\]
\begin{mathpar}
    \inferrule[Put]{%
        ( \stk, \func{getMax}{\mkvsCOPS, \viCL}, \emptyset ), \pmutate{\ke}{\vx} \toL
        ( \stk', \stub, \Set{(\otW, \ke, \val )} ), \pskip
        \\\\
        \dep = \Setcon{(\ke', \txid)}{\exsts{i} i \in \viCL(\ke') \land \txid = \WTx(\mkvsCOPS(\ke', i)) \lor (\ke', \txid) \in \depOf{\mkvsCOPS(\ke', i)} } \texttt{ ---> \cref{lst:simplified-put}, \cref{line:put-ctx-to-deps}} 
        \\\\
        \txid = \min\Setcon{%
        \txidCOPS{\repl}{\cl}{n'}{0}
        }{%
            \fora{\ke', i \in \viREPL(\ke'), n} \\
            \quad \txidCOPS{\stub}{\stub}{n}{\stub} = \WTx(\mkvsCOPS(\ke',i)) \\
            \qquad {} \implies n' > n 
        } \texttt{ ---> \cref{lst:simplified-put}, \cref{line:put-inc-local}}
        \\\\
        \mkvsCOPS' = \mkvsCOPS\rmto{\ke}{\mkvsCOPS(\ke) \lcat \List{(\ke, \txid, \emptyset, \dep)}} \texttt{ ---> \cref{lst:simplified-put}, \cref{line:put-update-kv}}
        \\\\
        \viREPL' = \viREPL\rmto{\ke}{\viREPL(\ke) \uplus \Set{\abs{\mkvsCOPS'(\ke)} - 1}} \texttt{ ---> \cref{lst:simplified-put}, \cref{line:put-update-kv}}
        \\\\
        \viCL' = \viCL\rmto{\ke}{\viREPL(\ke) \uplus \Set{\abs{\mkvsCOPS'(\ke)} - 1}} \texttt{ ---> \cref{lst:simplified-put}, \cref{line:put-update-ctx}}
    }{%
    \repl, \cl \vdash 
    \mkvsCOPS, \viREPL, \viCL, \stk, \ptrans{\pmutate{\ke}{\vx};} \toT{\viCL, \Set{(\otW, \ke, \val )} }
    \mkvsCOPS', \viREPL', \viCL', \stk', \pskip
    }
\end{mathpar}
The \verb|get_trans| fetches the latest versions from the replica via multiple atomic reads, one for each key.
As a result, a client has a list of candidates \verb|rst|.
Since interleaving might happen, versions might become out-of-date because the replicate receives new versions.
It is not a problem to read old versions as long as they satisfy causal consistency,
\ie if a client read a version \( \ver \), it should at least read all the versions that \( \ver \) depends on.
Thus the algorithm use \verb|ccv| to track the maximum versions the client should fetches,
and re-fetches the \verb|ccv[k]| version from the replica if it is greater than the candidate.

The following is a simplified algorithm by directly taking a list of versions \verb|ccv| satisfies causal consistency constraint,
and then read the versions indicated by \verb|ccv|.
The simplified algorithm is easier to understand.
\begin{lstlisting}[caption={get\_trans},label={lst:get-trans}]
// A simplified version by guessing
// a ccv satisfying dependency constraints
// and then read versions indicated by ccv.
// Note that it is a weaker version of the original code,
// as the original implementation fetches the latest versions
// for keys by a sequence of atomic get_by_version calls
List(Val) get_trans(ks,ctx) {
    take ccv: (*$\forall$*) k (*$\in$*) ks.(*\label{line:get-trans-ccv-1}*)
        (_,_,deps) := get_by_version(k,ccv[k]) (*${}\land \forall$*) dep (*$\in$*) deps.(*\label{line:get-trans-ccv-2}*)
            dep.key (*$\in$*) ks (*$\implies$*) ccv[dep.key] >= dep.ver (*\label{line:get-trans-ccv-3}*)

    for k in ks(*\label{line:get-trans-read-1}*)
        rst[k] = get_by_version(k,ccv[k]);(*\label{line:get-trans-read-2}*)

    // update the ctx
    for (k,ver,deps) in rst(*\label{line:get-trans-update-ctx-1}*)
        ctx.readers += (k,ver,deps);(*\label{line:get-trans-update-ctx-2}*)

    return to_vals(ks);
}                                   
\end{lstlisting}
\begin{mathpar}
    \inferrule[GetTrans]{%
        \viCL \viewleq \viCL' \viewleq \viREPL  \texttt{ ---> \cref{lst:get-trans}, \cref{line:get-trans-update-ctx-1,line:get-trans-update-ctx-2}}
        \\\\
        {\left(\begin{array}{@{}l@{}}
        \fora{\ke, \ke', m, \ver}  \\
        \quad \ver = \mkvsCOPS(\ke, \max(\viCL'(\ke)) \land {} \\
        \quad (\ke', \WTx(\mkvsCOPS(\ke', m))) \in \depOf{\ver} \\
        \qquad {} \implies m \in \viCL'(\ke')
        \end{array}\right)} \texttt{ ---> \cref{lst:get-trans}, \cref{line:get-trans-ccv-1,line:get-trans-ccv-2,line:get-trans-ccv-3}}
        \\\\
        \trans =  \pderef{\vx_1}{\ke_1}; \dots; \pderef{\vx_j}{\ke_j};
        \\\\
        ( \stk, \func{getMax}{\mkvsCOPS, \viCL'}, \emptyset ), \trans \toL
        ( \stk', \stub, \f ), \pskip \texttt{ ---> \cref{lst:get-trans}, \cref{line:get-trans-read-1,line:get-trans-read-2}}
        \\\\
        \txidCOPS{\repl}{\cl}{n'}{n} = \max\Setcon{\txidCOPS{\repl}{\cl}{z'}{z}}{\txidCOPS{\repl}{\cl}{z'}{z} \in \mkvsCOPS }
        \\
        \mkvsCOPS' = \updKV{\mkvsCOPS, \viCL', \txidCOPS{\repl}{\cl}{n'}{n+1}, \f} 
    }{%
        \repl, \cl \vdash 
        \mkvsCOPS, \viREPL, \viCL, \stk, \ptrans{\pderef{\vx_1}{\ke_1}; \dots; \pderef{\vx_j}{\ke_j}; } \toT{\viCL', \f}
        \mkvsCOPS', \viREPL, \viCL', \stk', \pskip
    }
    \and
    \inferrule[ClientCommit]{%
        \repl, \cl \vdash 
        \mkvsCOPS, \viewFunCOPS(\repl), \viewFunCOPS(\cl), \stk, \prog(\cl) \toT{\viCL'', \f}
        \mkvsCOPS', \viREPL', \viCL', \stk', \cmd'
    }{%
        \mkvsCOPS, \viewFunCOPS, \thdenv, \prog \toG{\viCL'', \f}
        \mkvsCOPS', \viewFunCOPS\rmto{\repl}{\viREPL'}\rmto{\cl}{\viCL'}, \thdenv\rmto{\cl}{\stk'}, \prog\rmto{\cl}{\cmd'}
    }
\end{mathpar}
A replica updates its local state only if all the dependencies has been receive.
\begin{lstlisting}[caption={Send and receive},label={lst:send-receive}]
// Syn to other replicas
send() {
    (k,v,ver,deps) := dequeue();
    for id in repls {
        send (k,v,ver,deps) to id;
    }
}

// receive a write message from other replica
on_receive(k,v,ver,deps) {
    // for a single machine
    // the following check immediately holds
    for (k',ver') in deps {
        wait until dep_check(k',ver');(*\label{line:receive-wait}*)
    }

    atomic{
        list_isnert(kv[k],(v,ver,deps));(*\label{line:receive-update-view-1}*)
        (remote_local_time + id) = ver;(*\label{line:receive-update-view-2}*)
        local_time = max(remote_local_time, local_time);(*\label{line:receive-update-view-3}*)
    }
}
\end{lstlisting}
\begin{mathpar}
    \inferrule[sync]{%
        \viREPL = \viewFunCOPS(\repl)\rmto{\ke}{\viewFunCOPS(\repl)(\ke) \uplus i} 
        \texttt{ ---> \cref{lst:send-receive}, \cref{line:receive-update-view-1,line:receive-update-view-2,line:receive-update-view-3}}
        \\\\
        {\left(\begin{array}{@{}l@{}}
        \fora{\ke', m, \ver} 
        \ver = \mkvsCOPS(\ke, i) \land {} \\
        \quad (\ke', \WTx(\mkvsCOPS(\ke', m))) \in \ver\projection{4} \\
        \qquad {} \implies m \in \viREPL'(\ke') 
        \end{array}\right)} \texttt{ ---> \cref{lst:send-receive}, \cref{line:receive-wait}} 
    }{%
        \mkvsCOPS, \viewFunCOPS, \thdenv, \prog \toG{}
        \mkvsCOPS, \viewFunCOPS\rmto{\repl}{\viREPL}, \thdenv, \prog
    }
\end{mathpar}

%A view \( \vi \) on key-value store \( \mkvsCOPS \) \emph{agrees} 
%with another view \( \vi \) on another key-value store \( \mkvsCOPS' \), if and only
%\[
 %\func{getMax}{\mkvsCOPS, \vi} = \func{getMax}{\mkvsCOPS', \vi'}
%\]


\begin{lemma}
    \label{lem:client-subset-repl}
    The view of a client is subset of the view of the replica that the client interacts with.
\end{lemma}


\begin{theorem}[Well-formed COPS key-value]
    \label{thm:cops-key-value-well-form}
    Let ignore the dependencies of versions from \( \mkvsCOPS \).
    Given the initial key-value store \( \mkvsCOPS_0 \), initial views \( \viewFunCOPS_0 \) and some programs \( \prog_0 \), for any \( \mkvsCOPS_i \) and \( \viewFunCOPS_i \)  such that: 
    \[
        \mkvsCOPS_0, \viewFunCOPS_0, \thdenv_0, \prog_0 {\toG{}}^* \mkvsCOPS_i, \viewFunCOPS_i, \thdenv_i, \prog_i
    \]
    The key-value store \( \mkvsCOPS_i \) satisfies the \cref{def:mkvs} and any replica or client view \( \vi \) from \( \viewFunCOPS_i \) is a valid view of the key-value store, \ie \( \vi \in \Views(\mkvsCOPS_i) \).
\end{theorem}
\begin{proof}
    We need to prove the  \( \mkvsCOPS_i \) satisfies the well-formed conditions,
    and any view \( \vi_i \Views(\mkvsCOPS_i) \).
    We prove it by introduction on the length \( i \).
    \begin{itemize}
    \item \caseB{\(i = 0\)}
        It holds trivially since each key only has the initial version \( (\val_0,\txid_0,\emptyset, \emptyset) \).
        Since there is only the initial version for each key, it is easy to see that any view \( \vi_0 \) satisfying the well-formed conditions in \cref{def:views}.
    \item \caseI{\(i > 0\)}
        Suppose it holds when \( i \), let consider \( i + 1 \).
        We perform case analysis on the possible next step:
        \begin{itemize}
            \item \rl{Put}
                Assume the client \( \cl \) of a replica \( \repl \) commits a single-write transaction \( \txid \) that installs a new version for key \( \ke \).
                By the premiss of \rl{Put}, the new transaction identifier \( \txid = \txidCOPS{\repl}{\cl}{n'}{0} \) where for some \( n' \) that is greater than any \( n \) from any writers \( \txidCOPS{\stub}{\stub}{n}{\stub} \) that are observable by the replica \( \repl \).
                Since the new transaction \( \txid = \txidCOPS{\repl}{\cl}{n'}{0} \) is a single-write transaction which is always installed at the end of the list associated to \( \ke \), it is sufficient to prove the following:
                \begin{gather}
                    \fora{j} 0 \leq j < \abs{ \mkvsCOPS_i(\ke) } \implies \WTx(\mkvsCOPS_{i}(\ke, j)) \neq \txid \label{equ:write-trans-unique} \\
                    \fora{j, n} \txidCOPS{\repl}{\cl}{n}{\stub} \in \Set{\WTx(\mkvsCOPS_{i}(\ke,j))} \cup \RTx(\mkvsCOPS_{i}(\ke, j)) \implies n < n' \label{equ:replica-time-monotonic-inc}
                \end{gather}
                \cref{lem:mono-local-time} implies \cref{equ:write-trans-unique} and \cref{equ:replica-time-monotonic-inc}.
                Thus the new key-value store \( \mkvsCOPS_{i+1} \) satisfies the well-formed conditions.
                Now let consider the views, especially the views of the replica \( \viREPL' \) and the client \( \viCL' \).
                Since that views \( \vi' \) from different replicas or clients remain unchanged, by \ih they satisfy \( \vi' \in \Views(\mkvsCOPS_{i+1}) \).
                The new view for replica \( \viREPL' = \viREPL\rmto{\ke}{\abs{\mkvsCOPS_{i+1}(\ke)} - 1} \)
                where \( \viREPL \) is the replica's view before updating and the writer of the last version of \( \ke \) is \( \txid \).
                Because \( \txid \) is a single-write transaction, so the new view \( \viREPL' \) still satisfies the atomic read.
                For similar reason, the new view for client \( \viCL' \) till satisfies atomic read.
                Therefore we have \( \viREPL', \viCL' \in \Views(\mkvsCOPS_{i+1}) \).

            \item \rl{GetTrans}
                Assume the client \( \cl \) of a replica \( \repl \) commits a read-only transaction \( \txid \).
                Since it is a read-only transaction, it suffice  to prove the following:
                \begin{gather}
                    \fora{\ke,j} 0 \leq j < \abs{ \mkvsCOPS_i(\ke) } \implies \txid \notin \RTx(\mkvsCOPS_{i}(\ke, j)) \label{equ:read-trans-unique} 
                \end{gather}
                \cref{lem:mono-local-time} implies \cref{equ:read-trans-unique}.
                Thus the new key-value store \( \mkvsCOPS_{i+1} \) satisfies the well-formed conditions.
                Now let consider the views.
                Since only the client view has changed, it is sufficient to  prove that \( \viCL' \in \Views(\mkvsCOPS_{i+1}) \), 
                where \( \viCL' \) is the new client.
                By \cref{lem:write-unique}, the new view \( \viCL' \) satisfies the atomic read constraint.
                Therefore \( \viCL' \in \Views(\mkvsCOPS_{i+1})  \).
        \end{itemize}
    \end{itemize}
\end{proof}

\begin{lemma}[Observe its own]
    \label{lem:repl-observe-own}
    \label{lem:cl-observe-own}
    A client observes all its own transactions, that is, for any key-value store \( \mkvsCOPS \) and view \( \viCL \):
    \[
        \fora{i,\ke, \val, \dep, \txid, \T, \txidCOPS{\stub}{\cl}{\stub}{\stub}} (\val, \txid, \T, \dep)  = \mkvsCOPS(\ke,i) 
        \land \txid = \txidCOPS{\stub}{\cl}{\stub}{\stub} 
        \lor \txidCOPS{\stub}{\cl}{\stub}{\stub} \in \T
        \implies i \in \viCL(\ke)
    \]
    Similarly, a replica observes all its own transactions.
\end{lemma}

\begin{lemma}[Unique writer]
    \label{lem:write-unique}
    Each version has a unique writer.
\end{lemma}
\begin{proof}
    Because a transaction can write to at most one key, then by \cref{lem:repl-observe-own} and the premiss of \rl{Put},
    we have the proof.
\end{proof}

\begin{lemma}[Monotonic local time]
    \label{lem:mono-local-time}
    Given a reduction step such that: 
    \[
        \mkvsCOPS, \viREPL, \viCL, \stk, \cmd {\toT{}}^* \mkvsCOPS', \viREPL', \viCL', \stk', \cmd'
    \]
    let \( \txidCOPS{\repl}{\cl}{n}{n'} \) be the new transaction, \ie \( \txidCOPS{\repl}{\cl}{n}{n'} \in \mkvsCOPS' \land  \txidCOPS{\repl}{\cl}{n}{n'} \notin \mkvsCOPS \).
    It implies the new transaction is greater than any transaction committed by the same client view \( \viCL \), \ie
    \[ 
        \txidCOPS{\repl}{\cl}{n''}{n'''} \in \mkvsCOPS \implies (n,\repl,n') > (n'', \repl, n''')
    \]
\end{lemma}
\begin{proof}
    We perform case analysis.
    \begin{itemize}
        \item \rl{Put}
            By the premiss of the rule, 
            the new transaction is in the form \( \txidCOPS{\repl}{\cl}{n}{0} \).
            By the \cref{lem:repl-observe-own} we have for any existing transaction \( \txidCOPS{\repl}{\cl}{n'}{\stub} \),
            \[
                \txidCOPS{\repl}{\cl}{n'}{\stub} \in \mkvsCOPS \implies n > n'
            \]
        \item \rl{GetTrans}
            Let \( \txidCOPS{\repl}{\cl}{n}{n'} \) be the new transaction.
            By the premiss we have that for any existing transaction \( \txidCOPS{\repl}{\cl}{n''}{n'''} \), 
            \[
                \txidCOPS{\repl}{\cl}{n''}{n'''} \in \mkvsCOPS \implies n = n'' \land n' > n'''
            \]
    \end{itemize}
\end{proof}


The dependency of a transaction \( \depOf{\mkvsCOPS, \txid} \) is defined as:
\begin{itemize}
    \item if \( \txid \) is a single-write transaction:
    \[
        \begin{rclarray}
            \depOf{\mkvsCOPS, \txid} & \defeq & 
            \begin{array}[t]{@{}l@{}}
                \dep  \ \text{where} 
                \exsts{\ke,j} \lastConf(\tr)\projection{1}(\ke,j) = (\stub, \txid, \stub, \dep)  \\
            \end{array}
        \end{rclarray}
    \]
    \item if \( \txid \) is a read-only transaction:
    \[
        \begin{rclarray}
            \depOf{\mkvsCOPS, \txid} & \defeq & 
            \begin{array}[t]{@{}l@{}}
                \bigcup_{\Setcon{\ver}{\exsts{\ke,j} \ver = \mkvsCOPS(\ke,j) \land \txid \in \RTx(\ver)}} \depOf{\ver} \\
            \end{array}
        \end{rclarray}
    \]
\end{itemize}

Given a trace \( \tr \), 
the function \( \func{maxVersion}{\tr, \txid} \) returns the version that the transaction \( \txid \) depends on
and is the last one begin reduced:
        \[
        \begin{rclarray}
            \func{maxVersion}{\tr, \txid} & \defeq & 
            \begin{array}[t]{@{}l@{}}
                \qquad \text{the \( \txid_i \) is the last one appears in \( \tr \) such that} \\
                \qquad (\ke',\txid_i) \in \depOf(\lastConf(\tr)\projection{1}, \txid) \land \txid_i \notin \mkvsCOPS_i \land  \txid_i \notin \mkvsCOPS_{i+1}
            \end{array}
        \end{rclarray}
    \]

A COPS's semi-normal trace is a trace \( \tr \) if it is in the form that
read-only transactions \( \txid_\rd \) directly follows its \( \func{maxVersion}{\tr, \txid_\rd} \) or another read-only transaction \( \txid_{\rd}' \) such that \( \func{maxVersion}{\tr, \txid_\rd}  =  \func{maxVersion}{\tr, \txid_{\rd}'}\).

Give two COPS's traces \( \tr \) and \( \tr' \), \( \mkvsCOPS \) being the final state of \( \tr \) and \( \mkvsCOPS' \) for \(\tr'\),
if the two traces are equivalent, if and only if,
\[ 
    \begin{array}{@{}l@{}}
    \fora{\txid,\f,\dep} \txid \in \mkvsCOPS
    \f = \func{RWset}{\txid,\mkvsCOPS} \land \dep =  \func{RWset}{\txid,\mkvsCOPS}
    \implies
    \txid \in \mkvsCOPS'
    \f = \func{RWset}{\txid',\mkvsCOPS} \land \dep =  \func{RWset}{\txid',\mkvsCOPS}
    \end{array}
\]
where \( \func{RWset}{\txid,\mkvsCOPS} \) is the read-write set of \( \txid \).
Note that \( \func{RWset}{.} \) is well-defined by \cref{thm:cops-key-value-well-form}.

\begin{corollary}
    \label{lem:cops-semi-normal-trace}
    \label{cor:cops-semi-normal-trace}
    For any COPS's trace \( \tr \), there exists a equivalent semi-normal trace \( \tr' \) 
    such that \( \lastConf(\tr) = \lastConf(\tr') \).
\end{corollary}
\begin{proof}
    It is easy to prove by induction on the numbers of read-only transactions that are not in the wanted position.
    Let take the first one for those read-only transactions \( \txid_\rd \) who does not follows its \( \func{maxVersion}{\tr, \txid_i} \).
    It is safe to move the reduction step to the right in the trace,
    until it directly follows its \( \func{maxVersion}{\tr, \txid_\rd} \) or another read-only transaction \( \txid_{\rd}' \) such that \( \func{maxVersion}{\tr, \txid_\rd}  =  \func{maxVersion}{\tr, \txid_{\rd}'}\). 
\end{proof}

A COPS's normal trace is a trace \( \tr \) if it is semi-normal trace and the single-write transactions commit in the same order of the transaction identifiers.

\begin{theorem}[normal trace]
    \label{thm:cops-normal-trace}
    \label{lem:cops-normal-trace}
    \label{cor:cops-normal-trace}
    For any COPS's trace \( \tr \), there exists a equivalent normal trace \( \tr' \) such that
\end{theorem}
\begin{proof}
    By \cref{cor:cops-semi-normal-trace}, let consider a semi-normal trace \( \tr \).
    It is easy to prove by induction on the single-write transactions that are out of order.
    Let take the first single-write transaction \( \txid = \txid{\repl}{\cl}{n}{n'} \) that is out of order.
    Suppose it is the i-\emph{step}.
    Assume \( \txid \) write to key \( \ke \) with value \( \val \).
    Assume the preview write-only transaction \( \txid'  = \txid{\repl'}{\cl'}{n''}{n'''} \) and it follows \( (n,\repl,n') < (n'', \repl', n''') \).
    It means if a view \( \vi \) includes both \( \txid \)  and \( \txid' \), and if \( \txid' \) also write to the same key \( \ke \) with value \( \val' \), the \( \vi \) will fetch the value from \( \txid' \):
    \begin{equation}
        \label{equ:out-order-wrte-older-value}
        \func{getMax}{\mkvsCOPS_i,\vi}(\ke) = \val'
    \end{equation}
    The intuition here is to swap the reduction steps of these two transactions and those read-only transactions following them.
    We assume \( \txid \)  and \( \txid' \) write to the same key, otherwise it is safe to swap.
    For any read-only transactions \( \txid_{\rd} \in \T_{\rd} \) following \( \txid \), we knows \( \txid' \notin \depOf(\mkvsCOPS_i, \txid_{\rd}) \), otherwise it violate \( \func{maxVersion}{\tr, \txid_\rd} = \txid \).
    Thus it is safe to swap the reduction steps.
\end{proof}


\begin{corollary}
    \label{cor:get-max-to-get-snap}
    For the \rl{Put} and \rl{GetTrans}, it is safe to replace the function \( \func{getMax}{.} \) with the function \( \getSN{.} \).
\end{corollary}
\begin{proof}
    By \cref{thm:cops-normal-trace}, each trace \( \tr \) has an equivalent normal trace \( \tr' \).
    Assume i-\emph{th} step in the trace \( \tr' \).
    Assume the key-value store before is \( \mkvsCOPS_i \).
    For any versions \( m \) and \( j \) from the same key in the \( \tr' \):
    \[
        0 < m < j < \abs{\mkvsCOPS_i(\ke)} \implies \WTx(\mkvsCOPS_i(\ke,m)) <  \WTx(\mkvsCOPS_i(\ke,j))
    \]
    thus it is safe to use \( \getSN{.} \).
\end{proof}

Given \cref{thm:cops-key-value-well-form} and \cref{cor:get-max-to-get-snap}, for any COPS's trace \( \tr \), 
there exists a trace \( \tr' \) that is a normal trace and satisfies \( \ET_\top \).

\begin{theorem}[COPS satisfying causal consistency]
    \label{thm:cops-cc}
    Given a trace starting from the initial key-value store \( \mkvsCOPS_0 \), initial views \( \viewFunCOPS_0 \) and some programs \( \prog_0 \), for any \( \mkvsCOPS_i \) and \( \viewFunCOPS_i \)  such that: 
    \[
        \mkvsCOPS_i, \viewFunCOPS_i, \thdenv_i, \prog_i \toG{\viCL,\f} \mkvsCOPS_{i+1}, \viewFunCOPS_{i+1}, \thdenv_{i+1}, \prog_{i+1} 
    \]
    then the i-\emph{th} step satisfies \( \ET_\CC \), \ie
    \[
        \ET_\CC \vdash ( \mkvsCOPS_i, \viCL ) \csat \f : \viewFunCOPS_{i+1}(\cl)
    \]
\end{theorem}
\begin{proof}
    We introduce an invariant \( I \) on the view of client that if the view includes a version, 
    it also includes all the version it depends on, that is,
    \[
        \begin{array}{@{}l@{}}
        \fora{\cl, \viCL,\ke,\ke',j,m,\dep} \\
        \quad \viCL = \viewFunCOPS_i(\cl) \land j \in \viCL(\ke') 
        \land (\stub,\stub,\stub,\dep) = \mkvsCOPS_i(\ke,j)
        \land (\ke',\WTx(\mkvsCOPS_i(\ke',m))) \in \dep \\
        \qquad \implies m \in \viCL(\ke')
        \end{array}
    \]
    Since \( \ET_\CC = \ET_\MRd \cap \ET_\MW \cap \ET_\RYW \cap \ET_\WFR \), we prove the four constraints separately.
    In each case we need to consider \rl{Put} and \rl{GetTrans}.
    \begin{itemize}
        \item \( \ET_\MRd \). 
            It is easy to see \( \viCL \viewleq \viewFunCOPS_{i+1}(\cl) \).

        \item \( \ET_\MW \).
            By \cref{lem:cops-dep} and the invariant, we have to proof.
            Now we need to re-establish the invariant \( I_{i+1} \).
            \begin{itemize}
                \item 
                For \rl{GetTrans}, the client \( \cl \) commits a read-only transaction.
                By the premiss of the rule, the new view \( \viewFunCOPS_{i+1}(\cl) \) satisfies the invariant.
                \item For \rl{Put}, the new view \( \viewFunCOPS_{i+1}(\cl) = \viCL\rmto{\ke}{j} \),
                where the new version \( \mkvsCOPS_{i+1}(\ke,j)\) is written by the client \( \cl \).
                Let \( \dep \) be the dependency for the new view, \ie \( \dep = \depOf(\mkvsCOPS_{i+1}(\ke,j)) \).
                By the premiss, the \( \dep \) includes all version included in \( \viCL \), 
                therefore the invariant has been preserved.
            \end{itemize}

        \item \( \ET_\RYW \). Let consider two cases:
            \begin{itemize}
                \item 
                For \rl{GetTrans}, the client \( \cl \) commits a read-only transaction.
                By \cref{lem:cl-observe-own} and  \( \viCL \viewleq \viewFunCOPS_{i+1}(\cl) \),
                we have the prove.
            \item For \rl{Put}, the new view \( \viewFunCOPS_{i+1}(\cl) = \viCL\rmto{\ke}{j} \),
                where the new version \( \mkvsCOPS_{i+1}(\ke,j)\) is written by the client \( \cl \).
                Then by \( \viCL \viewleq \viewFunCOPS_{i+1}(\cl) \), we have the proof.
            \end{itemize}

        \item \( \ET_\WFR \).
            By \cref{lem:cops-dep} and the invariant, we have to proof.
            Now we need to re-establish the invariant \( I_{i+1} \).
            \begin{itemize}
                \item 
                For \rl{GetTrans}, the client \( \cl \) commits a read-only transaction.
                By the premiss of the rule, the new view \( \viewFunCOPS_{i+1}(\cl) \) satisfies the invariant.
                \item For \rl{Put}, the new view \( \viewFunCOPS_{i+1}(\cl) = \viCL\rmto{\ke}{j} \),
                where the new version \( \mkvsCOPS_{i+1}(\ke,j)\) is written by the client \( \cl \).
                Let \( \dep \) be the dependency for the new view, \ie \( \dep = \depOf(\mkvsCOPS_{i+1}(\ke,j)) \).
                By the premiss, the \( \dep \) includes all version included in \( \viCL \), 
                therefore the invariant has been preserved.
            \end{itemize}
    \end{itemize}
\end{proof}

\begin{lemma}
    \label{lem:cops-dep}
    Given the initial key-value store \( \mkvsCOPS_0 \), initial views \( \viewFunCOPS_0 \) and some programs \( \prog_0 \), for any \( \mkvsCOPS_i \) and \( \viewFunCOPS_i \)  such that: 
    \[
        \mkvsCOPS_0, \viewFunCOPS_0, \thdenv_0, \prog_0 {\toG{}}^* \mkvsCOPS_i, \viewFunCOPS_i, \thdenv_i, \prog_i 
    \]
    for any versions \( ( \val,\txid,\T,\dep ) = \mkvsCOPS_i(\ke,j) \) and \( ( \val',\txid',\T',\dep' ) = \mkvsCOPS_i(\ke',m) \), if \( \txid \) depends on \( \txid' \), \ie
    \[
        \begin{array}{@{}l@{}}
            \txid' \toEdge{\SO ?} \txid
            \lor \exsts{\txid''}
            \txid'' \in \T' \land
            \txid'' \toEdge{\SO ?} \txid
        \end{array}
    \]
    then \( \txid' \) and \( \dep' \) is in the dependency \( \dep \), \ie
    \[
        (\stub, \txid') \in \dep \land \dep' \subseteq \dep
    \]
\end{lemma}
\begin{proof}
    We prove by induction on the length of trace \( i \).
    \begin{itemize}
        \item 
        \caseB{\(i = 0\)}
        It trivially holds.
        \item  
        \case{\( i > 0 \)}
        Suppose \( \mkvsCOPS_i \) satisfies the property, let consider the next key-value store \( \mkvsCOPS_{i+1}\).
        We perform case analysis.
        \begin{itemize}
            \item 
            \rl{Put}.
            Assume a client \( \cl \) commit a new transaction \( \txid \) that installs a new version to key \( \ke \).
            Assume the initial view for the client is \( \viCL \).
            In the new key-value store \( \mkvsCOPS_{i+1} \), for versions other than \( \mkvsCOPS_{i+1}(\ke, \abs{\mkvsCOPS_{i+1}} - 1 ) \), they still satisfy the property by \ih
            By \cref{lem:cl-observe-own}, it follows that for any preview transaction from the same client \( \txid' \):
            \[
                \begin{array}{@{}l@{}}
                    \txid' \toEdge{\SO ?} \txid
                    \lor \exsts{\txid''}
                    \txid'' \in \T' \land
                    \txid'' \toEdge{\SO ?} \txid
                \end{array}
            \]
            the version written by the transaction \( \txid' \) is included in the view \( \viCL \).
            By the premiss of \rl{Put} that how the new \( \dep \) is constructed, we have proof.

            \item 
            \rl{GetTrans}.
            Since it only commits a read-only transaction, 
            the \( \mkvsCOPS_{i+1} \)  satisfies the property by \ih
        \end{itemize}
    \end{itemize}
\end{proof}

%\begin{theorem}[COPS satisfy parallel snapshot isolation]
    %For any COPS's trace \( \tr \) starting from the initial key-value store \( \mkvsCOPS_0 \), initial views \( \viewFunCOPS_0 \) and some programs \( \prog_0 \), 
    %there exists an equivalent trace \( \tr' \) where \( \mkvsCOPS'_i \) and \( \viewFunCOPS'_i \)  such that: 
    %\[
        %\mkvsCOPS'_i, \viewFunCOPS'_i, \thdenv'_i, \prog'_i \toG{\viCL',\f'} \mkvsCOPS'_{i+1}, \viewFunCOPS'_{i+1}, \thdenv'_{i+1}, \prog'_{i+1} 
    %\]
    %then the i-\emph{th} step satisfies \( \ET_\PSI \), \ie
    %\[
        %\ET_\PSI \vdash ( \mkvsCOPS'_i, \viCL' ) \csat \f' : \viewFunCOPS'_{i+1}(\cl)
    %\]
%\end{theorem}
%\begin{proof}
    %By \cref{thm:cops-cc}, we already the trace \( \tr \) satisfying \( \ET_\CC \).
    %It is sufficient to construct the trace \( \tr' \) so that 
    %\( \ET_\PSI \vdash ( \mkvsCOPS'_i, \viCL' ) \csat \f' : \viewFunCOPS'_{i+1}(\cl) \) since \( \ET_\PSI = \ET_\CC \cap \ET_\UA\).
    %We inductively alter all single-write transactions \( \txid \) that 
    %does not start with a view containing all the versions for the key the transactions \( \txid \) want to write.
    %Initially let \( \tr' = \tr \).
    %Let pick the first single-write transaction \( \txid \), assuming it is i-\emph{step}, 
    %who installs a version \( \mkvsCOPS_{i+1}(\ke,j) = (\val,\txid,\T,\dep )\) with a initial view \( \viCL \) does not contain all versions \( \mkvsCOPS_i(\ke,m) \)
    %for some key \( \ke \), client \( \cl \) and index \( m \) and \( j \).
    %Since \( \txid \) is the first transaction does not contain all versions \( \mkvsCOPS_i(\ke,m) \),
    %it means the view \( \viCL \) does not include only the last version \( \mkvsCOPS_i(\ke,j-1) \).
    %Suppose the version \( \mkvsCOPS_i(\ke,j-1) = (\val',\txid',\T',\dep' ) \) for some transaction \( \txid' \).
    %Note that \( \txid' \)  and \( \txid \) comes from different client, otherwise it violate \( \ET_\RYW \).
    %Thus let assume the initial view for \( \txid' \) is \( \viCL[\cl'] \) for client \( \cl' \) such that \( \cl' \neq \cl \).
    %We performance case analysis as the following.
    %\begin{itemize}                                                               
        %\item Suppose \( \depOf(\txid') \subseteq \depOf(\txid_\rd) \), for all read-only transactions \( \txid_\rd \in \T \).
            %It means it is safe to include \( j-1 \) version into \( \viCL \),
            %\ie the new initial view for \( \txid \) is \( \viCL' = \viCL\rmto{\ke}{j-1} \).
            %Given that, all the initial views for the read-only transactions \( \txid_\rd \in \T \) also include \( \mkvsCOPS(\ke,j) \).
            %Yet because \( \depOf(\txid') \subseteq \depOf(\txid_\rd) \), the version \(\mkvsCOPS(\ke,j)  \) is already in the initial view of \( \txid_\rd \).
            %By the new initial view \( \viCL' \), it is easy to see 
            %\( \ET_\UA \vdash (\mkvsCOPS_i, \viCL') \csat \Set{(\otW, \ke, \val)}, \viCL'' \).
        %\item there exists a read-only transaction \( \txid_\rd \in \T \) such that 
              %\( \depOf(\txid') \not\subseteq \depOf(\txid_\rd) \).
              %\begin{itemize}
                  %\item If it is safe to include \( \depOf(\txid') \) into \( \depOf(\txid_\rd) \), consequently changing the initial for \( \txid_\rd \), for all read-only transactions \( \txid_\rd \in \T \), then we are back to the first case.
                  %\item If there exists a read-only transaction \( \txid_\rd \) that is not safe to include \( \depOf(\txid') \).
                      %That is, there exists a single-write transaction  \( \txid'' \) who installs a version \( \mkvsCOPS_i(\ke',x)\) for a key \( \ke' \) and a index \( x \) and the \( \txid_\rd \) read this version.
                      %Given that it is not safe for  \( \depOf(\txid_\rd) \) to includes \( \depOf(\txid') \), 
                      %there exists anther version \( \mkvsCOPS_i(\ke',y) \) for the same key \( \ke' \) and a index \( y \) such that \( y > x \).
                      %It follows 
                      %\[ 
                        %\depOf{\mkvsCOPS_i(\ke',x)} \subseteq \depOf{\mkvsCOPS_i(\ke',y) \subseteq \depOf{\txid'} } 
                      %\]
                      %therefore 
                      %\[
                          %\fora{\txid'_\rd \in \T'} \depOf{\mkvsCOPS_i(\ke',x)} \subseteq \depOf{ \txid'_\rd}
                      %\]
            %\end{itemize}
    %\end{itemize}
%\end{proof}



