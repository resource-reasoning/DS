\subsection{semantics}
Let \( \repl \in \Repls \) denotes the set of totally ordered replicates.
Each replicate can have multiple clients, and 
each clients can commit a sequence of either read-only transitions or single-write transactions.
To model these, we annotate the transaction identifier with replicate \( \repl \), client \( \cl \), 
local time of the replicate \( n \) and read-only transactions count \( n' \), \ie \( \txidCOPS{\repl}{\cl}{n}{n'} \).
Note that the \( (n, \repl, n') \) can be treated as a single number that \( n \) are the higher bits, 
\( \repl \) the middle bits and \( n' \) the lower bits.
There is a total order among transitions from the same replica and from the same client.
We extend version with the set of all versions it dependencies on, \( \dep \in \pset{\Keys \times \TxID} \).
The function \( \depOf{\ver} \) denotes the dependencies set of the version.
For readability, we annotate view with either a replica, \( \viREPL \), or a client, \( \viCL \).
The view environment is extended with replicas and their views, \( \viewFunCOPS : (\Repls \times \ClientID ) \parfinfun \Views \).
We give the following semantics to capture the behaviours of the code.

\begin{lstlisting}[caption={put},label={lst:simplified-put}]
// mixing the client API and system API
put(repl,k,v,ctx) {

    // Dependency for previous reads and writes
    deps = ctx_to_dep(ctx);(*\label{line:put-ctx-to-deps}*)

    atomic{
        // increase local time.
        inc(repl.local_time);(*\label{line:put-inc-local}*) 

        // appending local kv with a new version.
        list_isnert(repl.kv[k],(v, (local_time + id), deps));(*\label{line:put-update-kv}*)
    }

    // update dependency for writes
    ctx.writers += (k,(local_time + id),deps);(*\label{line:put-update-ctx}*)

    // put in the queue to sync with other replicas
    enqueue(k,v,(current_ver+id),(deps ++ vers));
}
\end{lstlisting}

The client always fetches the version with the maximum writer it can observed for each key,
Which is computed by \( \funcn{getMax} \) function. 
It is different from \( \snapshot \) as \( \snapshot \) fetches the latest version with respect to the position in the list.

\[
    \begin{rclarray}
        \func{getMax}{\mkvsCOPS, \viCL} & \defeq &
        \lambda \ke \ldotp \left( \max_\txid\Setcon{(\val, \txid, \T, \dep)}{\exsts{i} (\val, \txid, \T, \dep) = \mkvsCOPS(\ke, i)} \right)\projection{1}
    \end{rclarray}
\]
\begin{mathpar}
    \inferrule[Put]{%
        ( \stk, \func{getMax}{\mkvsCOPS, \viCL}, \emptyset ), \pmutate{\ke}{\vx} \toL
        ( \stk', \stub, \Set{(\otW, \ke, \val )} ), \pskip
        \\\\
        \dep = \Setcon{(\ke', \txid)}{\exsts{i} i \in \viCL(\ke') \land \txid = \WTx(\mkvsCOPS(\ke', i))} \texttt{ ---> \cref{lst:simplified-put}, \cref{line:put-ctx-to-deps}} 
        \\\\
        \txid = \min\Setcon{%
        \txidCOPS{\repl}{\cl}{n'}{0}
        }{%
            \fora{\ke', i \in \viREPL(\ke'), n} \\
            \quad \txidCOPS{\stub}{\stub}{n}{\stub} = \WTx(\mkvsCOPS(\ke',i)) \\
            \qquad {} \implies n' > n 
        } \texttt{ ---> \cref{lst:simplified-put}, \cref{line:put-inc-local}}
        \\\\
        \mkvsCOPS' = \mkvsCOPS\rmto{\ke}{\mkvsCOPS(\ke) \lcat \List{(\ke, \txid, \emptyset, \dep)}} \texttt{ ---> \cref{lst:simplified-put}, \cref{line:put-update-kv}}
        \\\\
        \viREPL' = \viREPL\rmto{\ke}{\viREPL(\ke) \uplus \Set{\abs{\mkvsCOPS'(\ke)} - 1}} \texttt{ ---> \cref{lst:simplified-put}, \cref{line:put-update-kv}}
        \\\\
        \viCL' = \viCL\rmto{\ke}{\viREPL(\ke) \uplus \Set{\abs{\mkvsCOPS'(\ke)} - 1}} \texttt{ ---> \cref{lst:simplified-put}, \cref{line:put-update-ctx}}
    }{%
    \repl, \cl \vdash 
    \mkvsCOPS, \viREPL, \viCL, \stk, \ptrans{\pmutate{\ke}{\vx};} \toT{}
    \mkvsCOPS', \viREPL', \viCL', \stk', \pskip
    }
\end{mathpar}
The \verb|get_trans| fetches the latest versions from the replica via multiple atomic reads, one for each key.
As a result, a client has a list of candidates \verb|rst|.
Since interleaving might happen, versions might become out-of-date because the replicate receives new versions.
It is not a problem to read old versions as long as they satisfy causal consistency,
\ie if a client read a version \( \ver \), it should at least read all the versions that \( \ver \) depends on.
Thus the algorithm use \verb|ccv| to track the maximum versions the client should fetches,
and re-fetches the \verb|ccv[k]| version from the replica if it is greater than the candidate.

The following is a simplified algorithm by directly taking a list of versions \verb|ccv| satisfies causal consistency constraint,
and then read the versions indicated by \verb|ccv|.
The simplified algorithm is easier to understand.
\begin{lstlisting}[caption={get\_trans},label={lst:get-trans}]
// A simplified version by guessing
// a ccv satisfying dependency constraints
// and then read versions indicated by ccv.
// Note that it is a weaker version of the original code,
// as the original implementation fetches the latest versions
// for keys by a sequence of atomic get_by_version calls
List(Val) get_trans(ks,ctx) {
    take ccv: (*$\forall$*) k (*$\in$*) ks.(*\label{line:get-trans-ccv-1}*)
        (_,_,deps) := get_by_version(k,ccv[k]) (*${}\land \forall$*) dep (*$\in$*) deps.(*\label{line:get-trans-ccv-2}*)
            dep.key (*$\in$*) ks (*$\implies$*) ccv[dep.key] >= dep.ver (*\label{line:get-trans-ccv-3}*)

    for k in ks(*\label{line:get-trans-read-1}*)
        rst[k] = get_by_version(k,ccv[k]);(*\label{line:get-trans-read-2}*)

    // update the ctx
    for (k,ver,deps) in rst(*\label{line:get-trans-update-ctx-1}*)
        ctx.readers += (k,ver,deps);(*\label{line:get-trans-update-ctx-2}*)

    return to_vals(ks);
}                                   
\end{lstlisting}
\begin{mathpar}
    \inferrule[GetTrans]{%
        \viCL \viewleq \viCL' \viewleq \viREPL  \texttt{ ---> \cref{lst:get-trans}, \cref{line:get-trans-update-ctx-1,line:get-trans-update-ctx-2}}
        \\\\
        {\left(\begin{array}{@{}l@{}}
        \fora{i : 1 \leq i \leq j, \ke', m, \ver}  \\
        \quad \ver = \mkvsCOPS(\ke_i, \max(\viCL'(\ke_i)) \land {} \\
        \quad (\ke', \WTx(\mkvsCOPS(\ke', m))) \in \ver\projection{4} \\
        \qquad {} \implies m \in \viCL'(\ke')
        \end{array}\right)} \texttt{ ---> \cref{lst:get-trans}, \cref{line:get-trans-ccv-1,line:get-trans-ccv-2,line:get-trans-ccv-3}}
        \\\\
        \trans =  \pderef{\vx_1}{\ke_1}; \dots; \pderef{\vx_j}{\ke_j};
        \\\\
        ( \stk, \func{getMax}{\mkvsCOPS, \viCL'}, \emptyset ), \trans \toL
        ( \stk', \stub, \f ), \pskip \texttt{ ---> \cref{lst:get-trans}, \cref{line:get-trans-read-1,line:get-trans-read-2}}
        \\\\
        \txidCOPS{\repl}{\cl}{n'}{n} = \max\Setcon{\txidCOPS{\repl}{\cl}{z'}{z}}{\txidCOPS{\repl}{\cl}{z'}{z} \in \mkvsCOPS }
        \\
        \mkvsCOPS' = \updKV{\mkvsCOPS, \viCL', \txidCOPS{\repl}{\cl}{n'}{n+1}, \f} 
    }{%
        \repl, \cl \vdash 
        \mkvsCOPS, \viREPL, \viCL, \stk, \ptrans{\pderef{\vx_1}{\ke_1}; \dots; \pderef{\vx_j}{\ke_j}; } \toT{}
        \mkvsCOPS', \viREPL, \viCL', \stk', \pskip
    }
    \and
    \inferrule[ClientCommit]{%
        \repl, \cl \vdash 
        \mkvsCOPS, \viewFunCOPS(\repl), \viewFunCOPS(\cl), \stk, \prog(\cl) \toT{}
        \mkvsCOPS', \viREPL', \viCL', \stk', \cmd'
    }{%
        \mkvsCOPS, \viewFunCOPS, \thdenv, \prog \toG{}
        \mkvsCOPS', \viewFunCOPS\rmto{\repl}{\viREPL'}\rmto{\cl}{\viCL'}, \thdenv\rmto{\cl}{\stk'}, \prog\rmto{\cl}{\cmd'}
    }
\end{mathpar}
A replica updates its local state only if all the dependencies has been receive.
\begin{lstlisting}[caption={Send and receive},label={lst:send-receive}]
// Syn to other replicas
send() {
    (k,v,ver,deps) := dequeue();
    for id in repls {
        send (k,v,ver,deps) to id;
    }
}

// receive a write message from other replica
on_receive(k,v,ver,deps) {
    // for a single machine
    // the following check immediately holds
    for (k',ver') in deps {
        wait until dep_check(k',ver');(*\label{line:receive-wait}*)
    }

    atomic{
        list_isnert(kv[k],(v,ver,deps));(*\label{line:receive-update-view-1}*)
        (remote_local_time + id) = ver;(*\label{line:receive-update-view-2}*)
        local_time = max(remote_local_time, local_time);(*\label{line:receive-update-view-3}*)
    }
}
\end{lstlisting}
\begin{mathpar}
    \inferrule[sync]{%
        \viREPL = \viewFunCOPS(\repl)\rmto{\ke}{\viewFunCOPS(\repl)(\ke) \uplus i} 
        \texttt{ ---> \cref{lst:send-receive}, \cref{line:receive-update-view-1,line:receive-update-view-2,line:receive-update-view-3}}
        \\\\
        {\left(\begin{array}{@{}l@{}}
        \fora{\ke', m, \ver} 
        \ver = \mkvsCOPS(\ke, i) \land {} \\
        \quad (\ke', \WTx(\mkvsCOPS(\ke', m))) \in \ver\projection{4} \\
        \qquad {} \implies m \in \viREPL'(\ke') 
        \end{array}\right)} \texttt{ ---> \cref{lst:send-receive}, \cref{line:receive-wait}} 
    }{%
        \mkvsCOPS, \viewFunCOPS, \thdenv, \prog \toG{}
        \mkvsCOPS, \viewFunCOPS\rmto{\repl}{\viREPL}, \thdenv, \prog
    }
\end{mathpar}

A view \( \vi \) on key-value store \( \mkvsCOPS \) \emph{agrees} 
with another view \( \vi \) on another key-value store \( \mkvsCOPS' \), if and only
\[
 \func{getMax}{\mkvsCOPS, \vi} = \func{getMax}{\mkvsCOPS', \vi'}
\]



%\begin{theorem}
    %For any trace \( \tr \) of COPS with final configuration \( (\mkvsCOPS, \viewFunCOPS) \), 
    %there exists a trace \( \tr' \) with final configuration \( (\mkvsCOPS', \viewFunCOPS') \) such that 
    %each step of the trace \( \tr' \) commits a transaction with strictly greater transaction identifier than any one appearing in the key-value store:
    %\[
        %\begin{array}{@{}l@{}}
        %(\mkvsCOPS_i, \viewFunCOPS_i) 
        %\toG{} (\mkvsCOPS_{i+1}, \viewFunCOPS_{i+1}) 
        %\land \exsts{\txid} \txid \in \mkvsCOPS_{i+1} 
        %\land \txid \notin \mkvsCOPS_{i+1}
        %\implies \fora{\txid' \in \mkvsCOPS_i} \txid > \txid'
        %\end{array}
    %\]
    %and any replica's view from \( \viewFunCOPS \) agrees with its counterpart from  \( \viewFunCOPS' \):
    %\[
        %\fora{i} 
        %\func{getMax}{\mkvsCOPS, \viewFunCOPS(i)} = \func{getMax}{\mkvsCOPS', \viewFunCOPS'(i)}
    %\]
%\end{theorem}
%\begin{proof}
%\end{proof}

%\begin{lemma}
%\[
    %\begin{array}{@{}l@{}}
    %\fora{\repl, \cl, \mkvsCOPS, \mkvsCOPS', \mkvsCOPS'', \viREPL, \viREPL', \viREPL'', \viCL, \viCL', \viCL'', \stk, \stk', \cmd, \cmd'} \\
    %\quad \func{getMax}{\mkvsCOPS, \viREPL} = \func{getMax}{\mkvsCOPS'', \viREPL''} 
    %\land \func{getMax}{\mkvsCOPS, \viCL} = \func{getMax}{\mkvsCOPS'', \viCL''} \\
    %\qquad \repl, \cl \vdash 
    %\mkvsCOPS, \viREPL, \viCL, \stk, \cmd \toT{}
    %\mkvsCOPS', \viREPL', \viCL', \stk', \cmd' \\
    %\qquad \implies 
    %\exsts{\mkvsCOPS''', \viREPL'''}
    %\mkvsCOPS'', \viREPL'', \viCL'', \stk, \cmd \toT{}
    %\mkvsCOPS''', \viREPL''', \viCL', \stk', \cmd' \\
    %\qquad \func{getMax}{\mkvsCOPS', \viREPL'} = \func{getMax}{\mkvsCOPS''', \viREPL'''} 
    %\land \func{getMax}{\mkvsCOPS', \viCL'} = \func{getMax}{\mkvsCOPS''', \viCL'''} \\
    %\end{array}
%\]
%\end{lemma}
%\begin{proof}
%We perform case analysis.
%\begin{itemize}
    %\item \rl{Put}.
    %We have \( \cmd \equiv \ptrans{\pmutate{\ke}{\vx};} \) for some key \( \ke \) and variable \( \vx \).
    %Suppose key-value stores \(  \mkvsCOPS, \mkvsCOPS', \mkvsCOPS'' \), 
    %replica's views \( \viREPL, \viREPL', \viREPL''\) and client's views \( \viCL, \viCL', \viCL''\) such that
    %\[
    %\begin{array}{@{}l@{}}
    %\func{getMax}{\mkvsCOPS, \viREPL} = \func{getMax}{\mkvsCOPS'', \viREPL''} 
    %\land \func{getMax}{\mkvsCOPS, \viCL} = \func{getMax}{\mkvsCOPS'', \viCL''} \\
    %\qquad \repl, \cl \vdash 
    %\mkvsCOPS, \viREPL, \viCL, \stk, \cmd \toT{}
    %\mkvsCOPS', \viREPL', \viCL', \stk', \cmd' \\
    %\end{array}
    %\]
    %By the premiss of the \rl{Put} rule, the new key-value store
    %\[
        %\mkvsCOPS' = \mkvsCOPS\rmto{\ke}{\mkvsCOPS(\ke) \lcat \List{(\ke, \txid, \emptyset, \dep)}}
    %\]
    %where
    %\[
        %\txid = \min\Setcon{%
            %\txidCOPS{\repl}{\cl}{n'}{0}
        %}{%
            %\fora{\ke', i \in \viREPL(\ke'), n} \\
            %\quad \txidCOPS{\stub}{\stub}{n}{\stub} = \WTx(\mkvsCOPS(\ke',i)) \\
            %\qquad {} \implies n' > n 
        %} 
    %\]
    %and the new views of replica and client are
    %\[   
        %\begin{array}{@{}l@{}}
        %\viREPL' = \viREPL\rmto{\ke}{\viREPL(\ke) \uplus \Set{\abs{\mkvsCOPS'(\ke)} - 1}} \\
        %{} \land \viCL' = \viCL\rmto{\ke}{\viREPL(\ke) \uplus \Set{\abs{\mkvsCOPS'(\ke)} - 1}}
        %\end{array}
    %\]
    %Similarly there exists a new \( \mkvsCOPS''' \) by committing a single-write transaction \( \txid' \) and two new views \( \viREPL''' \) and \( \viCL''' \).
    %This means for those key \( \ke' \) that is different from the key \( \ke \) being overwritten,
    %\begin{equation}
        %\label{equ:get-max-match-all-other-key}
        %\begin{array}{@{}l@{}}
            %\func{getMax}{\mkvsCOPS', \viREPL'}(\ke') = \func{getMax}{\mkvsCOPS''', \viREPL'''}(\ke') \\
            %{} \land \func{getMax}{\mkvsCOPS', \viCL'}(\ke') = \func{getMax}{\mkvsCOPS''', \viCL'''}(\ke') 
        %\end{array}
    %\end{equation}
    %Note that the \( \txid \) is greater than any writers \( \txidCOPS{\repl}{\cl}{n'}{0} \) that can be observed by the \( \viREPL \), so is \( \txid' \).
    %That is,
    %\begin{equation}
        %\label{equ:get-max-match-overwritten-key}
        %\begin{array}{@{}l@{}}
            %\func{getMax}{\mkvsCOPS', \viREPL'}(\ke) = \stk(\vx) = \func{getMax}{\mkvsCOPS''', \viREPL'''}(\ke)  \\
            %{} \land \func{getMax}{\mkvsCOPS', \viCL'}(\ke) = \stk(\vx) = \func{getMax}{\mkvsCOPS''', \viCL'''}(\ke) 
        %\end{array}
    %\end{equation}
    %Combine \cref{equ:get-max-match-all-other-key} and \cref{equ:get-max-match-overwritten-key},
    %we have the proof.

    %\item \rl{GetTrans}.
    %Since the views of replica remain unchanged, so we only need to prove that there exists a new key-value store and a new view \( \viCL''' \) such that
    %\[
        %\func{getMax}{\mkvsCOPS', \viCL'}(\ke) = \stk(\vx) = \func{getMax}{\mkvsCOPS''', \viCL'''}(\ke) 
    %\]
    
%\end{itemize}
%\end{proof}

\begin{lemma}
    \label{lem:client-subset-repl}
    The view of a client is subset of the view of the replica that the client interacts with.
\end{lemma}


\begin{lemma}
    Let ignore the dependencies of versions from \( \mkvsCOPS \).
    Given the initial key-value store \( \mkvsCOPS_0 \), initial views \( \viewFunCOPS_0 \) and some programs \( \prog_0 \), for any \( \mkvsCOPS_i \) and \( \viewFunCOPS_i \)  such that: 
    \[
        \mkvsCOPS_0, \viewFunCOPS_0, \thdenv_0, \prog_0 {\toG{}}^* \mkvsCOPS_i, \viewFunCOPS_i, \thdenv_i, \prog_i
    \]
    The key-value store \( \mkvsCOPS_i \) satisfies the \cref{def:mkvs} and any replica or client view \( \vi \) from \( \viewFunCOPS_i \) is a valid view of the key-value store, \ie \( \vi \in \Views(\mkvsCOPS_i) \).
\end{lemma}
\begin{proof}
    We need to prove the  \( \mkvsCOPS_i \) satisfies the well-formed conditions,
    and any view \( \vi_i \Views(\mkvsCOPS_i) \).
    We prove it by introduction on the length \( i \).
    \begin{itemize}
    \item \caseB{\(i = 0\)}
        It holds trivially since each key only has the initial version \( (\val_0,\txid_0,\emptyset, \emptyset) \).
        Since there is only the initial version for each key, it is easy to see that any view \( \vi_0 \) satisfying the well-formed conditions in \cref{def:views}.
    \item \caseI{\(i > 0\)}
        Suppose it holds when \( i \), let consider \( i + 1 \).
        We perform case analysis on the possible next step:
        \begin{itemize}
            \item \rl{Put}
                Assume the client \( \cl \) of a replica \( \repl \) commits a single-write transaction \( \txid \) that installs a new version for key \( \ke \).
                By the premiss of \rl{Put}, the new transaction identifier \( \txid = \txidCOPS{\repl}{\cl}{n'}{0} \) where for some \( n' \) that is greater than any \( n \) from any writers \( \txidCOPS{\stub}{\stub}{n}{\stub} \) that are observable by the replica \( \repl \).
                Since the new transaction \( \txid = \txidCOPS{\repl}{\cl}{n'}{0} \) is a single-write transaction which is always installed at the end of the list associated to \( \ke \), it is sufficient to prove the following:
                \begin{gather}
                    \fora{j} 0 \leq j < \abs{ \mkvsCOPS_i(\ke) } \implies \WTx(\mkvsCOPS_{i}(\ke, m)) \neq \txid \label{equ:write-trans-unique} \\
                    \fora{j, n} \txidCOPS{\repl}{\cl}{n}{\stub} \in \Set{\WTx(\mkvsCOPS_{i}(\ke,j))} \cup \RTx(\mkvsCOPS_{i}(\ke, j)) \implies n < n' \label{equ:replica-time-monotonic-inc}
                \end{gather}
                By \cref{lem:repl-observe-own}, we know that for any version written \( \ver = \mkvsCOPS_i(\ke, j) \) by the same replica \( \txidCOPS{\repl}{\stub}{\stub}{\stub} = \WTx(\ver) \), such version is included in the replica's view \( j \in \viREPL(\ke) \).
                It implies that first the new transaction identifier is unique \cref{equ:write-trans-unique} and second it is greater than any transactions in the form of \( \txidCOPS{\repl}{\cl}{\stub}{\stub} \) \cref{equ:replica-time-monotonic-inc}.
                Thus the new key-value store \( \mkvsCOPS_{i+1} \) satisfies the well-formed conditions.
                Now let consider the views, especially the views of the replica \( \viREPL' \) and the client \( \viCL' \).
                Since that views \( \vi' \) from different replicas or clients remain unchanged, by \ih they satisfy \( \vi' \in \Views(\mkvsCOPS_{i+1}) \).
                The new view for replica \( \viREPL' = \viREPL\rmto{\ke}{\abs{\mkvsCOPS_{i+1}(\ke)} - 1} \)
                where \( \viREPL \) is the replica's view before updating and the writer of the last version of \( \ke \) is \( \txid \).
                Because \( \txid \) is a single-write transaction, so the new view \( \viREPL' \) still satisfies the atomic read.
                For similar reason, the new view for client \( \viCL' \) till satisfies atomic read.
                Therefore we have \( \viREPL', \viCL' \in \Views(\mkvsCOPS_{i+1}) \).
            \item \rl{GetTrans}

        \end{itemize}
    \end{itemize}
\end{proof}

\begin{lemma}
    \label{lem:repl-observe-own}
    A replica observes all its own transactions.
\end{lemma}
