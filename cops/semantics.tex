\subsubsection{Verification}
\paragraph{\bf Semantics the code}
Let \( \repl \in \Repls \) denotes the set of totally ordered replicates.
Each replicate can have multiple clients, and 
each clients can commit a sequence of either read-only transitions or single-write transactions.
To model these, we annotate the transaction identifier with replicate \( \repl \), client \( \cl \), 
local time of the replicate \( n \) and read-only transactions counter \( n' \), \ie \( \txidCOPS{\repl}{\cl}{n}{n'} \).
Note that the \( (n, \repl, n') \) can be treated as a single number that \( n \) are the higher bits, 
\( \repl \) the middle bits and \( n' \) the lower bits.
For a new single-write transaction, it is allocated with a transaction identifier with larger local time,
and for a read-only transactions, it is allocated with a transaction identifier with larger read-only counter.
There is a total order among transitions from the same replica and from the same client.

To model the dependencies of each version,
We extend version from \cref{def:his_heap} 
with the set of all versions it dependencies on, \( \dep \in \pset{\Keys \times \TxID} \).
The function \( \depOf{\ver} \) denotes the dependencies set of the version.
We use \( \mkvsCOPS \) for key-value store whose versions contain the dependencies.

We use view to model the client context,
that is, a version is included in a context if and only if such version is in the view of the client.
We also use view to model a replica state,
that is, if a replica contains a version if and only if such version in the view of the replica.
For readability, we annotate view with either a replica, \( \viREPL \), or a client, \( \viCL \).
The view environment is extended with replicas and their views, \( \vienvCOPS : (\Repls \times \Clients ) \parfinfun \Views \).
We give the following semantics to capture the behaviours of the code.

\paragraph{\bf Write}
For purpose of verification, we eliminate code for performance, and put the client API and replica API in the same function (\cref{lst:simplified-put}).
\begin{lstlisting}[caption={put},label={lst:simplified-put}]
// mixing the client API and system API
put(repl,k,v,ctx) {

    // Dependency for previous reads and writes
    deps = ctx_to_dep(ctx);(*\label{line:put-ctx-to-deps}*)

    // increase local time and appending local kv with a new version.
    inc(repl.local_time);(*\label{line:put-inc-local}*) 
    list_isnert(repl.kv[k],(v, (local_time + id), deps));(*\label{line:put-update-kv}*)

    // update dependency for writes
    ctx.writers += (k,(local_time + id),deps);(*\label{line:put-update-ctx}*)

    // broad case
    asyn_brordcase(k, v, (time ++ id), deps);
    return (local_time + id);
}
\end{lstlisting}

The following is the rule corresponds to \cref{lst:simplified-put}:

\begin{mathpar}
    \inferrule[Put]{%
        ( \stk, \ss, \emptyset ), \pmutate{\key}{\vx} \toTRANS
        ( \stk', \stub, \Set{(\otW, \key, \val )} ), \pskip
        \\\\
        \dep = \Setcon{(\key', \txid)}{\exsts{i} i \in \viCL(\key') \land \txid = \wtOf(\mkvsCOPS(\key', i)) \lor (\key', \txid) \in \depOf{\mkvsCOPS(\key', i)} } \texttt{ ---> \cref{lst:simplified-put}, \cref{line:put-ctx-to-deps}} 
        \\\\
        \txid = \min\Setcon{%
        \txidCOPS{\repl}{\cl}{n'}{0}
        }{%
            \fora{\key', i \in \viREPL(\key'), n} 
            \txidCOPS{\stub}{\stub}{n}{\stub} = \wtOf(\mkvsCOPS(\key',i))
            \implies n' > n 
        } \texttt{ ---> \cref{lst:simplified-put}, \cref{line:put-inc-local}}
        \\\\
        \mkvsCOPS' = \mkvsCOPS\rmto{\key}{\mkvsCOPS(\key) \lcat \List{(\key, \txid, \emptyset, \dep)}} \texttt{ ---> \cref{lst:simplified-put}, \cref{line:put-update-kv}}
        \\\\
        \viREPL' = \viREPL\rmto{\key}{\viREPL(\key) \uplus \Set{\abs{\mkvsCOPS'(\key)} - 1}} \texttt{ ---> \cref{lst:simplified-put}, \cref{line:put-update-kv}}
        \\\\
        \viCL' = \viCL\rmto{\key}{\viREPL(\key) \uplus \Set{\abs{\mkvsCOPS'(\key)} - 1}} \texttt{ ---> \cref{lst:simplified-put}, \cref{line:put-update-ctx}}
    }{%
    \repl, \cl \vdash 
    \mkvsCOPS, \viREPL, \viCL, \stk, \ptrans{\pmutate{\key}{\vx};} \toCMD{\viCL, \Set{(\otW, \key, \val )} }
    \mkvsCOPS', \viREPL', \viCL', \stk', \pskip
    }
\end{mathpar}

The first premiss is to execute the transaction locally (\cref{fig:semantics-trans}).
Since there is only a write, the snapshot \( \ss \) can be any snapshot.
The second line computes the dependency set for the new write operation,
by collecting all the writers of versions included in the view \( \viCL \).
The third line simulates the increment of local time.
Even thought we do not directly track the local time of a replica, 
yet the local time can compute as the maximum time contained in the replica's view \( \viREPL \).
The forth and fifth simulates the updates of the replica's key-value store,
and the last premiss simulates the update of client context.

\paragraph{\bf Read}
The following is a simplified algorithm by directly taking a list of versions 
\verb|ccv| satisfies causal consistency constraint,
\ie the second phase of \cref{lst:cops-client-read},
and then read the versions indicated by \verb|ccv|.
The simplified algorithm is easier to understand,
yet it is only for verification purpose because the extremely bad performance.
\begin{lstlisting}[caption={get\_trans},label={lst:get-trans}]
// A simplified version by guessing
// a ccv satisfying dependency constraints
// and then read versions indicated by ccv.
// Note that it is a weaker version of the original code,
// as the original implementation fetches the latest versions
// for keys by a sequence of atomic get_by_version calls
List(Val) get_trans(ks,ctx) {
    take ccv: (*$\forall$*) k (*$\in$*) ks.(*\label{line:get-trans-ccv-1}*)
        (_,_,deps) := get_by_version(k,ccv[k]) (*${}\land \forall$*) dep (*$\in$*) deps.(*\label{line:get-trans-ccv-2}*)
            dep.key (*$\in$*) ks (*$\implies$*) ccv[dep.key] >= dep.ver (*\label{line:get-trans-ccv-3}*)

    for k in ks(*\label{line:get-trans-read-1}*)
        rst[k] = get_by_version(k,ccv[k]);(*\label{line:get-trans-read-2}*)

    // update the ctx
    for (k,ver,deps) in rst(*\label{line:get-trans-update-ctx-1}*)
        ctx.readers += (k,ver,deps);(*\label{line:get-trans-update-ctx-2}*)

    return to_vals(ks);
}                                   
\end{lstlisting}

The following is the rule for read-only transaction:

\begin{mathpar}
    \inferrule[GetTrans]{%
        \viCL \viewleq \viCL' \viewleq \viREPL  \texttt{ ---> \cref{lst:get-trans}, \cref{line:get-trans-update-ctx-1,line:get-trans-update-ctx-2}}
        \\\\
        {\left(\begin{array}{@{}l@{}}
        \fora{\key, \key', m, \ver}  
        \land \ver = \func{ccv}{\mkvsCOPS, \key, \viCL} \land 
        (\key', \wtOf(\mkvsCOPS(\key', m))) \in \depOf{\ver}
        \implies m \in \viCL'(\key')
        \end{array}\right)} \texttt{ ---> \cref{lst:get-trans}, \cref{line:get-trans-ccv-1,line:get-trans-ccv-2,line:get-trans-ccv-3}}
        \\\\
        \trans =  \plookup{\vx_1}{\key_1}; \dots; \plookup{\vx_j}{\key_j};
        \\\\
        ( \stk, \func{getMax}{\mkvsCOPS, \viCL'}, \emptyset ), \trans \toTRANS
        ( \stk', \stub, \fp ), \pskip \texttt{ ---> \cref{lst:get-trans}, \cref{line:get-trans-read-1,line:get-trans-read-2}}
        \\\\
        \txidCOPS{\repl}{\cl}{n'}{n} = \max\Setcon{\txidCOPS{\repl}{\cl}{z'}{z}}{\txidCOPS{\repl}{\cl}{z'}{z} \in \mkvsCOPS }
        \\
        \mkvsCOPS' = \updateKV[\mkvsCOPS, \viCL', \fp, \txidCOPS{\repl}{\cl}{n'}{n+1}] 
    }{%
        \repl, \cl \vdash 
        \mkvsCOPS, \viREPL, \viCL, \stk, \ptrans{\plookup{\vx_1}{\key_1}; \dots; \plookup{\vx_j}{\key_j}; } \toCMD{\viCL', \fp}
        \mkvsCOPS', \viREPL, \viCL', \stk', \pskip
    }
    \and
    \inferrule[ClientCommit]{%
        \repl, \cl \vdash 
        \mkvsCOPS, \vienvCOPS(\repl), \vienvCOPS(\cl), \stk, \prog(\cl) \toCMD{\viCL'', \fp}
        \mkvsCOPS', \viREPL', \viCL', \stk', \cmd'
    }{%
        \mkvsCOPS, \vienvCOPS, \thdenv, \prog \toPROG{\viCL'', \fp}
        \mkvsCOPS', \vienvCOPS\rmto{\repl}{\viREPL'}\rmto{\cl}{\viCL'}, \thdenv\rmto{\cl}{\stk'}, \prog\rmto{\cl}{\cmd'}
    }
\end{mathpar}

The first premiss pick a new view \( \viCL' \) for client, which later we will see it should be a new that corresponds to the \verb|ccv|.
Note that the new client view cannot see more versions than the replica to which the client connects.
The second premiss constrains the new client view \( \viCL' \).
It says for the version \( \ver \) that is included in the client view and has the maximum writers,
\[
    \begin{rclarray}
        \func{ccv}{\mkvsCOPS, \key, \viCL} & \defeq &
        \max\Setcon{(\val, \txid, \txidset, \dep)}{\exsts{i} (\val, \txid, \txidset, \dep) = \mkvsCOPS(\key, i) \land i \in \viCL(\key)} \\
        (\val, \txidCOPS{\repl}{\cl}{n}{n'}, \txidset, \dep) > (\val', \txidCOPS{\repl'}{\cl'}{n''}{n'''}, \txidset', \dep') & \iff & (n, \repl, n') > (n'', \repl, n''') \\
    \end{rclarray}
\]
any dependency of the version \( \ver \) is also included in the view.
Note that \verb|ccv[k]| corresponds \( \func{ccv}{\mkvsCOPS, \key, \viCL} \), where \( \key = \) \verb|k|.
The third line simulates local execution of the read-only transaction.
The client always fetches the version with the maximum writer it can observed for each key,
Which is computed by \( \func{getMax} \) function. 
It is different from \( \snapshot \) because \( \snapshot \) fetches the latest version with respect to the position in the list, but later one we will prove \( \func{getMax} \) and \( \snapshot \) are equivalent.
\[
    \begin{rclarray}
        \func{getMax}{\mkvsCOPS, \viCL} & \defeq &
        \lambda \key \ldotp \left( \max_\txid\Setcon{(\val, \txid, \txidset, \dep)}{\exsts{i} (\val, \txid, \txidset, \dep) = \mkvsCOPS(\key, i) \land i \in \viCL(\key)} \right)\projection{1}
    \end{rclarray}
\]
The rest part are trivial be picking a new transaction identifier with larger read counter and committing to key-value store.

Last the rule for receiving a update.
A replica updates its local state only if all the dependencies has been receive as shown in \cref{lst:cops-replica-receive-msg}.
\begin{mathpar}
    \inferrule[sync]{%
        \viREPL = \vienvCOPS(\repl)\rmto{\key}{\vienvCOPS(\repl)(\key) \uplus i} 
        \\\\
        {\left(\begin{array}{@{}l@{}}
        \fora{\key', m, \ver} 
        \ver = \mkvsCOPS(\key, i) \land {}
        (\key', \wtOf(\mkvsCOPS(\key', m))) \in \ver\projection{4}
        \implies m \in \viREPL'(\key') 
        \end{array}\right)} 
    }{%
        \mkvsCOPS, \vienvCOPS, \thdenv, \prog \toPROG{}
        \mkvsCOPS, \vienvCOPS\rmto{\repl}{\viREPL}, \thdenv, \prog
    }
\end{mathpar}
The premiss says, the first line, the replica \( \repl \) receive a new version \( i \) for key \( \key \),
and, the second line, only if all the dependencies of the new update already in the replica's view.


\paragraph{\bf COPS key-value store}
To verify the algorithm, we prove that for any COPS trace produced by the algorithm,
there exists a corresponding causal consistency trace.
First we prove that the key-value stores from COPS trace satisfy \cref{def:mkvs}.

\begin{theorem}[Well-formed COPS key-value]
    \label{thm:cops-key-value-well-form}
    Let ignore the dependencies of versions from \( \mkvsCOPS \).
    Given the initial key-value store \( \mkvsCOPS_0 \), initial views \( \vienvCOPS_0 \) and some programs \( \prog_0 \), for any \( \mkvsCOPS_i \) and \( \vienvCOPS_i \)  such that: 
    \[
        \mkvsCOPS_0, \vienvCOPS_0, \thdenv_0, \prog_0 {\toPROG{}}^* \mkvsCOPS_i, \vienvCOPS_i, \thdenv_i, \prog_i
    \]
    The key-value store \( \mkvsCOPS_i \) satisfies \cref{def:mkvs} and any replica or client view \( \vi \) from \( \vienvCOPS_i \) is a valid view of the key-value store, \ie \( \vi \in \Views(\mkvsCOPS_i) \).
\end{theorem}
\begin{proof}
    We need to prove the  \( \mkvsCOPS_i \) satisfies the well-formed conditions,
    and any view \( \vi_i \Views(\mkvsCOPS_i) \).
    We prove it by introduction on the length \( i \).
    \begin{itemize}
    \item \caseB{\(i = 0\)}
        It holds trivially since each key only has the initial version \( (\val_0,\txid_0,\emptyset, \emptyset) \).
        Since there is only the initial version for each key, it is easy to see that any view \( \vi_0 \) satisfying the well-formed conditions in \cref{def:views}.
    \item \caseI{\(i > 0\)}
        Suppose it holds when \( i \), let consider \( i + 1 \).
        We perform case analysis on the possible next step:
        \begin{itemize}
            \item \rl{Put}
                Assume the client \( \cl \) of a replica \( \repl \) commits a single-write transaction \( \txid \) that installs a new version for key \( \key \).
                By the premiss of \rl{Put}, the new transaction identifier \( \txid = \txidCOPS{\repl}{\cl}{n'}{0} \) where for some \( n' \) that is greater than any \( n \) from any writers \( \txidCOPS{\stub}{\stub}{n}{\stub} \) that are observable by the replica \( \repl \).
                Since the new transaction \( \txid = \txidCOPS{\repl}{\cl}{n'}{0} \) is a single-write transaction which is always installed at the end of the list associated to \( \key \), it is sufficient to prove the following:
                \begin{gather}
                    \fora{j} 0 \leq j < \abs{ \mkvsCOPS_i(\key) } \implies \wtOf(\mkvsCOPS_{i}(\key, j)) \neq \txid \label{equ:write-trans-unique} \\
                    \fora{j, n} \txidCOPS{\repl}{\cl}{n}{\stub} \in \Set{\wtOf(\mkvsCOPS_{i}(\key,j))} \cup \rsOf(\mkvsCOPS_{i}(\key, j)) \implies n < n' \label{equ:replica-time-monotonic-inc}
                \end{gather}
                \cref{lem:mono-local-time} implies \cref{equ:write-trans-unique} and \cref{equ:replica-time-monotonic-inc}.
                Thus the new key-value store \( \mkvsCOPS_{i+1} \) satisfies the well-formed conditions.
                Now let consider the views, especially the views of the replica \( \viREPL' \) and the client \( \viCL' \).
                Since that views \( \vi' \) from different replicas or clients remain unchanged, by \ih they satisfy \( \vi' \in \Views(\mkvsCOPS_{i+1}) \).
                The new view for replica \( \viREPL' = \viREPL\rmto{\key}{\abs{\mkvsCOPS_{i+1}(\key)} - 1} \)
                where \( \viREPL \) is the replica's view before updating and the writer of the last version of \( \key \) is \( \txid \).
                Because \( \txid \) is a single-write transaction, so the new view \( \viREPL' \) still satisfies the atomic read.
                For similar reason, the new view for client \( \viCL' \) till satisfies atomic read.
                Therefore we have \( \viREPL', \viCL' \in \Views(\mkvsCOPS_{i+1}) \).

            \item \rl{GetTrans}
                Assume the client \( \cl \) of a replica \( \repl \) commits a read-only transaction \( \txid \).
                Since it is a read-only transaction, it suffice  to prove the following:
                \begin{gather}
                    \fora{\key,j} 0 \leq j < \abs{ \mkvsCOPS_i(\key) } \implies \txid \notin \rsOf(\mkvsCOPS_{i}(\key, j)) \label{equ:read-trans-unique} 
                \end{gather}
                \cref{lem:mono-local-time} implies \cref{equ:read-trans-unique}.
                Thus the new key-value store \( \mkvsCOPS_{i+1} \) satisfies the well-formed conditions.
                Now let consider the views.
                Since only the client view has changed, it is sufficient to  prove that \( \viCL' \in \Views(\mkvsCOPS_{i+1}) \), 
                where \( \viCL' \) is the new client.
                By \cref{lem:write-unique}, the new view \( \viCL' \) satisfies the atomic read constraint.
                Therefore \( \viCL' \in \Views(\mkvsCOPS_{i+1})  \).
        \end{itemize}
    \end{itemize}
\end{proof}


\begin{lemma}[Unique writer]
    \label{lem:write-unique}
    Each version has a unique writer.
\end{lemma}
\begin{proof}
    Because a transaction can write to at most one key, then by \cref{lem:repl-observe-own} and the premiss of \rl{Put},
    we have the proof.
\end{proof}

\begin{lemma}[Monotonic local time]
    \label{lem:mono-local-time}
    Given a reduction step such that: 
    \[
        \mkvsCOPS, \viREPL, \viCL, \stk, \cmd {\toCMD{}}^* \mkvsCOPS', \viREPL', \viCL', \stk', \cmd'
    \]
    let \( \txidCOPS{\repl}{\cl}{n}{n'} \) be the new transaction, \ie \( \txidCOPS{\repl}{\cl}{n}{n'} \in \mkvsCOPS' \land  \txidCOPS{\repl}{\cl}{n}{n'} \notin \mkvsCOPS \).
    It implies the new transaction is greater than any transaction committed by the same client view \( \viCL \), \ie
    \[ 
        \txidCOPS{\repl}{\cl}{n''}{n'''} \in \mkvsCOPS \implies (n,\repl,n') > (n'', \repl, n''')
    \]
\end{lemma}
\begin{proof}
    We perform case analysis.
    \begin{itemize}
        \item \rl{Put}
            By the premiss of the rule, 
            the new transaction is in the form \( \txidCOPS{\repl}{\cl}{n}{0} \).
            By the \cref{lem:repl-observe-own} we have for any existing transaction \( \txidCOPS{\repl}{\cl}{n'}{\stub} \),
            \[
                \txidCOPS{\repl}{\cl}{n'}{\stub} \in \mkvsCOPS \implies n > n'
            \]
        \item \rl{GetTrans}
            Let \( \txidCOPS{\repl}{\cl}{n}{n'} \) be the new transaction.
            By the premiss we have that for any existing transaction \( \txidCOPS{\repl}{\cl}{n''}{n'''} \), 
            \[
                \txidCOPS{\repl}{\cl}{n''}{n'''} \in \mkvsCOPS \implies n = n'' \land n' > n'''
            \]
    \end{itemize}
\end{proof}

\begin{lemma}[Observe its own]
    \label{lem:repl-observe-own}
    \label{lem:cl-observe-own}
    A client observes all its own transactions, that is, for any key-value store \( \mkvsCOPS \) and view \( \viCL \):
    \[
        \fora{i,\key, \val, \dep, \txid, \txidset, \txidCOPS{\stub}{\cl}{\stub}{\stub}} (\val, \txid, \txidset, \dep)  = \mkvsCOPS(\key,i) 
        \land \txid = \txidCOPS{\stub}{\cl}{\stub}{\stub} 
        \lor \txidCOPS{\stub}{\cl}{\stub}{\stub} \in \txidset
        \implies i \in \viCL(\key)
    \]
    Similarly, a replica observes all its own transactions.
\end{lemma}


\paragraph{\bf COPS normal trace}
We define COPS semi-normal trace then normal trace.
Later, we prove for any COPS trace, there exists an equivalent normal trace.

The dependency of a transaction \( \depOf{\mkvsCOPS, \txid} \) is defined as:
\begin{itemize}
    \item if \( \txid \) is a single-write transaction:
    \[
        \begin{rclarray}
            \depOf{\mkvsCOPS, \txid} & \defeq & 
            \begin{array}[t]{@{}l@{}}
                \dep  \ \text{where} \ 
                \exsts{\key,j} \lastConf(\tr)\projection{1}(\key,j) = (\stub, \txid, \stub, \dep)  \\
            \end{array}
        \end{rclarray}
    \]
    \item if \( \txid \) is a read-only transaction:
    \[
        \begin{rclarray}
            \depOf{\mkvsCOPS, \txid} & \defeq & 
            \begin{array}[t]{@{}l@{}}
                \bigcup_{\Setcon{\ver}{\exsts{\key,j} \ver = \mkvsCOPS(\key,j) \land \txid \in \rsOf(\ver)}} \depOf{\ver} \\
            \end{array}
        \end{rclarray}
    \]
\end{itemize}
Given a trace \( \tr \), 
the function \( \func{maxVersion}{\tr, \txid} \) returns the version that the transaction \( \txid \) depends on
and is the last one begin reduced:
        \[
        \begin{rclarray}
            \func{maxVersion}{\tr, \txid} & \defeq &  \txid_i
            \quad \begin{array}[t]{@{}l@{}}
                \text{the \( \txid_i \) is the last one appears in \( \tr \) such that} \\
                (\key',\txid_i) \in \depOf{\lastConf(\tr)\projection{1}, \txid} \land \txid_i \notin \mkvsCOPS_i \land  \txid_i \notin \mkvsCOPS_{i+1}
            \end{array}
        \end{rclarray}
    \]
Give two COPS's traces \( \tr \) and \( \tr' \), \( \mkvsCOPS \) being the final state of \( \tr \) and \( \mkvsCOPS' \) for \(\tr'\),
if the two traces are equivalent, if and only if,
\[ 
    \begin{array}{@{}l@{}}
    \fora{\txid,\fp,\dep} \txid \in \mkvsCOPS
    \fp = \func{RWset}{\txid,\mkvsCOPS} \land \dep =  \func{RWset}{\txid,\mkvsCOPS}
    \implies
    \txid \in \mkvsCOPS'
    \fp = \func{RWset}{\txid',\mkvsCOPS} \land \dep =  \func{RWset}{\txid',\mkvsCOPS}
    \end{array}
\]
where \( \func{RWset}{\txid,\mkvsCOPS} \) is the read-write set of \( \txid \).
Note that \( \func{RWset}{.} \) is well-defined by \cref{thm:cops-key-value-well-form}.

A COPS's semi-normal trace is a trace \( \tr \) if it is in the form that
read-only transactions \( \txid_\rd \) directly follows its \( \func{maxVersion}{\tr, \txid_\rd} \) or another read-only transaction \( \txid_{\rd}' \) such that \( \func{maxVersion}{\tr, \txid_\rd}  =  \func{maxVersion}{\tr, \txid_{\rd}'}\).


\begin{corollary}
    \label{lem:cops-semi-normal-trace}
    \label{cor:cops-semi-normal-trace}
    For any COPS's trace \( \tr \), there exists a equivalent semi-normal trace \( \tr' \) 
    such that \( \lastConf(\tr) = \lastConf(\tr') \).
\end{corollary}
\begin{proof}
    It is easy to prove by induction on the numbers of read-only transactions that are not in the wanted position.
    Let take the first one for those read-only transactions \( \txid_\rd \) who does not follows its \( \func{maxVersion}{\tr, \txid_i} \).
    It is safe to move the reduction step to the right in the trace,
    until it directly follows its \( \func{maxVersion}{\tr, \txid_\rd} \) or another read-only transaction \( \txid_{\rd}' \) such that \( \func{maxVersion}{\tr, \txid_\rd}  =  \func{maxVersion}{\tr, \txid_{\rd}'}\). 
\end{proof}

A COPS's normal trace is a trace \( \tr \) if it is semi-normal trace and the single-write transactions commit in the same order of the transaction identifiers.

\begin{theorem}[normal trace]
    \label{thm:cops-normal-trace}
    \label{lem:cops-normal-trace}
    \label{cor:cops-normal-trace}
    For any COPS's trace \( \tr \), there exists a equivalent normal trace \( \tr' \) such that
\end{theorem}
\begin{proof}
    By \cref{cor:cops-semi-normal-trace}, let consider a semi-normal trace \( \tr \).
    It is easy to prove by induction on the single-write transactions that are out of order.
    Let take the first single-write transaction \( \txid = \txid{\repl}{\cl}{n}{n'} \) that is out of order.
    Suppose it is the i-\emph{step}.
    Assume \( \txid \) write to key \( \key \) with value \( \val \).
    Assume the preview write-only transaction \( \txid'  = \txid{\repl'}{\cl'}{n''}{n'''} \) and it follows \( (n,\repl,n') < (n'', \repl', n''') \).
    It means if a view \( \vi \) includes both \( \txid \)  and \( \txid' \), and if \( \txid' \) also write to the same key \( \key \) with value \( \val' \), the \( \vi \) will fetch the value from \( \txid' \):
    \begin{equation}
        \label{equ:out-order-wrte-older-value}
        \func{getMax}{\mkvsCOPS_i,\vi}(\key) = \val'
    \end{equation}
    The intuition here is to swap the reduction steps of these two transactions and those read-only transactions following them.
    We assume \( \txid \)  and \( \txid' \) write to the same key, otherwise it is safe to swap.
    For any read-only transactions \( \txid_{\rd} \in \txidset_{\rd} \) following \( \txid \), we knows \( \txid' \notin \depOf(\mkvsCOPS_i, \txid_{\rd}) \), otherwise it violate \( \func{maxVersion}{\tr, \txid_\rd} = \txid \).
    Thus it is safe to swap the reduction steps.
\end{proof}


\begin{corollary}
    \label{cor:get-max-to-get-snap}
    For the \rl{Put} and \rl{GetTrans}, it is safe to replace the function \( \func{getMax}{.} \) with the function \( \snapshot \).
\end{corollary}
\begin{proof}
    By \cref{thm:cops-normal-trace}, each trace \( \tr \) has an equivalent normal trace \( \tr' \).
    Assume i-\emph{th} step in the trace \( \tr' \).
    Assume the key-value store before is \( \mkvsCOPS_i \).
    For any versions \( m \) and \( j \) from the same key in the \( \tr' \):
    \[
        0 < m < j < \abs{\mkvsCOPS_i(\key)} \implies \wtOf(\mkvsCOPS_i(\key,m)) <  \wtOf(\mkvsCOPS_i(\key,j))
    \]
    thus it is safe to use \( \snapshot \).
\end{proof}

\paragraph{\bf COPS normal trace to \( \ET_\CC \) trace}
Given \cref{thm:cops-key-value-well-form} and \cref{cor:get-max-to-get-snap}, for any COPS's trace \( \tr \), 
there exists a trace \( \tr' \) that is a normal trace and satisfies \( \ET_\top \).
Then by the following theorem (\cref{thm:cops-cc}), we proof the COPS trace satisfies \( \ET_\CC \).

\begin{theorem}[COPS satisfying causal consistency]
    \label{thm:cops-cc}
    Given a trace starting from the initial key-value store \( \mkvsCOPS_0 \), initial views \( \vienvCOPS_0 \) and some programs \( \prog_0 \), for any \( \mkvsCOPS_i \) and \( \vienvCOPS_i \)  such that: 
    \[
        \mkvsCOPS_i, \vienvCOPS_i, \thdenv_i, \prog_i \toPROG{\viCL,\fp} \mkvsCOPS_{i+1}, \vienvCOPS_{i+1}, \thdenv_{i+1}, \prog_{i+1} 
    \]
    then the i-\emph{th} step satisfies \( \ET_\CC \), \ie
    \[
        \ET_\CC \vdash ( \mkvsCOPS_i, \viCL ) \csat \fp : (\mkvsCOPS_{i+1},\vienvCOPS_{i+1}(\cl) )
    \]
\end{theorem}
\begin{proof}
    We introduce an invariant \( I \) on the view of client that if the view includes a version, 
    it also includes all the version it depends on, that is,
    \[
        \begin{array}{@{}l@{}}
        \fora{\cl, \viCL,\key,\key',j,m,\dep} \\
        \quad \viCL = \vienvCOPS_i(\cl) \land j \in \viCL(\key') 
        \land (\stub,\stub,\stub,\dep) = \mkvsCOPS_i(\key,j)
        \land (\key',\wtOf(\mkvsCOPS_i(\key',m))) \in \dep \\
        \qquad \implies m \in \viCL(\key')
        \end{array}
    \]
    Since \( \ET_\CC = \ET_\MR \cap \ET_\MW \cap \ET_\RYW \cap \ET_\WFR \), we prove the four constraints separately.
    In each case we need to consider \rl{Put} and \rl{GetTrans}.
    \begin{itemize}
        \item \( \ET_\MR \). 
            It is easy to see \( \viCL \viewleq \vienvCOPS_{i+1}(\cl) \).

        \item \( \ET_\MW \).
            By \cref{lem:cops-dep} and the invariant, we have to proof.
            Now we need to re-establish the invariant \( I_{i+1} \).
            \begin{itemize}
                \item 
                For \rl{GetTrans}, the client \( \cl \) commits a read-only transaction.
                By the premiss of the rule, the new view \( \vienvCOPS_{i+1}(\cl) \) satisfies the invariant.
                \item For \rl{Put}, the new view \( \vienvCOPS_{i+1}(\cl) = \viCL\rmto{\key}{j} \),
                where the new version \( \mkvsCOPS_{i+1}(\key,j)\) is written by the client \( \cl \).
                Let \( \dep \) be the dependency for the new view, \ie \( \dep = \depOf(\mkvsCOPS_{i+1}(\key,j)) \).
                By the premiss, the \( \dep \) includes all version included in \( \viCL \), 
                therefore the invariant has been preserved.
            \end{itemize}

        \item \( \ET_\RYW \). Let consider two cases:
            \begin{itemize}
                \item 
                For \rl{GetTrans}, the client \( \cl \) commits a read-only transaction.
                By \cref{lem:cl-observe-own} and  \( \viCL \viewleq \vienvCOPS_{i+1}(\cl) \),
                we have the prove.
            \item For \rl{Put}, the new view \( \vienvCOPS_{i+1}(\cl) = \viCL\rmto{\key}{j} \),
                where the new version \( \mkvsCOPS_{i+1}(\key,j)\) is written by the client \( \cl \).
                Then by \( \viCL \viewleq \vienvCOPS_{i+1}(\cl) \), we have the proof.
            \end{itemize}

        \item \( \ET_\WFR \).
            By \cref{lem:cops-dep} and the invariant, we have to proof.
            Now we need to re-establish the invariant \( I_{i+1} \).
            \begin{itemize}
                \item 
                For \rl{GetTrans}, the client \( \cl \) commits a read-only transaction.
                By the premiss of the rule, the new view \( \vienvCOPS_{i+1}(\cl) \) satisfies the invariant.
                \item For \rl{Put}, the new view \( \vienvCOPS_{i+1}(\cl) = \viCL\rmto{\key}{j} \),
                where the new version \( \mkvsCOPS_{i+1}(\key,j)\) is written by the client \( \cl \).
                Let \( \dep \) be the dependency for the new view, \ie \( \dep = \depOf(\mkvsCOPS_{i+1}(\key,j)) \).
                By the premiss, the \( \dep \) includes all version included in \( \viCL \), 
                therefore the invariant has been preserved.
            \end{itemize}
    \end{itemize}
\end{proof}

\begin{lemma}
    \label{lem:cops-dep}
    Given the initial key-value store \( \mkvsCOPS_0 \), initial views \( \vienvCOPS_0 \) and some programs \( \prog_0 \), for any \( \mkvsCOPS_i \) and \( \vienvCOPS_i \)  such that: 
    \[
        \mkvsCOPS_0, \vienvCOPS_0, \thdenv_0, \prog_0 {\toPROG{}}^* \mkvsCOPS_i, \vienvCOPS_i, \thdenv_i, \prog_i 
    \]
    for any versions \( ( \val,\txid,\txidset,\dep ) = \mkvsCOPS_i(\key,j) \) and \( ( \val',\txid',\txidset',\dep' ) = \mkvsCOPS_i(\key',m) \), if \( \txid \) depends on \( \txid' \), \ie
    \[
        \begin{array}{@{}l@{}}
            \txid' \toEDGE{\SO ?} \txid
            \lor \exsts{\txid''}
            \txid'' \in \txidset' \land
            \txid'' \toEDGE{\SO ?} \txid
        \end{array}
    \]
    then \( \txid' \) and \( \dep' \) is in the dependency \( \dep \), \ie
    \[
        (\stub, \txid') \in \dep \land \dep' \subseteq \dep
    \]
\end{lemma}
\begin{proof}
    We prove by induction on the length of trace \( i \).
    \begin{itemize}
        \item 
        \caseB{\(i = 0\)}
        It trivially holds.
        \item  
        \caseI{\( i > 0 \)}
        Suppose \( \mkvsCOPS_i \) satisfies the property, let consider the next key-value store \( \mkvsCOPS_{i+1}\).
        We perform case analysis.
        \begin{itemize}
            \item 
            \rl{Put}.
            Assume a client \( \cl \) commit a new transaction \( \txid \) that installs a new version to key \( \key \).
            Assume the initial view for the client is \( \viCL \).
            In the new key-value store \( \mkvsCOPS_{i+1} \), for versions other than \( \mkvsCOPS_{i+1}(\key, \abs{\mkvsCOPS_{i+1}} - 1 ) \), they still satisfy the property by \ih
            By \cref{lem:cl-observe-own}, it follows that for any preview transaction from the same client \( \txid' \):
            \[
                \begin{array}{@{}l@{}}
                    \txid' \toEDGE{\SO ?} \txid
                    \lor \exsts{\txid''}
                    \txid'' \in \txidset' \land
                    \txid'' \toEDGE{\SO ?} \txid
                \end{array}
            \]
            the version written by the transaction \( \txid' \) is included in the view \( \viCL \).
            By the premiss of \rl{Put} that how the new \( \dep \) is constructed, we have proof.

            \item 
            \rl{GetTrans}.
            Since it only commits a read-only transaction, 
            the \( \mkvsCOPS_{i+1} \)  satisfies the property by \ih
        \end{itemize}
    \end{itemize}
\end{proof}

%\begin{theorem}[COPS satisfy parallel snapshot isolation]
    %For any COPS's trace \( \tr \) starting from the initial key-value store \( \mkvsCOPS_0 \), initial views \( \vienvCOPS_0 \) and some programs \( \prog_0 \), 
    %there exists an equivalent trace \( \tr' \) where \( \mkvsCOPS'_i \) and \( \vienvCOPS'_i \)  such that: 
    %\[
        %\mkvsCOPS'_i, \vienvCOPS'_i, \thdenv'_i, \prog'_i \toPROG{\viCL',\fp'} \mkvsCOPS'_{i+1}, \vienvCOPS'_{i+1}, \thdenv'_{i+1}, \prog'_{i+1} 
    %\]
    %then the i-\emph{th} step satisfies \( \ET_\PSI \), \ie
    %\[
%\ET_\PSI \vdash ( \mkvsCOPS'_i, \viCL' ) \csat \fp' : ( \mkvsCOPS'_{i+1}, \vienvCOPS'_{i+1}(\cl) )
    %\]
%\end{theorem}
%\begin{proof}
    %By \cref{thm:cops-cc}, we already the trace \( \tr \) satisfying \( \ET_\CC \).
    %It is sufficient to construct the trace \( \tr' \) so that 
%\( \ET_\PSI \vdash ( \mkvsCOPS'_i, \viCL' ) \csat \fp' : ( \mkvsCOPS'_{i+1}, \vienvCOPS'_{i+1}(\cl) ) \) since \( \ET_\PSI = \ET_\CC \cap \ET_\UA\).
    %We inductively alter all single-write transactions \( \txid \) that 
    %does not start with a view containing all the versions for the key the transactions \( \txid \) want to write.
    %Initially let \( \tr' = \tr \).
    %Let pick the first single-write transaction \( \txid \), assuming it is i-\emph{step}, 
    %who installs a version \( \mkvsCOPS_{i+1}(\key,j) = (\val,\txid,\txidset,\dep )\) with a initial view \( \viCL \) does not contain all versions \( \mkvsCOPS_i(\key,m) \)
    %for some key \( \key \), client \( \cl \) and index \( m \) and \( j \).
    %Since \( \txid \) is the first transaction does not contain all versions \( \mkvsCOPS_i(\key,m) \),
    %it means the view \( \viCL \) does not include only the last version \( \mkvsCOPS_i(\key,j-1) \).
    %Suppose the version \( \mkvsCOPS_i(\key,j-1) = (\val',\txid',\txidset',\dep' ) \) for some transaction \( \txid' \).
    %Note that \( \txid' \)  and \( \txid \) comes from different client, otherwise it violate \( \ET_\RYW \).
    %Thus let assume the initial view for \( \txid' \) is \( \viCL[\cl'] \) for client \( \cl' \) such that \( \cl' \neq \cl \).
    %We performance case analysis as the following.
    %\begin{itemize}                                                               
        %\item Suppose \( \depOf(\txid') \subseteq \depOf(\txid_\rd) \), for all read-only transactions \( \txid_\rd \in \txidset \).
            %It means it is safe to include \( j-1 \) version into \( \viCL \),
            %\ie the new initial view for \( \txid \) is \( \viCL' = \viCL\rmto{\key}{j-1} \).
            %Given that, all the initial views for the read-only transactions \( \txid_\rd \in \txidset \) also include \( \mkvsCOPS(\key,j) \).
            %Yet because \( \depOf(\txid') \subseteq \depOf(\txid_\rd) \), the version \(\mkvsCOPS(\key,j)  \) is already in the initial view of \( \txid_\rd \).
            %By the new initial view \( \viCL' \), it is easy to see 
            %\( \ET_\UA \vdash (\mkvsCOPS_i, \viCL') \csat \Set{(\otW, \key, \val)}, \viCL'' \).
        %\item there exists a read-only transaction \( \txid_\rd \in \txidset \) such that 
              %\( \depOf(\txid') \not\subseteq \depOf(\txid_\rd) \).
              %\begin{itemize}
                  %\item If it is safe to include \( \depOf(\txid') \) into \( \depOf(\txid_\rd) \), consequently changing the initial for \( \txid_\rd \), for all read-only transactions \( \txid_\rd \in \txidset \), then we are back to the first case.
                  %\item If there exists a read-only transaction \( \txid_\rd \) that is not safe to include \( \depOf(\txid') \).
                      %That is, there exists a single-write transaction  \( \txid'' \) who installs a version \( \mkvsCOPS_i(\key',x)\) for a key \( \key' \) and a index \( x \) and the \( \txid_\rd \) read this version.
                      %Given that it is not safe for  \( \depOf(\txid_\rd) \) to includes \( \depOf(\txid') \), 
                      %there exists anther version \( \mkvsCOPS_i(\key',y) \) for the same key \( \key' \) and a index \( y \) such that \( y > x \).
                      %It follows 
                      %\[ 
                        %\depOf{\mkvsCOPS_i(\key',x)} \subseteq \depOf{\mkvsCOPS_i(\key',y) \subseteq \depOf{\txid'} } 
                      %\]
                      %therefore 
                      %\[
                          %\fora{\txid'_\rd \in \txidset'} \depOf{\mkvsCOPS_i(\key',x)} \subseteq \depOf{ \txid'_\rd}
                      %\]
            %\end{itemize}
    %\end{itemize}
%\end{proof}
