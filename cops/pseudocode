COPS-GT SYSTEM PSEUDO_CODE

// local time and ID are totally ordered separately
VersionNo :: LocalTime + ID

// replica has a unique identifier,
// a local store and local time
Replica :: ID -> (KV,VersionNo)

// each key in the local store has a list of tuples 
// consisting of value, version and the dependency.
KV :: Key -> List(Val,VersionNo,Dep)

// Dependency is a set of versions.
// Each individual write operation corresponds to a version.
Dep :: Set(Key,VersionNo)

// A queue for sending put_after message.
// Messages have key, value, version number, the dependency.
ReplQueue :: List(Key,Val,VersionNo,Deps)
Ctx :: {
    readers : List(Key,VersionNo,Dep)
    writers : List(Key,VersionNo,Dep)
}


//  ******* replica API ********** //

// write to a key local

// Deps set come from read operations and 
// vers set come write operations
// nearest set is nearest of deps.
// For local call, all the nearest should already exist,
// since those has been checked the moment reading them
VersionNo put_after(k,v,deps,nearest,vers){
    for (k,ver) in nearest
        wait until dep_check(k,ver);

    atomic{
        // increase local time.
        inc(local_time);

        // appending local kv with a new version.
        list_isnert(kv[k],(v,
                (local_time + id),(deps + vers)));
    }

    enqueue(k,v,(current_ver+id),(deps ++ vers));
    return current_ver;
}

// Syn to other replicas
send() {
    (k,v,ver,deps) := dequeue();
    for id in repls {
        send (k,v,ver,deps) to id;
    }
}

// receive a write message from other replica
on_receive(k,v,ver,deps) {
    // for a single machine
    // the following check immediately holds
    for (k',ver') in deps {
        wait until dep_check(k',ver');
    }

    atomic{
        list_isnert(kv[k],(v,ver,deps));
    }
}

// Check dependency
bool dep_check(k,ver) {
    atomic {
        return  (_,ver,_) (*$\in$*) kv(k);
    }
}

// Read by version number
(Val,Version,Dep) get_by_version(k,ver) {

    if (ver  = LATEST)
        atomic {
            ver := max(kv[k].vers);
        }

    wait until dep_check(k,ver);
    
    atomic {
        take (val,ver,deps) in kv[k];
    }
    return (val,ver,deps);
}

Dep ctx_to_dep(ctx) {
    return { (k,ver) | (k,ver,_) (*$\in$*) ctx.readers (*$\lor$*)
                (k,ver,_) (*$\in$*) ctx.writers }
}

Dep dep_to_nearest(deps) {
    return { (k,ver) | (*$\forall$*)k',ver',deps'.
            (k',ver',deps') (*$\in$*) deps (*$\implies$*) (k,ver) (*$\notin$*) deps' };
}

//  ******* client API ********** //

// write a key
put(k,v,ctx) {

    // add up all the read and write dependency
    deps = ctx_to_dep(ctx);

    ver = put_after(k,v,
            deps,dep_to_nearest(deps),ctx.writers);

    ctx.writers += (k,ver,deps);
}

// read
List(Val) get_trans(ks,ctx) {
    for k in ks
        // only guarantee to read up-to-date value 
        // the moment reading the individual key
        rst[k] = get_by_version(k,LATEST);

    ccv[...] = min_version;

    for k in ks {
        ccv[k] = max (ccv[k],rst[k].ver);
        for dep in rst[k].deps
            if ( dep.key (*$\in$*) ks )
                ccv[k] = max (ccv[dep.key],dep.vers);
    }

    for k in ks 
        if ccv[k] > rst[k].vers
            rst[k] = get_by_version(k,ccv[k]);

    // update the ctx
    for (k,ver,deps) in rst
        ctx.readers += (k,ver,deps);

    return to_vals(ks);
}                                   
