Our operational semantics aims to reason about client programs and verify implementations in the same framework.
We prove robustness for counter and banking ADTs, 
and we believe that our robustness proof technique can be applied to more complicated transactional applications
such as examples in [CAV '19 checking robustness against snapshot isolation].
We have verified COPS and Clock-SI protocols.
In the current version of the paper, we present the verification for COPS protocol, which is the more difficult one.
We will give more details about COPS and Clock-SI if extra pages are allowed.

# Reviewer A

Weaknesses 

- The approach is restricted [..] Section 6.1).

As pointed out by the review, ADTs can be implemented on the low level kv-store,
although they need to be represented explicitly, however, we do not believe this is a severe limitation.
One of our intended application is that of proving the correctness of ADTs against a formal specification,
one example is given in section 6.1 as robustness of counter ADT implies its correctness.

- The general strategy and operational model [..] semantics are captured in terms of logs.

We are aware of the log-based models in the literature and we should have compared our work with them.
For example, the push/pull model is orthogonal to ours.
In contrast with us, the push/pull model only focuses on serialisiblity,
on the other hand it does not restrict to kv-stores.
It would be interesting to see we could generalise our model beyond key-value stores.

- The application to Transactional Libraries (Section 6.1) is nice, although it focuses on fairly simple counter-based ADTs and only PSI/WSI.

We believe that our robustness proof technique can be applied to more complicated transactional applications.
We already started investigating the examples presented in [CAV '19 checking robustness against snapshot isolation].

Overall assessment: 

- On the other hand, this is not that surprising and perhaps not too different [..] for example,

The model in Cerone's et al, in contrast with us, 
does not explain how abstract executions can be obtained in term of incremental transaction commits.
We believe that our operational semantics is the natural middle point between dependency graphs and abstract executions 
as it enables both program analysis and verification of implementations.

- What seems yet unproven is the degree to which the current paper's new formulation in terms of can-commit and vshift offers some new useful benefit.

We think that, although easy, the applications in Section 6.1 give some insight about how our operational 
Model can be used to prove interesting properties of transactional applications.
We also started investigating the examples presented in [CAV '19 checking robustness against snapshot isolation]. During the summer, we also improved the proof of correctness of the COPS protocol.

- Line516 - "convenient to separate shifting a view from committing a transaction." Can you provide more detail/citations as to real-world protocols where these indeed take place separately?

Many distributed protocols separate the so called visibility logic (which roughly corresponds to 
determining the view in which a transaction can execute) and the commit phase (which roughly 
Corresponds to checking whether a transaction commit is allowed by an execution tests). Other than 
COPS and Clock-SI, 
Examples of such protocols are Walter [SOSP '11, Transactional Storage for Geo-replicated Systems] 
And Non-Monotonic Snapshot Isolation [SRDS '13]].

- I had trouble parsing the definition of \textsf{closed}closed.

The definition of closed in the paper is indeed hard to read, mainly because it mixes the 
notion of visible transactions with the one of a set of transactions closed with respect to a relation. 
We will split the definition, hoping to make it more clear.

- Strict serializability - is it really the "strongest model in the literature"? 

There are other consistency models of transactions that are either stronger than, or non-comparable with, 
strict serialisability; e.g. Opacity. However, these models make sense only in settings which, unlike ours, 
do not abstract from aborted transactions.

Questions for authorsâ€™ response

- Transactions are not permitted to abort. Is that a reasonable assumption for your setting?

The assumption is reasonable. Since we are focusing on the client-observable behaviour of 
transactions, we can abstract from aborted transactions. This assumption is made also in the 
works concerning abstract executions and dependency graphs mentioned by the author.

# Reviewer B

he definition of consistency models in the new semantics, based on a key-value store, is not self contained, it assumes known previous formalisation of the consistency criteria.

We believe that the definitions of consistency models in our framework are self-contained, 
in particular all the definitions are developed around the notions of kv-stores and views. 
Some of these definitions (i.e. the WR, WW and RW relations) are the kv-store counterpart 
Of other relations for dependency graphs, and we decided to adopt the same name for them 
to emphasise the similarities they share.


-The paper goals is not clear. There is a the new semantics, insufficiently motivated, and robustness proofs, whose relevance/novelty is not clear. 

Our goal is provide an interleaving semantics that can be used to reason about client programs and verify implementation in the same framework. 
We already started investigating the examples presented in [CAV '19 checking robustness against snapshot isolation] and more implementations, and we have already improved on the part on protocol verification.

- Regarding verification of database protocols I like the COPS example and I would have liked to see in the paper also Clock-SI.

We really tried to put the verification of Clock-SI in the main paper, but we could not do it given the 
Space available. We had to make a choice between Clock-SI and Cops, and we decided to go for the former 
Because the proof is more involved.

- Regarding related work, my main question is the comparison with Nagar and Jagannathan 2018. What is the difference if a transaction consists of only one operation?

With respect to [Nagar and Jagannathan], even in the case of transactions with a single operation, 
The execution of a transaction would require several transaction steps (one to start, one to execute 
The operation, and one to commit). 
In the appendix of our paper, we give an alternative semantics 
based on abstract executions that can be seen as a simplification without losing in expressiveness. 
This operational semantics is at the core of our methodologies to prove that an execution test corresponds 
To an axiomatic specification based on abstract execution

# Reviewer C

- Despite what the title suggests, the semantics seems to be limited and modeling only particular executions [..]

(13) Being able to faithfully model the behaviour transactional applications under weak consistency models the comment about theorem 4.4 refers to 
without dealing multiple transactions being executed at the same time is a strength not a weakness.
It significantly simplifies program reasoning.
Because of operational nature of our framework, we can also verify implementations (see below).

- The paper states that "It is still possible for an underlying implementation, such as COPS, to update the distributed kv-store while the transaction is in progress.", however, it is not clear how [..] 

Our proof of COPS protocol is obtained via a trace refinement from an encoding of the pseudo-code from the original paper of COPS,which we have improved in the summer.
The proof of Clock-SI is simpler and we will make an effort to include it in the final version.

- Although the paper presents an operational semantics, the presented proofs still have the axiomatic flavor [..] 

The proofs of robustness results ue an induction argument, and do not rely on the 
Aciclycity of dependency graph. Rather the acyclicity of a dependency graph is a property that we 
Prove (and this is indeed equivalent to robustness). In practice, in our applications, it would be easy to tweak the proof of robustness by constructing serialisable ET-traces of programs directly,  
without involving any acyclicity property of the dependency graphs.

- The paper could motivate why reasoning about consistency models using this centralized approach should be preferred over abstract execution and dependency graphs by automating the verification part. 

We agree that developing a tool for automating verification would be a strong addition to our results and 
Would help us motivate the paper better, and our research is moving in that direction.

- The technique presented to verify protocols is not precise and seems to be incorrect.

In the main paper, we decided to focus on only presenting informal details for the proof of correctness 
Of COPS. In fact, its proof of correctness, which is given in the appendix, is obtained by giving a concrete 
Semantics for COPS, and performing a trace refinement to the kv-store semantics for causal consistency.

# Reviewer D

- Novelty: Reading the paper largely felt like re-developing known ideas and techniques using a ostentatiously different, but in fact largely equivalent formalism.

 Our model is significantly different from dependency graphs and abstract executions as explained when addressing the comments from reviewer A.

- Also, there are no progress guarantees telling us that it is always possible to execute a program, i.e. ensuring that the system does not get stuck.

Concerning progress properties, it is relatively easy to prove that:
none of the consistency models that we consider hinders progress if a program does not get stuck under serilizability, then it will not get stuck under any of the considered consistency models.

- Precision and presentation: Many things were not clear to me without consulting the supplemental material

We made a huge effort to make the paper as clear as possible. As pointed out by reviewer C, we were really 
Careful with precise definitions. However, we will take your comment into account and we will try to 
Improve the presentation of the paper even more.
