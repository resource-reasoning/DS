\makeatletter \let \proof \axp@oldproof \let \endproof \endaxp@oldproof \let \section \axp@oldsection 
\global \def \axp@protectref@ii {\ref {axp@sii}}
\axp@section {\appendixsectionformat {\protect \axp@protectref@ii }{Operational Semantics}}
\label{sec:proof-well-form-fingerprint-operations}
\begin{proposition}[Well-defined fingerprint combination operation]
\label{prop:well-formed-fp}
    Given a well-formed fingerprint \( \fp \) and an operation \( \op \in \Operations\),
    the new fingerprint \( \fp \AddOp \op \) is a well-formed fingerprint.
\end{proposition}
\begin{proof}
The operation \( \op \) may be a read or a write.
\begin{enumerate}
\Case{\(\op = \opR(\key,\val)\)}
    If there is a entry for the key \( \key \), that is,
    \( (l,\key,\val') \in \fp \) for some \( l \in \Set{\opR, \opW} \) and value \( \val' \),
    then the new fingerprint \( \fp \AddOp \op  = \fp \) is trivially well-formed.
    Otherwise, there is no entry for \( \key \)
    and the new fingerprint \( \fp \AddOp \op = \fp \uplus \opR(\key,\val) \)
    is also well-formed.
\Case{\(\op = \opW(\key,\val)\)}
    Let \( \fp' = \begin{Bracketed}
        \fp \setminus \Set{\opW(\key, \val') | \val' \in \Values} \end{Bracketed}\).
    By the definition of \AddOp,
    we have \( \fp \AddOp \op = \fp' \uplus \Set{\opW(\key, \val)} \).
    Since fingerprint \( \fp' \) contains no write operation for key \( \key \),
    \( \opW(\key, \val') \notin \fp' \) for all values \( \val' \),
    the new fingerprint \( \fp' \uplus \Set{\opW(\key, \val)}\) is a well-formed fingerprint. \qedhere
\end{enumerate}
\end{proof}
\label{sec:proof-well-formed-updatekv}
\setcounter {axp@equationx}{\c@equation }\setcounter {equation}{0}
{\pretocmd {\@begintheorem }{\patchcmd {\thmhead }{\@acmplainnotefont }{}{}{}\patchcmd {\thmhead }{\the \thm@notefont }{}{}{}\patchcmd {\thmhead }{(}{}{}{}\patchcmd {\thmhead }{)}{}{}{}}{}{} \begin {axp@theoremrp} [\ref {axp@ri}\ifdefined \thm@notefont \the \thm@notefont \fi {} (Well-defined \UpdateKV )]\axp@forward@target {axp@fw@ri}{}\axp@redefinelabels \rpleti \end {axp@theoremrp} }
\setcounter {equation}{\c@axp@equationx }
\begin {axp@oldproof}
It is easy to see that  \(\UpdateKV(\kvs,\vi,\fp,\txid) \) is always defined
as \( \fp \) contains finite number of operations.
To prove the uniqueness of \( \kvs' \), it suffice to prove that the order
in which the effect of operations is propagated to \( \kvs \) is irrelevant,
that is, two operations can swap.
Suppose \( \fp = (\fp' \uplus \Set{\op}) \uplus \Set{\op'} \)
for a fingerprint \( \fp' \) and two operations \( \op, \op' \).
We prove  the following result
\begin{Formulae}
\begin{Formula}
    \UpdateKV(\kvs,\vi,(\fp' \uplus \Set{\op}) \uplus \Set{\op'},\txid)
    = \UpdateKV(\kvs,\vi,(\fp' \uplus \Set{\op'}) \uplus \Set{\op},\txid)
\end{Formula}
\label{equ:updatekv-unique}
\end{Formulae}
\begin{enumerate}
\Case{\( \op = \opR(\key,\val)\) and \( \op' = \opR(\key',\val')\) }
    \label{item:updatekv-unique-opr-opr}
    Because \( \fp \) contains at most one read per key, then \( \key \neq \key' \).
    Let indexes \( \idx = \Max[<](\vi(\key)) \) and
    \(\idx' = \Max[<](\vi(\key')) \),
    versions \( (\val,\txid',\txidset) = \kvs(\key,\idx) \) and
    \( (\val',\txid'',\txidset') = \kvs(\key',\idx') \).
    Let the new version lists
    \( \verlist = \kvs(\key)\UpdateFunc{\idx -> (\val, \txid', \txidset \cup \Set{\txid})} \) and
    \( \verlist' = \kvs(\key')\UpdateFunc{\idx -> (\val', \txid'', \txidset' \cup \Set{\txid})} \).
    Because \( \key \neq \key' \) and \( \txid \notin \kvs \), it is easy to see
    \(\kvs\UpdateFunc{ \key -> \verlist | \key' -> \verlist' }
    = \kvs\UpdateFunc{ \key' -> \verlist' | \key -> \verlist }\),
    which implies \cref{equ:updatekv-unique}.
\Case{\( \op = \opW(\key,\val)\) and \( \op' = \opW(\key',\val')\) }
    Because \( \fp \) contains at most one write per key, then \( \key \neq \key' \).
    The proof for \cref{equ:updatekv-unique}
    is similar to \cref{item:updatekv-unique-opr-opr}.
\Case{\( \op = \opR(\key,\val)\) and \( \op' = \opW(\key',\val')\) } \label{item:opr-and-opw}
    Noting \( \key\) and \( \key' \) may be the same key.
    If \( \key \neq \key' \),
        the proof for \cref{equ:updatekv-unique} is similar to \cref{item:updatekv-unique-opr-opr}.
    Consider \( \key = \key' \).
        Let index \( \idx = \Max[<](\vi(\key)) \), version list \( \verlist = \kvs(\key)\)
        and version \( (\val,\txid',\txidset) = \verlist(\idx) \).
        Since \( \vi \in \Views(\kvs) \), the index \( idx \) must be in bound, that is, \(  0 \leq \idx < \Abs{\kvs(\key)} \),
        therefore \( \begin{Bracketed}
            \verlist\UpdateFunc{\idx -> (\val,\txid',\txidset \cup \Set{\txid}) }
            \end{Bracketed} \ListConcat \List{(\val',\txid,\emptyset)}
            = \begin{Bracketed}
            \verlist  \ListConcat \List{(\val',\txid,\emptyset)}
            \end{Bracketed} \UpdateFunc{\idx -> (\val,\txid',\txidset \cup \Set{\txid}) } \),
        which implies \cref{equ:updatekv-unique}.
\Case{\( \op = \opW(\key,\val)\) and \( \op' = \opR(\key',\val')\) }
    It is similar to \cref{item:opr-and-opw}.
\end{enumerate}
We now prove the kv-store \( \kvs' = \UpdateKV(\kvs,\vi,\fp,\txid) \) is well-formed
by showing the following result,
\begin{Formulae}
\begin{Formula}
    \WfKvs(\kvs) \land
    \Forall{ \txid' \in \kvs } (\txid, \txid') \notin \SO \land {}
    \Forall{ \key \in \Keys | \val \in \Values | \cl \in \Clients }
        \\ \begin{Bracketed}
        \opR(\key,\val) \in \fp
        \implies \Forall{\idx'} \txid \notin \RsOf(\kvs(\key,\idx'))
        \end{Bracketed}
        \\ {} \land \begin{Bracketed}
        \opW(\key,\val) \in \fp
        \implies \Forall{\idx'} \txid \neq \WtOf(\kvs(\key,\idx'))
        \end{Bracketed}
        \\ {} \land \Forall{\idx \in \vi(\key)} \txid \neq \WtOf(\kvs(\key,\idx))
        \implies \WfKvs(\kvs')
\end{Formula}
\label{equ:update-inv}
\end{Formulae}
Note that for any fresh transaction identifier \( \txid \) picked by \( \txid \in \NextTxid(\kvs,\cl) \),
it implies the hypothesis of \cref{equ:update-inv}.
We prove \cref{equ:update-inv} by induction on the size of \( \fp \).
\begin{enumerate}
\CaseBase{\Abs{\fp} = 0}
    In this case, we know \( \kvs' = \UpdateKV(\kvs,\vi,\emptyset,\txid) = \kvs \),
    therefore \( \WfKvs(\kvs') \).
\CaseInd{\(\Abs{\fp} > 0\)}
    The next operation may be a read or a write operation.
    \begin{enumerate}
    \Case{\(\fp = \fp' \uplus \opR(\key,\val)\)}
        Let index \( \idx = \Max[<](\vi(\key)) \),
        old version \( (\val,\txid',\txidset) = \kvs(\key,\idx) \),
        and new version list \( \verlist = \kvs(\key)\UpdateFunc{i -> (\val, \txid', \txidset \uplus \Set{\txid})} \).
        The intermediate kv-store \( \kvs^* \) is defined by \( \kvs^* = \kvs\UpdateFunc{\key -> \verlist} \).
        Since the original kv-store \( \kvs \) satisfies \cref{equ:update-inv},
        the fresh transaction identifier \( \txid \not\in \RsOf(\kvs(\key,\idx'))\)
        for all \( \idx' \) such that \( 0 \leq \idx' < \Abs{\kvs(\key)} \),
        and therefore  \(\kvs^*\) satisfies  the well-formed condition
        \cref{{equ:kvs-wf-txid-snapshot-property}} in \cref{def:well-formed-kv-store};
        because \( (\txid, \txid') \not\in \SO \) for any \( \txid' \in \kvs \),
        (It is only possible \( (\txid', \txid) \in \SO \)
        for some \( \txid' = \kvs(\key,\idx')\) where \( \idx' \in \vi(\key) \)),
        and \( \txid \neq \WtOf(\kvs(\key'',\idx'')) \) for \( \key'',\idx'' \) such that \( \idx'' \in \vi(\key'')\),
        therefore \( \kvs^* \) satisfies \cref{equ:kvs-wf-so-wr}.
        \Cref{equ:kvs-wf-init-version,equ:kvs-wf-so-ww} are trivially true for \( \kvs^* \).
        We proved the intermediate kv-store \( \kvs^*\) is well-formed, \( \WfKvs(\kvs^*)\).
        As \( \fp \) is well-formed, it follows that \( \opR(\key,\val') \not\in \fp' \),
        which means that \( \kvs^*, \fp',\vi,\txid \) satisfy the invariant \cref{equ:update-inv}.
        By \ih the final kv-store \( \kvs' = \UpdateKV(\kvs^*,\vi,\fp',\txid)\)  is a well-formed kv-store.
    \Case{\(\fp = \fp' \uplus \opW(\key,\val)\)}
        Let new version list \( \verlist = \kvs(\key)\ListConcat \List{ (\val, \txid, \emptyset)} \).
        The intermediate kv-store \( \kvs^* \) is defined by \( \kvs^* = \kvs\UpdateFunc{\key -> \verlist} \).
        Since the original kv-store \( \kvs \) satisfies \cref{equ:update-inv},
        the fresh identifier \( \txid \neq \WtOf(\kvs(\key,\idx'))\)
        for all \( \idx' \) such that \( 0 \leq \idx' < \Abs{\kvs(\key)} \),
        therefore \( \kvs^*\) satisfies \cref{{equ:kvs-wf-txid-snapshot-property}};
        because \( (\txid, \txid') \not\in \SO \) for any \( \txid' \in \kvs \)
        (It is only possible \( (\txid', \txid) \in \SO \) for some \( \txid' \) in \(\kvs(\key) \)),
        and \( \txid \) wrote the last version for \( \key \) in \( \kvs^*\),
        therefore \( \kvs^* \) satisfies \cref{equ:kvs-wf-so-ww}
        \Cref{equ:kvs-wf-init-version,equ:kvs-wf-so-wr} are trivially true for \( \kvs^* \).
        We proved the intermediate kv-store is well-fumed, \( \WfKvs(\kvs^*) \).
        As \( \fp \) is well-formed, it follows \( \opW(\key,\val') \not\in \fp' \),
        which means that \( \kvs^*, \fp',\vi,\txid \) satisfy the invariant \cref{equ:update-inv}.
        By \ih the final kv-store \( \kvs' = \UpdateKV(\kvs^*,\vi,\fp',\txid)\) is a well-formed kv-store. \qedhere
    \end{enumerate}
\end{enumerate}
\end {axp@oldproof}
\label{sec:proof-equivalent-normal-trace}
\setcounter {axp@equationx}{\c@equation }\setcounter {equation}{3}
{\pretocmd {\@begintheorem }{\patchcmd {\thmhead }{\@acmplainnotefont }{}{}{}\patchcmd {\thmhead }{\the \thm@notefont }{}{}{}\patchcmd {\thmhead }{(}{}{}{}\patchcmd {\thmhead }{)}{}{}{}}{}{} \begin {axp@theoremrp} [\ref {axp@rii}\ifdefined \thm@notefont \the \thm@notefont \fi {} (Equivalent normal \et -traces)]\axp@forward@target {axp@fw@rii}{}\axp@redefinelabels \rpletii \end {axp@theoremrp} }
\setcounter {equation}{\c@axp@equationx }
\begin {axp@oldproof}
Let initially \( \ettrc^* = \ettrc \);
we alters the trace until \( \ettrc^*\) is a normal trace.
\begin{enumerate}
\item \label{item:delete-last-view}
    Consider the last step \lb for each client \( \cl \) such that
    \begin{Formulae}*
    \begin{Formula}
    \ettrc^* =  \ToRed{\ettrc' | \lb -> \ettrc'' }  \land \lb = \lbCl{\alpha}
    \land \Forall{\cl'} \ettrc'' = \ToRed{\cdots | \lbCl[\cl']{\stub} -> \cdots }
    \implies \cl \neq \cl'
    \end{Formula}
    \end{Formulae}
    for two trace segments \( \ettrc',\ettrc'' \).
    Let view \( \vi = \LastConf(\ettrc')\Proj{2}(\cl)\).
    If \( \lb \) is a view shift step,
    \ie \( \alpha = \vi' \) for some view \( \vi' \) such that \( \vi \vileq \vi' \),
    we delete this step and re-assign the configurations
    in \( \ettrc'' \) resulting a new segment \( \ettrc^\dagger \) such that
    \[
        \Forall{\idx \in \Indexs | \kvs \in \KVSs | \vienv \in \ViewEnvs(\kvs) }
        \ettrc''\Proj{\idx} = (\kvs,\vienv) \iff \ettrc^\dagger\Proj{\idx} = (\kvs,\vienv\UpdateFunc{ \cl -> \vi}).
    \]
    We rename the new trace as \( \ettrc^* \) and go back \cref{item:delete-last-view}.
    Because trace \( \ettrc^* \)  has finite steps, \cref{item:delete-last-view} must terminate
    with trace \( \ettrc^* \) that satisfies:
    \begin{Formulae}
    \begin{Formula}
    \Forall{\lb \in \Labels | \cl, \cl' \in \Clients | \alpha | \ettrc',\ettrc''}
    \\
    \begin{Bracketed}
    \ettrc^* =  \ToRed{\ettrc' | \lb -> \ettrc'' }  \land \lb = \lbCl{\alpha}
    \land \ettrc''  =  \ToRed{\cdots | \lbCl[\cl']{\stub} -> \cdots}
    \implies \cl \neq \cl'
    \end{Bracketed}
    \implies \alpha \in \Fingerprints. \label{equ:last-step-must-be-update}
    \end{Formula}
    \end{Formulae}
\item \label{item:view-shift-move-right}
    Given a trace \( \ettrc^* \) satisfying \cref{equ:last-step-must-be-update},
    consider the first view-shift step \lb for a client \( \cl \)
    that is not followed by a step for the same client \( \cl \):
    \( \ettrc^* =  \ToRed{\ettrc' | \lb -> \conf | \lb' -> \ettrc'' } \)
    such that \( \lb = \lbView{\vi} \) and \( \lb' = \lbCl[\cl']{\alpha} \)
    for some \( \alpha\),
    view \( \vi \) and some clients \( \cl, \cl' \) with \( \cl \neq \cl' \).
    By \cref{lem:view-shift-right-move} we can move step \( \lb \) to the right resulting
    \(  \ToRed{\ettrc' | \lb' ->  \conf^* | \lb -> \ettrc''} \) for some \( \conf^* \),
    until the immediate next step is for the same client \( \cl \).
    Note that there must be a step for the same client \( \cl \) in \( \ettrc'' \)
    by \cref{equ:last-step-must-be-update}.
    We rename the new trace as \( \ettrc^* \) and go back to \cref{item:view-shift-move-right}.
    Because there are only finite steps
    and the number of out-of-order view-shifts decreases after each iteration,
    \cref{item:view-shift-move-right} must terminate with trace \( \ettrc^* \) such that
    \begin{Formulae}
    \begin{Formula}
    \Forall{\lb,\lb' \in \Labels | \cl \in \Clients | \vi \in \Views | \ettrc',\ettrc''}
    \\ \ettrc^* =  \ToRed{\ettrc' | \lb -> \conf | \lb' -> \ettrc''}
    \land \lb = \lbView{\vi}
    \implies \lb' = \lbCl[\cl]{\stub}.
    \label{equ:view-shift-followed-same-client-step}
    \end{Formula}
    \end{Formulae}
\item \label{item:view-shift-absorb}
    Given a trace \( \ettrc^* \) satisfying
    \cref{equ:last-step-must-be-update,equ:view-shift-followed-same-client-step},
    consider the two adjacent view-shifts steps \(\lb, \lb'\) such that
    \( \ettrc^* =  \ToRed{\ettrc' | \lb -> \conf | \lb' -> \ettrc''} \)
    where \( \lb = \lbView{\vi} \) and \( \lb' = \lbCl{\vi'} \) for two views \( \vi,\vi'\).
    By \cref{lem:view-shift-absorb}, we can merge these two steps resulting
    \(  \ToRed{\ettrc' | \lb' -> \ettrc'' }  \) and go back to \cref{item:view-shift-absorb}.
    Because there are only finite steps
    and the number of two adjacent view-shifts decreases after each iteration,
    \cref{item:view-shift-absorb} must terminate with trace \( \ettrc^* \) such that
    \begin{Formulae}
    \begin{Formula}
    \Forall{\lb,\lb' \in \Labels | \cl \in \Clients | \vi \in \Views | \ettrc',\ettrc''}
    \\ \ettrc^* =  \ToRed{\ettrc' | \lb -> \conf | \lb' -> \ettrc'' }
    \land \lb = \lbView{\vi}
    \implies \Exists{\fp \in \Fingerprints}
    \lb' = \lbFp{\fp}.
    \label{equ:view-shift-followed-update}
    \end{Formula}
    \end{Formulae}
\item \label{item:add-view-shift}
    Last, given a trace \( \ettrc^* \) satisfying
    \cref{equ:last-step-must-be-update,equ:view-shift-followed-same-client-step,equ:view-shift-followed-update},
    consider an update step \( \lb' \) without a view-shift predecessor,
    that is, \( \ettrc^* =  \ToRed{\ettrc' | \lb -> \conf | \lb' -> \ettrc''} \)
    such that \( \lb = \lbView{\fp} \) and \( \lb' = \lbCl[\cl']{\fp'} \)
    for some fingerprints \( \fp,\fp'\) and
    clients \( \cl, \cl' \) with \( \cl \neq \cl' \).
    We inject an identity view shift in between resulting
    \(  \ToRed{\ettrc' | \lb -> \conf | \lbView{\conf\Proj{2}(\cl)} -> \conf | \lb' -> \ettrc''} \).
    Rename the new trace as \( \ettrc^* \) and go back to \cref{item:add-view-shift}.
    Because there are only finite steps, \cref{item:add-view-shift} must
    terminate with trace \( \ettrc^* \) satisfying
    \begin{Formulae}
    \begin{Formula}
    \Forall{\lb,\lb' \in \Labels | \cl \in \Clients | \fp \in \Fingerprints | \ettrc',\ettrc''}
    \\ \ettrc^* =  \ToRed{\ettrc' | \lb -> \conf | \lb' -> \ettrc''}
    \land \lb' = \lbFp{\fp}
    \implies \Exists{\vi \in \Views}
    \lb' = \lbView{\vi}.
    \label{equ:update-impede-view}
    \end{Formula}
    \end{Formulae}
\end{enumerate}
Now we have an equivalent trace \( \ettrc^* \) such that \( \ettrc \ettrceq \ettrc^* \)
and \Cref{equ:view-shift-followed-update,equ:update-impede-view} imply \( \NormalTrace(\ettrc^*) \).
\end {axp@oldproof}
\begin{lemma}[View-shift right move]
\label{lem:view-shift-right-move}
Given a trace \( \ettrc \in \ETTraces(\et) \) for some \( \et \),
and a view-shift step \( \lbView{\vi} \) for a client \( \cl \) in the trace \( \ettrc \),
if the view-shift is not followed by a step for the same client \( \cl \),
this view-shift can be moved right without changing the final configuration.
\begin{Formulae}
\begin{Formula}
    \Forall{ \cl' \in \Clients | \lb,\lb' \in \Labels | \alpha, \ettrc',\ettrc'' }
    \\ \ettrc =  \ToRed{\ettrc' | \lb -> \conf | \lbView{\vi} -> \conf' | \lbCl[\cl']{\alpha}
                    -> \conf'' | \lb' -> \ettrc''}
    \land \cl \neq \cl'
    \\ \implies \Exists{\conf^* \in \Confs }
    \ToRed{\ettrc' | \lb -> \conf | \lbCl[\cl']{\alpha}
        -> \conf^* | \lbView{\vi} -> \conf'' | \lb' -> \ettrc''}.
    \label{equ:view-left-move}
\end{Formula}
\end{Formulae}
\end{lemma}
\begin{proof}
Let configuration \( (\kvs, \vienv) = \conf \); we preform case analysis on \( \alpha \).
\begin{enumerate}
    \Case{\(\alpha=\vi'\)}
    Given the two view-shifts for clients \( \cl \) and \( \cl' \) respectively,
    we know the configuration \( \conf'' \)  is given by
    \( \conf'' = \Tuple{\kvs, \vienv\UpdateFunc{\cl -> \vi | \cl' -> \vi' }} \).
    Since two clients are distinct \( \cl \neq \cl' \),
    then we have \( \conf'' = \Tuple{\kvs, \vienv\UpdateFunc{ \cl' -> \vi' | \cl -> \vi }} \);
    therefore we prove \cref{equ:view-left-move} by picking \( \conf^* = \Tuple{\kvs, \vienv\UpdateFunc{\cl' -> \vi' }}\).
    \Case{\(\alpha=\fp\)}
    Since \( \cl \neq \cl' \),
    we know \( \conf' = \Tuple{\kvs, \vienv\UpdateFunc{\cl -> \vi }} \)
    and \( \conf'' = \Tuple{\kvs', \vienv\UpdateFunc{ \cl -> \vi | \cl' -> \vi' }} \)
    for some view \( \vi' \),
    kv-store \( \kvs' = \UpdateKV(\kvs,\vienv(\cl'),\fp,\txid) \) with a fresh transition identifier \( \txid \),
    and \( \ToET{ \kvs | \vienv(\cl') | \fp | \kvs' | \vi' } \).
    Let \( \conf^* = \Tuple{\kvs', \vienv\UpdateFunc{ \cl' -> \vi' }}\) which gives us \cref{equ:view-left-move}. \qedhere
\end{enumerate}
\end{proof}


\begin{lemma}[View-shift absorption]
\label{lem:view-shift-absorb}
Given a trace \( \ettrc \in \ETTraces(\et) \) under \et,
two adjacent view-shifts \( \lbView{\vi},\lbView{\vi'} \) for a client \( \cl \) in the trace can be merged,
\begin{Formulae}
\begin{Formula}
    \Forall{ \ettrc',\ettrc'' | \lb,\lb' \in \Labels}
    \\ \ettrc = \ToRed{\ettrc' | \lb -> \conf | \lbView{\vi} -> \conf' | \lbView{\vi'}
        -> \conf'' | \lb' -> \ettrc''}
    \implies  \ToRed{\ettrc' | \lb -> \conf | \lbView{\vi'} -> \conf'' | \lb' ->  \ettrc''}.
    \label{equ:view-absorb}
\end{Formula}
\end{Formulae}
\end{lemma}
\begin{proof}
Let configuration \( (\kvs, \vienv ) = \conf \);
it is easy to see \( \conf = (\kvs, \vienv\UpdateFunc{\cl -> \vi})\), \( \conf = (\kvs, \vienv\UpdateFunc{\cl -> \vi'}) \)
and \( \vienv(\cl) \vileq \vi \vileq \vi' \), which implies \cref{equ:view-absorb}.
\end{proof}
\label{sec:proof-equivalent-expressibility}
\setcounter {axp@equationx}{\c@equation }\setcounter {equation}{3}
{\pretocmd {\@begintheorem }{\patchcmd {\thmhead }{\@acmplainnotefont }{}{}{}\patchcmd {\thmhead }{\the \thm@notefont }{}{}{}\patchcmd {\thmhead }{(}{}{}{}\patchcmd {\thmhead }{)}{}{}{}}{}{} \begin {axp@theoremrp} [\ref {axp@riii}\ifdefined \thm@notefont \the \thm@notefont \fi {} (Equivalent expressibility)]\axp@forward@target {axp@fw@riii}{}\axp@redefinelabels \rpletiii \end {axp@theoremrp} }
\setcounter {equation}{\c@axp@equationx }
\begin {axp@oldproof}
We prove \( \CMET(\et) \supseteq \bigcup_{\prog \in \Programs} \EvalET{\prog} \)
and \( \CMET(\et) \subseteq \bigcup_{\prog \in \Programs} \EvalET{\prog} \) respectively.
\begin{enumerate}
\Case{\(\bigcup_{\prog \in \Programs} \EvalET{\prog} \subseteq \CMET(\et)\)}
    By definition of \( \bigcup_{\prog \in \Programs} \EvalET{\prog} \) It is sufficient to prove that
    for any trace \( \progtrc \),
    initial configuration \( (\kvsinit,\vienvinit, \clenv_0) \) and
    final configuration \( (\kvs, \vienv, \clenv) \) with program \( \prog' \),
    \begin{Formulae}
    \begin{Formula}
    \Dom(\prog) \subseteq \Dom(\clenv)
    \land \progtrc = \ToProg{ \kvsinit | \vienvinit | \clenv_0 | \prog | \stub | *
                                    -> \kvs | \vienv | \clenv | \prog' }
    \\ \implies \ToRed{\kvsinit | \vienvinit | \stub | * -> \kvs' | \vienv'  }.
    \label{equ:prog-trace-to-et-trace}
    \end{Formula}
    \end{Formulae}
    We prove \cref{equ:prog-trace-to-et-trace} by induction on the length of the trace \( \progtrc \).
    \begin{enumerate}
    \CaseBase{\(\progtrc = \ToProg{ \kvsinit | \vienvinit | \clenv_0 | \prog }\)}
        \Cref{equ:prog-trace-to-et-trace} trivially holds.
    \CaseInd{\(\progtrc =
             \ToProg{\kvsinit| \vienvinit | \clenv_0 | \prog | \stub | n
                    ->  \kvs' | \vienv' | \clenv' | \prog'' | \lb
                    -> \kvs | \vienv | \clenv | \prog' } \)}
        By \ih, there must exist a \et-trace \( \ettrc \) such that
        \( \ettrc =  \ToRed{\kvsinit | \vienvinit | \stub | * -> \kvs' | \vienv'} \).
        We append steps to \et-trace \( \ettrc \) depending on the step \( \lb \).
        \begin{enumerate*}
        \Case{\( \lb = \lbPri \)}
            This means \( \kvs' = \kvs'' \) and \(\vienv' = \vienv'' \),
            and we immediately have the proof for \cref{equ:prog-trace-to-et-trace} with \et-trace \ettrc.
        \Case{\( \lb = \lbTrans{\vi,\fp} \)}
            This means \( \kvs' = \UpdateKV(\kvs'',\vi,\fp,\txid) \) and \(\vienv' = \vienv''\UpdateFunc{\cl -> \vi' } \)
            for a fresh \( \txid \) and a view \( \vi' \) such that \( \ToET{\kvs'' | \vi | \fp | \kvs' | \vi'} \).
            Let the new \et-trace \( \ettrc' \) be
            \(
                \ettrc' =  \ToRed{\ettrc | \lbView{\vi} ->  \kvs'' | \vienv''\UpdateFunc{\cl -> \vi} | \lbFp{\fp} -> \kvs' | \vienv' }
            \)
            which implies \cref{equ:prog-trace-to-et-trace}.
        \end{enumerate*}
    \end{enumerate}
\Case{\(\CMET(\et) \subseteq \bigcup_{\prog \in \Programs} \EvalET{\prog} \)}
    Since there exist equivalent normal traces for all traces in \( \CMET(\et) \) by \cref{thm:normal-trace},
    it is sufficient to prove that for any trace \( \ettrc \in \CMET(\et) \),
    initial configuration \( (\kvsinit,\vienvinit) \) and final configuration \( (\kvs, \vienv) \),
    \begin{Formulae}
    \begin{Formula}
    \NormalTrace(\ettrc)
    \land \ettrc =  \ToRed{ \kvsinit | \vienvinit | \stub | * -> \kvs | \vienv }
    \implies
    \\ \Exists{ \clenv_0,\clenv \in \ClientEnvs | \prog,\prog' \in \Programs }
    \\ \Dom(\prog) = \Dom(\clenv_0)
    \land  \ToProg{\kvsinit | \vienvinit | \clenv_0 | \prog | \stub | *
                            -> \kvs | \vienv | \clenv| \prog' }
    \\ \land \Forall{\cl \in \Dom(\prog')} \prog'(\cl) = \pskip .
    \label{equ:et-trace-to-prog-trace}
    \end{Formula}
    \end{Formulae}
    We prove \cref{equ:et-trace-to-prog-trace} by induction on the length of the trace \( \ettrc \).
    Note that the number of steps in trace \( \ettrc \) must be an \emph{even} number.
    \begin{enumerate}
    \CaseBase{\(\ettrc =  \ToRed{ \kvsinit | \vienvinit }\)}
        We pick \( \prog = \vienv_0 = \emptyset \) and
        \( \progtrc = \ToProg{ \kvsinit | \vienvinit | \vienv_0 | \prog } \)
        that implies \cref{equ:et-trace-to-prog-trace}.
    \CaseInd{\( \ettrc = \ToRed{ \kvsinit | \vienvinit | \stub | n -> \kvs' | \vienv' | \lbView{\vi}
                -> \kvs' | \vienv'\UpdateFunc{\cl -> \vi} | \lbFp{\fp} -> \kvs | \vienv } \)}
        By \ih, there must be a program trace \( \progtrc \) such that
        \[
            \progtrc =  \ToProg{\kvsinit | \vienvinit | \clenv_0 |\prog | \stub | *
                -> \kvs' | \vienv' | \clenv' | \prog' }
            \land \Forall{\cl \in \Dom(\prog')} \prog'(\cl) = \pskip.
        \]
        for client environment \(\clenv_0, \clenv' \) and program \( \prog' \).
        We now construct a new initial by extending a new transaction for client \( \cl \);
        this transaction has the fingerprint \( \fp \).
        Recall that a well-formed fingerprint contains at most one read and one write for each key.
        We define the transactional command for fingerprint \( \fp \), written \( \TransFp(\fp)\) as the following:
        \begin{align*}
           \TransFp(\emptyset) & \FuncDef \pskip ,
        \\ \TransFp(\fp \uplus \opR(\key,\val)) & \FuncDef
            \plookup{\var}{\key} \pseq \TransFp(\fp)  ,
        \\ \TransFp(\fp \uplus \opW(\key,\val)) & \FuncDef
            \begin{multlined}[t]
            \pmutate{\key}{\val} \pseq \TransFp(\fp)
            \\ \text{where} \ \Forall{\key' \in \Keys | \val' \in \Values} \opR(\key',\val') \notin \fp .
            \end{multlined}
        \end{align*}
        We then define a function that extends the command for a client:
        \[
        \ExtendProgram(\prog, \cl, \cmd) \FuncDef
        \begin{cases}
            \prog\UpdateFunc{ \cl -> ( \cmd' \pseq \cmd)} & \text{if} \ \prog(\cl) = \cmd'
            \\ \prog\uplus \Set{ \cl \mapsto \cmd} & \ow
        \end{cases}
        \]
        Let transactional command \( \trans = \TransFp(\fp) \),
        the new initial program as \( \ExtendProgram(\prog', \cl, \ptrans{\trans}) \)
        and the new final program \( \prog'' = \ExtendProgram(\prog', \cl, \ptrans{\trans}) \);
        and consequently apply \( \ExtendProgram \) to all intermediate programs.
        This means, we have a new trace \( \progtrc' \) such that
        \begin{Formulae}*
        \begin{Formula}
            \progtrc' = \ToProg{\kvsinit | \vienvinit | \clenv_0
                                            | \ExtendProgram(\prog, \cl, \ptrans{\trans}) | \stub | *
                                -> \kvs' | \vienv' | \clenv' | \prog''  }
            \\ {} \land \Forall{\cl' \in \Dom(\prog'')}
            \begin{Bracketed} \cl = \cl' \implies \prog''(\cl') = \ptrans{\trans} \end{Bracketed}
            \land \begin{Bracketed} \cl \neq \cl' \implies \prog''(\cl') = \pskip \end{Bracketed} .
        \end{Formula}
        \end{Formulae}
        The only next step for \( \progtrc' \) is to execute the \( \ptrans{\trans} \) for \( \cl \).
        Recall that \[ \ToRed{ \kvs' | \vienv'\UpdateFunc{\cl -> \vi} | \lbFp{\fp} -> \kvs | \vienv }. \]
        Given \rCAtomicTrans shown in \cref{fig:command-semantics},
        the client local stack is \( \stk = \clenv'(\cl)\) and the initial snapshot \( \snap \) for
        \( \trans \) is \( \snap =  \Snapshot(\kvs', \vi) \).
        By the hypothesis, we know that \( \ToET{\kvs' | \vi | \fp | \kvs' | \vienv(\cl) }  \)
        and by well-formed condition for \( \et \), we know
        \[
        \Forall{\key \in \Keys | \val \in \Values } \opR(\key,\val) \in \fp \implies \snap(\key) = \val ,
        \]
        which implies
        \( \ToTrans{\stk | \snap | \emptyset | \trans  | * -> \stk' | \snap' | \fp | \pskip } \)
        for some stack \( \stk' \) and snapshot \( \snap \).
        By \( \ToET{\kvs' | \vi | \fp | \kvs' | \vienv(\cl) } \),
        \( \CanCommit(\kvs,\vi,\fp)\) and \( \ViewShift(\kvs,\vi,\kvs',\vienv(\cl)) \) must hold.
        Thus we have a trace such that
        \[
         \ToCmd{\progtrc' | \lbTrans{\vi,\fp} -> \kvs | \vienv | \clenv'\UpdateFunc{\cl -> \stk'} | \prog^* }
        \land \Forall{\cl \in \Dom(\prog^*)} \prog^*(\cl) = \pskip
        \]
        for some program \( \prog^* \), which implies \cref{equ:et-trace-to-prog-trace}. \qedhere
    \end{enumerate}
\end{enumerate}
\end {axp@oldproof}
\global \def \axp@protectref@iii {\ref {axp@siii}}
\axp@section {\appendixsectionformat {\protect \axp@protectref@iii }{Correctness of Execution Tests}}
\label{sec:proof-kv-to-dep-graph}
\begin{proposition}[Well-defined \(\KToD\)]
\label{prop:ktod-well-defined}
Given a kv-store \( \kvs \in \KVSs \),
the dependency graph induced by the kv-store \( \KToD(\kvs) \) is well-formed,
that is, \( \KToD(\kvs) \in \DependencyGraphs\).
\end{proposition}
\begin{proof}
First we prove the dependency graph \( \KToT(\kvs) \) match the type constraint of the nodes.
Consider a transaction \( \txid \in \kvs \).
\begin{enumerate}
\Case{\( \txid = \txidinit \)}
    By the definition of versions \( \Versions \), \( \txidinit \) cannot in any reader set;
    By well-formedness of \( \kvs \), the initial transaction wrote the first version for each key (\cref{equ:kvs-wf-init-version});
    and it only wrote those versions (snapshot property in \cref{equ:kvs-wf-txid-snapshot-property}).
    Therefore \( \KToT(\kvs)(\txidinit) = \Set{\opW(\key,\valinit) | \key \in \Keys \land \valinit \in \InitVal(\key) } \).
\Case{\( \txid \neq \txidinit \)}
    By snapshot property of \( \kvs \) (\cref{equ:kvs-wf-txid-snapshot-property}),
    it is easy to see that \( \KToT(\kvs)(\txid) \in \Fingerprints\).
\end{enumerate}
Let \( \WR = \WR[\kvs], \WW = \WW[\kvs] , \RW= \RW[\kvs]\).
Now we prove that the relations are well-formed.
\begin{enumerate}
\Case{write-read dependency \(\WR\)}
    \begin{enumerate}
    \item Suppose a transaction \( \txid \) such that \( \opR(\key,\stub) \in \KToT(\kvs)(\txid) \).
        There exists a version \( \kvs(\key,\idx) \) for a key \( \key \) and an index \( \idx \),
        such that \( \txid \in \RsOf(\kvs(\key,\idx))\).
        We have \( (\WtOf(\kvs(\key,\idx)),\txid) \in \WR \) which implies \cref{equ:dgraph-wr-def}.
    \item Suppose transactions \( \txid, \txid'\) such that \( (\txid, \txid') \in \WR \).
        By definition of \( \WR \), there exists a version \( \kvs(\key,\idx) \)
        for a key \( \key \) and an index \( \idx \), such that \( \txid = \WtOf(\kvs(\key,\idx))\)
        and \( \txid' \in \RsOf(\kvs(\key,\idx))\), which immediately implies \cref{equ:dgraph-wr-minimum}.
    \item Suppose transactions \( \txid, \txid'\) such that \( (\txid, \txid') \in \WR \).
        By definition of \( \WR \), there exists a version \( \kvs(\key,\idx) \)
        for a key \( \key \) and an index \( \idx \), such that \( \txid = \WtOf(\kvs(\key,\idx))\)
        and \( \txid' \in \RsOf(\kvs(\key,\idx))\).
        Because \(\kvs\) is well-formed (\cref{equ:kvs-wf-so-wr}), it must be the case that \((\txid,\txid') \notin \SO \),
        which implies \cref{equ:dgraph-wr-so}.
    \item Suppose transactions \( \txid, \txid', \txid''\) such that \( (\txid', \txid), (\txid'', \txid)\in \WR \).
        There exist two versions \(\kvs(\key,\idx),\kvs(\key,\idx') \)
        for a key \( \key \) and indexes \( \idx,\idx' \), such that \( \txid \in \RsOf(\kvs(\key,\idx))\)
        and \( \txid \in \RsOf(\kvs(\key,\idx'))\).
        Because \(\kvs\) is well-formed (\cref{equ:kvs-wf-txid-snapshot-property}),
        it must be the case that \( \idx = \idx' \) which means that \( \txid' = \txid'' = \WtOf(\kvs(\key,\idx)) \)
        and thus \cref{equ:dgraph-wr-unique}.
    \end{enumerate}
\Case{write-write dependency \(\WW\)}
    \begin{enumerate}
    \item Suppose transactions \( \txid, \txid' \) such that
        \( \opW(\key,\stub) \in \KToT(\kvs)(\txid) \) and \( \opW(\key,\stub) \in \KToT(\kvs)(\txid') \).
        There exist two versions \(\kvs(\key,\idx),\kvs(\key,\idx') \)
        for a key \( \key \) and indexes \( \idx,\idx' \), such that
        \( \txid = \WtOf(\kvs(\key,\idx))\) and \( \txid' = \WtOf(\kvs(\key,\idx'))\).
        If \( \idx = \idx'\) then \( \txid = \txid' \);
        if \( \idx < \idx' \) or \( \idx > \idx' \),
        then \( (\txid,\txid') \in \WW \) or \( (\txid',\txid) \in \WW \) respectively.
        Thus we prove \cref{equ:dgraph-ww-def}.
    \item Suppose transactions \( \txid, \txid'\) such that \( (\txid, \txid') \in \WW \).
        There exist two versions \(\kvs(\key,\idx),\kvs(\key,\idx') \)
        for a key \( \key \) and indexes \( \idx,\idx' \)
        \( \txid = \WtOf(\kvs(\key,\idx))\) and \( \txid' = \WtOf(\kvs(\key,\idx'))\),
        which immediately implies \cref{equ:dgraph-ww-minimum}.
    \item Suppose transactions \( \txid, \txid'\) such that \( (\txid, \txid') \in \WW \).
        We prove \( \txid' \neq \txidinit \) by contradiction.
        Assume \( \txid' = \txidinit \).
        There exist a version \(\kvs(\key,\idx)\) for a key \( \key \) and an index \( \idx > 0 \),
        such that \( \txidinit = \WtOf(\kvs(\key,\idx))\).
        However, \( \txidinit = \WtOf(\kvs(\key,0)) \) by well-formedness;
        there are two versions for \( \key \) written by \( \txidinit \)
        which contradicts \cref{equ:kvs-wf-txid-snapshot-property}.
        Therefore \cref{equ:dgraph-ww-init} holds.
    \item Suppose transactions \( \txid, \txid'\) such that \( (\txid, \txid') \in \WW \).
        There exist two versions \(\kvs(\key,\idx),\kvs(\key,\idx') \)
        for a key \( \key \) and indexes \( \idx,\idx' \), such that \( \idx < \idx' \),
        \( \txid = \WtOf(\kvs(\key,\idx))\) and \( \txid' = \WtOf(\kvs(\key,\idx'))\).
        Because \(\kvs\) is well-formed (\cref{equ:kvs-wf-so-ww}),
        it must be the case that \((\txid',\txid) \notin \SO \),
        which implies \cref{equ:dgraph-ww-so}.
    \item Suppose transactions \( \txid, \txid'\) such that \( (\txid, \txid') \in \WW \).
        We prove \( \txid \neq \txid' \) by contradiction.
        Assume \( \txid = \txid' \).
        There exist two versions \(\kvs(\key,\idx),\kvs(\key,\idx') \)
        for a key \( \key \) and indexes \( \idx,\idx' \), such that
        \( \txid = \WtOf(\kvs(\key,\idx)) = \WtOf(\kvs(\key,\idx'))\);
        this contradicts \cref{equ:kvs-wf-txid-snapshot-property}.
        Thus \cref{equ:dgraph-ww-irreflexive} holds.
    \item Suppose transactions \( \txid, \txid', \txid''\) such that
        \( (\txid, \txid'),(\txid', \txid'') \in \WW \).
        There exist versions \(\kvs(\key,\idx),\kvs(\key,\idx'),\kvs(\key,\idx'') \)
        for a key \( \key \) and indexes \( \idx,\idx' \), such that \( \idx < \idx' < \idx'' \),
        \( \txid = \WtOf(\kvs(\key,\idx))\), \( \txid' = \WtOf(\kvs(\key,\idx'))\),
        and \( \txid'' = \WtOf(\kvs(\key,\idx''))\).
        By definition of \( \WW \), it must be the case that \( (\txid, \txid'') \in \WW \),
        which implies \cref{equ:dgraph-ww-transitive}.
    \end{enumerate}
\Case{read-write anti-dependency \(\RW\)}
    Suppose transactions \( \txid, \txid'\) such that
    \begin{Formulae}
    \begin{Formula}
    \txid \neq \txid' \land (\txid, \txid') \in \RW .
    \label{equ:kv-to-dgraph-rw-def}
    \end{Formula}
    \end{Formulae}
    \Cref{equ:kv-to-dgraph-rw-def} holds iff
    there a transaction \( \txid'' \) and two versions \(\kvs(\key,\idx),\kvs(\key,\idx') \)  such that
    \( \idx < \idx' \), \( \txid \in \RsOf(\kvs(\key,\idx)) \) and \( \txid' = \WtOf(\kvs(\key,\idx')) \);
    this means that
    \begin{Formulae}
    \begin{Formula}
    (\WtOf(\kvs(\key,\idx)),\txid) \in \WR \land (\WtOf(\kvs(\key,\idx)),\txid') \in \WW \land \txid \neq \txid' .
    \label{equ:kv-to-dgraph-rw-in-kv}
    \end{Formula}
    \end{Formulae}
    Since \cref{equ:kv-to-dgraph-rw-def} implies \cref{equ:kv-to-dgraph-rw-in-kv} and vice versa,
    we have the proof for \cref{equ:dgraph-rw}. \qedhere
\end{enumerate}
\end{proof}
%\begin{proofsketch}
%Given a kv-store \( \kvs \), it is easy to see that
%\[
%\KToT(\kvs) \in \begin{Bracketed} \begin{Bracketed} \TxIDZs \ToPFFunc \Fingerprints
            %\end{Bracketed} \uplus \Mapping{\txidinit -> \Set{\opW(\key,\valinit)
                        %| \key \in \Keys }} \end{Bracketed} .
%\]
%Let \( \dgraph = \KToD(\kvs)\).
%By the definition of \( \KToD\),
%we have \( \WR[\kvs] = \WR[\dgraph]\), \( \WW[\kvs] = \WW[\dgraph]\)
%and \( \RW[\kvs] = \RW[\dgraph]\).
%By the definitions of dependency relations on kv-store in \cref{def:dependency-kv-store},
%it is easy to see that these relations on \( \dgraph \) satisfy
%\cref{equ:dgraph-wr-minimum,equ:dgraph-wr-def,equ:dgraph-wr-so,equ:dgraph-wr-unique,equ:dgraph-ww-def,equ:dgraph-ww-minimum,equ:dgraph-ww-irreflexive,equ:dgraph-ww-transitive,equ:dgraph-ww-init,equ:dgraph-ww-so,equ:dgraph-rw}
%in \cref{def:dgraph}.
%The full proof is in \cref{sec:proof-kv-to-dep-graph} on page \pageref{sec:proof-kv-to-dep-graph}.
%\end{proofsketch}
\label{sec:proof-dep-graph-to-kvs}
\begin{proposition}[Well-defined \(\DToK\)]
\label{prop:dtok-well-defined}
Given a dependency graph \( \dgraph \in \DependencyGraphs \),
the kv-store induced by dependency graph, \( \DToK(\dgraph) \), is well-formed,
that is, \( \DToK(\dgraph) \in \KVSs\).
\end{proposition}
\begin{proof}
Let \( \kvs = \DToK(\dgraph) \).
Given a key \( \key \), by the well-formedness definition for kv-store,
it is sufficient to prove the following cases.
\begin{enumerate}
\item \label{item:well-form-dtok-read-read} Suppose two indexes \( \idx, \idx' \)
    such that \( \RsOf(\kvs(\key,\idx)) \cup \RsOf(\kvs(\key,\idx')) \neq \emptyset \).
    Assume \( \txid \in \RsOf(\kvs(\key,\idx)) \cup \RsOf(\kvs(\key,\idx)) \).
    There must exist edges
    \[ (\WtOf(\kvs(\key,\idx)),\txid), (\WtOf(\kvs(\key,\idx')),\txid) \in \WR[\dgraph]. \]
    Because \dgraph is well-formed (\cref{equ:dgraph-wr-unique}),
    \( \WtOf(\kvs(\key,\idx)) = \WtOf(\kvs(\key,\idx')) \) thus \( \idx = \idx' \).
\item Suppose two indexes \( \idx, \idx' \)
    such that \( \WtOf(\kvs(\key,\idx)) = \WtOf(\kvs(\key,\idx')) \).
    We prove \( \idx = \idx' \) by contradiction.
    Assume \( \idx \neq \idx' \).
    Without losing generality, this means that \( (\WtOf(\kvs(\key,\idx)),\WtOf(\kvs(\key,\idx'))) \in \WW[\dgraph]\);
    By well-formedness of \dgraph (\cref{equ:dgraph-ww-irreflexive}), it cannot be true.
    Thus we have \( \idx = \idx' \).
    Combine \cref{item:well-form-dtok-read-read}, we prove \cref{equ:kvs-wf-txid-snapshot-property}.
\item Given \cref{equ:dgraph-ww-init} we know that \( (\txidinit, \txid) \in \WW[\dgraph]\)
    for all \( \txid \in \dgraph \land \txid \neq \txidinit \);
    and \( \opW(\key,\valinit) \in \dgraph(\txidinit) \).
    By the definition of \( \VerListOf \), \( \kvs(\key,0) = (\valinit,\txidinit,\stub) \),
    which implies \cref{equ:kvs-wf-init-version}.
\item Suppose an index \( \txid, \txid' \) such that
    such that \( \txid = \WtOf(\kvs(\key,\idx)) \) and \( \txid' \in \RsOf(\kvs(\key,\idx)) \)
    for some index \( \idx \).
    This means \( (\txid,\txid') \in \WR[\dgraph] \).
    By \cref{equ:dgraph-wr-so}, it follows \( (\txid,\txid') \notin \Refl(\SO)\)
    which implies \cref{equ:kvs-wf-so-wr}.
\item Suppose an index \( \txid, \txid' \) such that
    such that \( \txid = \WtOf(\kvs(\key,\idx)) \) and \( \txid' = \WtOf(\kvs(\key,\idx')) \)
    for some indexes \( \idx, \idx' \) with \( \idx < \idx' \).
    This means \( (\txid,\txid') \in \WW[\dgraph] \).
    By \cref{equ:dgraph-ww-so}, it follows \( (\txid,\txid') \notin \SO\)
    which implies \cref{equ:kvs-wf-so-ww}. \qedhere
\end{enumerate}
\end{proof}
%\begin{proofsketch}
%It is straightforward that \( \DToK(\dgraph) \) satisfies
%the well-formed conditions for kv-store in \cref{def:well-formed-kv-store}.
%The full proof is given in \cref{sec:proof-dep-graph-to-kvs} on page \pageref{sec:proof-dep-graph-to-kvs}.
%\end{proofsketch}
\begin{proposition}[Well-defined last-write-win resolution policy]
\label{prop:well-defined-aexec-snapshot}
Given a well-formed abstract execution \( \aexec \) and a set of transactions \( \txidset \)
that includes the initialisation transaction \( \txidinit \),
the function \( \AexecSnapshot(\aexec, \txidset) \) is defined.
\end{proposition}
\begin{proof}
It is straightforward since transaction \( \txidinit \) initialise all the keys in a well-formed abstract execution.
\end{proof}
\label{sec:proof-well-defined-update-aexec}
\setcounter {axp@equationx}{\c@equation }\setcounter {equation}{20}
{\pretocmd {\@begintheorem }{\patchcmd {\thmhead }{\@acmplainnotefont }{}{}{}\patchcmd {\thmhead }{\the \thm@notefont }{}{}{}\patchcmd {\thmhead }{(}{}{}{}\patchcmd {\thmhead }{)}{}{}{}}{}{} \begin {axp@propositionrp} [\ref {axp@riv}\ifdefined \thm@notefont \the \thm@notefont \fi {} (Well-defined \(\UpdateAExec \) function)]\axp@forward@target {axp@fw@riv}{}\axp@redefinelabels \rpletiv \end {axp@propositionrp} }
\setcounter {equation}{\c@axp@equationx }
\begin {axp@oldproof}
Let new abstract execution \( \aexec' = \UpdateAExec(\aexec,\txidset,\fp,\txid) \).
\begin{enumerate}
\Case{well-formed arbitration order \(\AR[\aexec']\)}
    It suffices to only consider the edges related to the new transaction \( \txid \).
    Since the new arbitration order \( \AR[\aexec'] = \AR[\aexec] \cup \Set{(\txid',\txid) | \txid' \in \aexec'} \)
    and \( \txidinit \in \aexec\),
    it is straightforward for \cref{equ:aexec-ar-init,equ:aexec-ar-total}.
    Because \( \txid \) is a fresh transaction such that \( \txid \notin \aexec \), therefore \cref{equ:aexec-ar-irreflexive} holds.
    By the definition of \( \AR[\aexec'] \) that contains edges from any transaction \( \txid'\) from the old abstract execution \( \aexec \) to the new transaction \( \txid \), it follows \cref{equ:aexec-ar-transitive}.
    Last, by definition of \( \NextAExecTxid \),
    the fresh transaction \( \txid =  \txid[\cl](n) \) should be annotated with a bigger number \( n \) than
    transactions for the same client \( \cl \) in \( \aexec \), that is,
    \( \Forall{m \in \Indexs | \txid[\cl](m) \in \aexec } n > m \);
    this means that \( \SO \subseteq \AR[\aexec'] \) which implies \cref{equ:aexec-ar-so}.
\Case{well-formed visibility relation \(\VIS[\aexec']\)}
    It suffices to only consider the edges related to the new transaction \( \txid \).
    By the definition of \( \VIS[\aexec'] = \VIS[\aexec] \cup \Set{(\txid',\txid) | \txid' \in \txidset}  \) that
    contains edges from any transaction \( \txid' \) from \( \txidset \) to the new transaction \( \txid \)
    and \( \txidinit \in \txidset \),
    it follows \cref{equ:aexec-vis-init}.
    The \cref{equ:aexec-fp-constrain} immediately implies \cref{equ:aexec-vis-external}.
    Since the fresh transaction identifier are pick by  \( \txid \in \NextAExecTxid(\aexec,\cl) \),
    it is straightforward for \cref{equ:aexec-vis-so}.
    Last, by \( \txidset \subseteq \aexec \), it follows \cref{equ:aexec-ar-vis}. \qedhere
\end{enumerate}
\end {axp@oldproof}
\label{sec:proof-equal-axiom-semantics}
\setcounter {axp@equationx}{\c@equation }\setcounter {equation}{21}
{\pretocmd {\@begintheorem }{\patchcmd {\thmhead }{\@acmplainnotefont }{}{}{}\patchcmd {\thmhead }{\the \thm@notefont }{}{}{}\patchcmd {\thmhead }{(}{}{}{}\patchcmd {\thmhead }{)}{}{}{}}{}{} \begin {axp@theoremrp} [\ref {axp@rv}\ifdefined \thm@notefont \the \thm@notefont \fi {} (Equal expressibility between declarative and operational semantics on abstract executions)]\axp@forward@target {axp@fw@rv}{}\axp@redefinelabels \rpletv \end {axp@theoremrp} }
\setcounter {equation}{\c@axp@equationx }
\begin {axp@oldproof}
This prove is similar to the one in \cref{thm:ettrc-et-prog}.
We prove the set closure for both sides respectively.
\begin{enumerate}
\Case{\( \bigcup_{\prog \in \Programs} \EvalAExec{\prog} \subseteq \CMA(\visaxioms) \)}
    By the definition of \( \bigcup_{\prog \in \Programs}\EvalAExec{\prog}\),
    It suffices to prove that for every trace \( \aexectrc \),
    initial state \( (\aexecinit,\clenv_0) \) with program \( \prog \)
    and final state \( (\aexec,\clenv) \) with program \( \prog' \),
    \begin{Formulae}
    \begin{Formula}
        \Dom(\prog) \subseteq \Dom(\clenv_0)
        \land \aexectrc = \ToAexecProg{\aexecinit | \clenv_0 | \prog | \lb | * -> \aexec | \clenv | \prog' }
        \\ \aexec \in \CMA(\visaxioms) .
        \label{equ:aexec-prog-to-consistency-model}
    \end{Formula}
    \end{Formulae}
    We prove \cref{equ:aexec-prog-to-consistency-model} by induction on the length of \( \aexectrc \).
    \begin{enumerate*}
    \CaseBase{\(\aexectrc = \ToAexecProg{\aexecinit | \clenv_0 | \prog }\)}
        It is trivial that \( \AExecSat(\aexecinit,\visaxioms)\) and thus \( \aexecinit \in \CMA(\visaxioms)\).
    \CaseInd{\(\aexectrc = \ToAexecProg{ \aexectrc' | \lb -> \aexec | \clenv | \prog' }\)}
        Let \( \LastConf(\aexectrc) =  (\aexec',\clenv'), \prog'' \).
        If \( \lb = \lbPri\), then \( \aexec = \aexec' \);
        therefore by \ih, \cref{equ:aexec-prog-to-consistency-model} holds.
        Consider \( \lb = \lbTrans{\txidset,\fp}  \).
        By the \rAAtomicTrans rule, \( \aexec = \UpdateAExec(\aexec',\txidset,\fp,\txid) \)
        for some \( \txid \in \NextAExecTxid(\aexec,\cl) \).
        Note that the new abstract execution \( \aexec \) contains all transactions and edges in \( \aexec' \),
        and thus \( \aexec \aexeceq[\aexec'\Proj{0}] \aexec' \).
        This means that first by the \ih, \( \AExecSat(\aexec',\visaxioms) \),
        and by the definition of well-formed visibility axioms that every axiom must be local,
        we only need to consider the new visibility edges.
        By the last premise of the \rAAtomicTrans rule,
        for any \( \visaxiom \in \visaxioms \), it must be the case that \( \Inv(\visaxiom)(\aexec')(\txid) \subseteq \txidset \),
        and thus \( \aexec \in \CMA(\visaxioms) \).
    \end{enumerate*}
\Case{\( \bigcup_{\prog \in \Programs} \EvalAExec{\prog} \supseteq \CMA(\visaxioms) \)}
    Assume an abstract execution \( \aexec \in \CMA(\visaxioms) \).
    Let \( (\txidop,\VIS,\AR) =  \aexec \) .
    We prove a stronger result that
    there is an abstract execution trace \( \aexectrc \) corresponding to the cut of abstract execution,
    that is, for any number \( \idx \) and cut of abstract execution \( \aexec' \)
    \begin{Formulae}
    \begin{Formula}
        \aexec' = \AexecCut(\aexec,\idx) \implies
                \Exists{\aexectrc | \prog \in \Programs | \clenv \in \ClientEnvs }
                \\ \LastConf(\aexectrc) = (\aexec', \clenv), \prog
                \land \prog = \lambda \cl \in \Dom(\prog) \ldotp \pskip
    \label{equ:aexec-to-aexec-trace}
    \end{Formula}
    \end{Formulae}
    We prove by induction on the number of transactions.
    The key here is to construct a program \( \prog \) and this is done in similar way as in \cref{thm:ettrc-et-prog}.
    \begin{enumerate}
    \CaseBase{\(\AexecCut(\aexec,0)\)}
        We know \( \aexecinit = \AexecCut(\aexec,0) \) by the definition of \( \aexecinit \).
        Let the client set \( C  = \Set{\cl | \Exists{n \in \Indexs} \txid[\cl](n) \in \aexec }\).
        We pick a program \( \prog = \lambda \cl \in C \ldotp \pskip \)
        a client environment \( \clenv_0 = \lambda \cl \in C \ldotp \stk  \) for some stack \( \stk \),
        and therefore \( \aexectrc = \ToAexecProg{ \aexecinit | \clenv_0 | \prog }\)
        which implies \cref{equ:aexec-to-aexec-trace}.
    \CaseBase{\(\AexecCut(\aexec,\idx)\)}
        Let \( \aexec' = \AexecCut(\aexec,\idx-1) \) and \( \aexec'' = \AexecCut(\aexec,\idx) \).
        Suppose that there is a trace \( \aexectrc' \) for \( \AexecCut(\aexec,\idx-1) \),
        such that
        \[
        \begin{multlined}[t]
            \aexectrc' = \ToAexecProg{\aexecinit | \clenv_0 | \prog | \stub | * -> \aexec' | \clenv' | \prog' }
            \\ {} \land \prog' = \lambda \cl \in \Dom(\prog') \ldotp \pskip .
        \end{multlined}
        \]
        Let the transaction \( \txid = \aexec'' \setminus \aexec' \),
        fingerprint \( \fp = \aexec(\txid) \), transaction set \( \txidset = \VISInv(\txid) \).
        By \cref{prop:aexec-cut-to-update}, it follows that \( \aexec'' = \UpdateAExec(\aexec',\txidset,\fp,\txid) \).
        Let the transactional command \( \trans = \TransFp(\fp) \) (\TransFp is defined in \cref{thm:ettrc-et-prog})
        and the new initial program \( \prog'' = \ExtendProgram(\prog,\cl,\ptrans{\trans}) \).
        It is easy to see there exists a new trace \( \aexectrc \) such that
        \[
            \aexectrc = \ToAexecProg{ \aexecinit | \clenv_0 | \prog'' | \stub | *
                -> \aexec' | \clenv' | \prog'\UpdateFunc{\cl -> \ptrans{\trans} } | stub -> \aexec'' | \clenv'' | \prog^* } ,
        \]
        for some client environment \( \clenv'' \) and finial program \( \prog^* \)
        with \( \prog^* = \lambda \cl \in \Dom(\prog^*) \ldotp \pskip \). \qedhere
    \end{enumerate}
\end{enumerate}
\end {axp@oldproof}
\label{sec:proof-aexec-cut-to-trace}
\begin{proposition}[Abstract execution cut to update]
\label{prop:aexec-cut-to-update}
Given an abstract execution \( \aexec \) and the cut \( \aexec' = \AexecCut(\aexec,n) \),
assume that the transaction \( \txid \) is the next transaction in the arbitration order,
that is, \( \ToEdge{ \Max[\AR[\aexec]](\aexec') | \AR[\aexec] -> \txid }\),
assume there exists no transaction \( \txid' \) such that
\( \ToEdge{ \Max[\AR[\aexec]](\aexec') | \AR[\aexec] -> \txid' | \AR[\aexec] -> \txid  }\),
and then
\[ \AexecCut(\aexec,n+1) = \UpdateAExec(\aexec',\VISInv[\aexec](\txid),\txid,\aexec(\txid)) . \]
\end{proposition}
\begin{proof}
    It is trivial by the definitions of \( \AexecCut\) and \( \UpdateAExec \).
\end{proof}
\label{sec:proof-well-form-xtod}
\begin{proposition}[Well-defined \( \XToD \)]
\label{prop:well-defined-xtod}
Given an abstract execution \( \aexec \in \AbstractExecutions \),
the dependency graph \( \XToD(\aexec)\) is well-formed.
\end{proposition}
\begin{proof}
Given the definition of \( \XToD \), if the dependency graph \( \dgraph = \XToD(\aexec)\)
for some abstract execution \( \aexec \), then \( \WR[\dgraph] = \WR[\aexec] \),
\( \WW[\dgraph] = \WW[\aexec] \) and  \( \RW[\dgraph] = \RW[\aexec]\)  .
Consider all the well-formed conditions for relations \( \WR,\WW,\RW \) defined in \cref{def:dgraph}.
\begin{enumerate}
\Case{write-read dependency \( \WR \)}
    By the definition of \( \WR[\aexec] \), it is trivial for \cref{equ:dgraph-wr-def,equ:dgraph-wr-minimum}.
    Because visibility relation cannot violate session order by \cref{equ:aexec-vis-so},
    it follows \cref{equ:dgraph-wr-so}.
    Since \(\MaxVisTrans \) in the definition of \( \WR[\aexec] \) returns a unique transaction, it means that \cref{equ:dgraph-wr-unique} holds.
\Case{write-write dependency \( \WW \)}
    By the definition of \( \WW[\aexec] \), it is trivial for \cref{equ:dgraph-ww-def,equ:dgraph-ww-minimum}.
    Because the initialisation transaction \( \txidinit \)
    is \( \AR[\aexec]\)-before any other transactions by  \cref{equ:aexec-ar-init},
    this implies \cref{equ:dgraph-ww-init}.
    Since \(\AR[\aexec] \) is a total order and \( \SO \subseteq \AR[\aexec] \),
    by the definition of \( \WW[\aexec]\), the write-write dependency cannot violate the \( \SO \)
    and thus \cref{equ:dgraph-ww-so,equ:dgraph-ww-irreflexive} hold.
    Last write-write dependency must be transitive,
    because \( \AR[\aexec] \) is transitive and
    \( \ToEdge{\txid | \WW[\aexec](\key) -> \txid' | \WW[\aexec](\key) -> \txid'' }\) implies
    \( \ToEdge{\txid | \AR[\aexec] -> \txid' | \AR[\aexec] -> \txid'' }\) and therefore
    \( \ToEdge{\txid | \WW[\aexec](\key) -> \txid'' }\);
    this implies \cref{equ:dgraph-ww-transitive}.
\Case{read-write anti-dependency \( \RW \)}
    Consider two transactions \( \txid, \txid'\) such that \( (\txid,\txid') \in \RW[\aexec](\key) \)
    for some key \( \key \).
    By definition of \( \RW[\aexec] \), \( \opR(\key,\val) \in \aexec(\txid )\) for some value \( \val \).
    There exists a transition \( \txid'' \) such that \( \txid'' = \MaxVisTrans(\aexec,\VISInv[\aexec](\txid),\key) \),
    and therefore \( (\txid'',\txid) \in \WR[\aexec](\key)\).
    Again by definition of \( \RW[\aexec] \), it is must the case that \( (\txid'',\txid') \in \AR[\aexec] \)
    and therefore \( (\txid'',\txid') \in \WW[\aexec](\key) \).

    Now consider three transactions \( \txid, \txid', \txid'' \)
    such that \( (\txid'',\txid) \in \WR[\aexec](\key) \)
    and \( (\txid'',\txid') \in \WW[\aexec](\key) \) for some key \( \key \).
    First, \( (\txid'',\txid) \in \WR[\aexec](\key) \) implies
    \( \txid'' = \MaxVisTrans(\aexec,\VISInv[\aexec](\txid),\key) \) and \( (\txid'',\txid) \in \AR[\aexec] \);
    then because \( (\txid'',\txid') \in \WW[\aexec](\key) \), it means \( (\txid'',\txid') \in \AR[\aexec](\key) \)
    and thus we have \( (\txid,\txid') \in \RW[\aexec] \) by the definition of \( \RW[\aexec]\). \qedhere
\end{enumerate}
\end{proof}
%\begin{proofsketch}
%Given an abstract execution \( \aexec \), by the definition of \( \dgraph = \XToD(\aexec)\),
%we have \( \WR[\dgraph] = \WR[\aexec] \), \( \WW[\dgraph] = \WW[\aexec] \) and  \( \RW[\dgraph] = \RW[\aexec]\).
%Because \( \aexec \) apply last-write-wins policy,
%\( \WR[\aexec] \) satisfies \cref{equ:dgraph-wr-minimum,equ:dgraph-wr-def,equ:dgraph-wr-so}.
%Since \( \WW[\aexec] \subseteq \AR[\aexec]\),
%it is easy to prove
%\cref{equ:dgraph-ww-def,equ:dgraph-ww-minimum,equ:dgraph-ww-irreflexive,equ:dgraph-ww-transitive,equ:dgraph-ww-init,equ:dgraph-ww-so}.
%Last, \( \RW[\aexec] \) can be derived from \( \WR[\aexec]\) and \( \WW[\aexec]\).
%The full proof is given in \cref{sec:proof-well-form-xtod} on \pageref{sec:proof-well-form-xtod}.
%\end{proofsketch}
\label{sec:proof-xtod-compatibility}
\setcounter {axp@equationx}{\c@equation }\setcounter {equation}{24}
{\pretocmd {\@begintheorem }{\patchcmd {\thmhead }{\@acmplainnotefont }{}{}{}\patchcmd {\thmhead }{\the \thm@notefont }{}{}{}\patchcmd {\thmhead }{(}{}{}{}\patchcmd {\thmhead }{)}{}{}{}}{}{} \begin {axp@theoremrp} [\ref {axp@rvi}\ifdefined \thm@notefont \the \thm@notefont \fi {} (Compatibility of \( \aexec \) and \( \XToK (\aexec )\))]\axp@forward@target {axp@fw@rvi}{}\axp@redefinelabels \rpletvi \end {axp@theoremrp} }
\setcounter {equation}{\c@axp@equationx }
\begin {axp@oldproof}
Let kv-store \( \kvs = \XToK(\aexec) \).
\Case{\( \AexecSnapshot(\aexec,\txidset) = \Snapshot(\kvs,\GetView(\aexec,\txidset)) \)
            for all \( \txidset \subseteq \aexec \) such that \( \txidinit \in \txidset \)}
    By the \cref{prop:getview-valid}, the view \( \vi = \GetView(\aexec, \txidset)\)
    is a valid view on \( \kvs \), that is, \( \vi \in \Views(\kvs) \).
    Given that \( \vi \) is a valid view,
    it is sufficient to prove that for all keys \( \key \),
    \[
        \AexecSnapshot(\aexec,\txidset)(\key) = \Snapshot(\kvs,\GetView(\aexec,\txidset))(\key) .
    \]
    Let transaction \( \txid = \MaxVisTrans(\aexec,\txidset,\key)\).
    Therefore operation \( \opW{\key,\val} \in \aexec(\txid)\) for some \(\val \in \Values \).
    By definition of \(\AexecSnapshot\), it follows that \( \AexecSnapshot(\aexec,\txidset)(\key) \).
    By definition of \( \MaxVisTrans \), any other transaction \( \txid' \in \txidset \setminus \Set{\txid} \)
    that also wrote the key \( \key \) with \( \opW(\key,\stub) \in \aexec(\txid') \),
    must be \( \AR[\aexec] \)-before \( \txid \), that is \( (\txid',\txid) \in \AR[\aexec] \);
    this means that \( (\txid',\txid) \in \WW[\dgraph] \) for \( \dgraph = \XToD(\aexec) \).
    Since transactions \( \txid, \txid' \) both wrote key \( \key \),
    there must exists two indexes \( \idx, \idx' \) such that \( \txid = \WtOf(\kvs(\key,\idx)) \),
    \( \txid' = \WtOf(\kvs(\key,\idx'))\).
    Because \( \kvs = \DToK(\dgraph)\) and \( (\txid',\txid) \in \WW[\dgraph] \),
    then \( \idx > \idx' \);
    therefore by definition of \( \Snapshot \), the value matches as \( \Snapshot(\kvs,\vi)(\key) = \val \).
\Case{\( \Snapshot(\kvs,\vi) = \AexecSnapshot(\aexec,\VisTrans(\kvs,\vi)) \)
            for all \( \vi \subseteq \Views(\kvs) \)}
    %This case is non-trivial as \( \txidset \) contains \emph{read-only} transactions.
    %By \cref{prop:erase-read-only}, it is safe to erase read only transactions from \( \txidset \),
    %when calculating the view \( \GetView(\aexec, \txidset) \).
    Let transaction sets \( \txidset = \VisTrans(\kvs,\vi) \).
    It is sufficient to prove that for all keys \( \key \),
    \[
        \Snapshot(\kvs,\vi)(\key) = \AexecSnapshot(\aexec,\VisTrans(\kvs,\vi))(\key) .
    \]
    Let \( \val = \Snapshot(\kvs,\vi)(\key) \)
    By definition of \( \VisTrans \), for versions included in \( vi \) for key \( \key \),
    their writer must be included in \( \txidset \), that is
    \[
        \Forall{\idx \in \vi(\key)} \WtOf(\kvs(\key,\idx)) \in \txidset .
    \]
    Let \( \txid \) be the transaction that wrote the newest version for key \( \key \) in \( \vi \)
    as \( \txid = \WtOf(\kvs(\key,\Max[<](\vi(\key)))) \) and
    \[
        \Forall{\idx \in \vi(\key)} \ToEdge{ \WtOf(\kvs(\key,\idx)) | \Inv(\WW[\kvs]) -> \txid }.
    \]
    By definition of \( \Snapshot \), the snapshot must include \(\txid \)
    \[
        \ValOf(\kvs(\key,\Max[<](\vi(\key)))) = \val ,
    \]
    which means \( \val = \AexecSnapshot(\aexec,\VisTrans(\kvs,\vi))(\key) \)
    by definition of \( \AexecSnapshot \).
    Note that the initial version is always included in the view \( 0 \in \vi(\key) \),
    therefore \( \txidinit \in \txidset \) and the function
    \( \AexecSnapshot(\aexec,\VisTrans(\kvs,\vi)) \)
    must be defined by \cref{prop:well-defined-aexec-snapshot}.
\end {axp@oldproof}
\label{sec:proof-well-formed-get-view}
\begin{proposition}[Well-formed views of \( \GetView \)]
\label{prop:getview-valid}
For any abstract execution \(\aexec\), and \(\txidset \subseteq \aexec\),
\(\GetView(\aexec, \txidset) \in \Views(\XToK(\aexec))\).
\end{proposition}
\begin{proof}
Let \( \vi = \GetView(\aexec, \txidset)\) and \( \kvs = \XToK(\aexec) \).
By the definition of \(\GetView\),
the initial version must be included in the view \(0 \in \vi(\key)\) for any key \( \key \) (\cref{equ:view-wf-initial}).
For any index \( \idx \) included in the view for key \( \key \) such that \( \idx \in \vi(\key) \),
it must be the case that \(0 \leq \idx < \Abs{ \kvs(\key) }\) (\cref{equ:view-wf-with-in-range}).
Now consider two versions \( \kvs(\key,\idx) \) and \( \kvs(\key',\idx') \) such that
\( \idx \in \vi(\key)\) and \( \WtOf(\kvs(\key,\idx)) = \WtOf(\kvs(\key',\idx')) \),
it must the case that \( \WtOf(\kvs(\key,\idx)) \in \txidset \) thus \( \idx' \in \vi(\key')\) (\cref{equ:view-wf-atomic}).
\end{proof}
\label{sec:et-trace-aexec-well-formed}
\setcounter {axp@equationx}{\c@equation }\setcounter {equation}{24}
{\pretocmd {\@begintheorem }{\patchcmd {\thmhead }{\@acmplainnotefont }{}{}{}\patchcmd {\thmhead }{\the \thm@notefont }{}{}{}\patchcmd {\thmhead }{(}{}{}{}\patchcmd {\thmhead }{)}{}{}{}}{}{} \begin {axp@theoremrp} [\ref {axp@rvii}\ifdefined \thm@notefont \the \thm@notefont \fi {} (Well-formed abstract executions of {\( \XToTrace \)})]\axp@forward@target {axp@fw@rvii}{}\axp@redefinelabels \rpletvii \end {axp@theoremrp} }
\setcounter {equation}{\c@axp@equationx }
\begin {axp@oldproof}
We prove by induction on the length of the trace \( \ettrc \).
\begin{enumerate}
\CaseBase{\( \ettrc = \ToRed{\kvsinit | \vienvinit } \)}
    By definition of \( \TraceToX \), the only abstract execution \( \Set{\aexec} = \TraceToX(\ettrc) \)
    is defined by \( \aexec = \Tuple{\Mapping{\txidinit
                        -> \Set{(\key,\valinit) | \key \in \Keys \land  \valinit \in \InitVal(\key) } }
        , \emptyset, \emptyset} \);
    it is trivially a well-formed abstract execution and \( \kvsinit = \XToK(\aexec)\).
\CaseInd{\( \ettrc = \ToRed[\TOP]{\ettrc' | \lb -> \kvs | \vienv } \)}
    Consider the label \( \lb \).
    \begin{enumerate}
    \Case{\( \lb = \lbView{\vi}\)}
        By definition of \(\TraceToX\), \( \TraceToX(\ettrc) = \TraceToX(\ettrc') \);
        by \ih, every abstract execution in \TraceToX(\ettrc) is well-formed.
    \Case{\( \lb = \lbTrans{\fp}\)}
        Let configuration \( (\kvs',\vienv') = \LastConf(\ettrc') \)
        and view \( \vi = \vienv'(\cl)\).
        By \ih, suppose a well-formed abstract execution \( (\txidop',\VIS',\AR') \in \TraceToX(\ettrc') \).
        Let a set of read only transactions \( \txidsetrd \) such that
        \[
            \txidsetrd \subseteq
            \Set{ \txid' | \Forall{l | \key \in \Keys | \val \in \Values }
                    (l,\key,\val) \in \txidop'(\txid') \implies l = \opR } .
        \]
        Let the set of visible transactions \( \txidset = \GetView(\kvs',\vi') \cup \txidsetrd \).
        Assume new transaction \( \txid' = \kvs \setminus \kvs' \).
        By definitions of \( \TraceToX \) and \( \UpdateAExec \), the new abstract execution is defined by
        \[
            \aexec = \Tuple{\txidop \cup \Mapping{\txid' -> \fp }
            , \VIS' \cup \Set{(\txid',\txid) | \txid' \in \txidset }
            , \AR' \cup \Set{(\txid',\txid) | \txid' \in \aexec } } .
        \]
        Let \( \VIS = \VIS' \cup \Set{(\txid',\txid) | \txid' \in \txidset } \)
        and \( \AR = \AR' \cup \Set{(\txid',\txid) | \txid' \in \aexec } \).
        By \ih, we only need to consider
        the arbitration and visibility edges related to the new transaction \( \txid \).
        It is trivial that the new arbitrary relation \( \AR \) satisfies
        \cref{equ:aexec-ar-init,equ:aexec-ar-total,equ:aexec-ar-irreflexive,equ:aexec-ar-transitive};
        because the new transition is picked by \( \txid \in \NextTxid(\kvs',\cl)\),
        \cref{equ:aexec-ar-so} holds.
        Consider the new visibility relation \( \VIS' \cup \Set{(\txid',\txid) | \txid' \in \txidset } \).
        By the definition of \GetView, the initialisation transaction \( \txidinit \in \txidset \),
        and thus \( (\txidinit, \txid) \in \VIS \) which implies \( \cref{equ:aexec-vis-init}\).
        Consider a read operation \( \opR(\key,\val) \in \fp \) for some key \( \key \) and \( \val \).
        By the \( \et[\TOP] \)-trace and \UpdateKV function,
        it is known that \( \kvs'(\key,\Max[<](\kvs,\vi)) = \val \);
        therefore by the definition of \(\GetView\), the writer
        \( \WtOf(\kvs'(\key,\Max[<](\kvs,\vi))) = \MaxVisTrans((\txidop',\VIS',\AR'),\txidset,\key)\),
        which implies \cref{equ:aexec-vis-external}.
        Because the new transition is picked by \( \txid \in \NextTxid(\kvs',\cl)\),
        \cref{equ:aexec-vis-so} holds.
        Last, it is trivial that \( \VIS \subseteq \AR \).

        Now we prove \( \kvs = \XToK(\aexec) \) for the new abstract execution \( \aexec \).
        Note that \( \aexec = \UpdateAExec(\aexec,\txidset,\fp,\txid)\)
        for a fresh transaction identifier \( \txid in \NextAExecTxid(\aexec,\cl) \),
        and \( \kvs = \UpdateKV(\kvs,\vi,\fp,\txid)\) for the view \( \vi = \GetView(\txidset,\kvs) \).
        By \cref{prop:update-aexec-to-udpate-kv}, \(\kvs = \XToK(\aexec) \). \qedhere
    \end{enumerate}
\end{enumerate}
\end {axp@oldproof}
\label{sec:update-aexec-kv-store}
\begin{proposition}[Update of abstract execution matching update of kv-store]
\label{prop:update-aexec-to-udpate-kv}
Assume a kv-store \( \kvs \) and an abstract execution \( \aexec \) such that \( \kvs = \XToK(\aexec)\).
Let \( \vi = \GetView(\kvs,\txidset)\) for some view \( \vi \) and
transaction set \( \txidset \subseteq \aexec \) with \( \txidinit \in \txidset \).
Given the new abstract execution
\( \aexec' = \UpdateAExec(\aexec, \txidset, \fp, \txid) \) for some fingerprint \( \fp \)
and fresh transaction \( \txid \in \NextAExecTxid(\aexec,\cl) \),
then \( \UpdateKV(\kvs,\vi,\fp,\txid) = \XToK(\aexec') \).
\end{proposition}
\begin{proof}
Let \( \kvs' = \UpdateKV(\kvs,\vi,\fp,\txid)\).
Note that if the fresh transaction \( \txid \in \NextAExecTxid(\aexec,\cl) \)
then \( \txid \in \NextTxid(\kvs,\cl) \).
By \cref{thm:isomorphism-kvstore-dgraph,def:aexec-dgraph},
it suffice to prove that \( \KToD(\kvs') = \XToD(\aexec')\).
By the definition of \( \KToD \) and \( \XToD \)
in \cref{def:aexec-dgraph,def:kv-store-to-dependency-graph} respectively,
it is sufficient to prove that:
\begin{multline}
    \KToD(\kvs) = \XToD(\aexec) \implies
    \KToD(\kvs')\Proj{0} = \KToD(\kvs)\Proj{0}\Mapping{\txid -> \fp} = \XToD(\aexec')\Proj{0}
    \\ {} \land \WR[\kvs'] = \WR[\aexec']
    \land \WW[\kvs'] = \WW[\aexec'] .
\end{multline}
Recall that in dependency graphs, \( \RW \) can be derived from \( \WW \)  and \( \WW \).
Consider the three conjunctions.
\begin{enumerate}
\Case{new transaction \( \txid \) and its fingerprint \( \fp \)}
    By definition of \( \UpdateAExec \), it is known that, for any operation \( \op \in \fp\)
    key  \( \key \) and value \( \val \),
    \[
        \begin{multlined}
        ( \op = \opR(\key,\val) \iff \opR(\key,\val) \in \aexec'(\txid) )
        \land ( \op = \opW(\key,\val) \iff  \opW(\key,\val) \in \aexec'(\txid) ) .
        \end{multlined}
    \]
    then by definition of \( \XToD \),
    we know that \[ \XToD(\aexec)\Proj{0}\Mapping{\txid -> \fp} = \XToD(\aexec')\Proj{0} . \]
    Now consider the another side.
    By the definition of \( \UpdateKV \),
    for any operation \( \op \in \fp \),
    we have the following result for some key \( \key \) and \( \val \):
    \[
        \begin{multlined}
        ( \op = \opR(\key,\val) \iff  \Exists{\idx} \txid \in \RsOf(\kvs'(\key,\idx)) )
        \\ {} \land ( \op = \opW(\key,\val) \iff  \txid = \WtOf(\kvs'(\key,\Abs{\kvs'(\key)} - 1)) ) .
        \end{multlined}
    \]
    Therefore by definition of \( \KToD \),
    \[
        \begin{multlined}
        ( \Exists{\idx} \txid \in \RsOf(\kvs'(\key,\idx)) \iff \opR(\key,\val) \in \KToD(\kvs') )
        \\ {} \land ( \txid = \WtOf(\kvs'(\key,\Abs{\kvs'(\key)} - 1)) \iff \opW(\key,\val) \in \KToD(\kvs') ) ,
        \end{multlined}
    \]
    which means that \( \KToD(\kvs')\Proj{0} = \KToD(\kvs)\Proj{0}\Mapping{\txid -> \fp} \).
    Recall that \( \KToD(\kvs) = \XToD(\aexec)  \); this means \(  \KToD(\kvs') = \XToD(\aexec') \).
\Case{write-read dependency \( \WR \)}
    Because \( \KToD(\kvs) = \XToD(\aexec) \),
    we only need to consider \( \WR \)-edges related to the new transaction \( \txid \).
    Consider any key \( \key \) such that \( \opR(\key, \val) \in \fp \) for some value \(\val \).
    By definition of \( \UpdateAExec \), transaction \( \txid \) must read from
    a transaction \( \txid' \in \txidset \)
    who wrote the key \( \key \) and is the latest transaction visible by \( \txid \),
    and therefore by definition of \( \XToD \),
    \[
        \txid' = \MaxVisTrans(\aexec,\txidset,\key) \iff (\txid',\txid) \in \WR[\aexec'] .
    \]
    By definition of the view \( \vi = \GetView(\aexec,\txidset) \),
    the latest version of \( \key \) must be written by \( \txid \),
    that is,
    \[
        \txid' = \WtOf(\kvs(\key,\Max[<](\vi(\key)) )) .
    \]
    By the definition of \( \UpdateKV \),
    the transaction \( \txid \) must read the version \(\kvs(\key,\Max[<](\vi(\key)) )\),
    and then by definition of \( \KToD \),
    \[
        ( \txid' = \WtOf(\kvs'(\key,\Max[<](\vi(\key)))) \land \txid \in \RsOf(\kvs'(\key,\Max[<](\vi(\key)))) )
        \iff (\txid',\txid) \in \WR[\kvs'] .
    \]
    Given above, we know
    \[
        (\txid',\txid) \in \WR[\aexec'] \iff (\txid',\txid) \in \WR[\kvs']
    \]
    which means that for any new write-read dependency \( \WR[\aexec']\),
    the same edge exists in \( \WR[\kvs']\) and vice versa.
    Since \(\WR[\aexec] = \WR[\kvs]\), we know \( \WR[\aexec'] = \WR[\kvs'] \).
\Case{write-write dependency \( \WW \)}
    Because \( \KToD(\kvs) = \XToD(\aexec) \),
    we only need to consider \( \WW \)-edges related to the new transaction \( \txid \).
    Consider any key \( \key \) such that \( \opW(\key, \val) \in \fp \) for some value \( \val \).
    By the definition of \( UpdateAExec \), the new transaction wrote the key \( \key \),
    and then by definition of \( \XToD \),
    \[
        \opW(\key, \val) \in \aexec'(\txid) \iff
        \Forall{\txid' \in \aexec | \val' \in \Values}
        (\opW(\key,\val') \in \aexec(\txid') \implies (\txid',\txid) \in \AR[\aexec']) .
    \]
    Since \( \kvs = \XToK(\aexec) \),
    if a transaction wrote the key \( \key \) in \( \aexec \),
    it must wrote a version of the key \( \key \) in \( \kvs \),
    that is,
    \[
        \Forall{\txid' \in \aexec | \val' \in \Values }
        \opW(\key,\val') \in \aexec(\txid') \iff  \Exists{\idx \in \Indexs} \txid' = \WtOf(\kvs(\key,\idx)) .
    \]
    By the definition of \( \UpdateKV \),
    the transaction \( \txid \) wrote the latest version of \( \key \) in the new kv-store \( \kvs \),
    and by the definition of \( \KToD \),
    \[
    \begin{multlined}[t]
        \txid  = \WtOf(\kvs'(\key, \Abs{\kvs'(\key)} - 1 )) \iff {}
            \\ \Forall{\idx \in \Indexs}
            ( 0 \leq  \idx < \Abs{\kvs'(\key)} - 1
                        \implies \ToEdge{ \WtOf(\kvs'(\key,\idx)) | \WW[\kvs] -> \txid } )  .
    \end{multlined}
    \]
    Note that \( \Abs{\kvs'(\key)} - 1 = \Abs{\kvs(\key)} \).
    Therefore for any new write-write dependency \( \WW[\aexec']\),
    the same edge exists in \( \WW[\kvs']\) and vice versa.
    Since \(\WW[\aexec] = \WW[\kvs]\), we know \( \WW[\aexec'] = \WW[\kvs'] \). \qedhere
\end{enumerate}
\end{proof}
%\begin{proofsketch}
%We convert \( \UpdateKV(\kvs,\vi,\fp,\txid) \) and \( \XToK(\aexec') \) to dependency graphs,
%and prove the dependency graphs are the same.
%The full proof is given in \cref{sec:update-aexec-kv-store} on page \pageref{sec:update-aexec-kv-store}.
%\end{proofsketch}
\label{sec:proof-approx-view}
\begin{proposition}[Well-defined {\(\ApproxView\)}]
\label{prop:well-defined-approx-view}
Given an abstract execution \( \aexec \),
let \( \aexec' = \AexecCut(\aexec,\idx) \) and
\( \vi = \ApproxView(\aexec,\idx,\txid) \) for some number \( \idx \) and transaction \( \txid \).
If \( \txid \) is the last transaction with respect to arbitration order, \( \txid = \Max[\AR[\aexec']](\aexec')\),
then the view \( \vi \in \Views(\XToK(\aexec')) \).
\end{proposition}
\begin{proof}
It is trivial from the defintion of \(\ApproxView\).
\end{proof}
\label{sec:proof-well-formed-aexec-to-et-trace}
\setcounter {axp@equationx}{\c@equation }\setcounter {equation}{24}
{\pretocmd {\@begintheorem }{\patchcmd {\thmhead }{\@acmplainnotefont }{}{}{}\patchcmd {\thmhead }{\the \thm@notefont }{}{}{}\patchcmd {\thmhead }{(}{}{}{}\patchcmd {\thmhead }{)}{}{}{}}{}{} \begin {axp@theoremrp} [\ref {axp@rviii}\ifdefined \thm@notefont \the \thm@notefont \fi {} (Abstract executions to well-formed {\( \et [\TOP ]\)}-traces)]\axp@forward@target {axp@fw@rviii}{}\axp@redefinelabels \rpletviii \end {axp@theoremrp} }
\setcounter {equation}{\c@axp@equationx }
\begin {axp@oldproof}
Given the defintion of \( \XToTrace \), we prove a stronger result that,
for any number \( \idx \), kv-store \( \kvs \), view environment \( \vienv \) and trace \( \ettrc \),
\begin{Formulae}
\begin{Formula}
\ettrc = \XToTraceN(\aexec,\idx) \land (\kvs,\vienv) = \LastConf(\ettrc)
        \land \kvs = \XToK(\AexecCut(\aexec,\idx))
\label{equ:inv-aexec-to-et-trace}
\end{Formula}
\end{Formulae}
We prove by induction on the number \( \idx \).
\begin{enumerate}
\CaseBase{\( \idx = 0 \)}
    Any trace \( \ettrc \in \XToTraceN(\aexec,0) \) is of the form \( (\kvsinit, \vienvinit) \).
    By defintion of \( \AexecCut \), it follows \( \kvsinit = \XToK(\AexecCut(\aexec,0)) \).
\CaseBase{\( \idx > 0 \)}
    Suppose that \cref{equ:inv-aexec-to-et-trace} holds for \( \idx - 1 \) and consider \( \idx \).
    Let \( \aexec' = \AexecCut(\aexec,\idx-1) \) and \( \aexec'' = \AexecCut(\aexec,\idx) \).
    Assume the new transaction \( \txid[\cl](n) = \aexec'' \setminus \aexec' \)
    and its fingerprint \( \fp = \aexec(\txid[\cl](n)) \).
    By \ih, assume a valid \(\et[\TOP] \)-trace \( \ettrc \in \XToTraceN(\aexec,\idx) \)
    and its last configuration \( (\kvs,\vienv) = \LastConf(\ettrc)  \).
    Let the view \( \vi  = \GetView(\aexec,\VISInv(\txid[\cl](n))) \),
    the new kv-store \( \kvs' = \UpdateKV(\kvs,\vi,\fp,\txid[\cl](n)) \),
    and the new view \( \vi' = \ApproxView(\aexec,\idx, \txid[\cl](n)) \).
    Therefore the new trace \( \ettrc' \) is of the form
    \[
        \ettrc' = \ToRed{\ettrc | \lbView{\vi}
                -> \kvs | \vienv\UpdateFunc{\cl -> \vi} | \lbFp{\fp}
                -> \kvs' | \vienv\UpdateFunc{\cl -> \vi'} }
    \]
    We now prove the two new steps, \( \lbView{\vi}\) and \( \lbFp{\fp} \), satisfy
    the definition of \( \et[\TOP]\)-trace in \cref{def:et-reduction}.
    \begin{enumerate}
    \Case{\( \lbView{\vi} \)}
        By the definition of \( \XToTraceN\), there must exist a transaction \( \txid[\cl](l)\)
        for the client \( \cl \) such that
        \[
            \begin{multlined}[t]
            \ettrc = \ToRed{\cdots | \stub
                            -> \kvs^* | \vienv^* }
                \\ \ToRed{ {} |  \lbFp{\fp^*} -> \UpdateKV(\kvs^*, \vienv^*(\cl), \fp^*, \txid[\cl](l))
                                        | \vienv^*\UpdateFunc{\cl -> \vi^*} | \stub
                            -> \ettrc^{**} }
            \\ {} \land \Forall{ j } 0 \leq j < \Abs{\ettrc^{**}} \land (\ettrc'\Proj{j})\Proj{1}(\cl) = \vi^* ,
            \end{multlined}
        \]
        which means that \( \txid[\cl](m)\) is the last transaction for \( \cl \) in the trace \( \ettrc \).
        Again, by the definitions of \( \XToTraceN \) and \( \ApproxView \),
        for the view \( \vi \), there exists a set of transactions \( \txidset \) such that,
        \[
            \vi^* = \GetView(\aexec,\txidset)
            \land \txidset \subseteq \VISInv[\aexec](\txid[\cl](n)) \cap \Refl((\ARInv[\aexec]))(\txid[\cl](j)) .
        \]
        Note that \(\vi^*\) must be a valid view because of \cref{prop:well-defined-approx-view}.
        Last, by definition of \( \GetView \),
        \[
            \vi^* = \GetView(\aexec,\txidset) \subseteq \GetView(\aexec,\VISInv[\aexec](\txid[\cl](n))) = \vi
        \]
    \Case{\( \lbFp{\fp} \) and \( \kvs = \XToK(\AexecCut(\aexec,\idx)) \)}
        We prove that the new kv-store \( \kvs' \) is well-formed,
        \( \kvs = \XToK(\aexec'') \) and
        \( \ToET[\TOP]{\kvs | \vi | \fp | \kvs' | \vi' } \).
        The first and third sub-goals imply that \( \lbFp{\fp} \) is a valid \( \et[\TOP]\) step.
        \begin{enumerate}
        \Case{Well-formed \( \kvs' \)}
            Consider view \( \vi \) defined by \( \vi = \GetView(\aexec,\VISInv[\aexec](\txid[\cl](n)))\).
            Since \( \txid[\cl](n) = \Max[\AR[\aexec'']](\aexec'')\) and \( \aexec'' \) is well-formed,
            then \( \VISInv[\aexec](\txid[\cl](n)) \subseteq \aexec' \),
            which means that
            all visible transactions must exist in \( \aexec' = \AexecCut(\aexec, \idx - 1) \).
            By \ih, \( \kvs =  \XToK(\aexec')  \) and therefore \( \vi \in \Views(\vi) \).
            It is easy to see that \( \txid[\cl](n) \notin \kvs \) and \( \fp \in \Fingerprints \);
            thus by \cref{thm:well-deifned-updatekv}, the new kv-store \( \kvs' \) is well-formed.
        \Case{\( \kvs' = \XToK(\aexec'') \)}
            Let \( \txidset =  \VISInv[\aexec](\txid[\cl](n)) \).
            Previously,
            we known that \( \vi = \GetView(\aexec,\txidset) \) and \( \txidset \subseteq \aexec' \);
            therefore \( \vi = \GetView(\aexec',\txidset) \).
            By \cref{prop:aexec-cut-to-update}, \( \aexec'' = \UpdateAExec(\aexec',\txidset, \fp,\txid[\cl](n))\).
            By \ih, \( \kvs = \XToK(\aexec') \).
            Then by \cref{prop:update-aexec-to-udpate-kv}, \( \kvs' = \XToK(\aexec'') \).
        \Case{\( \ToET[\TOP]{\kvs | \vi | \fp | \kvs' | \vi' } \)}
            Previously, we proved \( \vi \in \Views(\kvs)\) and \( \kvs' = \XToK(\aexec'')\).
            Then by \cref{prop:well-defined-approx-view}, we know that \( \vi' \in \Views(\kvs')\).
            Because \( \CanCommit[\TOP] \) and \( \ViewShift[\TOP]\) are simply true,
            it remains to prove that every read operation \( \opR(\key,\val) \) agrees with the view \( \vi \).
            Note that by \cref{prop:aexec-cut-to-update},
            \( \aexec'' = \UpdateAExec(\aexec',\VISInv[\aexec](\txid[\cl](n)),\fp,\txid[\cl](n))\).
            Given the definition of \(\UpdateAExec \),
            \[
                \begin{multlined}[t]
                    \opR(\key,\val) \in \aexec''(\txid[\cl](n)) \iff
                    \\ \Exists{\txid \in \aexec'}
                    \txid = \MaxVisTrans(\aexec',\VISInv[\aexec](\txid[\cl](n)),\key)
                    \land \opW(\key,\val) \in \aexec'(\txid) .
                \end{multlined}
            \]
            Because \( \vi = \GetView(\aexec,\VISInv[\aexec](\txid[\cl](n))) \), then
            \[
                \begin{multlined}[t]
                    \opR(\key,\val) \in \aexec''(\txid[\cl](n)) \iff
                    \ValOf(\kvs(\key,\Max[<](\vi(\key)))) = \val .
                \end{multlined}
            \]
            Given above we proved \( \ToET[\TOP]{\kvs | \vi | \fp | \kvs' | \vi' } \). \qedhere
        \end{enumerate}
    \end{enumerate}
\end{enumerate}
\end {axp@oldproof}
\label{sec:proof-et-soundness}
\setcounter {axp@equationx}{\c@equation }\setcounter {equation}{28}
{\pretocmd {\@begintheorem }{\patchcmd {\thmhead }{\@acmplainnotefont }{}{}{}\patchcmd {\thmhead }{\the \thm@notefont }{}{}{}\patchcmd {\thmhead }{(}{}{}{}\patchcmd {\thmhead }{)}{}{}{}}{}{} \begin {axp@theoremrp} [\ref {axp@rix}\ifdefined \thm@notefont \the \thm@notefont \fi {} (Soundness of execution tests)]\axp@forward@target {axp@fw@rix}{}\axp@redefinelabels \rpletix \end {axp@theoremrp} }
\setcounter {equation}{\c@axp@equationx }
\begin {axp@oldproof}
    By \cref{thm:ettrc-et-prog} stating that \( \bigcup_{\prog \in \Programs} = \CMET(\et)\),
    it suffices to prove the following result:
    \[
        \CMET(\et) \subseteq \Set{ \XToK(\aexec) | \aexec \in \CMA(\visaxioms) } .
    \]
    Let \( \aexecinv \) be the invariant that gives rise of soundness constructor.
    We prove a stronger result that: for any \( \et\)-trace \( \ettrc \),
    there exists an abstract execution \( \aexec \) that satisfies \( \visaxioms \)
    and preserves \( \aexecinv \), that is,
    \begin{Formulae}
    \begin{Formula}
        \ettrc = \ToRed{ \kvsinit | \vienvinit | \stub | * -> \kvs | \vienv }
        \land \kvs = \XToK(\aexec) \land \aexec \in \CMA(\visaxioms)
        \\ {} \land \Forall{ \cl \in \Dom(\vienv) }
        \aexecinv(\aexec,\cl) \subseteq \VisTrans(\kvs,\vienv(\cl))
        \label{equ:ettrc-to-cma}
    \end{Formula}
    \end{Formulae}
    First, the trace \( \ettrc \) must be a \( \et[\TOP]\)-trace,
    and by \cref{prop:et-trace-to-well-formed-aexec} for any \( \aexec' \in \TraceToX(\ettrc)\),
    it satisfies that \( \kvs = \XToK(\aexec') \).
    We now show that we can always find an abstract execution \( \aexec \in \TraceToX(\ettrc) \)
    such that \( \AExecSat(\aexec,\visaxioms) \) and \( \aexecinv(\aexec,\cl) \subseteq \txidset_\cl \)
    for any client \( \cl \) and set of transactions
    \( \txidset_\cl = \VisTrans(\kvs,\vienv(\cl)) \cup \txidsetrd \)
    and read-only transactions \( \txidsetrd\) in \( \aexec \).
    We prove it by induction on the length of \( \ettrc \).
    Note that by \cref{thm:normal-trace}, it is safe to assume that \( \ettrc \) is a normal trace,
    that is, \( \NormalTrace(\ettrc) \).
    \begin{enumerate}
    \CaseBase{\(\ettrc = \ToRed{ \kvsinit | \vienvinit }\)}
        By definition of \( \TraceToX \), the initial abstract execution \( \aexecinit \)
        satisfies that \( \kvsinit = \XToK(\aexecinit) \) and \( \aexecinit \in \CMA(\visaxioms) \).
        For any client \( \cl \), by the definition \( \vienvinit \), we know that
        \( \VisTrans(\kvs,\vienv(\cl)) = \Set{\txid | \txid \in \kvsinit} \),
        and by the well-formed condition of \( \aexecinv \),
        therefore \( \aexecinv(\aexec,\cl) \subseteq \VisTrans(\kvs,\vienv(\cl)) \).
    \CaseInd{\(\ettrc = \ToRed{ \ettrc' | \lbView{\vi} -> \kvs | \vienv | \lbFp{\fp}
                -> \kvs'' | \vienv'' }\)}
        Let configuration \( (\kvs',\vienv') = \LastConf(\ettrc') \).
        By \ih, there exists \( \aexec' \in \CMA(\visaxioms) \) such that \( \kvs' \in \XToK(\aexec') \)
        and \( \aexecinv(\aexec,\cl') \subseteq \VisTrans(\kvs',\vienv(\cl')) \cup \txidsetrd \)
        for any client \( \cl' \in \Dom(\vienv) \) and some read only transaction set \( \txidsetrd \).
        Now consider the next two steps, \( \lbView{\vi} \) and \( \lbFp{\fp} \), for respectively.
        \begin{enumerate}
        \Case{\( \lbView{\vi} \)}
            By the definition of view-shift, \( \kvs = \kvs' \) and thus \( \kvs = \XToK(\aexec)\).
            Again, by the definition of view-shift
            \( \vienv = \vienv'\UpdateFunc{\cl -> \vi}\) and \( \vienv(\cl) \vileq \vi \).
            Since \( \aexecinv(\aexec,\cl) \subseteq \VisTrans(\kvs,\vienv(\cl)) \cup \txidsetrd \)
            for some read-only transaction set \( \txidsetrd \),
            then \( \aexecinv(\aexec,\cl) \subseteq \VisTrans(\kvs,\vi) \cup \txidsetrd \).
            Last, the invariant for client \( \cl' \) other than \( \cl \) is trivially preserved.
        \Case{\( \lbFp{\fp} \)}
            Let the new view \( \vi'' = \vienv''(\cl) \) and
            a set of transactions \( \txidset = \VisTrans(\kvs, \vi) \).
            By the definition of \( \lbFp{\fp} \),
            the new kv-store \( \kvs'' = \UpdateKV(\kvs,\vi,\fp,\txid) \)
            for some \( \txid \in \NextTxid(\kvs,\cl) \),
            and this update satisfies \( \et \),
            that is, \( \ToET{ \kvs | \vi | \fp | \kvs'' | \vi'' }\).
            Since \( \et \) is sound with respect to \( \visaxioms \),
            by \cref{def:et-sound-constructor},
            there must exists a set of read-only transactions \( \txidsetrd \)
            and a new abstract execution
            \( \aexec' = \UpdateAExec(\aexec,\txidset \cup \txidsetrd, \fp, \txid) \)
            such that \cref{equ:et-to-visaxioms,equ:aexecinv-preserve} hold.
            Note that \( \ettrc \) is also a \( \et[\TOP]\)-trace and
            \( \aexec' in \TraceToX(\ettrc) \);
            then by \cref{prop:et-trace-to-well-formed-aexec}, we know that
            \( \aexec' \) is a well-formed abstract execution and \( \kvs'' = \XToK(\aexec') \).

            Now we prove that \( \aexec' \in \CMA(\visaxioms) \).
            Fix a visibility axiom \( \visaxiom \in \visaxioms \).
            Assume two transactions \( \txid',\txid''\) such that
            \( (\txid',\txid'') \in \visaxiom(\aexec') \).
            Note that \( \txid' \neq \txid \) since \( \VIS[\aexec'] \subseteq \AR[\aexec']\).
            \begin{enumerate*}
            \Case{\(\txid'' \neq \txid\)}
                For this case, we know \( \txid',\txid'' \in \aexec \).
                By \ih that \( \aexec \in \CMA(\visaxioms)\)
                and the well-formed condition for  \( \visaxioms \),
                it follows that \( (\txid',\txid'') \in \VIS[\aexec'] \).
            \Case{\(\txid'' = \txid\)}
                By \cref{equ:et-to-visaxioms} and definition of \( \UpdateAExec \),
                then \( (\txid',\txid'') \in \VIS[\aexec'] \).
            \end{enumerate*}

            Last, we prove that
            \( \aexecinv(\aexec',\cl') \subseteq \VisTrans(\kvs'',\vienv''(\cl')) \)
            for any client \( \cl' \in \Dom(\vienv'') \).
            If \( \cl' \neq \cl \), by \ih, the invariant holds.
            Otherwise, \( \cl' = \cl \) and by \cref{equ:aexecinv-preserve} the invariant holds. \qedhere
        \end{enumerate}
    \end{enumerate}
\end {axp@oldproof}
\label{sec:proof-et-completeness}
\setcounter {axp@equationx}{\c@equation }\setcounter {equation}{29}
{\pretocmd {\@begintheorem }{\patchcmd {\thmhead }{\@acmplainnotefont }{}{}{}\patchcmd {\thmhead }{\the \thm@notefont }{}{}{}\patchcmd {\thmhead }{(}{}{}{}\patchcmd {\thmhead }{)}{}{}{}}{}{} \begin {axp@theoremrp} [\ref {axp@rx}\ifdefined \thm@notefont \the \thm@notefont \fi {} (Completeness of execution tests)]\axp@forward@target {axp@fw@rx}{}\axp@redefinelabels \rpletx \end {axp@theoremrp} }
\setcounter {equation}{\c@axp@equationx }
\begin {axp@oldproof}
%By \cref{thm:equivalence-aexec-trace-visaxioms}, it suffices to prove the following result,
%\[
    %\Set{\XToK(\aexec) | \aexec \in \bigcup_{\prog \in \Programs} \EvalAExec{\prog} }
    %\subseteq \bigcup_{\prog \in \Programs} \EvalET{\prog} ,
%\]
%then by \cref{prop:aexec-trace-visaxiom,prop:kvstore-trace-et} stating that
%\( \Set{\XToK(\aexec) | \aexec \in \CMA(\visaxioms)} = \Set{\XToK(\aexec) | \aexec \in \CMA(\visaxioms)
    %\cap \bigcup_{\prog \in \Programs} \EvalAExec{\prog}[\visaxioms[\TOP]] } \),
%the above holds if and only if,
%\[
%\begin{multlined}
    %\Set{\XToK(\aexec) | \aexec \in \CMA(\visaxioms)
    %\cap \bigcup_{\prog \in \Programs} \EvalAExec{\prog}[\visaxioms[\TOP]] }
    %\\ {} \subseteq  \CMET(\et) \cap \bigcup_{\prog \in \Programs} \EvalET{\prog}[\et[\TOP]]
%\end{multlined}
%\]
%and by \cref{thm:permissive-traces-equal} stating that
%\( \Set{\XToK(\aexec) | \aexec \in \bigcup_{\prog \in \Programs} \EvalAExec{\prog}[\visaxioms[\TOP]] }
%= \bigcup_{\prog \in \Programs} \EvalET{\prog}[\et[\TOP]] \),
%if and only if
By \cref{thm:ettrc-et-prog} stating that \( \bigcup_{\prog \in \Programs}  \EvalAExec{\prog} = \CMET(\et)\),
it suffices to prove the following result
\begin{Formulae}
\begin{Formula}
    \Set{\XToK(\aexec) | \aexec \in \CMA(\visaxioms) } \subseteq \CMET(\et) .
    \label{equ:visaxioms-to-et}
\end{Formula}
\end{Formulae}
For \cref{equ:visaxioms-to-et}, it is sufficient to prove that,
for any abstract execution \( \aexec \in \CMA(\visaxioms) \),
there exists an \(\et\)-trace \( \ettrc \) such that \( \LastConf(\ettrc)\Proj{0} =  \XToK(\aexec)  \) .
We prove a stronger result (an invariant) as the following:
for any cut of \( \aexec \), namely \( \aexec' = \AexecCut(\aexec,\idx) \),
there exists an \(\et\)-trace \( \ettrc \) such that,
for any kv-store \( \kvs \), view environment \( \vienv \)
and a set of clients \( \clset  \),
\begin{Formulae}
\begin{Formula}
    \clset = \Set{\cl | \Exists{\txid[\cl](n)} \txid[\cl](n) \in \aexec }
    \land (\kvs,\vienv) = \LastConf(\ettrc)
    \implies \kvs = \XToK(\aexec')
    \land {}
    \\ \left(
    \begin{array}{@{}l@{}}
    \Forall{\cl \in \clset | \txid \in \aexec' }
    \txid = \Max[\AR[\aexec]](\Set{\txid' | \txid \in \aexec' \land \txid' = \txid[\cl](\stub)} )
    \implies \Exists{\txidset' \subseteq \Refl((\ARInv[\aexec]))(\txid)}
    \\ \ \ \ \left(
        \Exists{\txid''}
            \txid'' = \Min[\SO](\Set{\txid' | \txid' \in \aexec \land (\txid,\txid') \in \SO})
            \implies \txidset' \subseteq \VISInv[\aexec](\txid'')
    \right)
    \\
    \multicolumn{1}{r}{{} \land \vienv(\cl) = \GetView(\aexec,\txidset') }
    \end{array}
    \right) .
    \label{equ:visaxioms-to-et-trace}
\end{Formula}
\end{Formulae}
Since \( \aexec \in \CMA(\visaxioms) \), then \( \aexec \in \CMA(\visaxioms[\TOP]) \).
By \cref{def:aexec-to-et-top-trace,thm:aexec-to-et-top-trace},
any trace included in \( \XToTrace(\aexec)  \) must be a valid \( \et[\TOP]\)-trace
and compatible with \( \aexec \).
We now prove that
\( \ettrc \) is a \( \et\)-trace and preserves the invariant in \cref{equ:visaxioms-to-et-trace}
by induction one the cut \( \idx \).
\begin{enumerate}
\CaseBase{\(\aexec' = \AexecCut(\aexec,0)\)}
    By definition of \( \AexecCut \), we know that \( \aexec' = \aexecinit\).
    We construct an \( \et\)-trace \( \ettrc \) such that
    \( \ettrc = \ToRed{\kvsinit | \vienvinit } \)
    and \( \vienvinit(\cl) = \viinit \) for any \( \cl \in \clset \);
    this trace \( \ettrc \) trivially satisfies \cref{equ:visaxioms-to-et-trace}.
\CaseInd{\(\aexec' = \AexecCut(\aexec,\idx)\) for \( \idx > 0 \)}
    Suppose that \( \aexec'' = \AexecCut(\aexec,\idx - 1) \) and there exists an \( \et \)-trace
    \( \ettrc' \) that satisfies \cref{equ:visaxioms-to-et-trace}.
    Let the set of client \( \clset = \Set{\cl | \Exists{\txid[\cl](n)} \txid[\cl](n) \in \aexec }  \)
    the new transaction \( \txid = \aexec' \setminus \aexec'' \),
    the set of visible transactions \( \txidset = \VISInv[\aexec](\txid) \)
    and the fingerprint \( \fp = \aexec(\txid) \).
    We know that \( \aexec' = \UpdateAExec(\aexec'',\txidset,\fp,\txid) \).
    Note that by \cref{def:aexec-to-et-top-trace,thm:aexec-to-et-top-trace},
    \( \ettrc' \in \XToTrace(\aexec'') \).
    Let configuration \( (\kvs'',\vienv'')  = \LastConf(\ettrc') \).
    Assume the new transaction \( \txid \) is from client \( \cl \),
    that is, \(\txid = \txid[\cl](\stub) \).
    Again by \cref{def:aexec-to-et-top-trace,thm:aexec-to-et-top-trace},
    for any \( \et[\TOP]\)-trace \( \ettrc \in \XToTrace(\aexec') \),
    \[
        \ettrc = \ToRed[\et[\TOP]]{\ettrc' | \lbView{\vi}
                    -> \kvs'' | \vienv''\UpdateFunc{\cl -> \vi} | \lbFp{\fp}
                    -> \kvs' | \vienv''\UpdateFunc{\cl -> \vi'} }
    \]
    for \( \kvs' = \UpdateKV(\kvs'',\vi,\fp,\txid) \) and two views \( \vi, \vi' \).
    The two views are defined by
    \( \vi = \GetView(\aexec, \txidset \cup \txidsetrd ) \) for a set of read-only transactions
    \( \txidsetrd \), and \( \vi' = \GetView(\aexec, \txidset')\) such that
    \[
    \begin{multlined}[t]
        \txidset' \subseteq \Refl((\ARInv[\aexec]))(\txid)
        \land \left(
            \Exists{\txid''}
                \txid'' = \Min[\SO](\Set{\txid' | \txid' \in \aexec \land (\txid,\txid') \in \SO})
                \implies \txidset' \subseteq \VISInv[\aexec](\txid'')
        \right) .
    \end{multlined}
    \]
    We need to prove that there exists
    an \( \et[\TOP]\)-trace \( \ettrc \in \XToTrace(\aexec') \) that is \( \et\)-trace.
    It is sufficient to find two views \( \vi, \vi'\) that satisfy
    \( \vienv''(\cl) \vileq \vi \) and \( \ToET{\kvs'' | \vi | \fp | \kvs' | \vi' } \).
    By the \ih, \( \vienv''(\cl) \subseteq \VISInv[\aexec](\txid)\)
    and thus \( \vienv''(\cl) \vileq \vi  \).
    Since \( \et \) is complete with \( \visaxioms \), by \cref{thm:et-complete},
    there exists two views \( \vi, \vi' \) that
    \( \ToET{\kvs'' | \vi | \fp | \kvs' | \vi' } \).
    Last, by \cref{thm:et-complete}, the invariant \cref{equ:visaxioms-to-et-trace}
    is preserved for the new trace \( \ettrc \) with respect to \( \aexec' \). \qedhere
\end{enumerate}
\end {axp@oldproof}
\begin{lemma}[Minimum visibility relation for (\texorpdfstring{\CC}{\texttt{CC}})]
\label{lem:aexec-spec-cc}
For any abstract execution \( \aexec \), if it satisfies \( \visaxioms[\CC] \),
there exists a new abstract execution \( \aexec' \) such that \( \SO \in \VIS[\aexec]\) and
\begin{Formulae}
\begin{Formula}
    \Forall{\txid \in \TxIDs | \fp } \left( \fp = \aexec(\txid) \iff \fp = \aexec'(\txid) \right)
    \land \AR[\aexec] = \AR[\aexec'] \land \VIS[\aexec'] ; \VIS[\aexec'] \subseteq \VIS[\aexec'] .
    \label{equ:aexec-spec-cc}
\end{Formula}
\end{Formulae}
\end{lemma}
\begin{proof}
We erase some visibility relation for each transaction following
the arbitration order \( \AR \) until the visibility is transitive.
Intuitively, the final visibility relation is exactly \( \Trasi((\WR[\aexec] \cup \SO)) \).
Assume the \Th{\idx} transaction \( \txid_\idx \)  with respect to the arbitration order.
Let \( \rel[\idx] \) be a new visibility for the transaction \( \txid_\idx \) such that
\( {\rel[\idx]}\Proj{2} = \Set{\txid_\idx}\) for all indexes \( \idx \)
and the union of visibility relations \( \bigcup_{0 \leq j \leq \idx } \rel[\idx] \) is transitive.
We preserve that, for each index \( \idx \), cut of abstract execution \( \aexec' =  \AexecCut(\aexec, \idx) \)
and visibility relation \( \VIS' = \bigcup_{0 \leq j \leq \idx } \rel[j] \),
the following invariant holds:
\begin{Formulae}
& \begin{Formula}
    \VIS' ; \VIS' \subseteq \VIS'  ,
    \label{equ:cc-vis-idx-transitive}
\end{Formula}
\\ & \begin{Formula}
    \Forall{ \txid \in \aexec } (\txid,\txid_i) \in \rel[\idx] \implies (\txid, \txid_i) \in (\WR[\aexec'] \cup \SO) .
    \label{equ:cc-vis-idx-minimum}
\end{Formula}
\end{Formulae}
We prove the above by induction on the number \( \idx \).
\begin{enumerate}
\CaseBase{\( \idx = 0 \)}
    By the definition of \( \AexecCut \), we know that \(\aexecinit = \AexecCut(\aexec,0) \)
    and \cref{equ:cc-vis-idx-transitive,equ:cc-vis-idx-minimum} trivially hold.
\CaseInd{\( \idx > 0 \)}
    Suppose that, for the \Th{(\idx-1)} step,
    the abstract execution \( \aexec'' =  \AexecCut(\aexec, \idx - 1) \)
    and the visibility relation \( \VIS'' = \bigcup_{0 \leq j \leq \idx-1 } \rel[j] \)
    satisfy \cref{equ:cc-vis-idx-transitive,equ:cc-vis-idx-minimum}.
    Let consider \Th{\idx} step, the transaction \( \txid_i \),
    the cut \( \aexec' =  \AexecCut(\aexec, \idx) \)
    and the visibility relation \( \VIS' = \bigcup_{0 \leq j \leq \idx } \rel[j] \).
    Initially we take \( \rel \) as an empty set.
    First, we include \( \Set{(\txid,\txid_i) | (\txid,\txid_i) \in \WR[\aexec]} \) to \( \rel \)
    and, by the definition of \( \WR[\aexec]\),
    it trivially does not affect any read operation for the transaction \( \txid_i \).
    Then we do the same for \( \SO \) as that
    we include \( \Set{(\txid,\txid_i) | (\txid,\txid_i) \in \SO} \) to \( \rel \).
    Note that \( \SO \) cannot affect any read operation for the transaction \( \txid_i \) neither,
    otherwise it contradicts to that \( \SO \subseteq \VIS[\aexec] \) and the definition of \( \WR[\aexec] \).

    For relations \( \rel' = \rel ; \bigcup_{0 \leq j \leq \idx-1 } \rel[j] \) and then \( \rel[\idx] = \rel \cup \rel' \),
    it easy to see that \( \rel \in \VIS[\aexec]\) and, then by \ih, \( \rel' \in \VIS[\aexec] \).
    We prove that the \( \rel[\idx] \) does not affect any read operation for the transaction \( \txid_i \)
    by contradiction.
    Assume distinct transactions \( \txid,\txid' \) such that
    \( \ToEdge{\txid'' | \rel \cup \rel' -> \txid' | \rel \cup \rel' -> \txid_i } \),
    and immediately  by the definition of \( \rel \) and \( \rel' \),
    then \( \ToEdge{\txid'' | \rel' -> \txid' | \rel -> \txid_i } \).
    Assume that \( \txid'' \) change the read operation for a key \( \key \) in \( \txid_i \).
    This means that there exists a transaction \( \txid^* \) such that
    \( (\txid^*,\txid_i) \in \WR[\aexec](\key)\) and \( (\txid^*,\txid'') \in \AR[\aexec] \),
    where the latter implies that \( (\txid'',\txid_i) \in \WR[\aexec](\key) \);
    there is a contradiction and thus
    \( \rel[\idx] \) does not affect any read operation for the transaction \( \txid_i \).

    We now prove that \cref{equ:cc-vis-idx-transitive,equ:cc-vis-idx-minimum} still hold.
    \begin{enumerate}
    \Case{\cref{equ:cc-vis-idx-transitive}}
        Assume a relation \( \rel^* = \bigcup_{0 \leq j \leq \idx-1 } \rel[j] \)
        and transactions \( \txid, \txid',\txid'' \) such that
        \[
            \ToEdge{\txid | \rel^* \cup \rel[\idx] -> \txid' | \rel^* \cup \rel[\idx] -> \txid'' } .
        \]
        If \( \ToEdge{\txid | \rel^*  -> \txid' | \rel^*  -> \txid'' } \),
        then by \ih, \( \ToEdge{\txid | \rel^*  -> \txid'' } \).
        Note that \( \ToEdge{\txid | \rel[\idx]  -> \txid' | \rel^*  -> \txid'' } \) cannot happen,
        because it contradict to that \( \txid' = \txid_i\) and \( (\txid'',\txid_i) \in \AR[\aexec] \).
        Thus consider \( \ToEdge{\txid | \rel^*  -> \txid' | \rel[\idx]  -> \txid'' } \).
        It must be the case that \( \txid'' = \txid_i \) and by the definition of \( \rel[\idx] \),
        we know that \( \ToEdge{\txid | \rel[\idx]  -> \txid'' } \).
    \Case{\cref{equ:cc-vis-idx-minimum}}
        By the construction, \cref{equ:cc-vis-idx-minimum} hold. \qedhere
    \end{enumerate}
\end{enumerate}
\end{proof}
\global \def \axp@protectref@iv {\ref {axp@siv}}
\axp@section {\appendixsectionformat {\protect \axp@protectref@iv }{Verification of Clock-SI Protocol}}
\label{sec:proof-right-move-clock-read-write}
\setcounter {axp@equationx}{\c@equation }\setcounter {equation}{5}
{\pretocmd {\@begintheorem }{\patchcmd {\thmhead }{\@acmplainnotefont }{}{}{}\patchcmd {\thmhead }{\the \thm@notefont }{}{}{}\patchcmd {\thmhead }{(}{}{}{}\patchcmd {\thmhead }{)}{}{}{}}{}{} \begin {axp@propositionrp} [\ref {axp@rxi}\ifdefined \thm@notefont \the \thm@notefont \fi {} (Right mover: Clock-SI internal read and write steps)]\axp@forward@target {axp@fw@rxi}{}\axp@redefinelabels \rpletxi \end {axp@propositionrp} }
\setcounter {equation}{\c@axp@equationx }
\begin {axp@oldproof}
Assume a trace \( \clockexttrc\) such that
\(
\clockexttrc = \ToClockProg{\clockexttrc' | \lb''
    -> \clocksi | \clockclientenv | \clenv | \clockrunprog | \lb
    -> \clocksi' | \clockclientenv' | \clenv' | \clockrunprog' | \lb' -> \clockexttrc''}
\)
and assume \( \lb \) such that
\(
\lb = \lbCLOCKOp{\opW(\key,\val),\clocktime}
\lor \lb = \lbCLOCKOp{\opR(\key,\val),\clocktime}
\)
where all other free variables are universal quantified.
By the \( \rCLOCKWrite \), \( \rCLOCKReadLocal\) and \( \rCLOCKReadShard\) rules,
thus there exists a stack \( \stk \) and a Clock-SI runtime command \(\clockruncmd \),
\[
\clocksi = \clocksi' \land  \clockclientenv = \clockclientenv'
\land \clenv' = \clenv\UpdateFunc{\cl -> \stk}
\land \prog' = \prog\UpdateFunc{\cl -> \clockruncmd} .
\]
This means that
\(
\clockexttrc = \ToClockProg{\clockexttrc' | \lb''
    -> \clocksi | \clockclientenv | \clenv | \clockrunprog | \lb
    -> \clocksi | \clockclientenv
                | \clenv\UpdateFunc{\cl -> \stk}
                | \clockrunprog\UpdateFunc{\cl -> \clockruncmd} | \lb'
    -> \clockexttrc''} .
\)
We perform case analysis on \( \lb' \).
\begin{enumerate}
\Case{\(\lb' = \lbCLOCKStart[\clockshard'](\cl'){\clocktime'}\)}
    We immediately have \( \cl \neq \cl' \).
    By \( \rCLOCKStart \) rule,
    there exists a Clock-SI runtime command \( \clockruncmd'\) such that
    \[
    \ToClockProg{\clocksi | \clockclientenv
                    | \clenv\UpdateFunc{\cl -> \stk}
                    | \clockrunprog\UpdateFunc{\cl -> \clockruncmd}
                    | \lbCLOCKStart[\clockshard'](\cl'){\clocktime'}
        -> \clocksi | \clockclientenv
                    | \clenv\UpdateFunc{\cl -> \stk}
                    | \clockrunprog\UpdateFunc{\cl -> \clockruncmd | \cl' -> \clockruncmd' }} .
    \]
    Note that \( \clockrunprog\UpdateFunc{\cl -> \clockruncmd | \cl' -> \clockruncmd' }
                    = \clockrunprog\UpdateFunc{\cl' -> \clockruncmd' | \cl -> \clockruncmd }\).
    This means that
    \[
    \clockexttrc \clocktrceq \left(
    \ToClockProg{\clockexttrc' | \lb''
        -> \clocksi | \clockclientenv | \clenv | \clockrunprog | \lb'
        -> \clocksi | \clockclientenv
                    | \clenv
                    | \clockrunprog\UpdateFunc{\cl' -> \clockruncmd'} | \lb
        -> \clockexttrc''}
    \right) .
    \]
\Case{\(\lb' = \lbCLOCKOp[\clockshard'](\cl'){(l',\key',\val'),\clocktime'}\)}
    We immediately have \( \cl \neq \cl' \) and \( l \in \Set{\opW,\opR,\opP}\).
    By \( \rCLOCKWrite \) (for \(\opW\)),
    \( \rCLOCKReadLocal\), \( \rCLOCKReadShard\) (for \( \opR\))
    and \(\rCLOCKPrepare \) (for \( \opP \)) rules,
    there exists a stack \( \stk' \) and a Clock-SI runtime command \( \clockruncmd'\) such that
    \begin{multline*}
    \ToClockProg{\clocksi | \clockclientenv
                    | \clenv\UpdateFunc{\cl -> \stk}
                    | \clockrunprog\UpdateFunc{\cl -> \clockruncmd}
                    | \lbCLOCKOp[\clockshard'](\cl'){(l',\key',\val'),\clocktime'} -> \ }
    \\ \ToClockProg{ \clocksi | \clockclientenv
                    | \clenv\UpdateFunc{\cl -> \stk | \cl' -> \stk'}
                    | \clockrunprog\UpdateFunc{\cl -> \clockruncmd | \cl' -> \clockruncmd' }} .
    \end{multline*}
    Note that
    \[ \clenv\UpdateFunc{\cl -> \stk | \cl' -> \stk'}
                = \clenv\UpdateFunc{\cl' -> \stk' | \cl -> \stk}
            \land \clockrunprog\UpdateFunc{\cl -> \clockruncmd | \cl' -> \clockruncmd' }
                    = \clockrunprog\UpdateFunc{\cl' -> \clockruncmd' | \cl -> \clockruncmd }.
    \]
    This means that
    \[
    \clockexttrc \clocktrceq \left(
    \ToClockProg{\clockexttrc' | \lb''
        -> \clocksi | \clockclientenv | \clenv | \clockrunprog | \lb'
        -> \clocksi | \clockclientenv
                    | \clenv\UpdateFunc{\cl' -> \stk'}
                    | \clockrunprog\UpdateFunc{\cl' -> \clockruncmd'} | \lb
        -> \clockexttrc''}
    \right) .
    \]
\Case{\(\lb' = \lbCLOCKEnd[\clockshard'](\cl'){\clocktime'}\)}
    We immediately have \( \cl \neq \cl' \).
    By \( \rCLOCKCommit \) rule
    there exists a new Clock-SI database \( \clocksi' \),
    and a Clock-SI runtime command \( \clockruncmd'\) such that
    \begin{multline*}
    \ToClockProg{\clocksi | \clockclientenv
                    | \clenv\UpdateFunc{\cl -> \stk}
                    | \clockrunprog\UpdateFunc{\cl -> \clockruncmd}
                    | \lbCLOCKOp[\clockshard'](\cl'){(l',\key',\val'),\clocktime'} -> \  }
     \\ \ToClockProg{ \clocksi' | \clockclientenv\UpdateFunc{\cl' -> \clocktime'}
                    | \clenv\UpdateFunc{\cl -> \stk}
                    | \clockrunprog\UpdateFunc{\cl -> \clockruncmd | \cl' -> \clockruncmd' }}
    \land \clocksi \clocksileq \clocksi' .
    \end{multline*}
    Note that \( \clockrunprog\UpdateFunc{\cl -> \clockruncmd | \cl' -> \clockruncmd' }
                    = \clockrunprog\UpdateFunc{\cl' -> \clockruncmd' | \cl -> \clockruncmd }\).
    Then by \( \clocksi \clocksileq \clocksi' \) and \cref{prop:read-write-on-bigger-database},
    the transition labelled by \( \lb \) can be proceeded on \( \clocksi \).
    This means that
    \[
    \clockexttrc \clocktrceq \left(
    \ToClockProg{\clockexttrc' | \lb''
        -> \clocksi | \clockclientenv | \clenv | \clockrunprog | \lb'
        -> \clocksi' | \clockclientenv\UpdateFunc{\cl' -> \clocktime'}
                    | \clenv
                    | \clockrunprog\UpdateFunc{\cl' -> \clockruncmd'} | \lb
        -> \clockexttrc''}
    \right) . \qedhere
    \]
\end{enumerate}
\end {axp@oldproof}
\begin{proposition}[Read and write steps on a larger Clock-SI database]
\label{prop:read-write-on-bigger-database}
Assume a read or write transition
\[
\ToClockCmd{ \clocksi | \clocktime | \stk | \clockruncmd | \lb
    -> \clocksi | \clocktime' | \stk' | \clockruncmd' }
\land
\left(
\lb = \lbCLOCKOp{\opW(\key,\val),\clocktime''}
\lor \lb = \lbCLOCKOp{\opR(\key,\val),\clocktime''}
\right) .
\]
Given a Clock-SI database \( \clocksi' \) such that
\( \clocksi \clocksileq \clocksi' \),
the same transition can be proceeded on \( \clocksi' \),
that is,
\[
\ToClockCmd{ \clocksi | \clocktime | \stk | \clockruncmd | \lb
    -> \clocksi | \clocktime' | \stk' | \clockruncmd' }
\]
\end{proposition}
\begin{proof}
We consider rules \( \rCLOCKWrite \), \(\rCLOCKReadLocal\) and \( \rCLOCKReadShard\) separately.
\begin{enumerate}
\Cases{{\(\rCLOCKWrite\)} and {\(\rCLOCKReadLocal\)}}
    Given the premise of \( \rCLOCKWrite \) and \( \rCLOCKReadLocal \),
    these two transitions do not depend on the state of \( \clocksi \).
\Case{{\(\rCLOCKReadShard\)}}
    We have \( \lb = \lbCLOCKOp{\opR(\key,\val),\clocktime} \)
    for some \( \clockshard,\cl,\key,\val,\clocktime\).
    Let \( \clockshard' = \ShardOf(\clocksi,\key) \) and \( (\clockkvs,\clocktime^*) = \clocksi(\clockshard') \).
    By the premise of \( \rCLOCKReadShard \),
    the shard local time must be greater than the snapshot time, that is \( \clocktime^* > \clocktime'' \).
    Let \( \clockverlist = \Set{\clockver | \Exists{\idx}
                \clockkvs(\key,\idx) = \clockver
                \land \TimeOf(\clockver) \leq \clocktime'' }\) be the set of versions of \( \key \)
    that have time-stamp smaller than the snapshot time \( \clocktime'' \).
    By the premise of \( \rCLOCKReadShard \),
    \( (\key\val,\stub) = \Max(\clockverlist) \).
    Because the hypothesis that \( \clocksi \clocksileq \clocksi' \).
    Let \( Tuple{\clockkvs',{\clocktime}^{**}} = \clocksi'(\clockshard')\).
    We have \( \clockkvs \clockkvsleq \clockkvs'  \) and \( \clocktime^* \leq {\clocktime}^{**} \).
    Therefore \( {\clocktime}^{**} > \clocktime'' \) and
    \( \clockverlist = \Set{\clockver | \Exists{\idx}
                \clockkvs'(\key,\idx) = \clockver
                \land \TimeOf(\clockver) \leq \clocktime }\),
    which means the same transition can be proceeded on \( \clocksi' \).
    In other words,
    \[
    \ToClockCmd{ \clocksi | \clocktime | \stk | \clockruncmd | \lb
        -> \clocksi | \clocktime' | \stk' | \clockruncmd' }  \qedhere
    \]
\end{enumerate}
\end{proof}
\label{sec:proof-left-move-preparation-commit}
\setcounter {axp@equationx}{\c@equation }\setcounter {equation}{5}
{\pretocmd {\@begintheorem }{\patchcmd {\thmhead }{\@acmplainnotefont }{}{}{}\patchcmd {\thmhead }{\the \thm@notefont }{}{}{}\patchcmd {\thmhead }{(}{}{}{}\patchcmd {\thmhead }{)}{}{}{}}{}{} \begin {axp@propositionrp} [\ref {axp@rxii}\ifdefined \thm@notefont \the \thm@notefont \fi {} (Left mover: Clock-SI preparation and commit steps)]\axp@forward@target {axp@fw@rxii}{}\axp@redefinelabels \rpletxii \end {axp@propositionrp} }
\setcounter {equation}{\c@axp@equationx }
\begin {axp@oldproof}
Assume a trace \(
\clockexttrc = \ToClockProg{\clockexttrc' | \lb''
    -> \clocksi | \clockclientenv | \clenv | \clockrunprog | \lb
    ->  \clockexttrc^* | \lb' -> \clockexttrc''} \).
Assume \( \lb' = \lbCLOCKOp{\opP(\key,\val),\clocktime'', \clocktime} \) or \( \lb' = \lbCLOCKEnd{\clocktime} \).
Let \( \left( \ToCOPSProg{\clocksi' | \clockclientenv' | \clenv' | \clockrunprog'}\right)  = \clockexttrc''\Proj{0}\)
be the first state of the trace segment \( \clockexttrc''\).
Let \( (\clockkvs,\clocktime^{**}) = \clocksi(\clockshard) \)
and \( \Tuple{\clockkvs',{\clocktime}^{***}} = \clocksi(\clockshard') \).
By \( \rCLOCKPrepare\)  and \( \rCLOCKCommit \),
\begin{Formulae}
& \begin{Formula}
\clockkvs \clockkvsleq \clockkvs' \land \clocktime^{**} < {\clocktime}^{***}
\land \clocksi' = \clocksi\UpdateFunc{\clockshard -> (\clockkvs',\clocktime^{***})}
\land \clockclientenv \clockclientenvleq \clockclientenv'
\label{equ:clocksi-left-move-preparation-step-or-end-step}
\end{Formula}
\end{Formulae}
We perform case analysis on the label \( \lb \).
\begin{enumerate}
\Case{{\(\lb = \lbCLOCKStart[\cl'](\clockshard'){\clocktime'}\)}}
    We immediately have \( \clockshard \neq \clockshard' \) and \( \cl \neq \cl' \).
    By \( \rCLOCKStart \), the transition labelled by \( \lb \) only depends on the state of \( \clockshard \),
    that is, \( \clocksi(\clockshard') = (\stub,\clocktime')\).
    This transition also does not change the state of the local time.
    By \cref{equ:clocksi-left-move-preparation-step-or-end-step},
    the state of \( \clockshard \) remain unchanged in \( \clocksi' \),
    that is, \( \clocksi(\clockshard') = \clocksi'(\clockshard')\).
    Therefore, there exists a new time-tick trace segment \( \clockexttrc^{**} \)
    and a runtime program \( \clockrunprog'' \) such that
    \[
    \left( \ToClockProg{\clockexttrc' | \lb''
                    -> \clockexttrc^{**} | \lb' ->
                    \clocksi' | \clockclientenv' | \clenv'
                                | \clockrunprog'' | \lb
                    -> \clockexttrc''} \right)
    \clocktrceq \clockexttrc
    \]
    where \( \clockexttrc^{**} \) a trace contains the same steps as \( \clockexttrc^{*} \).
\Case{{\(\lb = \lbCLOCKOp[\cl'](\clockshard'){\opR(\key',\val'), \clocktime'}\)} or {\(\lb = \lbCLOCKOp[\cl'](\clockshard'){\opW(\key',\val'), \clocktime'}\)}}
We immediately have \( \cl \neq \cl' \).
Note that any start label in the trace segment \( \clockexttrc^*\) cannot come from the client \( \cl' \),
because the transaction corresponds to the label \( \lb \) have not finish.
Therefore, by \cref{prop:read-write-on-bigger-database}, we move \( \lb \) to the right until we have the proof.
\Case{\(\lb = \lbCLOCKOp[\cl'](\clockshard'){\opP(\key',\val'),\clocktime',{\clocktime}^{*}}\)}
    We immediately have \( \cl \neq \cl' \) and \( {\clocktime}^{*} \geq \clocktime \).
    There are two cases: \( \clockshard = \clockshard' \) or \( \clockshard \neq \clockshard' \).
    \begin{enumerate}
    \Case{\( \clockshard = \clockshard' \)}
        There are two cases: \( \lb' = \lbCLOCKOp{\opP(\key,\val),\clocktime'', \clocktime} \) or \( \lb' = \lbCLOCKEnd{\clocktime} \).
        \begin{enumerate}
        \Case{\( \lb' = \lbCLOCKOp{\opP(\key,\val),\clocktime'', \clocktime} \)}
            Note that because both \(\lb \) and \( \lb' \) operate on the same shard \( \clockshard \),
            and by \( \rCLOCKPrepare \) that there must be no concurrent writes on the keys \( \key \) and \( \key' \)
            until the preparation time \( \clocktime'' \) and \( \clocktime' \) respectively
            (modelled by the premise
            \( \Forall{\idx} 0 \leq \idx < n \implies \TimeOf(\clockverlist(\idx)) < \clocktime' \) in \( \rCLOCKCommit\)),
            then \( \key \neq \key'\).
            These two preparation steps, \( \lb \) and \( \lb' \),
            also stop the preparation step from other transactions that want to write to
            keys \( \key \) and \( \key' \) in between \( \clocktime''\) and \( \clocktime \),
            and between \( \clocktime'\) and \( \clocktime^*\) respectively.
            Now consider the first preparation step \( \lb \).
            It is safe to advanced the preparation time of this transition up to the actual commit time \( \clocktime^* \).
            Recall that: \begin{enumerate*}
            \item by the hypothesis, we have \(\clocktime \leq \clocktime^*\);
            \item any preparation steps must happen before the actual commit,
            that is, \( \clocktime'' \leq \clocktime\) and  \( \clocktime' \leq \clocktime^*\)
            respectively;
            \item for the same shard, the time must monotonically increase, thus
            \( \clocktime' \leq \clocktime'' \).
            \end{enumerate*}
            Therefore, for the two preparation steps in the original trace,
            we have
            \[
                \clocktime' \leq \clocktime'' \leq \clocktime \leq \clocktime^* .
            \]
            This means it is allowed to delay the preparation step \( \lb \) after \( \lb' \),
            even thought the step \( \lb \) might be assigned a larger time as \( \clocktime'' \).
            Let \( \lb^* = \lbCLOCKOp[\cl'](\clockshard'){\opP(\key',\val'),\clocktime'',{\clocktime}^{*}} \)
            Therefore, there exists a new trace segment \(  \clockexttrc^{**} \) such that:
            \[
            \left( \ToClockProg{\clockexttrc' | \lb''
                            -> \clockexttrc^{**} | \lb' ->
                            \clocksi' | \clockclientenv' | \clenv'
                                        | \clockrunprog'' | \lb^*
                            -> \clockexttrc''} \right)
            \clocktrceq \clockexttrc .
            \]
        \Case{\( \lb' = \lbCLOCKEnd{\clocktime} \)}
            Follow the similar argument as the previous case,
            we have
            \[
                \clocktime' \leq \clocktime \leq \clocktime^* .
            \]
            Let \( \lb^* = \lbCLOCKOp[\cl'](\clockshard'){\opP(\key',\val'),\clocktime'',{\clocktime}^{*}} \)
            Therefore, there exists a new trace segment \(  \clockexttrc^{**} \) such that:
            \[
            \left( \ToClockProg{\clockexttrc' | \lb''
                            -> \clockexttrc^{**} | \lb' ->
                            \clocksi' | \clockclientenv' | \clenv'
                                        | \clockrunprog'' | \lb^*
                            -> \clockexttrc''} \right)
            \clocktrceq \clockexttrc .
            \]
        \end{enumerate}
    \Case{\( \clockshard \neq \clockshard' \)}
        Since steps from \( \clockexttrc^{*} \) and \( \lb \) operates on different shard,
        it is trivial to see that
        there exists a new time-tick trace segment \( \clockexttrc^{**} \)
        and a runtime program \( \clockrunprog'' \) such that
        \[
        \left( \ToClockProg{\clockexttrc' | \lb''
                        -> \clockexttrc^{**} | \lb' ->
                        \clocksi' | \clockclientenv' | \clenv'
                                    | \clockrunprog'' | \lb
                        -> \clockexttrc''} \right)
        \clocktrceq \clockexttrc . \qedhere
        \]
    \end{enumerate}
\end{enumerate}
\end {axp@oldproof}
\label{sec:proof-clock-si-txid-unique}
\begin{proposition}[Clock-SI unique transactional identifiers]
\label{prop:clock-si-unique-txid}
Assume an annotated normalised Clock-SI trace \( \clockexttrc \),
and the kv-store trace induced by the Clock-SI trace \( \progtrc = \ClockToKVTrace(\clockexttrc) \).
Let \( (\clocksi,\clockclientenv,\clenv,\clockrunprog) = \LastConf(\clockexttrc) \)
and \( (\kvs,\vienv,\clenv,\prog) = \LastConf(\progtrc) \).
The transaction identifiers in \( \kvs \) are unique in that:
\begin{Formulae}
& \begin{Formula}
    \nonumber
\end{Formula}
\\ & \begin{Formula}
    \land \Forall{\clockexttrc' \in \clockexttrc | \cl, \clockshard}
    \left( \CLOCKAtomic(\clockexttrc',\cl,\clockshard,n)
    \implies \clocktxid[\cl](n,\stub) \in \kvs \right)
    \label{equ:clock-si-txid-unique}
\end{Formula}
\\ & \begin{Formula}
    \land \Forall{\clocktxid[\cl](n,m) \in \kvs }
    \Exists{ \clockexttrc' \in \clockexttrc | \cl, \clockshard}
    \\ \left( \CLOCKAtomic(\clockexttrc',\cl,\clockshard,n)
    \land \Forall{ \clockexttrc'' \in \clockexttrc }
    \left( \CLOCKAtomic(\clockexttrc'',\cl,\clockshard,n)
    \implies \clockexttrc' = \clockexttrc'' \right) \right) .
    \label{equ:clock-kv-store-txid-unique}
\end{Formula}
\end{Formulae}
\end{proposition}
\begin{proof}
By the definition of \( \ClockToKVTrace \),
it is easy to see that \cref{equ:clock-si-txid-unique}
and
\[
    \Forall{\clocktxid[\cl](n,m) \in \kvs }
    \Exists{ \clockexttrc' \in \clockexttrc | \cl, \clockshard}
    \CLOCKAtomic(\clockexttrc',\cl,\clockshard,n) .
\]
We now prove that
\[
    \Forall{\clocktxid[\cl](n,m) \in \kvs |
    \clockexttrc', \clockexttrc'' \in \clockexttrc | \cl, \clockshard}
    \CLOCKAtomic(\clockexttrc',\cl,\clockshard,n)
    \land \CLOCKAtomic(\clockexttrc'',\cl,\clockshard,n)
    \implies \clockexttrc' = \clockexttrc'' .
\]
The above can be derived from the follows,
\begin{Formulae}*
\begin{Formula}
    \Forall{ \clockexttrc', \clockexttrc'' \in \clockexttrc
        | \cl \in \Clients | \clockshard, \clockshard' \in \CLOCKShards
        | n,n' \in \Nat }
    \\ \CLOCKAtomic(\clockexttrc',\cl,\clockshard,n)
    \land \CLOCKAtomic(\clockexttrc'',\cl,\clockshard',n')
    \\ \clockexttrc = \ToClockProg{\cdots | \stub -> \clockexttrc'
            | \stub -> \cdots | \stub -> \clockexttrc' | \stub -> \cdots}
    \implies n < n' .
\end{Formula}
\end{Formulae}
The above can be directly derived by \cref{lem:clock-si-local-time-mono}:
the snapshot time must be strictly greater then the client local time,
and the commit time must be greater or equal to the snapshot time.
Therefore, \cref{equ:clock-kv-store-txid-unique} holds.
\end{proof}
%\begin{proofsketch}
%By \cref{lem:clock-si-local-time-mono}, the snapshot time must be strictly
%greater then the client local time (\( \rCLOCKStart \)),
%and the commit time must be greater or equal to the snapshot time (\( \rCLOCKCommit \)).
%Then, by the definition of \( \ClockToKVTrace \),
%it is easy to prove \cref{equ:clock-si-txid-unique,equ:clock-kv-store-txid-unique}.
%The full detail is given in \cref{sec:proof-clock-si-txid-unique}
%on page \pageref{sec:proof-clock-si-txid-unique}.
%\end{proofsketch}
\label{sec:proof-client-local-time-mono}
\begin{lemma}[Monotonic Clock-SI client local times]
\label{lem:clock-si-local-time-mono}
Client local times monotonically increases:
given Clock-SI databases \( \clocksi, \clocksi'\), local time environments \( \clockclientenv, \clockclientenv' \),
local stack environments \( \clenv, \clenv'\), runtime programs \( \clockrunprog, \clockrunprog' \),
and label \( \lb \),
\begin{Formulae}*
& \begin{Formula}
\ToClockProg{\clocksi | \clockclientenv | \clenv | \clockrunprog | \lb
            -> \clocksi' | \clockclientenv' | \clenv' | \clockrunprog' }
\land \Forall{\cl \in \Dom(\clockclientenv) | \clockshard \in \Dom(\clocksi) | \clocktime }
    \clockclientenv(\cl) \leq \clockclientenv'(\cl)
\\ {} \land \left(
    \lb = \lbCLOCKStart{\clocktime} \implies
    \clockclientenv(\cl) < \clockclientenv'(\cl) .
\right)
\end{Formula}
\end{Formulae}
\end{lemma}
\begin{proof}
We perform case analysis on the label \( \lb \).
\begin{enumerate}
\Case{\( \lb = \lbCLOCKStart{\clocktime} \)}
    By the premise of \( \rCLOCKStart \), we have
    \( \clockclientenv(\cl) < \clockclientenv'(\cl) \).
    Other clients \( \cl' \) such that \( \cl' \neq \cl \), remains unchanged,
    therefore \( \clockclientenv(\cl') = \clockclientenv'(\cl') \).
\Case{\( \lb = \lbCLOCKOp{(l,\key,\val),\clocktime} \) with \( l \in \Set{\opW,\opR,\opP}\)}
    By \( \rCLOCKWrite \), \( \rCLOCKReadLocal \), \( \rCLOCKReadShard \) and \( \rCLOCKPrepare\),
    the client local environment remains unchanged,
    therefore \( \clockclientenv(\cl) = \clockclientenv'(\cl) \) for all clients \( \cl \).
\Case{\( \lb = \lbCLOCKEnd{\clocktime} \) or \( \lb = \lbCLOCKTick{\clocktime}\)}
    By \( \rCLOCKCommit \) and \( \rCLOCKShardTick \),
    the client local environment remains unchanged,
    therefore \( \clockclientenv(\cl) = \clockclientenv'(\cl) \) for all clients \( \cl \). \qedhere
\end{enumerate}
\end{proof}
%\begin{proofsketch}
%It is trivial by the rules presented in
%\cref{fig:clock-si-transaction-start,fig:clock-si-write-value,fig:clock-si-read-value,fig:clock-si-commit}.
%The full detail is given in \cref{sec:proof-client-local-time-mono}
%on page \pageref{sec:proof-client-local-time-mono}
%\end{proofsketch}
\label{sec:proof:clock-fp-well-formed}
\begin{proposition}[Well-formed Clock-SI fingerprints]
\label{prop:well-formed-clock-fp}
Assume an atomic trace segment \( \clockexttrc \) such that:
for some \( \clocksi,\clockclientenv,\clenv,\clockrunprog, \trans,\clockbuffer,\clocktime,\clockshard,\cmd\),
\begin{align}
\CLOCKAtomic(\clockexttrc,\cl,\clockshard)
\land (\clocksi,\clockclientenv,\clenv,\clockrunprog) = \clockexttrc\Proj{0}
\land \clockrunprog(\cl) = \pruntrans{\trans}{\emptyset,\clockbuffer}{\clocktime,\clockshard} \pseq \cmd .
\label{equ:clock-init-fp-match-with-trace}
\end{align}
Then, the fingerprint \(\fp = \ClockFp(\emptyset,\clockexttrc)\) satisfies the follows:
for some \( \clocksi',\clockclientenv',\clenv',\clockrunprog', \trans',\clockbuffer',\clocktime,\clockshard,\cmd\),
\begin{align}
(\clocksi',\clockclientenv', \clenv',\clockrunprog') = \LastConf(\clockexttrc)
\land \clockrunprog(\cl) = \pruntrans{\trans'}{\fp,\clockbuffer'}{\clocktime,\clockshard} \pseq \cmd .
\label{equ:clock-fp-match-with-trace}
\end{align}
\end{proposition}
\begin{proof}
Fix the initial fingerprint \( \fp \),
we prove by induction on the length of trace \( \clockexttrc \).
\begin{enumerate}
\CaseBase{\( \clockexttrc = \emptyset \)}
    By the definition,
    we have \( \ClockStaticProg(\emptyset,\clockexttrc) = \emptyset \).
    It is trivial that \( \emptyset \) is a well-formed fingerprint and \cref{equ:clock-fp-match-with-trace} holds.
\CaseInd{\( \clockexttrc = \ToClockProg{\clockexttrc' | \lb -> \clocksi' | \clockclientenv' | \clenv' | \clockrunprog' } \)}
    Given the client \( \cl \),
    assume the fingerprint \( \fp' \) such that
    \[
        (\clocksi,\clockclientenv,\clenv,\clockrunprog) = \LastConf(\clockexttrc')
        \land \clockrunprog(\cl) = \pruntrans{\trans}{\fp',\clockbuffer}{\clocktime,\clockshard} \pseq \cmd .
    \]
    and assume fingerprint \( \fp'' \) such that
    \[
        \clockrunprog'(\cl) = \pruntrans{\trans'}{\fp'',\clockbuffer'}{\clocktime,\clockshard} \pseq \cmd
    \]
    where the free variables are existentially quantified.
    By the \ih, we immediately have \( \ClockStaticProg(\fp,\clockexttrc') = \fp' \).
    We perform case analysis on the label \( \lb \).
    \begin{enumerate}
    \Case{\(\lb = \lbCLOCKOp{\opW(\key,\val),\clocktime,\clocktime'} \)}
        By the rule \( \rCLOCKWrite \),
        we have \( \fp'' = \fp' \AddOp \opW(\key,\val)\).
        By the definition of \( \ClockStaticProg \),
        we have
        \[
        \ClockStaticProg(\fp,\clockexttrc)
                = \ClockStaticProg(\fp,\clockexttrc') \AddOp \opW(\key,\val)
                = \fp'  \AddOp \opW(\key,\val) = \fp''
        \]
        which implies \cref{equ:clock-fp-match-with-trace}.
    \Case{\(\lb = \lbCLOCKOp{\opR(\key,\val),\clocktime,\clocktime'} \)}
        Consider if \( \fp' \) contains an entry for the key \( \key \),
        which corresponds to the two rules \( \rCLOCKReadLocal\) and \( \rCLOCKReadShard\).
        \begin{enumerate}
        \Case{\( \rCLOCKReadLocal\)}
            In this case, we have \( (l,\key,\val) \in \fp' \) for some \( l \in \Set{\opW,\opR} \) and value \( \val \).
            By the premise of  \( \rCLOCKReadLocal\),
            we have \( \fp' = \fp''\).
            By the definition of \( \ClockStaticProg \),
            we have
            \[
            \ClockStaticProg(\fp,\clockexttrc) = \ClockStaticProg(\fp,\clockexttrc') \AddOp \opR(\key,\val)
            = \fp' \AddOp \opR(\key,\val) = \fp''
            \]
            which implies \cref{equ:clock-fp-match-with-trace}.
        \Case{\( \rCLOCKReadShard\)}
            In this case, we have \( (l,\key,\val) \notin \fp' \) for all \( l \in \Set{\opW,\opR} \) and value \( \val \).
            By the premise of  \( \rCLOCKReadLocal\),
            we have \( \fp'' = \fp' \AddOp \opR(\key,\val) \).
            By the definition of \( \ClockStaticProg \),
            we have
            \[
            \ClockStaticProg(\fp,\clockexttrc) = \ClockStaticProg(\fp,\clockexttrc') \AddOp \opR(\key,\val)
            = \fp' \AddOp \opR(\key,\val) = \fp''
            \]
            which implies \cref{equ:clock-fp-match-with-trace}. \qedhere
        \end{enumerate}
    \end{enumerate}
\end{enumerate}
\end{proof}
%\begin{proofsketch}
    %We prove \cref{equ:clock-fp-match-with-trace} by induction on the length of \( \clockexttrc \).
    %In the inductive case, \cref{equ:clock-fp-match-with-trace} can be derived
    %by \( \rCLOCKWrite \) if the next step is a write,
    %\( \rCLOCKReadLocal\) if the next step is a local read,
    %or \( \rCLOCKReadShard\) if the next step is a read from a shard.
    %The full detail is given in \cref{sec:proof:clock-fp-well-formed}
    %on page \pageref{sec:proof:clock-fp-well-formed}.
%\end{proofsketch}
\label{sec:proof-well-formed-clock-si-to-kvs}
\setcounter {axp@equationx}{\c@equation }\setcounter {equation}{6}
{\pretocmd {\@begintheorem }{\patchcmd {\thmhead }{\@acmplainnotefont }{}{}{}\patchcmd {\thmhead }{\the \thm@notefont }{}{}{}\patchcmd {\thmhead }{(}{}{}{}\patchcmd {\thmhead }{)}{}{}{}}{}{} \begin {axp@theoremrp} [\ref {axp@rxiii}\ifdefined \thm@notefont \the \thm@notefont \fi {} (Well-formed Clock-SI centralised kv-store)]\axp@forward@target {axp@fw@rxiii}{}\axp@redefinelabels \rpletxiii \end {axp@theoremrp} }
\setcounter {equation}{\c@axp@equationx }
\begin {axp@oldproof}
We prove by induction on Clock-SI trace \( \clockexttrc \).
\begin{enumerate}
\CaseBase{\clockexttrc = \ToClockProg{\clocksiinit | \clockclientenvinit | \clenv_0 | \prog_0 }}
    By  the definition of \( \ClockToKVTrace \),
    \( \progtrc = \ToProg{ \kvsinit | \vienvinit | \clenv_0 | \prog_0 } \).
    It is trivial that the initial kv-store \( \kvsinit \) is well-formed,
    and \( \clocksiinit \) and \( \kvsinit \)  satisfy
    %\cref{equ:kvs-to-clock-si,equ:clock-si-to-kvs,equ:kvs-read-to-clock-si-read,equ:clock-si-read-to-kvs-read}.
    \cref{equ:kvs-to-clock-si,equ:clock-si-to-kvs}.
\CaseInd{ \clockexttrc = \ToClockProg{\clockexttrc' | \lb -> \clockexttrc'' | \lb'
        -> \clocksi'' | \clockclientenv'' | \clenv'' | \clockrunprog'' } }
    Let \( (\clocksi',\clockclientenv',\clenv',\clockrunprog) = \LastConf(\clockexttrc') \)
    and \( \progtrc' = \ClockToKVTrace(\clockexttrc') \).
    By \ih, the final kv-store \( \kvs' \) such that \( (\kvs',\vienv',\stub,\stub) = \LastConf(\progtrc') \),
    is well-formed,
    and \( \clocksi'\) and \( \kvs' \) satisfy
    %\cref{equ:kvs-to-clock-si,equ:clock-si-to-kvs,equ:kvs-read-to-clock-si-read,equ:clock-si-read-to-kvs-read}.
    \cref{equ:kvs-to-clock-si,equ:clock-si-to-kvs}.
    Now let consider the next step:
    there are two possible cases for \( \clockexttrc''\).
    \begin{enumerate}
    \Cases{\( \lb = \lbCLOCKStart{\clocktime}\) or \( \lb = \lbCLOCKTick{\clocktime} \), and both with \( \clockexttrc'' = \emptyset\)}
        By the definition of \( \ClockToKVTrace \), \( \ClockToKVTrace(\clockexttrc) = \ClockToKVTrace(\clockexttrc') \),
        and by \ih, we have the proof.
    \Cases{\( \lb = \lbCLOCKOp{(l,\key,\val), \clocktime,n}\)}
        Let \( \clockexttrc^* =
                \ToClockProg{\LastConf(\clockexttrc) | \lb
                            -> \clockexttrc' | \lb'
                            -> \clocksi'' | \clockclientenv'' | \clenv'' | \clockrunprog'' } \).
        In this case, we have \( \CLOCKAtomic(\clockexttrc^*,\cl,\clockshard,n) \).
        Let \( \vi = \ClockView(\kvs',\clocktime) \) and \( \fp =  \ClockFp(\emptyset,\clockexttrc^*) \).
        By the definition of \( \progtrc = \ClockToKVTrace(\clockexttrc) \), we have
        \[
            \progtrc = \ToProg{\progtrc' | \lbTrans{\vi,\fp}
                                    ->  \kvs''
                                       | \vienv'\UpdateFunc{\cl -> \vi'}
                                       | \clenv''
                                       | \ClockStaticProg(\clockrunprog) }
        \]
        where \( \kvs'' = \UpdateKV(\kvs,\vi,\fp,\clocktxid[cl](n,m)) \) and \( \vi = \ClockView(\kvs'',n) \).
        Note that we have the following results:
        \begin{enumerate}
            \item by \ih, the kv-store \( \kvs'' \) is well-formed;
            \item by \cref{prop:clock-si-view}, the pre-view \( \vi \) is well-formed on \( \kvs'' \);
            \item by \cref{prop:well-formed-clock-fp}, the fingerprint \( \fp \) is well-formed fingerprint; and
            \item by \cref{prop:clock-si-unique-txid}, the transaction identifier \( \clocktxid[cl](n,m) \) must be a unique
            and by \cref{lem:clock-si-local-time-mono}, \( \clocktxid[\cl](n,m) \in \NextTxid(\kvs,\cl) \).
        \end{enumerate}
        Given above, by \cref{thm:well-deifned-updatekv},
        we have that \( \kvs'' = \UpdateKV(\kvs,\vi,\fp,\clocktxid[cl](n,m)) \) is well-formed.

        Now we prove \cref{equ:kvs-to-clock-si,equ:clock-si-to-kvs}.
        Note that \( \kvs' \) and \( \clocksi' \) satisfy \cref{equ:kvs-to-clock-si,equ:clock-si-to-kvs},
        Consider the new versions in \( \kvs'' \).
        Take a write operation such that \( \opW(\key,\val) \in \fp \).
        This means that, if and only if, \( \kvs''(\key,\Abs{\kvs''(\key)} - 1 ) = (\val,\clocktxid[\cl](n,m),\emptyset) \).
        By definition of \( \fp = \ClockFp(\emptyset,\clockexttrc^*) \),
        if and only if, there exists two transitions,
        \( \lbCLOCKOp{\opW(\key,\val),\clocktime,n} \) and \( \lbCLOCKOp{\opW(\key,\val),\clocktime',n} \)
        for some preparation time \( \clocktime' \) such \( \clocktime' > \clocktime\),
        in the trace \( \clockexttrc^*\).
        By the definition of \( \rCLOCKPrepare \) and \( \rCLOCKCommit \),
        if and only if, we have \( \clockkvs''(\key, \Abs{\clockkvs''(\key)} - 1)  = (\val,n,\clocksicommitted) \)
        for \( (\clockkvs'',\stub) = \clocksi''(\ShardOf(\key))\).
        Thus, \cref{equ:kvs-to-clock-si,equ:clock-si-to-kvs} hold. \qedhere

        %Last, we prove \cref{equ:kvs-read-to-clock-si-read,equ:clock-si-read-to-kvs-read}.
        %Note that \( \kvs' \) and \( \clocksi' \) satisfy
        %\cref{equ:kvs-read-to-clock-si-read,equ:clock-si-read-to-kvs-read},
        %Consider the new transaction \( \clocktxid[\cl](n,m) \) from \( \cl \) that commits at time \( n\).
        %Assume \( \kvs(\key,\idx) =
            %\Tuple{\val, \clocktxid[\cl'](n'), \txidset \cup \Set{\clocktxid[\cl](n,m)}} \)
        %for some \( \key, \idx, \val, \txid[\cl](n) ,\txidset \).
        %This means, if and only if, the read operation \( \opR(\key,\val) \in \fp \),
        %by the definition of \( ClockToKVTrace \).
        %By definition of \( \fp = \ClockFp(\emptyset,\clockexttrc^*) \),
        %if and only if,
        %\[
            %\ClockReadFromShard(\clockexttrc^*,\cl,\clockshard,\key,\clocktime,n)
        %\]
        %and, then if and only if,
        %\[
            %n' = \Set{n'' | \Exists{\idx,\clockkvs} n'' < \clocktime \land \clocksi(\clockshard) = (\clockkvs,\stub) \land \clockkvs(\key,\idx) = (\stub,n'')}
        %\]
        %by the premise of \( \rCLOCKReadShard \).
        %Thus, \cref{equ:kvs-read-to-clock-si-read,equ:clock-si-read-to-kvs-read} hold. \qedhere
    \end{enumerate}
\end{enumerate}
\end {axp@oldproof}
\label{sec:proof-clock-si-sat-si}
\setcounter {axp@equationx}{\c@equation }\setcounter {equation}{8}
{\pretocmd {\@begintheorem }{\patchcmd {\thmhead }{\@acmplainnotefont }{}{}{}\patchcmd {\thmhead }{\the \thm@notefont }{}{}{}\patchcmd {\thmhead }{(}{}{}{}\patchcmd {\thmhead }{)}{}{}{}}{}{} \begin {axp@theoremrp} [\ref {axp@rxiv}\ifdefined \thm@notefont \the \thm@notefont \fi {} (Clock-SI traces satisfying snapshot isolation)]\axp@forward@target {axp@fw@rxiv}{}\axp@redefinelabels \rpletxiv \end {axp@theoremrp} }
\setcounter {equation}{\c@axp@equationx }
\begin {axp@oldproof}
Given a normalised Clock-SI trace \( \clockexttrc \),
by \cref{thm:well-formed-clock-trace},
the induced kv-store trace \( \progtrc = \ClockToKVTrace(\clockexttrc) \)
is a trace that can be obtained under \( \et[\top]\).
We prove that every transition in the trace \( \progtrc \) satisfies the constrains of \( \et[\PSI] \) by induction on \( \clockexttrc \).
\begin{enumerate}
\CaseBase{\clockexttrc = \ToClockProg{\clocksiinit | \clockclientenvinit | \clenv_0 | \prog_0 }}
    By the definition of \( \ClockToKVTrace \),
    \( \progtrc = \ToProg{ \kvsinit | \vienvinit | \clenv_0 | \prog_0 } \),
    and there is nothing to prove since no transition has been made.
\CaseInd{ \clockexttrc = \ToClockProg{\clockexttrc' | \lb -> \clockexttrc'' | \lb'
        -> \clocksi'' | \clockclientenv'' | \clenv'' | \clockrunprog'' } }
    If \( \lb  = \lbCLOCKTick{\clocktime} \) or \(  \lb = \lbCLOCKStart{\clocktime} \),
    by the definition of \( \ClockToKVTrace \),
    we have \( \ClockToKVTrace(\clockexttrc) = \ClockToKVTrace(\clockexttrc') \),
    and thus by \ih, we have the proof.
    Now consider
    \begin{Formulae}*
    \begin{Formula}
    \clockexttrc = \ToClockProg{\clockexttrc' | \lb -> \clockexttrc'' | \lb'
                -> \clocksi'' | \clockclientenv'' | \clenv'' | \clockrunprog'' }
    \\ {}
    \land \lb = \lbCLOCKOp{(l,\key,\val),m,n} \land l \in \Set{\opR,\opW}
    \land \lb' = \lbCLOCKEnd{n}
    \end{Formula}
    \end{Formulae}
    Let \( \clockexttrc^* =
            \ToClockProg{\LastConf(\clockexttrc) | \lb
                        -> \clockexttrc' | \lb'
                        -> \clocksi'' | \clockclientenv'' | \clenv'' | \clockrunprog'' } \).
    %In this case, we have \( \CLOCKAtomic(\clockexttrc^*) \).
    Let \( \progtrc' = \ClockToKVTrace(\clockexttrc') \)
    and \( (\kvs',\vienv', \allowbreak \stub,\stub)  = \LastConf(\progtrc') \).
    By the definition of \( \ClockToKVTrace \), we have
    \[
    \ClockToKVTrace(\clockexttrc) =
        \ToProg[\top]{\progtrc' | \lbTrans{\vi,\fp}
                -> \kvs'' | \vienv'\UpdateFunc{\cl -> \vi'} | \clenv'' | \prog''  } ,
    \]
    where
    \begin{Formulae}*
    \begin{Formula}
        \fp = \ClockFp(\emptyset, \clockexttrc^*)
        \land \vi = \ClockView(\kvs',\clocktime)
        \\ {} \land \kvs'' =  \UpdateKV(\kvs',\vi,\fp,\clocktxid[\cl](n,m) )
        \land \vi' = \ClockView(\kvs'',n)
        \land \prog' = \ClockStaticProg(\clockrunprog) .
    \end{Formula}
    \end{Formulae}
    Note that in the proof we call \( \clocktime \) as the snapshot time and
    \( n \) as the commit time.
    By the definition of \( \PSI \),
    we need to prove the following results:
    \begin{Formulae}
    & \begin{Formula}
    \vi \vileq \vi'
    \label{equ:clock-vi-increase}
    \end{Formula}
    \\ & \begin{Formula}
    \Forall{ \txid \in \kvs'' \setminus \kvs' | \key \in \Keys | \idx \in \Indexs }
    \ToEdge{ \WtOf(\kvs''(\key,\idx)) | \Refl(\SO) -> \txid }
    \implies \idx \in \vi'(\key)
    \label{equ:clock-vi-write}
    \end{Formula}
    \\ & \begin{Formula}
    \PreClosed(\kvs',\vi,\TraRe(\left({\Trasi(( \WR[\kvs'] \cup \SO \cup \WW[\kvs']))} ; \Refl(\RW[\kvs']) \right)))
    \label{equ:clock-vi-cloce-cycle}
    \end{Formula}
    \\ & \begin{Formula}
    \PreClosed(\kvs,\vi,\bigcup_{\opW(\key,\stub) \in \fp}\WWInv[\kvs'](\key))
    \label{equ:clock-vi-ua}
    \end{Formula}
    \end{Formulae}
    We prove \cref{equ:clock-vi-increase,equ:clock-vi-write,equ:clock-vi-cloce-cycle,equ:clock-vi-ua} separately.
    \begin{enumerate}
    \Case{{\cref{equ:clock-vi-increase}}}
        By \cref{lem:clock-si-local-time-mono}, we have the commit time \( n \) is greater or equal to the snapshot time \( m \).
        This means that \( m \leq n \) and thus
                \( \vi = \ClockView(\kvs',m) \vileq \ClockView(\kvs'',n) = \vi' \).
    \Case{{\cref{equ:clock-vi-write}}}
        Consider any write operation \( \opW(\key,\val) \in \fp \).
        By \( \rCLOCKPrepare \), \( \rCLOCKCommit\) and the definition of annotated Clock-SI traces, \(\CLOCKExtTraces\),
        there must exist a write step in the Clock-SI trace segment \( \clockexttrc' \)
        of the form \( \lbCLOCKOp{\opW(\key, \allowbreak \val),m,n}\) such that \( m \leq n \).
        Recall that \( \kvs'' =  \UpdateKV(\kvs',\vi,\fp,\txid[\cl](n,m) ) \),
        thus we know that
        \[
            \kvs''(\key,\Abs{\kvs'(\key)} - 1) = (\val,\txid[\cl](n,m),\emptyset) .
        \]
        By the definition of \( \vi' = \ClockView(\kvs'',n) \),
        we have \( \left( \Abs{\kvs''(\key)} - 1 \right) \in \vi'(\key) \).
    \Case{\cref{equ:clock-vi-cloce-cycle}}
        We prove the correspondence between the four relations, \( \WR, \allowbreak \WW, \allowbreak \RW \) and \( \SO\),
        with respect to the snapshot and commit times.
        Let consider two transactions \( \txid[\cl'](n',m'),\txid[\cl''](n'',m'') \) that accessed key \(key\) in \( \kvs' \).
        Note that \( \txid[\cl'](n',m'),\txid[\cl''](n'',m'') \) might be the writers or the readers of some versions.
        By \cref{thm:well-formed-clock-trace},
        there must exist read or write steps
        that corresponds to \( \txid[\cl'](n',m'),\txid[\cl''](n'',m'') \) in the trace \( \clockexttrc' \).
        Without losing generality, we assume the steps for \( \txid[\cl'](n',m') \)
        appear before the steps for \( \txid[\cl''](n'',m'') \):
        \[
            \clockexttrc' = \ToClockProg{\cdots | \lbCLOCKOp{(l',\key,\val'),m',n'}
                        -> \cdots | \lbCLOCKOp{(l'',\key,\val''),m'',n''} -> \cdots }
            \land l',l'' \in \Set{\opW,\opR}
        \]
        Given that the snapshot time \( m\) of the new transaction \( \txid[\cl](n,m) \),
        assume that \( n'' < m \).
        This means that \( \txid[\cl](n,m) \) observes \( \txid[\cl''](n'',m'') \).
        Now we prove that \( \txid[\cl](n,m) \) also observes \( \txid[\cl'](n',m') \)
        for the following cases.
        \begin{enumerate}
        \Case{\( (\txid[\cl'](n',m'),\txid[\cl''](n'',m'')) \in \WR[\kvs'](\key) \)}
            This means \( \cl'' \) read a version written by \( \cl' \):
            there exists an index \( \idx \) such that
            \[
                \txid[\cl'](n',m')  = \WtOf(\kvs'(\key,\idx))
                \land \txid[\cl''](n'',m'')  \in \RsOf(\kvs'(\key,\idx)) .
            \]
            We then have \( l' = \opW \) and \( \l'' = \opR \).
            By \cref{lem:clock-si-wr}
            \( \cl'' \) must have a snapshot time \( m'' \) greater or equal to the commit time \( n' \),
            and then by \cref{lem:clock-si-local-time-mono}, we have \( n' < n'' \).
            In other words,
            \begin{Formulae}
            \begin{Formula}
                (\txid[\cl'](n',m'),\txid[\cl''](n'',m'')) \in \WR[\kvs'] \implies n' < m'' \leq n'' .
                \label{equ:clock-wr-commit-time}
            \end{Formula}
            \end{Formulae}
        \Case{\( (\txid[\cl'](n',m'),\txid[\cl''](n'',m'')) \in \WW[\kvs'](\key) \)}
            This means \( \cl'' \) write a new version for \( \key \) after the version written by \( \cl' \):
            \[
                \txid[\cl'](n',m')  = \WtOf(\kvs'(\key,\idx))
                \land \txid[\cl''](n'',m'')  \in \WtOf(\kvs'(\key,\idx'))
                \idx < \idx'
            \]
            The transaction \( \txid[\cl''](n'',m'') \) commits after  \( \txid[\cl'](n',m') \)
            in the kv-store trace \( \progtrc' \),
            thus in the Clock-SI trace \( \clockexttrc' \).
            By \( \rCLOCKPrepare \) rule, when \( \cl'' \) prepares the new version,
            there must be no version that commit after the snapshot time of \( \cl'' \),
            which means
            \begin{Formulae}
            \begin{Formula}
                (\txid[\cl'](n',m'),\txid[\cl''](n'',m'')) \in \WW[\kvs] \implies n' < m'' \leq n''.
                \label{equ:clock-ww-commit-time}
            \end{Formula}
            \end{Formulae}
        \Case{\( (\txid[\cl'](n',m'),\txid[\cl'](n'',m'')) \in \SO \)}
            Because the local times for Clock-SI clients monotonically increase,
            we know that
            \begin{Formulae}
            \begin{Formula}
                (\txid[\cl'](n',m'),\txid[\cl'](n'',m'')) \in \SO \implies n' < m'' \leq n'' .
                \label{equ:clock-so-commit-time}
            \end{Formula}
            \end{Formulae}
        \Case{\( \ToEdge{\txid[\cl'](n',m') | \rel
                        -> \txid[\cl^*](n^*,m^*) | \RW[\kvs'](\key) -> \txid[\cl''](n'',m'') } \) with \( \rel \in \Set{\WR[\kvs'],\WW[\kvs'],\SO}\)}
            This means there exist two indexes \( \idx, \idx' \) such that
            \[
                \idx < \idx'
                \land \Exists{\txidset}
                \kvs(\key,\idx) = (\stub, \stub, \txidset)
                \land \txid[\cl^*](n^*) \in \txidset
                \land \kvs(\key,\idx') = (\stub, \txid[\cl''](n'',m''), \stub)
            \]
            Consider the transaction \( \txid[\cl^*](n^*,m^*) \) in the Clock-SI trace.
            By \cref{lem:clock-si-wr},
            %the snapshot time \( m^* \) of this transaction must be strictly smaller than the commit time \( n^* \).
            The snapshot time \( m^* \)  must be strictly smaller than than \( n'' \) (otherwise it contradict to \cref{lem:clock-si-wr}),
            that is, \(m^{*} < n'' \).
            By \ToEdge{\txid[\cl'](n',m') | \rel -> \txid[\cl^*](n^*,m^*) } for \( \rel \in \Set{\WR[\kvs'],\WW[\kvs'],\SO} \)
            and \cref{equ:clock-wr-commit-time,equ:clock-ww-commit-time,equ:clock-so-commit-time},
            we then have \(  n' < m^* < n^* \), that is,
            \begin{Formulae}
            \begin{Formula}
                \ToEdge{\txid[\cl'](n',m') | \rel -> \txid[\cl^*](n^*,m^*)| \RW[\kvs'](\key) -> \txid[\cl''](n'',m'') }
                \implies n' < n''
                \label{equ:clock-rw-commit-time}
            \end{Formula}
            \end{Formulae}
        \end{enumerate}
        Combine \cref{equ:clock-wr-commit-time,equ:clock-ww-commit-time,equ:clock-so-commit-time,equ:clock-rw-commit-time},
        we have
            \begin{Formulae}
            \begin{Formula}
                (\txid[\cl'](n',m'),\txid[\cl''](n'',m'')) \in
                    \TraRe(\left({\Trasi(( \WR[\kvs] \cup \SO \cup \WW[\kvs]))} ; (\RWRelf[\kvs']) \right))
                \implies n' < n'' .
                \label{equ:clock-si-commit-time}
            \end{Formula}
            \end{Formulae}
        This means, by the definition of \( \vi = \ClockView(\kvs,\clocktime) \),
        if the view \( \vi \) includes version written by  \( \txid[\cl''](n'',m'') \),
        then the view also includes version written by \( \txid[\cl'](n',m') \),
        thus we prove \cref{equ:clock-vi-cloce-cycle}.
    \Case{\cref{equ:clock-vi-ua}}
        Recall that the new transaction \( \txid[\cl](n,m) \).
        Consider any write operation \( \opW(\key,\val) \in \fp \).
        Let \( \clockshard = \ShardOf(\clocksi,\key) \) be the shard that contains \( \key \),
        and \( (\clockkvs,\stub) = \clocksi(\clockshard) \) be the local key-value store.
        By \( \rCLOCKPrepare \),
        there must be no version for the key \( \key \)
        with the committed or preparation time greater than \( m \),
        that is,
        \[
            \Forall{\idx,n'} \clockkvs(\key,\idx) = (\stub,n',\stub) \implies n' < m .
        \]
        By the definition of \( \vi = \ClockView(\kvs,\clocktime) \),
        we prove \cref{equ:clock-vi-ua}. \qedhere
    \end{enumerate}
\end{enumerate}
\end {axp@oldproof}
\begin{lemma}[Clock-SI \texorpdfstring{\(\WR\)}{\texttt{WR}}]
\label{lem:clock-si-wr}
Assume an annotated normalised  Clock-SI trace \( \clockexttrc \),
and the kv-store trace induced by the Clock-SI trace \( \progtrc = \ClockToKVTrace(\clockexttrc)\).
Given final kv-store \( \kvs \) in \( \progtrc \),
that is, \( (\kvs,\stub,\stub,\stub) = \LastConf(\progtrc) \),
and a write-read edge, \( \Tuple{ \clocktxid[\cl](n,m) , \clocktxid[\cl'](n',m') } \in \WR[\kvs](\key) \),
then \( \clocktxid[\cl](n,m) \) is the latest transaction that
write to key \( \key \) and commits before \( \txid[\cl'](n',m') \) starts,
that is,
\begin{Formulae}*
& \begin{Formula}
    n = \Max(\Set{n'' | \Exists{\idx,\cl'',m''} \clocktxid[\cl''](n'',m'') = \WtOf(\kvs(\key,\idx))} )
    \land n < m' .
\end{Formula}
\end{Formulae}
\end{lemma}
\begin{proof}
By the definition of \( \ClockToKVTrace \)
and \( \Tuple{ \clocktxid[\cl](n,m) , \clocktxid[\cl'](n',m') } \in \WR[\kvs](\key) \),
the transaction  \( \clocktxid[\cl'](n',m')  \)
commits after the commit of \( \clocktxid[\cl](n,m) \), that is, \( m < m'\).
This means that there exists a prefix of \( \clockexttrc \) and a corresponding prefix of \( \progtrc \),
in which the last transaction is \(  \clocktxid[\cl'](n',m') \).
Let \( \clockexttrc' \) denote the prefix of \( \clockexttrc \),
and \( \progtrc' \) denote the prefix of \( \progtrc \).
We have \( \progtrc' = \ClockToKVTrace(\clockexttrc') \).
Since \( \clockexttrc' \) is a normalised trace, then
\[
    \clockexttrc' = \ToClockProg {\clockexttrc'' | \lb -> \clockexttrc^* }
    \land \CLOCKAtomic(\clockexttrc^*,\cl',\clockshard,n') .
\]
Let \( (\clocksi,\clockclientenv,\clenv,\clockrunprog) = \clockexttrc^*\Proj{0} \).
Let \( \progtrc'' = \ClockToKVTrace(\ToClockProg{\clockexttrc'' | \lb -> \clocksi | \clockclientenv  | \clenv | \clockrunprog } ) \)
and \( (\kvs'',\vienv'',\clenv'',\prog'') = \Last(\progtrc'') \).
By the definition of \( \ClockToKVTrace \), we have
\[
 \progtrc' = \ToProg{ \progtrc'' | \lbTrans{\vi,\fp} -> \kvs^* | \vienv''\UpdateFunc{\cl' -> \vi'} | \clenv^* | \prog^*}
\]
where
\begin{Formulae}*
\begin{Formula}
\vi = \ClockView(\kvs'',m') \land \fp = \ClockFp(\emptyset,\clockexttrc^*)
\\ {} \land \kvs^* = \UpdateKV(\kvs'',\vi,\fp,\clocktxid[\cl'](n',m')) \land \vi' = \ClockView(\kvs^*,m')
\end{Formula}
\end{Formulae}
Because \( \clocktxid[\cl'](n',m') \) read the key \( \key \) in \( \kvs^* \),
then \( \opR(\key,\val) \in \fp \).
By the definition of  \( \fp = \ClockFp(\emptyset,\clockexttrc^*) \) and \cref{prop:well-formed-clock-fp},
there exists a read step that read from the shard \( \clockshard \) in  \( \clockexttrc^* \):
\begin{Formulae}*
\begin{Formula}
\clockexttrc^* = \ToClockProg{\cdots | \stub
                            -> \clocksi | \stub | \stub | \clockrunprog\UpdateFunc{\cl' ->
                                                        \pruntrans{\plookup{\var}{\expr}; \trans}%
                                                        {\fp',\emptyset}%
                                                        {m',\clockshard} }
                                        | \lbCLOCKOp[\cl'](\clockshard){\opR(\key,\val),m',n'} -> \ }
                \\ \ToClockProg{ \clocksi | \stub | \stub | \clockrunprog\UpdateFunc{\cl' ->
                                                        \pruntrans{\trans}%
                                                        {\fp' \AddOp \opR(\key,\val),\emptyset}%
                                                        {m',\clockshard} }
                            | \stub -> \cdots }
\end{Formula}
\end{Formulae}
where the free variables are existentially quantified.
By the \( \rCLOCKReadShard \) rule,
step \( \lbCLOCKOp[\cl'](\clockshard){\opR(\key,\val),m',n'}  \) read the version of \( \key \)
with time \( \clocktime \)
such that
\begin{Formulae}
\begin{Formula}
    \Exists{\clockkvs} (\clockkvs,\stub) = \clocksi(\clockshard)
    \land \clocktime = \Max(\Set{\clocktime' | \Exists{\idx} \clockkvs(\key,\idx) = (\stub,\clocktime') \land \clocktime' < m'}) .
    \label{equ:read-max-in-kvs-match-in-clock-si}
\end{Formula}
\end{Formulae}
Note that the state of \( \clocksi \) has not changed until the read step,
because of \( \CLOCKAtomic(\clockexttrc^*,\cl',\clockshard,n') \).
Thus, by the definition of \( \progtrc'' = \ClockToKVTrace(\ToClockProg{\clockexttrc'' | \lb
            -> \clocksi | \clockclientenv  | \clenv | \clockrunprog } ) \)
and \( (\kvs'',\vienv'',\clenv'',\prog'') = \Last(\progtrc'') \),
we have \( \kvs''(\key,\idx) = (\val,\clocktxid[\cl](n,m),\stub)\) for some \( \idx \),
By the definition of \( \vi = \ClockView(\kvs'',m') \), we have \( \idx \in \vi(\key) \).
Then by \cref{equ:read-max-in-kvs-match-in-clock-si},
and the definition of \( \kvs^* = \UpdateKV(\kvs'',\vi,\fp,\clocktxid[\cl'](n',m'))  \),
we have the proof.
\end{proof}
