\subsection{Adequate of KV-Store Semantic}

Our main aim is to prove that for any program $\prog$, 
the set of  kv-stores generated by $\prog$ under $\ET$ 
corresponds to all the possible abstract executions that 
can be obtained by running $\prog$ on a database that satisfies the axiomatic definition $\Ax$. 
In this sense, we aim to establish that our operational semantics is \emph{adequate}.

More precisely, suppose that a given execution test $\ET$ captures precisely 
a consistency model defined in the axiomatic style, using a set of 
axioms $\Ax$ and a resolution policy $\RP$ over abstract executions.
That is, for any abstract execution $\aexec$ that satisfies 
the axioms $\Ax$ and the resolution policy $\RP$, then $\KVtrace(\ET_{\top}, \aexec) \cap \CMs(\ET) \neq \emptyset$; 
and for any $\tr \in \CMs(\ET)$, there exists an abstract execution 
$\aexec \in \aeset(\tr)$ that satisfies the axioms $\Ax$ and the resolution policy $\RP$. 

To recall, we have already defined what is the set of all possible behaviours 
that can be produced by a program $\prog$ under a given consistency model $\CM$, for 
which an axiomatic definition $(\RP, \Ax)$ is known in {thm:consistency-intersect-anarchic}. 
It in turn requires: 
\textbf{(i)} the set of all possible behaviours that may be exhibited by a program $\prog$, independently of the consistency model, 
\ie \( \interpr{\prog}_{\anarchic} \) that is defined in \cref{def:anarchic-model,def:axiom-to-prog}; 
and \textbf{(ii)} defining the set of all possible behaviours that 
are allowed by a given consistency model $\CM$, 
\ie \( \CMa(\RP,\Ax) \) that is defined in \cref{def:axiom-to-aexec}.
Then the set of all possible behaviours of $\prog$ under $\CM$ 
is obtained by intersecting the two sets above (\cref{thm:consistency-intersect-anarchic}).
The kv-store semantics is intrinsically not expressive enough to tackle \textbf{(i)}. 
By \cref{cor:kvtrace2aexec}, only those kv-store arising from
abstract executions satisfying the last write wins resolution policy 
can be captured in the kv-store framework.
Further than \cref{cor:kvtrace2aexec}, we now consider the program \( \prog \).
The \cref{prop:kv2aexec_transition} and \cref{prop:aexec2kv_transition} show 
the connection between reduction steps between 
the last write win resolution policy \( (\RP_{\LWW}, \emptyset) \) 
and the most permissive execution test \( \ET_\top \).

\begin{proposition}[Permissive execution test to last write win]
\label{prop:kv2aexec_transition}
Suppose that $(\mkvs, \vienv, \thdenv), \prog \toT{(\cl, \vi, \fp)}_{\ET_{\top}} (\mkvs', 
\vienv', \thdenv'), \prog'$. Assuming an abstract execution $\aexec$ 
such that $\hh_{\aexec} = \mkvs$, and a set of read-only transactions $\T \subseteq \T_{\aexec}$,
then there exists an abstract execution $\aexec'$ such that $\hh_{\aexec'} = \mkvs'$, and 
\[
(\aexec, \thdenv), \prog \toA{(\cl, \T \cup \Tx(\mkvs, \vi), \fp)}_{(\RP_{\LWW}, \emptyset)}
(\aexec', \thdenv'), \prog'
\]
\end{proposition}
\begin{proof}
Suppose that $(\mkvs, \vienv, \thdenv), \prog \toT{(\cl, \vi, \fp)}_{\ET_{\top}} (\mkvs', \vienv', \thdenv), \prog'$. 
This transition can only be inferred by applying Rule \rl{PSingleThread}, meaning that 
\begin{itemize}
\item $\prog(\cl) \mapsto \cmd$ for some command $\cmd$, 
\item $\cl \vdash (\mkvs, \vienv(\cl), \thdenv(\cl)), \cmd \toT{(\cl, \vi, \fp)}_{\ET_{\top}} (\mkvs', \vi', \stk'), \cmd'$ 
for some $\vi', \stk'$, and 
\item $\vienv' = \vienv\rmto{\cl}{\vi'}$, $\thdenv' = \thdenv\rmto{\cl}{\stk'}$ and $\prog' = \prog\rmto{\cl}{\cmd'}$. 
\end{itemize}
Let $\aexec$ be such that $\hh_{\aexec} = \mkvs$, and let $\T \subseteq \T_{\aexec}$ be a set of read-only transactions in $\aexec$. 
It suffices to show that there exists an abstract execution $\aexec'$ such that 
$\hh_{\aexec'} = \mkvs'$, and 
\[
    \cl \vdash (\aexec, \thdenv(\cl)), \cmd \toA{(\cl, \T \cup \Tx(\mkvs, \vi), \fp)}_{(\RP_{\LWW}, \emptyset)} (\aexec', \stk'), \cmd'.
\]
By the \rl{ASingleThread} rule, we obtain 
\[ 
    (\aexec, \thdenv) \prog, \toA{(\cl, \T \cup \Tx(\mkvs,\vi), \fp)}_{(\RP_{\LWW}, \emptyset)} (\aexec' ,\thdenv'), \prog'
\]
Now we perform a rule induction on the derivation of the transition 
\[
    \cl \vdash (\mkvs, \vienv(\cl), \thdenv(\cl)), \cmd \toT{(\cl, \vi, \fp)}_{\ET_{\top}} (\mkvs', \vi', \sn'), \cmd'
\]
\caseB{\rl{PCommit}}
This implies that 
\begin{itemize}
\item $\cmd = \ptrans{\trans}$ for some $\trans$, and $\cmd' = \pskip$,
\item $\vienv(\cl) \viewleq \vi$, 
\item let $\sn = \snapshot(\mkvs, \vi)$; then $(\thdenv(\cl), \sn, \emptyset) \toL^{\ast} (\stk', \_, \fp)$, 
\item $hh' = \updateKV(\mkvs, \vi, \txid, \fp)$ for some $\txid \in \nextTxid(\mkvs, \cl)$, and
\item $\ET_{\top} \vdash \mkvs, \vi \triangleright \fp: \vi'$.
\end{itemize}
Choose an arbitrary set of of read-only transactions $\T \subseteq \T_{\aexec}$.
We observe that $\getView(\aexec, \T \cup \Tx(\mkvs, \vi)) = \vi$ since $\hh_{\aexec} = \mkvs$ and \cref{prop:getview.tx}.
We can now apply \cref{prop:compatible.aexec2kv} and ensure that $\RP_{\LWW}(\aexec, \T \cup \Tx(\mkvs, \vi)) = \{\sn\}$.
Let $\aexec' = \extend(\aexec, \txid, \T \cup \Tx(\mkvs, \vi)), \fp)$. 
Because $\getView(\aexec, \T \cup \Tx(\mkvs, \vi)) = \vi$, $\hh_{\aexec} = \mkvs$,
then by \cref{prop:extend.update.sameop} we have that $\hh_{\aexec'} = \updateKV(\mkvs, \vi, \txid, \fp) = \mkvs'$. 
To summarise, we have that $\T \cup \Tx(\mkvs, \vi) \subseteq \T_{\aexec}$, $\sn \in \RP_{\LWW}(\aexec, \T \cup \Tx(\mkvs, \vi))$,
$(\thdenv(\cl), \sn, \emptyset) \toL^{\ast} (\stk', \_, \fp)$ and $\txid \in \nextTxid(\T_{\aexec}, \cl)$. 
Now we can apply \rl{ACommit} and infer
\[
\cl \vdash (\aexec, \thdenv(\cl)), \ptrans{\trans} \toA{(\cl, \T \cup \Tx(\hh_{\aexec}, \vi))}_{(\RP_{\LWW}, \emptyset)} 
(\aexec', \stk'), \pskip
\]
which is exactly what we wanted to prove. 

\caseB{\rl{PPrimitive},\rl{PChoice},\rl{PIter},\rl{PSeqSkip}}
These cases are trivial since they do not alter the state of \( \mkvs \).
\caseI{\rl{PSeq}}
It is derived by the \ih
\end{proof}

\begin{proposition}[Last write win to permissive execution test]
\label{prop:aexec2kv_transition}
Suppose that $(\aexec, \thdenv), \prog \toA{(\cl, \T, \fp)}_{(\RP_{\LWW}, \emptyset)} (\aexec', \thdenv'), \prog'$. 
Then for any $\vienv$ and $\vi \in \Views(\hh_{\aexec})$ such that $\vi \viewleq \getView(\aexec, \T)$, 
the following holds:
\[
    (\hh_{\aexec}, \vienv\rmto{\cl}{\vi}, \thdenv), \prog 
    \toA{(\cl, \getView(\aexec, \T), \fp)}_{\ET_{\top}} (\hh_{\aexec'}, \vienv, \thdenv'), \prog'
\]
\end{proposition}
\begin{proof}
Suppose that $(\aexec, \thdenv), \prog \toA{(\cl, \T, \fp)}_{(\RP_{\LWW}, \emptyset)} (\aexec', \thdenv'), \prog'$. 
Fix a function $\vienv$ from clients in $\dom(\prog)$ to views in $\Views(\mkvs)$, and a view $\vi \viewleq \getView(\aexec, \T)$.
We show that 
$(\hh_{\aexec}, \vienv\rmto{\cl}{\vi}, \thdenv) \toT{(\cl, \getView(\aexec, \T), \fp)}_{\ET_{\top}} (\hh_{\aexec'}, 
\vienv, \thdenv'), \prog'$. 

Note that the transition 
$\aexec, \thdenv, \prog \toA{(\cl, \T, \fp)}_{(\RP_{\LWW}, \emptyset)} (\aexec', \thdenv'), \prog'$ 
can only be inferred using \rl{ASingleThread} rule, 
from which it follows that 
\[
    \cl \vdash (\aexec, \thdenv(\cl)), \prog(\cl) 
    \toA{(\cl, \T, \fp)}_{(\RP_{\LWW}, \emptyset)} (\aexec' ,\stk'), \cmd'
\]
for some $\stk'$ such that $\thdenv' = \thdenv\rmto{\cl}{\stk'}$ 
and $\cmd'$ such that $\prog' = \prog\rmto{\cl}{\cmd'}$.
It suffices to show that 
\[
    \cl \vdash (\hh_\aexec, \vi, \thdenv(\cl)), \prog(\cl) 
   \toT{(\cl, \getView(\hh_{\aexec}, \T), \fp)}_{\ET_{\top}} 
    (\hh_{\aexec'}, \vienv(\cl), \stk'), \cmd'
\]
Then by applying \rl{PSingleThread} we obtain 
\[
    (\hh_{\aexec}, \vienv\rmto{\cl}{\vi}, \thdenv), \prog 
    \toT{(\cl, \getView(\hh_{\aexec}, \T), \fp)}_{\ET_{\top}} 
    (\hh_{\aexec'}, \vienv, \thdenv'), \prog'
\]
The rest of the proof is performed by a rule induction on the derivation to inter 
\[ 
    \cl \vdash (\aexec, \thdenv(\cl)), \prog(\cl) 
    \toA{(\cl, \T, \fp)}_{(\RP_{\LWW}, \emptyset)} (\aexec', \stk'), \cmd'
\]
\caseB{\rl{ACommit}}
In this case we have that 
\begin{itemize}
    \item $\prog = \ptrans{\trans}$, 
    \item $\prog' = \pskip$, 
    \item $(\thdenv(\cl), \sn, \emptyset), \trans \toL^{\ast} (\stk', \_, \fp), \pskip$ for an index $\sn \in \RP_{\LWW}(\aexec, \T)$, and 
    \item $\aexec' = \extend(\aexec, \txid, \T, \fp)$ for some $\txid \in \nextTxid(\aexec, \cl)$. 
\end{itemize}
Furthermore, it is easy to see by induction on the length of the derivation 
$(\thdenv(\cl), \sn, \emptyset), \trans \toL^{\ast} (\stk', \_, \fp), \pskip$, 
that whenever $(\otR, \key, \val) \in \fp$ then $\sn(\key) = \val$.
Note that $\snapshot(\hh_{\aexec}, \getView(\aexec, \T)) = \sn$ by \cref{prop:compatible.aexec2kv}.
Also, if $(\otR,\key, \val) \in \fp$ then $\sn(\key) = \val$, which is possible only if  
$\hh_{\aexec}(\key, \max_{<}(\getView(\aexec, \T)(\key))) = (\val, \_, \_)$.
This ensures that $\ET_{\top} \vdash (\hh_{\aexec}, \getView(\aexec, \T)) \triangleright \fp: \vienv(\cl)$. 
\ac{There should be a condition here that $\vienv(\cl)(\key)$ is the same as $\getView(\aexec, \T)(\key)$ 
for any $\key$ that is neither read nor written by $\fp$.} 
We can now combine all the facts above to apply rule \rl{PCommit}
\[
    \cl \vdash (\hh_{\aexec}, \vi, \thdenv(\cl)), \ptrans{\trans}
    \toT{(\cl, \getView(\hh_{\aexec}, \T), \fp)}_{\ET_{\top}} 
    (\mkvs', \vienv(\cl), \stk'), \pskip, 
\] 
where $\mkvs' = \updateKV(\hh_{\aexec}, \txid, \getView(\aexec, \T), \fp)$. 
Recall that $\aexec' = \extend(\aexec, \T, \txid, \fp)$. 
Therefore by \cref{prop:extend.update.sameop} we have that $\mkvs' = \hh_{\aexec'}$, 
which concludes the proof of this case.

\caseB{\rl{APrimitive},\rl{AChoice},\rl{AIter},\rl{ASeqSkip}}
These cases are trivial since they do not alter the state of \( \aexec \).
\caseI{\rl{ASeq}}
It is derived by the \ih
\end{proof}

\begin{corollary}
For any program $\prog$, 
\[
\interpr{\prog}_{\ET_{\top}} = \{\hh_{\aexec} \mid \aexec \in \interpr{\prog}_{(\RP_{\LWW}, \emptyset)}\}
\]
\end{corollary}
\begin{proof}
    It can be derived by \cref{prop:aexec2kv_transition} and \cref{prop:kv2aexec_transition}.
\end{proof}


