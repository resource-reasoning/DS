\section{Applications}
\label{sec:applications}

We showcase the applications of or formalism by showing how we can prove the robustness of transactional libraries (\cref{sec:program-analysis}), and verify database implementations (\cref{sec:verify-impl}).

\subsection{Program Analysis}
\label{sec:program-analysis}
A transactional library, $L = \{\ptrans{\trans}_{i}\}_{i \in I}$, 
provides a set of operations through which the library clients can access the kv-store. 
For instance, the set of operations of the counter library on key $\ke$ in \cref{sec:overview} is $\Counter(\ke) = \{\ctrinc(\ke), \ctrread(\ke)\}$.
A program $\prog$ is a \emph{client} of library $L$ if the only transactional calls in $\prog$ are those to library $L$ operations.  
A transactional library $L$ is \emph{robust} against an execution test $\ET$ if: 
for all client programs $\prog$ of library $L$, the set of kv-stores by running $\prog$ are included in the set of kv-stores obtained by running $\prog$ under $\ET_{\SER}$.
As an application of our theory, we show how we can prove the robustness of simple transactional libraries. 
In the following, we write $\CMs(\ET, L)$ for the set of kv-stores obtained from running a client program $\prog$ of $L$. 

We prove the robustness of single and multiple counters (\cref{sec:overview}) against $\ET_{\PSI}$ and $\ET_{\SI}$, respectively.
Previous techniques for checking robustness~\cite{giovanni_concur16,SIanalysis,laws,sureshConcur} 
are based on static analysis: since the session order of clients cannot be determined at compile 
time, these techniques abstract from sessions. 
To our knowledge, we give the first robustness proofs that take sessions into account.

Our proof technique for robustness uses the following result, which is the kv-store counterpart of another well-known result on dependency graphs~\cite{adya}:
\begin{theorem}
\label{thm:serialisable_nocycle}
For all kv-stores $\hh$: $\hh \in \CMs(\ET_{\SER})$ iff $(\PO_{\hh} \cup \RF_{\hh} 
\cup \VO_{\hh} \cup \AD_{\hh})^{+}$ is irreflexive.
\end{theorem}
Given this theorem, to prove the robustness of $L$ against $\ET$, 
for an arbitrary a kv-store $\hh$, we 
\begin{enumerate*}
	\item identify a property of $\hh$ that remains \emph{invariant} when running any client program of $L$ on $\hh$; and 
	\item show that the invariant implies the irreflexivity of $(\PO_{\hh} \cup \RF_{\hh} \cup \VO_{\hh} \cup \AD_{\hh})^{+}$.
\end{enumerate*}

\mypar{Robustness of a Single Counter against $\ET_{\PSI}$}
Pick an arbitrary key $\ke$ and $\hh \in \CMs(\ET_{\PSI}, \mathsf{Counter}(\ke))$, 
with $\Counter(\ke) {=} \{\ctrinc(\ke), \ctrread(\ke)\}$. 
Note that clients can only write to $\ke$ by calling $\ctrinc(\ke)$.
As such, since $\ET_{\PSI}$ enforces write conflict freedom, we have: 
% in all $\hh \in \CMs(\ET_{\PSI}, \mathsf{Counter})$, we have:
$\for{\txid, i > 0} \txid {=} \WTx(\hh(\ke, i)) \implies \txid \in \RTx(\hh(\ke, i{-}1))$. 
Furthermore, because $\ET_{\PSI}$ satisfies monotonic reads ($\ET_{\PSI} \subseteq \ET_{\MRd}$),
the order in which clients observe the versions of $\ke$ (by calling $\ctrread(\ke)$), 
is consistent with the order of the index of such versions in $\hh(\ke)$:
%
\begin{align*}
	\hh(\ke) & = (0, \txid_{0}, \T^{\mathsf{r}}_{0} \cup \{\txid^{\mathsf{w}}_1\}) 
	\lcat (1, \txid^{\mathsf{w}}_{1}, \T^{\mathsf{r}}_{1} \cup \{\txid^{\mathsf{w}}_2\}) 
	\lcat \cdots  \\
	& \qquad \cdots \lcat (n-1, \txid^{\mathsf{w}}_{n-1}, \T^{\mathsf{r}}_{n-1} \cup \Set{\txid^{\mathsf{w}}_n})
	\lcat (n, \txid^{\mathsf{w}}_n, \T^{\mathsf{r}}_{n})
\end{align*}
%
where $\{\txid^{\mathsf{w}}_{i}\}_{i=1}^{n}$ is the set of transactions calling $\ctrinc(\ke)$, 
and $\bigcup_{i=0}^{n} \T^{\mathsf{r}}_{i}$ is the set of transactions calling $\ctrread(\ke)$. 

Next, we define a relation $\dashrightarrow$ between
the transactions in $\hh$ as the smallest transitive relation that 
satisfies the following: 
\begin{enumerate*}
	\item $\txid^{\mathsf{w}}_{i} 
	\dashrightarrow \txid$ if $\txid \in \T^{\mathsf{r}}_{i}$ 
	or $\txid {=} \txid^{\mathsf{w}}_{i+1}$; 
	\item $\txid \dashrightarrow \txid'$ 
	for some $\txid \in \T^{\mathsf{r}}_{i}$,
	if $\txid' {=} \txid^{\mathsf{w}}_{i+1}$
	or $\txid' \in \T^{\mathsf{r}}_{i} \land \txid \xrightarrow{\PO} \txid'$. 
\end{enumerate*}
%
Note that $\dashrightarrow$ yields a total order over the transactions in $\hh$, 
and includes $\PO_{\hh} \cup \RF_{\hh} \cup \VO_{\hh} \cup \AD_{\hh}$. 
As such, $(\PO_{\hh} \cup \RF_{\hh} \cup \VO_{\hh} \cup \AD_{\hh})^+$ is irreflexive, 
ensuring the robustness of $\Counter(\ke)$ against $\ET_{\PSI}$.


\mypar{Robustness of Multiple Counters against $\ET_{\SI}$}
Recall from \cref{sec:overview} that for the library comprising two or more counters we can 
observe the long fork anomaly disallowed under serialisability ($\ET_{\SER}$). 
While a library comprising a single counter is robust against 
As such, unlike the single counter above, multiple counters are not robust against $\ET_{\PSI}$. 
The long fork anomaly arises because different clients can observe increments 
over two different counters in a different order.
As this anomaly does not arise under $\SI$, 
we show that if we strengthen $\ET_{\PSI}$ to $\ET_{\SI}$, 
we can analogously recover the robustness of multiple counters.
For simplicity, here we assume that the library comprises only two counters: 
$\mathsf{Counters} {=} \Counter(\ke_1) \cup \Counter(\ke_2)$.

We use the following result, which is the kv-store counterpart of a well-known result for SI~\cite{fekete-tods,SIanalysis}: 
\begin{theorem}
\label{thm:si_cycles}
For all $\hh \in \CMs(\ET_{\SI})$, any cycle in $(\PO_{\hh} \cup \RF_{\hh} \cup \VO_{\hh} \cup \AD_{\hh})^+$ has two adjacent $\AD_{\hh}$-edges.
\end{theorem}

Consider a kv-store $\hh \in \CMs(\ET_{\SI}, \mathsf{Counters})$. 
As $\ET_{\SI} \subseteq \ET_{\PSI}$, the list of versions of $\hh(\ke_1)$ and $\hh(\ke_2)$ 
must both follow the same structure as that described above for a single counter under $\ET_{\PSI}$. 
Recall that this structure embeds a total order $\dashrightarrow$ over transactions in $\hh(\ke_1)$ and $\hh(\ke_2)$.
However, since a client can perform operations over two different counters, the $\dashrightarrow$ no longer comprises $\SO_{\hh}$. 

We thus define a second relation $\twoheadrightarrow$, where
$\txid \twoheadrightarrow \txid'$ if $\txid \in \{\WTx(\hh(\ke_{i}, \_)\} \cup \RTx(\hh(\ke_{i}, \_))$ 
and $\txid' \in \{\WTx(\hh(\ke_{j}, \_)\} \cup \RTx(\hh(\ke_{j}, \_))$ with $i,j \in \Set{1,2} \land j \neq i$,  
and $\txid \xrightarrow{\PO} \txid'$.
Relation $\twoheadrightarrow$ tracks the session order of transactions performing operations on different keys. 
Let $\rightarrow \eqdef (\dashrightarrow \cup \twoheadrightarrow)^{+}$; 
we then know that $\rightarrow$ embeds $(\PO_{\hh} \cup \RF_{\hh} \cup \VO_{\hh} \cup \AD_{\hh})^{+}$.
Furthermore, because $\mathsf{Counters}$ contains no operation that accesses both $\ke_1$ and $\ke_2$, and since $\dashrightarrow$ is acyclic, 
any cycle in $\rightarrow$ contains at least two edges from $\twoheadrightarrow$. 
In \cref{app:robustness} we show that the existence of such a cycle implies the 
existence of a cycle in $\rightarrow$ of the form $\txid \dashrightarrow \txid_{a} \twoheadrightarrow 
\txid_{b} \dashrightarrow \txid_{c} \twoheadrightarrow \txid$. 
However, this cannot happen in $\hh$, as otherwise we would have a cycle in $(\PO_{\hh} \cup \RF_{\hh} \cup \VO_{\hh} \cup \AD_{\hh})^{+}$ with no adjacent $\AD_{\hh}$-edges (a $\twoheadrightarrow$ edge represents two  $\PO_{\hh}$-related transactions, 
thus contradicting \cref{thm:si_cycles}). 
It then follows that $\rightarrow$ is irreflexive, and thus so is $(\PO_{\hh} \cup \RF_{\hh} \cup \VO_{\hh} \cup \AD_{\hh})^+$.

\subsection{Verifying Database Implementations}
\label{sec:verify-impl}
%\sx{
%    Short intro why it is good to use our models
%
%    What are cops and then clock-si.
%    how we verify
%}
Our representation of database state as kv-stores and client views closely matches the representation of database state in many well-known implementations~\cite{ramp,rola,cops,wren,redblue,PSI,NMSI,gdur,clocksi,distrsi}.
As such, when verifying such implementations, our state-based formalisms is better-suited than the existing graph-based formalisms of dependency graphs and abstract executions. 
In centralised databases, the state of the centralised server corresponds to a kv-store,
and the local snapshots that transactions operate on are extracted from our views.  
In distributed databases, each replica state corresponds to a view. 
Moreover, since most distributed databases are eventual consistent, 
\ie all replicas eventually agree on the database state,
replica states can be collectively encoded as a kv-store.
We verify the correctness of two database implementations in the literature,
COPS~\cite{cops} and Clock-SI~\cite{clock-si}.

\mypar{COPS}
COPS is a fully replicated database: each replica contains all keys, but their associated values may be out of date.
Database clients operate on a single replica; 
synchronisation between replicas ensures that each replica is in a consistent (albeit out-of-date) state.
The COPS API follows the multiple-readers-single-writer paradigm: 
at any given time, the database can be accessed by either multiple read-only concurrent transactions, or a single writing transaction. 
As such, all versions (on all keys) are totally ordered. 
To ensure causal consistency, each version $\ver$ records a \emph{dependency set}, written $\func{dep}{\ver}$,
tracking the versions on which $\ver$ depends.
A client maintains a context tracking the versions that have been either fetched from, or committed to, other replicas.
%
%When running a read-only transaction, 
%the replica returns a list of versions,  $\vilist = \ver^{1}_{\ke_1}, \dots \ver^{n}_{\ke_n}$,
%such that each $\ver^i_\ke \in \vilist$ is greater than or equal than those in the dependency of $\vilist$.
%That is, $\for{\ke} \for{\ver, \ver_\ke^i \in \vilist} \for{\ver_\ke^j \in \func{dep}{\ver}} i \geq j$. 
%
%%%%%To read multiple keys in a transaction, the replica returns a list of versions \( \vilist = \ver^{i_1}_{\ke_1}, \dots \ver^{i_n}_{\ke_n} \) 
%%%%%that are either equal or greater than any versions in the dependencies,
%%%%%\ie \( \fora{\ke, \ver, \ver^{i}_{\ke}, \ver^{j}_{\ke}} \ver \in \vilist \land \ver^{i}_{\ke} \in \vilist \land \ver^{j}_{\ke} \in \func{dep}{\ver} \implies i \geq j \).
%
%After running a writing transaction, in order to commit a new version to the replica, the client must provide its context. 
%A version is accepted by the replica only once all versions from the dependency have been made known to the same replica,
%otherwise it is put in the pending list.
%
We encode the COPS replicas as a kv-store, and encode client contexts as views.  
%We encode kv-store that includes all versions from all replicas, at any given time.
%A client context then converts to a view on the kv-store, 
%\ie if a version in the context then it is in the view.
We show that the COPS implementation is causally consistent in that it is sound with respect to the $\CMs(\ET_\CC)$
specification, where $\ET_\CC$ is the causal consistency execution test in \cref{fig:execution_tests}.
%We show that the views before and after any COPS transaction,
%satisfy the execution tests for causal consistency in \cref{fig:execution.tests}.
The COPS implementation and our soundness proof are given in \cref{sec:cops}.

\mypar{Clock-SI}
Clock-SI is a \emph{sharded} database implementation for snapshot isolation (SI),
where different shards host disjoint fragments of keys.
As with the original definition of SI, Clock-SI uses timestamps to maintain different versions. 
The clocks on different shards may not agree; however, the difference is assumed to be bounded.
Each key keeps a history of versions, where each version comprises a value and the commit timestamp.
Each transaction $\txid$ is assigned to a designated shard, known as the $\txid$ \emph{coordinator}. 
When $\txid$ starts, it obtains a snapshot and records the snapshot timestamp at its coordinator shard.
Transaction $\txid$ may then read from shards other than its coordinator, so long as the current timestamp at those shards are greater than the recorded snapshot time. 
Once $\txid$ completes, it may commit if  no transaction with a conflicting write has committed since the snapshot time.
%
We encode the shards collectively as a kv-store. 
Each snapshot timestamp is encoded as a view, contains all versions committed before that timestamp.
We show that Clock-SI is sound with respect to the $\CMs(\ET_\SI)$
specification, where $\ET_\SI$ is the snapshot isolation execution test in \cref{fig:execution_tests}.
%We show that the views before and after any COPS transaction,
%satisfy the execution tests for causal consistency in \cref{fig:execution.tests}.
The Clock-SI implementation and our soundness proof are given in \cref{sec:clock-si}.
