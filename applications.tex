\section{Applications}
\label{sec:applications}

We showcase the applications of our formalism by showing how we can prove the robustness of transactional libraries (\cref{sec:program-analysis}), and verifying database protocols
 (\cref{sec:verify-impl}).

\subsection{Program Analysis}
\label{sec:program-analysis}
A transactional library, $L = \Set{\ptrans{\trans}_{i}}_{i \in I}$, 
provides a set of operations through which the library clients can access the kv-store. 
For instance, the set of operations of the counter library on key $\key$ in \cref{sec:overview} is $\Counter(\key) = \Set{\ctrinc(\key), \ctrread(\key)}$.
A program $\prog$ is a \emph{client} of library $L$ if the only transactional calls in $\prog$ are those to library $L$ operations.  
A transactional library $L$ is \emph{robust} against an execution test $\ET$ if: 
for all client programs $\prog$ of library $L$, the set of kv-stores by running $\prog$ are included in the set of kv-stores obtained by running $\prog$ under $\ET_{\SER}$.
As an application of our theory, we show how we can prove the robustness of simple transactional libraries. 
In the following, we write $\CMs(\ET, L)$ for the set of kv-stores obtained from running a client program $\prog$ of $L$. 

We prove the robustness of single and multiple counters (\cref{sec:overview}) against $\ET_{\PSI}$ and $\ET_{\SI}$, respectively.
Previous techniques for checking robustness~\cite{giovanni_concur16,SIanalysis,laws,sureshConcur} 
are based on static analysis: since the session order of clients cannot be determined at compile 
time, these techniques abstract from sessions. 
To our knowledge, we give the first robustness proofs that take sessions into account.

Our proof technique for robustness uses the following result, which is the kv-store counterpart of another well-known result on dependency graphs~\cite{adya}:
\begin{theorem}
\label{thm:serialisable_nocycle}
For all kv-stores $\mkvs$: $\mkvs \in \CMs(\ET_{\SER})$ iff $(\SO \cup \WR_{\mkvs} 
\cup \WW_{\mkvs} \cup \RW_{\mkvs})^{+}$ is irreflexive.
\end{theorem}
Given this theorem, to prove the robustness of $L$ against $\ET$, 
for an arbitrary a kv-store $\mkvs$, we 
\begin{enumerate*}
	\item identify a property of $\mkvs$ that remains \emph{invariant} when running any client program of $L$ on $\mkvs$; and 
	\item show that the invariant implies the irreflexivity of $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^{+}$.
\end{enumerate*}

\mypar{Robustness of a Single Counter against $\ET_{\PSI}$}
Pick an arbitrary key $\key$ and a kv-store $\mkvs \in \CMs(\ET_{\PSI}, \mathsf{Counter}(\key))$, 
with $\Counter(\key) {=} \Set{\ctrinc(\key), \ctrread(\key)}$. 
Note that clients can only write to $\key$ by calling $\ctrinc(\key)$.
As such, since $\ET_{\PSI}$ enforces write conflict freedom, we have: 
% in all $\mkvs \in \CMs(\ET_{\PSI}, \mathsf{Counter})$, we have:
$\fora{\txid, i > 0} \txid {=} \wtOf(\mkvs(\key, i)) \implies \txid \in \rsOf(\mkvs(\key, i{-}1))$. 
Furthermore, because $\ET_{\PSI}$ satisfies monotonic reads ($\ET_{\PSI} \subseteq \ET_{\MR}$),
the order in which clients observe the versions of $\key$ (by calling $\ctrread(\key)$), 
is consistent with the order of the index of such versions in $\mkvs(\key)$:
%
%
{%
\begin{align*}
	\mkvs(\key) & = (0, \txid_{0}, \txidset^{\mathsf{r}}_{0} \cup \Set{\txid^{\mathsf{w}}_1}) 
	\lcat (1, \txid^{\mathsf{w}}_{1}, \txidset^{\mathsf{r}}_{1} \cup \Set{\txid^{\mathsf{w}}_2}) 
	\lcat \cdots \lcat (n-1, \txid^{\mathsf{w}}_{n-1}, \txidset^{\mathsf{r}}_{n-1} \cup \Set{\txid^{\mathsf{w}}_n})
	\lcat (n, \txid^{\mathsf{w}}_n, \txidset^{\mathsf{r}}_{n})
\end{align*}%
}%
%
\noindent where $\Set{\txid^{\mathsf{w}}_{i}}_{i=1}^{n}$ is the set of transactions calling $\ctrinc(\key)$, 
and $\bigcup_{i=0}^{n} \txidset^{\mathsf{r}}_{i}$ is the set of transactions calling $\ctrread(\key)$. 

Next, we define a relation $\dashrightarrow$ between
the transactions in $\mkvs$ as the smallest transitive relation that 
satisfies the following: 
\begin{enumerate*}
	\item $\txid^{\mathsf{w}}_{i} 
	\dashrightarrow \txid$ if $\txid \in \txidset^{\mathsf{r}}_{i}$ 
	or $\txid {=} \txid^{\mathsf{w}}_{i+1}$; 
	\item $\txid \dashrightarrow \txid'$ 
	for some $\txid \in \txidset^{\mathsf{r}}_{i}$,
	if $\txid' {=} \txid^{\mathsf{w}}_{i+1}$
	or $\txid' \in \txidset^{\mathsf{r}}_{i} \land \txid \toEDGE{\SO} \txid'$. 
\end{enumerate*}
%
Note that $\dashrightarrow$ yields a total order over the transactions in $\mkvs$, 
and includes $\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs}$. 
As such, $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^+$ is irreflexive, 
ensuring the robustness of $\Counter(\key)$ against $\ET_{\PSI}$.


\mypar{Robustness of Multiple Counters against $\ET_{\SI}$}. 
Recall from \cref{sec:overview} that for the library comprising two or more counters we can 
observe the long fork anomaly disallowed under serialisability ($\ET_{\SER}$). 
As such, multiple counters are not robust against $\ET_{\PSI}$. 
The long fork anomaly arises because different clients can observe increments 
over two different counters in a different order.
This anomaly does not arise under $\SI$: 
in fact, multiple counters are robust against $\ET_{\SI}$. 
%$\ET_{\PSI}$ to $\ET_{\SI}$, 
%we can analogously recover the robustness of multiple counters.
For simplicity, here we assume that the library comprises only two counters: 
$\mathsf{Counters} {=} \Counter(\key_1) \cup \Counter(\key_2)$.
%We use the following result, which is the kv-store counterpart of a well-known result for SI~\cite{fekete-tods,SIanalysis}: 
%\begin{theorem}
%\label{thm:si_cycles}
%For all $\mkvs \in \CMs(\ET_{\SI})$, any cycle in $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^+$ has two adjacent $\RW_{\mkvs}$-edges.
%\end{theorem}

Consider a kv-store $\mkvs \in \CMs(\ET_{\SI}, \mathsf{Counters})$. 
As $\ET_{\SI} \subseteq \ET_{\PSI}$, the list of versions of $\mkvs(\key_1)$ and $\mkvs(\key_2)$ 
must both follow the same structure as that described for a single counter under $\ET_{\PSI}$. 
Recall that this structure embeds a total order $\dashrightarrow$ over transactions in $\mkvs(\key_1)$ and $\mkvs(\key_2)$, 
which embeds an acyclic relation $\WR_{\mkvs} \cup \WW_{\mkvs} \cup \RF_{\mkvs}$. 
However, since a client can perform operations over two different counters, the $\dashrightarrow$ no longer comprises $\SO_{\mkvs}$. 

We define a second relation $\twoheadrightarrow$ that tracks the session order of transactions accessing different keys: 
$\txid \twoheadrightarrow \txid'$ if $\txid \in \Set{\wtOf(\mkvs(\key_{i}, \stub)} \cup \rsOf(\mkvs(\key_{i}, \stub))$ 
and $\txid' \in \Set{\wtOf(\mkvs(\key_{j}, \stub))} \cup \rsOf(\mkvs(\key_{j}, \stub))$ with $i,j \in \Set{1,2} \land j \neq i$,  
and $\txid \toEDGE{\SO} \txid'$. The combined relation $(\dashrightarrow \cup \twoheadrightarrow)$ embeds 
$(\SO_{\hh} \cup \WR_{\hh} \cup \WW_{\hh} \cup \RW_{\hh})$; next, we prove that the acyclicity of the relation $(\dashrightarrow \cup \twoheadrightarrow)$ 
is acyclic, from which it follows that the kv-store $\hh$ is serialisable. More specifically, we prove that any $\ET_{\SI}$-trace
%by induction on the length of a $\ET_{\SI}$-trace 
in $\CMs(\ET_{\SI}, \mathsf{Counter}(\key_1) \cup \mathsf{Counter}(\key_2))$ terminates in a configuration of the form $(\mkvs, \_)$ 
such that the relation $(\dashrightarrow \cup \twoheadrightarrow)$ over $\mkvs$ is irreflexive; the proof is by induction on the 
length of the $\ET_{\SI}$-trace. Here we only show the details of the inductive step of the proof in the most interesting case, 
that is one where a cycle in the relation $(\dashrightarrow \cup \twoheadrightarrow)$ is created because 
client $\cl_{1}$ reads a version of some key, e.g. $\key_{1}$, after accessing the other, e.g. $\key_{2}$, and the order 
of such operations seemingly contradicts the order of the versions of $\key_{1}, \key_{2}$ observed by another client 
$\cl_{2}$: as we will see shortly, this case leads to a contradiction. 
Let $\mkvs_{\mathsf{pre}}$ be a kv-store such that 
\begin{align*}
\mkvs(\key_{1}) & = (0, \txid_{0}, \txidset^{\mathsf{r},1}_{0} \cup \Set{\txid^{\mathsf{w},1}_1}) 
	%\lcat (1, \txid^{\mathsf{w},1}_{1}, \txidset^{\mathsf{r},1}_{1} \cup \Set{\txid^{\mathsf{w},1}_2}) 
	\lcat \cdots \lcat (n-1, \txid^{\mathsf{w},1}_{n-1}, \txidset^{\mathsf{r},1}_{n-1} \cup \Set{\txid^{\mathsf{w},1}_n})
	\lcat (n, \txid^{\mathsf{w},1}_n, \txidset^{\mathsf{r},1}_{n})\\
\mkvs(\key_{2}) & = (0, \txid_{0}, \txidset^{\mathsf{r},2}_{0} \cup \Set{\txid^{\mathsf{w},2}_1}) 
	%\lcat (1, \txid^{\mathsf{w},2}_{1}, \txidset^{\mathsf{r},2}_{1} \cup \Set{\txid^{\mathsf{w},2}_2}) 
	\lcat \cdots \lcat (m-1, \txid^{\mathsf{w},2}_{m-1}, \txidset^{\mathsf{r},1}_{m-1} \cup \Set{\txid^{\mathsf{w},2}_m})
	\lcat (m, \txid^{\mathsf{w},2}_m, \txidset^{\mathsf{r},2}_{m})
\end{align*}
and suppose that $(\mkvs, \vienv) \toET{\cl_{1}, (\otR, \key_{1}, \_)}[\ET_\SI] (\mkvs', \vienv')$, causing the relation 
$(\dashrightarrow \cup \twoheadrightarrow)$ to contain a cycle in $\mkvs'$. Let $i = \max_{\leq}(\vienv(\cl_1)(\key_1))$: 
it follows that $\mkvs'$ differs from $\mkvs$ only in the contents of the version $\mkvs'(\key_{1})$, 
which must contain a new transaction $\txid$ (i.e. not appearing in $\mkvs$) of the form $\txid_{\cl_{1}}^{\_}$ in its read-set.
Suppose that the relation $(\dashrightarrow \cup \twoheadrightarrow)$  
is acyclic in $\mkvs$. We already know that the relation $\dashrightarrow$ is acyclic in $\mkvs'$, so that 
any cycle in $(\dashrightarrow \cup \twoheadrightarrow)$ in $\mkvs'$ must contain at least a $\twoheadrightarrow$ 
edge. In fact, because $\twoheadrightarrow$ edges only connect transactions accessing different keys, such 
a cycle must contain at least two $\twoheadrightarrow$ edges. Without loss of generality, we can assume that 
this cycle has the form $\txid \dashrightarrow\rflx \txid' \twoheadrightarrow \txid'' \dashrightarrow\rflx \txid''' \twoheadrightarrow \txid$ 
for some $\txid', \txid'', \txid'''$. It follows that $\txid' = \txid = \txid^{w,1}_{i+1}$, or $\txid' \in \{\txid^{(w,1)}_{j}\} \cup \T^{(r,1)}_{j}$ 
for some $j > i$;  $\txid' \xrightarrow{\SO} \txid''$ and there exists an index $h$ such that either $\txid'' = \txid^{w,2}_{h}$, 
or $\txid'' \in \{\txid^{w,2}_{h+1}\} \cup \T^{r,2}_{h}$; 
either $\txid''' = \txid^{w,2}_{l}$, or $\txid''' \in \{\txid^{w,2}_{l+1}\} \cup \T^{r,2}_{l}$ for some $l > h$; and $\txid''' \xrightarrow{\SO} \txid$.
Without loss of generality, we assume that $\txid \in \T^{(r,1)}_{i}$, 
$\txid' \in \T^{(r,1)}_{j}$, $\txid'' \in \T^{r,2}_{h}$ and $\txid''' \in \T^{(r,2)}_{l}$: other cases are similar. 
Because $\txid''' \xrightarrow{\SO} \txid$, then at the time $\txid'''$ committed it must have been the case 
that the index $l$ was contained in the view of client $\cl_1$, and because $\ET_{\SI}$ is included in $\ET_{\MR}$, we also have 
that $l \in \vienv(\cl_{1})(\key_{2})$. Next, we have that $\T^{(r,1)}_{j} \ni \txid' \xrightarrow{\SO} \txid'' \xrightarrow{\RW} \txid^{(w,2)}_{l}$, 
and because $l \in \vienv(\cl_{1})(\key_{2})$,the constraints places on $\ET_{\CP}$, which includes $\ET_{\SI}$,  mandate that it must be the case that 
$j \in \vienv(\cl_{1})(\key_{1})$. But $j > i$, which contradicts the fact that $i = \max_{\leq}(\vienv(\cl_1)(\key_1)$.
Furthermore, one of these two edges should not 
be present in $\mkvs$, because we are assuming that the relation $(\dashrightarrow \cup \twoheadrightarrow)$ is 
acyclic in $\mkvs$. This implies that there exists an index $j = 0,\cdots, m$ such that either $\txid_{j}^{w, 2} 
\xrightarrow{\SO} \txid$, $\txid_{j+1}^{w,2} \xrightarrow{\SO} \txid$, or $\txid_{j+1}(\cl)$.

We remark that the argument that we used to prove that multiple counters are robust against $\ET_{\SI}$ make use 
of the properties of the execution tests $\ET_{\CP}$ and $\ET_{\UA}$ individually, and in fact the same proof can 
be used to prove that multiple counters are robust against the consistency model $\ET_{\WSI}$ 
introduced in \cref{sec:new_cm}. 
%We believe that the correctness of many applications under $\SI$ is preserved when 
%switching to the $\WSI$ consistency model.

%: as a result, 
%the kv-store $\hh$ is serialisable, which concludes the proof that multiple counters are robust against $\ET_{\SI}$
%Relation $\twoheadrightarrow$ tracks the session order of transactions performing operations on different keys. 
%Let $\rightarrow \defeq (\dashrightarrow \cup \twoheadrightarrow)^{+}$; 
%we then know that $\rightarrow$ embeds $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^{+}$.
%Furthermore, because $\mathsf{Counters}$ contains no operation that accesses both $\key_1$ and $\key_2$, and since $\dashrightarrow$ is acyclic, 
%any cycle in $\rightarrow$ contains at least two edges from $\twoheadrightarrow$. 
%In \cref{app:robustness} we show that the existence of such a cycle implies the 
%existence of a cycle in $\rightarrow$ of the form $\txid \dashrightarrow^{?} \txid_{a} \twoheadrightarrow 
%\txid_{b} \dashrightarrow^{?} \txid_{c} \twoheadrightarrow \txid$. 
%However, this cannot happen in $\mkvs$, as otherwise we would have a cycle in $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^{+}$ with no adjacent $\RW_{\mkvs}$-edges (a $\twoheadrightarrow$ edge represents two  $\SO_{\mkvs}$-related transactions, 
%thus contradicting \cref{thm:si_cycles}). 
%It then follows that $\rightarrow$ is irreflexive, and thus so is $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^+$.

\subsection{Verifying Database Protocols}
\label{sec:verify-impl}
Our representation of database state as kv-stores and client views closely matches the representation of database state in many implementations of 
well-known protocols~\cite{ramp,rola,cops,wren,redblue,PSI,NMSI,gdur,clocksi,distrsi}.
As such, when verifying such protocols, our state-based formalisms is better-suited than the existing graph-based formalisms of dependency graphs and abstract executions. 
In centralised databases, the state of the centralised server corresponds to a kv-store,
and the local snapshots that transactions operate on are extracted from our views.  
In distributed databases, each replica state corresponds to a view. 
Moreover, since most distributed databases are eventually consistent, 
\ie all replicas eventually agree on the database state,
replica states can be collectively encoded as a kv-store.
We verify the correctness of two database protocols:
COPS~\cite{cops} and Clock-SI~\cite{clocksi}.

%synchronisation among replicas ensures that they are in a consistent (albeit out-of-date) state.
\mypar{COPS}
COPS is a fully replicated database: each replica contains all keys.
A COPS client interacts with a single replica at a time via COPS API,
either single-write or multiple-read transactions.
Replicas \( \repl \) store all versions that has been received from clients, or other replicas via synchronisation.
Each version \( \ver \) includes a key, a value, a unique timestamp 
assigned by the replica who initially received this version from a client,
and a \emph{dependency set}, written by \( \depOf[\ver]\).
This dependency set traces the versions on which $\ver$ causally depends.
A synchronisation message with a version \( \ver \) will be received only 
when all the versions in the dependency set have been received.
This guarantees that for any version \( \ver \) in a replica \( \repl \), written by \( \ver \in \repl \),
the versions on which \( \ver \) depends also are in the replica, \( \depOf[\ver] \subseteq \repl \).
COPS assumes that all versions eventually deliver to all replicas.
Replicas themselves are assigned with unique identifiers that are totally ordered.
As such, all versions on all keys are totally ordered,
which, together with eventual delivery, guarantees eventual consistency among all replicas.
%The COPS API follows the multiple-readers-single-writer paradigm: 
%at any given time, the database can be accessed by either multiple read-only concurrent transactions, or single writing transactions. 
%Each version $\ver$ records a value and a \emph{dependency set}, written $\depOf[\ver]$,
%tracking the versions on which $\ver$ causally depends.
%This causal dependency contains previous reads and writes from the same client, and their dependencies,
%that is, 
%\( \left( \left( \SO \cup \WR \right) ^{-1}\right)^{*}(\wtOf[\ver]) \subseteq \depOf[\ver] \).

For a client to commit a single-write transaction, hence a new value \( \val \) of a key \( \key \),
it sends the new value \( \val \) and more importantly the dependency set \( D \), to a replica
in which the \( \key, \val, D \) together with a newly assigned timestamp \( \txid \), turn into a new version \( \ver \);
then the new timestamp returns to the client.
To construct the dependency set for the new version,
each client maintains a \emph{client context} that tracks the versions that have been either fetched from, or committed to any replicas. 
For a single-write transaction, the client context becomes the dependency set \( D \) of the new version \( \ver \) which ensures \( D \) contains all versions that \( \ver \) causally depends on.

A client can read some keys \( \key_1, \dots, \key_n \) in a multiple-read transaction through requesting a replica; the replica fetches the most recent version \( \ver_{\key_i} \) per key \( \key_i \) (\( 0 < i \leq n\)) one by one, between which interleaving can happen, that is, other writes and synchronisation messages might arrive.
This means that a previously read version \( \ver_{\key_j}\) on key \( \key_j \) might be too old for a later version \( \ver_{\key_m} \) on key \( \key_m\) (\(j < m\)) whose dependency set \( \depOf[\ver_{\key_m}] \) contains a newer version \( \ver'_{\key_j} \in \depOf[\ver_{\key_m}] \) on the key \( \key_j \).
To tackle the problem, after the first round of optimistic reads 
fetching versions \( \ver_{\key_1}, \dots, \ver_{\key_n} \), 
the replica computes the maximum version \( \ver'_{\key_i} \) for each key \( \key_i \) (\( 0 < i \leq n \))
among versions for the same key that are included in any dependency sets:
\( \ver'_{\key_i} = \max\bigcup_{0 < z \leq n }\Set{\ver}[\func{keyOf}[\ver] = \key_i \land \ver \in \depOf[\ver_{\key_z}]] \);
afterwards, if the \( \ver'_{\key_i} \) is newer than \( \ver_{\key_i} \) 
meaning \( \ver'_{\key_i} > \ver_{\key_i}\), 
the replica re-fetches and returns the newer version \( \ver'_{\key_i} \) to client for the key \( \key_i \),
otherwise it returns \( \ver_{\key_i} \).
Once the client receiving versions for keys \( \key_1,\dots,\key_n \) respectively, it adds those versions in its context so that any future single-write transactions will have correct dependency sets.

%The dependency set is crucial for fetching causally consistent versions.
%If a transaction reads a version \( \ver \) for key \( \key \) that 
%depends on another version \( \ver' \in \depOf[\ver]\) for key \( \key' \), 
%the transaction should at least read \( \ver' \) or any version later than \( \ver' \) for the key \( \key' \).
%A single-write transaction, meanwhile, commits the new version including the dependency set.
%When a client commits a single-write transaction,
%the dependency set of the new version \( \ver \) includes the context \( ctx \) and versions the context depends on:
%\[
    %\depOf[\ver]  = ctx \cup \bigcup_{\ver' \in ctx} \depOf[\ver']
%\]

We encode the COPS replicas as a centralised COPS kv-store by
\begin{enumerate*}
    \item collecting versions from all replicas and 
    \item ordering the versions for the same key via the total order among versions,
\end{enumerate*}
which yields a COPS kv-store \( \mkvsCOPS \) where each version records a value, a unique timestamp and a dependency set.
Upon COPS kv-store, any replica contains partial information of the COPS kv-store, 
and a client context can be encoded to a COPS client view, that is, a version is in the client context, if and only if it is in the view.
%A client view \( \vi = \func{viewOf}[\mkvsCOPS, ctx] \) contains the context \( ctx \) and versions that \( ctx \) depends on:
%\[
    %\func{viewOf}[\mkvsCOPS, ctx] \defeq \lambda \key \ldotp \Set{i}[\mkvsCOPS(\key,i) \in ctx] 
                            %\cup \Set{i}[\exsts{\ver} \mkvsCOPS(\key,i) \in \depOf[\ver] \land \ver \in ctx]  
%\]
%By construction, this view is closed under \( \SO \cup \WR_{\mkvsCOPS} \):
%for any \( \key, i, \txid\) such that \( i \in \vi(\key) \) and \( \txid = \wtOf[\mkvsCOPS(\key,i)]\),
%\begin{itemize}
    %\item if \( \mkvsCOPS(\key,i) \in ctx \) and \( \wtOf[\mkvsCOPS(\key',j)] \toEDGE{(\SO \cup \WR_{\mkvsCOPS})^*} \txid \) for some \( \key',j \),
        %then \( \wtOf[\mkvsCOPS(\key',j)] \in \depOf[\mkvsCOPS(\key,i)] \) so \( j \in \vi(\key') \); and
    %\item if \( \mkvsCOPS(\key,i) \in \depOf[\ver] \land \ver \in ctx \) and 
        %\( \wtOf[\mkvsCOPS(\key',j)] \toEDGE{(\SO \cup \WR_{\mkvsCOPS})^*} \txid \) for some \( \ver,\key',j \),
        %then it must be the case \( \wtOf[\mkvsCOPS(\key',j)]  \in \depOf[\ver] \) so \( j \in \vi(\key') \).
%\end{itemize}
%Therefore for any client context \( ctx \),
%the predicate \( \closed[\mkvsCOPS,\func{viewOf}[\mkvsCOPS, ctx], \left( \SO \cup \WR_{\mkvsCOPS} \right)] \) holds.

Given the encode of COPS kv-store \( \mkvsCOPS \) and view \( \vi \), we show that every COPS step 
of either multiple-read or single-write transaction satisfies $\ET_\CC$,
which is defined by 
\( \ET_\MR \cap \ET_\RYW \cap \closed[\mkvsCOPS, \vi, \left( \SO \cup \WR_{\mkvsCOPS} \right)] \) 
in \cref{fig:execution_tests}.
First, client contexts monotonically increase which implies \(\ET_\MR\); and 
second, versions committed by the client will be contained in the context, 
which implies \(\ET_\RYW \) given the fact of \(\ET_\MR\).
Now let consider the backwards closure of \( \SO \cup \WR \), 
especially for multiple-read transactions (because single-write transactions do not fetch any new version from a replica).
When a client requests versions for \( \key_1, \dots, \key_n \),
it will get versions \( \ver_{\key_1}, \dots, \ver_{\key_n}\) from a replica such that:
\begin{centermultline}[eq:dep-set-property]
    \fora{i, \ver} 0 < i \leq n \land \ver \in \depOf[\ver_{\key_i}]
    \land 
    \exsts{\key} \key = \func{keyOf}[\ver] \land \key \in \Set{\key_1, \dots, \key_n } \implies \ver < \ver_\key
\end{centermultline}
and those versions, which will be included in the client context and then read by the client,
can be encoded to a view that is backwards closed with respect to \( \SO \cup \WR \) relation
provided that \cref{eq:dep-set-property}.
%When a client commit a new version, meanwhile, 
%When a client commits a new transaction under a context \( ctx \), 
%the versions that have been either fetched from, or committed to, will be included in the context afterwards \( ctx' \).
%This means, given the kv-stores before and after committing, \( \mkvsCOPS \) and \( \mkvsCOPS' \) respectively,
%Last, any view that is constructed from a context is closed under \( \SO \cup \WR \) which implies \( \closed[\mkvsCOPS,\func{viewOf}[\mkvsCOPS, ctx], \left( \SO \cup \WR_{\mkvsCOPS} \right)] \).
More details about COPS protocol and our soundness proof are given in \cref{sec:cops}.

\mypar{Clock-SI}
Clock-SI is a \emph{partitioned} database protocol for snapshot isolation (SI),
where different partition host disjoint fragments of keys.
As with the original definition of SI, Clock-SI uses timestamps to maintain different versions. 
The clocks on different partitions may not agree; however, the difference is assumed to be bounded.
Each key keeps a history of versions, where each version comprises a value and the commit timestamp.
Each transaction $\txid$ is assigned to a designated partition, known as the $\txid$ \emph{coordinator}. 
When $\txid$ starts, it records the snapshot timestamp as the time of the coordinator.
Transaction $\txid$ may then read from partitions other than its coordinator,
so long as the current timestamp at those partitions are greater than the recorded snapshot time. 
Within a transaction \( \txid\), 
the first read before any write for a key, fetches the version with the maximum timestamp before the snapshot time,
afterwards any repeat reads are local to the transaction.
Once $\txid$ completes, it may commit if no transaction with a conflicting write has committed since the snapshot time.
This means there is no preceding version in the partition.
We encode the partitions collectively as a kv-store, by collecting keys from different partitions 
and ordering the versions for each key by the timestamps.
Each snapshot timestamp is encoded as a view, contains all versions committed before that timestamp.
We show that Clock-SI is sound with respect to the $\ET_\SI$, 
where $\ET_\SI = \closed(\mkvs,\vi, \rel_{\SI}(\fp)) \cap \ET_\MR \cap \ET_\RYW $ is the snapshot isolation execution test in \cref{fig:execution_tests}.
It means given the encoded kv-store \( \mkvs \) and view \( \vi \), 
the transaction with fingerprint \( \fp \) is allowed to commit: \( \closed[\mkvs,\vi,\rel_{\SI}(\fp)]\); and
the new view \( \vi' \) over the new kv-store \( \mkvs' \) satisfies \( \MR \) and \( \RYW \).
More details and our soundness proof are given in \cref{sec:clock-si}. 
