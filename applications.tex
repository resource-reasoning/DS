\section{Applications}
\label{sec:applications}

We showcase the applications of our formalism by showing how we can prove the robustness of transactional libraries (\cref{sec:program-analysis}), and verifying database protocols
 (\cref{sec:verify-impl}).

\subsection{Program Analysis}
\label{sec:program-analysis}
A transactional library, $L = \Set{\ptrans{\trans}_{i}}_{i \in I}$, 
provides a set of operations through which the library clients can access the kv-store. 
For instance, the set of operations of the counter library on key $\key$ in \cref{sec:overview} is $\Counter(\key) = \Set{\ctrinc(\key), \ctrread(\key)}$.
A program $\prog$ is a \emph{client} of library $L$ if the only transactional calls in $\prog$ are those to library $L$ operations.  
A transactional library $L$ is \emph{robust} against an execution test $\ET$ if: 
for all client programs $\prog$ of library $L$, the set of kv-stores by running $\prog$ are included in the set of kv-stores obtained by running $\prog$ under $\ET_{\SER}$.
As an application of our theory, we show how we can prove the robustness of simple transactional libraries. 
In the following, we write $\CMs(\ET, L)$ for the set of kv-stores obtained from running a client program $\prog$ of $L$. 

We prove the robustness of single and multiple counters (\cref{sec:overview}) against $\ET_{\PSI}$ and $\ET_{\SI}$, respectively.
Previous techniques for checking robustness~\cite{giovanni_concur16,SIanalysis,laws,sureshConcur} 
are based on static analysis: since the session order of clients cannot be determined at compile 
time, these techniques abstract from sessions. 
To our knowledge, we give the first robustness proofs that take sessions into account.

Our proof technique for robustness uses the following result, which is the kv-store counterpart of another well-known result on dependency graphs~\cite{adya}:
\begin{theorem}
\label{thm:serialisable_nocycle}
For all kv-stores $\mkvs$: $\mkvs \in \CMs(\ET_{\SER})$ iff $(\SO \cup \WR_{\mkvs} 
\cup \WW_{\mkvs} \cup \RW_{\mkvs})^{+}$ is irreflexive.
\end{theorem}
Given this theorem, to prove the robustness of $L$ against $\ET$, 
for an arbitrary a kv-store $\mkvs$, we 
\begin{enumerate*}
	\item identify a property of $\mkvs$ that remains \emph{invariant} when running any client program of $L$ on $\mkvs$; and 
	\item show that the invariant implies the irreflexivity of $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^{+}$.
\end{enumerate*}

\mypar{Robustness of a Single Counter against $\ET_{\PSI}$}
Pick an arbitrary key $\key$ and $\mkvs \in \CMs(\ET_{\PSI}, \mathsf{Counter}(\key))$, 
with $\Counter(\key) {=} \Set{\ctrinc(\key), \ctrread(\key)}$. 
Note that clients can only write to $\key$ by calling $\ctrinc(\key)$.
As such, since $\ET_{\PSI}$ enforces write conflict freedom, we have: 
% in all $\mkvs \in \CMs(\ET_{\PSI}, \mathsf{Counter})$, we have:
$\fora{\txid, i > 0} \txid {=} \wtOf(\mkvs(\key, i)) \implies \txid \in \rsOf(\mkvs(\key, i{-}1))$. 
Furthermore, because $\ET_{\PSI}$ satisfies monotonic reads ($\ET_{\PSI} \subseteq \ET_{\MR}$),
the order in which clients observe the versions of $\key$ (by calling $\ctrread(\key)$), 
is consistent with the order of the index of such versions in $\mkvs(\key)$:
%
%
{%
\begin{align*}
	\mkvs(\key) & = (0, \txid_{0}, \txidset^{\mathsf{r}}_{0} \cup \Set{\txid^{\mathsf{w}}_1}) 
	\lcat (1, \txid^{\mathsf{w}}_{1}, \txidset^{\mathsf{r}}_{1} \cup \Set{\txid^{\mathsf{w}}_2}) 
	\lcat \cdots \lcat (n-1, \txid^{\mathsf{w}}_{n-1}, \txidset^{\mathsf{r}}_{n-1} \cup \Set{\txid^{\mathsf{w}}_n})
	\lcat (n, \txid^{\mathsf{w}}_n, \txidset^{\mathsf{r}}_{n})
\end{align*}%
}%
%
\noindent where $\Set{\txid^{\mathsf{w}}_{i}}_{i=1}^{n}$ is the set of transactions calling $\ctrinc(\key)$, 
and $\bigcup_{i=0}^{n} \txidset^{\mathsf{r}}_{i}$ is the set of transactions calling $\ctrread(\key)$. 

Next, we define a relation $\dashrightarrow$ between
the transactions in $\mkvs$ as the smallest transitive relation that 
satisfies the following: 
\begin{enumerate*}
	\item $\txid^{\mathsf{w}}_{i} 
	\dashrightarrow \txid$ if $\txid \in \txidset^{\mathsf{r}}_{i}$ 
	or $\txid {=} \txid^{\mathsf{w}}_{i+1}$; 
	\item $\txid \dashrightarrow \txid'$ 
	for some $\txid \in \txidset^{\mathsf{r}}_{i}$,
	if $\txid' {=} \txid^{\mathsf{w}}_{i+1}$
	or $\txid' \in \txidset^{\mathsf{r}}_{i} \land \txid \toEDGE{\SO} \txid'$. 
\end{enumerate*}
%
Note that $\dashrightarrow$ yields a total order over the transactions in $\mkvs$, 
and includes $\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs}$. 
As such, $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^+$ is irreflexive, 
ensuring the robustness of $\Counter(\key)$ against $\ET_{\PSI}$.


\mypar{Robustness of Multiple Counters against $\ET_{\SI}$}. 
Recall from \cref{sec:overview} that for the library comprising two or more counters we can 
observe the long fork anomaly disallowed under serialisability ($\ET_{\SER}$). 
As such, multiple counters are not robust against $\ET_{\PSI}$. 
The long fork anomaly arises because different clients can observe increments 
over two different counters in a different order.
This anomaly does not arise under $\SI$: 
in fact, multiple counters are robust against $\ET_{\SI}$. 
%$\ET_{\PSI}$ to $\ET_{\SI}$, 
%we can analogously recover the robustness of multiple counters.
For simplicity, here we assume that the library comprises only two counters: 
$\mathsf{Counters} {=} \Counter(\key_1) \cup \Counter(\key_2)$.
%We use the following result, which is the kv-store counterpart of a well-known result for SI~\cite{fekete-tods,SIanalysis}: 
%\begin{theorem}
%\label{thm:si_cycles}
%For all $\mkvs \in \CMs(\ET_{\SI})$, any cycle in $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^+$ has two adjacent $\RW_{\mkvs}$-edges.
%\end{theorem}

Consider a kv-store $\mkvs \in \CMs(\ET_{\SI}, \mathsf{Counters})$. 
As $\ET_{\SI} \subseteq \ET_{\PSI}$, the list of versions of $\mkvs(\key_1)$ and $\mkvs(\key_2)$ 
must both follow the same structure as that described for a single counter under $\ET_{\PSI}$. 
Recall that this structure embeds a total order $\dashrightarrow$ over transactions in $\mkvs(\key_1)$ and $\mkvs(\key_2)$, 
which embeds an acyclic relation $\WR_{\mkvs} \cup \WW_{\mkvs} \cup \RF_{\mkvs}$. 
However, since a client can perform operations over two different counters, the $\dashrightarrow$ no longer comprises $\SO_{\mkvs}$. 

We define a second relation $\twoheadrightarrow$ that tracks the session order of transactions accessing different keys: 
$\txid \twoheadrightarrow \txid'$ if $\txid \in \Set{\wtOf(\mkvs(\key_{i}, \stub)} \cup \rsOf(\mkvs(\key_{i}, \stub))$ 
and $\txid' \in \Set{\wtOf(\mkvs(\key_{j}, \stub))} \cup \rsOf(\mkvs(\key_{j}, \stub))$ with $i,j \in \Set{1,2} \land j \neq i$,  
and $\txid \toEDGE{\SO} \txid'$. The combined relation $(\dashrightarrow \cup \twoheadrightarrow)$ embeds 
$(\SO_{\hh} \cup \WR_{\hh} \cup \WW_{\hh} \cup \RW_{\hh})$; next, we prove that the acyclicity of the relation $(\dashrightarrow \cup \twoheadrightarrow)$ 
is acyclic, from which it follows that the kv-store $\hh$ is serialisable. More specifically, we prove that any $\ET_{\SI}$-trace
%by induction on the length of a $\ET_{\SI}$-trace 
in $\CMs(\ET_{\SI}, \mathsf{Counter}(\key_1) \cup \mathsf{Counter}(\key_2))$ terminates in a configuration of the form $(\mkvs, \_)$ 
such that the relation $(\dashrightarrow \cup \twoheadrightarrow)$ over $\mkvs$ is irreflexive; the proof is by induction on the 
length of the $\ET_{\SI}$-trace. Here we only show the details of the inductive step of the proof in the most interesting case, 
that is one where a cycle in the relation $(\dashrightarrow \cup \twoheadrightarrow)$ is created because 
client $\cl_{1}$ reads a version of some key, e.g. $\key_{1}$, after accessing the other, e.g. $\key_{2}$, and the order 
of such operations seemingly contradicts the order of the versions of $\key_{1}, \key_{2}$ observed by another client 
$\cl_{2}$: as we will see shortly, this case leads to a contradiction. 
Let $\mkvs_{\mathsf{pre}}$ be a kv-store such that 
\[
\begin{array}{lr}
\mkvs(\key_{1}) & = (0, \txid_{0}, \txidset^{\mathsf{r},1}_{0} \cup \Set{\txid^{\mathsf{w},1}_1}) 
	%\lcat (1, \txid^{\mathsf{w},1}_{1}, \txidset^{\mathsf{r},1}_{1} \cup \Set{\txid^{\mathsf{w},1}_2}) 
	\lcat \cdots \lcat (n-1, \txid^{\mathsf{w},1}_{n-1}, \txidset^{\mathsf{r},1}_{n-1} \cup \Set{\txid^{\mathsf{w},1}_n})
	\lcat (n, \txid^{\mathsf{w},1}_n, \txidset^{\mathsf{r},1}_{n})\\
\mkvs(\key_{2}) & = (0, \txid_{0}, \txidset^{\mathsf{r},2}_{0} \cup \Set{\txid^{\mathsf{w},2}_1}) 
	%\lcat (1, \txid^{\mathsf{w},2}_{1}, \txidset^{\mathsf{r},2}_{1} \cup \Set{\txid^{\mathsf{w},2}_2}) 
	\lcat \cdots \lcat (m-1, \txid^{\mathsf{w},2}_{m-1}, \txidset^{\mathsf{r},1}_{m-1} \cup \Set{\txid^{\mathsf{w},2}_m})
	\lcat (m, \txid^{\mathsf{w},2}_m, \txidset^{\mathsf{r},2}_{m})
\end{array}
\]
and suppose that $(\mkvs, \vienv) \toET[\SI]{(\cl_{1}, (\otR, \key_{1}, \_)} (\mkvs', \vienv')$, causing the relation 
$(\dashrightarrow \cup \twoheadrightarrow)$ to contain a cycle in $\mkvs'$. Let $i = \max_{\leq}(\vienv(\cl_1)(\key_1))$: 
it follows that $\mkvs'$ differs from $\mkvs$ only in the contents of the version $\mkvs'(\key_{1})$, 
which must contain a new transaction $\txid$ (i.e. not appearing in $\mkvs$) of the form $\txid_{\cl_{1}}^{\_}$ in its read-set.
Suppose that the relation $(\dashrightarrow \cup \twoheadrightarrow)$  
is acyclic in $\mkvs$. We already know that the relation $\dashrightarrow$ is acyclic in $\mkvs'$, so that 
any cycle in $(\dashrightarrow \cup \twoheadrightarrow)$ in $\mkvs'$ must contain at least a $\twoheadrightarrow$ 
edge. In fact, because $\twoheadrightarrow$ edges only connect transactions accessing different keys, such 
a cycle must contain at least two $\twoheadrightarrow$ edges. Without loss of generality, we can assume that 
this cycle has the form $\txid \dashrightarrow\rflx \txid' \twoheadrightarrow \txid'' \dashrightarrow\rflx txid''' \twoheadrightarrow \txid$ 
for some $\txid', \txid'' \txid'''$. It follows that $\txid' = \txid = \txid^{w,1}_{i+1}$, or $\txid' \in \{\txid^{(w,1)}_{j}\} \cup \T^{(r,1)}_{j}$ 
for some $j > i$;  $\txid' \xrightarrow{\SO} \txid''$ and there exists an index $h$ such that either $\txid'' = \txid^{w,2}_{h}$, 
or $\txid'' \in \{\txid^{w,2}_{h+1}\} \cup \T^{r,2}_{h}$; 
either $\txid''' = \txid^{w,2}_{l}$, or $\txid''' \in \{\txid^{w,2}_{l+1}\} \cup \T^{r,2}_{l}$ for some $l > h$; and $\txid''' \xrightarrow{\SO} \txid$.
Without loss of generality, we assume that $\txid \in \T^{(r,1)}_{i}$, 
$\txid' \in \T^{(r,1)}_{j}$, $\txid'' \in \T^{r,2}_{h}$ and $\txid''' \in \T^{(r,2)}_{l}$: other cases are similar. 
Because $\txid''' \xrightarrow{\SO} \txid$, then at the time $\txid'''$ committed it must have been the case 
that the index $l$ was contained in the view of client $\cl_1$, and because $\ET_{\SI}$ is included in $\ET_{\MR}$, we also have 
that $l \in \vienv(\cl_{1})(\key_{2})$. Next, we have that $\T^{(r,1)}_{j} \ni \txid' \xrightarrow{\SO} \txid'' \xrightarrow{\RW} \txid^{(w,2)}_{l}$, 
and because $l \in \vienv(\cl_{1})(\key_{2})$,the constraints places on $\ET_{\CP}$, which includes $\ET_{\SI}$,  mandate that it must be the case that 
$j \in \vienv(\cl_{1})(\key_{1})$. But $j > i$, which contradicts the fact that $i = \max_{\leq}(\vienv(\cl_1)(\key_1)$.
Furthermore, one of these two edges should not 
be present in $\mkvs$, because we are assuming that the relation $(\dashrightarrow \cup \twoheadrightarrow)$ is 
acyclic in $\mkvs$. This implies that there exists an index $j = 0,\cdots, m$ such that either $\txid_{j}^{w, 2} 
\xrightarrow{\SO} \txid$, $\txid_{j+1}^{w,2} \xrightarrow{\SO} \txid$, or $\txid_{j+1}(\cl)$.

We remark that the argument that we used to prove that multiple counters are robust against $\ET_{\SI}$ make use 
of the properties of the execution tests $\ET_{\CP}$ and $\ET_{\UA}$ individually, and in fact the same proof can 
be used to prove that multiple counters are robust against the consistency model $\ET_{\WSI}$ 
introduced in \cref{sec:new_cm}. 
%We believe that the correctness of many applications under $\SI$ is preserved when 
%switching to the $\WSI$ consistency model.

%: as a result, 
%the kv-store $\hh$ is serialisable, which concludes the proof that multiple counters are robust against $\ET_{\SI}$
%Relation $\twoheadrightarrow$ tracks the session order of transactions performing operations on different keys. 
%Let $\rightarrow \defeq (\dashrightarrow \cup \twoheadrightarrow)^{+}$; 
%we then know that $\rightarrow$ embeds $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^{+}$.
%Furthermore, because $\mathsf{Counters}$ contains no operation that accesses both $\key_1$ and $\key_2$, and since $\dashrightarrow$ is acyclic, 
%any cycle in $\rightarrow$ contains at least two edges from $\twoheadrightarrow$. 
%In \cref{app:robustness} we show that the existence of such a cycle implies the 
%existence of a cycle in $\rightarrow$ of the form $\txid \dashrightarrow^{?} \txid_{a} \twoheadrightarrow 
%\txid_{b} \dashrightarrow^{?} \txid_{c} \twoheadrightarrow \txid$. 
%However, this cannot happen in $\mkvs$, as otherwise we would have a cycle in $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^{+}$ with no adjacent $\RW_{\mkvs}$-edges (a $\twoheadrightarrow$ edge represents two  $\SO_{\mkvs}$-related transactions, 
%thus contradicting \cref{thm:si_cycles}). 
%It then follows that $\rightarrow$ is irreflexive, and thus so is $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^+$.

\subsection{Verifying Database Protocols}
\label{sec:verify-impl}
Our representation of database state as kv-stores and client views closely matches the representation of database state in many implementations of 
well-known protocols~\cite{ramp,rola,cops,wren,redblue,PSI,NMSI,gdur,clocksi,distrsi}.
As such, when verifying such protocols, our state-based formalisms is better-suited than the existing graph-based formalisms of dependency graphs and abstract executions. 
In centralised databases, the state of the centralised server corresponds to a kv-store,
and the local snapshots that transactions operate on are extracted from our views.  
In distributed databases, each replica state corresponds to a view. 
Moreover, since most distributed databases are eventually consistent, 
\ie all replicas eventually agree on the database state,
replica states can be collectively encoded as a kv-store.
We verify the correctness of two database protocols:
COPS~\cite{cops} and Clock-SI~\cite{clocksi}.

\mypar{COPS}
COPS is a fully replicated database: each replica contains all keys, but their associated values may be out of date.
Database clients operate on a single replica; 
synchronisation among replicas ensures that they are in a consistent (albeit out-of-date) state.
The COPS API follows the multiple-readers-single-writer paradigm: 
at any given time, the database can be accessed by either multiple read-only concurrent transactions, or single writing transactions. 
Replicas are assigned unique identifiers, that are totally ordered.
As such, all versions (on all keys) are totally ordered,
which guarantees eventual consistency among all replicas.
Each version $\ver$ records a value and a \emph{dependency set}, written $\depOf[\ver]$,
tracking the versions on which $\ver$ causally depends.
This causal dependency contains previous reads and writes from the same client, and their dependencies,
that is, 
\( \left( \left( \SO \cup \WR \right) ^{-1}\right)^{*}(\wtOf[\ver]) \subseteq \depOf[\ver] \).
The dependency set is crucial for fetching causally consistent versions.
If a transaction reads a version \( \ver \) for key \( \key \) that 
depends on another version \( \ver' \in \depOf[\ver]\) for key \( \key' \), 
the transaction should at least read \( \ver' \) or any version later than \( \ver' \) for the key \( \key' \).
A single-write transaction, meanwhile, commits the new version including the dependency set.
To construct the dependency set for the new version,
each client maintains a context tracking the versions that have been either fetched from, or committed to, any replicas.
When a client commits a single-write transaction,
the dependency set of the new version \( \ver \) includes the context \( ctx \) and versions the context depends on:
\[
    \depOf[\ver]  = ctx \cup \bigcup_{\ver' \in ctx} \depOf[\ver']
\]

We encode the COPS replicas as a kv-store, and client contexts as views.  
We collect versions from all replicas and organise the versions for the same key to a list,
which yields a kv-store \( \mkvsCOPS \) where each version records an explicit dependency set.
A client view \( \vi = \func{viewOf}[\mkvsCOPS, ctx] \) contains the context \( ctx \) and versions that \( ctx \) depends on:
\[
    \func{viewOf}[\mkvsCOPS, ctx] \defeq \lambda \key \ldotp \Set{i}[\mkvsCOPS(\key,i) \in ctx] 
                            \cup \Set{i}[\exsts{\ver} \mkvsCOPS(\key,i) \in \depOf[\ver] \land \ver \in ctx]  
\]
By construction, this view is closed under \( \SO \cup \WR_{\mkvsCOPS} \):
for any \( \key, i, \txid\) such that \( i \in \vi(\key) \) and \( \txid = \wtOf[\mkvsCOPS(\key,i)]\),
\begin{itemize}
    \item if \( \mkvsCOPS(\key,i) \in ctx \) and \( \wtOf[\mkvsCOPS(\key',j)] \toEDGE{(\SO \cup \WR_{\mkvsCOPS})^*} \txid \) for some \( \key',j \),
        then \( \wtOf[\mkvsCOPS(\key',j)] \in \depOf[\mkvsCOPS(\key,i)] \) so \( j \in \vi(\key') \); and
    \item if \( \mkvsCOPS(\key,i) \in \depOf[\ver] \land \ver \in ctx \) and 
        \( \wtOf[\mkvsCOPS(\key',j)] \toEDGE{(\SO \cup \WR_{\mkvsCOPS})^*} \txid \) for some \( \ver,\key',j \),
        then it must be the case \( \wtOf[\mkvsCOPS(\key',j)]  \in \depOf[\ver] \) so \( j \in \vi(\key') \).
\end{itemize}
Therefore for any client context \( ctx \),
the predicate \( \closed[\mkvsCOPS,\func{viewOf}[\mkvsCOPS, ctx], \left( \SO \cup \WR_{\mkvsCOPS} \right)] \) holds.

Given the encode of kv-store and view, we show that every COPS step 
of either single-write or multiple-read transaction satisfies $\ET_\CC$,
where \(\ET_\CC = \closed[\mkvsCOPS, \vi, \left( \SO \cup \WR_{\mkvsCOPS} \right)] \cap \ET_\MR \cap \ET_\RYW \) 
in \cref{fig:execution_tests}.
When a client commits a new transaction under a context \( ctx \), 
the versions that have been either fetched from, or committed to, will be included in the context afterwards \( ctx' \).
This means, given the kv-stores before and after committing, \( \mkvsCOPS \) and \( \mkvsCOPS' \) respectively,
\begin{enumerate*} 
    \item context monotonically increases, that is, 
    \( ctx \subseteq ctx' \) and \( \func{viewOf}[\mkvsCOPS, ctx] \viewleq \func{viewOf}[\mkvsCOPS', ctx']\) which implies \(\ET_\MR\);
    and 
    \item any newly committed version, says \(j\)-\emph{th} version of a key \(\key\), will be contained in \( ctx' \),
    thus \( j \in \func{viewOf}[\mkvsCOPS', ctx'](\key') \) which implies \(\ET_\RYW \) under the fact of \(\ET_\MR\).
\end{enumerate*}
Last, any view that is constructed from a context is closed under \( \SO \cup \WR \) which implies \( \closed[\mkvsCOPS,\func{viewOf}[\mkvsCOPS, ctx], \left( \SO \cup \WR_{\mkvsCOPS} \right)] \).
More details about COPS protocol and our soundness proof are given in \cref{sec:cops}.

\mypar{Clock-SI}
Clock-SI is a \emph{partitioned} database protocol for snapshot isolation (SI),
where different partition host disjoint fragments of keys.
As with the original definition of SI, Clock-SI uses timestamps to maintain different versions. 
The clocks on different partitions may not agree; however, the difference is assumed to be bounded.
Each key keeps a history of versions, where each version comprises a value and the commit timestamp.
Each transaction $\txid$ is assigned to a designated partition, known as the $\txid$ \emph{coordinator}. 
When $\txid$ starts, it records the snapshot timestamp as the time of the coordinator.
Transaction $\txid$ may then read from partitions other than its coordinator,
so long as the current timestamp at those partitions are greater than the recorded snapshot time. 
Within a transaction \( \txid\), 
the first read before any write for a key, fetches the version with the maximum timestamp before the snapshot time,
afterwards any repeat reads are local to the transaction.
Once $\txid$ completes, it may commit if no transaction with a conflicting write has committed since the snapshot time.
This means there is no preceding version in the partition.
We encode the partitions collectively as a kv-store, by collecting keys from different partitions 
and ordering the versions for each key by the timestamps.
Each snapshot timestamp is encoded as a view, contains all versions committed before that timestamp.
We show that Clock-SI is sound with respect to the $\ET_\SI$, 
where $\ET_\SI = \closed(\mkvs,\vi, \rel_{\SI}(\fp)) \cap \ET_\MR \cap \ET_\RYW $ is the snapshot isolation execution test in \cref{fig:execution_tests}.
It means given the encoded kv-store \( \mkvs \) and view \( \vi \), 
the transaction with fingerprint \( \fp \) is allowed to commit: \( \closed[\mkvs,\vi,\rel_{\SI}(\fp)]\); and
the new view \( \vi' \) over the new kv-store \( \mkvs' \) satisfies \( \MR \) and \( \RYW \).
More details and our soundness proof are given in \cref{sec:clock-si}. 
