\section{Applications}
\label{sec:applications}

\subsection{Program Analysis}
\label{sec:program-analysis}
A transactional library is a set of operations 
$L = \{\ptrans{\trans}_{i}\}_{i \in I}$ that can be invoked 
by clients of a kv-store. A transactional library is said to be 
\emph{robust} against an execution test of $\ET$ if the set of kv-stores 
obtainable by letting clients interact with the kv-store using 
operations from $L$ can also be obtained by if the same 
set of operations were performed under $\ET_{\SER}$.
As an application of our theory, we show how we 
can prove the robustness of some simple applications. 

Elaborating on the examples from \cref{sec:overview}, in this Section 
we prove the robustness of a single counter against $\ET_{\PSI}$, 
and multiple counters against $\ET_{\SI}$. Previous techniques for 
checking the robustness of a transactional library \cite{giovanni_concur16,SIanalysis,laws,sureshConcur} 
are based on static analysis: because the session order of clients cannot be determined at compile 
time, these techniques abstract from sessions. To the best of our knowledge, 
we give the first proofs of robustness of transactional libraries that involve sessions.

Our proof technique for robustness uses the following result, which can be though 
as the kv-store counterpart of another well known result for dependency graphs \cite{adya}:
\begin{theorem}
Let $\hh$ be a kv-store. Then $\hh \in \CMs(\ET_{\SER})$ if and only if $(\PO_{\hh} \cup \RF_{\hh} 
\cup \VO_{\hh} \cup \AD_{\hh})^{+}$ is irreflexive.
\end{theorem}
To prove the robustness of a transactional library $L$ against an execution test 
$\ET$, we identify an invariant of kv-stores $\hh$ obtainable by letting clients 
invoke only operations contained in $L$, and we prove that such an invariant 
implies the irreflexivity of the relation $(\PO_{\hh} \cup \RF_{\hh} \cup \VO_{\hh} \cup 
\AD_{\hh})^{+}$.

\paragraph{Robustness of a single counter against $\ET_{\PSI}$}

\paragraph{Robustness of multiple counters against $\ET_{\SI}$}

\subsection{Verifying Implementations}
\label{sec:verify-impl}
\sx{
    Short intro why it is good to use our models

    What are cops and then clock-si.
    how we verify
}
Compared with graph-based models including dependency graphs and abstract executions,
our state-based model is useful for verifying implementations,
because many implementations embed notions of global kv-stores and local views.
For centralise databases, the state of the centralised server corresponds the kv-store,
and the views reflect the initial local states that transactions work on.
For distributed databases, since most distributed databases satisfy eventual consistency, 
\ie servers among the system eventually agree on states,
these states collectively can be encoded to a kv-store.
Views reflect the local states of servers.
We verify two implementations in the literature, 
COPS~\cite{Lloyd:2011:DSE:2043556.2043593} and Clock-SI~\cite{Du:2013:CSI:2553409.2553434}.

\paragraph{\bf COPS}
COPS is a fully replicated database, that is, 
each server also known as replica contains all keys yet the associated values may be out of date.
Synchronisation between replicas guarantees that each replica is in a valid yet maybe out-of-date state.
Therefore, clients only read or write to a replica.
A replica stores all versions that are aware of,
Versions among all keys are totally ordered given that
COPS restraints the API that only allows single-write or multiple reads transactions.
Each version has a \emph{dependency} that are other versions it depends on.
COPS uses the dependencies to ensure any reads satisfy causal consistency.
A client maintains a context which are versions 
that have been fetched from some replicas or committed to ones.

To read multiple keys in a transaction, the replica returns a list of versions \( \vilist = \ver^{i_1}_{\ke_1}, \dots \ver^{i_n}_{\ke_n} \) 
that are either equal or greater than any versions in the dependencies,
\ie \( \fora{\ke, \ver, \ver^{i}_{\ke}, \ver^{j}_{\ke}} \ver \in \vilist \land \ver^{i}_{\ke} \in \vilist \land \ver^{j}_{\ke} \in \func{dep}{\ver} \implies i \geq j \).
To commit a new version, the client also provides the context as the dependency.
A version is accepted by a replica
only until all versions from the dependency have been aware to the same replica,
otherwise it is put in the pending list.

We encode kv-store that includes all versions from all replicas, at any given time.
A client context then converts to a view on the kv-store, 
\ie if a version in the context then it is in the view.
We show that the views before and after any COPS transaction,
satisfy the execution tests for causal consistency in \cref{fig:execution.tests}.
The full detail is in \cref{sec:cops}.

\paragraph{\bf Clock-SI}
Clock-SI is a sharded database implementation for snapshot isolation.
A server also called a shard hosts a disjointed fragment of keys.
To implements snapshot isolation, Clock-SI uses physical times.
Obviously, times on shards will not always match, but it is assumed that the difference is bounded.
Each key keeps the history of versions consisting of the values and the commit times.
When a transaction starts, it gets a snapshot time by a shard 
and from now on this shard is the coordinator for the transaction.
Such transaction can read other shard, delegated by the coordinator, only if the local time is greater than the snapshot time.
At the end, a transaction can commit if there is no transaction with conflict writes since the snapshot time.

We encode kv-store as the union of all shard.
Over the kv-store, 
A time corresponds to a unique view,
which contains all versions committed before.
To verify the Clock-SI, 
we show the views constructed from the snapshot time and commit time,
if a transaction successfully commits, 
satisfy the execution tests for snapshot isolation in \cref{fig:execution.tests}.
The full detail is in \cref{sec:clock-si}.
