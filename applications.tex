\section{Applications}
\label{sec:applications}
\label{sec:program-analysis}

To demonstrate the applications of our operational semantics, 
in \cref{sec:robustness} we use our formalism to prove the robustness of several transactional libraries.
In contrast to static methods, we prove the robustness of a program $\prog$ against a weak consistency model \( \ET \)  by checking kv-store invariants when executing $\prog$ under \( \ET \).
In \cref{sec:verify-impl} we then use our formalism to verify several distributed protocols.

%In \cref{sec:verify-impl}, 
%we show that distributed sites, replicas or partitions, can be projected to our centralised kv-store,
%and different implementation mechanisms corresponds to constructing views. 
%Consider a simple 
\subsection{Application: Robustness of Transactional Libraries}
\label{sec:robustness}
A transactional library, $L {=} \Set{\ptrans{\trans}_{i}}_{i \in I}$
%, which 
provides a set of transactional operations used by library clients to access the underlying
kv-store\footnote{For simplicity, we model each operation as a single transaction; it is straightforward to extend this to multiple transactions.}. 
For instance, the set of operations of the counter library on key $\key$ in \cref{sec:overview} is $\Counter(\key) {=} \Set{\ctrinc(\key), \ctrread(\key)}$.
A program $\prog$ is a \emph{client program} of $L$ if the only transactional calls in $\prog$ are to operations of $L$.  
A transactional library $L$ is \emph{robust} against an execution test
$\ET$ if for all clients $\prog$ of $L$, the kv-stores obtained under $\ET$ can also be obtained under $\SER$; 
\ie $\CMs(\ET, L) \subseteq \CMs(\ET_{\SER})$. 

%Checking the robustness of an application against an execution test $\ET$ amounts to proving the serialisability of all the kv-stores that the 
%application can produce under $\ET$: this property is equivalent to check that the dependency graphs associated with such kv-stores 
%are acyclic~\cite{adya}:
\begin{theorem}
\label{thm:serialisable_nocycle}
For all kv-stores $\mkvs$, $\mkvs \in \CMs(\ET_{\SER})$ iff $(\SO \cup \WR_{\mkvs} 
\cup \WW_{\mkvs} \cup \RW_{\mkvs})^{+}$ is irreflexive.
\end{theorem}
This theorem is an adaptation of a well-known result on
dependency graphs~\cite{adya} stating that $\mkvs \in \CMs(\ET_{\SER})$ if and
only if its associated dependency graph is acyclic. 
\pg{I don't think we need this......
Our robustness proofs
%aim to \emph{prove} that kv-stores in $\CMs(\ET, L)$ have an acyclic dependency graph, but 
make no assumption on the structure of kv-stores in $\CMs(\ET, L)$; rather, we use the definition of $\ET$ to reason 
about the structure of kv-stores in $\CMs(\ET, L)$, and in particular to prove the acyclicity of the underlying 
dependency graphs. }
%Note that the acyclicity of dependency graphs in $\CMs(\ET,L)$ is a property that we \emph{prove}, using the 
%definition of the execution test $\ET$ as a hypothesis. We make no assumption on the 
%internal structure of a kv-store when proving the robustness of a library $L$, other than the fact that it is included
%$\CMs(\ET, L)$.
%To prove the robustness of $L$ against $\ET$, for an arbitrary a kv-store $\mkvs$, we 
%\begin{enumerate*}
%	\item identify a property of $\mkvs$ that remains \emph{invariant} when running any client program of $L$ on $\mkvs$; and 
%	\item show that the invariant implies the irreflexivity of $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^{+}$.
%\end{enumerate*}
%for all client programs $\prog$ of library $L$, the set of 
%kv-stores obtained by running $\prog$ under $\ET$ are included in the set of kv-stores obtained by running $\prog$ under $\ET_{\SER}$.
%As an application of our theory, we show how we can prove the robustness of simple transactional libraries. 
%In the following, we write $\CMs(\ET, L)$ for the set of kv-stores obtained from running a client program $\prog$ of $L$. 
Using this theorem, we prove the robustness of a single counter against $\ET_{\PSI}$.
As discussed in \cref{sec:overview} that the robustness of multiple counters against $\ET_{\PSI}$ does not hold.
We thus prove the robustness of multiple counters and banking libraries \citep{bank-example-wsi} against $\ET_{\WSI}$ instead. 
%This is done by introducing a notation of \emph{\( \WSI \) safe}, libraries with certain patterns, that implies robustness against \( \WSI \).
While previous work on checking robustness \citep{giovanni_concur16,SIanalysis,laws,sureshConcur} uses
static-analysis techniques that cannot be extended to support client sessions, 
%As far as we are aware, 
we give the first robustness proofs that take client sessions into account.



\subsubsection{Robustness of a Single Counter against $\ET_{\PSI}$}
Given the single counter library $\Counter(\key)$, 
a client reads from $\key$ by calling $\ctrread(\key)$, and writes to $\key$ by calling $\ctrinc(\key)$ which first reads the value of $k$ and subsequently increments it by one.
Pick an arbitrary key $\key$ and a kv-store $\mkvs \in \CMs(\ET_{\PSI}, \mathsf{Counter}(\key))$
As $\ET_{\PSI}$ enforces write conflict freedom (\(\UA\)), we know: that if a transaction $\txid$ updates $\key$ (by calling $\ctrinc(\key)$) and writes version $\ver$ to $\key$, then it must have read the version of $\key$ immediately preceding $\ver$:
% in all $\mkvs \in \CMs(\ET_{\PSI}, \mathsf{Counter})$, we have:
$\fora{\txid, i > 0}\!\! \txid {=} \wtOf(\mkvs(\key, i)) \implies \txid \in \rsOf(\mkvs(\key, i{-}1))$. 
Moreover, as $\ET_{\PSI}$ enforces monotonic reads ($\MR$),
the order in which clients observe the versions of $\key$ (by calling $\ctrread(\key)$)
is consistent with the order of versions in $\mkvs(\key)$. 
As such, the kv-stores in $\CMs(\ET_{\PSI}, \mathsf{Counter}(\key)$ have the canonical structure depicted in   \cref{fig:prog_analysis}, as defined below, where $\lcat$ denotes list concatenation, and 
$\{\txid^{\mathsf{}}_{i}\}_{i=1}^{n}$ and $\bigcup_{i=0}^{n} \txidset^{\mathsf{}}_{i}$ 
are disjoint sets of transactions calling $\ctrinc(\key)$ and
$\ctrread(\key)$ respectively: 

\input{prog_analysis_kv_store}

\vspace{-7pt}
{%
\displaymathfont
\[%
\begin{aligned}
	\mkvs(\key) & = (0, \txid_{0}, \txidset^{\mathsf{}}_{0} \cup \Set{\txid^{\mathsf{}}_1}) 
	\lcat (1, \txid^{\mathsf{}}_{1}, \txidset^{\mathsf{}}_{1} \cup \Set{\txid^{\mathsf{}}_2}) 
	\lcat \cdots \lcat (n-1, \txid^{\mathsf{}}_{n-1}, \txidset^{\mathsf{}}_{n-1} \cup \Set{\txid^{\mathsf{}}_n})
	\lcat (n, \txid^{\mathsf{}}_n, \txidset^{\mathsf{}}_{n})
\end{aligned}%
\]
}%
%
%is the set of transactions calling $\ctrinc(\key)$, 
%and $\bigcup_{i=0}^{n} \txidset^{\mathsf{r}}_{i}$ is the set of transactions calling $\ctrread(\key)$. 

%We define the $\dashrightarrow$ relation between
%the transactions in $\mkvs$ as the smallest transitive relation that 
%satisfies the following: 
%\begin{enumerate*}
%	\item $\txid^{\mathsf{}}_{i} 
%	\dashrightarrow \txid$ if $\txid \in \txidset^{\mathsf{}}_{i}$;  
%	%or $\txid {=} \txid^{\mathsf{}}_{i+1}$; 
%	\item $\txid \dashrightarrow \txid'$ 
%	for some $\txid \in \txidset^{\mathsf{}}_{i}$,
%	if $\txid' {=} \txid^{\mathsf{}}_{i+1}$
%	or $\txid' \in \txidset^{\mathsf{}}_{i} \land \txid \toEDGE{\SO} \txid'$. 
%\end{enumerate*}
%\noindent The relation $\dashrightarrow$ is depicted in \cref{fig:prog_analysis}.
%%
%Note that $\dashrightarrow$ yields a total order over the transactions in $\mkvs$, 
%and includes $\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs}$. 
%As such, $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^+$ is irreflexive, 
%ensuring the robustness of $\Counter(\key)$ against $\ET_{\PSI}$.



We define the $\dashrightarrow$ relation depicted in \cref{fig:prog_analysis} by extending 
$\SO \cup 
\{
	(\txid_i, \txid_j) 
	\mid 
	\txid_j \in \T_i \lor 	
	(\txid_i \in \T_i \land j {=} i {+} 1)
\}$
to a strict total order (transitive and irreflexive). 
Note that $\dashrightarrow$ contains $\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs}$ and thus
$(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^+$ is irreflexive; 
\ie $\Counter(\key)$ is robust against $\ET_{\PSI}$.


Recall from \cref{sec:overview} that unlike in $\SER$ and $\SI$, under $\PSI$ clients can observe 
the increments on different keys in different orders (see \cref{fig:cp-disallowed}).
%for two or more counters we can 
%observe the long fork anomaly allowed by $\ET_{\PSI}$.
%disallowed under serialisability ($\ET_{\SER}$). 
As such, multiple counters are not robust against $\ET_{\PSI}$. 
%The long fork anomaly arises because clients can observe increments 
%of different counters in a different order.
%This anomaly does not arise under $\SI$. 

\subsubsection{Robustness against $\ET_{\WSI}$}
\sx{strictly no blind write, \SI also works for sure, etc.}
Several existing examples in the literature that are robust against $\SI$ 
\citep{giovanni_concur16,bank-example-wsi}, are also robust against $\WSI$.
These examples all adhere to a particular pattern captured by the following definition.

\begin{definition}[\(\WSI\)-safe]
\label{def:main-body-wsi-safe}
    A kv-store \( \mkvs \) is \emph{\(\WSI\)-safe} if it is 
    reachable by executing a program \( \prog \) from an initial configuration \( \conf_0 \) under $\WSI$
   (\ie \( \conf_0, \prog \toPROG{}_{\ET_\WSI} (\mkvs, \stub), \stub\)), and for all $\txid, \key, i$:
    \begin{align}
         & \txid \in \rsOf[\mkvs(\key,i)] \land \txid \neq \wtOf[\mkvs(\key,i)]  \implies \fora{\key',j} \txid \neq \wtOf[\mkvs(\key',j)] \label{equ:main-wsi-safe-read-only} \\
         & \txid \neq \txid_0 \land \txid = \wtOf[\mkvs(\key,i)] \implies \exsts{j} \txid \in \rsOf[\mkvs(\key,j)] \label{equ:main-wsi-safe-write-must-read} \\
         & \txid \neq \txid_0 \land \txid = \wtOf[\mkvs(\key,i)] \land \exsts{k', j} \txid \in \rsOf[\mkvs(\key',j)] \implies \txid = \wtOf[\mkvs(\key',j)] \label{equ:main-wsi-safe-all-write}
    \end{align}
\end{definition}

This definition states that for each transaction $\txid$: 
\begin{enumerate*} 
    \item if $\txid$ reads from $\key$ without writing to it then $\txid$ must be a read-only transaction \eqref{equ:main-wsi-safe-read-only}; 
    \item if \( \txid \) writes to $\key$, then it must also read from it \eqref{equ:main-wsi-safe-write-must-read}, a property known as \emph{strictly-no-blind writes}; and
	\item  if \( \txid \) writes to $\key$, then it must also must write to all keys it reads \eqref{equ:main-wsi-safe-all-write}.
\end{enumerate*}
It is straightforward to see that the version $j$ read by \( \txid \) in \eqref{equ:main-wsi-safe-write-must-read} must be written immediately before the version $i$ written by \( \txid \), \ie \( i {=} j + 1 \).
%We next show that if a kv-store is \( \WSI \)-safe, then it is robustness against \( \WSI \).

\begin{theorem}[\( \WSI \) robustness]
    If a key-value store \( \mkvs \) is \(\WSI\)-safe, it is robust against \(\WSI\).
\end{theorem}

\noindent From \cref{thm:serialisable_nocycle} it suffices to prove $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^{+}$ is irreflexive.
We proceed by contradiction and assume there exists $\txid_1$ such that $\txid_1 \toEDGE{(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^{+}} \txid_1$. 
Since \( \mkvs \) is reachable under \( \WSI \) and thus also reachable under \( \CC \),
this cycle is of the form:
\[
    \txid_1 \toEDGE{\rel^*} \txid_2 \toEDGE{\RW} \txid_3 \toEDGE{\rel^*} \cdots \toEDGE{\rel^*} \txid_{n-2} \toEDGE{\RW} \txid_{n-1} \toEDGE{\rel^*} \txid_n = \txid_1
\]
\noindent where \( \rel \defeq \WR \cup \SO \cup \WW \).
From \eqref{equ:main-wsi-safe-write-must-read}, \eqref{equ:main-wsi-safe-all-write} we know that 
an \( \RW \) edge from a writing transaction can be replaced by a \( \WW \) edge.
Moreover, \( \WW \) edges can be replaced by \( \WR^* \) edges, since \( \mkvs \) is reachable under \( \UA \).
We thus have:
\[
    \txid_1 \toEDGE{{\rel'}^*} \txid'_2 \toEDGE{\RW} \txid'_3 \toEDGE{{\rel'}^+} \cdots \toEDGE{{\rel'}^+} \txid'_{m-2} \toEDGE{\RW} \txid'_{m-1} \toEDGE{{\rel'}^*} \txid'_m = \txid_n = \txid_1
\]
\noindent where \( \rel' = \WR \cup \SO \).
That is, \( \txid_1 \toEDGE{( (\WR \cup \SO); \RW^? )^* } \txid_n \).
This however leads to a contradiction as \( (\WR \cup \SO); \RW^? \subseteq \rel_\CP \) and 
\( \WSI \) requires views to be closed under \( \rel_\CP \) (see \cref{fig:execution_tests}). 

\subsubsection{Robustness of Multiple Counters against $\ET_{\WSI}$} 
\label{sec:multi-counter-robust}
A multi-counter library on a set of keys \( \codeFont{\keyset} \) is: 
\( \mathsf{Counters(\keyset)} \defeq \bigcup_{\codeFont{\key} \in \codeFont{\keyset} } \Counter(\codeFont{\key}) \).
We next show that a multi-counter library is \( \WSI \)-safe, and is therefore robust against \( \WSI \) and all stronger models such as \( \SI \).

\begin{theorem}
  A multi-counter library \( \mathsf{Counters(\keyset)}  \) is robust against \( \WSI \).
\end{theorem}

It sufficient to show that a kv-store obtained by executing arbitrary transactional calls from the library are \( \WSI \)-safe.
We proceed by induction on the length of traces.
Let \( \conf_0 = (\mkvs_0, \vienv_0) \) be an initial configuration and \( \prog_0 \) be a program such that \( \dom(\prog_0) \subseteq \dom(\vienv_0) \).
The initial kv-store trivially satisfies \eqref{equ:main-wsi-safe-read-only}, \eqref{equ:main-wsi-safe-write-must-read} and \eqref{equ:main-wsi-safe-all-write} above. 
%because \( \mkvs_0) \) contains only the initialisation transaction \( \txid_0 \).
Let \( \mkvs_i \) be the resulting kv-store after \( i \) steps of execution under \( \WSI \).
The next transaction \( \txid_{i+1} \) may then be a call to either \( \ctrinc(\pv{\key}) \) or \( \ctrread(\pv{\key}) \).
If \( \txid_{i+1} \) is a \( \ctrread(\pv{\key}) \) call,
then the new kv-store is: 
\[ 
	\mkvs_{i+1} = \mkvs_{i}\rmto{\pv{\key}}{\mkvs_i(\pv{\key})\rmto{j}{(\val, \txid, \txidset \uplus \Set{\txid_{i+1}})}} 
\]
%
for some \( j \) and \( \mkvs_i(\pv{\key},j) {=} (\val,\txid,\txidset)\).
Since \( \txid_{i+1} \) is a read-only transaction,
then  \eqref{equ:main-wsi-safe-read-only}, \eqref{equ:main-wsi-safe-write-must-read} and \eqref{equ:main-wsi-safe-all-write} immediately hold.
On the other hand, if \( \txid_{i+1} \) is a \( \ctrinc(\codeFont{\key}) \) call, 
then the new kv-store is: 
\[
    \mkvs_{i+1} = \mkvs_{i}\rmto{\pv{\key}}{( \mkvs_i(\pv{\key})\rmto{j}{(\val, \txid, \txidset \uplus \Set{\txid_{i+1}})} ) \lcat (\val+1, \txid_{i+1}, \emptyset) } 
\]
where \( j  {=} \abs{\mkvs_i(\pv{\key})} \) and \( \mkvs_i(\pv{\key},j) {=} (\val,\txid,\txidset)\).
As \( \txid_{i+1} \) reads the latest version of \( \pv{\key} \) and writes a new version to \( \pv{\key} \),
the new kv-store \( \mkvs_{i+1} \) satisfies \eqref{equ:main-wsi-safe-read-only}, \eqref{equ:main-wsi-safe-write-must-read} and \eqref{equ:main-wsi-safe-all-write}.

\subsubsection{Robustness of Banking example against $\ET_{\WSI}$}

\citet{bank-example-wsi} presented a banking example
and claimed that it is robust against  \( \SI \).
We find that the banking example is also robust against weak snapshot isolation \( \WSI \).
The example based on relational database has three tables, account, saving and checking.
The account table maps customer names to customer IDs (\( \codeFont{Account(\underline{Name}, CustomerID )} \))
and saving and checking tables map customer IDs to its saving balances (\( \codeFont{Saving(\underline{CustomerID}, Balance )} \)) 
and its checking balances (\( \codeFont{Checking(\underline{CustomerID}, Balance )} \)) respectively.
For simplicity, we only encode the saving and checking tables together as a kv-store,
but ignore the account table given that it is effectively an immutable lookup table.
In the encoding, each customer is encoded as an integer \( n \),
its checking balance is associated with 
key \( n_c \) defined by \( n_c \defeq 2 \times n \) and 
saving balance with \( n_s \) defined by \( n_s \defeq 2 \times n + 1 \).
Thus \( \Keys \defeq \bigcup_{n \in \Nat} \Set{n_c, n_s} \).
Given this encoding, if \( n \) is a customer, that is, \( (\stub, n) \in \codeFont{Account(\underline{Name}, CustomerID )} \),
then
\[ (n, \valueOf[\mkvs(n_s, \abs{\mkvs(n_s)})]) \in \codeFont{Saving(\underline{CustomerID}, Balance )} \]
\noindent and 
\( (n, \valueOf[\mkvs(n_s, \abs{\mkvs(n_c)})]) \in \codeFont{Checking(\underline{CustomerID}, Balance )} \) respectively.
This banking example consists of five types of transactions for interacting with the database.
For brevity, we assume balances are integers.
\begin{align*}
    \codeFont{balance(n)} & \defeq
    \begin{transaction}
    \plookup{\pv{x}}{\pv{n}_c}; \ 
    \plookup{\pv{y}}{\pv{n}_s}; \ 
    \passign{\ret}{\pv{x}+\pv{y}}
    \end{transaction} \\
    \codeFont{depositChecking(n,v)} & \defeq
    \begin{transaction}
    \pifs{\pv{v} \geq 0} \ 
    \plookup{\pv{x}}{\pv{n}_c}; \ 
    \pmutate{\pv{n}_c}{\pv{x} + \pv{v}}; \ 
    \pife
    \end{transaction}  \\
    \codeFont{transactSaving(n,v)} & \defeq
    \begin{transaction}
    \plookup{\pv{x}}{\pv{n}_s}; \ 
    \pifs{\pv{v} + \pv{x} \geq 0} \ 
    \pmutate{\pv{n}_s}{\pv{x} + \pv{v}}; \ 
    \pife
    \end{transaction}
\end{align*}
\( \codeFont{balance(n)} \) returns total balance of customer \( n \) through the spatial variable \( \ret \).
\( \codeFont{depositChecking(n,v)} \) deposits \( v \) to the checking account of customer \( n \)
if \( v  \) is non-negative, otherwise the transaction does nothing.
\( \codeFont{transactSaving(n,v)} \) allows a consumer \( n \) to deposit or withdraw money
from the saving account as long as the resulting balance is non-negative.
\begin{align*}
    \codeFont{amalgamate(n,n')} & \defeq
    \begin{transaction}
    \plookup{\pv{x}}{\pv{n}_s}; \ 
    \plookup{\pv{y}}{\pv{n}_c}; \ 
    \plookup{\pv{z}}{\pv{n'}_c}; \ 
    \pmutate{\pv{n}_s}{0}; \ 
    \pmutate{\pv{n}_c}{0}; \ 
    \pmutate{\pv{n'}_c}{\pv{x} + \pv{y} + \pv{z}}; 
    \end{transaction} \\
    \codeFont{writeCheck(n,v)} & \defeq
    \begin{transaction}
    \plookup{\pv{x}}{\pv{n}_s}; \ 
    \plookup{\pv{y}}{\pv{n}_c}; \\
    \pifs{\pv{x} + \pv{y} < \pv{v} } \
        \pmutate{\pv{n}_c}{\pv{y} - \pv{v} - 1 }; \
    \pifm \
        \pmutate{\pv{n}_c}{\pv{y} - \pv{v} }; \ 
    \pife \ 
    \pmutate{\pv{n}_s}{\pv{x}}; 
    \end{transaction} 
\end{align*}
\( \codeFont{amalgamate(n,n')} \) represents moving all funds from consumer \( n \) to
the checking account of another customer \( n'\).
Last, \( \codeFont{writeCheck(n,v)} \) updates the checking account of \( n \).
If funds, both saving and checking, from \( n \) is greater than the \( v \),
the transaction deducts \( v \) from the checking account.
If funds are not enough, the transaction further deducts one pound as penalty.
\citet{bank-example-wsi} argued that, to make this example robust against \( \SI \),
\( \codeFont{writeCheck(n,v)} \) must be strengthened by writing back the balance to the saving account 
(\(\pmutate{\pv{n}_s}{\pv{x}} \)),
even thought the saving balance is unchanged.
The banking library, \( \codeFont{Bank} \), is defined by
\[ 
    \codeFont{Bank} \defeq \Set{\codeFont{balance(n)}, \codeFont{depositChecking(n,v)}, 
    \codeFont{amalgamate(n,n')}, \\ \codeFont{writeCheck(n,v)}, \codeFont{writeCheck(n,v)} }
    [ n,n' \in \Nat \land \pv{v} \in \mathbb{Z} ] 
\]

This banking example is more complex than the previous multiple counter example (\cref{sec:multi-counter-robust}),
but all the transactions are either read-only or
satisfy strict no blind write.

\begin{theorem}
    Bank libraries \codeFont{Bank} are robust against \( \WSI \).
\end{theorem}

\noindent We prove it in a similar way to the previous multiple counter example: given a kv-store \( \mkvs_i \) that is \( \WSI \) safe,
we check if the next transaction preserves \( \WSI \) safe, 
specifically \cref{equ:main-wsi-safe-all-write,equ:main-wsi-safe-read-only,equ:main-wsi-safe-write-must-read}.
\(\codeFont{balance(n)} \) reads \( n_c \) and \( n_s \) therefore satisfies \cref{equ:main-wsi-safe-all-write,equ:main-wsi-safe-read-only,equ:main-wsi-safe-write-must-read}.
\(\codeFont{depositChecking(n,v)} \) reads and updates \( n_c \) if \( v \) is greater or equal than 0, and does nothing otherwise.
In the case that \( v \) greater or equal than 0,  \(\codeFont{depositChecking(n,v)} \) preserves  
\cref{equ:main-wsi-safe-all-write,equ:main-wsi-safe-read-only,equ:main-wsi-safe-write-must-read} since
the transaction only touch \( n_c \).
While in the case that \( v \) less than 0, there is nothing to prove.
\( \codeFont{transactSaving(n,v)}, \codeFont{amalgamate(n,n')} \) and \( \codeFont{writeCheck(n,v)}\)
always read and write to any keys they touch, thus ensure strict no blind write.

\ac{
\subsubsection{Robustness of Multiple Counters against $\ET_{\SI}$} 
%$\ET_{\PSI}$ to $\ET_{\SI}$, 
%we can analogously recover the robustness of multiple counters.
For simplicity, here we assume that the library comprises only two counters: 
$\mathsf{Counters(\key_1, \key_2)} {=} \Counter(\key_1) \cup \Counter(\key_2)$.
%We use the following result, which is the kv-store counterpart of a well-known result for SI~\cite{fekete-tods,SIanalysis}: 
%\begin{theorem}
%\label{thm:si_cycles}
%For all $\mkvs \in \CMs(\ET_{\SI})$, any cycle in $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^+$ has two adjacent $\RW_{\mkvs}$-edges.
%\end{theorem}xs
Consider a kv-store $\mkvs \in \CMs(\ET_{\SI}, \mathsf{Counters})$. 
As $\ET_{\SI} \subseteq \ET_{\PSI}$, the lists of versions of $\mkvs(\key_1)$ and $\mkvs(\key_2)$ 
must both follow the same structure described for a single counter under $\ET_{\PSI}$. 

\vspace{-7pt}
%
{\displaymathfont%
\begin{align}
\nonumber
\mkvs(\key_{1}) & = (0, \txid_{0}, \txidset^{1}_{0} \cup \Set{\txid^{1}_1}) 
	%\lcat (1, \txid^{1}_{1}, \txidset^{1}_{1} \cup \T^{1}_2}) 
	\lcat \cdots \lcat (n-1, \txid^{1}_{n-1}, \txidset^{1}_{n-1} \cup \Set{\txid^{1}_n})
	\lcat (n, \txid^{1}_n, \txidset^{1}_{n})\\
\mkvs(\key_{2}) & = (0, \txid_{0}, \txidset^{2}_{0} \cup \Set{\txid^{2}_1}) 
	%\lcat (1, \txid^{\2}_{1}, \txidset^{2}_{1} \cup \Set{\txid^{2}_2}) 
	\lcat \cdots \lcat (m-1, \txid^{2}_{m-1}, \txidset^{1}_{m-1} \cup \Set{\txid^{2}_m})
	\lcat (m, \txid^{2}_m, \txidset^{2}_{m}) \label{eq:si_counter_structure}
\end{align}
}%
Recall that this structure yields a total order $\dashrightarrow$ over transactions in $\mkvs(\key_1)$ and $\mkvs(\key_2)$, 
which embeds an acyclic relation $\WR_{\mkvs} \cup \WW_{\mkvs} \cup \RF_{\mkvs}$. 
However, since a client can now perform operations on both counters, $\dashrightarrow$ no longer comprises $\SO_{\mkvs}$. 

We define a second relation $\twoheadrightarrow$ that tracks the session order of transactions accessing different keys: 
$\txid \twoheadrightarrow \txid'$ iff $\txid \xrightarrow{\SO} \txid'$ and there exists $i,j \in \{1,2\}$ such that
$i \neq j$ and $\txid \in \Set{\wtOf(\mkvs(\key_{i}, \stub)} \cup \rsOf(\mkvs(\key_{i}, \stub)),  
\txid' \in \Set{\wtOf(\mkvs(\key_{j}, \stub))} \cup \rsOf(\mkvs(\key_{j}, \stub))$.
The combined relation $(\dashrightarrow \cup \twoheadrightarrow)$ embeds 
$(\SO_{\hh} \cup \WR_{\hh} \cup \WW_{\hh} \cup \RW_{\hh})$. We prove that the relation $(\dashrightarrow \cup \twoheadrightarrow)$ 
is acyclic: therefore, $\hh$ is serialisable. 

More specifically, we prove that any $\ET_{\SI}$-trace
%by induction on the length of a $\ET_{\SI}$-trace 
in $\CMs(\ET_{\SI}, \mathsf{Counter}(\key_1) \cup \mathsf{Counter}(\key_2))$ terminates in a configuration of the form $(\mkvs, \_)$ 
such that the relation $(\dashrightarrow \cup \twoheadrightarrow)$ over $\mkvs$ is irreflexive; the proof is by induction on the 
length of the $\ET_{\SI}$-trace. Here we only show the details of the inductive step of the proof in the most interesting case, 
that is one where a cycle in the relation $(\dashrightarrow \cup \twoheadrightarrow)$ is created because 
client $\cl_{1}$ reads a version of some key, e.g. $\key_{1}$, after accessing the other, e.g. $\key_{2}$; and the order 
of such operations seemingly contradicts the order of the versions of $\key_{1}, \key_{2}$ observed by another client 
$\cl_{2}$. As we will see shortly, this case leads to a contradiction. 

Let $\mkvs$ be the kv-store from \cref{eq:si_counter_structure}, and assume that the relation $(\dashrightarrow \cup \twoheadrightarrow)$ 
is acyclic in $\mkvs$. Suppose also that 
$(\mkvs, \vienv) \toET{\cl_{1}, (\otR, \key_{1}, \_)}[\ET_\SI] (\mkvs', \vienv')$, and the relation
$(\dashrightarrow \cup \twoheadrightarrow)$ contains a cycle in $\mkvs'$. Let $i = \max_{\leq}(\vienv(\cl_1)(\key_1))$: 
it follows that $\mkvs'$ differs from $\mkvs$ only in the set of transactions that read version $\mkvs'(\key_{1})$, 
which must contain a new transaction $\txid$ (i.e. not appearing in $\mkvs$) of the form $\txid_{\cl_{1}}^{\_}$.
We know that the relation $\dashrightarrow$ is acyclic in $\mkvs'$, so that 
any cycle in $(\dashrightarrow \cup \twoheadrightarrow)$ in $\mkvs'$ must contain at least a $\twoheadrightarrow$ 
edge. In fact, because $\twoheadrightarrow$ edges only connect transactions accessing different keys, such 
a cycle must contain at least two $\twoheadrightarrow$ edges. Without loss of generality, we can assume that 
this cycle has the form $\txid \dashrightarrow\rflx \txid' \twoheadrightarrow \txid'' \dashrightarrow\rflx \txid''' \twoheadrightarrow \txid$ 
for some $\txid', \txid'', \txid'''$. It follows that either $\txid' = \txid = \txid^{w,1}_{i+1}$, or $\txid' \in \{\txid^{(w,1)}_{j}\} \cup \T^{r,1}_{j}$ 
for some $j > i$;  $\txid' \xrightarrow{\SO} \txid''$ and there exists an index $h$ such that either $\txid'' = \txid^{w,2}_{h}$, 
or $\txid'' \in \{\txid^{w,2}_{h+1}\} \cup \T^{r,2}_{h}$; 
either $\txid''' = \txid^{w,2}_{l}$, or $\txid''' \in \{\txid^{w,2}_{l+1}\} \cup \T^{r,2}_{l}$ for some $l > h$; and $\txid''' \xrightarrow{\SO} \txid$.
Without loss of generality, we assume that $\txid \in \T^{(r,1)}_{i}$, 
$\txid' \in \T^{(r,1)}_{j}$, $\txid'' \in \T^{r,2}_{h}$ and $\txid''' \in \T^{(r,2)}_{l}$, with $j > i$, $l > h$: other cases are similar. 
Because $\txid''' \xrightarrow{\SO} \txid$, then when $\txid''' \in \T^{r,2}_{l}$ committed client $\cl_1$ included $l$ 
in the view of $\key$; it follows from $\ET_{\MR}$  
%that the index $l$ was contained in the view of client $\cl_1$, and because $\ET_{\SI}$ is included in $\ET_{\MR}$, we also have 
that $l \in \vienv(\cl_{1})(\key_{2})$. Next, we have that $\T^{(r,1)}_{j} \ni \txid' \xrightarrow{\SO} \txid'' \xrightarrow{\RW} \txid^{(w,2)}_{l}$, 
and because $l \in \vienv(\cl_{1})(\key_{2})$, it follows from $\ET_{\CP}$ (which includes $\ET_{\SI}$) that 
$j \in \vienv(\cl_{1})(\key_{1})$. But $j > i$, contradicting the fact that $i = \max_{\leq}(\vienv(\cl_1)(\key_1)$.
%Furthermore, one of these two edges should not 
%be present in $\mkvs$, because we are assuming that the relation $(\dashrightarrow \cup \twoheadrightarrow)$ is 
%acyclic in $\mkvs$. This implies that there exists an index $j = 0,\cdots, m$ such that either $\txid_{j}^{w, 2} 
%\xrightarrow{\SO} \txid$, $\txid_{j+1}^{w,2} \xrightarrow{\SO} \txid$, or $\txid_{j+1}(\cl)$.

Our proof that multiple counters are robust against $\ET_{\SI}$ makes use 
of the properties of the execution tests $\ET_{\CP}$ and $\ET_{\UA}$ individually, and in fact the same proof can 
be used to prove that multiple counters are robust against the novel execution test $\ET_{\WSI}$ 
introduced in \cref{sec:new_cm}. 
%We believe that the correctness of many applications under $\SI$ is preserved when 
%switching to the $\WSI$ consistency model.

%: as a result, 
%the kv-store $\hh$ is serialisable, which concludes the proof that multiple counters are robust against $\ET_{\SI}$
%Relation $\twoheadrightarrow$ tracks the session order of transactions performing operations on different keys. 
%Let $\rightarrow \defeq (\dashrightarrow \cup \twoheadrightarrow)^{+}$; 
%we then know that $\rightarrow$ embeds $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^{+}$.
%Furthermore, because $\mathsf{Counters}$ contains no operation that accesses both $\key_1$ and $\key_2$, and since $\dashrightarrow$ is acyclic, 
%any cycle in $\rightarrow$ contains at least two edges from $\twoheadrightarrow$. 
%In \cref{app:robustness} we show that the existence of such a cycle implies the 
%existence of a cycle in $\rightarrow$ of the form $\txid \dashrightarrow^{?} \txid_{a} \twoheadrightarrow 
%\txid_{b} \dashrightarrow^{?} \txid_{c} \twoheadrightarrow \txid$. 
%However, this cannot happen in $\mkvs$, as otherwise we would have a cycle in $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^{+}$ with no adjacent $\RW_{\mkvs}$-edges (a $\twoheadrightarrow$ edge represents two  $\SO_{\mkvs}$-related transactions, 
%thus contradicting \cref{thm:si_cycles}). 
%It then follows that $\rightarrow$ is irreflexive, and thus so is $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^+$.
}

\subsection{Verifying Database Protocols}
\label{sec:verify-impl}
Kv-stores and views provide a 
faithful abstraction of the state of geo-replicated and partitioned
databases, and  execution tests provide a powerful abstraction of the synchronisation mechanisms 
enforced by these databases to commit a transaction. This makes it
possible to use our 
semantics to verify the correctness of distributed database protocols. 
We  demonstrate this by showing that  the replicated database 
%Our representation of database state as kv-stores and client views closely matches the representation of database state in many implementations of 
%well-known protocols~\cite{ramp,rola,cops,wren,redblue,PSI,NMSI,gdur,clocksi,distrsi}.
%As such, when verifying such protocols, our state-based formalism is better-suited than the existing graph-based formalisms of dependency graphs and abstract executions. 
%In centralised databases, the state of the centralised server corresponds to a kv-store,
%and the local snapshots that transactions operate on are extracted from our views.  
%In distributed databases, each replica state corresponds to a view. 
%Moreover, since most distributed databases are eventually consistent, 
%\ie all replicas eventually agree on the database state,
%replica states can be collectively encoded as a kv-store.
%We verify the correctness of two database protocols:
COPS~\cite{cops} satisfies causal consistency  (this section and \cref{sec:implementation-verification}), and that
the partitioned database Clock-SI~\cite{clocksi} satisfies snapshot isolation (\cref{sec:implementation-verification}).


\input{cops-graph.tex}

COPS is a fully replicated database, with each replica storing multiple versions of each key as illustrated in \cref{fig:initial-cops,fig:cops-after-write-transaction}. 
Each COPS version \( \ver \),
\eg \( (\key_1,\val_1,(\txid_1,\repl_1), \emptyset) \) in \cref{fig:cops-after-write-transaction},
contains a key (\eg $\key_1$), a value (\eg $\val_1$), a time-stamp denoting when a client first requested the
replica to write the version (\eg $(\txid_1, \repl_1)$), and a set of dependencies, written $\depOf[\ver]$ (\eg $\emptyset$). 
A time-stamp associated with a version $\ver$ is of the form $(\txid, \repl)$, where $\repl$ identifies the replica that committed $\ver$, and $\txid$ denotes the local, real time when $\repl$ committed $\ver$. 
Each dependency in $\depOf[\ver]$ comprises a key and the time-stamp of the version of that key on which $\ver$ directly depends.  
COPS assumes a total order among replica identifiers. Thus,  time-stamps can be
totally ordered lexicographically over pairs of real-time of
operations and replica identifiers.

The COPS API provides two operations for  clients: one for writing to a single
key; and another for reading from 
a set of keys atomically. Each instance of these operations is processed by a single replica. 
Each client maintains a \emph{context}, which is a set of dependencies
corresponding to the versions it observes.  
%future operations that the client performs depend from such versions.

We demonstrate how a client \( \cl \) interacts with a replica through the following example:
\begin{align}
    \label{equ:client-repl-1}
    \cl: \begin{transaction} \pmutate{\key_1}{\val_1}; \end{transaction} ; \ 
    \begin{transaction} \pderef{\vx}{\key_1}; \ \pderef{\vy}{\key_2}; \end{transaction}
    \tag{\textsc{cops-cl}}
\end{align}
For brevity, we assume that there are two keys ($\key_1$ and $\key_2$) and two replicas ($\repl_1$ and $\repl_2$) 
as shown in \cref{fig:initial-cops}, where $\repl_1 < \repl_2$.
Initially, client \( \cl \) connects to replica \( \repl_1 \) and initialises its local context \( ctx \) as $\emptyset$.
To execute its first single-write transaction, client $\cl$ requests to write $\val_1$ to $\key_1$ at its associated replica $\repl_1$, by sending the message $(\key_1, \val_1, ctx)$ to $\repl_1$. 
It then awaits a reply from $\repl_1$.
Upon receiving the message, $\repl_1$ produces a monotonically increasing local time $\txid_1$, and uses it to install  a new version $\ver {=} (\key_1,\val_1, (\txid_1,\repl_1), ctx)$ as shown in \cref{fig:cops-after-write-transaction}.
Note that the dependency set of $\ver$ is the $\cl$ context ($ctx {=} \emptyset$).
%The version carries the value received, and the context received as its set of dependencies: 
%It thus depends on other versions previously observed by the client $\cl_1$. 
Replica $\repl_1$ then sends the time-stamp $(\txid_1,\repl_1)$ back to client $\cl_1$, and $\cl_1$ in turn  incorporates $(\key_1, \txid_1,\repl_1)$ in its local context; \ie 
$\cl$ observes its own write. 
Finally, replica $\repl_1$ propagates the written version to other replicas asynchronously, by sending a \emph{synchronisation message} 
using \emph{causal delivery} as follows. 
In the general case, when a replica $\repl'$ receives a version $\ver'$ from another replica $\repl$, it 
first waits for all dependencies of $\ver$ to be committed to $\repl'$, and then commits $\ver$.
As such, the set of versions contained in each replica is closed with respect to causal dependencies.
In the example above, when other replicas receive version $\ver$ from $\repl_1$, they can immediately commit $\ver$ as its dependency set is empty. 
Note that replicas may accept new versions from different clients in parallel (see \cref{fig:cops-after-write-transaction}).
%This property ensures that 
%A COPS client interacts with a single replica at a time via COPS API,
%either single-write or multiple-read transactions.
%Replicas \( \repl \) store all versions that has been received from clients, or other replicas via synchronisation.
%Each version \( \ver \) includes a key, a value, a unique timestamp 
%assigned by the replica who initially received this version from a client,
%and a \emph{dependency set}, written by \( \depOf[\ver]\).
%This dependency set traces the versions on which $\ver$ causally depends.
%A synchronisation message with a version \( \ver \) will be received only 
%when all the versions in the dependency set have been received.
%This guarantees that for any version \( \ver \) in a replica \( \repl \), written by \( \ver \in \repl \),
%the versions on which \( \ver \) depends also are in the replica, \( \depOf[\ver] \subseteq \repl \).
%COPS assumes that all versions eventually deliver to all replicas.
%Replicas themselves are assigned with unique identifiers that are totally ordered.
%As such, all versions on all keys are totally ordered,
%which, together with eventual delivery, guarantees eventual consistency among all replicas.
%The COPS API follows the multiple-readers-single-writer paradigm: 
%at any given time, the database can be accessed by either multiple read-only concurrent transactions, or single writing transactions. 
%Each version $\ver$ records a value and a \emph{dependency set}, written $\depOf[\ver]$,
%tracking the versions on which $\ver$ causally depends.
%This causal dependency contains previous reads and writes from the same client, and their dependencies,
%that is, 
%\( \left( \left( \SO \cup \WR \right) ^{-1}\right)^{*}(\wtOf[\ver]) \subseteq \depOf[\ver] \).
%
%For a client to commit a single-write transaction, hence a new value \( \val \) of a key \( \key \),
%it sends the new value \( \val \) and more importantly the dependency set \( D \), to a replica
%in which the \( \key, \val, D \) together with a newly assigned timestamp \( \txid \), turn into a new version \( \ver \);
%then the new timestamp returns to the client.
%To construct the dependency set for the new version,
%each client maintains a \emph{client context} that tracks the versions that have been either fetched from, or committed to any replicas. 
%For a single-write transaction, the client context becomes the dependency set \( D \) of the new version \( \ver \) which ensures \( D \) contains all versions that \( \ver \) causally depends on.
%
%

To execute its second multi-read transaction ,
client  \( cl \) requests to read keys \( \Set{\key_1, \key_2} \) by sending a message containing 
\( \Set{\key_1, \key_2} \) to replica $\repl_1$ and awaits a reply.
Upon receiving this message, replica $\repl_1$ builds a causally consistent snapshot, \ie
a mapping from $\Set{\key_1, \key_2}$ to values, in two rounds as follows. 
First, $\repl_1$ optimistically fetches the most recent versions for \( \Set{\key_1,\key_2}\)
one at a time. 
This process may be interleaved with other writes and synchronisation messages (propagated from other replicas). 
For instance, \cref{fig:cops-request-values} depicts a scenario where \( \repl_1 \)
\begin{enumerate*}
	\item first fetches \( (\key_1,\val_1,(\txid_1,\repl_1), \emptyset) \) for $\key_1$ (highlighted) ; %(highlighted in \cref{fig:cops-request-values})
	\item then receives two synchronisation messages from \( \repl_2 \), 
containing versions \( ( \key_1, \val'_1, (\txid_1,\repl_2),\emptyset ) \) and \( ( \key_2, \val'_2, (t_2,\repl_2),\Set{(\key_1,\txid_1,\repl_2)} ) \); and
	\item finally fetches \( ( \key_2, \val'_2, (t_2,\repl_2),\Set{(\key_1,\txid_1,\repl_2)} ) \) for $\key_2$ (highlighted).
\end{enumerate*}
As such, the versions fetched for \( \Set{\key_1,\key_2}\) are not causally consistency,: 
\( ( \key_2, \val'_2, (t_2,\repl_2),\Set{(\key_1,\txid_1,\repl_2)} ) \) depends on a version of \( \key_1 \) with time-stamp $(\txid_1, \repl_2)$ which is bigger than that fetched for $\key_1$: $(\txid_1, \repl_1)$.
%In particular, it may be the case that the version $\ver_{\key_{n}}$ causally depends 
%on a version $\ver'_{\key_{i}}$ that is newer than $\ver_{\key_{i}}$,  where $0 < i < n$, but commits at replica $r$ 
%after the version $\ver_{\key_{i}}$ is read. The set of versions read by $r$ is not causally consistent. 
To remedy this, after the first round of optimistic reads,
$\repl_1$ collects all dependency sets and uses them as an upper-bound in the second round.
to re-fetch the most recent version (with the biggest time-stamp) of each key from the dependency sets.
For instance, in \cref{fig:cops-request-values} re-fetches the newer version \( ( \key_1, \val'_1, (\txid_1,\repl_2),\emptyset ) \) for \( \key_1 \), as depicted in \cref{fig:cops-re-read-values}.
The snapshot obtained after the second round is thus causally consistent. 
The snapshot is then sent to the client, together with the set of dependencies of each version read which are 
included into the local context of the client.
% Future operations of
%the client depend frthe versions 
%the client has read.
\ac{I will leave this to myself for future reference: why the hell does COPS do this in two rounds? It looks like you can do 
this in a single round, by simply taking the time-stamp of the first version you read as an upper bound for future reads.
Update: Went to check directly on the COPS protocol, and indeed COPS really does something more - but not much more - complicated. 
The main aspect from which COPS differs from Shale's idealisation of it is that (1) reads happen concurrently, and the 
one with highest time-stamp is used to fix the bound on versions in the first round, and (2) in the second round not all keys 
are re-fetched, but only those that are really needed to recover a causally consistent snapshot.}

%This means that a previously read version \( \ver_{\key_j}\) on key \( \key_j \) might be too old for a later version \( \ver_{\key_m} \) on key \( \key_m\) (\(j < m\)) whose dependency set \( \depOf[\ver_{\key_m}] \) contains a newer version \( \ver'_{\key_j} \in \depOf[\ver_{\key_m}] \) on the key \( \key_j \).
%To tackle the problem, after the first round of optimistic reads 
%fetching versions \( \ver_{\key_1}, \dots, \ver_{\key_n} \), 
%the replica computes the maximum version \( \ver'_{\key_i} \) for each key \( \key_i \) (\( 0 < i \leq n \))
%among versions for the same key that are included in any dependency sets:
%\( \ver'_{\key_i} = \max\bigcup_{0 < z \leq n }\Set{\ver}[\func{keyOf}[\ver] = \key_i \land \ver \in \depOf[\ver_{\key_z}]] \);
%afterwards, if the \( \ver'_{\key_i} \) is newer than \( \ver_{\key_i} \) 
%meaning \( \ver'_{\key_i} > \ver_{\key_i}\), 
%the replica re-fetches and returns the newer version \( \ver'_{\key_i} \) to client for the key \( \key_i \),
%otherwise it returns \( \ver_{\key_i} \).
%Once the client receiving versions for keys \( \key_1,\dots,\key_n \) respectively, it adds those versions in its context so that any future single-write transactions will have correct dependency sets.

%The dependency set is crucial for fetching causally consistent versions.
%If a transaction reads a version \( \ver \) for key \( \key \) that 
%depends on another version \( \ver' \in \depOf[\ver]\) for key \( \key' \), 
%the transaction should at least read \( \ver' \) or any version later than \( \ver' \) for the key \( \key' \).
%A single-write transaction, meanwhile, commits the new version including the dependency set.
%When a client commits a single-write transaction,
%the dependency set of the new version \( \ver \) includes the context \( ctx \) and versions the context depends on:
%\[
    %\depOf[\ver]  = ctx \cup \bigcup_{\ver' \in ctx} \depOf[\ver']
%\]

\input{cops-encoded.tex}

To prove that COPS satisfies causal consistency,
we encode the state of the system 
(comprising the state of all replicas and clients) as a
configuration in  our operational semantics. 
As each replica stores a set of versions (for each key in COPS) and their dependencies, 
we can project the state of  COPS replicas into a kv-store 
by mapping  COPS versions into our kv-store versions.
The writer of a mapped version is uniquely
determined by the time-stamp of the corresponding COPS version.
The reader set of the mapped version 
can be recovered by annotating read-only transactions.
%from the time-stamps in the dependency set of the corresponding COPS version. 
For example, the COPS state in \cref{fig:cops-after-write-transaction} can be encoded as the kv-store depicted in \cref{fig:encode-mkvs}.
Similarly, as the context of a client $\cl$ identifies the set of COPS versions that $\cl$ sees, 
we can project COPS client contexts to our client views over kv-stores. 
For example, the context of \( \cl \) after committing its single-write transaction in \eqref{equ:client-repl-1} is encoded as the client view depicted in \cref{fig:encode-view}.
%a set of dependencies, which are mapped into a set of (kv-store) versions 
%in the kv-store built from the state of COPS replicas: the local context of a client determines a view over the kv-store.

%Having encoded client-replica states in COPS into configurations, 
We next map the execution of a COPS transaction into an $\ET_{\CC}$ reduction between the configurations 
obtained from encoding the COPS states before and after executing the transaction.
Note that existing verification techniques \cite{framework-concur,seebelieve} require examining the \emph{entire} sequence of operations of a protocol to show that it implements a consistency model.
By contrast, we only need to look at how the system evolves after a \emph{single} transaction is executed.
In particular, we check the client views (obtained from COPS client contexts) over kv-stores after executing a transaction as follows.
Intuitively, we observe that when a COPS client $\cl$ executes a transaction then:
\begin{enumerate*} 
\item the $\cl$ context grows, and thus we obtain a more up-to-date view of the associated kv-store; \ie $\vshiftname_{\MR}$ holds;
\item the $\cl$ context always includes the time-stamp of the versions written by itself, and thus the 
corresponding client view always includes the versions $\cl$ has written; \ie $\vshiftname_{\RYW}$ holds; 
\item the $\cl$ context always contains the dependencies corresponding to versions it has 
either written or read from other transactions, and thus the corresponding client view is always closed-down 
with respect to the relation $\SO \cup \WR_{\mkvs}$; \ie $\closed[\mkvs, \vi, R_{\CC}])$ holds.
\end{enumerate*}
As such, from the definition of $\CC$ in \cref{fig:execution_tests} we know that COPS satisfies causal consistency ($\CC$).
We refer the reader to  \cref{sec:cops} for further details and the full soundness proof.

%\subsubsection{Clock-SI}
%Clock-SI is a distributed protocol for partitioned key-value
%stores. The set of keys  and 
%their respective versions are partitioned across different machines; versions of keys are time-stamped. 
%Clock-SI supports transactions with arbitrary reads and writes. 
%The protocol assigns a \emph{coordinator} partition to each transaction, which    
%is responsible for contacting other partitions when reading keys remotely or 
%when committing the transaction. Upon starting, a transaction records 
%the current time of the coordinator, which it uses as an upper bound for the time-stamp 
%of versions that the transaction can read. To ensure that the snapshot built by a transaction is consistent, 
%remote reads are delayed until the clock of the contacted partition catches up with the time recorded by 
%the coordinator. To ensure write-conflict-freedom, Clock-SI employs a two-phase-commit protocol, a specialised 
%form of consensus where all the partitions check locally for write-conflict freedom, and the transaction 
%is committed only after all partitions agree to commit.
%The proof that Clock-SI is sound with respect to $\ET_\SI$ is given in
%\cref{sec:clock-si}.
