\section{Applications}
\label{sec:applications}

\subsection{Program Analysis}
\label{sec:program-analysis}
A transactional library is a set of transactions 
$L = \{\ptrans{\trans}_{i}\}_{i \in I}$ that can be invoked 
by clients of a kv-store. A transactional library is said to be 
\emph{robust} against an execution test of $\ET$ if the set of kv-stores 
obtainable by letting clients interact with the kv-store using 
operations from $L$ can also be obtained by if the same 
set of operations were performed under $\ET_{\SER}$.
As an application of our theory, we show how we 
can prove the robustness of some simple applications. 
In the following, we let $\CMs(\ET, L)$ be 
the set of kv-stores that can be obtained if clients 
only invoke operations from $L$.

Elaborating on the examples from \cref{sec:overview}, in this Section 
we prove the robustness of a single counter against $\ET_{\PSI}$, 
and multiple counters against $\ET_{\SI}$. Previous techniques for 
checking the robustness of a transactional library \cite{giovanni_concur16,SIanalysis,laws,sureshConcur} 
are based on static analysis: because the session order of clients cannot be determined at compile 
time, these techniques abstract from sessions. To the best of our knowledge, 
we give the first proofs of robustness of transactional libraries that involve sessions.

Our proof technique for robustness uses the following result, which can be though 
as the kv-store counterpart of another well known result for dependency graphs \cite{adya}:
\begin{theorem}
\label{thm:serialisable_nocycle}
Let $\hh$ be a kv-store. Then $\hh \in \CMs(\ET_{\SER})$ if and only if $(\PO_{\hh} \cup \RF_{\hh} 
\cup \VO_{\hh} \cup \AD_{\hh})^{+}$ is irreflexive.
\end{theorem}
To prove the robustness of a transactional library $L$ against an execution test 
$\ET$, we identify an invariant of kv-stores $\hh$ obtainable by letting clients 
invoke only operations contained in $L$, and prove that the invariant 
implies the irreflexivity of the relation $(\PO_{\hh} \cup \RF_{\hh} \cup \VO_{\hh} \cup 
\AD_{\hh})^{+}$.

\mypar{Robustness of a single counter against $\ET_{\PSI}$}
Fix a key $\ke \in \Keys$, and let $\Counter(\ke) = \{\ctrinc(\ke), 
\ctrread(\ke)\}$. Let $\hh \in \CMs(\ET_{\PSI}, \mathsf{Counter}(\ke))$.
Clients can only write a version for key $\ke$ by invoking the 
operation $\ctrinc(\ke)$; because $\ET_{\PSI}$ 
enforces write-conflict detection freedom, in any key-value store 
$\hh \in \CMs(\ET_{\PSI}, \mathsf{Counter})$, we have that 
for all \( \txid, i > 0\):
$\txid = \WTx(\hh(\ke, i)) \implies \txid \in \RTx(\hh(\ke, i-1))$. 
Furthermore, because 
$\ET_{\PSI}$ satisfies the monotonic reads, 
$\ET_{\PSI} \subseteq \ET_{\MRd}$, the order in which 
a client $\cl$ observes the versions of $\ke$ by invocations of $\ctrread(\ke)$, 
is consistent with the order of the index of such versions in $\hh(\ke)$. 
Formally, we have:
\begin{align*}
\hh(\ke) & = (0, \txid_{0}, \T^{\mathsf{r}}_{0} \cup \{\txid^{\mathsf{w}}_1\}) 
\lcat (1, \txid^{\mathsf{w}}_{1}, \T^{\mathsf{r}}_{1} \cup \{\txid^{\mathsf{w}}_2\}) 
\lcat \cdots  \\
& \qquad \cdots \lcat (n-1, \txid^{\mathsf{w}}_{n-1}, \T^{\mathsf{r}}_{n-1} \cup \Set{\txid^{\mathsf{w}}_n})
\lcat (n, \txid^{\mathsf{w}}_n, \T^{\mathsf{r}}_{n})
\end{align*}
where $\{\txid^{\mathsf{w}}_{i}\}_{i=1}^{n}$ is the 
set of transactions invoking operation $\ctrinc(\ke)$, and $\bigcup_{i=0}^{n} 
\T^{\mathsf{r}}_{i}$ is the set of transactions invoking operation $\ctrread(\ke)$. 
Next, we define a relation $\dashrightarrow$ between
transactions appearing in $\hh$ as the smallest transitive relation that 
satisfies the following constraints: 
\begin{enumerate*}
\item $\txid^{\mathsf{w}}_{i} 
\dashrightarrow \txid$ whenever $\txid \in \T^{\mathsf{r}}_{i}$ 
or $\txid = \txid^{\mathsf{w}}_{i+1}$; 
\item $\txid \dashrightarrow \txid'$ 
for some $\txid \in \T^{\mathsf{r}}_{i}$,
whenever $\txid' = \txid^{\mathsf{w}}_{i+1}$
or $\txid' \in \T^{\mathsf{r}}_{i} \land \txid \xrightarrow{\PO} \txid'$. 
\end{enumerate*}
Because of the structure of $\hh$, the relation $\dashrightarrow$ corresponds to a 
total order over transactions appearing in $\hh$; furthermore, it comprises 
the relations $\PO_{\hh}, \RF_{\hh}, \VO_{\hh}$ and $\AD_{\hh}$, which implies 
the robustness of the library $\Counter(\ke)$ under $\ET_{\PSI}$.


\mypar{Robustness of multiple counters against $\ET_{\SI}$}
While a library comprising a single counter is robust against 
$\ET_{\SI}$, the same does not hold if the library two or more counters. 
In \cref{sec:overview} we have outlined how in this scenario it is 
possible to obtain an anomaly, known as long fork, which cannot be 
replicated under $\ET_{\SER}$. 
This anomaly happens because different clients can observe increments 
over two different counters appearing in a different order. Here we prove 
that, if we strengthen the execution test from $\ET_{\PSI}$ to $\ET_{\SI}$, 
then we recover the robustness of the multiple counter library. For the 
sake of simplicity, here we assume that our library consists of only two 
counters: $\mathsf{Counters} = \Counter(\ke_1) \cup \Counter(\ke_2)$.
To this end, we need the following result for kv-stores included in $\CMs(\ET_{\SI})$, 
which is the kv-store counterpart of a very well known result for snapshot isolation 
\cite{feketeSI,SIanalysis}: 
\begin{theorem}
\label{thm:si_cycles}
Any cycle induced by the relations $\PO_{\hh}, \RF_{\hh}, \VO_{\hh}, \AD_{\hh}$ 
for $\hh \in \CMs(\ET_{\SI})$ has two adjacent $\AD_{\hh}$-edges.
\end{theorem}

Consider a kv-store $\hh \in \CMs(\ET_{\SI}, \mathsf{Counters})$. 
Because $\ET_{\SI} \subseteq \ET_{\PSI}$, each of the list of versions $\hh(\ke_1)$ and 
$\hh(\ke_2)$ must follow the same structure given for kv-stores resulting from clients 
using a single counter under $\ET_{\PSI}$. this structure embeds a total order $\dashrightarrow$ 
over transactions appearing in $\hh(\ke_1)$ and $\hh(\ke_2)$; however, because the same 
client can perform operations over two different counters, it is not the case anymore that 
the relation $\dashrightarrow$ comprises the relation $\SO_{\hh}$. In this case, 
we define a second relation $\twoheadrightarrow$ as
$\txid \twoheadrightarrow \txid'$ if $\txid \in \{\WTx(\hh(\ke_{i}, \_)\} \cup \RTx(\hh(\ke_{i}, \_))$ 
and $\txid' \in \{\WTx(\hh(\ke_{j}, \_)\} \cup \RTx(\hh(\ke_{j}, \_))$ where $i,j \in \Set{1,2} \land j \neq i$,  
and $\txid \xrightarrow{\PO} \txid'$.
Relation $\twoheadrightarrow$ tracks the session order of transactions 
performing operations on different keys. If we let $\rightarrow = (\dashrightarrow \cup \twoheadrightarrow)^{+}$, 
we now have that the relation $\rightarrow$ embeds the relation $(\PO_{\hh} \cup \RF_{\hh} \cup 
\VO_{\hh} \cup \AD_{\hh})^{+}$; furthermore, because the library $\mathsf{Counters}$ does 
not contain any operation that accesses both keys $\ke_1$ and $\ke_2$, 
and because the relation $\dashrightarrow$ is acyclic, 
any cycle in $\rightarrow$ must contain at least two edges from the relation $\twoheadrightarrow$. 
In \cref{app:robustness} we show that in fact the existence of such a cycle implies the 
existence of a cycle in $\rightarrow$ of the form $\txid \dashrightarrow \txid_{a} \twoheadrightarrow 
\txid_{b} \dashrightarrow \txid_{c} \twoheadrightarrow \txid$. However, this scenario cannot 
happen in $\hh$, because otherwise we would have a cycle in the relation $(\PO_{\hh} \cup \RF_{\hh} 
\cup \VO_{\hh} \cup \AD_{\hh})^{+}$ with no adjacent $\AD_{\hh}$-edges (recall that an edge 
labelled as $\twoheadrightarrow$ can only  represent two transactions related by $\PO_{\hh}$, 
thus contradicting \cref{thm:si_cycles}). It follows that the relation $\rightarrow$ is irreflexive, 
and so is $(\PO_{\hh} \cup \RF_{\hh} \cup \VO_{\hh} \cup \AD_{\hh})^+$.

\subsection{Verifying Database Implementations}
\label{sec:verify-impl}
%\sx{
%    Short intro why it is good to use our models
%
%    What are cops and then clock-si.
%    how we verify
%}
Our representation of database state as kv-stores and client views closely matches the representation of database state in many well-known implementations~\cite{??}.
As such, when verifying such implementations, our state-based formalisms is better-suited than the existing graph-based formalisms of dependency graphs and abstract executions. 
In centralised databases, the state of the centralised server corresponds to a kv-store,
and the local snapshots that transactions operate on are extracted from our views.  
In distributed databases, each replica state corresponds to a view. 
Moreover, since most distributed databases are eventual consistent, 
\ie all replicas eventually agree on the database state,
replica states can be collectively encoded as a kv-store.
We verify the correctness of two database implementations in the literature,
COPS~\cite{Lloyd:2011:DSE:2043556.2043593} and Clock-SI~\cite{Du:2013:CSI:2553409.2553434}.

\mypar{COPS}
COPS is a fully replicated database: each replica contains all keys, but their associated values may be out of date.
Database clients operate on a single replica; 
synchronisation between replicas ensures that each replica is in a consistent (albeit out-of-date) state.
The COPS API follows the multiple-readers-single-writer paradigm: 
at any given time, the database can be accessed by either multiple read-only concurrent transactions, or a single writing transaction. 
As such, all versions (on all keys) are totally ordered. 
To ensure causal consistency, each version $\ver$ records a \emph{dependency set}, written $\func{dep}{\ver}$,
tracking the versions on which $\ver$ depends.
A client maintains a context tracking the versions that have been either fetched from, or committed to, other replicas.
%
%When running a read-only transaction, 
%the replica returns a list of versions,  $\vilist = \ver^{1}_{\ke_1}, \dots \ver^{n}_{\ke_n}$,
%such that each $\ver^i_\ke \in \vilist$ is greater than or equal than those in the dependency of $\vilist$.
%That is, $\for{\ke} \for{\ver, \ver_\ke^i \in \vilist} \for{\ver_\ke^j \in \func{dep}{\ver}} i \geq j$. 
%
%%%%%To read multiple keys in a transaction, the replica returns a list of versions \( \vilist = \ver^{i_1}_{\ke_1}, \dots \ver^{i_n}_{\ke_n} \) 
%%%%%that are either equal or greater than any versions in the dependencies,
%%%%%\ie \( \fora{\ke, \ver, \ver^{i}_{\ke}, \ver^{j}_{\ke}} \ver \in \vilist \land \ver^{i}_{\ke} \in \vilist \land \ver^{j}_{\ke} \in \func{dep}{\ver} \implies i \geq j \).
%
%After running a writing transaction, in order to commit a new version to the replica, the client must provide its context. 
%A version is accepted by the replica only once all versions from the dependency have been made known to the same replica,
%otherwise it is put in the pending list.
%
We encode the COPS replicas as a kv-store, and encode client contexts as views.  
%We encode kv-store that includes all versions from all replicas, at any given time.
%A client context then converts to a view on the kv-store, 
%\ie if a version in the context then it is in the view.
We show that the COPS implementation is causally consistent in that it is sound with respect to the $\CMs(\ET_\CC)$
specification, where $\ET_\CC$ is the causal consistency execution test in \cref{fig:execution_tests}.
%We show that the views before and after any COPS transaction,
%satisfy the execution tests for causal consistency in \cref{fig:execution.tests}.
The COPS implementation and our soundness proof are given in \cref{sec:cops}.

\mypar{Clock-SI}
Clock-SI is a \emph{sharded} database implementation for snapshot isolation (SI),
where different shards host disjoint fragments of keys.
As with the original definition of SI, Clock-SI uses timestamps to maintain different versions. 
The clocks on different shards may not agree; however, the difference is assumed to be bounded.
Each key keeps a history of versions, where each version comprises a value and the commit timestamp.
Each transaction $\txid$ is assigned to a designated shard, known as the $\txid$ \emph{coordinator}. 
When $\txid$ starts, it obtains a snapshot and records the snapshot timestamp at its coordinator shard.
Transaction $\txid$ may then read from shards other than its coordinator, so long as the current timestamp at those shards are greater than the recorded snapshot time. 
Once $\txid$ completes, it may commit if  no transaction with a conflicting write has committed since the snapshot time.
%
We encode the shards collectively as a kv-store. 
Each snapshot timestamp is encoded as a view, contains all versions committed before that timestamp.
We show that Clock-SI is sound with respect to the $\CMs(\ET_\SI)$
specification, where $\ET_\SI$ is the snapshot isolation execution test in \cref{fig:execution_tests}.
%We show that the views before and after any COPS transaction,
%satisfy the execution tests for causal consistency in \cref{fig:execution.tests}.
The Clock-SI implementation and our soundness proof are given in \cref{sec:clock-si}.
