\section{Applications}
\label{sec:applications}

We showcase applications of our operational semantics by proving the
robustness of transactional libraries (\cref{sec:program-analysis})
and verifying database protocols
 (\cref{sec:verify-impl}).

\subsection{Program Analysis}
\label{sec:program-analysis}
%Consider a simple 
a transactional library, $L =
\Set{\ptrans{\trans}_{i}}_{i \in I}$
%, which 
provides  a set of transactions  used by  library clients for accessing  the
kv-store\footnote{The choice of modelling each operation of a library
  just  as a transaction is only a 
matter of convenience. The definition of library can be easily extended to contain operations that involve multiple transactions.}. 
For instance, the set of operations of the counter library on key $\key$ in \cref{sec:overview} is $\Counter(\key) = \Set{\ctrinc(\key), \ctrread(\key)}$.
A program $\prog$ is a \emph{client} of library $L$ if  the only transactional calls in $\prog$ are those to operations of $L$.  
A transactional library $L$ is \emph{robust} against an execution test
$\ET$ if the set of kv-stores obtained under $\ET$ using 
clients of  $L$, written $\CMs(\ET, L)$, is included in
$\CMs(\ET_{\SER})$. 

%Checking the robustness of an application against an execution test $\ET$ amounts to proving the serialisability of all the kv-stores that the 
%application can produce under $\ET$: this property is equivalent to check that the dependency graphs associated with such kv-stores 
%are acyclic~\cite{adya}:
\begin{theorem}
\label{thm:serialisable_nocycle}
For all kv-stores $\mkvs$, $\mkvs \in \CMs(\ET_{\SER})$ iff $(\SO \cup \WR_{\mkvs} 
\cup \WW_{\mkvs} \cup \RW_{\mkvs})^{+}$ is irreflexive.
\end{theorem}
This result is an adaptation of a well-known result on
dependency graphs~\cite{adya}: $\mkvs \in \CMs(\ET_{\SER})$ if and
only if its associated dependency graph is acyclic. 
\pg{I don't think we need this......
Our robustness proofs
%aim to \emph{prove} that kv-stores in $\CMs(\ET, L)$ have an acyclic dependency graph, but 
make no assumption on the structure of kv-stores in $\CMs(\ET, L)$; rather, we use the definition of $\ET$ to reason 
about the structure of kv-stores in $\CMs(\ET, L)$, and in particular to prove the acyclicity of the underlying 
dependency graphs. }
%Note that the acyclicity of dependency graphs in $\CMs(\ET,L)$ is a property that we \emph{prove}, using the 
%definition of the execution test $\ET$ as a hypothesis. We make no assumption on the 
%internal structure of a kv-store when proving the robustness of a library $L$, other than the fact that it is included
%$\CMs(\ET, L)$.
%To prove the robustness of $L$ against $\ET$, for an arbitrary a kv-store $\mkvs$, we 
%\begin{enumerate*}
%	\item identify a property of $\mkvs$ that remains \emph{invariant} when running any client program of $L$ on $\mkvs$; and 
%	\item show that the invariant implies the irreflexivity of $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^{+}$.
%\end{enumerate*}
%for all client programs $\prog$ of library $L$, the set of 
%kv-stores obtained by running $\prog$ under $\ET$ are included in the set of kv-stores obtained by running $\prog$ under $\ET_{\SER}$.
%As an application of our theory, we show how we can prove the robustness of simple transactional libraries. 
%In the following, we write $\CMs(\ET, L)$ for the set of kv-stores obtained from running a client program $\prog$ of $L$. 
Using this result, we prove the robustness of a single counter against $\ET_{\PSI}$ and
the robustness of  multiple counters against $\ET_{\SI}$; recall
from~\cref{sec:overview} that the robustness
of multiple counters against $\ET_{\PSI}$ does not hold.  Previous
work on checking
robustness~\cite{giovanni_concur16,SIanalysis,laws,sureshConcur} use
static-analysis techniques that cannot be extended to include
sessions.  
%As far as we are aware, 
We believe that we give the first robustness proofs
that take sessions into account.



\subsubsection{Robustness of a Single Counter against $\ET_{\PSI}$}
\input{prog_analysis_kv_store}
Pick an arbitrary key $\key$ and a kv-store $\mkvs \in \CMs(\ET_{\PSI}, \mathsf{Counter}(\key))$
with $\Counter(\key) {=} \Set{\ctrinc(\key), \ctrread(\key)}$.
Clients write to  $\key$ by calling $\ctrinc(\key)$ which first
looks up a value of $k$ and then updates a value to $k$.
Since $\ET_{\PSI}$ enforces write conflict freedom (\(\UA\)), we have 
% in all $\mkvs \in \CMs(\ET_{\PSI}, \mathsf{Counter})$, we have:
$\fora{\txid, i > 0} \txid {=} \wtOf(\mkvs(\key, i)) \implies \txid \in \rsOf(\mkvs(\key, i{-}1))$. 
Because $\ET_{\PSI}$ satisfies monotonic reads ($\ET_{\PSI} \subseteq \ET_{\MR}$),
the order in which clients observe the versions of $\key$ by calling $\ctrread(\key)$
is consistent with the order of the index of such versions in
$\mkvs(\key)$: this yields to kv-stores in $\CMs(\ET_{\PSI}, \mathsf{Counter}(\key)$ 
to have the canonical structure of \cref{fig:prog_analysis}, defined below: 

\vspace{-7pt}
{%
\displaymathfont
\[%
\begin{aligned}
	\mkvs(\key) & = (0, \txid_{0}, \txidset^{\mathsf{}}_{0} \cup \Set{\txid^{\mathsf{}}_1}) 
	\lcat (1, \txid^{\mathsf{}}_{1}, \txidset^{\mathsf{}}_{1} \cup \Set{\txid^{\mathsf{}}_2}) 
	\lcat \cdots \lcat (n-1, \txid^{\mathsf{}}_{n-1}, \txidset^{\mathsf{}}_{n-1} \cup \Set{\txid^{\mathsf{}}_n})
	\lcat (n, \txid^{\mathsf{}}_n, \txidset^{\mathsf{}}_{n})
\end{aligned}%
\]
}%
%
\noindent where $\{\txid^{\mathsf{}}_{i}\}_{i=1}^{n}$ and $\bigcup_{i=0}^{n} \txidset^{\mathsf{}}_{i}$ 
are disjoint sets of transactions calling $\ctrinc(\key)$ and
$\ctrread(\key)$ respectively.
%is the set of transactions calling $\ctrinc(\key)$, 
%and $\bigcup_{i=0}^{n} \txidset^{\mathsf{r}}_{i}$ is the set of transactions calling $\ctrread(\key)$. 

We define a relation $\dashrightarrow$ between
the transactions in $\mkvs$ as the smallest transitive relation that 
satisfies the following: 
\begin{enumerate*}
	\item $\txid^{\mathsf{}}_{i} 
	\dashrightarrow \txid$ if $\txid \in \txidset^{\mathsf{}}_{i}$;  
	%or $\txid {=} \txid^{\mathsf{}}_{i+1}$; 
	\item $\txid \dashrightarrow \txid'$ 
	for some $\txid \in \txidset^{\mathsf{}}_{i}$,
	if $\txid' {=} \txid^{\mathsf{}}_{i+1}$
	or $\txid' \in \txidset^{\mathsf{}}_{i} \land \txid \toEDGE{\SO} \txid'$. 
\end{enumerate*}
\noindent The relation $\dashrightarrow$ is depicted in \cref{fig:prog_analysis}.
%
Note that $\dashrightarrow$ yields a total order over the transactions in $\mkvs$, 
and includes $\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs}$. 
As such, $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^+$ is irreflexive, 
ensuring the robustness of $\Counter(\key)$ against $\ET_{\PSI}$.


Recall from \cref{sec:overview} that 
under $\ET_{\PSI}$ clients can observe 
increments of different counters in different order, 
known as a long fork \cref{fig:cp-disallowed}. that is 
not allowed by $\ET_{\SER}$. 
%for two or more counters we can 
%observe the long fork anomaly allowed by $\ET_{\PSI}$.
%disallowed under serialisability ($\ET_{\SER}$). 
Thus, multiple counters are not robust against $\ET_{\PSI}$. 
The long fork cannot be replicated by $\ET_{\SI}$.
%The long fork anomaly arises because clients can observe increments 
%of different counters in a different order.
%This anomaly does not arise under $\SI$. 

\sx{check the following}
\subsubsection{Robustness against $\ET_{\WSI}$}
\sx{strictly no blind write, \SI also works for sure, etc.}
Many examples \cite{.......} in the literatures that are robust against Snapshot Isolation \( \SI \),
turn out also robust against Weak Snapshot Isolation \( \WSI \).
Those examples usually interact with databases via transactions that 
are either read-only, or read and update any keys they touch.
We call the latter as \emph{strict no blind write}.
Such patterns are captured by the following \( \WSI\)-safe definition.

\begin{definition}[\(\WSI\)-safe]
    \label{def:main-body-wsi-safe}
    A key-value store \( \mkvs \) is \(\WSI\) safe if it is 
    reachable from executing an program \( \prog \) from an initial configuration \( \conf_0 \),
    that is, \( \conf_0, \prog \toPROG{}_{\ET_\WSI} (\mkvs, \vienv), \prog' \),
    and satisfies the following properties:
    \begin{align}
         & \fora{\txid,\key, \key',i,j,k} ( \txid \in \rsOf[\mkvs(\key,i)] \implies \txid \neq \wtOf[\mkvs(\key,i)] ) \implies \txid \neq \wtOf[\mkvs(\key',k)] \label{equ:main-wsi-safe-read-only} \\
         & \fora{\txid,\key,i} \txid \neq \txid_0 \land \txid = \wtOf[\mkvs(\key,i)] \implies \exsts{j} \txid \in \rsOf[\mkvs(\key,j)] \label{equ:main-wsi-safe-write-must-read} \\
         & \fora{\txid,\key,\key',i, j} \txid \neq \txid_0 \land \txid = \wtOf[\mkvs(\key,i)] \land \exsts{k} \txid \in \rsOf[\mkvs(\key',j)] \implies \txid = \wtOf[\mkvs(\key',k)] \label{equ:main-wsi-safe-all-write}
    \end{align}
\end{definition}

\Cref{def:main-body-wsi-safe} captures that:
\begin{enumerate*} 
    \item a transaction \( \txid \) is either a read-only transaction (\cref{equ:main-wsi-safe-read-only}); or
    \item a transaction \( \txid \) satisfies \emph{strict no blind write}: 
        \( \txid \) must read before write to any key, also known as \emph{no blind write} (\cref{equ:main-wsi-safe-write-must-read}) 
        and moreover if \( \txid \) has writes, \( \txid \) must write any key it read. (\cref{equ:main-wsi-safe-all-write}).
\end{enumerate*}
It is easy to see in \cref{equ:main-wsi-safe-write-must-read} that 
the version read by \( \txid \) must be the immediate predecessor of the one written by \( \txid \),
that is, \( i = j + 1 \).

\begin{theorem}[\( \WSI \) robustness]
    If a key-value store \( \mkvs \) is \(\WSI\)-safe, it is robust against \(\WSI\).
\end{theorem}

By \cref{thm:serialisable_nocycle}, 
it suffices to prove $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^{+}$ is irreflexive.
We prove it by contradiction.
Because \( \mkvs \) is reachable under \( \WSI \) henceforth \( \CC \),
any cycle must be in the form
\[
    \txid_1 \toEDGE{\rel^*} \txid_2 \toEDGE{\RW} \txid_3 \toEDGE{\rel^*} \cdots \toEDGE{\rel^*} \txid_{n-2} \toEDGE{\RW} \txid_{n-1} \toEDGE{\rel^*} \txid_n = \txid_1
\]
\noindent where \( \rel = \WR \cup \SO \cup \WW \).
By \cref{equ:main-wsi-safe-write-must-read,equ:main-wsi-safe-all-write}, 
any \( \RW \)-edge that starts from a transaction that wrote a key, can be replaced by a \( \WW \)-edge.
Moreover, \( \WW \)-edges can be replaced by \( \WR^* \)-edges, since \( \mkvs \) is reachable under \( \UA \).
Now we have a new cycle,
\[
    \txid_1 \toEDGE{{\rel'}^*} \txid'_2 \toEDGE{\RW} \txid'_3 \toEDGE{{\rel'}^+} \cdots \toEDGE{{\rel'}^+} \txid'_{m-2} \toEDGE{\RW} \txid'_{m-1} \toEDGE{{\rel'}^*} \txid'_m = \txid_n = \txid_1
\]
\noindent where \( \rel' = \WR \cup \SO \), in other words, \( \txid_1 \toEDGE{( (\WR \cup \SO); \RW^? )^* } \txid_n \).
Yet it cannot be a cycle because \( \WSI \) requires views must be closed under \( \rel_\CP \), given that \( (\WR \cup \SO); \RW^? \subseteq \rel_\CP \).

\subsubsection{Robustness of Multiple Counters against $\ET_{\WSI}$} 
A multiple counters library on a set of keys \( \codeFont{\keyset} \) is defined by:
\( \mathsf{Counters(\keyset)} \defeq \bigcup_{\codeFont{\key} \in \codeFont{\keyset} } \Counter(\codeFont{\key}) \).
The library only allows clients to read or increment a counter,
It is easy to see it is \( \WSI \) safe, therefore robust against \( \WSI \) and any stronger models such as \( \SI \).

\begin{theorem}
    Any kv-stores from multiple counter libraries \( \mathsf{Counters(\keyset)}  \) are \( \WSI \) safe.
\end{theorem}

We prove the theorem by induction on the length of traces.
Let \( conf_0 = (\mkvs_0, \vienv_0) \) be an initial configuration and \( \prog_0 \) be a program such that \( \dom(\prog_0) \subseteq \dom(\vienv_0) \).
The initial kv-store trivially satisfies \cref{equ:main-wsi-safe-all-write,equ:main-wsi-safe-read-only,equ:main-wsi-safe-write-must-read},
because the only transaction is \( \txid_0 \) that initialises all the keys.
After \( i \) steps of execution under \( \WSI \), let \( \mkvs_i \) be the resulting kv-store.
Let consider the next transaction \( \txid_{i+1} \), that may be either a \( \ctrinc(\pv{\key}) \) or a \( \ctrread(\pv{\key}) \).
If it is a \( \ctrread(\pv{\key}) \),
then the new kv-store is 
\[ \mkvs_{i+1} = \mkvs_{i}\rmto{\pv{\key}}{\mkvs_i(\pv{\key})\rmto{j}{(\val, \txid, \txidset \uplus \Set{\txid_{i+1}})}} \]
\noindent for some index \( j \) and \( \mkvs_i(\pv{\key},j) = (\val,\txid,\txidset)\).
Since \( \txid_{i+1} \) is a read-only transaction, \cref{equ:main-wsi-safe-all-write,equ:main-wsi-safe-read-only,equ:main-wsi-safe-write-must-read} immediately hold.
Otherwise, if it is a \( \ctrinc(\codeFont{\key}) \), 
the new kv-store is 
\[
    \mkvs_{i+1} = \mkvs_{i}\rmto{\pv{\key}}{( \mkvs_i(\pv{\key})\rmto{j}{(\val, \txid, \txidset \uplus \Set{\txid_{i+1}})} ) \lcat (\val+1, \txid_{i+1}, \emptyset) } 
\]
\noindent for index \( j  = \abs{\mkvs_i(\pv{\key})} \) and \( \mkvs_i(\pv{\key},j) = (\val,\txid,\txidset)\).

\subsubsection{Robustness of Banking example against $\ET_{\WSI}$}

\citet{bank-example-wsi} presented a banking example
and claimed that it is robust against  \( \SI \).
We find out that the banking example is also robust against \( \WSI \).
The example bases on relational database with three tables, account, saving and checking.
The account table maps customer names to customer IDs (\( \codeFont{Account(\underline{Name}, CustomerID )} \))
and saving and checking map customer IDs to saving balances (\( \codeFont{Saving(\underline{CustomerID}, Balance )} \)) 
and checking balances (\( \codeFont{Checking(\underline{CustomerID}, Balance )} \)) respectively.
For simplicity, we encode the saving and checking tables together as a kv-store,
but ignore the account table given that it is effectively an immutable lookup table.
In the encoding, each customer is represent as an integer \( n \)
its checking balance is associated with 
key \( n_s = 2 \times n \) and saving with \( n_c = 2 \times n + 1 \).
Assume keys are from natural numbers.
We use notation \( n_c \) for checking account of \( n \), defined by \( n_c \defeq 2 \times n \),
and \( n_s \) for saving account of \( n \) defined by \( n_s \defeq 2 \times n + 1 \).
Thus \( \Keys \defeq \bigcup_{n \in \Nat} \Set{n_c, n_s} \).
Given this encoding, If \( n \) is a customer, that is, \( (\stub, n) \in \codeFont{Account(\underline{Name}, CustomerID )} \),
then
\[ (n, \valueOf[\mkvs(n_s, \abs{\mkvs(n_s)})]) \in \codeFont{Saving(\underline{CustomerID}, Balance )} \]
\noindent and 
\[ (n, \valueOf[\mkvs(n_s, \abs{\mkvs(n_c)})]) \in \codeFont{Checking(\underline{CustomerID}, Balance )} \]
There are five types of transactions for interacting with the database.
For brevity we assume balances are integers, that is, \( \mathbb{Z} \subseteq \Val \).
\begin{align*}
    \codeFont{balance(n)} & \defeq
    \begin{transaction}
    \plookup{\pv{x}}{\pv{n}_c}; \ 
    \plookup{\pv{y}}{\pv{n}_s}; \ 
    \passign{\ret}{\pv{x}+\pv{y}}
    \end{transaction} \\
    \codeFont{depositChecking(n,v)} & \defeq
    \begin{transaction}
    \pifs{\pv{v} \geq 0} \ 
    \plookup{\pv{x}}{\pv{n}_c}; \ 
    \pmutate{\pv{n}_c}{\pv{x} + \pv{v}}; \ 
    \pife
    \end{transaction}  \\
    \codeFont{transactSaving(n,v)} & \defeq
    \begin{transaction}
    \plookup{\pv{x}}{\pv{n}_s}; \ 
    \pifs{\pv{v} + \pv{x} \geq 0} \ 
    \pmutate{\pv{n}_s}{\pv{x} + \pv{v}}; \ 
    \pife
    \end{transaction}
\end{align*}
\( \codeFont{balance(n)} \) returns customer \( n \) total balance.
\( \codeFont{depositChecking(n,v)} \) deposits \( v \) to the checking account of customer \( n \),
if \( v  \) is non-negative, otherwise the transaction does nothing.
While \( \codeFont{transactSaving(n,v)} \) allows a consumer \( n \) to deposit or withdraw money
from the saving account as long as the saving account afterwards is non-negative.
\begin{align*}
    \codeFont{amalgamate(n,n')} & \defeq
    \begin{transaction}
    \plookup{\pv{x}}{\pv{n}_s}; \ 
    \plookup{\pv{y}}{\pv{n}_c}; \ 
    \plookup{\pv{z}}{\pv{n'}_c}; \\
    \pmutate{\pv{n}_s}{0}; \ 
    \pmutate{\pv{n}_c}{0}; \ 
    \pmutate{\pv{n'}_c}{\pv{x} + \pv{y} + \pv{z}}; 
    \end{transaction} \\
    \codeFont{writeCheck(n,v)} & \defeq
    \begin{transaction}
    \plookup{\pv{x}}{\pv{n}_s}; \ 
    \plookup{\pv{y}}{\pv{n}_c}; \\
    \pifs{\pv{x} + \pv{y} < \pv{v} } \
        \pmutate{\pv{n}_c}{\pv{y} - \pv{v} - 1 }; \
    \pifm \
        \pmutate{\pv{n}_c}{\pv{y} - \pv{v} }; \ 
    \pife \\
    \pmutate{\pv{n}_s}{\pv{x}}; 
    \end{transaction} 
\end{align*}
\( \codeFont{amalgamate(n,n')} \) represents moving all funds from consumer \( n \) to
the checking account of another customer \( n'\).
Last, \( \codeFont{writeCheck(n,v)} \) updates the checking account of \( n \).
If funds, both saving and checking, from \( n \) is greater than the \( v \),
the transaction deducts \( v \) from the checking account.
If funds are not enough, the transaction further deducts one pound as penalty.
\citet{bank-example-wsi} argued that, to make this example robust against \( \SI \),
\( \codeFont{writeCheck(n,v)} \) must be strengthened by writing back the balance to the saving account 
(the last line, \(\pmutate{\pv{n}_s}{\pv{x}} \)),
even thought the saving balance is unchanged.
The bank \( \codeFont{bank} \) libraries are defined by
\[ 
    \codeFont{Bank} \defeq \Set{\codeFont{balance(n)}, \codeFont{depositChecking(n,v)}, 
    \codeFont{amalgamate(n,n')}, \\ \codeFont{writeCheck(n,v)}, \codeFont{writeCheck(n,v)} }
    [ n,n' \in \Nat \land \pv{v} \in \mathbb{Z} ] 
\]

This banking example is more complex than the previous multiple counter example,
but all the transactions are either read-only or
satisfy strict no blind write.

\begin{theorem}
    Any kv-stores from bank libraries \codeFont{Bank} are \( \WSI \) safe.
\end{theorem}

Similarly to previous multiple counter example, given a kv-store \( \mkvs_i \) that is \( \WSI \) safe,
we check the next transactions.
\(\codeFont{balance(n)} \) reads \( n_c \) and \( n_s \).
\(\codeFont{depositChecking(n,v)} \) reads and upadtes \( n_c \) if \( v \) is greater or equal than 0, and does nothing otherwise.
For the rest three possible transactions, \( \codeFont{transactSaving(n,v)}, \codeFont{amalgamate(n,n')} \) and \( \codeFont{writeCheck(n,v)}\),
they all ensures strict no blind write.

\ac{
\subsubsection{Robustness of Multiple Counters against $\ET_{\SI}$} 
%$\ET_{\PSI}$ to $\ET_{\SI}$, 
%we can analogously recover the robustness of multiple counters.
For simplicity, here we assume that the library comprises only two counters: 
$\mathsf{Counters(\key_1, \key_2)} {=} \Counter(\key_1) \cup \Counter(\key_2)$.
%We use the following result, which is the kv-store counterpart of a well-known result for SI~\cite{fekete-tods,SIanalysis}: 
%\begin{theorem}
%\label{thm:si_cycles}
%For all $\mkvs \in \CMs(\ET_{\SI})$, any cycle in $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^+$ has two adjacent $\RW_{\mkvs}$-edges.
%\end{theorem}xs
Consider a kv-store $\mkvs \in \CMs(\ET_{\SI}, \mathsf{Counters})$. 
As $\ET_{\SI} \subseteq \ET_{\PSI}$, the lists of versions of $\mkvs(\key_1)$ and $\mkvs(\key_2)$ 
must both follow the same structure described for a single counter under $\ET_{\PSI}$. 

\vspace{-7pt}
%
{\displaymathfont%
\begin{align}
\nonumber
\mkvs(\key_{1}) & = (0, \txid_{0}, \txidset^{1}_{0} \cup \Set{\txid^{1}_1}) 
	%\lcat (1, \txid^{1}_{1}, \txidset^{1}_{1} \cup \T^{1}_2}) 
	\lcat \cdots \lcat (n-1, \txid^{1}_{n-1}, \txidset^{1}_{n-1} \cup \Set{\txid^{1}_n})
	\lcat (n, \txid^{1}_n, \txidset^{1}_{n})\\
\mkvs(\key_{2}) & = (0, \txid_{0}, \txidset^{2}_{0} \cup \Set{\txid^{2}_1}) 
	%\lcat (1, \txid^{\2}_{1}, \txidset^{2}_{1} \cup \Set{\txid^{2}_2}) 
	\lcat \cdots \lcat (m-1, \txid^{2}_{m-1}, \txidset^{1}_{m-1} \cup \Set{\txid^{2}_m})
	\lcat (m, \txid^{2}_m, \txidset^{2}_{m}) \label{eq:si_counter_structure}
\end{align}
}%
Recall that this structure yields a total order $\dashrightarrow$ over transactions in $\mkvs(\key_1)$ and $\mkvs(\key_2)$, 
which embeds an acyclic relation $\WR_{\mkvs} \cup \WW_{\mkvs} \cup \RF_{\mkvs}$. 
However, since a client can now perform operations on both counters, $\dashrightarrow$ no longer comprises $\SO_{\mkvs}$. 

We define a second relation $\twoheadrightarrow$ that tracks the session order of transactions accessing different keys: 
$\txid \twoheadrightarrow \txid'$ iff $\txid \xrightarrow{\SO} \txid'$ and there exists $i,j \in \{1,2\}$ such that
$i \neq j$ and $\txid \in \Set{\wtOf(\mkvs(\key_{i}, \stub)} \cup \rsOf(\mkvs(\key_{i}, \stub)),  
\txid' \in \Set{\wtOf(\mkvs(\key_{j}, \stub))} \cup \rsOf(\mkvs(\key_{j}, \stub))$.
The combined relation $(\dashrightarrow \cup \twoheadrightarrow)$ embeds 
$(\SO_{\hh} \cup \WR_{\hh} \cup \WW_{\hh} \cup \RW_{\hh})$. We prove that the relation $(\dashrightarrow \cup \twoheadrightarrow)$ 
is acyclic: therefore, $\hh$ is serialisable. 

More specifically, we prove that any $\ET_{\SI}$-trace
%by induction on the length of a $\ET_{\SI}$-trace 
in $\CMs(\ET_{\SI}, \mathsf{Counter}(\key_1) \cup \mathsf{Counter}(\key_2))$ terminates in a configuration of the form $(\mkvs, \_)$ 
such that the relation $(\dashrightarrow \cup \twoheadrightarrow)$ over $\mkvs$ is irreflexive; the proof is by induction on the 
length of the $\ET_{\SI}$-trace. Here we only show the details of the inductive step of the proof in the most interesting case, 
that is one where a cycle in the relation $(\dashrightarrow \cup \twoheadrightarrow)$ is created because 
client $\cl_{1}$ reads a version of some key, e.g. $\key_{1}$, after accessing the other, e.g. $\key_{2}$; and the order 
of such operations seemingly contradicts the order of the versions of $\key_{1}, \key_{2}$ observed by another client 
$\cl_{2}$. As we will see shortly, this case leads to a contradiction. 

Let $\mkvs$ be the kv-store from \cref{eq:si_counter_structure}, and assume that the relation $(\dashrightarrow \cup \twoheadrightarrow)$ 
is acyclic in $\mkvs$. Suppose also that 
$(\mkvs, \vienv) \toET{\cl_{1}, (\otR, \key_{1}, \_)}[\ET_\SI] (\mkvs', \vienv')$, and the relation
$(\dashrightarrow \cup \twoheadrightarrow)$ contains a cycle in $\mkvs'$. Let $i = \max_{\leq}(\vienv(\cl_1)(\key_1))$: 
it follows that $\mkvs'$ differs from $\mkvs$ only in the set of transactions that read version $\mkvs'(\key_{1})$, 
which must contain a new transaction $\txid$ (i.e. not appearing in $\mkvs$) of the form $\txid_{\cl_{1}}^{\_}$.
We know that the relation $\dashrightarrow$ is acyclic in $\mkvs'$, so that 
any cycle in $(\dashrightarrow \cup \twoheadrightarrow)$ in $\mkvs'$ must contain at least a $\twoheadrightarrow$ 
edge. In fact, because $\twoheadrightarrow$ edges only connect transactions accessing different keys, such 
a cycle must contain at least two $\twoheadrightarrow$ edges. Without loss of generality, we can assume that 
this cycle has the form $\txid \dashrightarrow\rflx \txid' \twoheadrightarrow \txid'' \dashrightarrow\rflx \txid''' \twoheadrightarrow \txid$ 
for some $\txid', \txid'', \txid'''$. It follows that either $\txid' = \txid = \txid^{w,1}_{i+1}$, or $\txid' \in \{\txid^{(w,1)}_{j}\} \cup \T^{r,1}_{j}$ 
for some $j > i$;  $\txid' \xrightarrow{\SO} \txid''$ and there exists an index $h$ such that either $\txid'' = \txid^{w,2}_{h}$, 
or $\txid'' \in \{\txid^{w,2}_{h+1}\} \cup \T^{r,2}_{h}$; 
either $\txid''' = \txid^{w,2}_{l}$, or $\txid''' \in \{\txid^{w,2}_{l+1}\} \cup \T^{r,2}_{l}$ for some $l > h$; and $\txid''' \xrightarrow{\SO} \txid$.
Without loss of generality, we assume that $\txid \in \T^{(r,1)}_{i}$, 
$\txid' \in \T^{(r,1)}_{j}$, $\txid'' \in \T^{r,2}_{h}$ and $\txid''' \in \T^{(r,2)}_{l}$, with $j > i$, $l > h$: other cases are similar. 
Because $\txid''' \xrightarrow{\SO} \txid$, then when $\txid''' \in \T^{r,2}_{l}$ committed client $\cl_1$ included $l$ 
in the view of $\key$; it follows from $\ET_{\MR}$  
%that the index $l$ was contained in the view of client $\cl_1$, and because $\ET_{\SI}$ is included in $\ET_{\MR}$, we also have 
that $l \in \vienv(\cl_{1})(\key_{2})$. Next, we have that $\T^{(r,1)}_{j} \ni \txid' \xrightarrow{\SO} \txid'' \xrightarrow{\RW} \txid^{(w,2)}_{l}$, 
and because $l \in \vienv(\cl_{1})(\key_{2})$, it follows from $\ET_{\CP}$ (which includes $\ET_{\SI}$) that 
$j \in \vienv(\cl_{1})(\key_{1})$. But $j > i$, contradicting the fact that $i = \max_{\leq}(\vienv(\cl_1)(\key_1)$.
%Furthermore, one of these two edges should not 
%be present in $\mkvs$, because we are assuming that the relation $(\dashrightarrow \cup \twoheadrightarrow)$ is 
%acyclic in $\mkvs$. This implies that there exists an index $j = 0,\cdots, m$ such that either $\txid_{j}^{w, 2} 
%\xrightarrow{\SO} \txid$, $\txid_{j+1}^{w,2} \xrightarrow{\SO} \txid$, or $\txid_{j+1}(\cl)$.

Our proof that multiple counters are robust against $\ET_{\SI}$ makes use 
of the properties of the execution tests $\ET_{\CP}$ and $\ET_{\UA}$ individually, and in fact the same proof can 
be used to prove that multiple counters are robust against the novel execution test $\ET_{\WSI}$ 
introduced in \cref{sec:new_cm}. 
%We believe that the correctness of many applications under $\SI$ is preserved when 
%switching to the $\WSI$ consistency model.

%: as a result, 
%the kv-store $\hh$ is serialisable, which concludes the proof that multiple counters are robust against $\ET_{\SI}$
%Relation $\twoheadrightarrow$ tracks the session order of transactions performing operations on different keys. 
%Let $\rightarrow \defeq (\dashrightarrow \cup \twoheadrightarrow)^{+}$; 
%we then know that $\rightarrow$ embeds $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^{+}$.
%Furthermore, because $\mathsf{Counters}$ contains no operation that accesses both $\key_1$ and $\key_2$, and since $\dashrightarrow$ is acyclic, 
%any cycle in $\rightarrow$ contains at least two edges from $\twoheadrightarrow$. 
%In \cref{app:robustness} we show that the existence of such a cycle implies the 
%existence of a cycle in $\rightarrow$ of the form $\txid \dashrightarrow^{?} \txid_{a} \twoheadrightarrow 
%\txid_{b} \dashrightarrow^{?} \txid_{c} \twoheadrightarrow \txid$. 
%However, this cannot happen in $\mkvs$, as otherwise we would have a cycle in $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^{+}$ with no adjacent $\RW_{\mkvs}$-edges (a $\twoheadrightarrow$ edge represents two  $\SO_{\mkvs}$-related transactions, 
%thus contradicting \cref{thm:si_cycles}). 
%It then follows that $\rightarrow$ is irreflexive, and thus so is $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^+$.
}

\sx{THE FOLLOWING SECTION WILL BE CUT OUT. Keep it for now, merge some part into sec 1-2. }
\subsection{Verifying Database Protocols}
\label{sec:verify-impl}
Kv-stores and views provide a 
faithful abstraction of the state of geo-replicated and partitioned
databases, and  execution tests provide a powerful abstraction of the synchronisation mechanisms 
enforced by these databases to commit a transaction. This makes it
possible to use our 
semantics to verify the correctness of distributed database protocols. 
We  demonstrate this by showing that  the replicated database 
%Our representation of database state as kv-stores and client views closely matches the representation of database state in many implementations of 
%well-known protocols~\cite{ramp,rola,cops,wren,redblue,PSI,NMSI,gdur,clocksi,distrsi}.
%As such, when verifying such protocols, our state-based formalism is better-suited than the existing graph-based formalisms of dependency graphs and abstract executions. 
%In centralised databases, the state of the centralised server corresponds to a kv-store,
%and the local snapshots that transactions operate on are extracted from our views.  
%In distributed databases, each replica state corresponds to a view. 
%Moreover, since most distributed databases are eventually consistent, 
%\ie all replicas eventually agree on the database state,
%replica states can be collectively encoded as a kv-store.
%We verify the correctness of two database protocols:
COPS~\cite{cops} satisfies causal consistency  and the partitioned
database Clock-SI~\cite{clocksi} satisfies snapshot isolation; the
proofs are  in~\cref{sec:implementation-verification}. 

%synchronisation among replicas ensures that they are in a consistent (albeit out-of-date) state.
\mypar{COPS}
COPS is a fully replicated database where  each replica stores multiple versions of each key. 
%contains all keys.
In COPS, a version \( \ver \) on a replica contains a key, a value, a
time-stamp identifying the time when a client first requested the
replica to write the version, and a set of dependencies
$\depOf[\ver]$.  Each dependency consists of a key and a time-stamp of
the version of that key on which $\ver$ directly depends.  This
 time-stamp consists of the local, real time when a replica
first committed the version plus the replica identifier. COPS assumes
a total order among replica identifiers. Thus,  time-stamps can be
totally ordered lexicographically over pairs of real-time of
operations and replica identifiers.

The COPS API provides two operations for  clients: writing a single
key; and reading 
a set of keys atomically. Each instance of these operations is processed by a single replica. 
Each client maintains a \emph{context}, which is a set of dependencies
corresponding to the versions it observes.  
%future operations that the client performs depend from such versions.

When client $\cl$ requests to write key $\key$ to replica $r$, it
sends a message containing the value $\val$ to be written and its
context $ctx$ to $r$. It then waits for a reply from the replica. 
Upon receiving the message, $r$ produces a monotonically increasing time-stamp $t$, which it uses to install a new version $\ver = (\val, t, ctx)$ for the key $\key$. 
Note that the dependency set of $\ver$ is the context $ctx$ of the client.
%The version carries the value received, and the context received as its set of dependencies: 
It thus  depends on other versions previously observed by the client $\cl$. 
Replica $r$ then sends the time-stamp $t$ back to the client, which will incorporate the pair $(\key, t)$ in its local context: 
the client observes the write it performed. Finally, replica $r$ propagates the version written to other replicas asynchronously, 
using \emph{causal delivery}: when replica $r'$ receives a version $\ver$ from some replica $\ver$, it 
will wait to commit all its dependencies to its local state, before committing $\ver$ itself.
%This property ensures that 
The set of versions contained in the local state of each replica is closed with respect to causal dependencies.
%A COPS client interacts with a single replica at a time via COPS API,
%either single-write or multiple-read transactions.
%Replicas \( \repl \) store all versions that has been received from clients, or other replicas via synchronisation.
%Each version \( \ver \) includes a key, a value, a unique timestamp 
%assigned by the replica who initially received this version from a client,
%and a \emph{dependency set}, written by \( \depOf[\ver]\).
%This dependency set traces the versions on which $\ver$ causally depends.
%A synchronisation message with a version \( \ver \) will be received only 
%when all the versions in the dependency set have been received.
%This guarantees that for any version \( \ver \) in a replica \( \repl \), written by \( \ver \in \repl \),
%the versions on which \( \ver \) depends also are in the replica, \( \depOf[\ver] \subseteq \repl \).
%COPS assumes that all versions eventually deliver to all replicas.
%Replicas themselves are assigned with unique identifiers that are totally ordered.
%As such, all versions on all keys are totally ordered,
%which, together with eventual delivery, guarantees eventual consistency among all replicas.
%The COPS API follows the multiple-readers-single-writer paradigm: 
%at any given time, the database can be accessed by either multiple read-only concurrent transactions, or single writing transactions. 
%Each version $\ver$ records a value and a \emph{dependency set}, written $\depOf[\ver]$,
%tracking the versions on which $\ver$ causally depends.
%This causal dependency contains previous reads and writes from the same client, and their dependencies,
%that is, 
%\( \left( \left( \SO \cup \WR \right) ^{-1}\right)^{*}(\wtOf[\ver]) \subseteq \depOf[\ver] \).
%
%For a client to commit a single-write transaction, hence a new value \( \val \) of a key \( \key \),
%it sends the new value \( \val \) and more importantly the dependency set \( D \), to a replica
%in which the \( \key, \val, D \) together with a newly assigned timestamp \( \txid \), turn into a new version \( \ver \);
%then the new timestamp returns to the client.
%To construct the dependency set for the new version,
%each client maintains a \emph{client context} that tracks the versions that have been either fetched from, or committed to any replicas. 
%For a single-write transaction, the client context becomes the dependency set \( D \) of the new version \( \ver \) which ensures \( D \) contains all versions that \( \ver \) causally depends on.

When a client requests to read a set of keys \( \{\key_1, \dots,
\key_n\} \) from a  replica $r$, it sends a message 
containing the set of keys to the replica and  waits for a reply from $r$. Upon receiving the message, replica $r$ builds a causally consistent snapshot, i.e. 
a mapping from the set $\{\key_{1},\cdots, \key_{n}\}$ to values, in two rounds. 
First, $r$ fetches from its state 
%A client can read some keys \( \key_1, \dots, \key_n \) in a multiple-read transaction through requesting a replica; 
%the replica fetches 
the most recent version \( \ver_{\key_i} \) for each $i
=0,\cdots,n$. Each of these operations happens atomically. However, 
new versions may be committed at $r$ in-between the times the replica fetches the versions for the keys 
$\key_{i}$, for $0 < i < n$,  and $\key_{n}$. In particular, it may be the case that the version $\ver_{\key_{n}}$ causally depends 
on a version $\ver'_{\key_{i}}$ that is newer than $\ver_{\key_{i}}$,  where $0 < i < n$, but commits at replica $r$ 
after the version $\ver_{\key_{i}}$ is read. The set of versions read by $r$ is not causally consistent. 
To overcome this problem, the replica $r$ uses the time-stamp $t_{n}$ of the version $\ver_{\key_{n}}$ as an upper-bound, 
and it proceeds to fetch the most up-to-date version of each key $\key_{1}, \cdots, \key_{n}$ with time-stamp 
at most $t_{n}$. At the time $\ver_{\key_{n}}$ is read,  all its causal dependencies must be included in the local 
state of $r$, hence the new snapshot built by $r$ is causally consistent. The snapshot is sent  from $r$ 
to the client, together with the set of dependencies of each version
read which are 
included into the local context of the client.
% Future operations of
%the client depend frthe versions 
%the client has read.
\ac{I will leave this to myself for future reference: why the hell does COPS do this in two rounds? It looks like you can do 
this in a single round, by simply taking the time-stamp of the first version you read as an upper bound for future reads.
Update: Went to check directly on the COPS protocol, and indeed COPS really does something more - but not much more - complicated. 
The main aspect from which COPS differs from Shale's idealisation of it is that (1) reads happen concurrently, and the 
one with highest time-stamp is used to fix the bound on versions in the first round, and (2) in the second round not all keys 
are re-fetched, but only those that are really needed to recover a causally consistent snapshot.}

%one by one, between which interleaving can happen, that is, other writes and synchronisation messages might arrive.
%This means that a previously read version \( \ver_{\key_j}\) on key \( \key_j \) might be too old for a later version \( \ver_{\key_m} \) on key \( \key_m\) (\(j < m\)) whose dependency set \( \depOf[\ver_{\key_m}] \) contains a newer version \( \ver'_{\key_j} \in \depOf[\ver_{\key_m}] \) on the key \( \key_j \).
%To tackle the problem, after the first round of optimistic reads 
%fetching versions \( \ver_{\key_1}, \dots, \ver_{\key_n} \), 
%the replica computes the maximum version \( \ver'_{\key_i} \) for each key \( \key_i \) (\( 0 < i \leq n \))
%among versions for the same key that are included in any dependency sets:
%\( \ver'_{\key_i} = \max\bigcup_{0 < z \leq n }\Set{\ver}[\func{keyOf}[\ver] = \key_i \land \ver \in \depOf[\ver_{\key_z}]] \);
%afterwards, if the \( \ver'_{\key_i} \) is newer than \( \ver_{\key_i} \) 
%meaning \( \ver'_{\key_i} > \ver_{\key_i}\), 
%the replica re-fetches and returns the newer version \( \ver'_{\key_i} \) to client for the key \( \key_i \),
%otherwise it returns \( \ver_{\key_i} \).
%Once the client receiving versions for keys \( \key_1,\dots,\key_n \) respectively, it adds those versions in its context so that any future single-write transactions will have correct dependency sets.

%The dependency set is crucial for fetching causally consistent versions.
%If a transaction reads a version \( \ver \) for key \( \key \) that 
%depends on another version \( \ver' \in \depOf[\ver]\) for key \( \key' \), 
%the transaction should at least read \( \ver' \) or any version later than \( \ver' \) for the key \( \key' \).
%A single-write transaction, meanwhile, commits the new version including the dependency set.
%When a client commits a single-write transaction,
%the dependency set of the new version \( \ver \) includes the context \( ctx \) and versions the context depends on:
%\[
    %\depOf[\ver]  = ctx \cup \bigcup_{\ver' \in ctx} \depOf[\ver']
%\]

To prove that COPS satisfies causal consistency, we encode the state of the system 
(comprising the state of all replicas and clients) into a
configuration in  our operational semantics. 
Each replica stores a set of versions for each key in COPS, as well as the dependencies of 
such replicas. We can project the state of all replicas in COPS into a kv-store, 
by mapping  COPS versions stored in replicas into versions of the
kv-store. The transaction identifier of a mapped version is uniquely
determined by the time-stamp of the corresponding COPS version and 
by the identifier of the client that wrote the version. The set of reading transactions of the mapped version 
can be recovered from the time-stamps in the dependency set of the corresponding COPS version. 
% Furthermore, the 
The local context of a COPS client identifies the set of COPS versions
that the client sees.
Their mapping into kv-store versions determines a view of the client over the 
kv-store encoded from the state of COPS replicas.
%a set of dependencies, which are mapped into a set of (kv-store) versions 
%in the kv-store built from the state of COPS replicas: the local context of a client determines a view over the kv-store.

%Having encoded client-replica states in COPS into configurations, 
Next, we map  the execution of a transaction in COPS into an $\ET_{\CC}$ reduction between the configurations 
obtained by encoding the COPS system states before and after executing the transaction, respectively.
In contrast with other verification techniques \cite{framework-concur,seebelieve} that require examining the whole sequence of operations 
of a protocol to that it implements a consistency model, we only need to look at how the system evolves 
when a single transaction is executed. As for the COPS protocol, we observe 
than when a transaction is executed then 
\begin{enumerate*} 
\item the COPS client context increases, i.e. a more up-to-date view of the system is obtained for the corresponding client in the 
kv-store semantics ($\ET_{\MR}$), 
\item a COPS client always includes the time-stamp of versions it writes in its context, meaning that the 
corresponding client view in the kv-store semantics always includes the versions it has written ($\ET_{\RYW}$), 
\item the COPS client context always contains the dependencies corresponding to versions it has 
either written or read from other transactions, that is in the corresponding kv-store semantics the view of the client is always closed-down 
w.r.t the relation $\SO \cup \WR_{\mkvs}$ ($\closed[\mkvs, \vi, R_{\CC}])$.
\end{enumerate*}

%We encode the COPS replicas as a centralised COPS kv-store by
%\begin{enumerate*}
%    \item collecting versions from all replicas and 
%    \item ordering the versions for the same key via the total order among versions,
%\end{enumerate*}
%which yields a COPS kv-store \( \mkvsCOPS \) where each version records a value, a unique timestamp and a dependency set.
%Upon COPS kv-store, any replica contains partial information of the COPS kv-store, 
%and a client context can be encoded to a COPS client view, that is, a version is in the client context, if and only if it is in the view.
%A client view \( \vi = \func{viewOf}[\mkvsCOPS, ctx] \) contains the context \( ctx \) and versions that \( ctx \) depends on:
%\[
    %\func{viewOf}[\mkvsCOPS, ctx] \defeq \lambda \key \ldotp \Set{i}[\mkvsCOPS(\key,i) \in ctx] 
                            %\cup \Set{i}[\exsts{\ver} \mkvsCOPS(\key,i) \in \depOf[\ver] \land \ver \in ctx]  
%\]
%By construction, this view is closed under \( \SO \cup \WR_{\mkvsCOPS} \):
%for any \( \key, i, \txid\) such that \( i \in \vi(\key) \) and \( \txid = \wtOf[\mkvsCOPS(\key,i)]\),
%\begin{itemize}
    %\item if \( \mkvsCOPS(\key,i) \in ctx \) and \( \wtOf[\mkvsCOPS(\key',j)] \toEDGE{(\SO \cup \WR_{\mkvsCOPS})^*} \txid \) for some \( \key',j \),
        %then \( \wtOf[\mkvsCOPS(\key',j)] \in \depOf[\mkvsCOPS(\key,i)] \) so \( j \in \vi(\key') \); and
    %\item if \( \mkvsCOPS(\key,i) \in \depOf[\ver] \land \ver \in ctx \) and 
        %\( \wtOf[\mkvsCOPS(\key',j)] \toEDGE{(\SO \cup \WR_{\mkvsCOPS})^*} \txid \) for some \( \ver,\key',j \),
        %then it must be the case \( \wtOf[\mkvsCOPS(\key',j)]  \in \depOf[\ver] \) so \( j \in \vi(\key') \).
%\end{itemize}
%Therefore for any client context \( ctx \),
%the predicate \( \closed[\mkvsCOPS,\func{viewOf}[\mkvsCOPS, ctx], \left( \SO \cup \WR_{\mkvsCOPS} \right)] \) holds.

%Given the encode of COPS kv-store \( \mkvsCOPS \) and view \( \vi \), we show that every COPS step 
%of either multiple-read or single-write transaction satisfies $\ET_\CC$,
%which is defined by 
%\( \ET_\MR \cap \ET_\RYW \cap \closed[\mkvsCOPS, \vi, \left( \SO \cup \WR_{\mkvsCOPS} \right)] \) 
%in \cref{fig:execution_tests}.
%First, client contexts monotonically increase which implies \(\ET_\MR\); and 
%second, versions committed by the client will be contained in the context, 
%which implies \(\ET_\RYW \) given the fact of \(\ET_\MR\).
%Now let consider the backwards closure of \( \SO \cup \WR \), 
%especially for multiple-read transactions (because single-write transactions do not fetch any new version from a replica).
%When a client requests versions for \( \key_1, \dots, \key_n \),
%it will get versions \( \ver_{\key_1}, \dots, \ver_{\key_n}\) from a replica such that:
%\begin{centermultline}[eq:dep-set-property]
%    \fora{i, \ver} 0 < i \leq n \land \ver \in \depOf[\ver_{\key_i}]
%    \land 
%    \exsts{\key} \key = \func{keyOf}[\ver] \land \key \in \Set{\key_1, \dots, \key_n } \implies \ver < \ver_\key
%\end{centermultline}
%and those versions, which will be included in the client context and then read by the client,
%can be encoded to a view that is backwards closed with respect to \( \SO \cup \WR \) relation
%provided that \cref{eq:dep-set-property}.
%When a client commit a new version, meanwhile, 
%When a client commits a new transaction under a context \( ctx \), 
%the versions that have been either fetched from, or committed to, will be included in the context afterwards \( ctx' \).
%This means, given the kv-stores before and after committing, \( \mkvsCOPS \) and \( \mkvsCOPS' \) respectively,
%Last, any view that is constructed from a context is closed under \( \SO \cup \WR \) which implies \( \closed[\mkvsCOPS,\func{viewOf}[\mkvsCOPS, ctx], \left( \SO \cup \WR_{\mkvsCOPS} \right)] \).
Further details  and  the  proof of soundness with
respect to $\ET_\CC$  are given in \cref{sec:cops}.

\mypar{Clock-SI}
Clock-SI is a distributed protocol for partitioned key-value
stores. The set of keys  and 
their respective versions are partitioned across different machines; versions of keys are time-stamped. 
Clock-SI supports transactions with arbitrary reads and writes. 
The protocol assigns a \emph{coordinator} partition to each transaction, which    
is responsible for contacting other partitions when reading keys remotely or 
when committing the transaction. Upon starting, a transaction records 
the current time of the coordinator, which it uses as an upper bound for the time-stamp 
of versions that the transaction can read. To ensure that the snapshot built by a transaction is consistent, 
remote reads are delayed until the clock of the contacted partition catches up with the time recorded by 
the coordinator. To ensure write-conflict-freedom, Clock-SI employs a two-phase-commit protocol, a specialised 
form of consensus where all the partitions check locally for write-conflict freedom, and the transaction 
is committed only after all partitions agree to commit.

%Clock-SI is a \emph{partitioned} database protocol for snapshot isolation (SI): different partitions store versions for disjoint subsets of keys. 
%%As with the original definition of SI, 
%Clock-SI uses timestamps to maintain different versions. The values of local clocks at different partitions may disagree by a bounded amount.
%Partitions store a list of versions for each key: versions comprise a value and a commit timestamp.
%Each key keeps a history of versions, where each version comprises a value and the commit timestamp.
%
%Transactions with arbitrary read and write operations are supported in Clock-SI.
%When a client executes a transaction $\txid$, it gets assigned a partition $p$ that acts as a \emph{coordinator}. 
%Upon starting, $\txid$ records a the current time of the coordinator as a \emph{snapshot time}, which 
%it will use as an upper bound when reading versions of keys; furthermore, 
%when $\txid$ tries to read a key stored at a different partition $p'$, it must wait for the local time of 
%$p'$ to become greater than the snapshot time. Transaction $\txid$ reads a each key remotely only once; 
%subsequent reads of the same key return the value first read by $\txid$, which is stored locally.
%
%%Each transaction $\txid$ is assigned to a designated partition, known as the $\txid$ \emph{coordinator}. 
%%When $\txid$ starts, it records the snapshot timestamp as the time of the coordinator.
%%Transaction $\txid$ may then read from partitions other than its coordinator,
%%so long as the current timestamp at those partitions are greater than the recorded snapshot time. 
%%Within a transaction \( \txid\), 
%%the first read before any write for a key, fetches the version with the maximum timestamp before the snapshot time,
%%afterwards any repeat reads are local to the transaction.
%To ensure write-conflict freedom, a two-phase commit protocol is used: 
%the coordinator of transaction $\txid$ assigns a commit time-stamp to $\txid$ 
%by recording its current time. Then it sends the values of the keys $\txid$ wants to write 
%to the corresponding partitions; these updates are pending. Each partition votes 
%whether to commit or not the updates: it checks that no version of the keys 
%it attempts to write has a time-stamp greater than the snapshot time-stamp of $\txid$ 
%(i.e. no other transaction concurrently wrote to one of the keys $\txid$ wishes to write), 
%in which case it sends a \emph{free-to-commit} message to the coordinator of $\txid$. 
%If the coordinator of $\txid$ receives a free-to-commit message from all of the partitions 
%it contacted, it will broadcast to them a notification to commit the pending updates, 
%using the commit time-stamp of $\txid$ as the time-stamp for the versions to be committed.
%
%%each of which checks locally if it contains a version of such 
%%Once $\txid$ completes, it may commit if no transaction with a conflicting write has committed since the snapshot time.
%%This means there is no preceding version in the partition.
%To verify that Clock-SI correctly implements Snapshot Isolation, 
%we encode the partitions collectively as a kv-store, by collecting keys from different partitions 
%and ordering the versions for each key by the timestamps.
%Each snapshot timestamp $t$ determines a view, which contains all versions committed before $t$.
The proof that Clock-SI is sound with respect to $\ET_\SI$ is given in
\cref{sec:clock-si}.
%In \cref{sec:clock-si} we explain the protocol in detail, and we give the soundness proof.
%where $\ET_\SI = \closed(\mkvs,\vi, \rel_{\SI}(\fp)) \cap \ET_\MR \cap \ET_\RYW $ is the snapshot isolation execution test in \cref{fig:execution_tests}.
%It means given the encoded kv-store \( \mkvs \) and view \( \vi \), 
%the transaction with fingerprint \( \fp \) is allowed to commit: \( \closed[\mkvs,\vi,\rel_{\SI}(\fp)]\); and
%the new view \( \vi' \) over the new kv-store \( \mkvs' \) satisfies \( \MR \) and \( \RYW \).
%Details of the protocol and our soundness proof are given in \cref{sec:clock-si}. 
