\section{Applications}
\label{sec:applications}

We showcase the applications of our formalism by showing how we can prove the robustness of transactional libraries (\cref{sec:program-analysis}), and verifying database protocols
 (\cref{sec:verify-impl}).

\subsection{Program Analysis}
\label{sec:program-analysis}
A transactional library, $L = \Set{\ptrans{\trans}_{i}}_{i \in I}$, 
provides a set of operations through which the library clients can access the kv-store\footnote{The choice of modelling each operation of a library as a transactions is only a 
matter of convenience; the definition of library can be easily extended to contain operations that involve multiple transactions.}. 
For instance, the set of operations of the counter library on key $\key$ in \cref{sec:overview} is $\Counter(\key) = \Set{\ctrinc(\key), \ctrread(\key)}$.
A program $\prog$ is a \emph{client} of library $L$ if the only transactional calls in $\prog$ are those to library $L$ operations.  
A transactional library $L$ is \emph{robust} against an execution test $\ET$ if the set of kv-stores obtained under $\ET$ when 
clients invoke only operations from $L$, denoted as $\CMs(\ET, L)$, is included in $\CMs(\SER)$.
By re-adapting a well known result of dependency graphs to kv-stores, the latter amounts to proving that the dependency graph associated 
with a kv-store in $\CMs(\ET, L)$ is acyclic. \cite{adya}
%Checking the robustness of an application against an execution test $\ET$ amounts to proving the serialisability of all the kv-stores that the 
%application can produce under $\ET$: this property is equivalent to check that the dependency graphs associated with such kv-stores 
%are acyclic~\cite{adya}:
\begin{theorem}
\label{thm:serialisable_nocycle}
For all kv-stores $\mkvs$: $\mkvs \in \CMs(\ET_{\SER})$ iff $(\SO \cup \WR_{\mkvs} 
\cup \WW_{\mkvs} \cup \RW_{\mkvs})^{+}$ is irreflexive.
\end{theorem}
We remark here that the we \emph{prove} the acyclicity of dependency graphs in $\CMs(\ET,L)$, using the 
definition of the execution test $\ET$ as hypothesis. In this regard, we make no assumption on the 
internal structure of a kv-store when proving the robustness of a library $L$, other than the fact that it is included
$\CMs(\ET, L)$.

%To prove the robustness of $L$ against $\ET$, for an arbitrary a kv-store $\mkvs$, we 
%\begin{enumerate*}
%	\item identify a property of $\mkvs$ that remains \emph{invariant} when running any client program of $L$ on $\mkvs$; and 
%	\item show that the invariant implies the irreflexivity of $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^{+}$.
%\end{enumerate*}
%for all client programs $\prog$ of library $L$, the set of 
%kv-stores obtained by running $\prog$ under $\ET$ are included in the set of kv-stores obtained by running $\prog$ under $\ET_{\SER}$.
%As an application of our theory, we show how we can prove the robustness of simple transactional libraries. 
%In the following, we write $\CMs(\ET, L)$ for the set of kv-stores obtained from running a client program $\prog$ of $L$. 
We prove the robustness of single and multiple counters (\cref{sec:overview}) against $\ET_{\PSI}$ and $\ET_{\SI}$, respectively.
Previous techniques for checking robustness~\cite{giovanni_concur16,SIanalysis,laws,sureshConcur} 
are based on static analysis: since the session order of clients cannot be determined at compile 
time, these techniques abstract from sessions. 
To our knowledge, we give the first robustness proofs that take sessions into account.

\mypar{Robustness of a Single Counter against $\ET_{\PSI}$}
Pick an arbitrary key $\key$ and a kv-store $\mkvs \in \CMs(\ET_{\PSI}, \mathsf{Counter}(\key))$, 
with $\Counter(\key) {=} \Set{\ctrinc(\key), \ctrread(\key)}$. 
Note that clients can only write to $\key$ by calling $\ctrinc(\key)$.
As such, since $\ET_{\PSI}$ enforces write conflict freedom, we have: 
% in all $\mkvs \in \CMs(\ET_{\PSI}, \mathsf{Counter})$, we have:
$\fora{\txid, i > 0} \txid {=} \wtOf(\mkvs(\key, i)) \implies \txid \in \rsOf(\mkvs(\key, i{-}1))$. 
Furthermore, because $\ET_{\PSI}$ satisfies monotonic reads ($\ET_{\PSI} \subseteq \ET_{\MR}$),
the order in which clients observe the versions of $\key$ (by calling $\ctrread(\key)$), 
is consistent with the order of the index of such versions in $\mkvs(\key)$:
%
%
{%
\begin{align*}
	\mkvs(\key) & = (0, \txid_{0}, \txidset^{\mathsf{r}}_{0} \cup \Set{\txid^{\mathsf{w}}_1}) 
	\lcat (1, \txid^{\mathsf{w}}_{1}, \txidset^{\mathsf{r}}_{1} \cup \Set{\txid^{\mathsf{w}}_2}) 
	\lcat \cdots \lcat (n-1, \txid^{\mathsf{w}}_{n-1}, \txidset^{\mathsf{r}}_{n-1} \cup \Set{\txid^{\mathsf{w}}_n})
	\lcat (n, \txid^{\mathsf{w}}_n, \txidset^{\mathsf{r}}_{n})
\end{align*}%
}%
%
\noindent where $\{\txid^{\mathsf{w}}_{i}\}_{i=1}^{n}$ is the set of transactions calling $\ctrinc(\key)$, 
and $\bigcup_{i=0}^{n} \txidset^{\mathsf{r}}_{i}$ is the set of transactions calling $\ctrread(\key)$. 

Next, we define a relation $\dashrightarrow$ between
the transactions in $\mkvs$ as the smallest transitive relation that 
satisfies the following: 
\begin{enumerate*}
	\item $\txid^{\mathsf{w}}_{i} 
	\dashrightarrow \txid$ if $\txid \in \txidset^{\mathsf{r}}_{i}$ 
	or $\txid {=} \txid^{\mathsf{w}}_{i+1}$; 
	\item $\txid \dashrightarrow \txid'$ 
	for some $\txid \in \txidset^{\mathsf{r}}_{i}$,
	if $\txid' {=} \txid^{\mathsf{w}}_{i+1}$
	or $\txid' \in \txidset^{\mathsf{r}}_{i} \land \txid \toEDGE{\SO} \txid'$. 
\end{enumerate*}
%
Note that $\dashrightarrow$ yields a total order over the transactions in $\mkvs$, 
and includes $\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs}$. 
As such, $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^+$ is irreflexive, 
ensuring the robustness of $\Counter(\key)$ against $\ET_{\PSI}$.


\mypar{Robustness of Multiple Counters against $\ET_{\SI}$} 
Recall from \cref{sec:overview} that for the library comprising two or more counters we can 
observe the long fork anomaly disallowed under serialisability ($\ET_{\SER}$). 
As such, multiple counters are not robust against $\ET_{\PSI}$. 
The long fork anomaly arises because clients can observe increments 
of different counters in a different order.
This anomaly does not arise under $\SI$: 
in fact, multiple counters are robust against $\ET_{\SI}$. 
%$\ET_{\PSI}$ to $\ET_{\SI}$, 
%we can analogously recover the robustness of multiple counters.
For simplicity, here we assume that the library comprises only two counters: 
$\mathsf{Counters} {=} \Counter(\key_1) \cup \Counter(\key_2)$.
%We use the following result, which is the kv-store counterpart of a well-known result for SI~\cite{fekete-tods,SIanalysis}: 
%\begin{theorem}
%\label{thm:si_cycles}
%For all $\mkvs \in \CMs(\ET_{\SI})$, any cycle in $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^+$ has two adjacent $\RW_{\mkvs}$-edges.
%\end{theorem}

Consider a kv-store $\mkvs \in \CMs(\ET_{\SI}, \mathsf{Counters})$. 
As $\ET_{\SI} \subseteq \ET_{\PSI}$, the lists of versions of $\mkvs(\key_1)$ and $\mkvs(\key_2)$ 
must both follow the same structure as that described for a single counter under $\ET_{\PSI}$. 
\begin{align}
\nonumber
\mkvs(\key_{1}) & = (0, \txid_{0}, \txidset^{\mathsf{r},1}_{0} \cup \Set{\txid^{\mathsf{w},1}_1}) 
	%\lcat (1, \txid^{\mathsf{w},1}_{1}, \txidset^{\mathsf{r},1}_{1} \cup \Set{\txid^{\mathsf{w},1}_2}) 
	\lcat \cdots \lcat (n-1, \txid^{\mathsf{w},1}_{n-1}, \txidset^{\mathsf{r},1}_{n-1} \cup \Set{\txid^{\mathsf{w},1}_n})
	\lcat (n, \txid^{\mathsf{w},1}_n, \txidset^{\mathsf{r},1}_{n})\\
\mkvs(\key_{2}) & = (0, \txid_{0}, \txidset^{\mathsf{r},2}_{0} \cup \Set{\txid^{\mathsf{w},2}_1}) 
	%\lcat (1, \txid^{\mathsf{w},2}_{1}, \txidset^{\mathsf{r},2}_{1} \cup \Set{\txid^{\mathsf{w},2}_2}) 
	\lcat \cdots \lcat (m-1, \txid^{\mathsf{w},2}_{m-1}, \txidset^{\mathsf{r},1}_{m-1} \cup \Set{\txid^{\mathsf{w},2}_m})
	\lcat (m, \txid^{\mathsf{w},2}_m, \txidset^{\mathsf{r},2}_{m}) \label{eq:si_counter_structure}
\end{align}
Recall that this structure embeds a total order $\dashrightarrow$ over transactions in $\mkvs(\key_1)$ and $\mkvs(\key_2)$, 
which embeds an acyclic relation $\WR_{\mkvs} \cup \WW_{\mkvs} \cup \RF_{\mkvs}$. 
However, since a client can perform operations on both counters, $\dashrightarrow$ no longer comprises $\SO_{\mkvs}$. 

We define a second relation $\twoheadrightarrow$ that tracks the session order of transactions accessing different keys: 
$\txid \twoheadrightarrow \txid'$ iff $\txid \xrightarrow{\SO} \txid'$ and there exists $i,j \in \{1,2\}$ such that
$i \neq j$ and $\txid \in \Set{\wtOf(\mkvs(\key_{i}, \stub)} \cup \rsOf(\mkvs(\key_{i}, \stub)),  
\txid' \in \Set{\wtOf(\mkvs(\key_{j}, \stub))} \cup \rsOf(\mkvs(\key_{j}, \stub))$.
The combined relation $(\dashrightarrow \cup \twoheadrightarrow)$ embeds 
$(\SO_{\hh} \cup \WR_{\hh} \cup \WW_{\hh} \cup \RW_{\hh})$; next, we prove that the relation $(\dashrightarrow \cup \twoheadrightarrow)$ 
is acyclic, from which it follows that the kv-store $\hh$ is serialisable. More specifically, we prove that any $\ET_{\SI}$-trace
%by induction on the length of a $\ET_{\SI}$-trace 
in $\CMs(\ET_{\SI}, \mathsf{Counter}(\key_1) \cup \mathsf{Counter}(\key_2))$ terminates in a configuration of the form $(\mkvs, \_)$ 
such that the relation $(\dashrightarrow \cup \twoheadrightarrow)$ over $\mkvs$ is irreflexive; the proof is by induction on the 
length of the $\ET_{\SI}$-trace. Here we only show the details of the inductive step of the proof in the most interesting case, 
that is one where a cycle in the relation $(\dashrightarrow \cup \twoheadrightarrow)$ is created because 
client $\cl_{1}$ reads a version of some key, e.g. $\key_{1}$, after accessing the other, e.g. $\key_{2}$, and the order 
of such operations seemingly contradicts the order of the versions of $\key_{1}, \key_{2}$ observed by another client 
$\cl_{2}$: as we will see shortly, this case leads to a contradiction. 

Let $\mkvs$ be the kv-store from \cref{eq:si_counter_structure}, and assume that the relation $(\dashrightarrow \cup \twoheadrightarrow)$ 
is acyclic in $\mkvs$. Suppose also that 
$(\mkvs, \vienv) \toET{\cl_{1}, (\otR, \key_{1}, \_)}[\ET_\SI] (\mkvs', \vienv')$, and the relation
$(\dashrightarrow \cup \twoheadrightarrow)$ contains a cycle in $\mkvs'$. Let $i = \max_{\leq}(\vienv(\cl_1)(\key_1))$: 
it follows that $\mkvs'$ differs from $\mkvs$ only in the set of transactions that read version $\mkvs'(\key_{1})$, 
which must contain a new transaction $\txid$ (i.e. not appearing in $\mkvs$) of the form $\txid_{\cl_{1}}^{\_}$.
We know that the relation $\dashrightarrow$ is acyclic in $\mkvs'$, so that 
any cycle in $(\dashrightarrow \cup \twoheadrightarrow)$ in $\mkvs'$ must contain at least a $\twoheadrightarrow$ 
edge. In fact, because $\twoheadrightarrow$ edges only connect transactions accessing different keys, such 
a cycle must contain at least two $\twoheadrightarrow$ edges. Without loss of generality, we can assume that 
this cycle has the form $\txid \dashrightarrow\rflx \txid' \twoheadrightarrow \txid'' \dashrightarrow\rflx \txid''' \twoheadrightarrow \txid$ 
for some $\txid', \txid'', \txid'''$. It follows that $\txid' = \txid = \txid^{w,1}_{i+1}$, or $\txid' \in \{\txid^{(w,1)}_{j}\} \cup \T^{r,1}_{j}$ 
for some $j > i$;  $\txid' \xrightarrow{\SO} \txid''$ and there exists an index $h$ such that either $\txid'' = \txid^{w,2}_{h}$, 
or $\txid'' \in \{\txid^{w,2}_{h+1}\} \cup \T^{r,2}_{h}$; 
either $\txid''' = \txid^{w,2}_{l}$, or $\txid''' \in \{\txid^{w,2}_{l+1}\} \cup \T^{r,2}_{l}$ for some $l > h$; and $\txid''' \xrightarrow{\SO} \txid$.
Without loss of generality, we assume that $\txid \in \T^{(r,1)}_{i}$, 
$\txid' \in \T^{(r,1)}_{j}$, $\txid'' \in \T^{r,2}_{h}$ and $\txid''' \in \T^{(r,2)}_{l}$: other cases are similar. 
Because $\txid''' \xrightarrow{\SO} \txid$, then at the time $\txid'''$ committed it must have been the case 
that the index $l$ was contained in the view of client $\cl_1$, and because $\ET_{\SI}$ is included in $\ET_{\MR}$, we also have 
that $l \in \vienv(\cl_{1})(\key_{2})$. Next, we have that $\T^{(r,1)}_{j} \ni \txid' \xrightarrow{\SO} \txid'' \xrightarrow{\RW} \txid^{(w,2)}_{l}$, 
and because $l \in \vienv(\cl_{1})(\key_{2})$,the constraints places on $\ET_{\CP}$, which includes $\ET_{\SI}$,  mandate that it must be the case that 
$j \in \vienv(\cl_{1})(\key_{1})$. But $j > i$, which contradicts the fact that $i = \max_{\leq}(\vienv(\cl_1)(\key_1)$.
%Furthermore, one of these two edges should not 
%be present in $\mkvs$, because we are assuming that the relation $(\dashrightarrow \cup \twoheadrightarrow)$ is 
%acyclic in $\mkvs$. This implies that there exists an index $j = 0,\cdots, m$ such that either $\txid_{j}^{w, 2} 
%\xrightarrow{\SO} \txid$, $\txid_{j+1}^{w,2} \xrightarrow{\SO} \txid$, or $\txid_{j+1}(\cl)$.

Our proof that multiple counters are robust against $\ET_{\SI}$ make use 
of the properties of the execution tests $\ET_{\CP}$ and $\ET_{\UA}$ individually, and in fact the same proof can 
be used to prove that multiple counters are robust against the execution $\ET_{\WSI}$ 
introduced in \cref{sec:new_cm}. 
%We believe that the correctness of many applications under $\SI$ is preserved when 
%switching to the $\WSI$ consistency model.

%: as a result, 
%the kv-store $\hh$ is serialisable, which concludes the proof that multiple counters are robust against $\ET_{\SI}$
%Relation $\twoheadrightarrow$ tracks the session order of transactions performing operations on different keys. 
%Let $\rightarrow \defeq (\dashrightarrow \cup \twoheadrightarrow)^{+}$; 
%we then know that $\rightarrow$ embeds $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^{+}$.
%Furthermore, because $\mathsf{Counters}$ contains no operation that accesses both $\key_1$ and $\key_2$, and since $\dashrightarrow$ is acyclic, 
%any cycle in $\rightarrow$ contains at least two edges from $\twoheadrightarrow$. 
%In \cref{app:robustness} we show that the existence of such a cycle implies the 
%existence of a cycle in $\rightarrow$ of the form $\txid \dashrightarrow^{?} \txid_{a} \twoheadrightarrow 
%\txid_{b} \dashrightarrow^{?} \txid_{c} \twoheadrightarrow \txid$. 
%However, this cannot happen in $\mkvs$, as otherwise we would have a cycle in $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^{+}$ with no adjacent $\RW_{\mkvs}$-edges (a $\twoheadrightarrow$ edge represents two  $\SO_{\mkvs}$-related transactions, 
%thus contradicting \cref{thm:si_cycles}). 
%It then follows that $\rightarrow$ is irreflexive, and thus so is $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^+$.

\subsection{Verifying Database Protocols}
\label{sec:verify-impl}
Kv-stores represent a faithful abstraction of the state of the database both in a geo-replicated and 
partitioned setting; similarly, execution tests are a powerful abstraction of the synchronisation mechanisms 
enforced by these systems to commit a transaction. This makes it possible to employ our 
framework to verify the correctness of distributed database protocols. 
We discuss two examples:
%Our representation of database state as kv-stores and client views closely matches the representation of database state in many implementations of 
%well-known protocols~\cite{ramp,rola,cops,wren,redblue,PSI,NMSI,gdur,clocksi,distrsi}.
%As such, when verifying such protocols, our state-based formalism is better-suited than the existing graph-based formalisms of dependency graphs and abstract executions. 
%In centralised databases, the state of the centralised server corresponds to a kv-store,
%and the local snapshots that transactions operate on are extracted from our views.  
%In distributed databases, each replica state corresponds to a view. 
%Moreover, since most distributed databases are eventually consistent, 
%\ie all replicas eventually agree on the database state,
%replica states can be collectively encoded as a kv-store.
%We verify the correctness of two database protocols:
COPS~\cite{cops} and Clock-SI~\cite{clocksi}.

%synchronisation among replicas ensures that they are in a consistent (albeit out-of-date) state.
\mypar{COPS}
COPS is a fully replicated database: each replica stores multiple versions of each key. 
%contains all keys.
In COPS, versions \( \ver \) contain a key, a time-stamp identifying the logical time when the 
client first requested a replica to write the version, and a set of dependencies $\depOf[\ver]$: 
each dependency consists of a key identifier and the time-stamp of the version of that key on which $\ver$ directly depends. 
The time-stamp of a version consist of the local, real time at which a replica first included the version in its state, plus 
a replica identifier. COPS assumes a total order among replicas, and time-stamps can be totally 
ordered via the lexicographic over pairs of real-time of operations and replica identifiers.

The COPS API provide two operations to clients: writing a single key, or reading 
a set of keys atomically. Each of these operations is processed by  single replica. 
Each client maintains a \emph{context}, the set of dependencies corresponding to versions observed by  the client.  
%future operations that the client performs depend from such versions.

When a client $\cl$ requests to write a key $\key$ to a replica $r$, it sends a message containing the value to be written and its context to $r$, and 
it waits for a reply from the replica. 
Upon receiving the  message, replica $r$ produces a time-stamp for the write operation, and installs a new version for the key $\key$ using 
the received context as its set of dependencies: the version being written depends on any other version previously observed by the client $\cl$. 
The replica sends the time-stamp $t$ of the version installed back to the client, which will incorporate the pair $(\key, t)$ in its local context: 
the client observes the write it performed. Once this operation completed, replica $r$ proceeds to forward the version written to other replicas. 
COPS employs \emph{causal delivery} for propagating the version: when a replica $r'$ receives a version $\ver$ from some replica $\ver$, it 
will wait to commit all its depencies to its local state, before committing $\ver$ itself. This property ensures that the set of versions 
contained in the local state of a replica $r$ is closed down with respect to causal dependencies.
%A COPS client interacts with a single replica at a time via COPS API,
%either single-write or multiple-read transactions.
%Replicas \( \repl \) store all versions that has been received from clients, or other replicas via synchronisation.
%Each version \( \ver \) includes a key, a value, a unique timestamp 
%assigned by the replica who initially received this version from a client,
%and a \emph{dependency set}, written by \( \depOf[\ver]\).
%This dependency set traces the versions on which $\ver$ causally depends.
%A synchronisation message with a version \( \ver \) will be received only 
%when all the versions in the dependency set have been received.
%This guarantees that for any version \( \ver \) in a replica \( \repl \), written by \( \ver \in \repl \),
%the versions on which \( \ver \) depends also are in the replica, \( \depOf[\ver] \subseteq \repl \).
%COPS assumes that all versions eventually deliver to all replicas.
%Replicas themselves are assigned with unique identifiers that are totally ordered.
%As such, all versions on all keys are totally ordered,
%which, together with eventual delivery, guarantees eventual consistency among all replicas.
%The COPS API follows the multiple-readers-single-writer paradigm: 
%at any given time, the database can be accessed by either multiple read-only concurrent transactions, or single writing transactions. 
%Each version $\ver$ records a value and a \emph{dependency set}, written $\depOf[\ver]$,
%tracking the versions on which $\ver$ causally depends.
%This causal dependency contains previous reads and writes from the same client, and their dependencies,
%that is, 
%\( \left( \left( \SO \cup \WR \right) ^{-1}\right)^{*}(\wtOf[\ver]) \subseteq \depOf[\ver] \).
%
%For a client to commit a single-write transaction, hence a new value \( \val \) of a key \( \key \),
%it sends the new value \( \val \) and more importantly the dependency set \( D \), to a replica
%in which the \( \key, \val, D \) together with a newly assigned timestamp \( \txid \), turn into a new version \( \ver \);
%then the new timestamp returns to the client.
%To construct the dependency set for the new version,
%each client maintains a \emph{client context} that tracks the versions that have been either fetched from, or committed to any replicas. 
%For a single-write transaction, the client context becomes the dependency set \( D \) of the new version \( \ver \) which ensures \( D \) contains all versions that \( \ver \) causally depends on.

When a client requests to read a set of keys \( \key_1, \dots, \key_n \) to some replica $r$, it will send a message 
containing the list of keys to the replica, and will wait for a reply from $r$. Replica $r$ will then proceed to build a causally consistent snapshot, i.e. 
a mapping from the set $\{\key_{1},\cdots, \key_{n}\}$ to values, in two rounds. 
First, $r$ fetches from its state 
%A client can read some keys \( \key_1, \dots, \key_n \) in a multiple-read transaction through requesting a replica; 
%the replica fetches 
the most recent version \( \ver_{\key_i} \) per key \( \key_i \) (\( 0 < i \leq n\). Each of these operations happen atomically, and 
in particular new versions may be committed at $r$ in-between the times the replica fetches the versions for the keys 
$\key_{i}, 0 < i < n$ and $\key_{n}$: in particular, it may be the case that the version $\ver_{\key_{n}}$ causally depends 
on a version $\ver'_{\key'_{n}}$, that is more up-to-date than $\ver_{\key_{n}}$ but was committed at replica $r$ 
after the replica fetched the version $\ver_{\key_{i}}$. In other words, the set of versions read by $r$ is not causally consistent. 
To overcome this problem, the replica $r$ uses the time-stamp $t_{n}$ of the version $\ver_{\key_{n}}$ as an upper-bound, 
and it proceeds to fetch again the most up-to-date version of each key $\key_{1}, \cdots, \key_{n}$ whose time-stamp is 
less than $t_{n}$. Because at the time $\ver_{\key_{n}}$ is read, all its causal dependencies must be included in the local 
state of $r$, then it is ensured that the snapshot built by $r$ is causally consistent. Replica $r$ sends this snapshot 
to the client, together with the set of dependencies of each version included in this snapshot. These dependencies are 
then included into the local context of the client: future operations performed by the client will depend from the versions 
the client has read.
\ac{I will leave this to myself for future reference: why the hell does COPS do this in two rounds? It looks like you can do 
this in a single round, by simply taking the time-stamp of the first version you read as an upper bound for future reads.
Update: Went to check directly on the COPS protocol, and indeed COPS really does something more - but not much more - complicated. 
The main aspect from which COPS differs from Shale's idealisation of it is that in the second round not all keys 
are re-fetched, but only those that are really needed to recover a causally consistent snapshot.}

%one by one, between which interleaving can happen, that is, other writes and synchronisation messages might arrive.
%This means that a previously read version \( \ver_{\key_j}\) on key \( \key_j \) might be too old for a later version \( \ver_{\key_m} \) on key \( \key_m\) (\(j < m\)) whose dependency set \( \depOf[\ver_{\key_m}] \) contains a newer version \( \ver'_{\key_j} \in \depOf[\ver_{\key_m}] \) on the key \( \key_j \).
%To tackle the problem, after the first round of optimistic reads 
%fetching versions \( \ver_{\key_1}, \dots, \ver_{\key_n} \), 
%the replica computes the maximum version \( \ver'_{\key_i} \) for each key \( \key_i \) (\( 0 < i \leq n \))
%among versions for the same key that are included in any dependency sets:
%\( \ver'_{\key_i} = \max\bigcup_{0 < z \leq n }\Set{\ver}[\func{keyOf}[\ver] = \key_i \land \ver \in \depOf[\ver_{\key_z}]] \);
%afterwards, if the \( \ver'_{\key_i} \) is newer than \( \ver_{\key_i} \) 
%meaning \( \ver'_{\key_i} > \ver_{\key_i}\), 
%the replica re-fetches and returns the newer version \( \ver'_{\key_i} \) to client for the key \( \key_i \),
%otherwise it returns \( \ver_{\key_i} \).
%Once the client receiving versions for keys \( \key_1,\dots,\key_n \) respectively, it adds those versions in its context so that any future single-write transactions will have correct dependency sets.

%The dependency set is crucial for fetching causally consistent versions.
%If a transaction reads a version \( \ver \) for key \( \key \) that 
%depends on another version \( \ver' \in \depOf[\ver]\) for key \( \key' \), 
%the transaction should at least read \( \ver' \) or any version later than \( \ver' \) for the key \( \key' \).
%A single-write transaction, meanwhile, commits the new version including the dependency set.
%When a client commits a single-write transaction,
%the dependency set of the new version \( \ver \) includes the context \( ctx \) and versions the context depends on:
%\[
    %\depOf[\ver]  = ctx \cup \bigcup_{\ver' \in ctx} \depOf[\ver']
%\]

We encode the state of the system (comprising the state of each replica and client) into 
a configuration in the kv-store framework.
Each replica stores a set of versions for each key in COPS, as well as the dependencies of 
such replicas, thus we can project the state of all replicas in COPS into a kv-store. 
A (COPS) version stored in some replica corresponds to a version of the kv-store: 
the transaction identifier of such a version is uniquely determined by the time-stamp of the corresponding COPS version, and 
by the identifier of the client that wrote such a version. The set of reading transactions  of the kv-store version 
can be recovered from the time-stamps in the dependency set of the corresponding COPS version. 
% Furthermore, the 
The local context of a (COPS) client identifies a set of dependencies, and therefore it corresponds to a set of versions 
in the kv-store built from the state of COPS replicas: the local context of a client uniquely determines a view over the kv-store.

Having encoded client-replica states in COPS into configurations, we show 
that executing a transaction in COPS corresponds to executing a transaction in the kv-store 
semantics, which is allowed by the execution test $\ET_{\CC}$. Note that, in contrast 
with other verification techniques \cite{framework-concur,seebelieve} that require examining the whole sequence of operations 
of a protocol to determine that is implements a consistency model, we only need to look at how the system evolves 
affected when a single transaction is executed. As for the COPS protocol, we observe 
than when a transaction is executed then 
\begin{enumerate*} 
\item the COPS client context increases, i.e. a more up-to-date view of the system is obtained for the corresponding client in the 
kv-store semantics ($\ET_{\MR}$), 
\item a COPS client always includes the time-stamp of versions it writes in its context, meaning that the 
corresponding client view in the kv-store semantics always includes the versions it has written ($\ET_{\RYW}$), 
\item the COPS client context always contains the dependencies corresponding to versions it has 
either written or read from other transactions, that is in the corresponding kv-store semantics the view of the client is always closed-down 
w.r.t the relation $\SO \cup \WR_{\mkvs}$ ($\closed(\mkvs, \vi, R_{\CC})$.
\end{enumerate*}

%We encode the COPS replicas as a centralised COPS kv-store by
%\begin{enumerate*}
%    \item collecting versions from all replicas and 
%    \item ordering the versions for the same key via the total order among versions,
%\end{enumerate*}
%which yields a COPS kv-store \( \mkvsCOPS \) where each version records a value, a unique timestamp and a dependency set.
%Upon COPS kv-store, any replica contains partial information of the COPS kv-store, 
%and a client context can be encoded to a COPS client view, that is, a version is in the client context, if and only if it is in the view.
%A client view \( \vi = \func{viewOf}[\mkvsCOPS, ctx] \) contains the context \( ctx \) and versions that \( ctx \) depends on:
%\[
    %\func{viewOf}[\mkvsCOPS, ctx] \defeq \lambda \key \ldotp \Set{i}[\mkvsCOPS(\key,i) \in ctx] 
                            %\cup \Set{i}[\exsts{\ver} \mkvsCOPS(\key,i) \in \depOf[\ver] \land \ver \in ctx]  
%\]
%By construction, this view is closed under \( \SO \cup \WR_{\mkvsCOPS} \):
%for any \( \key, i, \txid\) such that \( i \in \vi(\key) \) and \( \txid = \wtOf[\mkvsCOPS(\key,i)]\),
%\begin{itemize}
    %\item if \( \mkvsCOPS(\key,i) \in ctx \) and \( \wtOf[\mkvsCOPS(\key',j)] \toEDGE{(\SO \cup \WR_{\mkvsCOPS})^*} \txid \) for some \( \key',j \),
        %then \( \wtOf[\mkvsCOPS(\key',j)] \in \depOf[\mkvsCOPS(\key,i)] \) so \( j \in \vi(\key') \); and
    %\item if \( \mkvsCOPS(\key,i) \in \depOf[\ver] \land \ver \in ctx \) and 
        %\( \wtOf[\mkvsCOPS(\key',j)] \toEDGE{(\SO \cup \WR_{\mkvsCOPS})^*} \txid \) for some \( \ver,\key',j \),
        %then it must be the case \( \wtOf[\mkvsCOPS(\key',j)]  \in \depOf[\ver] \) so \( j \in \vi(\key') \).
%\end{itemize}
%Therefore for any client context \( ctx \),
%the predicate \( \closed[\mkvsCOPS,\func{viewOf}[\mkvsCOPS, ctx], \left( \SO \cup \WR_{\mkvsCOPS} \right)] \) holds.

%Given the encode of COPS kv-store \( \mkvsCOPS \) and view \( \vi \), we show that every COPS step 
%of either multiple-read or single-write transaction satisfies $\ET_\CC$,
%which is defined by 
%\( \ET_\MR \cap \ET_\RYW \cap \closed[\mkvsCOPS, \vi, \left( \SO \cup \WR_{\mkvsCOPS} \right)] \) 
%in \cref{fig:execution_tests}.
%First, client contexts monotonically increase which implies \(\ET_\MR\); and 
%second, versions committed by the client will be contained in the context, 
%which implies \(\ET_\RYW \) given the fact of \(\ET_\MR\).
%Now let consider the backwards closure of \( \SO \cup \WR \), 
%especially for multiple-read transactions (because single-write transactions do not fetch any new version from a replica).
%When a client requests versions for \( \key_1, \dots, \key_n \),
%it will get versions \( \ver_{\key_1}, \dots, \ver_{\key_n}\) from a replica such that:
%\begin{centermultline}[eq:dep-set-property]
%    \fora{i, \ver} 0 < i \leq n \land \ver \in \depOf[\ver_{\key_i}]
%    \land 
%    \exsts{\key} \key = \func{keyOf}[\ver] \land \key \in \Set{\key_1, \dots, \key_n } \implies \ver < \ver_\key
%\end{centermultline}
%and those versions, which will be included in the client context and then read by the client,
%can be encoded to a view that is backwards closed with respect to \( \SO \cup \WR \) relation
%provided that \cref{eq:dep-set-property}.
%When a client commit a new version, meanwhile, 
%When a client commits a new transaction under a context \( ctx \), 
%the versions that have been either fetched from, or committed to, will be included in the context afterwards \( ctx' \).
%This means, given the kv-stores before and after committing, \( \mkvsCOPS \) and \( \mkvsCOPS' \) respectively,
%Last, any view that is constructed from a context is closed under \( \SO \cup \WR \) which implies \( \closed[\mkvsCOPS,\func{viewOf}[\mkvsCOPS, ctx], \left( \SO \cup \WR_{\mkvsCOPS} \right)] \).
More details about COPS protocol and our soundness proof are given in \cref{sec:cops}.

\mypar{Clock-SI}
Clock-SI is a \emph{partitioned} database protocol for snapshot isolation (SI),
where different partition host disjoint fragments of keys.
As with the original definition of SI, Clock-SI uses timestamps to maintain different versions. 
The clocks on different partitions may not agree; however, the difference is assumed to be bounded.
Each key keeps a history of versions, where each version comprises a value and the commit timestamp.
Each transaction $\txid$ is assigned to a designated partition, known as the $\txid$ \emph{coordinator}. 
When $\txid$ starts, it records the snapshot timestamp as the time of the coordinator.
Transaction $\txid$ may then read from partitions other than its coordinator,
so long as the current timestamp at those partitions are greater than the recorded snapshot time. 
Within a transaction \( \txid\), 
the first read before any write for a key, fetches the version with the maximum timestamp before the snapshot time,
afterwards any repeat reads are local to the transaction.
Once $\txid$ completes, it may commit if no transaction with a conflicting write has committed since the snapshot time.
This means there is no preceding version in the partition.
We encode the partitions collectively as a kv-store, by collecting keys from different partitions 
and ordering the versions for each key by the timestamps.
Each snapshot timestamp is encoded as a view, contains all versions committed before that timestamp.
We show that Clock-SI is sound with respect to $\ET_\SI$.
%where $\ET_\SI = \closed(\mkvs,\vi, \rel_{\SI}(\fp)) \cap \ET_\MR \cap \ET_\RYW $ is the snapshot isolation execution test in \cref{fig:execution_tests}.
%It means given the encoded kv-store \( \mkvs \) and view \( \vi \), 
%the transaction with fingerprint \( \fp \) is allowed to commit: \( \closed[\mkvs,\vi,\rel_{\SI}(\fp)]\); and
%the new view \( \vi' \) over the new kv-store \( \mkvs' \) satisfies \( \MR \) and \( \RYW \).
Details of the protocol and our soundness proof are given in \cref{sec:clock-si}. 
