\section{Applications}
\label{sec:applications}
\label{sec:program-analysis}

To demonstrate the applications of our operational semantics, 
in \cref{sec:verify-impl} we then use our formalism to verify several distributed protocols.
In \cref{sec:robustness} we use our formalism to prove the robustness of several transactional libraries.

\subsection{Application: Verifying Database Protocols}
\label{sec:verify-impl}
Kv-stores and views faithfully abstract the state of geo-replicated and partitioned
databases, and  execution tests provide a powerful abstraction of the synchronisation mechanisms  enforced by these databases when committing a transaction. This makes it
possible to use our 
semantics to verify the correctness of distributed database protocols. 
We  demonstrate this by showing that the replicated database 
COPS~\cite{cops} satisfies causal consistency and
the partitioned database Clock-SI~\cite{clocksi} satisfies snapshot isolation.
We present an intuitive account of how we verify the COPS protocol using trace refinement;
we refer the reader to \cref{sec:cops} for the full details.
In the technical appendix (\cref{sec:clock-si}) we apply the same method to verify Clock-SI.

\input{cops-graph.tex}

COPS is a fully replicated database, with each replica storing multiple versions of each key as shown in \cref{fig:cops-after-write-transaction}. 
Each COPS version \( \ver \),
\eg \( (\key_1,\val_1,(\txid_1,\repl_1), \emptyset) \) in \cref{fig:cops-after-write-transaction},
contains a key (\eg $\key_1$), a value (\eg $\val_1$), a time-stamp denoting when a client first wrote the version to the replica (\eg $(\txid_1, \repl_1)$), and a set of dependencies, written $\depOf[\ver]$ (\eg $\emptyset$). 
A time-stamp associated with a version $\ver$ is of the form $(\txid, \repl)$, where $\repl$ identifies the replica that committed $\ver$, and $\txid$ denotes the local, real time when $\repl$ committed $\ver$. 
Each dependency in $\depOf[\ver]$ comprises a key and the time-stamp of the version of that key on which $\ver$ directly depends.  
COPS assumes a total order over replica identifiers. As such, time-stamps can be
totally ordered lexicographically over time-stamps. 

The COPS API provides two operations: one for writing to a single
key; and another for atomically reading from a set of keys. 
Each call to a COPS operation is processed by a single replica. 
Each client maintains a \emph{context}, which is a set of dependencies
tracking the versions the client observes.  
We demonstrate how a client \( \cl \) interacts with a replica through the following example:
\begin{align}
    \label{equ:client-repl-1}
    \cl: \begin{transaction} \pmutate{\key_1}{\val_1}; \end{transaction} ; \ 
    \begin{transaction} \pderef{\vx}{\key_1}; \ \pderef{\vy}{\key_2}; \end{transaction}
    \tag{\textsc{cops-cl}}
\end{align}
For brevity, we assume that there are two keys, $\key_1$ and $\key_2$, and two replicas, $\repl_1$ and $\repl_2$, 
as shown in \cref{fig:initial-cops}, where $\repl_1 < \repl_2$.
Initially, client \( \cl \) connects to replica \( \repl_1 \) and initialises its local context as $ctx {=} \emptyset$.
To execute its first single-write transaction, $\cl$ requests to write $\val_1$ to $\key_1$ by sending the message $(\key_1, \val_1, ctx)$ to its associated replica $\repl_1$. 
It then awaits a reply from $\repl_1$.
Upon receiving the message, $\repl_1$ produces a monotonically increasing local time $\txid_1$, and uses it to install  a new version $\ver {=} (\key_1,\val_1, (\txid_1,\repl_1), ctx)$, as shown in \cref{fig:cops-after-write-transaction}.
Note that the dependency set of $\ver$ is the $\cl$ context ($ctx {=} \emptyset$).
Replica $\repl_1$ then sends the time-stamp $(\txid_1,\repl_1)$ back to $\cl_1$, and $\cl_1$ in turn  incorporates $(\key_1, \txid_1,\repl_1)$ in its local context; \ie 
$\cl$ observes its own write. 
Finally, $\repl_1$ propagates the written version to other replicas asynchronously by sending a \emph{synchronisation message} 
using \emph{causal delivery} as follows. 
When a replica $\repl'$ receives a version $\ver'$ from another replica $\repl$, it 
first waits for all $\ver$ dependencies to arrive at $\repl'$, and then accepts $\ver$.
As such, the set of versions contained in each replica is closed with respect to causal dependencies.
In the example above, when other replicas receive $\ver$ from $\repl_1$, they can immediately accept $\ver$ as its dependency set is empty. 
Note that replicas may accept new versions from different clients in parallel (see \cref{fig:cops-after-write-transaction}).

To execute its second multi-read transaction,
client  \( cl \) requests to read from the $\key_1, \key_2$ keys by sending the message 
\( \Set{\key_1, \key_2} \) to replica $\repl_1$ and awaits a reply.
Upon receiving this message, $\repl_1$ builds a causally consistent snapshot (a mapping from $\Set{\key_1, \key_2}$ to values) in two phases as follows. 
First, $\repl_1$ optimistically fetches the most recent versions for $\key_1$ and $\key_2$,
one at a time. 
This process may be interleaved with other writes and synchronisation messages (propagated from other replicas). 
For instance, \cref{fig:cops-request-values} depicts a scenario where \( \repl_1 \)
\begin{enumerate*}
	\item first fetches \( (\key_1,\val_1,(\txid_1,\repl_1), \emptyset) \) for $\key_1$ (highlighted); %(highlighted in \cref{fig:cops-request-values})
	\item then receives two synchronisation messages from \( \repl_2 \), 
containing versions \( ( \key_1, \val'_1, (\txid_1,\repl_2),\emptyset ) \) and \( ( \key_2, \val'_2, (t_2,\repl_2),\Set{(\key_1,\txid_1,\repl_2)} ) \); and
	\item finally fetches \( ( \key_2, \val'_2, (t_2,\repl_2),\Set{(\key_1,\txid_1,\repl_2)} ) \) for $\key_2$ (highlighted).
\end{enumerate*}
As such, the versions fetched for \( \Set{\key_1,\key_2}\) are not causally consistent: 
\( ( \key_2, \val'_2, (t_2,\repl_2),\Set{(\key_1,\txid_1,\repl_2)} ) \) depends on a $\key_1$ version with time-stamp $(\txid_1, \repl_2)$ which is bigger than that fetched for $\key_1$, namely $(\txid_1, \repl_1)$.
To remedy this, after the first phase of optimistic reads,
$\repl_1$ collects all the dependency sets and uses them as a lower-bound in the second phase
to re-fetch the most recent version (with the biggest time-stamp) of each key between the lower-bound and the first phase.
For instance, in \cref{fig:cops-request-values} replica $\repl_1$ re-fetches the newer version \( ( \key_1, \val'_1, (\txid_1,\repl_2),\emptyset ) \) for \( \key_1 \) (\cref{fig:cops-re-read-values}).
The snapshot obtained after the second phase is thus causally consistent. 
Finally, the snapshot and the dependencies of each version read are sent to the client, and subsequently added to the client context.

\input{cops-encoded.tex}

To prove that COPS satisfies causal consistency,
we show that COPS traces can be refined to causal dependency traces in our semantics.
To do this, we first define an operational semantics for COPS describing transitions over abstract states comprising a set of replicas, a set of client contexts and a program.
A transition describes either writing a version to a replica, reading a version from a replica, or a receiving synchronisation messages at a replica.
Recall that COPS supports reading from multiple versions atomically. 
This is captured by multiple read transitions in the trace, analogously divided into two phases: those of optimistic reads and those of re-fetch reads.
Moreover, these read transitions may be interleaved by other transitions. 
Note that the optimistic reads are opaque to the client\azalea{why is that?} and
thus it suffices to show that the second re-fetch phase is atomic.
To show this, we \emph{normalise} the trace by moving all re-fetch transitions to the right (essentially delaying them) so that re-fetch transitions are no longer interleaved by others.
As such, in the resulting normalised trace each transaction is executed atomically. 
Note that normalising the trace does not alter it observably in that the values read remain unchanged. 
This is because the re-fetch phase cannot read a version committed after the end of the optimistic phase.



We next show that normalised COPS traces can be refined to causal consistency traces in our semantics.
To do this, we encode the abstract COPS states above as configuration in our operational semantics (\cref{sec:model}). 
As each replica stores several COPS versions, 
we can project COPS replicas into kv-stores
by mapping COPS replicas to kv-store replicas.
The writer of a mapped version is uniquely
determined by the time-stamp of the corresponding COPS version, while
its reader set 
can be recovered by annotating read-only transactions.
For example, the COPS state in \cref{fig:cops-after-write-transaction} can be encoded as the kv-store depicted in \cref{fig:encode-mkvs}.
Similarly, as the context of a client $\cl$ identifies the set of COPS versions that $\cl$ sees, 
we can project COPS client contexts to our client views over kv-stores. 
For example, the context of \( \cl \) after committing its first single-write transaction in \eqref{equ:client-repl-1} is encoded as the client view depicted in \cref{fig:encode-view}.

We next map a normalised COPS trace to a kv-store trace such that each resulting 
kv-store transition corresponds 
to either a write operation or the sequence of re-fetch operations. 
Last, we show that every step in the kv-store trace satisfies \( \et[\CC] \).
Note that existing verification techniques \cite{framework-concur,seebelieve} require examining 
the \emph{entire} sequence of operations of a protocol to show that it implements a consistency model.
By contrast, we only need to look at how the system evolves after a \emph{single} transaction is executed.
In particular, we check the client views (obtained from COPS client contexts) over the kv-store as follows.
Intuitively, we observe that when a COPS client $\cl$ executes a transaction then:
\begin{enumerate*} 
\item the $\cl$ context grows, and thus we obtain a more up-to-date view of the associated kv-store; \ie $\vshiftname_{\MR}$ holds;
\item the $\cl$ context always includes the time-stamp of the versions written by itself, and thus the 
corresponding client view always includes the versions $\cl$ has written; \ie $\vshiftname_{\RYW}$ holds; and
\item the $\cl$ context always contains the dependencies corresponding to versions it has 
either written or read from other transactions, and thus the corresponding client view is always closed-down 
with respect to the relation $\SO \cup \WR_{\mkvs}$; \ie $\closed[\mkvs, \vi, R_{\CC}])$ holds.
\end{enumerate*}
As such, from the definition of $\CC$ in \cref{fig:execution_tests} we know that COPS satisfies causal consistency ($\CC$).
We refer the reader to \cref{sec:cops} for the full details.

\subsection{Application: Robustness of Transactional Libraries}
\label{sec:robustness}
A transactional library, $L {=} \Set{\ptrans{\trans}_{i}}_{i \in I}$,
provides a set of transactional operations which can be used by its clients to access the underlying
kv-store\footnote{For simplicity, we model each operation as a single transaction; it is straightforward to extend this to multiple transactions.}. 
For instance, the set of operations of the counter library on key $\key$ in \cref{sec:overview} is: $\Counter(\key) \defeq \Set{\ctrinc(\key), \ctrread(\key)}$.
A program $\prog$ is a \emph{client program} of $L$ if the only transactional calls in $\prog$ are to operations of $L$.  
Let $\CMs(\ET, L)$ denote the set of kv-stores obtained by running $L$ clients under $\ET$.
A library $L$ is \emph{robust} against an execution test
$\ET$ if for all clients of $L$, the kv-stores obtained under $\ET$ can also be obtained under $\SER$; 
\ie $\CMs(\ET, L) \subseteq \CMs(\SER)$.



\begin{theorem}
\label{thm:serialisable_nocycle}
A kv-store $\mkvs {\in} \CMs(\SER)$ iff $(\SO {\cup} \WR_{\mkvs} 
{\cup} \WW_{\mkvs} {\cup} \RW_{\mkvs})^{+} \cap \CodeFont{Id} = \emptyset$.% is irreflexive.
\end{theorem}
This theorem is an adaptation of a well-known result on
dependency graphs~\cite{adya} stating that $\mkvs \in \CMs(\SER)$ iff its associated dependency graph is acyclic. 
Using this theorem, we prove the robustness of a single counter against $\PSI$.
As discussed in \cref{sec:overview}, the multi-counter library is not robust against $\PSI$. 
We thus prove the robustness of the multi-counter library and the banking library of \citet{bank-example-wsi} against $\WSI$ instead. 
While previous static-analysis techniques for checking robustness \citep{giovanni_concur16,SIanalysis,laws,sureshConcur}
cannot be extended to support client sessions, 
we give the first robustness proofs that take client sessions into account.



\subsubsection{Robustness of a Single Counter against $\PSI$}
In the single-counter library $\Counter(\key)$, 
a client reads from $\key$ by calling $\ctrread(\key)$, and writes to $\key$ by calling $\ctrinc(\key)$ which first reads the value of $k$ and subsequently increments it by one.
Pick an arbitrary key $\key$ and a kv-store $\mkvs \in \CMs(\PSI, \mathsf{Counter}(\key))$.
As $\PSI$ enforces write conflict freedom (\(\UA\)), we know that if a transaction $\txid$ updates $\key$ (by calling $\ctrinc(\key)$) and writes version $\ver$ to $\key$, then it must have read the version of $\key$ immediately preceding $\ver$:
$\fora{\txid, i > 0}\!\! \txid {=} \wtOf(\mkvs(\key, i)) \implies \txid \in \rsOf(\mkvs(\key, i{-}1))$. 
Moreover, as $\PSI$ enforces monotonic reads ($\MR$),
the order in which clients observe the versions of $\key$ (by calling $\ctrread(\key)$)
is consistent with the order of versions in $\mkvs(\key)$. 
As such, the kv-stores in $\CMs(\PSI, \mathsf{Counter}(\key))$ have the canonical structure depicted in  \cref{fig:prog_analysis} and defined below, where $\lcat$ denotes list concatenation, and 
$\{\txid^{\mathsf{}}_{i}\}_{i=1}^{n}$ and $\bigcup_{i=0}^{n} \txidset^{\mathsf{}}_{i}$ 
denote disjoint sets of transactions calling $\ctrinc(\key)$ and $\ctrread(\key)$: 

{%
\displaymathfont
\[%
	\mkvs(\key) = (0, \txid_{0}, \txidset^{\mathsf{}}_{0} \cup \Set{\txid^{\mathsf{}}_1}) 
	\lcat (1, \txid^{\mathsf{}}_{1}, \txidset^{\mathsf{}}_{1} \cup \Set{\txid^{\mathsf{}}_2}) 
	\lcat \cdots \lcat (n-1, \txid^{\mathsf{}}_{n-1}, \txidset^{\mathsf{}}_{n-1} \cup \Set{\txid^{\mathsf{}}_n})
	\lcat (n, \txid^{\mathsf{}}_n, \txidset^{\mathsf{}}_{n})
\]
\normalsize
}%


\input{prog_analysis_kv_store}

We define the $\dashrightarrow$ relation depicted in \cref{fig:prog_analysis} by extending 
$\SO \cup 
\{
	(\txid_i, \txid_j) 
	\mid 
	\txid_j \in \T_i \lor 	
	(\txid_i \in \T_i \land j {=} i {+} 1)
\}$
to a strict total order (\ie is $\dashrightarrow$ irreflexive and transitive). 
Note that $\dashrightarrow$ contains $\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs}$ and thus
$(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^+$ is irreflexive; 
\ie $\Counter(\key)$ is robust against $\PSI$.

A multi-counter library on a set of keys \( \codeFont{\keyset} \) is: 
\( \mathsf{Counters(\keyset)} \defeq \bigcup_{\codeFont{\key} \in \codeFont{\keyset} } \Counter(\codeFont{\key}) \).
Recall from \cref{sec:overview} that unlike in $\SER$ and $\SI$, under $\PSI$ clients can observe 
the increments on different keys in different orders (see \cref{fig:cp-disallowed}).
As such, multiple counters are not robust against $\PSI$. 
The following result shows that 
a multi-counter library is robust against \( \WSI \) and all stronger models such as \( \SI \).

\subsubsection{Robustness Conditions against $\WSI$}
\sx{strictly no blind write, \SI also works for sure, etc.}
Several libraries in the literature that are robust against $\SI$ 
\citep{giovanni_concur16,bank-example-wsi} are also robust against $\WSI$.
The operations of these libraries all yield kv-stores that adhere to a particular pattern:% captured by the following definition.

\begin{definition}[\(\WSI\)-safe]
\label{def:main-body-wsi-safe}
    A kv-store \( \mkvs \) is \emph{\(\WSI\)-safe} if it is 
    reachable by executing a program \( \prog \) from an initial configuration \( \conf_0 \) under $\WSI$
   (\ie \( \conf_0, \prog \toPROG{}_{\ET_\WSI} (\mkvs, \stub), \stub\)), and for all $\txid, \key, i$:
   {\displaymathfont
    \begin{align}
         & \txid \in \rsOf[\mkvs(\key,i)] \land \txid \neq \wtOf[\mkvs(\key,i)]  \implies \fora{\key',j} \txid \neq \wtOf[\mkvs(\key',j)] \label{equ:main-wsi-safe-read-only} \\
         & \txid \neq \txid_0 \land \txid = \wtOf[\mkvs(\key,i)] \implies \exsts{j} \txid \in \rsOf[\mkvs(\key,j)] \label{equ:main-wsi-safe-write-must-read} \\
         & \txid \neq \txid_0 \land \txid = \wtOf[\mkvs(\key,i)] \land \exsts{k', j} \txid \in \rsOf[\mkvs(\key',j)] \implies \txid = \wtOf[\mkvs(\key',j)] \label{equ:main-wsi-safe-all-write}
    \end{align}
    \normalsize
    }
\end{definition}

This definition states that a kv-store $\mkvs$ is \WSI-safe if for each transaction $\txid$: 
\begin{enumerate*} 
    \item if $\txid$ reads from $\key$ without writing to it then $\txid$ must be a read-only transaction \eqref{equ:main-wsi-safe-read-only}; 
    \item if \( \txid \) writes to $\key$, then it must also read from it \eqref{equ:main-wsi-safe-write-must-read}, a property known as \emph{strictly-no-blind writes}; and
	\item  if \( \txid \) writes to $\key$, then it must also write to all keys it reads \eqref{equ:main-wsi-safe-all-write}.
\end{enumerate*}
It is straightforward to see that the version $j$ read by \( \txid \) in \eqref{equ:main-wsi-safe-write-must-read} must be written immediately before the version $i$ written by \( \txid \), \ie \( i {=} j + 1 \).

\begin{theorem}[\( \WSI \) robustness]
 \label{thm:main-wsi-robust}
    Any \(\WSI\)-safe kv-store \( \mkvs \) is robust against \(\WSI\).   
\end{theorem}

\noindent From \cref{thm:serialisable_nocycle} it suffices to prove that $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^{+}$ is irreflexive.
We proceed by contradiction and assume that there exists $\txid_1$ such that $\txid_1 \toEDGE{(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^{+}} \txid_1$. 
Since \( \mkvs \) is reachable under \( \WSI \) and thus also reachable under \( \CC \),
this cycle is of the form:

{\displaymathfont
\[
    \txid_1 \toEDGE{\rel^*} \txid_2 \toEDGE{\RW} \txid_3 \toEDGE{\rel^*} \cdots \toEDGE{\rel^*} \txid_{n-2} \toEDGE{\RW} \txid_{n-1} \toEDGE{\rel^*} \txid_n = \txid_1
\]
\normalsize}

\noindent where \( \rel \defeq \WR \cup \SO \cup \WW \).
From \cref{equ:main-wsi-safe-write-must-read,equ:main-wsi-safe-all-write} we know that 
an \( \RW \) edge from a writing transaction can be replaced by a \( \WW \) edge.
Moreover, \( \WW \) edges can be replaced by \( \WR^* \) edges since \( \mkvs \) is reachable under \( \UA \).
We thus have:

{\displaymathfont
\[
    \txid_1 \toEDGE{{\rel'}^*} \txid'_2 \toEDGE{\RW} \txid'_3 \toEDGE{{\rel'}^+} \cdots \toEDGE{{\rel'}^+} \txid'_{m-2} \toEDGE{\RW} \txid'_{m-1} \toEDGE{{\rel'}^*} \txid'_m = \txid_n = \txid_1
\]
\normalsize}

\noindent where \( \rel' \defeq \WR \cup \SO \).
That is, \( \txid_1 \toEDGE{( \rel'; \RW^? )^* } \txid_n \).
This however leads to a contradiction as \( \rel'; \RW^? \subseteq \rel_\CP \) and 
\( \WSI \) requires views to be closed under \( \rel[\CP] \) (see \cref{fig:execution_tests}). 

%\subsubsection{Robustness of Multiple Counters against $\WSI$} 
%\label{sec:multi-counter-robust}
%A multi-counter library on a set of keys \( \codeFont{\keyset} \) is: 
%\( \mathsf{Counters(\keyset)} \defeq \bigcup_{\codeFont{\key} \in \codeFont{\keyset} } \Counter(\codeFont{\key}) \).
%We next show that a multi-counter library is \( \WSI \)-safe, and is therefore robust against \( \WSI \) and all stronger models such as \( \SI \).

%\begin{theorem}
  %A multi-counter library \( \mathsf{Counters(\keyset)}  \) is robust against \( \WSI \).
%\end{theorem}

%It is sufficient to show that a kv-store obtained by executing arbitrary transactional calls from the library are \( \WSI \)-safe.
%We proceed by induction on the length of traces.
%Let \( \conf_0 = (\mkvs_0, \vienv_0) \) be an initial configuration and \( \prog_0 \) be a program such that \( \dom(\prog_0) \subseteq \dom(\vienv_0) \).
%The initial kv-store trivially satisfies \eqref{equ:main-wsi-safe-read-only}, \eqref{equ:main-wsi-safe-write-must-read} and \eqref{equ:main-wsi-safe-all-write} above. 
%Let \( \mkvs_i \) be the resulting kv-store after \( i \) steps of execution under \( \WSI \).
%The next transaction \( \txid_{i+1} \) may then be a call to either \( \ctrinc(\pv{\key}) \) or \( \ctrread(\pv{\key}) \).
%If \( \txid_{i+1} \) is a \( \ctrread(\pv{\key}) \) call,
%then the resulting kv-store is: 
%{\displaymathfont
%\[ 
	%\mkvs_{i+1} = \mkvs_{i}\rmto{\pv{\key}}{\mkvs_i(\pv{\key})\rmto{j}{(\val, \txid, \txidset \uplus \Set{\txid_{i+1}})}} 
%\]
%\normalsize}
%%
%for some \( j \) and \( \mkvs_i(\pv{\key},j) {=} (\val,\txid,\txidset)\).
%Since \( \txid_{i+1} \) is a read-only transaction,
%then  \eqref{equ:main-wsi-safe-read-only}, \eqref{equ:main-wsi-safe-write-must-read} and \eqref{equ:main-wsi-safe-all-write} immediately hold.
%On the other hand, if \( \txid_{i+1} \) is an \( \ctrinc(\codeFont{\key}) \) call, 
%then the resulting kv-store is: 
%{\displaymathfont
%\[
    %\mkvs_{i+1} = \mkvs_{i}\rmto{\pv{\key}}{( \mkvs_i(\pv{\key})\rmto{j}{(\val, \txid, \txidset \uplus \Set{\txid_{i+1}})} ) \lcat (\val+1, \txid_{i+1}, \emptyset) } 
%\]
%\normalsize}
%where \( j  {=} \abs{\mkvs_i(\pv{\key})} \) and \( \mkvs_i(\pv{\key},j) {=} (\val,\txid,\txidset)\).
%As \( \txid_{i+1} \) reads the latest version of \( \pv{\key} \) and writes a new version to \( \pv{\key} \),
%the new kv-store \( \mkvs_{i+1} \) satisfies \eqref{equ:main-wsi-safe-read-only}, \eqref{equ:main-wsi-safe-write-must-read} and \eqref{equ:main-wsi-safe-all-write}.

\subsubsection{Robustness of a Banking Library against $\WSI$}

\citet{bank-example-wsi} present a banking library
which is robust against  \( \SI \).
Here, we show that this library is also robust against \( \WSI \).
The banking example is based on relational databases and has three tables: account, saving and checking.
The account table maps customer names to customer IDs (\( \codeFont{Account(\underline{Name}, CID )} \)); 
the saving table maps customer IDs to their saving balances (\( \codeFont{Saving(\underline{CID}, Balance )} \)); and
the checking table maps customer IDs to their checking balances (\( \codeFont{Checking(\underline{CID}, Balance )} \)).

For simplicity, we encode the saving and checking tables as a kv-store,
and forgo the account table as it is an immutable lookup table.
We model a customer ID as an integer \( n \in \mathbb{N}\), and assume that balances are integer values. 
We then define the key associated with customer $n$ in the checking table as 
$n_c \defeq 2 n$; 
and define the key associated with $n$ in the saving table as 
$n_s \defeq 2n {+} 1$. 
That is, \( \Keys \defeq \bigcup_{n \in \Nat} \Set{n_c, n_s} \).
Moreover, if \( n \) identifies a customer, \ie $(\stub, n) \in \codeFont{Account(\underline{Name}, CID )}$,
then:

{
\displaymathfont
\begin{align*}
	(n, \valueOf[\mkvs(n_s, \abs{\mkvs(n_s)} - 1)]) \in \codeFont{Saving(\underline{CID}, Balance )} 
	\\ (n, \valueOf[\mkvs(n_s, \abs{\mkvs(n_c)} - 1)]) \in \codeFont{Checking(\underline{CID}, Balance )}
\end{align*}
%
\normalsize
}

The banking library provides five transactional operations:% for accessing the database:

{
\displaymathfont
\begin{align*}
    \codeFont{balance(n)} & \defeq
    \begin{transaction}
    \plookup{\pv{x}}{\pv{n}_c}; \ 
    \plookup{\pv{y}}{\pv{n}_s}; \ 
    \passign{\ret}{\pv{x}+\pv{y}}
    \end{transaction} \\
    \codeFont{depositChecking(n,v)} & \defeq
    \begin{transaction}
    \pifs{\pv{v} \geq 0} \ 
    \plookup{\pv{x}}{\pv{n}_c}; \ 
    \pmutate{\pv{n}_c}{\pv{x} + \pv{v}}; \ 
    \pife
    \end{transaction}  \\
    \codeFont{transactSaving(n,v)} & \defeq
    \begin{transaction}
    \plookup{\pv{x}}{\pv{n}_s}; \ 
    \pifs{\pv{v} + \pv{x} \geq 0} \ 
    \pmutate{\pv{n}_s}{\pv{x} + \pv{v}}; \ 
    \pife
    \end{transaction} \\
%
	 \codeFont{amalgamate(n,n')} & \defeq
    \begin{transaction}
    \plookup{\pv{x}}{\pv{n}_s}; \ 
    \plookup{\pv{y}}{\pv{n}_c}; \ 
    \plookup{\pv{z}}{\pv{n'}_c}; \\
    \pmutate{\pv{n}_s}{0}; \ 
    \pmutate{\pv{n}_c}{0}; \ 
    \pmutate{\pv{n'}_c}{\pv{x} + \pv{y} + \pv{z}}; 
    \end{transaction} \\
    \codeFont{writeCheck(n,v)} & \defeq
    \begin{transaction}
    \plookup{\pv{x}}{\pv{n}_s}; \ 
    \plookup{\pv{y}}{\pv{n}_c}; \\
    \pifs{\pv{x} + \pv{y} < \pv{v} } \
        \pmutate{\pv{n}_c}{\pv{y} - \pv{v} - 1 }; \ \} \\
    \CodeFont{else} \{
        \pmutate{\pv{n}_c}{\pv{y} - \pv{v} };  \
    \pife \ 
    \pmutate{\pv{n}_s}{\pv{x}}; 
    \end{transaction}     
\end{align*}
%
\normalsize
}

The \( \codeFont{balance(n)} \) operation returns the total balance of customer \codeFont{n} in  \( \ret \).
The \( \codeFont{depositChecking(n,v)} \) operation deposits \codeFont{v} to the checking account of customer \codeFont{n} when \codeFont{v} is non-negative; otherwise the checking account remains unchanged.
When $\codeFont{v} \geq 0$,  \( \codeFont{transactSaving(n,v)} \) deposits \codeFont{v} to the saving account of \codeFont{n}.
When $\codeFont{v} < 0$, \( \codeFont{transactSaving(n,v)} \) withdraws \codeFont{v} from the saving account of \codeFont{n} only if the resulting balance is non-negative; otherwise the saving account remains unchanged.
The \( \codeFont{amalgamate(n,n')} \) operation moves the combined checking and saving funds of consumer \codeFont{n} to the checking account of customer $\codeFont{n}'$.
Lastly, \( \codeFont{writeCheck(n,v)} \) cashes a cheque of customer \codeFont{n} in the amount  \codeFont{v} by deducting \codeFont{v} from its checking account.
If \codeFont{n} does not hold sufficient funds (\ie the combined checking and saving balance is less than \codeFont{v}), customer \codeFont{n} is penalised by deducting one additional pound. 
%
\citet{bank-example-wsi} argue that to make the banking library robust against \( \SI \),
the \( \codeFont{writeCheck(n,v)} \) operation must be strengthened by writing back the balance to the saving account 
(via \(\pmutate{\pv{n}_s}{\pv{x}} \)),
even though the saving balance is unchanged.

The banking library is more complex than the multi-counter library discussed in \cref{sec:multi-counter-robust}.
Nevertheless, all banking transactions are either read-only or
satisfy the strictly-no-blind-writes property; \ie the banking library is \WSI-safe.
As such, we can prove its robustness against $\WSI$ in a similar fashion to that of the multi-counter library.
More concretely, given a \( \WSI \)-safe kv-store \( \mkvs\),
we show that the kv-store resulting from executing a banking operation on \( \mkvs \) remains \WSI-safe. 

As \(\codeFont{balance(n)} \) is read-only, it immediately satisfies \eqref{equ:main-wsi-safe-read-only}--\eqref{equ:main-wsi-safe-all-write}.
When $\codeFont{v} \geq 0$, then \(\codeFont{depositChecking(n,v)} \) both reads and writes \( n_c \), and thus preserves  
\eqref{equ:main-wsi-safe-read-only}--\eqref{equ:main-wsi-safe-all-write}.
When $\codeFont{v} < 0$, then  \(\codeFont{depositChecking(n,v)} \) leaves the kv-store unchanged and thus \eqref{equ:main-wsi-safe-read-only}--\eqref{equ:main-wsi-safe-all-write} are trivially preserved.
Lastly, the
\( \codeFont{transactSaving(n,v)}, \allowbreak \codeFont{amalgamate(n,n')} \) and \( \codeFont{writeCheck(n,v)}\) operations
always read and write the keys they access, thus satisfying \eqref{equ:main-wsi-safe-read-only}--\eqref{equ:main-wsi-safe-all-write}.



%\subsubsection{Clock-SI}
%Clock-SI is a distributed protocol for partitioned key-value
%stores. The set of keys  and 
%their respective versions are partitioned across different machines; versions of keys are time-stamped. 
%Clock-SI supports transactions with arbitrary reads and writes. 
%The protocol assigns a \emph{coordinator} partition to each transaction, which    
%is responsible for contacting other partitions when reading keys remotely or 
%when committing the transaction. Upon starting, a transaction records 
%the current time of the coordinator, which it uses as an upper bound for the time-stamp 
%of versions that the transaction can read. To ensure that the snapshot built by a transaction is consistent, 
%remote reads are delayed until the clock of the contacted partition catches up with the time recorded by 
%the coordinator. To ensure write-conflict-freedom, Clock-SI employs a two-phase-commit protocol, a specialised 
%form of consensus where all the partitions check locally for write-conflict freedom, and the transaction 
%is committed only after all partitions agree to commit.
%The proof that Clock-SI is sound with respect to $\ET_\SI$ is given in
%\cref{sec:clock-si}.
