\section{Applications}
\label{sec:applications}
\label{sec:program-analysis}

To show the applications of our operational semantics, 
we use it to verify several distributed protocols \!(\cref{sec:verify-impl})\! and
prove the invariants of transactional libraries \!(\cref{sec:robustness}).

\subsection{Application: Verifying Database Protocols}
\label{sec:verify-impl}
Kv-stores and views faithfully abstract the state of geo-replicated and partitioned
databases, and execution tests provide a powerful abstraction of the synchronisation mechanisms 
enforced by these databases when committing a transaction. 
This makes it possible to use our 
semantics to verify the correctness of distributed database protocols. 
We demonstrate this by showing that the replicated database,
COPS \cite{cops}, satisfies causal consistency.
We refer the reader to \cref{sec:cops} for the full details.
\ifTechRepEdits%
In the technical report,
\else%
In \cref{sec:clock-si}, 
\fi
we apply the same method to verify that 
Clock-SI \cite{clocksi}, a partitioned database, satisfies snapshot isolation.

\input{cops-graph.tex}

\mypar{COPS Protocol} 
COPS is a fully replicated database, with each replica storing multiple versions of each key as shown in \cref{fig:cops-after-write-transaction}. 
Each COPS version \( \ver \)
such as \( (\key_1,\val_1,(\txid_1,\repl_1), \emptyset) \) in \cref{fig:cops-after-write-transaction},
contains a key ($\key_1$), a value ($\val_1$), a \emph{unique} time-stamp ($\txid_1, \repl_1$) denoting
when a client first wrote the version to the replica, 
and a set of dependencies ($\emptyset$), written $\depOf[\ver]$. 
The time-stamp associated with a version $\ver$ has the form $(\txid, \repl)$, where $\repl$ identifies the replica that committed $\ver$, 
and $\txid$ denotes the local time when $\repl$ committed $\ver$. 
Each dependency in $\depOf[\ver]$ comprises a key and the time-stamp of the versions on which $\ver$ directly depends.  
We define the \( \DEP \) relation, \( (\txid,\repl) {\xrightarrow{\DEP}} (\txid',\repl') \),
to denote that version \( (\txid,\repl) \) is included in the dependency set of version \( (\txid',\repl')\).
COPS assumes a total order over replica identifiers. 
As such, versions can be totally ordered lexicographically. 

The COPS API provides two operations: \begin{enumerate*}
\item \( \pcopsput(\key,\val) \) for writing to a \emph{single}
key; and \item  \( \pcopsread(\keyset) \) for atomically reading from \emph{multiple} keys. 
\end{enumerate*}
Operations from a client is processed by a single replica. 
Each client maintains a \emph{context}, which is a set of dependencies
tracking the versions the client observes.  

We demonstrate how a COPS client \( \cl \) interacts with a replica through the following example:
\(
    \prog_\CodeFont{cops-cl} \defeq \cl: \pcopsput(\key_1,\val_1) ; \ 
    \pcopsread(\List{\key_1,\key_2})
\).
For brevity, we assume that there are two keys, $\key_1$ and $\key_2$, 
and two replicas, $\repl_1$ and $\repl_2$, where $\repl_1 < \repl_2$ (\cref{fig:initial-cops}).
Initially, client \( \cl \) connects to replica \( \repl_1 \) and initialises its local context as $ctx {=} \emptyset$.
To execute its first single-write transaction, $\cl$ requests to write $\val_1$ to $\key_1$
by sending the message $(\key_1, \val_1, ctx)$ to its associated replica $\repl_1$
and awaits a reply.
Upon receiving the message, $\repl_1$ produces a monotonically increasing local time $\txid_1$, 
and uses it to install  a new version $\ver {=} (\key_1,\val_1, (\txid_1,\repl_1), ctx)$, as shown in \cref{fig:cops-after-write-transaction}.
Note that the dependency set of $\ver$ is the $\cl$ context ($ctx {=} \emptyset$).
Replica $\repl_1$ then sends the time-stamp $(\txid_1,\repl_1)$ back to $\cl_1$, and $\cl_1$ in turn  incorporates $(\key_1, \txid_1,\repl_1)$ in its local context,
\ie $\cl$ observes its own write. 
Finally, $\repl_1$ propagates the written version to other replicas \emph{asynchronously} by sending a \emph{synchronisation message} 
using \emph{causal delivery}:
when a replica $\repl'$ receives a version $\ver'$ from another replica $\repl$, 
it waits for all $\ver'$ dependencies to arrive at $\repl'$, and then accepts $\ver'$.
As such, the set of versions contained in each replica is closed with respect to the \( \DEP \) relation.
In the example above, when other replicas receive $\ver$ from $\repl_1$, they can immediately accept $\ver$ as \( \depOf[\ver]{=}\emptyset\). 
Note that replicas may accept new versions from different clients in parallel.

To execute its second multi-read transaction,
client  \( cl \) requests to read from the $\key_1, \key_2$ keys by sending the message 
\( \Set{\key_1, \key_2} \) to replica $\repl_1$ and awaits a reply.
Upon receiving this message, $\repl_1$ builds a \emph{\( \DEP \)-closed snapshot} (a mapping from $\Set{\key_1, \key_2}$ to values) in two phases as follows. 
First, $\repl_1$ \emph{optimistically reads} the most recent versions for $\key_1$ and $\key_2$,
\emph{one at a time}. 
This process may be interleaved with other writes and synchronisation messages. 
For instance, \cref{fig:cops-request-values} depicts a scenario where \( \repl_1 \):
\begin{enumerate*}
	\item first reads \( (\key_1,\val_1,(\txid_1,\repl_1), \emptyset) \) for $\key_1$ (highlighted); %(highlighted in \cref{fig:cops-request-values})
	\item then receives two synchronisation messages from \( \repl_2 \), 
containing versions \( ( \key_1, \val'_1, (\txid_1,\repl_2),\emptyset ) \) and \( ( \key_2, \val'_2, (t_2,\repl_2),\Set{(\key_1,\txid_1,\repl_2)} ) \); and
	\item finally reads \( ( \key_2, \val'_2, (t_2,\repl_2),\Set{(\key_1,\txid_1,\repl_2)} ) \) for $\key_2$ (highlighted).
\end{enumerate*}
As such, the current snapshot for \( \Set{\key_1,\key_2}\) are not \( \DEP \)-closed: 
\( ( \key_2, \val'_2, (t_2,\repl_2),\Set{(\key_1,\txid_1,\repl_2)} ) \) depends on 
a $\key_1$ version with time-stamp $(\txid_1, \repl_2)$ which is bigger than $(\txid_1, \repl_1)$ for $\key_1$.
To remedy this, after the first phase of optimistic reads,
$\repl_1$ combines (unions) all dependency sets of the versions from the first phase as a \emph{re-fetch set},
and uses it to \emph{re-fetch}
the most recent version of each key with the biggest time-stamp 
from the union of the re-fetch set and the versions from the first phase.
For instance, in \cref{fig:cops-re-read-values}, replica $\repl_1$ re-fetches 
the newer version \( ( \key_1, \val'_1, (\txid_1,\repl_2),\emptyset ) \) for \( \key_1 \).
Finally, the snapshot obtained after the second phase 
are sent to the client, and then added to the client context.
For their specific setting, Lloyd et al. \citet{cops} \emph{informally} argue that the snapshot sent to the client is causally consistent.
By contrast, we \emph{verify} the COPS protocol with our general definition of causal consistency.


\mypar{COPS Verification} 
we give an operational semantics for the COPS protocol, which allows fine-grained single reads and writes of a key
and show that COPS traces can be refined to traces in our semantics using \( \ET[\CC] \) in three steps:
\begin{enumerate*}
\item every COPS trace can be transferred to a normalised COPS trace, 
in which multiple reads of a transaction are not interleaved by other transactions; and
\item the normalised COPS trace can be refined to traces in our semantics, in which \item each step satisfies \( \ET[\CC] \).
\end{enumerate*}

The COPS Operational semantics
describes transitions over abstract states \( \copsconf \) comprising a set of replicas,
a set of client contexts and a program.
For instance, the COPS trace that produces \cref{fig:cops-request-values,fig:cops-re-read-values} is depicted in \cref{fig:cops-trace}, stating that
given client \(\cl\) and replica \( \repl_1 \),
\begin{enumerate*}
\item \( \cl \) writes version \( (\opW,\key_1, (\txid_1,\repl_1)) \) to $\repl_1$;
\item \( \cl \) starts a multi-read transaction (\( \mathtt{s} \));
\item \( \cl \) reads  \( (\opR,\key_1, (\txid_1,\repl_1)) \) from $\repl_1$;
\item \( \repl_1 \) receives synchronisation messages (\(\mathtt{sync}\));
\item \( \cl \) reads  \( (\opR,\key_2, (\txid_2,\repl_2)) \) from $\repl_2$;
\item \( \cl \) enters the second phase of the multi-read transaction (\(\mathtt{p}\));
\item an arbitrary step \( \lb \) interferes;
\item \( \cl \) re-fetches the version \( (\opR,\key_1, (\txid_1,\repl_2)) \) from \( \repl_2 \) and puts the version in the snapshot;
\item an arbitrary step \( \lb' \) interferes;
\item \( \cl \) puts the version \( (\opR,\key_2, (\txid_2,\repl_2)) \) in the snapshot;
\item \( \cl \) reads the values in the snapshot and commit the multi-read transaction (\(\mathtt{e}\)).
\end{enumerate*}

\input{cops-trace.tex}

Recall that a multi-read transaction does not executed atomically in the replica,
which is captured by multiple read transitions in the trace.
For example, the \( \lb\) and \( \lb' \) steps in \cref{fig:cops-trace}
interleave the multi-read transaction from \( \cl \).
Note that the optimistic reads are not observable to the client and
thus it suffices to show that the reads from second re-fetch phase are atomic.
To show this, we \emph{normalise} the trace as follows. 
For any multi-read transaction, 
we move all reads from the re-fetch phase to the right towards the return step \( \mathtt{e}\),
so that these reads are no longer interleaved by others.
An example of a normalised trace is given in \cref{fig:cops-normalise}.
For any multi-read transaction,
the re-fetch phase can only read a version committed before the \( \mathtt{p}\) step.
For example, in \cref{fig:cops-trace} (top)
the multi-read transaction from \( \cl \) can only read versions in \( \copsconf \) and before.
As such, normalising traces does not alter the returned versions of transactions.
After normalisation, transactions in the resulting trace can be seen as if executed atomically. 

We next show that normalised COPS traces can be refined to traces in our semantics.
To do this, we encode the abstract COPS states \(\copsconf \) as configurations
in our operational semantics (\cref{fig:encode-mkvs}). 
We map all COPS replicas to a single kv-store.
The writer of a mapped version is uniquely
determined by the time-stamp of the corresponding COPS version, 
while its reader set 
can be recovered by annotating read-only transactions in the traces such as \( \txidrd \) in \cref{fig:encode-mkvs}.
For example, the COPS state in \cref{fig:cops-after-write-transaction}
can be encoded as the kv-store depicted in \cref{fig:encode-mkvs}.
Similarly, as the context of a client $\cl$ identifies the set of COPS versions that $\cl$ sees, 
we can project COPS client contexts to our client views over kv-stores. 
For example, the contexts of \( \cl \) 
before and after committing its second multi-read transaction in \( \prog_{\CodeFont{COPS}} \) 
is encoded as the client view depicted in \cref{fig:encode-view}.

We finally show that every step in the kv-store trace satisfies \( \et[\CC] \).
Note that existing verification techniques \cite{framework-concur,seebelieve} require examining 
the \emph{entire} sequence of operations of a protocol to show that it implements a consistency model.
By contrast, we only need to look at how the state evolves after a \emph{single} transaction is executed.
In particular, we check the client views over the kv-store.
Intuitively, we observe that when a COPS client $\cl$ executes a transaction then:
\begin{enumerate*} 
\item the $\cl$ context grows, and thus we obtain a more up-to-date view of the associated kv-store; \ie $\vshiftname_{\MR}$ holds;
\item the $\cl$ context always includes the time-stamp of the versions written by itself, and thus the 
corresponding client view always includes the versions $\cl$ has written; \ie $\vshiftname_{\RYW}$ holds; and
\item the $\cl$ context is always closed to the relation \( \DEP \), 
which contains the relation $\SO \cup \WR_{\mkvs}$; \ie $\closed[\mkvs, \vi, \rel[\CC]])$ holds.
\end{enumerate*}
We have thus demonstrated that COPS satisfies causal consistency; 
we refer the reader to \cref{sec:cops} for the full details.

\subsection{Application: Invariant Properties of Transactional Libraries}
\label{sec:robustness}
\label{sec:invariant-client-programs}

A transactional library provides 
a set of transactional operations which can be used by its clients to access the underlying kv-store.
For instance, the counter library on key $\key$ in \cref{sec:overview} is
$\Counter(\key) \defeq \Set{\ctrinc(\key), \ctrread(\key)}$.
Our operational semantics enables us to prove invariant properties of kv-stores, such as:
\begin{enumerate*}
\item the robustness of the single
counter library discussed above against \(\PSI\);
\item the robustness of a multi-counter library and the banking library of \citet{bank-example-wsi} against \( \SI \),
which satisfy a particular pattern that guarantees robustness against 
our new proposed model \(\WSI\) and any stronger model such as \(\SI\); and
\item the correctness of a lock paradigm under \( \UA \), even though it is not robust.
\end{enumerate*}

\mypar{Robustness of a Single Counter against $\PSI$}

A library $L$ is \emph{robust} against an execution test $\ET$,
if for all client programs \( \prog \) of $L$, 
the kv-stores \( \kvs \) obtained under $\ET$ can also be obtained under $\SER$:
that is, for any reachable kv-store \( \kvs \) such that
\( \ToProg{\kvs_0 | \vienv_0 | \clenv | \prog | \stub | * -> \kvs | \stub | \stub | \stub }\),
then \( \kvs {\in} \CMs(\SER) \).

\SpaceAboveDef
\begin{theorem}
\label{thm:serialisable_nocycle}
A kv-store $\mkvs {\in} \CMs(\SER)$ iff $(\SO {\cup} \WR_{\mkvs} 
{\cup} \WW_{\mkvs} {\cup} \RW_{\mkvs})^{+} \cap \CodeFont{Id} = \emptyset$.
\end{theorem}
\SpaceBelowDef

\Cref{thm:serialisable_nocycle} states that any kv-stores in trace under serialisability must contain no cycle, and vice versa.
While previous static-analysis techniques for checking robustness \citep{giovanni_concur16,SIanalysis,laws,sureshConcur}
cannot be extended to support client sessions, 
we give the first robustness proofs that take client sessions into account.

In the single-counter library, $\Counter(\key)$, 
a client reads from $\key$ by calling $\ctrread(\key)$, and writes to $\key$ by calling $\ctrinc(\key)$ 
that first reads the value of $k$ and subsequently increments it by one.
As $\PSI$ enforces write-conflict freedom (\(\UA\)),
we know that if a transaction $\txid$ updates $\key$ (by calling $\ctrinc(\key)$) and writes version $\ver$ to $\key$, 
then it must have read the version of $\key$ immediately preceding $\ver$:
$\fora{\txid, i > 0}\!\! \txid {=} \wtOf(\mkvs(\key, i)) \implies \txid \in \rsOf(\mkvs(\key, i{-}1))$. 
Moreover, as $\PSI$ enforces monotonic reads ($\MR$),
the order in which clients observe the versions of $\key$ (by calling $\ctrread(\key)$)
is consistent with the order of versions in $\mkvs(\key)$. 
As such, the invariant depicted as below always holds, where  
$\{\txid^{\CodeFont{}}_{i}\}_{i=1}^{n}$ and $\bigcup_{i=0}^{n} \txidset^{\CodeFont{}}_{i}$ 
denote disjoint sets of transactions calling $\ctrinc(\key)$ and $\ctrread(\key)$, respectively:
%
\begin{center}
\begin{tabular}{@{} c @{\quad}| c @{} }
{%
\displaymathfont
\(%
\begin{multlined}
    \\[-40pt]
    (0, \txid_{0}, \txidset_{0} \cup \Set{\txid_1}) 
	\lcat (1, \txid_{1}, \txidset_{1} \cup \Set{\txid_2}) \lcat \cdots 
    \\ \lcat (n{-}1, \txid_{n{-}1}, \txidset_{n{-}1} \cup \Set{\txid_n})
	\lcat (n, \txid_n, \txidset_{n}) 
\end{multlined}
\)%
\normalsize
}%
%
& 
%
\scalebox{.6}{%
\begin{tikzpicture}%
\KVMapping{x}{ \key }{ %
     /0/\txidinit/\Set{\txid_1} \uplus \txidset_0
    , /1/\txid_1/\Set{\txid_2} \uplus \txidset_1
    , /\cdots/\cdots/\cdots
	, /n-1/\txid_{n-1}/\Set{\txid_{n}} \uplus \txidset_{n-1}
	, /n/\txid_{n}/\txidset_{n}
};

\path[->,dashed,thick]  (Writerx1) edge[bend left=30] (Readersx1)
                        (Readersx1) edge[bend left=30] (Writerx2)
                        (Writerx2) edge[bend left=30] (Readersx2)
                        (Readersx2) edge[bend left=30] (Writerx3) 
                        (Writerx3.east) edge[bend left=30] (Readersx3.east)
                        (Readersx3.east) edge[bend left=30] (Writerx4) 
                        (Writerx4) edge[bend left=30] (Readersx4)
                        (Readersx4) edge[bend left=30] (Writerx5) 
                        (Writerx5.east) edge[bend left=30] (Readersx5.east);
\draw[->,dashed,thick]  ([xshift=-3pt]Readersx1.south) to[out=270, in=180] ([yshift=-15pt]Readersx1.south) 
                    to[out=0, in=270] ([xshift=3pt]Readersx1.south);
\draw[->,dashed,thick]  ([xshift=-3pt]Readersx2.south) to[out=270, in=180] ([yshift=-15pt]Readersx2.south) 
                    to[out=0, in=270] ([xshift=3pt]Readersx2.south);
\draw[->,dashed,thick]  ([xshift=-3pt]Readersx3.south) to[out=270, in=180] ([yshift=-15pt]Readersx3.south) 
                    to[out=0, in=270] ([xshift=3pt]Readersx3.south);
\draw[->,dashed,thick]  ([xshift=-3pt]Readersx4.south) to[out=270, in=180] ([yshift=-15pt]Readersx4.south) 
                    to[out=0, in=270] ([xshift=3pt]Readersx4.south);
\draw[->,dashed,thick]  ([xshift=-3pt]Readersx5.south) to[out=270, in=180] ([yshift=-15pt]Readersx5.south) 
                    to[out=0, in=270] ([xshift=3pt]Readersx5.south);
\end{tikzpicture}%
}

\end{tabular}
\end{center}

\noindent
We define the $\dashrightarrow$ relation depicted above is defined by extending relation
$ \rel \defeq \SO \cup 
\{
	(\txid, \txid') 
	\mid 
    \Exists{i}
    \left( 
        \txid = \txid_i
        \allowbreak \land  (\txid' = \txid_{i+1} \lor \txid' \in \txidset_i)
    \right)
    \allowbreak \lor 
    \left(
	\txid \in \txidset_i 
    \allowbreak \land
    \txid' = \txid_{i+1}
    \right)
\}$
to a strict total order (\ie an irreflexive and transitive relation). 
Note that $\dashrightarrow$ contains $\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs}$ and thus
$(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^+$ is irreflexive; 
\ie $\Counter(\key)$ is robust against $\PSI$.

A multi-counter library on a set of keys \( \keyset \) is
\( \mathsf{Counters}(\keyset) \defeq \bigcup_{\key \in \keyset } \Counter(\key) \).
Recall from \cref{sec:overview} that unlike in $\SER$ and $\SI$, under $\PSI$ clients can observe 
the increments on different keys in different orders (see \cref{fig:cp-disallowed}).
As such, the multi-counter library is not robust against $\PSI$. 

The following result shows that 
the multi-counter library and banking library from \citet{bank-example-wsi} are robust against \( \SI \).
We show that these two libraries satisfy a pattern, named \emph{\( \WSI \)-safe},
which guarantees the robustness against \( \WSI \) 
and hence \( \SI \).
To show \( \WSI \)-safe inducing robustness,
we use two specific acyclic results on kv-stores.

\mypar{Acyclic results on kv-stores}
We prove two general acyclic properties on kv-stores, which
can be seen as invariant properties.
First, any reachable kv-store \( \kvs\) under \( \et[\top] \) does not contains cycle of the relation \( (\SO {\cup} \WR_{\mkvs}) \),
where \( \et[\top] \) is the most permissive execution test defined in \cref{def:cm}.
Then, we show any reachable kv-store \( \kvs\) under \( \et[\CP] \) does not contains cycle of the relation \( ((\SO {\cup} \WR_{\mkvs}); \RW_{\mkvs}^{-1})\).                  

\SpaceAboveDef
\begin{theorem}
\label{thm:acyclic-cc}
Any kv-store \( \kvs \in \CMs(\et[\top]) \) satisfies \( (\SO {\cup} \WR_{\mkvs})^{+} \cap \CodeFont{Id} = \emptyset \).
\end{theorem}
\SpaceBelowDef

By the definition of \( \CMs \) defined in \cref{def:cm},
any kv-store \( \kvs \in \CMs(\et[\top]) \) must be reachable with a given program.
This means that \cref{thm:acyclic-cc} can be seen as an invariant property.
We prove it by induction on the length of a trace.
For the base case, the initial kv-store \( \kvs_0 \) trivially contains no cycle.
For the inductive case, 
because any local computation step does rely on kv-store,
let specifically focus on the case where the last step is a transaction step of the form:
\( \ToProg{\kvs | \vienv | \clenv | \prog | \lbTrans{\vi,\fp} -> \kvs' | \vienv' | \clenv' | \prog' } \),
where \( \kvs \) contains no cycle of the relation \( (\SO {\cup} \WR_{\mkvs}) \) by the inductive hypothesis.
We prove \( \kvs' \) also has no cycle by contradiction.
Let \( \txid \) be the new transaction in \( \kvs' \).
Assume there is cycle in \( \kvs' \), which must involve in \( \txid \):
that is:
\(
\ToEdge{\txid | \rel -> \txid_1 | \rel -> \cdots | \rel -> \txid_n | \rel -> \txid}, 
\)
where \( \rel = \SO {\cup} \WR_{\mkvs'} \), and \( \txid_1 \) to \( \txid_n \) are distinct transactions.
Consider \( \ToEdge{\txid | \SO {\cup} \WR_{\mkvs'} -> \txid_1} \).
Because \( \txid \) is the last transaction and \( \txid \notin \kvs\),
it cannot be \( \ToEdge{\txid | \SO -> \txid_1} \).
All versions written by \( \txid \) have empty reader sets.
Thus, it cannot be \( \ToEdge{\txid | \WR_{\mkvs'} -> \txid_1} \).
This leads to a contradiction.
Therefore, the new kv-store \( \kvs' \) satisfies \( (\SO {\cup} \WR_{\mkvs'})^{+} \cap \CodeFont{Id} = \emptyset \).

\SpaceAboveDef
\begin{theorem}
\label{thm:acyclic-cp}
Any kv-store \( \kvs \in \CMs(\et[\CP]) \) satisfies \( ((\SO {\cup} \WR_{\mkvs}) ; \RW_{\kvs}^? )^{+}  \cap \CodeFont{Id} = \emptyset \).
\end{theorem}
\SpaceBelowDef

\Cref{thm:acyclic-cp} can be proven in the similar way as that of \cref{thm:acyclic-cc}.
For inductive case, 
consider 
\( \ToProg{\kvs | \vienv | \clenv | \prog | \lbTrans{\vi,\fp} -> \kvs' | \vienv' | \clenv' | \prog' } \),
where \( \kvs \) contains no cycle of the relation \( ((\SO {\cup} \WR_{\mkvs}) ; \RW_{\kvs}^? )^{+} \) 
by the inductive hypothesis.
Assume there is a cycle in \( \kvs' \), which must include the new transaction \( \txid \).
There are two possible cycles.
This first one is of the form
\(
\ToEdge{\txid | \rel -> \txid_1 | \rel -> \cdots | \rel -> \txid_n | \rel -> \txid}, 
\)
where \( \rel = (\SO {\cup} \WR_{\mkvs'}) ; \RW_{\kvs'}^?  \), and \( \txid_1 \) to \( \txid_n \) are distinct transactions.
This cycle cannot exist because \( \txid \) is the last transaction in \( \kvs' \).
The second one is of the form
\(
\ToEdge{ \txid_1 | \rel -> \cdots | \rel -> \txid_n | (\SO {\cup} \WR_{\mkvs'}) -> \txid | \RW_{\kvs'} -> \txid_1} .
\)
However by \( \et[\CP] \), the view \( \vi \) must contains all effect of \( \txid_1 \),
which means \(\ToEdge{ \txid | \RW_{\kvs'} -> \txid_1 } \) cannot happen.


\mypar{Robustness Conditions against $\WSI$}
Many libraries \citep{snapshot-isolation-robust-tool,giovanni_concur16,bank-example-wsi} 
yield kv-stores that have a particular pattern that guarantees robustness against \( \WSI \):

\SpaceAboveDef
\begin{definition}[\(\WSI\)-safe]
\label{def:main-body-wsi-safe}
A kv-store \( \mkvs \) is \emph{\(\WSI\)-safe}, if it is 
reachable by executing a program \( \prog \) % from an initial configuration \( \conf_0 \) 
under $\WSI$,
\ie \( \conf_0, \prog \toPROG{}_{\ET_\WSI} (\mkvs, \stub), \stub\), and for all $\txid, \key, i,i'$:

\SpaceAboveMath
\begin{align}
     & \txid \in \rsOf[\mkvs(\key,i)] \land \txid \neq \wtOf[\mkvs(\key,i')]  \implies \fora{\key',j} \txid \neq \wtOf[\mkvs(\key',j)] , \label{equ:main-wsi-safe-read-only} \\
     & \txid \neq \txid_0 \land \txid = \wtOf[\mkvs(\key,i)] \implies \exsts{j} \txid \in \rsOf[\mkvs(\key,j)] , \label{equ:main-wsi-safe-write-must-read} \\
     & \txid \neq \txid_0 \land \txid = \wtOf[\mkvs(\key,i)] \land \exsts{k',j,j'} \txid \in \rsOf[\mkvs(\key',j)] \implies \txid = \wtOf[\mkvs(\key',j')] . \label{equ:main-wsi-safe-all-write}
\end{align}
\SpaceBelowMath

\end{definition}
\SpaceBelowDef

This definition states that a kv-store $\mkvs$ is \(\WSI\)-safe if for each transaction $\txid$: 
\begin{enumerate*} 
\item if $\txid$ read but does not write to $\key$, then $\txid$ must be a read-only transaction \eqref{equ:main-wsi-safe-read-only}; 
\item if \( \txid \) writes to $\key$, then it must also read from it \eqref{equ:main-wsi-safe-write-must-read}, a property known as \emph{no-blind writes}; and
\item if \( \txid \) writes to $\key$, then it must also write to all keys it reads \eqref{equ:main-wsi-safe-all-write}.
\end{enumerate*}
It is straightforward to see that the version $j$ read by \( \txid \) in \eqref{equ:main-wsi-safe-write-must-read} must be written immediately before the version $i$ written by \( \txid \), \ie \( i {=} j + 1 \).

\SpaceAboveDef
\begin{theorem}[\( \WSI \) robustness]
 \label{thm:main-wsi-robust}
    Any \(\WSI\)-safe kv-store \( \mkvs \) is robust against \(\WSI\).   
\end{theorem}
\SpaceBelowDef

\input{acyclic-fig}

\noindent From \cref{thm:serialisable_nocycle} it suffices to prove that $(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^{+}$ is acyclic.
We proceed by contradiction.
Assume that there exists $\txid_1$ such that $\txid_1 \toEDGE{(\SO \cup \WR_{\mkvs} \cup \WW_{\mkvs} \cup \RW_{\mkvs})^{+}} \txid_1$. 
By \cref{thm:acyclic-cc}, \( (\SO \cup \WR_{\mkvs})^{+} \) is acyclic.
Because of no no-blind-writes in \eqref{equ:main-wsi-safe-write-must-read} and \( \UA \),
any \( \WW_{\mkvs}(\key)\) edge on a key \( \key \) can be replace by \( \WR_{\mkvs}^{+}(\key) ) \), 
illustrated by \cref{fig:wr-replace-ww}.
Therefore, \( (\SO \cup \WR_{\mkvs})^{+} \cup \WW_{\kvs}\) is acyclic.
Hence, any cycle must of the form:
\(
    \txid_1 \toEDGE{\rel^*} \txid_2 \toEDGE{\RW} \txid_3 \toEDGE{\rel^*} \cdots \toEDGE{\rel^*} \txid_{n-2} \toEDGE{\RW} \txid_{n-1} \toEDGE{\rel^*} \txid_n = \txid_1
\),
where \( \rel \defeq \WR \cup \SO \cup \WW \).
By \eqref{equ:main-wsi-safe-all-write} we know that 
an \( \RW_{\mkvs}(\key_1) \) edge on a key \( \key_1 \) starting from 
a writing transaction \( \txid \) can be replaced by a \( \WW \) edge,
illustrated by \cref{fig:ww-replace-rw}.
Note that \( \txid \) might not write to a different key \( \key_2 \).
However, by the \( \RW_{\mkvs}(\key_1) \) edge, \( \txid \) reads \( \key_1 \),
and by \eqref{equ:main-wsi-safe-all-write}, it must also write to \( \key_1 \).
Moreover, we replace any new \( \WW \) edges by \( \WR^+ \).
We thus have
\(
    \txid_1 \toEDGE{{\rel'}^*} \txid'_2 \toEDGE{\RW} \txid'_3 \toEDGE{{\rel'}^+} \cdots \toEDGE{{\rel'}^+} \txid'_{m-2} \toEDGE{\RW} \txid'_{m-1} \toEDGE{{\rel'}^*} \txid'_m = \txid_n = \txid_1
\),
where \( \rel' \defeq \WR \cup \SO \),
that is, \( \txid_1 \toEDGE{( \rel'; \RW^? )^* } \txid_1 \).
This leads to a contradiction with respect to \cref{thm:acyclic-cp}.

\mypar{Robustness of a Banking Library against $\WSI$}

Using \cref{thm:main-wsi-robust},
we are able to prove the robustness of the banking library in \citet{bank-example-wsi} against \( \WSI \).
The banking example is based on relational databases and has three tables: \emph{account}, \emph{saving} and \emph{checking}.
The account table maps customer names to customer IDs (\( \codeFont{Account(\underline{Name}, CID )} \)).
The saving table maps customer IDs to their saving balances (\( \codeFont{Saving(\underline{CID}, Balance )} \)), and
the checking table maps customer IDs to their checking balances (\( \codeFont{Checking(\underline{CID}, Balance )} \)).

For simplicity, we encode the saving and checking tables as a kv-store,
and forgo the account table as it is an immutable lookup table.
We model a customer ID as an integer \( n \in \mathbb{N}\), and assume that balances are integer values. 
We then define the key associated with customer $n$ in the checking table as 
$n_c \defeq 2 n$,
and define the key associated with $n$ in the saving table as 
$n_s \defeq 2n {+} 1$. 
That is, \( \Keys \defeq \bigcup_{n \in \Nat} \Set{n_c, n_s} \).
Moreover, if \( n \) identifies a customer, \ie $(\stub, n) \in \codeFont{Account(\underline{Name}, CID )}$,
then
\( (n, \valueOf[\mkvs(n_s, \abs{\mkvs(n_s)} - 1)]) \in \codeFont{Saving(\underline{CID}, Balance )} \)
and \( (n, \valueOf[\mkvs(n_c, \abs{\mkvs(n_c)} - 1)]) \in \codeFont{Checking(\underline{CID}, Balance )} \).

The banking library provides five transactional operations.
The \( \codeFont{balance(n)} \) operation returns the total balance of customer \codeFont{n} in  \( \ret \).
The \( \codeFont{depositCheck(n,v)} \) operation deposits \codeFont{v} to the checking account of customer \codeFont{n} when \codeFont{v} is non-negative,
otherwise the checking account remains unchanged.

\SpaceAboveMath
\begin{align*}
    \codeFont{balance(n)} & \defeq
    \begin{transaction}
    \plookup{\pv{x}}{\pv{n}_c}; \ 
    \plookup{\pv{y}}{\pv{n}_s}; 
    \\ \passign{\ret}{\pv{x}+\pv{y}}
    \end{transaction} 
    & 
    \codeFont{depositCheck(n,v)} & \defeq
    \begin{transaction}
    \pifs{\pv{v} \geq 0} 
    \\ \plookup{\pv{x}}{\pv{n}_c}; \ 
    \pmutate{\pv{n}_c}{\pv{x} + \pv{v}}; \ 
    \pife
    \end{transaction}
\end{align*}
%
\SpaceBelowMath

\SpaceAboveMath
\begin{align*}
    \codeFont{transactSaving(n,v)} & \defeq
    \begin{transaction}
    \plookup{\pv{x}}{\pv{n}_s}; \
    \pifs{\pv{v} + \pv{x} \geq 0} \ 
    \pmutate{\pv{n}_s}{\pv{x} + \pv{v}}; \ 
    \pife
    \end{transaction} 
    \\
	\codeFont{amalgamate(n,n')} & \defeq
    \begin{transaction}
    \plookup{\pv{x}}{\pv{n}_s}; \ 
    \plookup{\pv{y}}{\pv{n}_c}; \ 
    \plookup{\pv{z}}{\pv{n'}_c}; \\
    \pmutate{\pv{n}_s}{0}; \ 
    \pmutate{\pv{n}_c}{0}; \ 
    \pmutate{\pv{n'}_c}{\pv{x} + \pv{y} + \pv{z}}; 
    \end{transaction} 
    \\
    \codeFont{writeCheck(n,v)} & \defeq
    \begin{transaction}
    \plookup{\pv{x}}{\pv{n}_s}; \ 
    \plookup{\pv{y}}{\pv{n}_c}; 
    \\
    \pifs{\pv{x} + \pv{y} < \pv{v} } \
        \pmutate{\pv{n}_c}{\pv{y} - \pv{v} - 1 }; \ \} \\
    \CodeFont{else} \{ \ 
        \pmutate{\pv{n}_c}{\pv{y} - \pv{v} };  \
    \pife \ 
    \pmutate{\pv{n}_s}{\pv{x}}; 
    \end{transaction}     
\end{align*}
%
\SpaceBelowMath

\noindent
The \( \codeFont{balance(n)} \) operation returns the total balance of customer \codeFont{n} in  \( \ret \).
The \( \codeFont{depositChecking(n,v)} \) operation deposits \codeFont{v} to the checking account of customer \codeFont{n} when \codeFont{v} is non-negative,
otherwise the checking account remains unchanged.
When $\codeFont{v} \geq 0$,  \( \codeFont{transactSaving(n,v)} \) deposits \codeFont{v} to the saving account of \codeFont{n}.
When $\codeFont{v} < 0$, \( \codeFont{transactSaving(n,v)} \) withdraws \codeFont{v} from the saving account of \codeFont{n} only if the resulting balance is non-negative,
otherwise the saving account remains unchanged.
The \( \codeFont{amalgamate(n,n')} \) operation moves the combined checking and saving funds of costumer \codeFont{n} to the checking account of customer $\codeFont{n}'$.
Lastly, \( \codeFont{writeCheck(n,v)} \) cashes a cheque of customer \codeFont{n} in the amount  \codeFont{v} by deducting \codeFont{v} from its checking account.
If \codeFont{n} does not hold sufficient funds (\ie the combined checking and saving balance is less than \codeFont{v}), customer \codeFont{n} is penalised by deducting one additional pound. 
%
\citet{bank-example-wsi} argue that to make the banking library robust against \( \SI \),
the \( \codeFont{writeCheck(n,v)} \) operation must be strengthened by writing back the balance to the saving account 
(via \(\pmutate{\pv{n}_s}{\pv{x}} \)),
even though the saving balance is unchanged.
The banking library is more complex than the multi-counter library.
Nevertheless, all banking transactions are either read-only or
satisfy the strictly-no-blind writes property; \ie the banking library is \(\WSI\)-safe.
As such, we can prove its robustness against $\WSI$ and hence \( \SI \).

\mypar{Lock Invariant}

The distributed lock library provides \(\plock(k)\), \(\ptrylock(k)\) and \(\punlock(k)\) 
operations on the key \( \key \):

\SpaceAboveMath
\begin{align*}
    \ptrylock(k) & \defeq \begin{transaction}
    \plookup{\pv{x}}{k}; \ \pifs{\pv{x} {=} 0} \;
    \pmutate{k}{ \var(ClientID) }; \; \passign{\var(m)}{\true} \; \} 
    \CodeFont{else} \{ \; \passign{\var(m)}{\false} \; \pife 
    \end{transaction}     
    \\ \plock(k) & \defeq  \;
    \codeFont{do}  \{\; \ptrylock(\key) \; \} \codeFont{until}(\var(m) {=} \false)
    \qquad \punlock(k) \defeq \begin{transaction}
        \pmutate{k}{ 0 }
    \end{transaction}     
\end{align*}
\SpaceBelowMath

\noindent 
The \( \ptrylock \) operation reads the \( \key \) vale.
If it is zero, \ie the lock is available, 
the operation sets it to the client ID and returns \( \true \);
otherwise it leaves it unchanged and returns \( \false \).
The \( \plock \) operation calls \( \ptrylock \) until it successfully acquires the lock.
The \( \punlock \) operation simply set the value to zero.

Consider the program \( \prog_{\CodeFont{LK}} \) where clients \( \cl\) and \( \cl'\) compete the lock \( \key \):

\SpaceAboveMath
\begin{align*}
    \prog_{\CodeFont{LK}} & \defeq ( \cl: (\plock(\key); \ \codeFont{...} ; \ \punlock(\key))^*
    \ \| \ 
    \cl': (\plock(\key); \ \codeFont{...} ; \ \punlock(\key))^* )
\end{align*}
\SpaceBelowMath

\noindent
The locking paradigm in \( \prog_{\CodeFont{LK}} \) is correct, in that
only one client can hold the lock at a time,
when executed under serialisability.
Since all the operations are trivially \( \WSI \)-safe,
\( \prog_{\CodeFont{LK}} \) is robust and hence correct under \( \WSI \) 
and any stronger model such as \( \SI \).
However, \( \prog_{\CodeFont{LK}} \) is not robust under \( \UA \), 
because the \( \plock \) operation might read any old value of key \( \key \)
until it reads the up-to-date value of \( \key \) and acquires the lock.
Nevertheless, we show that \( \prog_{\CodeFont{LK}} \) is still correct under \( \UA \).
We capture thus by the following invariant:
for all \( i \), if  \( i > 0\), then:

\SpaceAboveMath
\begin{align}
& \valueOf(\kvs(\key,i)) \neq 0 \iff \valueOf(\kvs(\key,i-1)) = 0
\label{equ:lock-unique-hold}
\\ & \valueOf(\kvs(\key,i)) = 0 \implies \wtOf(\kvs(\key,i)) = \wtOf(\kvs(\key,i-1))
\label{equ:lock-release}
\end{align}
\SpaceBelowMath

\noindent
It is straightforward to show that under \( \UA \), 
only one client can hold the key \eqref{equ:lock-unique-hold},
and the same client releases the lock \eqref{equ:lock-release}.

