\subsection{Read Atomic} 
\sx{example RAMP, not sure the meaning}
\ac{not be failed. Double negation. Bad English.}
Read atomic (RA) \cite{ramp} is the weakest consistency model among those that enjoy \emph{atomic visibility} \cite{framework-concur}. 
It requires of a transaction to read an atomic snapshot of the database and never observe the partial effects of other transactions.
This is also known as the \emph{all-or-nothing} property: a transaction observes either none or all the updates performed by other transactions. 
One litmus test that should \textbf{not} be failed in RAMP consists of the program $\prog_1$ from \secref{sec:semantics.example}, which we have presented a trace violating atomic visibility if no constraints on the commit test are placed.
Intuitively, in such a program, it violate the atomic visibility because it is allowed to execute the second transaction \( \trans_2\) when the thread $\thid_2$ only observes partial effect from transaction \( \txid_1 \).
%\ac{, which is obtained by removing all the information about $\thid_1$ (view and stack) in Figure \ref{fig:opsem.example}(c).
%\[
%\prog_1 \equiv 
    %\begin{array}{c} 
    %\begin{transaction} 
        %\pderef{\pvar{a}}{\vx};\\
        %\pderef{\pvar{b}}{\vy};\\
        %\pifs{\pvar{a}=1 \wedge \pvar{b}=0}\\
        %\quad \passign{\retvar}{\Large \frownie{}} \\
        %\pife
    %\end{transaction}
%\end{array}
%\]
%}

%\ac{
%To avoid transactions to only observe the partial effects of other transactions, we 
%must ensure that transactional code cannot be executed by a thread whose 
%views is up-to-date with respect to some transaction $\tsid$ for some location $[\loc_x]$, 
%but not for some other location $[\loc_y]$. This leads to the following definition.
%}
To avoid a transaction to observe the partial effects of other transactions, we need to ensure that transactional code cannot be executed by a thread whose views is partially up-to-date with respect to some transactions.
This leads to the following definition.
\begin{defn}[Read atomic]
\label{def:readatomic}
%Let $\hh$ be a history heap,$V$ be a view, $[\loc_x]$ be 
%a location and $\nu$ be a version. We say that $V$ $[\loc_x]$-\emph{sees} version 
%$\nu$ if there exists an index $i \leq V([\loc_x])$ such that $V(i) = \nu$. 
%We say that $V$ $[\loc_x]$-\emph{sees} transaction $\tsid$ if 
%$V$ $[\loc_x]$-sees a version $\nu = (\_, \tsid, \_)$. 
Given a view $\vi \in \Views$, a history heap $\hh \in \HisHeaps$, and a transaction identifier $\txid \in \TxID$, the view \emph{sees} the transaction in the history heap, written $\pred{visible}{\txid, \vi, \hh}$, if the view sees all the writes from the transaction,
%We say that $V$ \emph{sees} transaction $\tsid$ in $\hh$, written 
%$\mathsf{Visible}(\tsid, V, \hh)$, iff 
\sx{\( \exsts{i} \) might be enough}
\[
\begin{rclarray}
\pred{visible}{\txid, \vi, \hh} & \eqdef & \fora{\ke, i} \hh(\ke)(i) = (\stub, \txid, \stub) \implies i \leq \vi(\ke).
\end{rclarray}
\]
\ac{In English: the view is up-to-date with respect to all the updates 
performed by transaction $\tsid$.

In English: if the view $V$ is up-to-date with some of the updates performed 
by $\tsid$, then it must be up-to-date with all the updates performed by $\tsid$. 
This is the all-or-nothing property.

In English: Before executing a transaction, either you observe all or none the 
updates of all other transactions. We may strengthen the consistency model and 
require that the same property must be satisfied at the end as well, though 
this is not strictly necessary. In this case the check becomes: 
\[
\mathsf{atomic}(\hh, V) \wedge \mathsf{atomic}(\hh, V') \wedge \mathsf{UpdateView}(\hh, V, \mathcal{O}) 
\sqsubseteq V' \implies (\hh, V) \triangleright_{\mathsf{RA}} \mathcal{O}: V'.
\]
}
                                                          
\sx{consistent has been used in many place, might mislead?}
Then given a history \( \hh \), the view $\vi$ is \emph{consistent} with respect to \emph{atomic visibility}, written $\pred{atomic}{\vi, \hh}$, if the view $\vi$ is up-to-date with some of the updates performed by transaction $\txid$, then it should be up-to-date with all the updates performed by $\txid$,
\[
\begin{rclarray}
\pred{atomic}{\vi ,\hh} & \eqdef & \fora{\txid } \exsts{\ke, i} i \leq \vi(\ke) \land \hh(\ke)(i) = (\stub, \txid, \stub) \implies \pred{vusible}{\txid, \vi, \hh}
\end{rclarray}
\]
The commit test for \emph{read atomic} $\csatRA$ is defined as,
\[
\begin{rclarray}
(\hh, \vi) \csatRA \stub: \stub & \defeq & \pred{atomic}{\hh, \vi} 
\end{rclarray}
\]
%written $\mathsf{up-to-date}(\hh, V, \tsid, [\loc_x])$, 
%if either 
%
%\begin{itemize}
%\item for all indexes $i = 0,\cdots, \lvert \hh([\loc_x]) - 1 \rvert$, 
%$\WS(\hh([\loc_x])(i)) \neq \tsid)$, or 
%\item if $\WS(\hh([\loc_x])(i)) = \tsid$ for some $i = 0,\cdots, \lvert \hh([\loc_n]) -1 \rvert$, 
%then $i \leq V([\loc_n])$.
%\end{itemize}
\end{defn}

Suppose that we execute the program $\prog_1$ under read atomic $\comoRA$.
Assume the \( \txid_{1}\) is still committed first as in Section \ref{sec:semantics.example}, yielding the result shown in \figref{fig:opsem-example-b}.
Yet the second transaction \( \txid_{2} \) cannot starts with a view as in \figref{fig:opsem-example-c}, because later when the transaction try to commit, the read atomic commit test will stop it.
\ac{
$\langle \mathcal{C_0}, \prog_1 \rangle \xrightarrow{\mathsf{RA}} \langle \mathcal{C}_1, \prog_1' \rangle$, 
where we recall that $\mathcal{C}_0$, $\mathcal{C}_1$ are depicted in Figure \ref{fig:opsem.exampe}(a), 
\ref{fig:opsem.example}(b), respectively. 

It is immediate to observe that the only way in which the execution of transaction $\ptrans{\trans}$ from $\thid_2$ in $\prog_1'$ can return value ${\Large \frownie}$ is the following: 
\begin{itemize}
\item first, push the view $V$ of thread $\txid_2$ in the configuration 
$\mathcal{C}_1$ of Figure \ref{fig:opsem.example}(b) to observe the update of location $[\vx]$, but not the update of 
$[\vy]$. This view is the one labelled with $\txid_2$ in Figure \ref{fig:opsem.example}(c), and we refer 
to it as $V'$;
\item then, execute the transaction $\ptrans{\trans}$ in $\thid_2$. 
\end{itemize}
}
