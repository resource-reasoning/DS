\subsubsection{Program Semantics}
\sx{
For weak consistency models, or weak isolation levels as a common term used in database community, a thread is not necessary to work on the up-to-date version of a database in exchange for better performance. 
Even in a single machine database, a thread running under weak consistency model can make less synchronisation with the hard drivers and other running threads, which means the thread could observe out-of-date state.
Therefore, we introduce \emph{views} to model threads of a database.
A \emph{view} is a cut in a history heap that corresponds the indexes of versions that a thread work with.
We also define a order between two views, if they contain the same addresses and the indexes are ordered point-wise.
This is to model the synchronisation between threads.
For example \( \vi \orderVI \vi' \) could mean that a thread updates it view from \( \vi \) to \( \vi' \) by synchronisation with others.
}

\label{sec:prog-semantics}
The semantics for commands is in \figref{fig:thread_semantics}, taking the form
\[
    ( \hh, \stk, \vi ), \cmd \ \toT{\et} \ ( \hh', \stk', \vi' ) , \cmd'
\]
Where \( \hh, \hh' \) are multi-version key-value stores (\defref{def:mkvs}), \( \stk, \stk'\) are the stacks (\defref{def:stacks}), \( \vi, \vi'\) are views (\defref{def:view}), and $\ET$ is \emph{an execution test} (\defref{def:consistency-models}), i.e. a condition that must be satisfied in order for a client to execute a transaction safely. 
The well-formed condition for the thread states asserts the views and history heaps contains the same keys:
\[
\fora{\hh, \vi, \hh', \vi'} (\stub, \hh, \vi, \stub) \toT{\stub} (\stub, \hh', \vi', \stub)  \implies \dom(\hh) = \dom(\vi) \land \dom(\hh') = \dom(\vi')
\]
Execution tests is a set of quadruples \( (\mkvs, \vi, \opset, \vi') \) consisting of a key-value store, a view before execution, a operation set and a view after committing of the operation set. 
We often write \( (\mkvs, \vi) \etto \opset : \vi'\) in lieu of \( (\mkvs, \vi, \opset, \vi') \in \et\).
The quadruple describes that when the state of the key-value store is \( \hh \), a client who has view \( \vi \) is allowed to commit a single transaction that can be abstracted to the operation set \( \opset \), and then after the commit the thread view must be updated to at least \( \vi' \)
We parametrise the execution test in the operational semantics of commands (\figref{fig:thread_semantics}), while we will give examples of execution tests in \secref{sec:cmexamples}. 

\ac{
There we also note that by tweaking the execution test used by the 
semantics, we capture different consistency models of 
key-value stores.
}

\begin{defn}[Execution Tests]
\label{def:consistency-models}
\label{def:executiontests}
Given the set of history heaps \( \hh \in \HisHeaps \) (\defref{def:his_heap}), operation sets \( \opset \in \Opsets \) (\defref{def:ops}) and views \( \vi, \vi' \in \Views \) (\defref{def:views}), \emph{a consistency model} \( \como \in \Como \) is a set of quadruples in the form of \( ( \hh, \vi, \opset, \vi' ) \),
\[
    \begin{rclarray}
        \et \in \ETS & \defeq & \powerset{\HisHeaps \times \Views \times \Opsets \times \Views}
    \end{rclarray}
\]
A well-formed consistency model, written \( \pred{wfC}{\como}\), requires the domain of pre- and post views are the same as the domain of the history heap, and the operation set only has keys included in the previous domain.
\[
    \begin{rclarray}
        \pred{wfC}{\como} & \defeq & \fora{\hh, \vi, \vi', \opset } (\hh, \vi, \opset, \vi') \in \como \implies \opset\projection{2} \subseteq \dom(\vi) = \dom(\vi') = \dom(\hh)
    \end{rclarray}
\]
\sx{
    Maybe also some version of composition requirement.
    For example, the composition of two should be also included in the consistency model.
    \[
        \fora{m,m'} m \in \como \land m' \in \como \implies m \compose{} m' \in \como
    \]
    where \( \compose{} \defeq (\composeHH, \composeVI,\composeO, \composeVI)\).
}
\end{defn}


\sx{Re-assemble some words from Andrea. Need more work on the words }

The main rule in the operational semantics for commands is the one corresponding to the execution of a transaction \rl{PCommit}.
%A new transaction is committed through the  rule.
First, the view can shift to later versions before executing the transaction to model the clients might gain more information about the system since its last commit.
To recall The order between two views  with the same domain, for example \( \vi'' \geq \vi \) in \rl{PCommit}, is defined by the order of the indexes (\defref{def:views}).
This new local view \( \vi'' \) should also be consistent with the key-value stores, \ie it leads to a situation where the current client is allowed to commit the effect of the immediate next transaction.
The transaction code \( \trans \) is executed locally given an initial snapshot \( \sn = \clpsHH{\hh, \vi''}\) (\defref{def:snapshot}) that is decided by the current state of key-value store \( \mkvs \) and the local view \( \vi'' \).
%The \( \funcn{localHeap} \) function uniquely determined a (local) heap from a history heap and a view by picking the versions of addresses indexed by the view.
After local execution through semantics for transactions (\figref{fig:transaction_semantics}), we propagate the stack \( \stk' \) and more importantly obtain the operation set \( \opset \), while the snapshot \( \sn' \) will be throw away.
Then the transaction picks a fresh identifier \( \txid \) and commits the operation set \( \opset \), which will update the key-value store and local view.
The operation set includes the first read and last write of each key, which are the operations might affect the key-value store, because of the atomicity of transactions.
The \funcn{updateMKVS} function updates the history heap using the operation set, \( \mkvs' = \func{updateMKVS}{\mkvs,\vi'',\txid, \opset}\).
For read operations, it includes the new identifier to the read set of the version related to the corresponding key and the local view \( \vi \).
For write operations, it extends a new version to the tail and puts the new identifier as the writer.
Since we assume strong program order, we set a lower bound for the new local view by \funcn{updateView} function.
This function shifts the view to the latest version if the version is written by the current transaction.
This guarantees strong program order, meaning the following transaction will at least read its own write.
Finally, the actual new local view \( \vi' \) is any view greater than the lower bound \( \vi' \geq \func{updateView}{\mkvs', \vi'', \opset}\) and the overall satisfied the execution tests, \ie \( (\mkvs, \vi'') \etto \opset : \vi'\).

\ac{The paragraph below should probably go when discussing the rules of the semantics
Note that the way in which MKVSs and views are updated ensure the following: 
$\bullet$ a client always reads its own preceding writes; 
$\bullet$ clients always read from an increasingly up-to-date state of the database; 
$\bullet$ the order in which clients update a key $\key{k}$ is consistent with the 
order of the versions for such keys in the MKVS; 
$\bullet$ writes take place after reads on which they depend. 
}

\begin{figure}[!t]
\hrule\vspace{5pt}
For any functions \( f \), the notation \( f\rmto{k}{v} \) means the result by replacing or extending the element associated with \( k \) to \( v \).
For any lists or tuples \( l \), the notation \( l\rmto{i}{k} \) means the result by replacing the \emph{i-th} element to \( k \).
To record the index of list starts from 0.
The \( \lcat \) denotes list concatenation.
\[
\begin{rclarray}                                 
    \func{updateMKVS}{\hh, \vi, \txid, \opset} & \defeq & 
    \left\{ \begin{array}{@{} l l}
        \hh & \text{if } \opset = \unitO \\
        \func{updateMKVS}{\hh', \vi, \txid, \opset'} & \text{if } \opset = \opset' \uplus (\otR, \addr, \val) \\
        \multicolumn{2}{@{}l}{\qqquad \text{and } \hh' \equiv \hh\rmto{\addr}{\hh(\addr)\rmto{\vi(\addr)}{ \ver\rmto{3}{\RTx(\ver) \uplus \Set{\txid}} }}}\\
        \multicolumn{2}{@{}l}{\qqquad \text{and } \ver = \hh(\addr)(\vi(\addr)}\\
        \func{updateMKVS}{\hh'', \vi, \txid, \opset'} & \text{if } \opset = \opset' \uplus (\otW, \addr, \val) \\
        \multicolumn{2}{@{}l}{\qqquad \text{and } \hh'' \equiv \hh\rmto{\addr}{\hh(\addr) \lcat \List{(\val, \txid, \emptyset)} } }\\
    \end{array} 
    \right. \\
%
%
    \func{updateView}{\hh, \vi, \opset} & \defeq &
    \begin{cases}
        \vi & \text{if } \opset = \unitO \\
        \func{updateView}{\hh, \vi, \opset'} & \text{if } \opset = \opset' \uplus (\otR, \addr, \val) \\
        \func{updateView}{\hh, \vi\rmto{\addr}{(\left| \hh(\addr) \right| - 1)}, \opset'} & \text{if } \opset = \opset' \uplus (\otW, \addr, \val) \\
    \end{cases} \\
%
%              
	\func{fresh}{\hh}  & \defeq & \Setcon{ \txid }{ \txid \in \TxID \land \fora{\addr, i} \txid \neq \hh(\addr)(i).\texttt{write} \land \txid \notin \hhR(\addr)(i).\texttt{read}} \\
\end{rclarray}
\]
\hrule\vspace{5pt}
%
The function \( \snapshot \) is defined in \defref{def:snapshot} and operational semantics for transactions \( \toL{} \) in \figref{fig:transaction_semantics}.
Given the set of executions tests \( \ConsisModels \) (\defref{def:consistency-models}), stacks \( \Stacks \) (\defref{def:stacks}), multi-version key-value stores \( \HisHeaps \) (\defref{def:his_heap}) and views \( \Views \) (\defref{def:cuts}), the \emph{operational semantics for commands}:
\[
\begin{rclarray}
	\toT{}  & : &
    %\begin{array}[t]{@{}l@{}}
	\left( ( \HisHeaps \times \Stacks \times \Views ) \times \Commands \right) 
	\times \Como \times 
	\left( ( \HisHeaps \times \Stacks \times \Views ) \times \Commands \right) 
    %\end{array}
\end{rclarray}
\]
\[
\begin{array}{@{} c @{\qquad} c @{} }
    \multicolumn{2}{c}{
        \infer[\rl{PCommit}]{%
            ( \hh, \stk, \vi ), \ptrans{\trans} \ \toT{\como} \ ( \hh', \stk', \vi' ) , \pskip
        }{%
            \begin{array}{c}
                \vi'' \geq \vi
                \quad \txid \in \func{fresh}{\hh}  
                \quad \h = \clpsHH{\hh,\vi''}
                \quad (\stk, \h, \unitO), \trans \ \toL^{*} \  (\stk', \h', \opset) , \pskip \\
                \hh' = \func{updateMKVS}{\hh, \vi'', \txid, \opset}  
                \quad \vi' \geq \func{updateView}{\hh', \vi'', \opset}
                \quad (\hh, \vi) \csat \opset : \vi'
            \end{array}
        }
    }
    \\[1em]
    \infer[\rl{PAssign}]{%
        ( \hh, \stk, \vi ) , \passign{\var}{\expr} \ \toT{\como} \  ( \hh, \stk\rmto{\var}{\val}, \vi ) , \pskip
    }{
        \val = \evalE{\expr}
    }
    &
    \infer[\rl{PAssume}]{%
        ( \hh, \stk, \vi ) , \passume{\expr} \ \toT{\como} \  ( \hh, \stk, \vi ) , \pskip
    }{%
        \evalE[\thstk]{\expr} = 0
    }
    \\[1em]
    \infer[\rl{PChoice}]{%
        ( \hh, \stk, \vi ) , \cmd_{1} \pchoice \cmd_{2} \ \toT{\como} \  ( \hh, \stk, \vi ) , \cmd_{i}
    }{
        i \in \Set{1,2}
    }
    &
    \infer[\rl{PIter}]{%
        ( \hh, \stk, \vi ) , \cmd\prepeat \ \toT{\como} \  ( \hh, \stk, \vi ) , \pskip \pchoice (\cmd \pseq \cmd\prepeat)
    }{}
    \\[1em]
    \infer[\rl{PSeqSkip}]{%
        ( \hh, \stk, \vi ) , \pskip \pseq \cmd \ \toT{\como} \  ( \hh, \stk, \vi ) , \cmd
    }{}
    &
    \infer[\rl{PSeq}]{%
        ( \hh, \stk, \vi ) , \cmd_{1} \pseq \cmd_{2} \ \toT{\como} \ ( \hh, \stk', \vi' ) , {\cmd_{1}}' \pseq \cmd_{2}
    }{% 
        ( \hh, \stk, \vi ) , \cmd_{1} \ \toT{\como} \  ( \hh, \stk', \vi' ) , {\cmd_{1}}' 
    }
    \\[1em]
\end{array}
\]
\hrule\vspace{5pt}
The thread environment is a partial function from thread identifiers to pairs of stacks and views \( \thdenv \in \ThdEnv \defeq \ThreadID \parfinfun \Stacks \times \Views \).
Given the set of execution tests \( \ConsisModels \) (\defref{def:consistency-models}) and key-value stores \(\HisHeaps\) (\defref{def:mkvs}), the \emph{semantics for programs}:
\[
	. \toG{.} . : 
    ( \HisHeaps \times \ThdEnv \times \Programs) 
    \times \Como 
    \times ( \HisHeaps \times \ThdEnv \times \Programs) 
\]
\[
    \infer[\rl{PSingleThread}]{%
        ( \hh, \thdenv, \prog ) \ \toG{\como} \  ( \hh', \thdenv\rmto{\thid}{(\stk',\vi')} , \prog\rmto{\thid}{\cmd'} ) 
    }{%
        (\stk,\vi) = \thdenv(\thid)
        && \cmd = \prog(\thid) 
        && ( \hh, \stk, \vi ), \cmd, \ \toT{\como} \  ( \stk', \hh', \vi' ) , \cmd'  
    }
\]
%
\hrule\vspace{5pt}
\caption{operational semantics for threads and programs}
\label{def:thread_semantics}
\label{fig:thread_semantics}
\label{def:thread_pool_semantics}
\label{def:program_semantics}
\label{fig:thread_pool_semantics}
\end{figure}

\begin{lemma}
\label{lem:hhupdate.welldefined}
The function $\HHupdate_{\tsid}$ is well-defined over well-formed MKVS, sets of operations and 
views. If $\hh$ is a well-formed history heap, $V$ is a well-formed view with respect 
to $\hh$, $\mathcal{O}$ is a well-formed set of operations and $\tsid$ does not 
appear in $\hh$, then $\HHupdate_{\tsid}(\hh, \mathcal{O}, V)$ is uniquely determined 
and equivalent to a well-formed MKVS.
\end{lemma}

\begin{lemma}
The function $\Vupdate$ is well-defined. Furthermore, let $\hh, V, \mathcal{O}$ and $\tsid$ 
be a well-formed MKVS, view, set of operations, and a transction identifier that does not appear 
in $\hh$, respectively. Then $\Vupdate(\hh, V, \mathcal{O})$ is well-formed with respect 
to $\HHupdate_{\tsid}(\hh, V, \mathcal{O})$.
\end{lemma}

\begin{lem}[Confluence of \funcn{updateMKVS} and \funcn{updateView}]
Given a valid operation set \( \opset \), the order of applying \( \funcn{updateMKVS} \) function (\( \funcn{updateView} \) function) to the elements from operation set does not affect the final result.
\end{lem}
                                                                                                         
Last, the program has standard interleaving semantics by picking a client and then progressing one step (\figref{fig:thread_pool_semantics}).
To achieve that a thread environment holds the stacks and views associated with all active clients \( Env \in \sort{ThdEnv} \).
We assume the client identifiers from client environment match with those in the program \( \prog \).
We also assume all the stacks and views initially are the same respectively.
