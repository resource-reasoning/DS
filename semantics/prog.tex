\subsection{Operational Semantics of Programs}
\label{sec:prog-semantics}
\azalea{I rewrote most of this section.}
%\sx{
%For weak consistency models, or weak isolation levels as a common term used in database community, a thread is not necessary to work on the up-to-date version of a database in exchange for better performance. 
%Even in a single machine database, a thread running under weak consistency model can make less synchronisation with the hard drivers and other running threads, which means the thread could observe out-of-date state.
%Therefore, we introduce \emph{views} to model threads of a database.
%A \emph{view} is a cut in a history heap that corresponds the indexes of versions that a thread work with.
%We also define a order between two views, if they contain the same addresses and the indexes are ordered point-wise.
%This is to model the synchronisation between threads.
%For example \( \vi \orderVI \vi' \) could mean that a thread updates it view from \( \vi \) to \( \vi' \) by synchronisation with others.
%}

Before proceeding with the program operational semantics, we formalise the notion of \emph{execution tests}.
Execution tests are used to determine whether a transaction may commit its effects (fingerprint) to the MKVS by ensuring that its  effects comply with the underlying consistency model.

\mypar{Execution Tests}
An execution tests of a transaction is a quadruples of the form \( (\mkvs, \vi, \opset, \vi') \), where $\mkvs$ denotes the MKVS;
the $\vi$ denotes the \emph{initial} view, recorded at the beginning of the transactions; 
the $\opset$ denotes the fingerprint of the transaction; and 
$\vi'$ demotes the \emph{final} view of the transaction, obtained after committing the transaction. 
An execution test $(\mkvs, \vi, \opset, \vi')$ states that when the MKVS is described by $\mkvs$, a client with view $\vi$ is allowed to execute a single transaction with fingerprints $\opset$, commit the transaction and obtain an updated view $\vi'$. 
%
%
\azalea{What do we mean by at least $\vi'$? \sx{ meaning the lower bound of the view. The semantics  model this by shift the view at the beginning, so I think we should say update to the exact view.} }
%
%
\azalea{Why do we call these execution tests and not the consistency model? \sx{Andrea thinks it is more precise than consistency model, if I remember.}}
\begin{definition}[Execution Tests]
\label{def:consistency-models}
\label{def:executiontests}
Given the set of $\HisHeaps$ (\cref{def:his_heap}), fingerprints $\Opsets$ (\cref{def:ops}), and views $\Views$ (\cref{def:views}), the set of \emph{execution tests}, \( \como \in \Como \), is:
\[
        \ETS \eqdef  
		\setcomp{
			(\mkvs, \vi, \opset, \vi') \in \HisHeaps \times \Views \times \Opsets \times \Views
		} 
		{
		\opset\projection{2} \subseteq \dom(\vi) = \dom(\vi') = \dom(\hh)
		}       
\]
\end{definition}
%
We often write $(\mkvs, \vi) \etto \opset : \vi'$ for  $(\mkvs, \vi, \opset, \vi') \in \et$.
\sx{
    Maybe also some version of composition requirement.
    For example, the composition of two should be also included in the consistency model.
    \[
        \fora{m,m'} m \in \como \land m' \in \como \implies m \compose{} m' \in \como
    \]
    where \( \compose{} \defeq (\composeHH, \composeVI,\composeO, \composeVI)\).
}


%\begin{definition}[Execution tests]
%\label{def:consistency-models}
%\label{def:executiontests}
%Given the set of key-value stores \( \hh \in \HisHeaps \) (\cref{def:his_heap}), fingerprints \( \opset \in \Opsets \) (\cref{def:ops}) and views \( \vi, \vi' \in \Views \) (\cref{def:views}), \emph{execution tests} \( \como \in \Como \) is a set of quadruples in the form of \( ( \hh, \vi, \opset, \vi' ) \):
%\[
%    \begin{rclarray}
%        \et \in \ETS & \defeq & \powerset{\HisHeaps \times \Views \times \Opsets \times \Views}
%    \end{rclarray}
%\]
%Well-formed  execution tests \( \et \) require the domain of views and the key-value store are the same, and the fingerprints only have keys included in the previous domain:
%\[
%    \begin{rclarray}
%         &&\fora{\hh, \vi, \vi', \opset } (\hh, \vi, \opset, \vi') \in \como \implies \opset\projection{2} \subseteq \dom(\vi) = \dom(\vi') = \dom(\hh)
%    \end{rclarray}
%\]
%\sx{
%    Maybe also some version of composition requirement.
%    For example, the composition of two should be also included in the consistency model.
%    \[
%        \fora{m,m'} m \in \como \land m' \in \como \implies m \compose{} m' \in \como
%    \]
%    where \( \compose{} \defeq (\composeHH, \composeVI,\composeO, \composeVI)\).
%}
%\end{definition}
%
%

%Execution tests is a set of quadruples \( (\mkvs, \vi, \opset, \vi') \) consisting of a key-value store, a view before execution, a operation set and a view after committing of the operation set. 
%We often write \( (\mkvs, \vi) \etto \opset : \vi'\) in lieu of \( (\mkvs, \vi, \opset, \vi') \in \et\).
%The quadruple describes that when the state of the key-value store is \( \hh \), a client who has view \( \vi \) is allowed to execute a single transaction that has  the fingerprints \( \opset \), and then after the commit the thread view must be updated to at least \( \vi' \).

\ac{
There we also note that by tweaking the execution test used by the 
semantics, we capture different consistency models of 
key-value stores.
}


\begin{figure}[!t]
\sx{change the order to key-value, view and stack, and the program semantics change to the type of configuration + a stack env.}
\hrule
%
\[
\begin{rclarray}
	\toT{}  & : &
	\left( ( \HisHeaps \times \Views \times \Stacks ) \times \Commands \right) 
	\; \times\; \Como \;\times \;
	\left( ( \HisHeaps \times \Views \times \Stacks ) \times \Commands \right) 
	\vspace{5pt}
\end{rclarray}
\]
\begin{mathpar}
    \inferrule[\rl{PCommit}]{%
        \vi \orderVI  \vi''
        \\ \h = \clpsHH{\hh,\vi''}
        \\ (\stk, \h, \unitO), \trans \ \toL^{*} \  (\stk', \stub,  \opset) , \pskip
        \\ \txid \in \func{fresh}{\hh}  
        \\\\ \hh' = \func{updateMKVS}{\hh, \vi'', \txid, \opset}  
        \\ \func{updateView}{\hh', \vi'', \opset} \orderVI \vi'
        \\ (\hh, \vi) \csat \opset : \vi'
    }{%
        ( \hh, \vi, \stk ), \ptrans{\trans} \ \toT{\como} \ ( \hh', \vi', \stk' ) , \pskip
    }
    \and
    \inferrule[\rl{PAssign}]{
        \val = \evalE{\expr}
    }{%
        ( \hh, \vi, \stk ) , \passign{\var}{\expr} \ \toT{\como} \  ( \hh, \vi, \stk\rmto{\var}{\val} ) , \pskip
    }
    \and
    \inferrule[\rl{PAssume}]{%
        \evalE[\thstk]{\expr} \neq 0
    }{%
        ( \hh, \vi, \stk ) , \passume{\expr} \ \toT{\como} \  ( \hh, \vi, \stk ) , \pskip
    }
    \and
    \inferrule[\rl{PChoice}]{
        i \in \Set{1,2}
    }{%
        ( \hh, \vi, \stk ) , \cmd_{1} \pchoice \cmd_{2} \ \toT{\como} \  ( \hh, \vi, \stk ) , \cmd_{i}
    }
    \and
    \inferrule[\rl{PIter}]{ }{%
        ( \hh, \vi, \stk ) , \cmd\prepeat \ \toT{\como} \  ( \hh, \vi, \stk ) , \pskip \pchoice (\cmd \pseq \cmd\prepeat)
    }
    \and
    \inferrule[\rl{PSeqSkip}]{ }{%
        ( \hh, \vi, \stk ) , \pskip \pseq \cmd \ \toT{\como} \  ( \hh, \vi, \stk ) , \cmd
    }
    \and
    \inferrule[\rl{PSeq}]{% 
        ( \hh, \vi, \stk ) , \cmd_{1} \ \toT{\como} \  ( \hh, \vi', \stk' ) , {\cmd_{1}}' 
    }{%
        ( \hh, \vi, \stk ) , \cmd_{1} \pseq \cmd_{2} \ \toT{\como} \ ( \hh, \vi', \stk' ) , {\cmd_{1}}' \pseq \cmd_{2}
    }\vspace{5pt}
\end{mathpar}
\begin{flushleft} 
with
\quad
$
\func{fresh}{\hh}  \eqdef
\Setcon{ \txid }{ 
	\txid \in \TxID \land \fora{\addr, i} \txid \neq \WTx(\hh(\addr,i)) 
	\land \txid \notin \RTx(\hhR(\addr,i))
} 
$, and
\vspace{5pt}
 \end{flushleft}
%
\[
\begin{rclarray}         
%	 \func{updateMKVS}{., ., ., .} & : & \MKVSs \times \Views \times  \\                        
    \func{updateMKVS}{\hh, \vi, \txid, \unitO} & \defeq & \hh \\
    \func{updateMKVS}{\hh, \vi, \txid, \opset \uplus \Set{(\otR, \ke, \stub)}} & \defeq &  
    \begin{array}[t]{@{}l}
        \texttt{let } (\nat, \txid', \txidset) = \hh(\ke, \vi(\ke)) \\
        \texttt{and } \hh' = \hh\rmto{\ke}{%
            \hh(\ke)\rmto{\vi(\addr)}{%
                (\nat, \txid', \txidset \uplus \Set{\txid}) } } \\
        \texttt{ in } \func{updateMKVS}{\hh', \vi, \txid, \opset}
    \end{array} \\
    \func{updateMKVS}{\hh, \vi, \txid, \opset \uplus \Set{(\otW, \ke, \nat)}} & \defeq &  
    \begin{array}[t]{@{}l}
        \texttt{let } \hh' = \hh\rmto{\ke}{ ( \hh(\ke) \lcat \List{(\nat, \txid, \emptyset)} ) } \\
        \texttt{ in } \func{updateMKVS}{\hh', \vi, \txid, \opset}
    \end{array} 
%
\end{rclarray}
\]
\begin{flushleft} and \end{flushleft}
%
\[
\begin{rclarray}
    \func{updateView}{\hh, \vi, \unitO} & \defeq & \vi \\
    \func{updateView}{\hh, \vi, \opset \uplus \Set{(\otR, \ke, \stub)}} & \defeq & \func{updateView}{\hh, \vi, \opset}\\
    \func{updateView}{\hh, \vi, \opset \uplus \Set{(\otW, \ke, \stub)}} & \defeq & \func{updateView}{\hh, \vi\rmto{\addr}{(\left| \hh(\addr) \right| - 1)}, \opset}\\
%
%%              
%	\func{fresh}{\hh}  & \defeq & 
%	\Setcon{ \txid }{ 
%		\txid \in \TxID \land \fora{\addr, i} \txid \neq \WTx(\hh(\addr,i)) \\
%		\land\ \txid \notin \RTx(\hhR(\addr,i))
%	} 
\end{rclarray}
\]
\vspace{5pt}
\hrule%\vspace{5pt}
%\begin{flushleft}
%The thread environment is a partial function from thread identifiers to pairs of stacks and views \( \thdenv \in \ThdEnv \defeq \ThreadID \parfinfun \Stacks \times \Views \).
%Given the set of execution tests \( \ConsisModels \) (\cref{def:consistency-models}) and key-value stores \(\HisHeaps\) (\cref{def:mkvs}), the \emph{semantics for programs}:
%\end{flushleft}
\[
	\toG{} : 
    ( \Confs \times \ThdEnv \times \Programs) 
    \;\times\; \Como \;\times\;
    ( \Confs \times \ThdEnv \times \Programs) 
\]
\begin{mathpar}
    \inferrule[\rl{PSingleThread}]{%
        ( \mkvs, \viewFun(\thid), \thdenv(\thid) ), \prog(\thid), \ \toT{\como} \  ( \mkvs', \vi', \stk' ) , \cmd'  
    }{%
        ( (\mkvs, \viewFun), \thdenv, \prog ) \ \toG{\como} \  ( \mkvs', \viewFun\rmto{\thid}{\vi'}) \thdenv\rmto{\thid}{\stk'} , \prog\rmto{\thid}{\cmd'} ) 
    }
\end{mathpar}
%
\hrule
\caption{Operational semantics of commands (above) and programs (below)}
\label{def:thread_semantics}
\label{fig:thread_semantics}
\label{def:thread_pool_semantics}
\label{fig:thread_pool_semantics}
\label{def:program_semantics}
\label{fig:program_semantics}
\end{figure}


\mypar{Operational Semantics of Commands}
The \emph{operational semantics of commands} is given at the top of \cref{fig:thread_semantics}. 
Command transitions are of the form $(\mkvs, \vi, \stk), \cmd \ \toT{\et} \ (\mkvs', \vi', \stk') , \cmd'$, stating that given the MKVS $\mkvs$, view $\vi$ and stack $\stk$, executing command $\cmd$ for one step under $\como$, updates the MKVS to $\mkvs'$, the stack to $\stk'$, and the command to its continuation $\cmd'$. 
Note that $\ET$ denotes the set of execution tests, prescribing the permissible executions of transactions. 
We keep the command operational semantics in \cref{fig:thread_semantics} parametric in the choice of execution tests. 
Later in \cref{sec:cmexamples} we present several examples of execution tests of well-known consistency models in the literature. 

With the exception of the \rl{PCommit} transition, the remaining command transitions are standard and behave as expected. We write 
In \cref{fig:thread_semantics} we write $\lcat$ for denotes list concatenation.
We write $f \rmto{a}{b}$ for function update: $f \rmto{a}{b}(a) = b$, and for all $c \ne a$, $f \rmto{a}{b}(c) = f(c)$.

%The notation \( l\rmto{i}{k} \) on a list \( l \) means the result by replacing the \emph{i-th} element to \( k \).
%%To record the index of list starts from 0.
%The \( \lcat \) denotes list concatenation.

The premise of \rl{PCommit} state that the current view $\vi$ of the executing command maybe advanced to a newer view $\vi''$ (see \cref{def:views}). 
Given the new view $\vi''$, the transaction proceeds by obtaining a snapshot $\sn$ of the MKVS $\mkvs$, and executing $\trans$ locally to completion ($\pskip$), updating the stack to $\stack'$, while accumulating the fingerprint $\opset$. Note that the resulting snapshot is ignored (denoted by $\stub$) as the effect of the transaction is recorded in the fingerprint $\opset$. 
%

The transaction is now ready to commit and may propagate its changes to $\mkvs$.
To this end, a \emph{fresh} transaction identifier $\txid$ is picked (\ie one that does not appear in $\mkvs$ as defined in \cref{fig:thread_semantics}) to identify the completed transaction, and the changes performed by $\txid$ are propagated to $\mkvs$. 
This is done via the $\func{updateMKVS}{\mkvs, \vi'', \txid, \opset}$ function (defined in \cref{fig:thread_semantics}) to update $\mkvs$ to  $\mkvs'$. 
As expected, for every read operation $(\otR, \ke, -)$ in fingerprint $\opset$, the readers of $\ke$ at index $\vi(\ke)$ are extended with $\txid$.
For every write operation $(\otW, \ke, \val)$ in fingerprint $\opset$, the $\mkvs(\ke)$ entry is extended with a new version $(\val, \txid, \emptyset)$, denoting that $\txid$ is responsible for creating this version which has no readers as of yet. 

Once the MKVS is updated to $\mkvs'$, the client subsequently updates its view $\vi''$ with respect to its fingerprint via the $\func{updateView}{\mkvs', \vi'', \opset}$ function, defined in \cref{fig:thread_semantics}.
Whilst the client does not need to update its view for those keys it has read from, 
%for each key $\ke$ that the client has written to, 
it must update its view to the \emph{latest} version available for those keys it has written to. %$\ke$. 
This definition of $\funcFont{updateView}$ imposes a lower bound on the updated view by ensuring that the view of the client is up-to-date for all those keys it has written to. 
This in turn guarantees a strong program order, meaning that the following transactions of the same client will at least read the previous writes of the client  itself.
Assuming that client commands are wrapped within a single session, this lower bound of the view corresponds to the strong session guarantees introduced by \cite{.........}.
%\azalea{I have rewritten this whole section. However, I don't quite understand the motivation behind $\func{updateView}{\mkvs', \vi'', \opset}$. Please elaborate.}

The updated view of the client may then be advanced to a newer view $\vi'$.
Lastly, to ensure that the effect of the transaction (its fingerprint  $\opset$) is permitted by the underlying consistency model, 
the final premise of the transition requires that the updates be permitted by the execution test $\ET$, \ie \( (\mkvs, \vi'') \etto \opset : \vi'\).





%First, the view can shift to later versions before executing the transaction to model the client might gain more information about the key-value store since its last commit.
%To recall The order between two views with the same domain, for example \( \vi'' \geq \vi \) in \rl{PCommit}, is defined by the order of the indexes (\cref{def:views}).
%This new local view \( \vi'' \) should also be consistent with the key-value stores, \ie it leads to a situation where the current client is allowed to execute the transaction.
%The transaction code \( \trans \) is executed locally given an initial snapshot \( \sn = \clpsHH{\hh, \vi''}\) (\cref{def:snapshot}) decided by the current state of key-value store \( \mkvs \) and the local view \( \vi'' \).
%The \( \funcn{localHeap} \) function uniquely determined a (local) heap from a history heap and a view by picking the versions of addresses indexed by the view.
%After local execution via the semantics for transactions (\cref{fig:transaction_semantics}), we propagate the stack \( \stk' \) and more importantly obtain the fingerprints \( \opset \), while the snapshot \( \sn' \) will be throw away.
%Then the transaction picks a fresh identifier \( \txid \), \ie one that does not appear in the key-value store, and commits the fingerprint \( \opset \), which will update the key-value store and local view.
%%The operation set includes the first read and last write of each key, which are the operations might affect the key-value store, because of the atomicity of transactions.
%The \funcn{updateMKVS} function updates the history heap using the fingerprint, \( \mkvs' = \func{updateMKVS}{\mkvs,\vi'',\txid, \opset}\).
%For read operations, it includes the new identifier to the read set of the version the is pointed by the local view \( \vi''\).
%For write operations of the form \( (\otW, \ke, \nat) \), it extends a new version written by the new transaction \( (\nat, \txid, \emptyset) \) to the tail of \( \mkvs(\ke) \).
%For updating the view, we set a lower bound for the new local view by \funcn{updateView} function.
%Assuming the commands executed by clients are wrapped with in a single session, the lower bound of the view corresponds to the strong session guarantees introduced by \cite{.........}.
%This function shifts the view to the up-to-date version in the new key-value store if the version is installed by the current transaction.
%This guarantees strong program order, meaning the following transaction will at least read its own write.
%Finally, the actual new local view \( \vi' \) is any view greater than the lower bound \( \vi' \geq \func{updateView}{\mkvs', \vi'', \opset}\).
%The overall execution satisfied the execution tests, \ie \( (\mkvs, \vi'') \etto \opset : \vi'\).

\ac{The paragraph below should probably go when discussing the rules of the semantics:

Note that the way in which MKVSs and views are updated ensure the following: 
$\bullet$ a client always reads its own preceding writes; 
$\bullet$ clients always read from an increasingly up-to-date state of the database; 
$\bullet$ the order in which clients update a key $\key{k}$ is consistent with the 
order of the versions for such keys in the MKVS; 
$\bullet$ writes take place after reads on which they depend. 
}



\mypar{Program Operational Semantics}
The \emph{operational semantics of programs} are given at the bottom of \cref{fig:program_semantics}. 
Programs transitions are of the form $(\conf,  \thdenv, \prog) \ \toG{\como} (\conf',  \thdenv', \prog')$,
stating that given the configuration $\mkvs$ and the \emph{client environment} $\thdenv$, executing program $\prog$ for one step under $\como$, updates the configuration to $\conf'$, the client environment to $\thdenv'$, and the program to its continuation $\prog'$. 
A \emph{client environment}, $\thdenv \in \ThdEnv$, tracks the local variable stack ($\stack$). 
That is, a client environment is a mapping from client identifiers to pairs of stacks and views. 
We assume that the client identifiers in the domain of client environments are are those in the domain of the program throughout the execution. 
%$\prog$: $\dom(\thdenv) = \dom(\prog)$; and that 
Program transitions are simply defined in terms of the transitions of their constituent client commands, defined by $\toT{\como}$. 
This in turn yields the standard interleaving semantics for concurrent programs. 

%Last, the program has standard interleaving semantics by picking a client and then progressing one step (\cref{fig:thread_pool_semantics}).
%To achieve that a thread environment holds the stacks and views associated with all active clients \( Env \in \sort{ThdEnv} \).
%We assume the client identifiers from client environment match with those in the program \( \prog \).
%We also assume all the stacks and views initially are the same respectively.



\begin{lemma}
\label{lem:hhupdate.welldefined}
%The function $\HHupdate$ is well-defined over well-formed MKVS, fingerprints and views. 
Given a well-formed MKVS $\hh$, a view $\vi$ that is well-formed with respect to \( \mkvs \), a fingerprint \( \opset \), and a $\txid$ that does not appear in $\hh$, then $\HHupdate(\hh, \opset, \tsid, \vi)$ is uniquely determined and yields a well-formed MKVS.
\end{lemma}

\begin{lemma}
%The function $\Vupdate$ is well-defined.
Given a well-formed MKVS $\hh$, a view $\vi$ that is well-formed with respect to \( \mkvs \), and a fingerprint \( \opset \), the $\Vupdate(\hh, \opset, \vi)$ uniquely determines a view which is well-formed with respect to $\mkvs$.
\end{lemma}

%\begin{lem}[Confluence of \funcn{updateMKVS} and \funcn{updateView}]
%Given a valid operation set \( \opset \), the order of applying \( \funcn{updateMKVS} \) function (\( \funcn{updateView} \) function) to the elements from operation set does not affect the final result.
%\end{lem}
                                                                                                         
