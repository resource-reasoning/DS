\subsection{Consistent Prefix} 
%\begin{figure}
%\begin{center}
%\begin{tabular}{|@{}c|c@{}|}
%\hline
%\begin{tikzpicture}[font=\large]

%\begin{pgfonlayer}{foreground}
%%Uncomment line below for help lines
%%\draw[help lines] grid(5,4);

%%Location x
%\node(locx) at (1,3) {$[\loc_x] \mapsto$};

%\matrix(locxcells) [version list, text width=7mm, anchor=west]
   %at ([xshift=10pt]locx.east) {
 %{a} & $T_0$ \\
  %{a} & $\emptyset$ \\
%};
%\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
%%\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};

%%Location y
%\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
%\matrix(locycells) [version list, text width=7mm, anchor=west]
   %at ([xshift=10pt]locy.east) {
 %{a} & $T_0$ \\
  %{a} & $\emptyset$ \\
%};
%\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
%%\node[version node, fit=(locycells-1-3) (locycells-2-3), fill=white, inner sep=0cm, font=\Large] (locy-v1) {$1$};

%% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
%\draw[-, blue, very thick, rounded corners=10pt]
 %([xshift=-3pt, yshift=20pt]locx-v0.north east) node (tid1start) {} -- 
%% ([xshift=-2pt, yshift=-5pt]locx-v0.south east) --
%% ([xshift=-2pt, yshift=5pt]locy-v0.north east) -- 
 %([xshift=-3pt, yshift=-5pt]locy-v0.south east);
 
 %\path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\thid_1$};

%%red view
%\draw[-, red, very thick, rounded corners = 10pt]
 %([xshift=-16pt, yshift=5pt]locx-v0.north east) node (tid2start) {}-- 
%% ([xshift=-8pt, yshift=-5pt]locx-v0.south east) --
%% ([xshift=-8pt, yshift=5pt]locy-v0.north east) -- 
 %([xshift=-16pt, yshift=-5pt]locy-v0.south east) node {};
 
%\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\thid_2$};

%%%Stack for threads tid_1 and tid_2
%%
%%\draw[-, dashed] let 
%%   \p1 = ([xshift=0pt]locy.west),
%%   \p2 = ([yshift=-5pt]locycells.south),
%%   \p3 = ([xshift=10pt]locycells.east) in
%%   (\x1, \y2) -- (\x3, \y2);
%%   
%%\matrix(stacks) [
%%   matrix of nodes,
%%   anchor=north, 
%%   text=blue, 
%%   font=\normalsize, 
%%   row 1/.style = {text = blue}, 
%%   row 2/.style = {text = red}, 
%%   text width= 13mm ] 
%%   at ([xshift=-10pt,yshift=-8pt]locycells.south) {
%%   $\thid_1:$ & $\retvar = 0$\\
%%   $\thid_2:$ & $\retvar = 0$\\
%%   };
%\end{pgfonlayer}
%\end{tikzpicture} 
%%
%&
%%
%\begin{tikzpicture}[font=\large]

%\begin{pgfonlayer}{foreground}
%%Uncomment line below for help lines
%%\draw[help lines] grid(5,4);

%%Location x
%\node(locx) at (1,3) {$[\loc_x] \mapsto$};

%\matrix(locxcells) [version list, text width=7mm, anchor=west]
   %at ([xshift=10pt]locx.east) {
 %{a} & $T_0$ & {a} & $\tsid_1$\\
  %{a} & $\emptyset$ & {a} & $\emptyset$ \\
%};
%\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
%\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};

%%Location y
%\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
%\matrix(locycells) [version list, text width=7mm, anchor=west]
   %at ([xshift=10pt]locy.east) {
 %{a} & $T_0$ \\
  %{a} & $\emptyset$ \\
%};
%\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
%%\node[version node, fit=(locycells-1-3) (locycells-2-3), fill=white, inner sep=0cm, font=\Large] (locy-v1) {$1$};

%% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
%\draw[-, blue, very thick, rounded corners=10pt]
 %([xshift=-3pt, yshift=20pt]locx-v1.north east) node (tid1start) {} -- 
 %([xshift=-3pt, yshift=-5pt]locx-v1.south east) --
 %([xshift=-3pt, yshift=5pt]locy-v0.north east) -- 
 %([xshift=-3pt, yshift=-5pt]locy-v0.south east);
 
 %\path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\thid_1$};

%%red view
%\draw[-, red, very thick, rounded corners = 10pt]
 %([xshift=-16pt, yshift=5pt]locx-v0.north east) node (tid2start) {}-- 
%% ([xshift=-8pt, yshift=-5pt]locx-v0.south east) --
%% ([xshift=-8pt, yshift=5pt]locy-v0.north east) -- 
 %([xshift=-16pt, yshift=-5pt]locy-v0.south east) node {};
 
%\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\thid_2$};

%%%Stack for threads tid_1 and tid_2
%%
%%\draw[-, dashed] let 
%%   \p1 = ([xshift=0pt]locy.west),
%%   \p2 = ([yshift=-5pt]locycells.south),
%%   \p3 = ([xshift=10pt]locycells.east) in
%%   (\x1, \y2) -- (\x3, \y2);
%%   
%%\matrix(stacks) [
%%   matrix of nodes,
%%   anchor=north, 
%%   text=blue, 
%%   font=\normalsize, 
%%   row 1/.style = {text = blue}, 
%%   row 2/.style = {text = red}, 
%%   text width= 13mm ] 
%%   at ([xshift=-10pt,yshift=-8pt]locycells.south) {
%%   $\thid_1:$ & $\retvar = 0$\\
%%   $\thid_2:$ & $\retvar = 0$\\
%%   };
%\end{pgfonlayer}
%\end{tikzpicture}
%\\
%{\small(a)} & {\small(b)}\\
%\hline

%\begin{pgfonlayer}{foreground}
%%Uncomment line below for help lines
%%\draw[help lines] grid(5,4);

%%Location x
%\node(locx) at (1,3) {$[\loc_x] \mapsto$};

%\matrix(locxcells) [version list, text width=7mm, anchor=west]
   %at ([xshift=10pt]locx.east) {
 %{a} & $T_0$ & {a} & $\tsid_1$\\
  %{a} & $\emptyset$ & {a} & $\emptyset$ \\
%};
%\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
%\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};

%%Location y
%\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
%\matrix(locycells) [version list, text width=7mm, anchor=west]
   %at ([xshift=10pt]locy.east) {
 %{a} & $T_0$ & {a} & $\tsid_2$ \\
  %{a} & $\emptyset$ & {a} & $\emptyset$\\
%};
%\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
%\node[version node, fit=(locycells-1-3) (locycells-2-3), fill=white, inner sep=0cm, font=\Large] (locy-v1) {$1$};

%% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
%\draw[-, blue, very thick, rounded corners=10pt]
 %([xshift=-3pt, yshift=20pt]locx-v1.north east) node (tid1start) {} -- 
 %([xshift=-3pt, yshift=-5pt]locx-v1.south east) --
 %([xshift=-3pt, yshift=5pt]locy-v0.north east) -- 
 %([xshift=-3pt, yshift=-5pt]locy-v0.south east);
 
 %\path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\thid_1$};

%%red view
%\draw[-, red, very thick, rounded corners = 10pt]
 %([xshift=-16pt, yshift=5pt]locx-v0.north east) node (tid2start) {}-- 
 %([xshift=-16pt, yshift=-5pt]locx-v0.south east) --
 %([xshift=-16pt, yshift=5pt]locy-v1.north east) -- 
 %([xshift=-16pt, yshift=-5pt]locy-v1.south east) node {};
 
%\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\thid_2$};

%%%Stack for threads tid_1 and tid_2
%%
%%\draw[-, dashed] let 
%%   \p1 = ([xshift=0pt]locy.west),
%%   \p2 = ([yshift=-5pt]locycells.south),
%%   \p3 = ([xshift=10pt]locycells.east) in
%%   (\x1, \y2) -- (\x3, \y2);
%%   
%%\matrix(stacks) [
%%   matrix of nodes,
%%   anchor=north, 
%%   text=blue, 
%%   font=\normalsize, 
%%   row 1/.style = {text = blue}, 
%%   row 2/.style = {text = red}, 
%%   text width= 13mm ] 
%%   at ([xshift=-10pt,yshift=-8pt]locycells.south) {
%%   $\thid_1:$ & $\retvar = 0$\\
%%   $\thid_2:$ & $\retvar = 0$\\
%%   };
%\end{pgfonlayer}
%\end{tikzpicture}
%%
%&
%%
%\begin{tikzpicture}[font=\large]

%\begin{pgfonlayer}{foreground}
%%Uncomment line below for help lines
%%\draw[help lines] grid(5,4);

%%Location x
%\node(locx) at (1,3) {$[\loc_x] \mapsto$};

%\matrix(locxcells) [version list, text width=7mm, anchor=west]
   %at ([xshift=10pt]locx.east) {
 %{a} & $T_0$ & {a} & $\tsid_1$\\
  %{a} & $\{\tsid_4\}$ & {a} & $\emptyset$ \\
%};
%\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
%\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};

%%Location y
%\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
%\matrix(locycells) [version list, text width=7mm, anchor=west]
   %at ([xshift=10pt]locy.east) {
 %{a} & $T_0$ & {a} & $\tsid_2$ \\
  %{a} & $\{\tsid_3\}$ & {a} & $\emptyset$\\
%};
%\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
%\node[version node, fit=(locycells-1-3) (locycells-2-3), fill=white, inner sep=0cm, font=\Large] (locy-v1) {$1$};

%% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
%\draw[-, blue, very thick, rounded corners=10pt]
 %([xshift=-3pt, yshift=20pt]locx-v1.north east) node (tid1start) {} -- 
%% ([xshift=-3pt, yshift=-5pt]locx-v1.south east) --
%% ([xshift=-3pt, yshift=5pt]locy-v0.north east) -- 
 %([xshift=-3pt, yshift=-5pt]locy-v1.south east);
 
 %\path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\thid_1$};

%%red view
%\draw[-, red, very thick, rounded corners = 10pt]
 %([xshift=-16pt, yshift=5pt]locx-v1.north east) node (tid2start) {}-- 
%% ([xshift=-16pt, yshift=-5pt]locx-v0.south east) --
%% ([xshift=-16pt, yshift=5pt]locy-v1.north east) -- 
 %([xshift=-16pt, yshift=-5pt]locy-v1.south east) node {};
 
%\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\thid_2$};

%%%Stack for threads tid_1 and tid_2
%%
%%\draw[-, dashed] let 
%%   \p1 = ([xshift=0pt]locy.west),
%%   \p2 = ([yshift=-5pt]locycells.south),
%%   \p3 = ([xshift=10pt]locycells.east) in
%%   (\x1, \y2) -- (\x3, \y2);
%%   
%%\matrix(stacks) [
%%   matrix of nodes,
%%   anchor=north, 
%%   text=blue, 
%%   font=\normalsize, 
%%   row 1/.style = {text = blue}, 
%%   row 2/.style = {text = red}, 
%%   text width= 13mm ] 
%%   at ([xshift=-10pt,yshift=-8pt]locycells.south) {
%%   $\thid_1:$ & $\retvar = 0$\\
%%   $\thid_2:$ & $\retvar = 0$\\
%%   };
%\end{pgfonlayer}
%\end{tikzpicture}
%\\
%{\small(c)} & {\small(d)}\\
%\hline
%\begin{tikzpicture}[font=\large]

%\begin{pgfonlayer}{foreground}
%%Uncomment line below for help lines
%%\draw[help lines] grid(5,4);

%%Location x
%\node(locx) at (1,3) {$[\loc_x] \mapsto$};

%\matrix(locxcells) [version list, text width=7mm, anchor=west]
   %at ([xshift=10pt]locx.east) {
 %{a} & $T_0$ & {a} & $\tsid_1$\\
  %{a} & $\emptyset$ & {a} & $\emptyset$ \\
%};
%\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
%\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};

%%Location y
%\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
%\matrix(locycells) [version list, text width=7mm, anchor=west]
   %at ([xshift=10pt]locy.east) {
 %{a} & $T_0$ & {a} & $\tsid_2$ \\
  %{a} & $\emptyset$ & {a} & $\emptyset$\\
%};
%\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
%\node[version node, fit=(locycells-1-3) (locycells-2-3), fill=white, inner sep=0cm, font=\Large] (locy-v1) {$1$};

%% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
%\draw[-, blue, very thick, rounded corners=10pt]
 %([xshift=-3pt, yshift=20pt]locx-v1.north east) node (tid1start) {} -- 
 %([xshift=-3pt, yshift=-5pt]locx-v1.south east) --
 %([xshift=-3pt, yshift=5pt]locy-v0.north east) -- 
 %([xshift=-3pt, yshift=-5pt]locy-v0.south east);
 
 %\path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\thid_1$};

%%red view
%\draw[-, red, very thick, rounded corners = 10pt]
 %([xshift=-16pt, yshift=5pt]locx-v1.north east) node (tid2start) {}-- 
%% ([xshift=-16pt, yshift=-5pt]locx-v0.south east) --
%% ([xshift=-16pt, yshift=5pt]locy-v1.north east) -- 
 %([xshift=-16pt, yshift=-5pt]locy-v1.south east) node {};
 
%\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\thid_2$};

%%%Stack for threads tid_1 and tid_2
%%
%%\draw[-, dashed] let 
%%   \p1 = ([xshift=0pt]locy.west),
%%   \p2 = ([yshift=-5pt]locycells.south),
%%   \p3 = ([xshift=10pt]locycells.east) in
%%   (\x1, \y2) -- (\x3, \y2);
%%   
%%\matrix(stacks) [
%%   matrix of nodes,
%%   anchor=north, 
%%   text=blue, 
%%   font=\normalsize, 
%%   row 1/.style = {text = blue}, 
%%   row 2/.style = {text = red}, 
%%   text width= 13mm ] 
%%   at ([xshift=-10pt,yshift=-8pt]locycells.south) {
%%   $\thid_1:$ & $\retvar = 0$\\
%%   $\thid_2:$ & $\retvar = 0$\\
%%   };
%\end{pgfonlayer}
%\end{tikzpicture}
%&
%\begin{tikzpicture}[font=\large]

%\begin{pgfonlayer}{foreground}
%%Uncomment line below for help lines
%%\draw[help lines] grid(5,4);

%%Location x
%\node(locx) at (1,3) {$[\loc_x] \mapsto$};

%\matrix(locxcells) [version list, text width=7mm, anchor=west]
   %at ([xshift=10pt]locx.east) {
 %{a} & $T_0$ & {a} & $\tsid_1$\\
  %{a} & $\emptyset$ & {a} & $\{\tsid_4\}$ \\
%};
%\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
%\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};

%%Location y
%\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
%\matrix(locycells) [version list, text width=7mm, anchor=west]
   %at ([xshift=10pt]locy.east) {
 %{a} & $T_0$ & {a} & $\tsid_2$ \\
  %{a} & $\{\tsid_3\}$ & {a} & $\emptyset$\\
%};
%\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
%\node[version node, fit=(locycells-1-3) (locycells-2-3), fill=white, inner sep=0cm, font=\Large] (locy-v1) {$1$};

%% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
%\draw[-, blue, very thick, rounded corners=10pt]
 %([xshift=-3pt, yshift=20pt]locx-v1.north east) node (tid1start) {} -- 
%% ([xshift=-3pt, yshift=-5pt]locx-v1.south east) --
%% ([xshift=-3pt, yshift=5pt]locy-v0.north east) -- 
 %([xshift=-3pt, yshift=-5pt]locy-v1.south east);
 
 %\path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\thid_1$};

%%red view
%\draw[-, red, very thick, rounded corners = 10pt]
 %([xshift=-16pt, yshift=5pt]locx-v1.north east) node (tid2start) {}-- 
%% ([xshift=-16pt, yshift=-5pt]locx-v0.south east) --
%% ([xshift=-16pt, yshift=5pt]locy-v1.north east) -- 
 %([xshift=-16pt, yshift=-5pt]locy-v1.south east) node {};
 
%\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\thid_2$};

%%%Stack for threads tid_1 and tid_2
%%
%%\draw[-, dashed] let 
%%   \p1 = ([xshift=0pt]locy.west),
%%   \p2 = ([yshift=-5pt]locycells.south),
%%   \p3 = ([xshift=10pt]locycells.east) in
%%   (\x1, \y2) -- (\x3, \y2);
%%   
%%\matrix(stacks) [
%%   matrix of nodes,
%%   anchor=north, 
%%   text=blue, 
%%   font=\normalsize, 
%%   row 1/.style = {text = blue}, 
%%   row 2/.style = {text = red}, 
%%   text width= 13mm ] 
%%   at ([xshift=-10pt,yshift=-8pt]locycells.south) {
%%   $\thid_1:$ & $\retvar = 0$\\
%%   $\thid_2:$ & $\retvar = 0$\\
%%   };
%\end{pgfonlayer}
%\end{tikzpicture}
%\\
%{\small(e)} & {\small(f)}\\
%\hline
%\end{tabular}
%\end{center}
%\caption{Configurations obtained throughout an execution of 
%$\prog_4$.}
%\label{fig:cp.exec}
%\end{figure}

The next consistency model that we illustrate is \emph{consistent prefix}. 
It ensures that once a thread observes the effects of some transaction $\txid$, it also observes all the transactions that were committed before $\txid$. 
\sx{why different locations}
Another way to express this property is that two different transactions never observe the updates to different addresses in a different order.

Consider the program $\prog_4$ below,
 \[
    \prog_4 \equiv  
    \left( 
    \begin{session} 
        \begin{array}{@{}c || c @{}}
            \begin{session} 
            \txid_1 : 
            \begin{transaction}
                \pmutate{\vx}{1};\\
            \end{transaction}; \\
            
            \txid_3 :
            \begin{transaction}
              	\pderef{\pvar{a}}{\vy};\\
              	\pifs{\pvar{a}=0}\\
                    \quad \passign{\retvar}{\Large \frownie{}} 
                \pife 
            \end{transaction}
            \end{session}
            &
            \begin{session}
            \txid_2 :
            \begin{transaction}
                \pmutate{\vy}{1};\\
            \end{transaction} ; \\
            
            \txid_4 :
            \begin{transaction}
              	\pderef{\pvar{a}}{\vx};\\
              	\pifs{\pvar{a}=0}\\
              		\quad \passign{\retvar}{\Large \frownie{}} 
                \pife
            \end{transaction}
            \end{session}
        \end{array}
    \end{session}
    \right)
 \]

We argue that, under $\mathsf{RA}$, it is possible to obtain an execution 
of program $\prog_4$ where both $\ptrans{\trans_2}$ and $\ptrans{\trans_4}$ 
return value ${\Large \frownie{}}$.
Such an execution can be summarised as follows: 

\begin{itemize}
\item initially, $\thid_1$ executes transaction $\ptrans{\trans_1}$, 
leading to the configuration of Figure \ref{fig:cp.exec}(b), and the program 
$\ptrans{\trans_2} \ppar \ptrans{\trans_3} ; \ptrans{\trans_4}$ to be 
executed, 
\item then $\thid_2$ executes transaction $\ptrans{\trans_3}$, leading 
to the configuration of Figure \ref{fig:cp.exec}(c); the remaining 
program to be executed is $\ptrans{\trans_3} \ppar \ptrans{\trans_4}$, 
\item without changing its view, $\thid_1$ executes transaction $\ptrans{\trans_2}$. 
The code $\trans_2$ is executed using the heap $[ [\loc_x] \mapsto 1, [\loc_y] \mapsto 0]$ 
as a snapshot; this means that, by executing $\trans_2$, the variable $\retvar$ of the thread-local 
stack of $\thid_1$ is set to ${\Large \frownie{}}$. Next, the thread $\thid_2$ executes $\ptrans{\trans_4}$ 
without altering its view. Similarly to the execution of $\ptrans{\trans_2}$ in $\thid_1$, this causes the 
$\retvar$ variable of the thread-local stack of $\thid_2$ to be set to ${\Large \frownie{}}$. At this point, 
the final configuration of the program is the one given in Figure \ref{fig:cp.exec}(d).
\end{itemize}

\sx{What is different update ?}
To avoid different threads to observe different updates in different orders, we impose a constraint known as \emph{consistent prefix}.
\sx{ why centralised? 
in a centralised database, where 
transactions have a start and a commit point, 
}
Assuming a transaction has a start and commit point, \emph{consistent prefix} requires that if a transaction $\txid_1$ observes the effects of another transaction $\txid_2$, then it must observe the effects of any other transaction that committed before $\txid_2$.
In the history heaps framework, transactions are executed in a single step in the semantics,
\sx{
this constraint can be formalised as follows: 
\emph{If a transaction $\tsid_1$ observes the effects of another transaction $\tsid_2$, then it must 
observe the effects of any transaction that committed before $\tsid_2$.}
}
In the history heaps framework, transactions are executed in a single step and the step corresponds to the commit order.
Thus, upon the read atomic (\defref{def:readatomic}), \emph{consistent prefix} requires once a thread commits a transaction, it pushes the view to be up-to-date with the state of the database, so the following transactions from the thread will observe the effects of all transactions committed before \( \txid \) included.
\sx{It is easy to see the definition match the intuition when inside a thread, but not easy to see cross-thread. There is something I feel subtle but dont know what it is and I feel it is actually already included in the definition.}

\sx{ dont understand:
In the history heaps framework, transactions are executed in a single step; 
however, one may think of the order in which transactions execute in our 
operational semantics to be consistent with the order in which 
transactions commit (this correspondence will be made precise later in 
the document, when we will relate executions in our operational semantics 
to abstract executions used in the declarative style for specifications of 
consistency models). By requiring that, after a thread $\thid$ executes 
a transaction $\tsid$, it pushes its own view to be up-to-date with the state of 
the system, we model the fact that any future transaction executed 
by $\thid$ will observe the effects of anything that committed before 
$\tsid$ (included).
}

\begin{defn}[consistent prefix]
\label{def:consistent-prefix}
The \emph{consistent prefix} is stronger than read atomic (\defref{def:readatomic}) by further requiring the view after pushes to the latest for all addresses, 
\[
\begin{rclarray}
    (\hh, \vi) \csat[\mathsf{CP}] \opset: \vi' & \defeq &  (\hh, \vi) \csat[\mathsf{RA}] \opset: \vi' \land \fora{\addr \in \dom(\hh)} \vi'(\addr) = \left| \hh(\addr) \right| \\
\end{rclarray}
\]
\sx{
We say that $(hh, V) \triangleright_{\mathsf{CP}} \mathcal{O}: V'$ 
if and only if $(\hh, V) \triangleright_{\mathsf{RA}} \mathcal{O}: V'$, 
and for any location $[\loc_x]$, $V'([\loc_x]) = \lvert \mathsf{HHeapUpdate}(\hh, V, \mathcal{O}) \rvert -1$. 
}
\end{defn}


\sx{did not read} 
Consider again th program $\prog_4$, ths time to be executed 
under $\mathsf{CP}$. We argue that in this case it is not possible to have both 
threads $\thid_1$ and $\thid_2$ to set the value of $\retvar$ to ${\Large \frownie{}}$. 
The initial configuration in which the program $\prog_4$ is executed is 
the one depicted in Figure \ref{fig:cp.exec}(a). Initially, either thread $\thid_1$ executes 
the code $\ptrans{\trans_1}$, or thread $\thid_2$ executes transaction $\ptrans{\trans_3}$; without 
loss of generality, we consider the former option (the case in which $\thid_2$ executes 
first is symmetric). Upon executing the code $\ptrans{\trans_1}$, we obtain the 
configuration of Figure \ref{fig:cp.exec}(b), with the program $\ptrans{\trans_2} \ppar (\ptrans{\trans_3} ; \ptrans{\trans_4})$ 
to be executed next.
At this point, note that under $\mathsf{CP}$ it is not possible for $\thid_2$ to execute $\ptrans{\trans_3}$ and obtain 
the configuration of Figure \ref{fig:cp.exec}(c) as a result. This is because, in $\mathsf{CP}$, we require the view of $\thid_2$ 
\textbf{after} executing $\ptrans{\trans_3}$ to be up-to-date, i.e. to point to the last location of each version. That is, 
assuming that $\thid_2$ executes $\ptrans{\trans_3}$ next, we obtain the configuration of Figure \ref{fig:cp.exec}(e). 
From this point on, whenever $\thid_2$ will execute transaction $\ptrans{\trans_4}$, it will read value $1$ for 
location $[\loc_x]$, hence it won't be able to set the value of $\retvar$ to ${\Large \frownie{}}$. One possible 
final configuration for the program is given in Figure \ref{fig:cp.exec}(f).

%\begin{definition}
%$(\hh, V, \mathcal{V}) \triangleright_{\mathsf{CP}} \mathcal{O}$ iff 
%$(\hh, V, \mathcal{V}) \triangleright_{\mathsf{RA}} \mathcal{O}$, 
%and for any $V' \in \mathcal{V}$, either $V' \sqsubseteq V$ or 
%$V \sqsubseteq V'$.
%\end{definition}
%\ac{I found that this is a very easy way to encode consistent 
%prefix. In English, a thread can execute a transaction if its view does 
%not cross with the views of any other thread.}

%\ac{Very Important - note to self: It seems that the condition of 
%requiring that views do not cross before executing a transaction 
%does not suffice to model snapshot isolation. In fact, it seems that 
%consistent prefix (when transaction are limited to either one read 
%or one write) coincides with TSO.
%Update, it seems that the condition that I need for Snapshot Isolation 
%(besides write confict detection) is that, after you execute a transaction, 
%you bring your view up-to-date. (So here I have to concede that I was wrong, 
%and the state of the view after you execute a transaction is actually important).\\
%
%}
