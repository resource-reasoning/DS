\subsection{Consistent Prefix} 
\begin{figure}[!t]
\hrule
\begin{center}
\begin{tabular}{@{}c c c @{} }
\begin{halfsubfig}
\begin{centertikz}

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\ke_\vx \mapsto$};

\matrix(versionx) [version list]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ \\
    {a} & $\emptyset$ \\
};

\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{0};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_\vy \mapsto$};
\matrix(versiony) [version list]
    at ([xshift=\tikzkvspace]locy.east) {
    {a} & $\txid_0$ \\
    {a} & $\emptyset$ \\
};
\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{0};

% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
([xshift=-3pt, yshift=20pt]locx-v0.north east) node (tid1start) {} -- 
([xshift=-3pt, yshift=-5pt]locy-v0.south east);

\path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\thid_1$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
([xshift=-16pt, yshift=5pt]locx-v0.north east) node (tid2start) {}-- 
([xshift=-16pt, yshift=-5pt]locy-v0.south east) node {};
 
\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\thid_2$};

\end{pgfonlayer}
\end{centertikz}%
\caption{Initial configuration}
\label{fig:prefix-init}
\end{halfsubfig}
%
&
%
\begin{halfsubfig}
\begin{centertikz}

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\ke_\vx \mapsto$};

\matrix(versionx) [version list]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\tsid_1$\\
    {a} & $\emptyset$ & {a} & $\emptyset$ \\
};

\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{0};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{1};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_\vy \mapsto$};
\matrix(versiony) [version list]
    at ([xshift=\tikzkvspace]locy.east) {
    {a} & $\txid_0$ \\
    {a} & $\emptyset$ \\
};
\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{0};

%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
([xshift=-3pt, yshift=20pt]locx-v1.north east) node (tid1start) {} -- 
([xshift=-3pt, yshift=-5pt]locx-v1.south east) --
([xshift=-3pt, yshift=5pt]locy-v0.north east) -- 
([xshift=-3pt, yshift=-5pt]locy-v0.south east);

\path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\thid_1$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
([xshift=-16pt, yshift=5pt]locx-v0.north east) node (tid2start) {}-- 
([xshift=-16pt, yshift=-5pt]locy-v0.south east) node {};
 
\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\thid_2$};

\end{pgfonlayer}
\end{centertikz}%
\caption{After \( \txid_1 \)}
\label{fig:prefix-after-tx1}
\end{halfsubfig}
&
\begin{halfsubfig}
\begin{centertikz}

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\ke_\vx \mapsto$};

\matrix(versionx) [version list]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\tsid_1$\\
    {a} & $\emptyset$ & {a} & $\emptyset$ \\
};

\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{0};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{1};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_\vy \mapsto$};
\matrix(versiony) [version list]
    at ([xshift=\tikzkvspace]locy.east) {
    {a} & $\txid_0$ & {a} & $\tsid_2$ \\
    {a} & $\emptyset$ & {a} & $\emptyset$\\
};
\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{0};
\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{1};

%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
([xshift=-3pt, yshift=20pt]locx-v1.north east) node (tid1start) {} -- 
([xshift=-3pt, yshift=-5pt]locx-v1.south east) --
([xshift=-3pt, yshift=5pt]locy-v0.north east) -- 
([xshift=-3pt, yshift=-5pt]locy-v0.south east);

\path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\thid_1$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
([xshift=-16pt, yshift=5pt]locx-v0.north east) node (tid2start) {}-- 
([xshift=-16pt, yshift=-5pt]locx-v0.south east) --
([xshift=-16pt, yshift=5pt]locy-v1.north east) -- 
([xshift=-16pt, yshift=-5pt]locy-v1.south east) node {};

\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\thid_2$};

\end{pgfonlayer}
\end{centertikz}%
\caption{After \( \txid_2\)}
\label{fig:prefix-after-tx2}
\end{halfsubfig}
%
\\
%
\begin{halfsubfig}
\begin{centertikz}

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\ke_\vx \mapsto$};

\matrix(versionx) [version list]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\tsid_1$\\
    {a} & $\Set{\txid_4}$ & {a} & $\emptyset$ \\
};

\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{0};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{1};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_\vy \mapsto$};
\matrix(versiony) [version list]
    at ([xshift=\tikzkvspace]locy.east) {
    {a} & $\txid_0$ & {a} & $\tsid_2$ \\
    {a} & $\Set{\txid_3}$ & {a} & $\emptyset$\\
};
\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{0};
\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{1};
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);


%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
([xshift=-3pt, yshift=20pt]locx-v1.north east) node (tid1start) {} -- 
([xshift=-3pt, yshift=-5pt]locy-v1.south east);
 
\path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\thid_1$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
([xshift=-16pt, yshift=5pt]locx-v1.north east) node (tid2start) {}-- 
([xshift=-16pt, yshift=-5pt]locy-v1.south east) node {};
 
\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\thid_2$};

\end{pgfonlayer}
\end{centertikz}%
\caption{transaction \( \txid_3 \) and \( \txid_4 \) both returning \( \sadface \)}
\label{fig:prefix-sadface}
\end{halfsubfig} 
&
\begin{halfsubfig}
\begin{centertikz}

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\ke_\vx \mapsto$};

\matrix(versionx) [version list]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\tsid_1$\\
    {a} & $\emptyset$ & {a} & $\emptyset$ \\
};

\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{0};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{1};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_\vy \mapsto$};
\matrix(versiony) [version list]
    at ([xshift=\tikzkvspace]locy.east) {
    {a} & $\txid_0$ & {a} & $\tsid_2$ \\
    {a} & $\emptyset$ & {a} & $\emptyset$\\
};
\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{0};
\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{1};


% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
([xshift=-3pt, yshift=20pt]locx-v1.north east) node (tid1start) {} -- 
([xshift=-3pt, yshift=-5pt]locx-v1.south east) --
([xshift=-3pt, yshift=5pt]locy-v0.north east) -- 
([xshift=-3pt, yshift=-5pt]locy-v0.south east);

\path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\thid_1$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
([xshift=-16pt, yshift=5pt]locx-v1.north east) node (tid2start) {}-- 
([xshift=-16pt, yshift=-5pt]locy-v1.south east) node {};
 
\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\thid_2$};

\end{pgfonlayer}
\end{centertikz}%
\caption{The client \( \cl_2\) advance the view}
\label{fig:prefix-cl2-update-view}
\end{halfsubfig}
&
\begin{halfsubfig}
\begin{centertikz}

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\ke_\vx \mapsto$};

\matrix(versionx) [version list]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\tsid_1$\\
    {a} & $\emptyset$ & {a} & $\Set{\txid_4}$ \\
};

\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{0};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{1};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_\vy \mapsto$};
\matrix(versiony) [version list]
    at ([xshift=\tikzkvspace]locy.east) {
    {a} & $\txid_0$ & {a} & $\tsid_2$ \\
    {a} & $\Set{\txid_3}$ & {a} & $\emptyset$\\
};
\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{0};
\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{1};

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
([xshift=-3pt, yshift=20pt]locx-v1.north east) node (tid1start) {} -- 
([xshift=-3pt, yshift=-5pt]locy-v1.south east);

\path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\thid_1$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
([xshift=-16pt, yshift=5pt]locx-v1.north east) node (tid2start) {}-- 
([xshift=-16pt, yshift=-5pt]locy-v1.south east) node {};

\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\thid_2$};

\end{pgfonlayer}
\end{centertikz}%
\caption{After \( \txid_3\) and \( \txid_4\)}
\label{fig:prefix-after-tx34}
\end{halfsubfig}
\end{tabular}
\end{center}
\hrule
\caption{Configurations obtained throughout an execution of $\prog_4$.}
\label{fig:cp.exec}
\end{figure}

The next consistency model that we illustrate is \emph{consistent prefix}. 
It ensures that once a client observes the effects of some transaction $\txid$, it also observes all the transactions that were committed before $\txid$. 
Another way to express this property is that two different transactions never observe the updates to different keys in a different order.
Consider the program $\prog_4$ below:
 \[
    \prog_4 \equiv  
    \left( 
    \begin{session} 
        \begin{array}{@{}c || c @{}}
            \begin{session} 
            \txid_1 : 
            \begin{transaction}
                \pmutate{\vx}{1};\\
            \end{transaction}; \\
            
            \txid_3 :
            \begin{transaction}
              	\pderef{\pvar{a}}{\vy};\\
              	\pifs{\pvar{a}=0}\\
                    \quad \passign{\retvar}{\sadface} 
                \pife 
            \end{transaction}
            \end{session}
            &
            \begin{session}
            \txid_2 :
            \begin{transaction}
                \pmutate{\vy}{1};\\
            \end{transaction} ; \\
            
            \txid_4 :
            \begin{transaction}
              	\pderef{\pvar{a}}{\vx};\\
              	\pifs{\pvar{a}=0}\\
              		\quad \passign{\retvar}{\sadface} 
                \pife
            \end{transaction}
            \end{session}
        \end{array}
    \end{session}
    \right)
 \]
Under $\mathsf{RA}$, It is possible to obtain an execution of program $\prog_4$ where both $\txid_3$ and $\txid_4$ return $\sadface$.
Assume that initially $\thid_1$ executes transaction $\txid_1$ (\cref{fig:prefix-after-tx1}), and then \(\thid_2\) executes \(\txid_2 \) with a view pointing to the initial versions (\cref{fig:prefix-after-tx2}).
Now \( \cl_1\) and \( \cl_2 \) can execute transactions \( \txid_3\) and \( \txid_4 \) respectively without changing their views, thus both transactions return \( \sadface \).

To avoid different clients to observe different updates in different orders, we impose a constraint known as \emph{consistent prefix}.
Intuitively, assuming a transaction has start and commit points, \emph{consistent prefix} requires that if a transaction $\txid_1$ observes the effects of another transaction $\txid_2$, then it must observe the effects of any other transaction that committed before $\txid_2$.
In our framework, transactions are executed in a single step which corresponds to the commit order
\footnote{%
this correspondence will be made precise later.
We will relate executions in our operational semantics to abstract executions used in the declarative style for specifications of consistency models}.
Thus, among the read atomic (\cref{def:readatomic}), \emph{consistent prefix} requires once a client commits a transaction, it pushes the view to be up-to-date with the state of the database, so the following transactions from the same client will observe the effects of all transactions committed before \( \txid \) included.

\begin{definition}[Consistent prefix]
\label{def:consistent-prefix}
The \emph{consistent prefix} is stronger than read atomic (\cref{def:readatomic}) by further requiring the view after pushes to the latest for all addresses, 
\[
\begin{rclarray}
    (\hh, \vi) \csat[\mathsf{CP}] \opset: \vi' & \defeq &  (\hh, \vi) \csat[\mathsf{RA}] \opset: \vi' \land \fora{\addr \in \dom(\hh)} \vi'(\addr) = \left| \hh(\addr) \right| - 1 \\
\end{rclarray}
\]
\end{definition}

Let consider again the program $\prog_4$. 
Under $\mathsf{CP}$ it is impossible for both client $\thid_1$ and $\thid_2$ to return ${\sadface}$. 
Assume initial configuration in which the program $\prog_4$ is executed is the one depicted in \cref{fig:prefix-init}. 
Since it is symmetric, we execute \( \txid_1 \) (\cref{fig:prefix-after-tx1}).
At this point, under $\mathsf{CP}$ it is impossible for $\thid_2$ to execute $\txid_2$ and obtain the configuration in \cref{fig:prefix-after-tx2}. 
because it requires the view of $\thid_2$ \textbf{after} executing $\txid_2$ to be up-to-date, i.e. to point to the last version of each key (\cref{fig:prefix-cl2-update-view}). 
From this point on, whenever $\thid_2$ will execute transaction $\txid_4$, it will read value $1$ for key $\ke_\vx$, hence it cannot return $\sadface$ (\cref{fig:prefix-after-tx34}).
