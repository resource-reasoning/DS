\section{Operational Semantics of Key-Value Stores}

We define a simple programming language for client programs interacting with a kv-store.
Clients may only interact with a kv-store by issuing read and write requests via transactions. 
For simplicity, we abstract away from aborting transactions:
rather than assuming a transaction may abort due to a violation of the consistency guarantees given by the kv-store,
we only allow a transaction to execute if its effects are guaranteed to not violate the consistency model. 
This emulates the setting in which clients always restart a transaction if it aborts.


\subsubsection{Programming Language}

\emph{A program} \( \prog \) comprises a finite number of clients,
where each client is associated with a unique identifier \( \thid \in \ThreadID \), 
and executes a sequential \emph{command} $\cmd$, given by the following grammar:
\[
\begin{array}{@{} r @{\hspace{2pt}} l @{\hspace{30pt}} r @{\hspace{2pt}} l@{} }
	\cmd ::=  &
        \pskip \mid 
        \ptrans{\trans} \mid 
	    \cmdpri \mid  
        \cmd \pseq \cmd \mid 
        \cmd \pchoice \cmd \mid 
        \cmd \prepeat 
        
   & \cmdpri ::=  &
   		\pass{\txvar}{\expr} \mid 
   		\passume{\expr} \\
%   
	\trans ::= &
        \pskip \mid
        \transpri \mid 
        \trans \pseq \trans \mid
        \trans \pchoice \trans \mid
        \trans\prepeat    
	& \transpri ::= &
   		\cmdpri \mid
        \pderef{\txvar}{\expr} \mid
        \pmutate{\expr}{\expr} 
 \end{array} 
\]
%
Sequential commands include the standard constructs of $\pskip$, sequential composition ($\cmd \pseq \cmd$), non-deterministic choice ($\cmd \pchoice \cmd$), loops $\cmd\prepeat$, 
as well as \emph{transactions} ($\ptrans{\trans}$) and primitive commands. 
Primitive commands include variable assignments ($\pass{\txvar}{\expr}$) and assume statements ($\passume{\expr}$) used to encode conditionals,
and are split into transactional ones (the $\transpri$ clause) 
and non-transactional ones (the $\cmdpri$ clause).
Transactional primitive commands are used for reading and writing to kv-stores and 
can be invoked only within the boundaries of transactions (the $\ptrans{\trans}$ clause).
Non-transactional primitive commands are used for computations over client-local data
and can be invoked without restrictions.

For clarity, we often write \( \cmd_{1}\ppar \dots \ppar \cmd_{n}\) as syntactic sugar 
for a program \( \prog \) with $n$ implicit clients associated with identifiers, 
$\thid_1 \dots \thid_n$, where each client $\thid_i$ executes $\cmd_i$: 
\( \prog = \Set{\thid_{1} \mapsto \cmd_{1}, \dots, \thid_{n} \mapsto \cmd_{n}  }\).

As is standard, we assume a language of expressions built from values ($\val \in \Val$), 
and (client-local) \emph{program variables} $\Vars$, ranged over by $\pvar{x}, \pvar{y}, \cdots$. 
The evaluation $\evalE{\expr}$ of  expression $\expr$ is parametric in the (client-local) \emph{stack} 
$\stk \in \Stacks \defeq \Vars \to \Val$, mapping program variables to values. 
\[
\expr  ::= 
        \val \mid
        \var \mid
        \expr + \expr \mid
        \dots  
\qquad   
\evalE{\val}  =  \val \quad 
\evalE{\var} = \stk(\var)  \quad  
\evalE{\expr_{1} + \expr_{2}}  =  \evalE{\expr_{1}} + \evalE{\expr_{2}} \quad
\dots
\]


\subsubsection{Operational Semantics of Transactions}
Transactional commands in $\transpri$ are associated with a transition system: 
$\toLTS{\transpri} \subseteq (\Stacks \times \Heaps) \times (\Stacks \times \Heaps)$, 
describing how the snapshot and stack evolve upon executing $\transpri$:
% \cref{fig:semantics}.
\[
\begin{array}{rcl @{\qquad} rcl}
(\stk, \h)  & \toLTS{\passign{\var}{\expr}}          & (\stk\rmto{\var}{\evalE{\expr}}, \h)                  &
(\stk, \h)  & \toLTS{\passume{\expr}}                & (\stk, \h) \text{ where } \evalE{\expr} \neq 0        \\
(\stk, \h)  & \toLTS{\pderef{\var}{\expr}}           & (\stk\rmto{\var}{\h(\evalE{\expr})}, \h)              &
(\stk, \h)  & \toLTS{\pmutate{\expr_{1}}{\expr_{2}}} & (\stk, \h\rmto{\evalE{\expr_{1}}}{\evalE{\expr_{2}}}) \\
\end{array}                                                                                               
\]

To compute the overall effect of a transaction,
we define a \emph{fingerprint function}, 
$\func{fp}{\stub} : \Stacks \times \Heaps \times \transpri \rightarrow \Ops \cup \{\varepsilon\}$, extracting the operation of a primitive transactional command: 
%
\[
\begin{array}{rcl @{\quad} rcl}
\func{fp}{\stk, \h, \passign{\var}{\expr}}          & \defeq & \emptyop                                     &
\func{fp}{\stk, \h, \passume{\expr}}                & \defeq & \emptyop                                     \\
\func{fp}{\stk, \h, \pderef{\var}{\expr}}           & \defeq & (\etR, \evalE{\expr}, \h(\evalE{\expr}))     &
\func{fp}{\stk, \h, \pmutate{\expr_{1}}{\expr_{2}}} & \defeq & (\etW, \evalE{\expr_{1}}, \evalE{\expr_{2}}) \\
\end{array}
\]
%and a \emph{fingerprint composition operator} \( \addO \).
Note that non-transactional primitive commands are associated with the empty operation $\varepsilon$,
as they only access the local stack and do not access the kv-store.

We further define a \emph{fingerprint composition operator}, \( \addO \), 
incrementally computing the fingerprint of a transaction, after executing each constituent primitive command. 
For instance, when executing $ \ptrans{\trans}$ with $\trans \eqdef \transpri^1; \cdots ; \transpri^n$,
the effect of each $\transpri^i$ is calculated via the $\op_i = \func{fp}{-, -, \transpri^i}$ function, 
with the overall fingerprint given as the $\addO$-composition of the constituent effects: $\op_1 \addO \cdots \addO \op_n$. 

For each key $\ke$, the composition operator \( \addO \) records
the first value a transaction reads (before a subsequent write) for $\ke$, 
and the last value the transaction writes for $\ke$.
This is in line with our assumption that transactions read from an atomic snapshot of the kv-store.
In particular, for each key $\ke$, 
only the first read from $\ke$ fetches its value from the kv-store,
and since clients observe either none or all effects of a transaction, 
only the last write to $\ke$ is committed.
%
\[
\begin{rclarray}
    \opset \addO (\etR, \addr, \val)  & \defeq  &
    \begin{cases}
        \opset \cup \{(\etR, \addr, \val)\} & \text{if } \for{l, v'} (l, \addr, v') \notin \opset \\
        \opset &  \text{otherwise} \\
    \end{cases} 
    	\qqquad 
    \opset \addO \emptyop  \defeq  \opset  \\
    \opset \addO (\etW, \addr, \val) & \defeq & 
    \left( \opset \setminus \setcomp{(\etW, \addr, v')}{v' \in \Val} \right) \cup\ \{(\etW, \addr, \val)\} 
%    \opset \addO \emptyop & \defeq & \opset \\
\end{rclarray}
\]
%
\ifTechReport
    \input{\RootPath/semantics/semantics-fig.tex}
\else
\begin{figure}[t]
\hrulefill
\[
	\inferrule[\rl{TSeq}]{%
     	\begin{array}{@{} c @{}}
     		(\stk, \h, \opset) , \trans_1 
	     	\ \toL \  
	     	(\stk', \h', \opset') , \trans'_1 
     	\end{array}
    }{%
        (\stk, \h, \opset) , \trans_1 \pseq \trans_2 \ \toL \  (\stk', \h', \opset') , \trans'_1 \pseq \trans_2 \rangle
    }
    \qquad
    \inferrule[\rl{TPrimitive}]{%
        (\stk, \h) \toLTS{\transpri} (\stk', \h')
        \\ \func{fp}{\stk, \h, \transpri} = \op
    }{%
        (\stk, \h, \opset) , \transpri \ \toL \  (\stk', \h', \opset \addO \op) , \pskip \rangle
    }
\]
\hrulefill
\[
    \inferrule[\rl{PCommit}]{%
        \vi \orderVI  \vi''
        \qquad \h = \clpsHH{\hh,\vi''}
        \qquad \txid \in \nextTxId(\cl, \hh)
        \\\\ (\stk, \h, \emptyset), \trans \ \toL^{*} \  (\stk', \stub,  \opset) , \pskip
        \\ \ET \vdash (\hh, \vi'') \triangleright \opset : \vi'
    }{%
        \cl \vdash ( \hh, \vi, \stk ), \ptrans{\trans} \ \toT{(\cl, \vi'', \opset)}_{\ET} \ ( \updateKV(\hh, \vi, \txid, \opset),\vi', \stk' ) , \pskip
    }
\]
\[
    \inferrule[\rl{PPrimitive}]{
        \stk \toLTS{\cmdpri} \stk'
    }{%
    \cl \vdash ( \hh, \vi, \stk ) , \cmdpri \ \toT{(\cl,\iota)}_{\como} \  ( \hh, \vi, \stk' ) , \pskip
    }
\]
\hrulefill
\[
    \inferrule[\rl{PProg}]{%
         \cl \vdash ( \mkvs, \vi, \thdenv(\thid) ) , \prog(\thid), \ \toT{\lambda}_{\ET} \  ( \mkvs', \vi', \stk' ) , \cmd'  
    }{%
         (\mkvs, \viewFun\rmto{\thid}{\vi}, \thdenv ), \prog  \ \toT{\lambda}_{\ET} \  ( \mkvs', \viewFun\rmto{\thid}{\vi'}, \thdenv\rmto{\thid}{\stk'} ) , \prog\rmto{\thid}{\cmd'} ) 
    }
\]
\hrulefill
\caption{Selected operational semantics rules for transactions (above); sequential commands (middle); and programs (below)}
\azalea{Why is the caption so narrow?}
\ac{I had to introduce labels for transitions in the semantics. These is because I need 
to carry the information about the view in which a transaction is executed: this cannot be 
recovered from the pre and post configurations of the transition.}
\label{fig:semantics}
\end{figure}
\fi

\ifTechReport%
In the top part of \cref{fig:semantics} we present the operational semantics of transactional code (within the transaction boundaries in $\ptrans{}$). 
\else%
In the top part of \cref{fig:semantics} we present a few selected rules of the operational semantics of transactional code (within the transaction boundaries in $\ptrans{}$). 
We refer the reader to \cref{sec:full-semantics} for the full operational semantics.
\azalea{Maybe we should add one or two more rules for transactions?}
\fi%
%
%The rules presented in the top part of \cref{fig:semantics} pertains to that of executing transactional code (within the transaction boundaries in $\ptrans{}$). 
Transactional rules are of the form $(\stk, \h, \opset), \toL (\stk', \h', \opset'), \trans'$, 
stating that when the fingerprint accumulated so far is recorded in $\opset$, 
executing $\trans$ for one step transforms the client-local stack $\stk$ 
and snapshot $\h$ %(used to fetch the values of read operations),
to $\stk'$ and $\h'$, respectively, with the extended fingerprint $\opset'$, and continuation $\trans'$.
The \rl{TSeq} rule is in a standard format; 
the \rl{TPrimitive}  models the execution of primitive transactional commands.
%The transaction maintains a client-local-stack $\stk$, 
%a snapshot $\h$ used to fetch the value of read operations, 
%and a set of operations $\opset$ recording the transaction fingerprint to be applied to the kv-store upon committing the transaction. 
When $(\stk, \h)$ is transformed to $(\stk', \h')$ via the transition system $\toLTS{\transpri}$,
$\func{fp}{\stk, \h, \transpri} = \op$, and the fingerprint recorded so far is given by $\opset$, 
then executing $\transpri$ transforms $(\stk, \h)$ to $(\stk', \h')$, with the fingerprint updated to $\opset \addO \op$ (to incorporate the effect of $\transpri$), with continuation $\pskip$. 







\subsubsection{Operational Semantics of Commands}
\ifTechReport%
In \cref{fig:semantics} we present the \emph{(sequential) command operational semantics}.
\else%
In \cref{fig:semantics} we present a select number of \emph{(sequential) command operational semantics}.
We refer the reader to \cref{sec:full-semantics} for the full operational semantics.
\fi%
Command transitions are of the form $\cl \vdash (\hh, \vi, \stk), \cmd \ \toT{\lambda}_{\ET} \ (\hh', \vi', \stk') , \cmd'$, 
stating that given the kv-store $\hh$, view $\vi$ and stack $\stk$, client $\cl$ may execute command $\cmd$ for one step under $\ET$, update the kv-store to $\hh'$, the stack to $\stk'$, and the command to its continuation $\cmd'$, with label $\lambda$.
A transition label $\lambda$ is either
\begin{enumerate*}
	\item of the form $(\cl, \iota)$, denoting that the transition involved 
client-local computation that did not require access to the kv-store (\eg primitive commands $\cmdpri$; or
	\item of the form $(\cl, \vi, \opset)$, denoting that client $\cl$ commits a transaction with fingerprint $\opset$ under the view $\vi$.
\end{enumerate*}
Note that the operational semantics of commands are parametric in the choice of execution test $\ET$, 
and thus the choice of the underlying consistency model.
%The execution test induces a set of transfers on key-value stores allowed by the consistency model.


With the exception of the \rl{PCommit} rule, the remaining command transitions are standard and behave as expected. 
For instance, the \rl{PPrimitive} rule models the execution of a non-transactional primitive command $\cmdpri$, where the $\stk \toLTS{\cmdpri} \stk'$ transition describes how the stack of a client 
evolve upon executing $\cmdpri$:
\[
\begin{array}{rcl @{\qquad} rcl}
\stk  & \toLTS{\passign{\var}{\expr}} & \stk\rmto{\var}{\evalE{\expr}} &
\stk  & \toLTS{\passume{\expr}} & \stk \text{ where } \evalE{\expr} \neq 0 \\
\end{array}                                                                                               
\]
%
%
%We write $\lcat$ for denotes list concatenation.
%We write $f \rmto{a}{b}$ for function update: $f \rmto{a}{b}(a) = b$, and for all $c \ne a$, $f \rmto{a}{b}(c) = f(c)$.
%
%The notation \( l\rmto{i}{k} \) on a list \( l \) means the result by replacing the \emph{i-th} element to \( k \).
%%To record the index of list starts from 0.
%The \( \lcat \) denotes list concatenation.


The \rl{PCommit} rule models the execution of a transaction $\ptrans{\trans}$, under the execution test $\ET$. 
The first premise of \rl{PCommit} states that the current view $\vi$ of the executing command maybe advanced to a newer atomic view $\vi''$ (see \cref{def:views}). 
The semantics only allows to advance the view to latest versions, which corresponds to \emph{monotonic read} \cite{.......}.
Given the new view $\vi''$, the transaction proceeds by obtaining a snapshot $\sn$ of the kv-store $\hh$, and executing $\trans$ locally to completion ($\pskip$), updating the stack to $\stack'$, while accumulating the fingerprint $\opset$. Note that the resulting snapshot is ignored (denoted by $\stub$) as the effect of the transaction is recorded in the fingerprint $\opset$. 
%

The transaction is now ready to commit and may propagate its changes to $\hh$.
To this end, a \emph{fresh} transaction identifier $\txid \in \nextTxId(\cl, \hh)$ (defined shortly) is picked
to identify the completed transaction, and the changes performed by $\txid$ are propagated to $\hh$. 
This is done via the $\func{updateMKVS}{\hh, \vi, \txid, \opset}$ function (defined shortly) to update $\hh$. 
%The fresh identifier $\txid$ is given by the $t \in \nextTxId(\cl, \hh)$ function defined shortly.
Once the kv-store is updated, the client subsequently updates its view to $\vi'$ with respect to its fingerprint. 
Lastly, to ensure that the effect of the transaction (its fingerprint  $\opset$) is permitted by the underlying consistency model, 
the last premise requires that the updates be permitted by the execution test $\ET$, \ie \( (\hh, \vi'') \etto \opset : \vi'\).

The $\nextTxId(\cl, \hh)$ returns the set of transactions identifiers associated with $\cl$ that are fresh with respect to $\hh$: 
$\nextTxId(\cl, \hh) \defeq \Setcon{\txid_{\cl}^{n}}{\fora{m} \txid_{\cl}^{m} \in \hh \Rightarrow m < n }$.
Note that when $\txid_\cl^n = \nextTxId(\cl, \hh)$ in the premise of \rl{PCommit}, then $\txid_\cl^n$ is greater than any transaction identifier 
(with respect to session order $\xrightarrow{\PO}$) 
of the form $\txid_{\cl}^{i}$ appearing in $\hh$,
as to reflect the fact that $\txid_\cl^n$ is the most recent transaction executed by $\cl$.

%Given a fresh transaction identifier $\txid \in \nextTxId(\cl, \hh)$ for some $\cl$,
%then $\updateKV(\hh, \vi, \txid, \opset)$ produces a valid key-value store according to \cref{def:mkvs}.
%For brevity, we commit an abuse of notation $\updateKV(\hh, \vi, \cl, \opset)$ 
%for the set 
%$\Setcon{\hh'}{\exsts { \txid \in \nextTxId(\cl, \mkvs) } \hh' = \updateKV(\hh, \vi, \txid, \opset)}$.
%
The \( \updateKV \) function is defined below, where $\lcat$ denotes list concatenation; 
and when $\vilist = \ver_0, \cdots, \ver_n$ and $i=0,\cdots,n$, 
$\vilist\rmto{i}{\ver}$ denotes the updated list 
$\vilist' = \ver_0, \cdots, \ver_{i-1}, \ver, \ver_{i+1}, \cdots, \ver_{n}$. 
%
%
%
%
%for a client to commit the effects of a transaction to the key-value store. 
%Suppose that a client $\cl$, with a view $\vi$ of a key-value store $\hh$,
%wants to commit a transaction with a freshly picked identifier \( \txid \)
%whose fingerprint is $\opset$.
%The function 
%$\updateKV: \HisHeaps \times \Views \times \TxID \times \powerset{\Ops} \to \HisHeaps$
%is defined recursively below:
\begin{equation*}
\begin{rclarray}         
    \updateKV(\hh, \vi, \txid, \emptyset) &\defeq & \hh \\
    \updateKV(\hh, \vi, \txid, \opset \uplus \Set{(\otR, \ke, \stub)}) & \defeq &  
    \begin{array}[t]{@{}l}
        \texttt{let } (\val, \txid', \txidset) = \hh(\ke, \max_{<}(\vi(\ke))), \\
        \vilist = \hh(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val, \txid', \txidset \uplus \{ t \})}\\
        \quad \texttt{in } \updateKV(\hh\rmto{\ke}{\vilist}, \vi, \txid, \opset)
    \end{array} \\
    \updateKV(\hh, \vi, \txid, \opset \uplus \Set{(\otW, \ke, \val)} )& \defeq &  
    \begin{array}[t]{@{}l}
        \texttt{let } \hh' = \hh\rmto{\ke}{ ( \hh(\ke) \lcat (\val, \txid, \emptyset) ) } \\
        \quad \texttt{in } \updateKV(\hh', \vi, \txid, \opset)
    \end{array} 
\end{rclarray}
\label{eq:updatekv}
\end{equation*}
%
%As expected, for every read operation $(\otR, \ke, \stub)$ in fingerprint $\opset$, the readers of $\ke$ at index $\vi(\ke)$ are extended with $\txid$.
%
For every read operation $(\otR, \ke, \stub)$ in fingerprint $\opset$,
since a transaction reads the values of keys from 
the atomic snapshot determined by the view of the client, 
the version read by $\txid$ for key $\ke$ corresponds to $\hh(\ke, \max_{<}(\vi(\ke)))$.
As such, to commit the transaction, 
the reader set of the version $\hh(\ke, \max_{<}(\vi(\ke)))$ is extended with a new reader $\txid_\cl^n$.
Similarly, for every write operation $(\otW, \ke, \val)$ in fingerprint $\opset$, 
the list of versions $\hh(\ke)$ is extended with a new version $(\val, \txid, \emptyset)$, 
denoting that $\txid_\cl^n$ is the writer of this version which has no readers as of yet. 

Note that the assumption that 
versions of a given key are totally ordered and consistent with the order in which 
transactions commit is standard, 
which corresponds to last-write-win resolution policy \cite{adya,framework-concur,seebelieve}. 
Moreover, under the assumption that fingerprints contain at most one read and one write 
operation per key, and the identifier is fresh $\txid \notin \hh$%
\footnote{%
We write $\txid \in \hh$ when there exists a key 
$\ke$ and an index $i=0,\cdots, \lvert \hh(\ke) \rvert -1$ such that $\txid \in \{\WTx(\hh(\ke, i)\} \cup \RTx(\hh(\ke, i))$.}, 
the $\updateKV$ is well-defined.

\sx{List notation? simply put all the elements one after another or we use \List{} to wrap them?}


\sx{well defined mean? Confluence?}


\ac{The paragraph below should probably go when discussing the rules of the semantics:

Note that the way in which MKVSs and views are updated ensure the following: 
$\bullet$ a client always reads its own preceding writes; 
$\bullet$ clients always read from an increasingly up-to-date state of the database; 
$\bullet$ the order in which clients update a key $\key{k}$ is consistent with the 
order of the versions for such keys in the MKVS; 
$\bullet$ writes take place after reads on which they depend. 
}









\subsubsection{Operational Semantics of Programs}
%Let us discuss how key-value stores in $\updateKV(\hh, \vi, \cl, \opset)$ are computed. 
%Suppose that client \( \cl \) wants to commit a transaction.
%First, we select a fresh transaction identifier $\txid_\cl^n \in \nextTxId(\cl, \hh)$ 
%that we associate with the fingerprint to be committed into the key-value store.
%The $\txid_\cl^n$ is greater than any transaction identifier 
%(w.r.t. the session order $\xrightarrow{\PO}$) 
%of the form $\txid_{\cl}^{i}$ appearing in $\hh$,
%as to reflect the fact that $\txid_\cl^n$ is the most recent transaction executed by $\cl$.


%Similarly to transactional commands,
%Program commands are equipped with a transformer relation 
%$\toLTS{\cmdpri} \subseteq \Stacks \times \Stacks$.
%The transformer $\stk \toLTS{\cmdpri} \stk$ describes how the stack of a client 
%evolve upon executing the primitive command $\cmdpri$.
%\[
%\begin{array}{rcl @{\qquad} rcl}
%\stk  & \toLTS{\passign{\var}{\expr}} & \stk\rmto{\var}{\evalE{\expr}} &
%\stk  & \toLTS{\passume{\expr}} & \stk \text{ where } \evalE{\expr} \neq 0 \\
%\end{array}                                                                                               
%\]


 




The \emph{operational semantics of programs} are given at the bottom of \cref{fig:semantics}. 
Programs transitions are of the form $(\conf,  \thdenv, \prog) \ \toG{\lambda}_{|ET} (\conf',  \thdenv', \prog')$,
stating that given the configuration $\conf$ and the \emph{client environment} $\thdenv$, executing program $\prog$ for one step under $\ET$, updates the configuration to $\conf'$, the client environment to $\thdenv'$, and the program to its continuation $\prog'$. 
A \emph{client environment}, $\thdenv \in \ThdEnv$, is a mapping from client identifiers to pairs of stacks and views. 
We assume that the clients in the domain of client environments are are those in the domain of the program throughout the execution: 
$\dom(\thdenv) = \dom(\prog)$.
%$\prog$: $\dom(\thdenv) = \dom(\prog)$; and that 
Program transitions are simply defined in terms of the transitions of their constituent client commands.
% defined by $\toT{\lambda}_{\ET}$. 
This in turn yields the standard interleaving semantics for concurrent programs. 
That is, a client performs a reduction in an atomic step, without affecting other clients.


%The \rl{PProg} rule at the bottom of \cref{fig:semantics} models the execution of a command bound to a client in a program. 
%The \( \thdenv \) is a partial function from clients \( \ClientID \) to stacks \( \Stacks \).
%
%This rule models the standard interleaving semantics of programs, that is, a client that is able to 
%perform a reduction, can do so in an atomic step, without affecting the state of other clients.




%\begin{definition}[Programming language]
%\label{def:language}
%\label{def:program_values}
%A \emph{program}, $\prog \in \Programs$, is a partial finite function from client identifiers to commands.
%The sequential \emph{commands}, \( \cmd \in \Commands \), are defined by the following grammar, where
%$\val \in \Val \eqdef \Nat \cup \Addr$ denotes the set of \emph{program values}, and $\addr \in \Addr$ denotes the set of MKVS keys (\cref{def:mkvs}):
%\[
%\begin{array}{@{} l @{}  l @{}}
%    \begin{rclarray}
%    \cmd & ::= &
%        \pskip \mid 
%        \passign{\thvar}{\expr} \mid
%        \passume{\expr} \mid
%        \ptrans{\trans} \mid 
%        \cmd \pseq \cmd \mid 
%        \cmd \pchoice \cmd \mid 
%        \cmd \prepeat \\
%%
%	 \expr & ::= &
%        \val \mid
%        \var \mid
%        \expr + \expr \mid
%        \expr \times \expr \mid
%        \dots  
%       \end{rclarray} 
%%    
%	& 
%%
%	\begin{rclarray}        
%	\trans & ::= &
%        \pskip \mid
%        \transpri \mid 
%        \trans \pseq \trans \mid
%        \trans \pchoice \trans \mid
%        \trans\prepeat   \\
%%        
%	\transpri & ::= &
%        \pass{\txvar}{\expr} \mid
%        \pderef{\txvar}{\expr} \mid
%        \pmutate{\expr}{\expr} \mid
%        \passume{\expr} 
%%
%    \end{rclarray}
%\end{array} 
%\]
%\end{definition}
 
%Expressions in 
%Sequential \emph{commands}, ranged over by $\cmd$, are defined by an inductive grammar comprising the standard constructs of $\pskip$, sequential composition ($\cmd; \cmd$), non-deterministic choice ($\cmd+\cmd$) and loops ($\cmd^*$).
%To simulate conditional branching and loops, commands include the standard constructs of assume (\( \passume{\expr}\)), and assignment (\( \passign{\var}{\expr} \)), where \( \var \) denotes a local variable (on the stack), and \( \expr \) denotes an arithmetic expression with no side effect.  
%evaluated with respect to a stack  with no side effect.
%Arithmetic expressions are evaluated with respect to a local stack (variable store) -- see  \cref{def:stacks,def:eval-expr} below.
%We assume a countably infinite set of local variables, $\Vars $, and use the \texttt{typewriter} font for its meta variables, \eg $\var$.\\
%%
%\indent Commands additionally include the \emph{transaction} construct, $\ptrans{\trans}$, denoting the \emph{atomic} execution of the transaction $\trans$. 
%The atomicity guarantees the execution are dictated by the underlying consistency model.
%\emph{Transactions}, ranged over by $\trans$, are similarly defined by an inductive grammar comprising $\pskip$, \emph{primitive commands} \( \transpri \), non-deterministic choice, loops and sequential composition.
%Primitive commands include assignment (\( \passign{\var}{\expr}\)), lookup (\( \pderef{\expr}{\expr}\)), mutation (\( \pmutate{\expr}{\expr}\)) and assume (\( \passume{\expr}\)). 
%Note that transactions do \emph{not} contain the \emph{parallel} composition construct ($\ppar$) as they are executed atomically.

%We assume a valid transactions codes must have the only return at the end.
%For better presentation, sometime we omit the default return zero \( \preturn{0} \).
%Transactions can only assign to their own variables, namely transaction variables (\defref{def:program_values}), but it can read from both the thread and transaction stacks.

%\begin{definition}[Program values]
%where $ \nat \in \Nat$ denotes the set of natural numbers.
%\end{definition}

%\begin{definition}[Programming language]
%\label{def:language}
%\label{def:program_values}
%A \emph{program}, $\prog \in \Programs$, is a partial finite function from client identifiers to commands.
%The sequential \emph{commands}, \( \cmd \in \Commands \), are defined by the following grammar, where
%$\val \in \Val \eqdef \Nat \cup \Addr$ denotes the set of \emph{program values}, and $\addr \in \Addr$ denotes the set of MKVS keys (\cref{def:mkvs}):
%\[
%\begin{array}{@{} l @{}  l @{}}
%    \begin{rclarray}
%    \cmd & ::= &
%        \pskip \mid 
%        \passign{\thvar}{\expr} \mid
%        \passume{\expr} \mid
%        \ptrans{\trans} \mid 
%        \cmd \pseq \cmd \mid 
%        \cmd \pchoice \cmd \mid 
%        \cmd \prepeat \\
%%
%	 \expr & ::= &
%        \val \mid
%        \var \mid
%        \expr + \expr \mid
%        \expr \times \expr \mid
%        \dots  
%       \end{rclarray} 
%%    
%	& 
%%
%	\begin{rclarray}        
%	\trans & ::= &
%        \pskip \mid
%        \transpri \mid 
%        \trans \pseq \trans \mid
%        \trans \pchoice \trans \mid
%        \trans\prepeat   \\
%%        
%	\transpri & ::= &
%        \pass{\txvar}{\expr} \mid
%        \pderef{\txvar}{\expr} \mid
%        \pmutate{\expr}{\expr} \mid
%        \passume{\expr} 
%%
%    \end{rclarray}
%\end{array} 
%\]
%%The $\trans \in \Transactions$ in the grammar above denotes a \emph{transaction} defined by the following grammar including the primitive transactional commands \( \transpri\):
%%The transaction codes \( \ptrans{\trans} \) satisfy a well-form condition that there is exactly a return at the end, \ie \( \ptrans{\trans} \iff \exsts{\trans', \expr} \trans \equiv ( \trans' \pseq \preturn{\expr} )  \land \pred{noRet}{\trans'} \)
%%\[
%%    \begin{rclarray}
%%        \transpri & ::= &
%%        \pass{\txvar}{\expr} \mid
%%        \pderef{\txvar}{\expr} \mid
%%        \pmutate{\expr}{\expr} \mid
%%        \passume{\expr} \mid \\
%%        %\preturn{\expr} \\
%%        \trans & ::= &
%%        \pskip \mid
%%        \transpri \mid 
%%        \trans \pseq \trans \mid
%%        \trans \pchoice \trans \mid
%%        \trans\prepeat
%%    \end{rclarray}
%%\]
%%Given the set of \emph{keys}, $\addr \in \Addr$ (\cref{def:mkvs}), the set of \emph{program values} is $\val \in \Val \eqdef \Nat \cup \Addr$.
%%The $\expr \in \Expressions$ denotes an \emph{arithmetic expression} defined by the grammar:
%%\[
%%    \begin{rclarray}
%%        \expr & ::= &
%%        \val \mid
%%        \var \mid
%%        \expr + \expr \mid
%%        \expr \times \expr \mid
%%        \dots 
%%    \end{rclarray}
%%\]
%\end{definition}
%
%\begin{definition}[Stacks]
%\label{def:stacks}
%\label{def:eval-expr}
%A \emph{stack}, $\stk \in \Stacks$, is a partial finite function from variables to values: \(\Stacks \defeq \Vars \parfinfun \Val \).
%Given a stack $\stk \in \Stacks$, %(\cref{def:stacks}), 
%the \emph{arithmetic expression evaluation} function, $\evalE[(.)]{.}:\Expressions \times \Stacks \parfun \Val$, is defined inductively over the structure of expressions: 
%%
%\[
%	\evalE{\val}  \defeq  \val 
%	\qquad 
%	\evalE{\var} \defeq \stk(\var) 
%	\qquad 
%	\evalE{\expr_{1} + \expr_{2}}  \defeq  \evalE{\expr_{1}} + \evalE{\expr_{2}} 
%	\qquad
%	\evalE{\expr_{1} \times \expr_{2}}  \defeq  \evalE{\expr_{1}} \times \evalE{\expr_{2}} 
%	\qquad 
%	\dots
%\]
%\end{definition}
%
%%\begin{definition}[Evaluation of expression]
%%\label{def:eval-expr}
%%Given a stack $\stk \in \Stacks$, %(\cref{def:stacks}), 
%%the \emph{arithmetic expression evaluation} function, $\evalE[(.)]{.}:\Expressions \times \Stacks \parfun \Val$, is defined inductively over the structure of expressions: 
%%%
%%\[
%%	\evalE{\val}  \defeq  \val 
%%	\qquad 
%%	\evalE{\var} \defeq \stk(\var) 
%%	\qquad 
%%	\evalE{\expr_{1} + \expr_{2}}  \defeq  \evalE{\expr_{1}} + \evalE{\expr_{2}} 
%%	\qquad
%%	\evalE{\expr_{1} \times \expr_{2}}  \defeq  \evalE{\expr_{1}} \times \evalE{\expr_{2}} 
%%	\qquad 
%%	\dots
%%\]
%%%\[
%%%    \begin{rclarray}
%%%        \evalE{\val} & \defeq & \val \\
%%%        \evalE{\var} & \defeq & \stk(\var) \\
%%%        \evalE{\expr_{1} + \expr_{2}} & \defeq & \evalE{\expr_{1}} + \evalE{\expr_{2}} \\
%%%        \evalE{\expr_{1} \times \expr_{2}} & \defeq & \evalE{\expr_{1}} \times \evalE{\expr_{2}} \\
%%%        \dots & \eqdef & \dots \\
%%%    \end{rclarray}
%%%\]
%%\end{definition}
%
%\subsection{Operational Semantics of Transactions}
%\label{sec:trans-semantics}
%\azalea{I rewrote most of this section.}
%
%\mypar{Operations and Fingerprints}
%Recall that when a transaction starts, it extracts a local snapshot $\ss$ of the MKVS via its view. 
%The execution of the transaction is then carried out \emph{locally} on $\ss$:  
%read operations inspect $\ss$ and write operations update $\ss$. 
%%, as we discuss in \cref{sec:prog-semantics}.
%To track the effect of a transaction while executing, each transaction is associated with a \emph{fingerprint}, initially set to empty. 
%The fingerprint of a transaction records its interactions (read or write operations) with the MKVS.
%Each time a transaction executes a primitive command \( \transpri\) (locally on $\ss$), its fingerprint is updated to track the effect of $\transpri$.
%%More concretely, every time the transaction performs a write operation, 
%Once the local execution of a transaction is complete, its local snapshot is discarded, and the transaction is committed by propagating the effects in its fingerprint to the MKVS.
%%
%
%The fingerprint of a transaction, $\opset$, is modelled as a set of \emph{operations}. 
%Each operation $\op$ is a tuple of the form $(\mathit{tag}, \ke, \val)$, where $\mathit{tag}$ denotes the operation type and may be one of $\otW$ for \emph{write} operations, or $\otR$ for \emph{read} operations; 
%the $\ke$ denotes the operation key, and  $\val$ denotes the operation value. 
%For instance, $(\otW, \ke, \val)$ denotes the execution of an operation where value $\val$ is written to key $\ke$; and
%$(\otR, \ke, \val)$ denotes the execution of an operation where value $\val$ is read from key $\ke$.
%
%
%When tracking the write operations (with tag $\otW$) in a fingerprint $\opset$, for each key $\ke$, only the effect of the \emph{last} write to $\ke$ is recorded in $\opset$. 
%This is because while executing, a transaction may write to $\ke$ multiple times. Upon committing however, only the last value written to $\ke$ is propagated to the MKVS. 
%As such, $\opset$ need not include duplicate writes operations for  $\ke$ and thus only records its latest write. 
%This choice is motivated by the atomic visibility of transactions: the intermediate writes to a key are not visible from outside a transaction.
%
%
%Analogously, when tracking the read operations (with tag $\otR$), for each key $\ke$, the fingerprint $\opset$ includes a read operation for $\ke$ \emph{only if} the transaction reads from $\ke$ \emph{before} subsequently writing to it.
%More concretely, a read $\op$ operation from $\ke$ is recorded in $\opset$ if $\op$ reads from the initial value recorded in the snapshot. % $\ss$. 
%That is, read operations track those operations that read from the MKVS and not those that read internally from the updated snapshot.
%These two principles, \emph{last-write} and \emph{read-before-write}, are formalised in the definition of {fingerprint update}, $\opset \addO \op$,  in \cref{def:ops} below. 
%For convenience, we define $\opset \addO \emptyop \eqdef \opset$, to denote fingerprint update with respect to an operation with no effect.
%
%
%In what follows we write $\op \projection{i}$ to denote the $i$\textsuperscript{th} projection of $\op$. 
%We lift this notation to sets and write \eg $\{\op_1 \cdots \op_n\}\projection{i}$ for the set comprising the $i$\textsuperscript{th} projection of $\op_1 \cdots \op_n$. 
%
%\ac{Need to say: I am strongly against using the projections $\projection{i}$ for components, as they do not give any intuition 
%about what that component is used for: $\mathsf{Tag}(\op), \mathsf{Key}(\Op)$ and $\mathsf{Value}(Op)$ 
%are much more meaningful than $\op\projection_{1}, \op \projection_2, \op \projection{3}$.}
%
%
%
%%The fingerprints include the \emph{first read preceding a write} and \emph{last write} for each key.
%%This is because a transaction is executed atomically, all the intermediate steps are not observable from the outside world.
%%The \emph{fingerprints} formally is a set of \emph{operations} \( \Ops \) which are either read \( (\etR, \addr, \val)\) from the \( \ke \) with the value \( \val \), or write \( (\etW, \addr, \val) \) to the key \( \ke \) with the value \( \val \) (\cref{def:ops}).
%
%
%%
%%Note that In the \cref{def:ops}, the \( (.)\projection{(.)} \) denotes projection.
%%For a tuple, for example \( \op\projection{i} \), it gives the \emph{i-th} element of the tuple.
%%It is lifted to a set of tuples, for example \( \opset\projection{i}\), which gives a set of all the \emph{i-th} elements.
%%The well-formedness condition for fingerprints asserts it is a set of operations in which there are at most one read and one write for each key.
%%The composition, then, is defined as set disjointed union as long as the result is well-formed.
% 
%
%\begin{definition}[Operations and fingerprints]
%\label{def:ops}
%The set of \emph{operations} is \( \op \in \Ops \eqdef \powerset{\Set{\otR, \otW}} \times \Addr \times \Val\).
%%A \emph{transaction operation} is a tuple of \emph{an operation tag} that is either read or write, an key and a value.
%%\[
%%\begin{rclarray}
%%\op \in \Ops & \defeq  & \powerset{\Set{\otR, \otW}} \times \Addr \times \Val
%%\end{rclarray}
%%\]
%\emph{A fingerprint}, \( \opset \in \Opsets \), is a subset of \( \Ops \) in which any two elements contain either different tags or different keys:
%\[
%    \begin{rclarray}
%        \Opsets & \defeq & \Setcon{\opset}{%
%            \opset \subseteq \Events \land \fora{\op, \op' \in \opset} 
%            \op\projection{1} \neq  \op'\projection{1} \lor \op\projection{2} \neq  \op'\projection{2}  } \\
%    \end{rclarray}
%\]
%%
%The \emph{fingerprint update function}, $\addO: \Opsets \times \Ops \cup \{\emptyop\} \rightarrow \Opsets$, is defined as follows: 
%\[
%\begin{array}{@{} c @{\qquad} c @{}}
%\begin{rclarray}
%    \opset \addO (\etR, \addr, \val) & \defeq & 
%    \begin{cases}
%        \opset \cup \{(\etR, \addr, \val)\} & \for{\mathit{tg}, v'} (\mathit{tg}, \addr, v') \notin \opset \\\\
%        \opset &  \text{otherwise} \\
%    \end{cases} \\
%\end{rclarray}
%&
%\begin{rclarray}
%    \opset \addO (\etW, \addr, \val) & \defeq & 
%    \left( \opset \setminus \setcomp{(\etW, \addr, v')}{v' \in \Val} \right) \\
%    && \cup\ \{(\etW, \addr, \val)\} \\
%    \opset \addO \emptyop & \defeq & \opset \\
%\end{rclarray}
%\end{array}
%\]
%
%
%The \emph{fingerprint unit element} is \( \unitE \defeq \emptyset\); 
%the \emph{fingerprint composition}, $\composeO: \Opsets \times \Opsets \rightharpoonup \Opsets$,  is defined when two fingerprints contain operations with distinct keys: 
%\[ 
%\begin{rclarray}
%    \opset \composeO \opset' & \defeq & 
%    \begin{cases}
%        \opset \uplus \opset' & \text{if } \opset\projection{2} \cap \opset'\projection{2} = \emptyset \\
%        \text{undefined} & \text{otherwise}
%    \end{cases}
%\end{rclarray}
%\]
%\end{definition}
%%\pg{ \(\opset \addO \opset'\)?. \sx{We can define this but not sure it is useful}}
%%
%%\begin{lemma}
%%The well-formedness of fingerprints is closed under \( \addO \).
%%\end{lemma}
%%\azalea{What is $\addO$? You have not defined this yet.}
%
%\mypar{Operational Semantics of Transactions}
%The \emph{operational semantics of transactions} (\cref{def:language}) is given at the bottom of  \cref{fig:transaction_semantics},
%described with respect to a transactional state of the form \((\stk, \sn, \opset)\), where $\stk$ denotes a local variable stack (\cref{def:stacks}), $\sn$ denotes an MKVS snapshot (\cref{def:snapshot}), and $\opset$ denotes a fingerprint (\cref{def:ops}).\\
%%
%\indent To this end, we first define a \emph{local state transformer} on pairs of stacks and snapshots for primitive commands \(\trans_{p}\) (top of  \cref{fig:transaction_semantics}).
%More concretely, we write $(\stk, \h)  \toLTS{\trans_{p}} (\stk', \h')$ to denote that executing $\trans_p$ updates the stack $\stk$ and snapshot $\h$, to $\stk'$ and $\h'$, respectively.
%Additionally, we compute the fingerprint (effect) of a primitive command via the $\funcFont{fp}$ function and write $\func{fp}{\stk, \h, \trans_p}$ to denote the effect of $\trans_p$ on stack $\stk$ and snapshot $\h$.\\
%%
%%We also define its fingerprint by \( \funcn{fp} \) function, which denotes the contribution of the primitive command that might observed by the external environment, \ie transactions from other threads.
%%The \( \funcn{fp} \) extracts the read or write operation from loop-up and mutation respectively, otherwise \( \emptyop \).
%%We also define a binary operator \( \opset \addO \op \) that specifies the effects of adding a new operation \( \op \) to the fingerprints \( \opset \).
%%If the new operation is a read, for example \((\otR, \addr, \val)\) where \( \addr \) is the key and \( \val\) is the associated value, and there is no other operation related to the same key, this new read operation will be included in the result.
%%Meanwhile, if the new operation is a write, it will overwrite all preview write operations to the same key.
%%This ensures the fingerprints contains only the first read preceding a write, and only the last write for each key.
%%This choice is motivated by the fact that we only focus on atomically visible transactions: keys are read from a snapshot of the database, and new version are written only at the moment the transaction commits.
%%For technical reasons, if the right hand side is a special token \( \emptyop \) corresponding to a command does not result in an interaction with key-value store.
%%Therefore, the semantics for primitive command \(\rl{TPrimitive}\) updates the stack and heap by the transformers relation and updates the operation set by first extracting the operation and adding it via \( \addO \) operator.
%%The semantics for non-deterministic choices \(\rl{TChoice}\), sequential compositions \(\rl{TSeqSkip}\) and \(\rl{TSeq}\), and iteration \(\rl{TIter}\) have the expected behaviours.
%%
%\indent Each step of the operational semantics updates the stack and snapshot using the local state transformer, and updates the fingerprint via the \( \addO \) function.
%The behaviour of all transitions in \cref{fig:transaction_semantics} is standard.
%
%
%\begin{figure}[!t]
%\sx{Arrows open for discussion}
%\hrule%\vspace{5pt}
%%\begin{flushleft}
%%The state transformers on pairs of stacks and snapshots for the primitive commands \(\trans_{p}\) (left), and the \( \funcn{op} \) for extracting the operation from the primitive commands (right):
%%\end{flushleft}
%\[
%\begin{array}{@{} c @{\qquad} c @{}}
%\begin{rclarray}
%(\Stacks \times \Heaps)\!\!\! & \toLTS{\trans_p} &   (\Stacks \times \Heaps)  \vspace{5pt}\\
%(\stk, \h)  & \toLTS{\passign{\var}{\expr}}          & (\stk\rmto{\var}{\evalE{\expr}}, \h)                  \\
%(\stk, \h)  & \toLTS{\pderef{\var}{\expr}}           & (\stk\rmto{\var}{\h(\evalE{\expr})}, \h)              \\
%(\stk, \h)  & \toLTS{\pmutate{\expr_{1}}{\expr_{2}}} & (\stk, \h\rmto{\evalE{\expr_{1}}}{\evalE{\expr_{2}}}) \\
%(\stk, \h)  & \toLTS{\passume{\expr}}                & (\stk, \h) \text{ where } \evalE{\expr} \neq 0          
%%(\stk, \h) & \toLTS{\preturn{\expr}}                & (\stk\rmto{\ret}{\evalE{\expr}}, \h)                 
%\end{rclarray}                                                                                               
%&
%\begin{array}{@{} l @{}}
%\funcFont{fp}: \Stacks \times \Heaps \times \trans_p \rightarrow \Ops \cup \{\emptyop\} \vspace{5pt} \\
%\begin{rclarray}
%\func{fp}{\stk, \h, \passign{\var}{\expr}}          & \defeq & \emptyop                                     \\
%\func{fp}{\stk, \h, \pderef{\var}{\expr}}           & \defeq & (\etR, \evalE{\expr}, \h(\evalE{\expr}))     \\
%\func{fp}{\stk, \h, \pmutate{\expr_{1}}{\expr_{2}}} & \defeq & (\etW, \evalE{\expr_{1}}, \evalE{\expr_{2}}) \\
%\func{fp}{\stk, \h, \passume{\expr}}                & \defeq & \emptyop                                     \\
%\func{fp}{\stk, \h, \preturn{\expr}}                & \defeq & \emptyop                                     
%\end{rclarray}
%\end{array}
%\end{array}
%\]
%
%%\hrule\vspace{5pt}
%%\begin{flushleft}
%%The binary operator \( \opset \addO \op \) that specifies the effects of adding a new operation \( \op \) to the set \( \opset \):
%%\end{flushleft}
%%\[
%%\begin{array}{c @{\qquad} c}
%%\begin{rclarray}
%%    \opset \addO (\etR, \addr, \val) & \defeq & 
%%    \begin{cases}
%%        \opset \uplus \Set{(\etR, \addr, \val)} & (\stub, \addr, \stub) \notin \opset \\
%%        \opset &  \text{otherwise} \\
%%    \end{cases} \\
%%\end{rclarray}
%%&
%%\begin{rclarray}
%%    \opset \addO (\etW, \addr, \val) & \defeq & \left( \opset \setminus \Set{(\etW, \addr, \stub)} \right) \uplus \Set{(\etW, \addr, \val)} \\
%%    \opset \addO \emptyop & \defeq & \opset \\
%%\end{rclarray}
%%\end{array}
%%\]
%
%\hrule%\vspace{5pt}
%%\begin{flushleft}
%%Given the set of stacks \( \Stacks \) (\cref{def:stacks}), heaps \( \Heaps \) (\cref{def:heaps}) and transactions \( \Transactions \) (\cref{def:language}) and the arithmetic expression evaluation \( \evalE{\expr} \) (\cref{def:language}), the \emph{operational semantics of transactions}:
%%\end{flushleft}
%\[
%\begin{rclarray}
%\toL & : & ((\Stacks \times \Heaps \times \Opsets) \times \Transactions) \times ((\Stacks \times \Heaps \times \Opsets) \times \Transactions)
%\end{rclarray}
%\]
%
%\begin{mathpar}
%    \inferrule[\rl{TPrimitive}]{%
%        (\stk, \h) \toLTS{\transpri} (\stk', \h')
%        \\ \op = \func{fp}{\stk, \h, \transpri}
%    }{%
%        (\stk, \h, \opset) , \transpri \ \toL \  (\stk', \h', \opset \addO \op) , \pskip \rangle
%    }
%    \and
%    \inferrule[\rl{TChoice}]{
%        i \in \Set{1,2}
%    }{%
%        (\stk, \h, \opset) , \trans_{1} \pchoice \trans_{2} \ \toL \  (\stk, \h, \opset) , \trans_{i}
%    }
%    \and
%    \inferrule[\rl{TIter}]{ }{%
%        (\stk, \h, \opset),  \trans\prepeat \ \toL \  (\stk, \h, \opset), \pskip \pchoice (\trans \pseq \trans\prepeat)
%    } 
%    \and
%    \inferrule[\rl{TSeqSkip}]{ }{%
%        (\stk, \h, \opset), \pskip \pseq \trans \ \toL \  (\stk, \h, \opset), \trans
%    }
%    \and
%    \inferrule[\rl{TSeq}]{%
%        (\stk, \h, \opset), \trans_{1} \ \toL \  (\stk', \h', \opset'), \trans_{1}'
%    }{%
%        (\stk, \h, \opset), \trans_{1} \pseq \trans_{2} \ \toL \  (\stk', \h', \opset'), \trans_{1}' \pseq \trans_{2}
%    }
%\end{mathpar}
%\hrule
%\caption{Operational semantics of transactions}
%\label{fig:transaction_semantics}
%\end{figure}
%

