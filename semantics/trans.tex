\subsection{Programming Language and Operational Semantics}

In this section we define a simple programming language for client programs interacting with a key-value store where clients can only interact with the key-value store using transactions. 
We abstract from aborting transactions: rather than assuming that a transaction may abort due to a violation of the consistency guarantees given by the key-value store, we only allow the execution of a transaction when its effects are guaranteed to not violate the consistency model of the key-value store. This approach is equivalent to a setting where clients always restart a transaction after it aborts.
\sx{The sentence is too long. I think before the ``:'' is enough}
 
\subsubsection{Programming Language}

\emph{A program} \( \prog \) contains fixed numbers of clients associated with their \emph{commands} (\defref{def:language}).
Each client has a unique identifier \( \txid \in \ThreadID \).
For better presentation, we often write \( \cmd_{1} \ppar \cmd_{2} \ppar \dots \ppar \cmd_{n}\) as a syntactic sugar for a program \( \prog \) with implicit unique client identifiers \( \prog = \Set{\thid_{1} \mapsto \cmd_{1}, \thid_{2} \mapsto \cmd_{2}, \dots, \thid_{n} \mapsto \cmd_{n}  }\), where \( \cmd_i\) denotes commands.
The \emph{commands}, ranged over by $\cmd$, are defined by an inductive grammar comprising the standard constructs of $\pskip$, sequential composition ($\cmd; \cmd$), non-deterministic choice ($\cmd+\cmd$) and iterations ($\cmd^*$).
To simulate conditional branching and iterations, we have primitive commands: assume (\( \passume{\expr}\)) and assignment (\( \passign{\var}{\expr} \)), where \( \var \) denotes stack variable and \( \expr \) denotes arithmetic expressions which have no side effect.
Additionally, the programming language contains the \emph{transaction} construct $\ptrans{\trans}$ denoting the \emph{atomic} execution of the transaction $\trans$. 
The atomicity guarantees the execution are dictated by the underlying consistency model.
\emph{Transactions}, ranged over by $\trans$, are defined by a similar inductive grammar comprising $\pskip$, the primitive command \( \transpri \), non-deterministic choice, iteration and sequential composition.
The primitive commands include assignment (\( \passign{\var}{\expr}\)), lookup (\( \pderef{\expr}{\expr}\)), mutation (\( \pmutate{\expr}{\expr}\)) and assume (\( \passume{\expr}\)). 
The arithmetic expression is interpreted to a value (\defref{def:eval-expr}) via a stack \( \stk \in \Stacks \) (\defref{def:stacks}) and there is no side-effect.
Transactions do \emph{not} contain the \emph{parallel} composition construct ($\ppar$) as they are to be executed atomically.

%We assume a valid transactions codes must have the only return at the end.
%For better presentation, sometime we omit the default return zero \( \preturn{0} \).
%Transactions can only assign to their own variables, namely transaction variables (\defref{def:program_values}), but it can read from both the thread and transaction stacks.

%\begin{defn}[Program values]
%where $ \nat \in \Nat$ denotes the set of natural numbers.
%\end{defn}


\begin{defn}[Programming language]
\label{def:language}
\label{def:program_values}
A \emph{program}, $\prog \in \Programs$, is a partial finite function from thread identifiers to commands.
Assuming the set of \emph{variables} \( \var \in \Vars \), the commands \( \cmd \in \Commands \) are defined by the following grammar:
\[
    \begin{rclarray}
    \cmd & ::= &
        \pskip \mid 
        \passign{\thvar}{\expr} \mid
        \passume{\expr} \mid
        \ptrans{\trans} \mid 
        \cmd \pseq \cmd \mid 
        \cmd \pchoice \cmd \mid 
        \cmd \prepeat 
    \end{rclarray}
\]
The $\trans \in \Transactions$ in the grammar above denotes a \emph{transaction} defined by the following grammar:
%The transaction codes \( \ptrans{\trans} \) satisfy a well-form condition that there is exactly a return at the end, \ie \( \ptrans{\trans} \iff \exsts{\trans', \expr} \trans \equiv ( \trans' \pseq \preturn{\expr} )  \land \pred{noRet}{\trans'} \).
\[
    \begin{rclarray}
        \transpri & ::= &
        \pass{\txvar}{\expr} \mid
        \pderef{\txvar}{\expr} \mid
        \pmutate{\expr}{\expr} \mid
        \passume{\expr} \mid \\
        %\preturn{\expr} \\
        \trans & ::= &
        \pskip \mid
        \transpri \mid 
        \trans \pseq \trans \mid
        \trans \pchoice \trans \mid
        \trans\prepeat
    \end{rclarray}
\]
Given the set of \emph{keys}, $\addr \in \Addr$ (\defref{def:mkvs}), the set of \emph{program values} is $\val \in \Val \eqdef \Nat \cup \Addr$.
The $\expr \in \Expressions$ denotes an \emph{arithmetic expression} defined by the grammar below with $\val \in \Val$:
\[
    \begin{rclarray}
        \expr & ::= &
        \val \mid
        \var \mid
        \expr + \expr \mid
        \expr \times \expr \mid
        \dots 
    \end{rclarray}
\]
\end{defn}

\begin{defn}[Stacks]
\label{def:stacks}
A \emph{stack} is a partial finite function from variables \( \Vars \) (\defref{def:language}) to program values \( \Val \) (\defref{def:program_values}): \( \stk \in \Stacks \defeq \Vars \parfinfun \Val \).
\end{defn}

\begin{defn}[Evaluation of expression]
\label{def:eval-expr}
Given a stack $\stk \in \Stacks$ (\defin\ref{def:stacks}), the \emph{arithmetic expression evaluation} function, $\evalE[(.)]{.}:\Expressions \times \Stacks \parfun \Val$, is defined inductively over the structure of expressions as follows: 
%
\[
    \begin{rclarray}
        \evalE{\val} & \defeq & \val \\
        \evalE{\var} & \defeq & \stk(\var) \\
        \evalE{\expr_{1} + \expr_{2}} & \defeq & \evalE{\expr_{1}} + \evalE{\expr_{2}} \\
        \evalE{\expr_{1} \times \expr_{2}} & \defeq & \evalE{\expr_{1}} \times \evalE{\expr_{2}} \\
        \dots & \eqdef & \dots \\
    \end{rclarray}
\]
\end{defn}

\subsubsection{Semantics for transactions}

When a transaction starts, it determines a local snapshot from the current state of the system and a view, which we will explain the process in \secref{sec:prog-semantics}.
The transaction also installed with \emph{a operation set} which is initially empty.
Then time the transaction executes a primitive command \( \transpri\), the operation set get updated to trace the effect of the command.
At the end, the transaction throw away the local snapshot, but commit the operation set to the system.

The operation set, intuitively, contains a transaction's contribution when the transaction is about to commit.
This means it includes the \emph{first read} and \emph{last write} for each key, because a transaction is executed atomically, all the intermediate steps are not observable from the outside world.
The operation set formally is a set of \emph{operations} \( \Ops \) which are either read \( (\etR, \addr, \val)\) from the \( \ke \) with the value \( \val \), or write \( (\etW, \addr, \val) \) to the key \( \ke \) with the value \( \val \) (\defref{def:ops}).
Note that In the \defref{def:ops}, the \( (.)\projection{(.)} \) denotes projection.
For a tuple, for example \( \op\projection{i} \), it gives the \emph{i-th} element of the tuple.
It is lifted to a set of tuples, for example \( \opset\projection{i}\), which gives a set of all the \emph{i-th} elements.
The well-formedness condition for operation set asserts it is a set of operations in which there are at most one read and one write for each key.
The composition, then, is defined as set disjointed union as long as the result is well-formed.
 

\begin{definition}[Operation and operation set]
\label{def:ops}
A \emph{transaction operation} \( \op \in \Ops \) is a tuple of \emph{an operation tag} containing either read or write, an key and a value.
\[
\begin{rclarray}
\OTags & \defeq & \Set{\otR, \otW} \\
\op \in \Ops & \defeq  & \OTags \times \Addr \times \Val
\end{rclarray}
\]
\emph{A well-formed operation set}, \( \opset \in \Opsets \), is a subset of \( \Ops \) in which any two elements contain either different tags or different key.
\[
    \begin{rclarray}
        \Opsets & \defeq & \Setcon{\opset}{\opset \subseteq \Events \land \wfO{\opset} } \\
        \wfO{\opset} & \defeq & \fora{\op, \op' \in \opset} \op\projection{1} \neq  \op'\projection{1} \lor \op\projection{2} \neq  \op'\projection{2}
    \end{rclarray}
\]
The unit element is \( \unitE \defeq \emptyset\) and the composition of two set of operations is the disjointed union when the two sets contain disjointed keyes,
\[ 
\begin{rclarray}
    \opset \composeO \opset' & \defeq & 
    \begin{cases}
        \opset \uplus \opset' & \text{if } \opset\projection{2} \cap \opset'\projection{2} = \emptyset \\
        \text{undefined} & \text{otherwise}
    \end{cases}
\end{rclarray}
\]
\end{definition}
\pg{ \(\opset \addO \opset'\)?. \sx{We can define this but not sure it is useful}}

\begin{lem}
The \( \addO \) operator preserves the well-formedness property.
\end{lem}

The operational semantics for transactions \(\trans\) (\figref{fig:transaction_semantics}) is defined with respect to a transactional state of the form \((\stk, \sn, \opset)\) comprising a stack, a snapshot and a \emph{operation set}.
We first define a state transformers between pairs of stacks and heaps for the primitive commands \(\trans_{p}\).
We also define its operation by \( \funcn{op} \) function, which denotes the contribution of the primitive command that might observed by the external environment, \ie transactions from other threads.
The \( \funcn{op} \) extracts the read or write operation from loop-up and mutation respectively, otherwise \( \emptyop \).
We also define a binary operator \( \opset \addO \op \) that specifies the effects of adding a new operation \( \op \) to the set \( \opset \).
If the new operation is a read, for example \((\otR, \addr, \val)\) where \( \addr \) is the key and \( \val\) is the associated value, and there is no other operation related to the same key, this new read operation will be included in the result.
Meanwhile, if the new operation is a write, it will overwrite all preview write operations to the same key.
This ensures the set contains the first read and last write.
For technical reasons, if the right hand side is a special token \( \emptyop \), which represents \emph{no operation}, the operation set remains the same.
Therefore, the semantics for primitive command \(\rl{TPrimitive}\) updates the stack and heap by the transformers relation and updates the operation set by first extracting the operation and adding it via \( \addO \) operator.
The semantics for non-deterministic choices \(\rl{TChoice}\), sequential compositions \(\rl{TSeqSkip}\) and \(\rl{TSeq}\), and iteration \(\rl{TIter}\) have the expected behaviours.

\begin{figure}[!t]
\hrule\vspace{5pt}
\sx{design choice: assume zero or non-zero? }
\[
\begin{array}{@{} r c l r  c l @{}}
    (\stk, \h) & \toLTS{\passign{\var}{\expr}} & (\stk\rmto{\var}{\evalE{\expr}}, \h) & \func{fp}{\stk, \h, \passign{\var}{\expr}} & \defeq & \emptyop \\
    (\stk, \h) & \toLTS{\pderef{\var}{\expr}} & (\stk\rmto{\var}{\h(\evalE{\expr})}, \h) & \func{fp}{\stk, \h, \pderef{\var}{\expr}} & \defeq & (\etR, \evalE{\expr}, \h(\evalE{\expr})) \\
    (\stk, \h) & \toLTS{\pmutate{\expr_{1}}{\expr_{2}}} & (\stk, \h\rmto{\evalE{\expr_{1}}}{\evalE{\expr_{2}}}) & \func{fp}{\stk, \h, \pmutate{\expr_{1}}{\expr_{2}}} & \defeq & (\etW, \evalE{\expr_{1}}, \evalE{\expr_{2}}) \\
    (\stk, \h) & \toLTS{\passume{\expr}} & (\stk, \h) \text{ where } \evalE{\expr} = 0 & \func{fp}{\stk, \h, \passume{\expr}} & \defeq & \emptyop \\
    %(\stk, \h) & \toLTS{\preturn{\expr}} & (\stk\rmto{\ret}{\evalE{\expr}}, \h) & \func{fp}{\stk, \h, \preturn{\expr}} & \defeq & \emptyop \\
\end{array}
\]

\hrule\vspace{5pt}

\[
\begin{rclarray}
    \opset \addO (\etR, \addr, \val) & \defeq & 
    \begin{cases}
        \opset \uplus \Set{(\etR, \addr, \val)} & (\stub, \addr, \stub) \notin \opset \\
        \opset &  \text{otherwise} \\
    \end{cases} \\
    \opset \addO (\etW, \addr, \val) & \defeq & \left( \opset \setminus \Set{(\etW, \addr, \stub)} \right) \uplus \Set{(\etW, \addr, \val)} \\
    \opset \addO \emptyop & \defeq & \opset \\
\end{rclarray}
\]

\hrule\vspace{5pt}
Given the set of stacks \( \Stacks \) (\defref{def:stacks}), heaps \( \Heaps \) (\defin\ref{def:heaps}) and transactions \( \Transactions \) (\defin\ref{def:language}) and the arithmetic expression evaluation \( \evalE{\expr} \) (\defref{def:language}), the \emph{operational semantics of transactions}:
\[
\begin{rclarray}
\toL & : & ((\Stacks \times \Heaps \times \Opsets) \times \Transactions) \times ((\Stacks \times \Heaps \times \Opsets) \times \Transactions)
\end{rclarray}
\]

\[	
    \infer[\rl{TPrimitive}]{%
        (\stk, \h, \opset) , \transpri \ \toL \  (\stk', \h', \opset \addO \op) , \pskip
    }{%
        (\stk, \h) \toLTS{\transpri} (\stk', \h')
        && \op = \func{fp}{\stk, \h, \transpri}
    }
\]

\[
    \infer[\rl{TChoice}]{%
        (\stk, \h, \opset) , \trans_{1} \pchoice \trans_{2} \ \toL \  (\stk, \h, \opset) , \trans_{i}
    }{
        i \in \Set{1,2}
    }
\]

\[
    \infer[\rl{TIter}]{%
        (\stk, \h, \opset),  \trans\prepeat \ \toL \  (\stk, \h, \opset), \pskip \pchoice (\trans \pseq \trans\prepeat)
    }{}
\]


\[
    \infer[\rl{TSeqSkip}]{%
        (\stk, \h, \opset), \pskip \pseq \trans \ \toL \  (\stk, \h, \opset), \trans
    }{%
    }
\]

\[
    \infer[\rl{TSeq}]{%
        (\stk, \h, \opset), \trans_{1} \pseq \trans_{2} \ \toL \  (\stk', \h', \opset'), \trans_{1}' \pseq \trans_{2}
    }{%
        (\stk, \h, \opset), \trans_{1} \ \toL \  (\stk', \h', \opset'), \trans_{1}'
    }
\]

.

\hrule\vspace{5pt}
\caption{Operational semantics for transactions}
\label{fig:transaction_semantics}
\end{figure}

