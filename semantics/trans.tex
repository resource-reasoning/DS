\section{Operational Semantics for Clients of Kv-stores.}
\azalea{I rewrote most of this section.}
In this section we define a simple programming language for client programs interacting with a kv-store. Clients may only interact with the kv-store by 
issuing read and write requests via transactions. 
For simplicity, we abstract away from aborting transactions
: rather than assuming that a transaction may abort due to a violation of the consistency guarantees given by the kv-store, we only allow the execution of a transaction when its effects are guaranteed to not violate the consistency model. This emulates the setting in which clients always restart a transaction if it aborts.
: rather than assuming that a transaction may abort due to a violation of the consistency guarantees given by the kv-store, we only allow the execution of a transaction when its effects are guaranteed to not violate the consistency model. This emulates a setting where clients immediately restart transactions upon aborts.

\begin{figure}
\[
\begin{array}{lcllcl}
\Val &=& \Nat \cup \Addr & 
\expr & ::= &
        \val \mid
        \var \mid
        \expr + \expr \mid
%        \expr \times \expr \mid
        \dots  
 \\
   \cmdpri & ::= & 
   		\pass{\txvar}{\expr} \mid 
   		\passume{\expr} 
    & 
 	\transpri & ::= &
 	    \cmdpri \mid 
%        \pass{\txvar}{\expr} \mid
        \pderef{\txvar}{\expr} \mid
        \pmutate{\expr}{\expr} \mid \\
%        \passume{\expr} \\
	\trans & ::= &
        \pskip \mid
        \transpri \mid 
        \trans \pseq \trans \mid
        \trans \pchoice \trans \mid
        \trans\prepeat   
        &
    \cmd & ::= & 
        \pskip \mid 
%        \passign{\thvar}{\expr} \mid
%        \passume{\expr} \mid
		\cmdpri \mid
        \ptrans{\trans} \mid 
        \cmd \pseq \cmd \mid 
        \cmd \pchoice \cmd \mid 
        \cmd \prepeat \\
 \end{array} 
\]
\hrulefill
\[
	\evalE{\val}  =  \val 
	\qquad 
	\evalE{\var} = \stk(\var) 
	\qquad 
	\evalE{\expr_{1} + \expr_{2}}  =  \evalE{\expr_{1}} + \evalE{\expr_{2}} 
	\qquad 
	\dots
\]
\[
\begin{array}{@{} l @{\qquad} l @{}}
\begin{rclarray}
(\Stacks \times \Heaps)\!\!\! & \toLTS{\trans_p} &   (\Stacks \times \Heaps)  \vspace{5pt}\\
(\stk, \h)  & \toLTS{\passign{\var}{\expr}}          & (\stk\rmto{\var}{\evalE{\expr}}, \h)                  \\
(\stk, \h)  & \toLTS{\pderef{\var}{\expr}}           & (\stk\rmto{\var}{\h(\evalE{\expr})}, \h)              \\
(\stk, \h)  & \toLTS{\pmutate{\expr_{1}}{\expr_{2}}} & (\stk, \h\rmto{\evalE{\expr_{1}}}{\evalE{\expr_{2}}}) \\
(\stk, \h)  & \toLTS{\passume{\expr}}                & (\stk, \h) \text{ where } \evalE{\expr} \neq 0        \\
\end{rclarray}                                                                                               
&
\begin{array}{@{} l @{}}
\funcFont{fp}: \Stacks \times \Heaps \times \trans_p \rightarrow \Ops \cup \{\emptyop\} \vspace{5pt} \\
\begin{rclarray}
\func{fp}{\stk, \h, \passign{\var}{\expr}}          & \defeq & \emptyop                                     \\
\func{fp}{\stk, \h, \pderef{\var}{\expr}}           & \defeq & (\etR, \evalE{\expr}, \h(\evalE{\expr}))     \\
\func{fp}{\stk, \h, \pmutate{\expr_{1}}{\expr_{2}}} & \defeq & (\etW, \evalE{\expr_{1}}, \evalE{\expr_{2}}) \\
\func{fp}{\stk, \h, \passume{\expr}}                & \defeq & \emptyop                                     \\
\end{rclarray}
\end{array}
\end{array}
\]
\hrulefill
\[
\small
\begin{array}{@{} c @{\qquad} c @{}}
\begin{rclarray}
    \opset \addO (\etR, \addr, \val) & \defeq & 
    \begin{cases}
        \opset \cup \{(\etR, \addr, \val)\} & \for{\mathit{tg}, v'} (\mathit{tg}, \addr, v') \notin \opset \\
        \opset &  \text{otherwise} \\
    \end{cases} \\
\end{rclarray}
&
\begin{rclarray}
    \opset \addO (\etW, \addr, \val) & \defeq & 
    \left( \opset \setminus \setcomp{(\etW, \addr, v')}{v' \in \Val} \right) \\
    && \cup\ \{(\etW, \addr, \val)\} \\
    \opset \addO \emptyop & \defeq & \opset \\
\end{rclarray}
\end{array}
\]
\hrulefill
\[
    \inferrule[\rl{TPrimitive}]{%
        (\stk, \h) \toLTS{\transpri} (\stk', \h')
        \\ \op = \func{fp}{\stk, \h, \transpri}
    }{%
        (\stk, \h, \opset) , \transpri \ \toL \  (\stk', \h', \opset \addO \op) , \pskip \rangle
    }
\]
\[
    \inferrule[\rl{PCommit}]{%
        \vi \orderVI  \vi''
%        \\\\ \pred{atomic}{\vi'', \hh}
        \qquad \h = \clpsHH{\hh,\vi''}
        \\\\ (\stk, \h, \emptyset), \trans \ \toL^{*} \  (\stk', \stub,  \opset) , \pskip
 %     \\ \txid \in \func{nextTxid}{\hh,\cl}  
 %       \\\\ \hh' = \func{updateMKVS}{\hh, \vi'', \txid, \opset}  
 %       \\\\ \vi'' \leq \vi'
        %\\ \pred{atomic}{\vi', \hh'}
        %\\ \func{updateView}{\hh, \vi'', \opset} \orderVI \vi'
        \\ \ET \vdash (\hh, \vi'') \triangleright \opset : \vi'
    }{%
        \cl \vdash ( \hh, \vi, \stk ), \ptrans{\trans} \ \toT{(\cl, \vi'', \opset)}_{\ET} \ ( \updateKV(\hh, \vi, \cl, \opset),\vi', \stk' ) , \pskip
    }
\]
\[
    \inferrule[\rl{PSingleThread}]{%
         \cl \vdash ( \mkvs, \vi, \thdenv(\thid) ) , \prog(\thid), \ \toT{\lambda}_{\ET} \  ( \mkvs', \vi', \stk' ) , \cmd'  
    }{%
         (\mkvs, \viewFun\rmto{\thid}{\vi}, \thdenv ), \prog  \ \toT{\lambda}_{\ET} \  ( \mkvs', \viewFun\rmto{\thid}{\vi'}, \thdenv\rmto{\thid}{\stk'} ) , \prog\rmto{\thid}{\cmd'} ) 
    }
\]
\hrulefill
\caption{Syntax and Selected Rules of the Semantics for Clients of Kv-stores
\ac{I had to introduce labels for transitions in the semantics. These is because I need 
to carry the information about the view in which a transaction is executed: this cannot be 
recovered from the pre and post configurations of the transition.}}
\label{fig:semantics}
\end{figure}

%\begin{definition}[Programming language]
%\label{def:language}
%\label{def:program_values}
%A \emph{program}, $\prog \in \Programs$, is a partial finite function from client identifiers to commands.
%The sequential \emph{commands}, \( \cmd \in \Commands \), are defined by the following grammar, where
%$\val \in \Val \eqdef \Nat \cup \Addr$ denotes the set of \emph{program values}, and $\addr \in \Addr$ denotes the set of MKVS keys (\cref{def:mkvs}):
%\[
%\begin{array}{@{} l @{}  l @{}}
%    \begin{rclarray}
%    \cmd & ::= &
%        \pskip \mid 
%        \passign{\thvar}{\expr} \mid
%        \passume{\expr} \mid
%        \ptrans{\trans} \mid 
%        \cmd \pseq \cmd \mid 
%        \cmd \pchoice \cmd \mid 
%        \cmd \prepeat \\
%%
%	 \expr & ::= &
%        \val \mid
%        \var \mid
%        \expr + \expr \mid
%        \expr \times \expr \mid
%        \dots  
%       \end{rclarray} 
%%    
%	& 
%%
%	\begin{rclarray}        
%	\trans & ::= &
%        \pskip \mid
%        \transpri \mid 
%        \trans \pseq \trans \mid
%        \trans \pchoice \trans \mid
%        \trans\prepeat   \\
%%        
%	\transpri & ::= &
%        \pass{\txvar}{\expr} \mid
%        \pderef{\txvar}{\expr} \mid
%        \pmutate{\expr}{\expr} \mid
%        \passume{\expr} 
%%
%    \end{rclarray}
%\end{array} 
%\]
%\end{definition}
 
%\mypar{Programming Language}
\emph{A program} \( \prog \) consists of a finite number of clients, where each client is associated with a unique identifier \( \thid \in \ThreadID \), and executes a sequential \emph{command}. The syntax of commands is given in \cref{fig:semantics}. 
%The clause $\expr, \transpri, \cmdpri, \trans$ and $\cmd$ 
%denote expressions, transactional and non-transactional primitive commands, transactions and commands, respectively.
The syntax of commands in our programming language is roughly standard, exception made for the following: 
primitive commands that can be invoked by clients are split into transactional ones, corresponding to the $\transpri$ clause in the Figure, and which is used for reading 
and writing keys of the kv-store; and non-transactional ones, corresponding to the $\cmdpri$ clause, and which are used for computations over client-local data. 
Transactional primitive commands can be invoked only within the boundaries of transactions (corresponding to $\ptrans{\trans}$) executed by clients in commands;
non-transactional primitive commands can be invoked without restrictions.
% which can 
%be executed by clients in commands (corresponding to $\cmd$). 
%Commands ($\cmd$) are being equipped with a $\ptrans{\trans}$ clause for executing transactions. 
%Read and Write operations over a key-value store, corresponding to the  $\cexpr$
%We thus model a program $\prog$ as a function from client identifiers to commands (\cref{def:language}).
For clarity, we often write \( \cmd_{1}\ppar \dots \ppar \cmd_{n}\) as a syntactic sugar for a program \( \prog \) with $n$ implicit clients associated with identifiers, $\thid_1 \dots \thid_n$, where each client $\thid_i$ executes the command $\cmd_i$:  \( \prog = \Set{\thid_{1} \mapsto \cmd_{1}, \dots, \thid_{n} \mapsto \cmd_{n}  }\).

As it is usual, we assume a language of expressions 
built from \emph{values}, which can be either keys or natural number and are ranged over by $\val, \val', \cdots$; 
and client-local variables from a set $\Vars$, which are ranged over by $\pvar{x}, \pvar{y}, \cdots$. The evaluation $\evalE{\expr}$ of  expression 
$\expr$  is parametric in the (client-local) \emph{stack} $s: \Vars \parfun \Val$, which is a function from variables to values. 
Henceforth we let $\Stacks = \Vars \parfun \Val$

Both transactional and non-transactional commands are equipped with a transformer relation $\toLTS{\cmdpri} \subseteq 
(\Stacks \times \Heaps) \times (\Stacks \times \Heaps)$, as well as a 
novel \emph{fingerprint} function $\func{fp}{\_} : \Stacks \times \Heaps \times \cmdpriset \rightarrow \Ops_{\varepsilon}$, 
examples of which are given in \cref{fig:semantics}. 
\ac{The transformer relation has always been denoted with $\leadsto$. Why did we change it to straight arrows? 
I'm changing it back. Note that the macro has typesetting problems and will need to be changed again.}
The transformer $(\stk, \h)  \toLTS{\cmdpri} (\stk, \h')$ describes how the stack of a client (and, in the case of transactional commands, 
the local snapshot of a transaction) evolve upon executing the primitive command $\cmdpri$.
The function $\func{fp}{\cdot}$ identifies, for each primitive command $\cmdpri$, the operation $\op \in \Ops_{\varepsilon}$
that a client executing $\cmdpri$  performs on the kv-store. Note that non-transactional primitive commands are associated with 
the empty operation $\varepsilon$. 

In \cref{fig:semantics} we illustrate few selected rules of the operational semantics of programs. 
The reader can refer to \cref{app:semantics} {\color{red} appendix reference missing} 
for the complete set of rules of the semantics of clients. 
The first rule in \cref{fig:semantics}, \rl{TPrimitive}, models the execution of both transactional and 
non-transactional primitive commands within the scope of a transaction: the client maintains 
a local-stack $\stk$, a key-value mapping $\h$ which is used to fetch the value of read operations, 
and a set of operations $\opset$ to be applied to the kv-store upon committing the transaction. 
By executing a primitive command $\cmdpri$,  the first two components are updated to $\stk'$ and 
$\h'$, respectively, according to the transformer of the command. The set of operations associated with 
the transaction is also updated to include the new operation $\op$ associated with $\cmdpri$, 
via the operator $\addO$. This operator enforces transactions to record, for each key, the first 
read (before a write) and the last write. This is in line with our assumption that transactions read from an atomic 
snapshot of the kv-store,
(for each key, only the first read before a write fetches its value from the kv-store), 
and clients observe either none or all the effects of a transaction (only the last write of each key is committed).

Transitions for commands executed by individual clients, and transitions of programs in general, are labelled 
either as $(\cl, \iota)$, meaning that some computation that did not require an access to the kv-store 
has been performed by $\cl$ (for example, resolving a non-deterministic choice), or as 
$(\cl, \vi, \opset)$, meaning that client $\cl$ executed a transaction with fingerprint $\opset$ using 
the view $\vi$.
 
Rule \rl{PCommit} models the execution of a transaction $\ptrans{\trans}$ within a command, under the execution 
test $\ET$. Given a stack $\stk$, a 
kv-store $\hh$ and a view $\vi$, a key-value mapping is created for the transaction by taking the 
snapshot $\h$ of $\hh$ induced by $\vi$. Then a fingerprint $\opset$ is calculated by executing the command $\trans$ using 
$\stk$ and $\h$ as an initial state. If there exists a view $\vi'$ such that the $\ET \vdash (\hh, \vi) \triangleright \opset : \vi'$, 
then the effects of $\opset$ are committed to $\hh$, using the function $\updateKV$ from \cref{sec:execution.tests}. 
Note that, because it may be that no such view $\vi'$ exists, Rule \rl{PCommit} allows to update the view $\vi$ to a 
newer one, before executing the transaction $\ptrans{\trans}$.

The last rule, \rl{PSingleThread}, models the execution of a command bound to a client in programs. 
This rule models the standard interleaving semantics of programs, that is a client that is able to 
perform a reduction, can do so in an atomic step, without affecting the state of other clients.
%Expressions in 
%Sequential \emph{commands}, ranged over by $\cmd$, are defined by an inductive grammar comprising the standard constructs of $\pskip$, sequential composition ($\cmd; \cmd$), non-deterministic choice ($\cmd+\cmd$) and loops ($\cmd^*$).
%To simulate conditional branching and loops, commands include the standard constructs of assume (\( \passume{\expr}\)), and assignment (\( \passign{\var}{\expr} \)), where \( \var \) denotes a local variable (on the stack), and \( \expr \) denotes an arithmetic expression with no side effect.  
%evaluated with respect to a stack  with no side effect.
%Arithmetic expressions are evaluated with respect to a local stack (variable store) -- see  \cref{def:stacks,def:eval-expr} below.
%We assume a countably infinite set of local variables, $\Vars $, and use the \texttt{typewriter} font for its meta variables, \eg $\var$.\\
%%
%\indent Commands additionally include the \emph{transaction} construct, $\ptrans{\trans}$, denoting the \emph{atomic} execution of the transaction $\trans$. 
%The atomicity guarantees the execution are dictated by the underlying consistency model.
%\emph{Transactions}, ranged over by $\trans$, are similarly defined by an inductive grammar comprising $\pskip$, \emph{primitive commands} \( \transpri \), non-deterministic choice, loops and sequential composition.
%Primitive commands include assignment (\( \passign{\var}{\expr}\)), lookup (\( \pderef{\expr}{\expr}\)), mutation (\( \pmutate{\expr}{\expr}\)) and assume (\( \passume{\expr}\)). 
%Note that transactions do \emph{not} contain the \emph{parallel} composition construct ($\ppar$) as they are executed atomically.

%We assume a valid transactions codes must have the only return at the end.
%For better presentation, sometime we omit the default return zero \( \preturn{0} \).
%Transactions can only assign to their own variables, namely transaction variables (\defref{def:program_values}), but it can read from both the thread and transaction stacks.

%\begin{definition}[Program values]
%where $ \nat \in \Nat$ denotes the set of natural numbers.
%\end{definition}

%\begin{definition}[Programming language]
%\label{def:language}
%\label{def:program_values}
%A \emph{program}, $\prog \in \Programs$, is a partial finite function from client identifiers to commands.
%The sequential \emph{commands}, \( \cmd \in \Commands \), are defined by the following grammar, where
%$\val \in \Val \eqdef \Nat \cup \Addr$ denotes the set of \emph{program values}, and $\addr \in \Addr$ denotes the set of MKVS keys (\cref{def:mkvs}):
%\[
%\begin{array}{@{} l @{}  l @{}}
%    \begin{rclarray}
%    \cmd & ::= &
%        \pskip \mid 
%        \passign{\thvar}{\expr} \mid
%        \passume{\expr} \mid
%        \ptrans{\trans} \mid 
%        \cmd \pseq \cmd \mid 
%        \cmd \pchoice \cmd \mid 
%        \cmd \prepeat \\
%%
%	 \expr & ::= &
%        \val \mid
%        \var \mid
%        \expr + \expr \mid
%        \expr \times \expr \mid
%        \dots  
%       \end{rclarray} 
%%    
%	& 
%%
%	\begin{rclarray}        
%	\trans & ::= &
%        \pskip \mid
%        \transpri \mid 
%        \trans \pseq \trans \mid
%        \trans \pchoice \trans \mid
%        \trans\prepeat   \\
%%        
%	\transpri & ::= &
%        \pass{\txvar}{\expr} \mid
%        \pderef{\txvar}{\expr} \mid
%        \pmutate{\expr}{\expr} \mid
%        \passume{\expr} 
%%
%    \end{rclarray}
%\end{array} 
%\]
%%The $\trans \in \Transactions$ in the grammar above denotes a \emph{transaction} defined by the following grammar including the primitive transactional commands \( \transpri\):
%%The transaction codes \( \ptrans{\trans} \) satisfy a well-form condition that there is exactly a return at the end, \ie \( \ptrans{\trans} \iff \exsts{\trans', \expr} \trans \equiv ( \trans' \pseq \preturn{\expr} )  \land \pred{noRet}{\trans'} \)
%%\[
%%    \begin{rclarray}
%%        \transpri & ::= &
%%        \pass{\txvar}{\expr} \mid
%%        \pderef{\txvar}{\expr} \mid
%%        \pmutate{\expr}{\expr} \mid
%%        \passume{\expr} \mid \\
%%        %\preturn{\expr} \\
%%        \trans & ::= &
%%        \pskip \mid
%%        \transpri \mid 
%%        \trans \pseq \trans \mid
%%        \trans \pchoice \trans \mid
%%        \trans\prepeat
%%    \end{rclarray}
%%\]
%%Given the set of \emph{keys}, $\addr \in \Addr$ (\cref{def:mkvs}), the set of \emph{program values} is $\val \in \Val \eqdef \Nat \cup \Addr$.
%%The $\expr \in \Expressions$ denotes an \emph{arithmetic expression} defined by the grammar:
%%\[
%%    \begin{rclarray}
%%        \expr & ::= &
%%        \val \mid
%%        \var \mid
%%        \expr + \expr \mid
%%        \expr \times \expr \mid
%%        \dots 
%%    \end{rclarray}
%%\]
%\end{definition}
%
%\begin{definition}[Stacks]
%\label{def:stacks}
%\label{def:eval-expr}
%A \emph{stack}, $\stk \in \Stacks$, is a partial finite function from variables to values: \(\Stacks \defeq \Vars \parfinfun \Val \).
%Given a stack $\stk \in \Stacks$, %(\cref{def:stacks}), 
%the \emph{arithmetic expression evaluation} function, $\evalE[(.)]{.}:\Expressions \times \Stacks \parfun \Val$, is defined inductively over the structure of expressions: 
%%
%\[
%	\evalE{\val}  \defeq  \val 
%	\qquad 
%	\evalE{\var} \defeq \stk(\var) 
%	\qquad 
%	\evalE{\expr_{1} + \expr_{2}}  \defeq  \evalE{\expr_{1}} + \evalE{\expr_{2}} 
%	\qquad
%	\evalE{\expr_{1} \times \expr_{2}}  \defeq  \evalE{\expr_{1}} \times \evalE{\expr_{2}} 
%	\qquad 
%	\dots
%\]
%\end{definition}
%
%%\begin{definition}[Evaluation of expression]
%%\label{def:eval-expr}
%%Given a stack $\stk \in \Stacks$, %(\cref{def:stacks}), 
%%the \emph{arithmetic expression evaluation} function, $\evalE[(.)]{.}:\Expressions \times \Stacks \parfun \Val$, is defined inductively over the structure of expressions: 
%%%
%%\[
%%	\evalE{\val}  \defeq  \val 
%%	\qquad 
%%	\evalE{\var} \defeq \stk(\var) 
%%	\qquad 
%%	\evalE{\expr_{1} + \expr_{2}}  \defeq  \evalE{\expr_{1}} + \evalE{\expr_{2}} 
%%	\qquad
%%	\evalE{\expr_{1} \times \expr_{2}}  \defeq  \evalE{\expr_{1}} \times \evalE{\expr_{2}} 
%%	\qquad 
%%	\dots
%%\]
%%%\[
%%%    \begin{rclarray}
%%%        \evalE{\val} & \defeq & \val \\
%%%        \evalE{\var} & \defeq & \stk(\var) \\
%%%        \evalE{\expr_{1} + \expr_{2}} & \defeq & \evalE{\expr_{1}} + \evalE{\expr_{2}} \\
%%%        \evalE{\expr_{1} \times \expr_{2}} & \defeq & \evalE{\expr_{1}} \times \evalE{\expr_{2}} \\
%%%        \dots & \eqdef & \dots \\
%%%    \end{rclarray}
%%%\]
%%\end{definition}
%
%\subsection{Operational Semantics of Transactions}
%\label{sec:trans-semantics}
%\azalea{I rewrote most of this section.}
%
%\mypar{Operations and Fingerprints}
%Recall that when a transaction starts, it extracts a local snapshot $\ss$ of the MKVS via its view. 
%The execution of the transaction is then carried out \emph{locally} on $\ss$:  
%read operations inspect $\ss$ and write operations update $\ss$. 
%%, as we discuss in \cref{sec:prog-semantics}.
%To track the effect of a transaction while executing, each transaction is associated with a \emph{fingerprint}, initially set to empty. 
%The fingerprint of a transaction records its interactions (read or write operations) with the MKVS.
%Each time a transaction executes a primitive command \( \transpri\) (locally on $\ss$), its fingerprint is updated to track the effect of $\transpri$.
%%More concretely, every time the transaction performs a write operation, 
%Once the local execution of a transaction is complete, its local snapshot is discarded, and the transaction is committed by propagating the effects in its fingerprint to the MKVS.
%%
%
%The fingerprint of a transaction, $\opset$, is modelled as a set of \emph{operations}. 
%Each operation $\op$ is a tuple of the form $(\mathit{tag}, \ke, \val)$, where $\mathit{tag}$ denotes the operation type and may be one of $\otW$ for \emph{write} operations, or $\otR$ for \emph{read} operations; 
%the $\ke$ denotes the operation key, and  $\val$ denotes the operation value. 
%For instance, $(\otW, \ke, \val)$ denotes the execution of an operation where value $\val$ is written to key $\ke$; and
%$(\otR, \ke, \val)$ denotes the execution of an operation where value $\val$ is read from key $\ke$.
%
%
%When tracking the write operations (with tag $\otW$) in a fingerprint $\opset$, for each key $\ke$, only the effect of the \emph{last} write to $\ke$ is recorded in $\opset$. 
%This is because while executing, a transaction may write to $\ke$ multiple times. Upon committing however, only the last value written to $\ke$ is propagated to the MKVS. 
%As such, $\opset$ need not include duplicate writes operations for  $\ke$ and thus only records its latest write. 
%This choice is motivated by the atomic visibility of transactions: the intermediate writes to a key are not visible from outside a transaction.
%
%
%Analogously, when tracking the read operations (with tag $\otR$), for each key $\ke$, the fingerprint $\opset$ includes a read operation for $\ke$ \emph{only if} the transaction reads from $\ke$ \emph{before} subsequently writing to it.
%More concretely, a read $\op$ operation from $\ke$ is recorded in $\opset$ if $\op$ reads from the initial value recorded in the snapshot. % $\ss$. 
%That is, read operations track those operations that read from the MKVS and not those that read internally from the updated snapshot.
%These two principles, \emph{last-write} and \emph{read-before-write}, are formalised in the definition of {fingerprint update}, $\opset \addO \op$,  in \cref{def:ops} below. 
%For convenience, we define $\opset \addO \emptyop \eqdef \opset$, to denote fingerprint update with respect to an operation with no effect.
%
%
%In what follows we write $\op \projection{i}$ to denote the $i$\textsuperscript{th} projection of $\op$. 
%We lift this notation to sets and write \eg $\{\op_1 \cdots \op_n\}\projection{i}$ for the set comprising the $i$\textsuperscript{th} projection of $\op_1 \cdots \op_n$. 
%
%\ac{Need to say: I am strongly against using the projections $\projection{i}$ for components, as they do not give any intuition 
%about what that component is used for: $\mathsf{Tag}(\op), \mathsf{Key}(\Op)$ and $\mathsf{Value}(Op)$ 
%are much more meaningful than $\op\projection_{1}, \op \projection_2, \op \projection{3}$.}
%
%
%
%%The fingerprints include the \emph{first read preceding a write} and \emph{last write} for each key.
%%This is because a transaction is executed atomically, all the intermediate steps are not observable from the outside world.
%%The \emph{fingerprints} formally is a set of \emph{operations} \( \Ops \) which are either read \( (\etR, \addr, \val)\) from the \( \ke \) with the value \( \val \), or write \( (\etW, \addr, \val) \) to the key \( \ke \) with the value \( \val \) (\cref{def:ops}).
%
%
%%
%%Note that In the \cref{def:ops}, the \( (.)\projection{(.)} \) denotes projection.
%%For a tuple, for example \( \op\projection{i} \), it gives the \emph{i-th} element of the tuple.
%%It is lifted to a set of tuples, for example \( \opset\projection{i}\), which gives a set of all the \emph{i-th} elements.
%%The well-formedness condition for fingerprints asserts it is a set of operations in which there are at most one read and one write for each key.
%%The composition, then, is defined as set disjointed union as long as the result is well-formed.
% 
%
%\begin{definition}[Operations and fingerprints]
%\label{def:ops}
%The set of \emph{operations} is \( \op \in \Ops \eqdef \powerset{\Set{\otR, \otW}} \times \Addr \times \Val\).
%%A \emph{transaction operation} is a tuple of \emph{an operation tag} that is either read or write, an key and a value.
%%\[
%%\begin{rclarray}
%%\op \in \Ops & \defeq  & \powerset{\Set{\otR, \otW}} \times \Addr \times \Val
%%\end{rclarray}
%%\]
%\emph{A fingerprint}, \( \opset \in \Opsets \), is a subset of \( \Ops \) in which any two elements contain either different tags or different keys:
%\[
%    \begin{rclarray}
%        \Opsets & \defeq & \Setcon{\opset}{%
%            \opset \subseteq \Events \land \fora{\op, \op' \in \opset} 
%            \op\projection{1} \neq  \op'\projection{1} \lor \op\projection{2} \neq  \op'\projection{2}  } \\
%    \end{rclarray}
%\]
%%
%The \emph{fingerprint update function}, $\addO: \Opsets \times \Ops \cup \{\emptyop\} \rightarrow \Opsets$, is defined as follows: 
%\[
%\small
%\begin{array}{@{} c @{\qquad} c @{}}
%\begin{rclarray}
%    \opset \addO (\etR, \addr, \val) & \defeq & 
%    \begin{cases}
%        \opset \cup \{(\etR, \addr, \val)\} & \for{\mathit{tg}, v'} (\mathit{tg}, \addr, v') \notin \opset \\\\
%        \opset &  \text{otherwise} \\
%    \end{cases} \\
%\end{rclarray}
%&
%\begin{rclarray}
%    \opset \addO (\etW, \addr, \val) & \defeq & 
%    \left( \opset \setminus \setcomp{(\etW, \addr, v')}{v' \in \Val} \right) \\
%    && \cup\ \{(\etW, \addr, \val)\} \\
%    \opset \addO \emptyop & \defeq & \opset \\
%\end{rclarray}
%\end{array}
%\]
%
%
%The \emph{fingerprint unit element} is \( \unitE \defeq \emptyset\); 
%the \emph{fingerprint composition}, $\composeO: \Opsets \times \Opsets \rightharpoonup \Opsets$,  is defined when two fingerprints contain operations with distinct keys: 
%\[ 
%\begin{rclarray}
%    \opset \composeO \opset' & \defeq & 
%    \begin{cases}
%        \opset \uplus \opset' & \text{if } \opset\projection{2} \cap \opset'\projection{2} = \emptyset \\
%        \text{undefined} & \text{otherwise}
%    \end{cases}
%\end{rclarray}
%\]
%\end{definition}
%%\pg{ \(\opset \addO \opset'\)?. \sx{We can define this but not sure it is useful}}
%%
%%\begin{lemma}
%%The well-formedness of fingerprints is closed under \( \addO \).
%%\end{lemma}
%%\azalea{What is $\addO$?? You have not defined this yet.}
%
%\mypar{Operational Semantics of Transactions}
%The \emph{operational semantics of transactions} (\cref{def:language}) is given at the bottom of  \cref{fig:transaction_semantics},
%described with respect to a transactional state of the form \((\stk, \sn, \opset)\), where $\stk$ denotes a local variable stack (\cref{def:stacks}), $\sn$ denotes an MKVS snapshot (\cref{def:snapshot}), and $\opset$ denotes a fingerprint (\cref{def:ops}).\\
%%
%\indent To this end, we first define a \emph{local state transformer} on pairs of stacks and snapshots for primitive commands \(\trans_{p}\) (top of  \cref{fig:transaction_semantics}).
%More concretely, we write $(\stk, \h)  \toLTS{\trans_{p}} (\stk', \h')$ to denote that executing $\trans_p$ updates the stack $\stk$ and snapshot $\h$, to $\stk'$ and $\h'$, respectively.
%Additionally, we compute the fingerprint (effect) of a primitive command via the $\funcFont{fp}$ function and write $\func{fp}{\stk, \h, \trans_p}$ to denote the effect of $\trans_p$ on stack $\stk$ and snapshot $\h$.\\
%%
%%We also define its fingerprint by \( \funcn{fp} \) function, which denotes the contribution of the primitive command that might observed by the external environment, \ie transactions from other threads.
%%The \( \funcn{fp} \) extracts the read or write operation from loop-up and mutation respectively, otherwise \( \emptyop \).
%%We also define a binary operator \( \opset \addO \op \) that specifies the effects of adding a new operation \( \op \) to the fingerprints \( \opset \).
%%If the new operation is a read, for example \((\otR, \addr, \val)\) where \( \addr \) is the key and \( \val\) is the associated value, and there is no other operation related to the same key, this new read operation will be included in the result.
%%Meanwhile, if the new operation is a write, it will overwrite all preview write operations to the same key.
%%This ensures the fingerprints contains only the first read preceding a write, and only the last write for each key.
%%This choice is motivated by the fact that we only focus on atomically visible transactions: keys are read from a snapshot of the database, and new version are written only at the moment the transaction commits.
%%For technical reasons, if the right hand side is a special token \( \emptyop \) corresponding to a command does not result in an interaction with key-value store.
%%Therefore, the semantics for primitive command \(\rl{TPrimitive}\) updates the stack and heap by the transformers relation and updates the operation set by first extracting the operation and adding it via \( \addO \) operator.
%%The semantics for non-deterministic choices \(\rl{TChoice}\), sequential compositions \(\rl{TSeqSkip}\) and \(\rl{TSeq}\), and iteration \(\rl{TIter}\) have the expected behaviours.
%%
%\indent Each step of the operational semantics updates the stack and snapshot using the local state transformer, and updates the fingerprint via the \( \addO \) function.
%The behaviour of all transitions in \cref{fig:transaction_semantics} is standard.
%
%
%\begin{figure}[!t]
%\sx{Arrows open for discussion}
%\hrule%\vspace{5pt}
%%\begin{flushleft}
%%The state transformers on pairs of stacks and snapshots for the primitive commands \(\trans_{p}\) (left), and the \( \funcn{op} \) for extracting the operation from the primitive commands (right):
%%\end{flushleft}
%\[
%\begin{array}{@{} c @{\qquad} c @{}}
%\begin{rclarray}
%(\Stacks \times \Heaps)\!\!\! & \toLTS{\trans_p} &   (\Stacks \times \Heaps)  \vspace{5pt}\\
%(\stk, \h)  & \toLTS{\passign{\var}{\expr}}          & (\stk\rmto{\var}{\evalE{\expr}}, \h)                  \\
%(\stk, \h)  & \toLTS{\pderef{\var}{\expr}}           & (\stk\rmto{\var}{\h(\evalE{\expr})}, \h)              \\
%(\stk, \h)  & \toLTS{\pmutate{\expr_{1}}{\expr_{2}}} & (\stk, \h\rmto{\evalE{\expr_{1}}}{\evalE{\expr_{2}}}) \\
%(\stk, \h)  & \toLTS{\passume{\expr}}                & (\stk, \h) \text{ where } \evalE{\expr} \neq 0          
%%(\stk, \h) & \toLTS{\preturn{\expr}}                & (\stk\rmto{\ret}{\evalE{\expr}}, \h)                 
%\end{rclarray}                                                                                               
%&
%\begin{array}{@{} l @{}}
%\funcFont{fp}: \Stacks \times \Heaps \times \trans_p \rightarrow \Ops \cup \{\emptyop\} \vspace{5pt} \\
%\begin{rclarray}
%\func{fp}{\stk, \h, \passign{\var}{\expr}}          & \defeq & \emptyop                                     \\
%\func{fp}{\stk, \h, \pderef{\var}{\expr}}           & \defeq & (\etR, \evalE{\expr}, \h(\evalE{\expr}))     \\
%\func{fp}{\stk, \h, \pmutate{\expr_{1}}{\expr_{2}}} & \defeq & (\etW, \evalE{\expr_{1}}, \evalE{\expr_{2}}) \\
%\func{fp}{\stk, \h, \passume{\expr}}                & \defeq & \emptyop                                     \\
%\func{fp}{\stk, \h, \preturn{\expr}}                & \defeq & \emptyop                                     
%\end{rclarray}
%\end{array}
%\end{array}
%\]
%
%%\hrule\vspace{5pt}
%%\begin{flushleft}
%%The binary operator \( \opset \addO \op \) that specifies the effects of adding a new operation \( \op \) to the set \( \opset \):
%%\end{flushleft}
%%\[
%%\begin{array}{c @{\qquad} c}
%%\begin{rclarray}
%%    \opset \addO (\etR, \addr, \val) & \defeq & 
%%    \begin{cases}
%%        \opset \uplus \Set{(\etR, \addr, \val)} & (\stub, \addr, \stub) \notin \opset \\
%%        \opset &  \text{otherwise} \\
%%    \end{cases} \\
%%\end{rclarray}
%%&
%%\begin{rclarray}
%%    \opset \addO (\etW, \addr, \val) & \defeq & \left( \opset \setminus \Set{(\etW, \addr, \stub)} \right) \uplus \Set{(\etW, \addr, \val)} \\
%%    \opset \addO \emptyop & \defeq & \opset \\
%%\end{rclarray}
%%\end{array}
%%\]
%
%\hrule%\vspace{5pt}
%%\begin{flushleft}
%%Given the set of stacks \( \Stacks \) (\cref{def:stacks}), heaps \( \Heaps \) (\cref{def:heaps}) and transactions \( \Transactions \) (\cref{def:language}) and the arithmetic expression evaluation \( \evalE{\expr} \) (\cref{def:language}), the \emph{operational semantics of transactions}:
%%\end{flushleft}
%\[
%\begin{rclarray}
%\toL & : & ((\Stacks \times \Heaps \times \Opsets) \times \Transactions) \times ((\Stacks \times \Heaps \times \Opsets) \times \Transactions)
%\end{rclarray}
%\]
%
%\begin{mathpar}
%    \inferrule[\rl{TPrimitive}]{%
%        (\stk, \h) \toLTS{\transpri} (\stk', \h')
%        \\ \op = \func{fp}{\stk, \h, \transpri}
%    }{%
%        (\stk, \h, \opset) , \transpri \ \toL \  (\stk', \h', \opset \addO \op) , \pskip \rangle
%    }
%    \and
%    \inferrule[\rl{TChoice}]{
%        i \in \Set{1,2}
%    }{%
%        (\stk, \h, \opset) , \trans_{1} \pchoice \trans_{2} \ \toL \  (\stk, \h, \opset) , \trans_{i}
%    }
%    \and
%    \inferrule[\rl{TIter}]{ }{%
%        (\stk, \h, \opset),  \trans\prepeat \ \toL \  (\stk, \h, \opset), \pskip \pchoice (\trans \pseq \trans\prepeat)
%    } 
%    \and
%    \inferrule[\rl{TSeqSkip}]{ }{%
%        (\stk, \h, \opset), \pskip \pseq \trans \ \toL \  (\stk, \h, \opset), \trans
%    }
%    \and
%    \inferrule[\rl{TSeq}]{%
%        (\stk, \h, \opset), \trans_{1} \ \toL \  (\stk', \h', \opset'), \trans_{1}'
%    }{%
%        (\stk, \h, \opset), \trans_{1} \pseq \trans_{2} \ \toL \  (\stk', \h', \opset'), \trans_{1}' \pseq \trans_{2}
%    }
%\end{mathpar}
%\hrule
%\caption{Operational semantics of transactions}
%\label{fig:transaction_semantics}
%\end{figure}
%

\mypar{Traces of Programs}
In this Section we define the set of $\ET$-traces generated by a program 
$\prog$. Our main goal is that of proving that our semantics is correct, 
meaning that if a program $\prog$ executing under the execution 
test $\ET$ terminates in a state $(\hh, \_)$, then $\hh \in \CMs(\ET)$. 

\begin{definition}
Let $\ET$ be an execution test. For each program $\prog$ and state 
$(\hh, \viewFun, \thdenv)$, we define $\OPtraces(\ET, \prog, \hh, \viewFun, \thdenv)$ 
as the smallest set such that 
\begin{itemize}
\item $(\hh, \viewFun) \in \OPtraces(\ET, \prog, \hh, \viewFun, \thdenv)$, 
\item if $\tr \in \OPtraces(\ET, \prog', \hh', \viewFun',\thdenv')$, 
and $((\hh, \viewFun, \thdenv) , \prog) \toT{(\cl, \iota)}_{\ET} (\hh', \viewFun', \thdenv')$, 
then $\tr \in \OPtraces(\ET, \prog, \hh, \viewFun, \thdenv')$, 
\item if $\tr$ in $\OPtraces(\ET, \prog', \hh', \viewFun', \thdenv')$ and 
% $(\hh', \viewFun') \in \OPtraces(\ET, \prog', \hh', \viewFun', \thdenv')$ and
\newline $(\hh, \viewFun, \thdenv), \prog) \toT{(\cl, \vi, \opset)} ((\hh', \viewFun', \thdenv'), \prog')$,  
then $(\hh, \viewFun) \xrightarrowtriangle{(\cl, \varepsilon)}_{\ET} (\hh, \viewFun\rmto{\cl}{\vi}) 
\xrightarrowtriangle{(\cl, \opset)}_{\ET} \tr$ in $\OPtraces(\ET, \prog, \hh, \viewFun, \thdenv)$. 
\end{itemize}

The set of traces generated by a program $\prog$ under the execution test $\ET$ is 
then defined as $\OPtraces(\ET, \prog) \triangleq (\OPtraces(\ET, \prog, \hh_{0}, \viewFun_{0}, 
\thdenv_{0})$, where $\viewFun_{0} = \lambda \cl \in \dom(\prog).\lambda \ke.\{0\}$, and 
$\thdenv_{0} = \lambda \cl \in \dom(\prog).\lambda a.0$.

\end{definition}

\begin{proposition}
For each program $\prog$ and execution test $\ET$, 
$\OPtraces(\ET, \prog) \subseteq \KVtrace(\ET)$. 
Furthermore, each $\tr \in \OPtraces(\ET, \prog)$ is in normal form. 
\end{proposition}

\begin{corollary}
If $(\hh_{0}, \viewFun_{0}, \thdenv_{0}), \prog) \toL{\ET} \cdots \toL{\ET} 
(\hh, \viewFun, \thdenv, \lambda \cl \in \dom(\prog). \pskip)$, then $\hh \in \CMs(\ET)$.
\end{corollary}

\begin{proposition}
For any program $\prog$ and execution test $\ET$, $\OPtraces(\ET, \prog) = \OPtraces(\ET_{\top}, \prog) 
\cap \CMs(\ET)$.
\end{proposition}

\ac{These results should be easy to prove, either I or somebody else will type up a proof 
at some point.}

\subsection{Adequacy of the Semantics.}
\begin{figure}
\[
    \inferrule[\rl{ACommit}]{
        \T \subseteq \T_{\aexec} \qquad \h \in \RP(\aexec, \T) \qquad
		(\stk, \h, \emptyset), \trans \ \toL^{*} \  (\stk', \stub,  \opset) , \pskip \\\\
		\txid \in \nextTxId(\T_{\aexec}, \cl) \qquad \aexec' = \extend(\aexec, \txid, \T, \opset) \qquad 
		\forall A \in \Ax.\;\{\txid' \mid (\txid', \txid) \in \A(\aexec') \} \subseteq \T
    }{
        \cl \vdash ( \aexec, \stk ), \ptrans{\trans} \ \toA{(\cl, \T, \opset)}_{(\RP, \Ax)} \ ( \aexec', \stk' ) , \pskip
    }
\]
\[
    \inferrule[\rl{ASingleThread}]{%
         \cl \vdash ( \aexec, \thdenv(\thid) ) , \prog(\thid), \ \toA{\lambda}_{(\RP, \Ax)} \  ( \aexec', \stk' ) , \cmd'  
    }{%
         (\aexec, \thdenv ), \prog  \ \toA{\lambda}_{(\RP, \Ax)} \  ( \aexec', \thdenv\rmto{\thid}{\stk'} ) , \prog\rmto{\thid}{\cmd'} ) 
    }
\]
\hrulefill
\caption{Selected Rule of the Semantics for Programs using Abstract Executions.}
\label{fig:aexec.semantics}
\end{figure}
Suppose that a given execution test $\ET$ captures precisely 
a consistency model specified in the axiomatic style, using a set of 
axioms $\Ax$ and a resolution policy $\RP$ over abstract executions.
That is, for any abstract execution $\aexec$ that satisfies 
the axioms $\Ax$ and the resolution policy $\RP$, then $\KVtrace(\ET_{\top}, \aexec) \cap \CMs(\ET) \neq \emptyset$; 
and for any $\tr \in \CMs(\ET)$, there exists an abstract execution 
$\aexec \in \aeset(\tr)$ that satisfies the axioms $\Ax$ and the resolution policy $\RP$. 
\ac{In practice, the functions $\KVtrace(\ET, \aexec) = \KVtrace(\ET_{\top}, \aexec) \cap \CMs(\ET)$, 
and $\aeset(\Ax, \aexec) = \aeset(\ET_{\top}, \aexec) \cap \aeset(\Ax)$, abstracted over the second 
argument and lifted to sets of abstract executions/traces, 
define a Galois Connection between the powerset of abstract executions in the axiomatic specification 
of the consistency model, and the powerset of kv-stores generated by such a consistency model.}
Our main aim in this section consists in proving that, for each program $\prog$, the 
set of kv-stores generated by $\prog$ under $\ET$ corresponds to all the possible kv-stores 
that could be obtained by running $\prog$ on a database that satisfies the axiomatic specification 
$\Ax$. In this sense, we aim to establish that our operational semantics is \emph{adequate}.

To tackle this question, we need to define what is the set of all possible behaviours 
that can be produced by a program $\prog$ under a given consistency model $\CM$, for 
which an axiomatic specification $(\RP, \Ax)$ is known. This in turn requires addressing two orthogonal 
problems: \textbf{(i)} defining the set of all possible behaviours that may be exhibited by a program 
$\prog$, independently of the consistency model; and \textbf{(ii)} defining the set of all possible 
behaviours that are allowed by a given consistency model $\CM$. Then the set of all 
possible behaviours of $\prog$ under $\CM$ is obtained by intersecting the two sets 
above.

The kv-store semantics is intrinsically not expressive enough to tackle problem \textbf{(i)}. 
By \cref{cor:kvtrace2aexec}, only kv-stores arising 
from abstract executions satisfying the last write wins resolution policy can be captured in the kv-store 
framework; instead, we seek to model all the behaviours of a program independently of a consistency 
models, and therefore independently of a resolution policy. 

Our solution requires defining an alternative semantics of programs under weak consistency models, 
based on abstract executions. The operational semantics we propose is parameterised in 
the axiomatic specification $(\RP, \Ax)$ of a consistency model: transitions take the form 
$(\aexec, \Env, \prog) \toA{\_}_{(\RP, \Ax)} (\aexec', \Env', \prog')$. 

In \cref{fig:aexec.semantics} we illustrate two rules of the operational semantics of programs 
based on abstract executions. The complete operational semantics is given in \ref{app:aexec.semantics}. 
\ac{Todo: type down the semantics. This must be done in order to prove the Theorem that 
establishes the correspondence between kv-store semantics and abstract execution semantics.} 
Rule \rl{ACommit} is the abstact execution counterpart of rule \rl{PCommit} for kv-stores, in that 
it models how an abstract execution $\aexec$ evolves when a client wants to execute a transaction whose 
code is $\ptrans{\trans}$. In this rule, $\T$ is the set of transactions of $\aexec$ that are visible to the client 
$\cl$ that wishes to execute $\ptrans{\trans}$. Such a set of transactions is used to determine a snapshot 
$\h \in \RP(\aexec, \T)$ that the client $\cl$ uses to execute the code $\ptrans{\trans}$, and obtain a 
fingerprint $\opset$. This fingerprint is then used to extend abstract execution $\aexec$ with 
a transaction from the set $\nextTxId(\T_{\aexec}, \cl)$. Another rule in \cref{fig:aexec.semantics} 
is Rule \rl{ASinglethread}; the structure of this rule is analogous to \rl{PSingleThread}, and it models 
multi-thread concurrency in an interleaving fashion. All the rules of the abstract operational semantics 
that are not illustrated in \cref{fig:aexec.semantics} have a similar counterpart in the kv-store semantics.

In some sense that is going to be made mathematically precise later, Rule \rl{ACommit} is more general 
than Rule \rl{Pcommit} in the kv-store semantics. In the latter, the snapshot of a transaction is uniquely 
determined from a view of the client, in a way that roughly corresponds to the last write wins policy 
in the abstract execution framework. In contrast, in Rule \rl{ACommit} the snapshot of a transaction 
is chosen non-deterministically from those made available to the client by the resolution policy 
$\RP$ adopted by a weak consistency model, which may not necessarily be $\RP_{\LWW}$. 
One example of resolution policy that we will use in this Section is given by the anarchic resolution policy. 

\begin{definition}
The anarchic resolution policy $\RP_{\anarchic}$ is defined by letting, 
$\RP_{\anarchic}(\_, \_) = \Snapshots$. The \emph{anarchic consistency model} is 
specified axiomatically by the pair $\anarchicCM = (\RP_{\anarchic}, \emptyset)$.
\end{definition}

\begin{example}
Suppose that we want to execute the single-threaded program $\prog$ that maps client 
$\cl$ to the transactional code below:
\[
\begin{session}
%\ptrans{\pmutate{\ke}{\val_2}}; \\
\ptrans{\pderef{\pvar{a}}{\ke}; \\
\pifs{\pvar{a} = \val_{1}} \pmutate{\ke'}{\val_1} \pife}
\end{session}
\]
Suppose that the program is executed under a consistency model that adopts the last write 
wins resolution policy $\RP_{\LWW}$, and with no additional axioms. Then the behaviour of $\prog$ is 
completely deterministic (up-to the choice of transaction identifiers), and the execution of $\prog$ terminates in a 
state corresponding to the abstract execution below: 

\begin{center}
\begin{tikzpicture}[scale=0.85, every node/.style={transform shape}]

\node(t0rx) at (-1,2) {$(\otR, \ke, \val_0)$}; 
%\path (t0wx.south) + (0,-0.2) node[anchor=north] (t0wy) {$(\otW, \ke_2, \val'_0)$};

\begin{pgfonlayer}{background}
\node[background, fit=(t0rx)]  {};

\path(t0.west) node[anchor=east] (t0lbl) {$\txid_{\cl}^{\_}$};
%\path(t1.north) node[anchor=south] (t1lbl) {$\txid_1$};
%\path(t2.south) node[anchor=north] (t2lbl) {$\txid_2$};

%\path[->]
%(t0.north) edge[bend left=70] node[above, yshift=7pt, xshift=-1pt, pos=0.3] {$\RF(\ke_2), \VO(\ke_1)$} (t1.west)
%(t0.south) edge[bend right=70] node[below, yshift=-8pt, xshift=-1pt, pos=0.3] {$\RF(\ke_1), \VO(\ke_2)$} (t2.west)
%([xshift=-8pt]t2.north) edge[bend left=40] node[left] {$\AD(\ke_1)$} ([xshift=-8pt]t1.south) 
%([xshift=8pt]t1.south) edge[bend left=40] node[right] {$\AD(\ke_2)$} ([xshift=8pt]t2.north);
\end{pgfonlayer}
\end{tikzpicture}
\end{center}

However, if we replace the consistency model specification $(\RP_{\LWW}, \emptyset)$ with the 
anarchic one $\anarchicCM$. Because the snapshot in which client $\cl$ executes the 
transactional code above is chosen non-deterministically, 
the program $\prog$ exhibits infinitely many additional behaviours. 
In particular, the program may now terminate in a state corresponding 
to the abstract execution below: 

\begin{center}
\begin{tikzpicture}[scale=0.85, every node/.style={transform shape}]

\node(t0rx) at (-1,2) {$(\otR, \ke, \val_1)$}; 
\path (t0wx.east) + (0,0.2) node[anchor=west] (t0wy) {$(\otW, \ke', \val_1)$};

\begin{pgfonlayer}{background}
\node[background, fit=(t0rx) (t0wy)]  {};

\path(t0.west) node[anchor=east] (t0lbl) {$\txid_{\cl}^{\_}$};
%\path(t1.north) node[anchor=south] (t1lbl) {$\txid_1$};
%\path(t2.south) node[anchor=north] (t2lbl) {$\txid_2$};

%\path[->]
%(t0.north) edge[bend left=70] node[above, yshift=7pt, xshift=-1pt, pos=0.3] {$\RF(\ke_2), \VO(\ke_1)$} (t1.west)
%(t0.south) edge[bend right=70] node[below, yshift=-8pt, xshift=-1pt, pos=0.3] {$\RF(\ke_1), \VO(\ke_2)$} (t2.west)
%([xshift=-8pt]t2.north) edge[bend left=40] node[left] {$\AD(\ke_1)$} ([xshift=-8pt]t1.south) 
%([xshift=8pt]t1.south) edge[bend left=40] node[right] {$\AD(\ke_2)$} ([xshift=8pt]t2.north);
\end{pgfonlayer}
\end{tikzpicture}
\end{center}

It is important to note, however, that the set of abstract executions generated by $\prog$ is still bound 
to the structure of the program itself. For example, executing $\prog$ under the anarchic execution model 
will never lead to an abstract execution with multiple transactions, or to an abstract execution where a transaction 
writes a key other than $\ke'$ is written.
\end{example}

\begin{definition}
The semantics of a program $\prog$ under a consistency model with axiomatic specification 
$(\RP, \Ax)$ is given by 
\[
\interpr{\prog}_{(\RP, \Ax)} = \{ \aexec \mid (\aexec_{0}, \Env_{0}, \prog) \toA{\_}_{(\RP, \Ax)}^{\ast} (\aexec, \_, \prog_{f}) \}, 
\]
where $\Env_{0} = \lambda \cl \in \dom(\prog).\lambda \pvar{x}.0$ and $\prog_{f} = \lambda \cl \in \dom(\prog).\pskip$.
\end{definition}

We define the set of all the possible behaviours of a program $\prog$ to be $\interpr{\prog}_{\anarchic}$. 
The following result supports our claim that this definition is indeed accurate: 

\begin{proposition}
Let $\aexec$ be an abstract execution. Then $\aexec$ satsifies $\anarchicCM$.
\end{proposition}

\begin{example}
One may argue that the axiomatic specification $\anarchicCM$ does not 
truly represent an anarchic consistency model. Consider for example the single-threaded 
program $\prog'$ that associates to a client $\cl$ the following code:
\[
\begin{session}
%\ptrans{\pmutate{\ke}{\val_1}}; \\
\ptrans{
\pderef{\pvar{a}}{\ke}; \\
\pderef{\pvar{b}}{\ke};\\
\pifs{\pvar{a} != \pvar{b}} \pmutate{\ke'}{\val_1} \pife}
\end{session}
\]
One would expect that, under a truly anarchic consistency model, it would be possible 
for program $\prog'$ to write the value $\val_1$ for key $\ke'$. However, 
this never happens if $\prog'$ is executed under $\anarchicCM$. This is because 
we embedded into abstract execution the assumption that transactions only read 
at most one value for each key. 

In theory, we could lift this limitation and still retain 
the validity of all the results contained in this report; however, doing so would 
require to work with mathematical structures that are far more complex than 
abstract executions, and we preferred to avoid this issue. 
Furthermore, the constraint that an object is never read twice in transactions is enforced 
at client side in virtually all the implementations {\color{red} to be checked} 
of libraries for accessing kv-stores. When a client first requests to fetch 
the value of some key $\ke$ within a transaction, a local copy of the value fetched is 
saved on the client (typically in an object containing the meta-data of the transaction); 
if a request to read the same key is performed again within the same client, the local 
copy of the value previously fetched for that key is returned, instead of issuing a second 
read request to the kv-store.
\end{example}

As explained above, the set of all possible behaviours exhibited by a program $\prog$ under a 
consistency model $(\RP, \Ax)$ can be defined by intersecting the set of executions 
that $\prog$ exhibits under the anarchic consistency model, with the set of all executions 
allowed by the axiomatic specification $(\RP, \Ax)$. As the next theorem shows, 
this is exactly the set of abstract executions in which $\prog$ terminates, 
when executed under the axiomatic specification $(\RP, \Ax)$.

\begin{theorem}
For any program $\prog$ and axiomatic specification $(\RP, \Ax)$:
\[
\interpr{\prog}_{(\RP, \Ax)} = \interpr{\prog}_{\anarchic} \cap \CMa(\RP, \Ax). 
\]
\end{theorem}
\ac{The proof was already typed up in the other set of notes, will need to do 
cut, paste and adapt in the appendix.}


\mypar{Comparing the abstract execution and kv-store semantics.}

\begin{proposition}
\label{prop:kv2aexec_transition}
Suppose that $(\hh, \viewFun, \thdenv), \prog \toT{(\cl, \vi, \opset)}_{\ET_{\top}} (\hh', 
\viewFun', \thdenv'), \prog'$. Let $\aexec$ be an abstract execution 
such that $\hh_{\aexec} = \hh$, and let $\T \subseteq \T_{\aexec}$ be a 
set of read-only transactions. Then there exists an abstract execution $\aexec'$ 
such that $\hh_{\aexec'} = \hh'$, and 
\[
(\aexec, \thdenv), \prog \toA{(\cl, \T \cup \Tx(\hh, \vi), \opset)}_{(\RP_{\LWW}, \emptyset)}. 
(\aexec', \thdenv'), \prog'
\]
\end{proposition}

\begin{proposition}
\label{prop:aexec2kv_transition}
Suppose that $(\aexec, \thdenv), \prog \toA{(\cl, \T, \opset)}_{(\RP_{\LWW})} (\aexec', \thdenv'), \prog'$. 
Then for any $\viewFun$ and $\vi \in \Views(\hh_{\aexec})$ such that $\vi \viewleq \getView(\aexec, \T)$, 
we have that 
\[
(\hh_{\aexec}, \viewFun\rmto{\cl}{\vi}, \thdenv), \prog \toA{(\cl, \getView(\aexec, \T), \opset)}_{\ET_{\top}} (\hh_{\aexec'}, \viewFun, \thdenv'), \prog'.
\]
\end{proposition}

\begin{corollary}
For any program $\prog$, 
\[
\interpr{\prog}_{\ET_{\top}} = \{\hh_{\aexec} \mid \aexec \in \interpr{\prog}_{(\RP_{\LWW}, \emptyset)}\}
\]
\end{corollary}

\mypar{Putting it all together}
To conclude this Section, we show how all the results illustrated so far 
can be put together to show that the kv-store operational semantics is adequate. 
\begin{definition}
A \emph{client-based invariant condition}, or simply \emph{invariant}, is a 
function $I : \aeset \times \Clients \rightarrow \powerset{\TxID}$ 
such that for any $\cl$ we have that $I(\aeset, \cl) \subseteq \T_{\aexec}$, and 
for any  $\cl'$ such that $\cl' \neq \cl$ we have that 
$I(\extend(\aexec, \txid_{\cl'}^{\cdot}, \_, \_), \cl) = I(\aexec, \cl)$.
%of triples of the form $(\aexec, \cl, \T)$ such that whenever 
%$(\aexec, \cl, \T) \in I$ then $\T \subseteq \aexec$, 
%for any $\cl' \neq \cl$ and transaction $\txid = \txid_{\cl'}^{\cdot}$, 
%then $(\extend(\aexec, \txid, \_, \_)), \cl, \T) \in I$, 
%and for any $\T' : \T \subseteq \T' \subseteq \T_{\aexec}$, 
%$(\aexec, \cl ,\T') \in I$.
\end{definition}
\ac{The idea behind client-based invariant being that $I(\aexec, \cl)$ represents 
the minimal set of transactions that $\cl$ must see in $\aexec$, before 
updating the view and performing a transaction. Such a set of transaction 
roughly correspond to the view of the client before performing a 
sequence of \emph{update view+execute transaction} operations, 
or equivalently from the view obtained after the execution of the 
last transaction from that client.}

%\begin{definition}
%\label{def:et_sound}
%An execution test $\ET$ is sound with respect to an axiomatic 
%specification $(\RP_{\LWW}, \Ax)$ if and only if there exists an 
%invariant condition $I$ such that whenever $\ET \vdash (\hh, \vi) 
%\triangleright \opset: \vi'$, for any $\aexec$ such that 
%$\hh_{\aexec} = \hh$, and for any client $\cl$, and for any 
%transaction identifier $\txid \in \nextTxId(\hh, \cl)$, 
%%and for any $\T \subseteq \T_{\aexec}$ such that 
%%$\getView(\aexec, \T) = \vi$ 
%and $I(\aexec, \cl) \subseteq \Tx(\hh, \vi)$, then  
%there exist a set of read-only transactions $\T_{\mathsf{rd}}$ and 
%a set of transactions 
%%$\T \subseteq \T_{\aexec}$ and 
%$\T' \subseteq \T_{\aexec} \cup \{\txid\}$ 
%\begin{itemize}
%%\item $\getView(\aexec, \T) = \vi$, $I(\aexec, \cl) \subseteq \T$, 
%\item $\forall \A \in \Ax. \{\txid' \mid (\txid', \txid) \in \A(\aexec')\} \subseteq \Tx(\hh, \vi) \cup \T_{\mathsf{rd}}$, 
%where $\aexec' = \extend(\aexec, \txid, \Tx(\hh, \vi), \opset)$ for $\txid \in \nextTxId(\hh, \cl)$, 
%\item $I(\aexec', \cl) \subseteq \T'$, where $\T' = \Tx(\aexec', \vi')$. 
%\end{itemize}
%\end{definition}

\begin{definition}
\label{def:et_sound}
An execution test $\ET$ is sound with respect to an axiomatic 
specification $(\RP_{\LWW}, \Ax)$ if and only if there exists an 
invariant condition $I$ such that whenever $\ET \vdash (\hh, \vi) 
\triangleright \opset: \vi'$, for any $\aexec$ such that 
$\hh_{\aexec} = \hh$,  for any client $\cl$,for any 
transaction identifier $\txid \in \nextTxId(\hh, \cl)$, 
%and for any $\T \subseteq \T_{\aexec}$ such that 
%$\getView(\aexec, \T) = \vi$ 
and for any set of transactions $\T_{\mathsf{rd}}$ that are 
read-only in $\aexec$ such that  $I(\aexec, \cl) \subseteq \Tx(\hh, \vi) \cup \T_{\mathsf{rd}}$, then  
there exist two other sets of transactions $\T'_{\mathsf{rd}}, \T''_{\mathsf{rd}}$, 
which are read-only in $\aexec$ and $\aexec' := \extend(\aexec, \txid, 
\Tx(\hh,\vi) \cup \T_{\mathsf{rd}} \cup \T'_{\mathsf{rd}}, \opset)$, respectively, such that 
%$\T \subseteq \T_{\aexec}$ and 
%$\T' \subseteq \T_{\aexec} \cup \{\txid\}$ 
\begin{itemize}
%\item $\getView(\aexec, \T) = \vi$, $I(\aexec, \cl) \subseteq \T$, 
\item $\forall \A \in \Ax. \{\txid' \mid (\txid', \txid) \in \A(\aexec')\} \subseteq \Tx(\hh, \vi) \cup \T_{\mathsf{rd}} \cup \mathsf{T}'_{\mathsf{rd}}$, 
%where $\aexec' = \extend(\aexec, \txid, \Tx(\hh, \vi), \opset)$ for $\txid \in \nextTxId(\hh, \cl)$, 
\item $I(\aexec', \cl) \subseteq \Tx(\aexec', \vi') \cup \T''_{\mathsf{rd}}$
%, where $\T' = \Tx(\aexec', \vi')$. 
\end{itemize}
\end{definition}

\begin{theorem}
\label{thm:et_soundness}
If $\ET$ is sound with respect to $(\RP_{\LWW}, \Ax)$, then 
$\CMs(\ET) \subseteq \{ \hh \mid \exists \aexec \in \CMa(\RP_{\LWW}, \Ax)).\;\hh_{\aexec} = \hh\}$.
\end{theorem}

\begin{corollary}
\label{thm:et_soundness}
\label{cor:et-soundness}
If $\ET$ is sound with respect to $(\RP_{\LWW}, \Ax)$, then 
for any program $\prog$, $\interpr{\prog}_{\ET} \subseteq \{ \hh_{\aexec} \mid \aexec \in \interpr{P}_{(\RP_{\LWW}, \Ax)}$.
\end{corollary}

\begin{definition}
An execution test $\ET$ precisely captures an axiomatic specification 
$(\RP_{\LWW}, \Ax)$ if and only if
\begin{itemize}
\item given a kv-store $\hh$ and a view $\vi \in \Views(\hh)$ and a set of operations 
$\opset$ such that $\ET \vdash \hh, \vi \triangleright \opset : \_$, then for any 
abstract execution $\aexec$ such that $\hh_{\aexec} = \hh$, there exists a set 
of transactions $\T = \T' \cup \Tx(\hh, \vi)$, where $\T' \subseteq \T_{\aexec}$ 
only contains read-only transactions, such that for any $\A \in \Ax.\;\{ \txid' \mid (\txid', \txid) \in \A(\extend(\aexec, \_, \T, \opset)) \times \subseteq \T$, 
\item given an abstract execution $\aexec$, a transaction identifier $\txid \notin \T_{\aexec}$, a 
set of operations $\opset$ and a set of transactions $\T$ such that 
$\forall \A \in \Ax.\{\txid' \mid (\txid', \txid) \in \A(\extend(\aexec, \txid, \T, \opset))\} \subseteq \T$, 
then $\ET \vdash \hh_{\aexec}, \getView(\aexec, \T) \triangleright \opset : \_$. 
\end{itemize}
\end{definition}

\begin{theorem}
If $\ET$ precisely captures the axiomatic specification $(\RP_{\LWW}, \Ax)$, then 
\label{thm:prooftechnique_sound}
\begin{itemize}
\item $\CMs((\RP_{\LWW}, \Ax)) = \{ \hh_{\aexec} \mid \aexec \in \CMa(\RP_{\LWW}, \Ax)\}$, 
\item $\forall \prog. \interpr{\prog}_{(\RP_{\LWW}, \Ax)} = \{ \hh_{\aexec} \mid \aexec \in \interpr{\prog}_{\ET} \}$.
\end{itemize}
\end{theorem}
