\subsection{Programming Language and Operational Semantics}

We define a simple programming language for client programs interacting with an MKVS where clients may only interact with the MKVS via transactions. 
For simplicity, we abstract away from aborting transactions: rather than assuming that a transaction may abort due to a violation of the consistency guarantees given by the MKVS, we only allow the execution of a transaction when its effects are guaranteed to not violate the consistency model. This emulates the setting in which clients always restart a transaction if it aborts.
\sx{The sentence is too long. I think before the ``:'' is enough}
 
\subsubsection{Programming Language}

\emph{A program} \( \prog \) contains a fixed number of clients, where each client is associated with a unique identifier \( \thid \in \ThreadID \), and executes a sequential \emph{command}.
We thus model a program $\prog$ as a function from client identifiers  to commands (\cref{def:language}).
For clarity, we often write \( \cmd_{1}\ppar \dots \ppar \cmd_{n}\) as a syntactic sugar for a program \( \prog \) with $n$ implicit clients associated with identifiers, $\thid_1 \dots \thid_n$, where each client $\thid_i$ executes the command $\cmd_i$:  \( \prog = \Set{\thid_{1} \mapsto \cmd_{1}, \dots, \thid_{n} \mapsto \cmd_{n}  }\).
Sequential \emph{commands}, ranged over by $\cmd$, are defined by an inductive grammar comprising the standard constructs of $\pskip$, sequential composition ($\cmd; \cmd$), non-deterministic choice ($\cmd+\cmd$) and loops ($\cmd^*$).
To simulate conditional branching and loops, commands include the standard constructs of assume (\( \passume{\expr}\)), and assignment (\( \passign{\var}{\expr} \)), where \( \var \) denotes a local variable (on the stack), and \( \expr \) denotes an arithmetic expression with no side effect.  
evaluated with respect to a stack  with no side effect.
Arithmetic expressions are evaluated with respect to a local stack (variable store) -- see  \cref{def:stacks,def:eval-expr} below.
We assume a countably infinite set of local variables, $\Vars $, and use the \texttt{typewriter} font for its meta variables, \eg $\var$. 

Commands additionally include the \emph{transaction} construct, $\ptrans{\trans}$, denoting the \emph{atomic} execution of the transaction $\trans$. 
The atomicity guarantees the execution are dictated by the underlying consistency model.
\emph{Transactions}, ranged over by $\trans$, are similarly defined by an inductive grammar comprising $\pskip$, \emph{primitive commands} \( \transpri \), non-deterministic choice, loops and sequential composition.
Primitive commands include assignment (\( \passign{\var}{\expr}\)), lookup (\( \pderef{\expr}{\expr}\)), mutation (\( \pmutate{\expr}{\expr}\)) and assume (\( \passume{\expr}\)). 
Note that transactions do \emph{not} contain the \emph{parallel} composition construct ($\ppar$) as they are executed atomically.

%We assume a valid transactions codes must have the only return at the end.
%For better presentation, sometime we omit the default return zero \( \preturn{0} \).
%Transactions can only assign to their own variables, namely transaction variables (\defref{def:program_values}), but it can read from both the thread and transaction stacks.

%\begin{definition}[Program values]
%where $ \nat \in \Nat$ denotes the set of natural numbers.
%\end{definition}

\begin{definition}[Programming language]
\label{def:language}
\label{def:program_values}
A \emph{program}, $\prog \in \Programs$, is a partial finite function from client identifiers to commands.
The sequential \emph{commands}, \( \cmd \in \Commands \), are defined by the following grammar, where
$\val \in \Val \eqdef \Nat \cup \Addr$ denotes the set of \emph{program values}, and $\addr \in \Addr$ denotes the set of MKVS keys (\cref{def:mkvs}):
\[
\begin{array}{@{} l @{\hspace{20pt}}  l @{}}
    \begin{rclarray}
    \cmd & ::= &
        \pskip \mid 
        \passign{\thvar}{\expr} \mid
        \passume{\expr} \mid
        \ptrans{\trans} \mid 
        \cmd \pseq \cmd \mid 
        \cmd \pchoice \cmd \mid 
        \cmd \prepeat \\
%
	 \expr & ::= &
        \val \mid
        \var \mid
        \expr + \expr \mid
        \expr \times \expr \mid
        \dots  
       \end{rclarray} 
%    
	& 
%
	\begin{rclarray}        
	\trans & ::= &
        \pskip \mid
        \transpri \mid 
        \trans \pseq \trans \mid
        \trans \pchoice \trans \mid
        \trans\prepeat   \\
%        
	\transpri & ::= &
        \pass{\txvar}{\expr} \mid
        \pderef{\txvar}{\expr} \mid
        \pmutate{\expr}{\expr} \mid
        \passume{\expr} 
%
    \end{rclarray}
\end{array} 
\]
%The $\trans \in \Transactions$ in the grammar above denotes a \emph{transaction} defined by the following grammar including the primitive transactional commands \( \transpri\):
%The transaction codes \( \ptrans{\trans} \) satisfy a well-form condition that there is exactly a return at the end, \ie \( \ptrans{\trans} \iff \exsts{\trans', \expr} \trans \equiv ( \trans' \pseq \preturn{\expr} )  \land \pred{noRet}{\trans'} \)
%\[
%    \begin{rclarray}
%        \transpri & ::= &
%        \pass{\txvar}{\expr} \mid
%        \pderef{\txvar}{\expr} \mid
%        \pmutate{\expr}{\expr} \mid
%        \passume{\expr} \mid \\
%        %\preturn{\expr} \\
%        \trans & ::= &
%        \pskip \mid
%        \transpri \mid 
%        \trans \pseq \trans \mid
%        \trans \pchoice \trans \mid
%        \trans\prepeat
%    \end{rclarray}
%\]
%Given the set of \emph{keys}, $\addr \in \Addr$ (\cref{def:mkvs}), the set of \emph{program values} is $\val \in \Val \eqdef \Nat \cup \Addr$.
%The $\expr \in \Expressions$ denotes an \emph{arithmetic expression} defined by the grammar:
%\[
%    \begin{rclarray}
%        \expr & ::= &
%        \val \mid
%        \var \mid
%        \expr + \expr \mid
%        \expr \times \expr \mid
%        \dots 
%    \end{rclarray}
%\]
\end{definition}

\begin{definition}[Stacks]
\label{def:stacks}
\label{def:eval-expr}
A \emph{stack}, $\stk \in \Stacks$, is a partial finite function from variables to values: \(\Stacks \defeq \Vars \parfinfun \Val \).
Given a stack $\stk \in \Stacks$, %(\cref{def:stacks}), 
the \emph{arithmetic expression evaluation} function, $\evalE[(.)]{.}:\Expressions \times \Stacks \parfun \Val$, is defined inductively over the structure of expressions: 
%
\[
	\evalE{\val}  \defeq  \val 
	\qqquad 
	\evalE{\var} \defeq \stk(\var) 
	\qqquad 
	\evalE{\expr_{1} + \expr_{2}}  \defeq  \evalE{\expr_{1}} + \evalE{\expr_{2}} 
	\qqquad
	\evalE{\expr_{1} \times \expr_{2}}  \defeq  \evalE{\expr_{1}} \times \evalE{\expr_{2}} 
	\qqquad 
	\dots
\]
\end{definition}

%\begin{definition}[Evaluation of expression]
%\label{def:eval-expr}
%Given a stack $\stk \in \Stacks$, %(\cref{def:stacks}), 
%the \emph{arithmetic expression evaluation} function, $\evalE[(.)]{.}:\Expressions \times \Stacks \parfun \Val$, is defined inductively over the structure of expressions: 
%%
%\[
%	\evalE{\val}  \defeq  \val 
%	\qquad 
%	\evalE{\var} \defeq \stk(\var) 
%	\qquad 
%	\evalE{\expr_{1} + \expr_{2}}  \defeq  \evalE{\expr_{1}} + \evalE{\expr_{2}} 
%	\qquad
%	\evalE{\expr_{1} \times \expr_{2}}  \defeq  \evalE{\expr_{1}} \times \evalE{\expr_{2}} 
%	\qquad 
%	\dots
%\]
%%\[
%%    \begin{rclarray}
%%        \evalE{\val} & \defeq & \val \\
%%        \evalE{\var} & \defeq & \stk(\var) \\
%%        \evalE{\expr_{1} + \expr_{2}} & \defeq & \evalE{\expr_{1}} + \evalE{\expr_{2}} \\
%%        \evalE{\expr_{1} \times \expr_{2}} & \defeq & \evalE{\expr_{1}} \times \evalE{\expr_{2}} \\
%%        \dots & \eqdef & \dots \\
%%    \end{rclarray}
%%\]
%\end{definition}

\subsubsection{Semantics for transactions}
\label{sec:trans-semantics}

When a transaction starts, it determines a local snapshot from the current state of the system and a view, which we will explain the process in \cref{sec:prog-semantics}.
The transaction also installed with \emph{fingerprints} which is initially empty.
The fingerprints of a transaction corresponds to the set of all its interaction with the key-value store.
Each time the transaction executes a primitive command \( \transpri\) internal, the fingerprints get updated to trace the effect of the command.
At the end, the transaction throw away the local snapshot, but commit the fingerprints to the system.

The fingerprints include the \emph{first read preceding a write} and \emph{last write} for each key.
This is because a transaction is executed atomically, all the intermediate steps are not observable from the outside world.
The \emph{fingerprints} formally is a set of \emph{operations} \( \Ops \) which are either read \( (\etR, \addr, \val)\) from the \( \ke \) with the value \( \val \), or write \( (\etW, \addr, \val) \) to the key \( \ke \) with the value \( \val \) (\cref{def:ops}).
Note that In the \cref{def:ops}, the \( (.)\projection{(.)} \) denotes projection.
For a tuple, for example \( \op\projection{i} \), it gives the \emph{i-th} element of the tuple.
It is lifted to a set of tuples, for example \( \opset\projection{i}\), which gives a set of all the \emph{i-th} elements.
The well-formedness condition for fingerprints asserts it is a set of operations in which there are at most one read and one write for each key.
The composition, then, is defined as set disjointed union as long as the result is well-formed.
 

\begin{definition}[operation and fingerprints]
\label{def:ops}
A \emph{transaction operation} \( \op \in \Ops \) is a tuple of \emph{an operation tag} that is either read or write, an key and a value.
\[
\begin{rclarray}
\op \in \Ops & \defeq  & \powerset{\Set{\otR, \otW}} \times \Addr \times \Val
\end{rclarray}
\]
\emph{A well-formed fingerprint}, \( \opset \in \Opsets \), is a subset of \( \Ops \) in which any two elements contain either different tags or different key.
\[
    \begin{rclarray}
        \Opsets & \defeq & \Setcon{\opset}{%
            \opset \subseteq \Events \land \fora{\op, \op' \in \opset} 
            \op\projection{1} \neq  \op'\projection{1} \lor \op\projection{2} \neq  \op'\projection{2}  } \\
    \end{rclarray}
\]
The unit element is \( \unitE \defeq \emptyset\) and the composition of two fingerprints is the disjointed union when the two sets contain disjointed keyes,
\[ 
\begin{rclarray}
    \opset \composeO \opset' & \defeq & 
    \begin{cases}
        \opset \uplus \opset' & \text{if } \opset\projection{2} \cap \opset'\projection{2} = \emptyset \\
        \text{undefined} & \text{otherwise}
    \end{cases}
\end{rclarray}
\]
\end{definition}
\pg{ \(\opset \addO \opset'\)?. \sx{We can define this but not sure it is useful}}

\begin{lemma}
The well-formedness of fingerprints is closed under \( \addO \).
\end{lemma}

The operational semantics for transactions \(\trans\) (\cref{fig:transaction_semantics}) is defined with respect to a transactional state of the form \((\stk, \sn, \opset)\) comprising a stack, a snapshot and \emph{fingerprints}.
We first define a state transformers on pairs of stacks and snapshots for the primitive commands \(\trans_{p}\).
We also define its fingerprint by \( \funcn{fp} \) function, which denotes the contribution of the primitive command that might observed by the external environment, \ie transactions from other threads.
The \( \funcn{fp} \) extracts the read or write operation from loop-up and mutation respectively, otherwise \( \emptyop \).
We also define a binary operator \( \opset \addO \op \) that specifies the effects of adding a new operation \( \op \) to the fingerprints \( \opset \).
If the new operation is a read, for example \((\otR, \addr, \val)\) where \( \addr \) is the key and \( \val\) is the associated value, and there is no other operation related to the same key, this new read operation will be included in the result.
Meanwhile, if the new operation is a write, it will overwrite all preview write operations to the same key.
This ensures the fingerprints contains only the first read preceding a write, and only the last write for each key.
This choice is motivated by the fact that we only focus on atomically visible transactions: keys are read from a snapshot of the database, and new version are written only at the moment the transaction commits.
For technical reasons, if the right hand side is a special token \( \emptyop \) corresponding to a command does not result in an interaction with key-value store.
Therefore, the semantics for primitive command \(\rl{TPrimitive}\) updates the stack and heap by the transformers relation and updates the operation set by first extracting the operation and adding it via \( \addO \) operator.
The semantics for non-deterministic choices \(\rl{TChoice}\), sequential compositions \(\rl{TSeqSkip}\) and \(\rl{TSeq}\), and iteration \(\rl{TIter}\) have the expected behaviours.

\begin{figure}[!t]
\hrule\vspace{5pt}
\begin{flushleft}
The state transformers on pairs of stacks and snapshots for the primitive commands \(\trans_{p}\) (left), and the \( \funcn{op} \) for extracting the operation from the primitive commands (right):
\end{flushleft}
\[
\begin{array}{c @{\qquad} c}
\begin{rclarray}
(\stk, \h)  & \toLTS{\passign{\var}{\expr}}          & (\stk\rmto{\var}{\evalE{\expr}}, \h)                  \\
(\stk, \h)  & \toLTS{\pderef{\var}{\expr}}           & (\stk\rmto{\var}{\h(\evalE{\expr})}, \h)              \\
(\stk, \h)  & \toLTS{\pmutate{\expr_{1}}{\expr_{2}}} & (\stk, \h\rmto{\evalE{\expr_{1}}}{\evalE{\expr_{2}}}) \\
(\stk, \h)  & \toLTS{\passume{\expr}}                & (\stk, \h) \text{ where } \evalE{\expr} \neq 0           \\
%(\stk, \h) & \toLTS{\preturn{\expr}}                & (\stk\rmto{\ret}{\evalE{\expr}}, \h)                  \\
\end{rclarray}                                                                                               
&
\begin{rclarray}
\end{rclarray}
\begin{array}{@{} r c l @{\qquad} r  c l @{}}
\func{fp}{\stk, \h, \passign{\var}{\expr}}          & \defeq & \emptyop                                     \\
\func{fp}{\stk, \h, \pderef{\var}{\expr}}           & \defeq & (\etR, \evalE{\expr}, \h(\evalE{\expr}))     \\
\func{fp}{\stk, \h, \pmutate{\expr_{1}}{\expr_{2}}} & \defeq & (\etW, \evalE{\expr_{1}}, \evalE{\expr_{2}}) \\
\func{fp}{\stk, \h, \passume{\expr}}                & \defeq & \emptyop                                     \\
\func{fp}{\stk, \h, \preturn{\expr}}                & \defeq & \emptyop                                     \\
\end{array}
\end{array}
\]

\hrule\vspace{5pt}
\begin{flushleft}
The binary operator \( \opset \addO \op \) that specifies the effects of adding a new operation \( \op \) to the set \( \opset \):
\end{flushleft}
\[
\begin{array}{c @{\qquad} c}
\begin{rclarray}
    \opset \addO (\etR, \addr, \val) & \defeq & 
    \begin{cases}
        \opset \uplus \Set{(\etR, \addr, \val)} & (\stub, \addr, \stub) \notin \opset \\
        \opset &  \text{otherwise} \\
    \end{cases} \\
\end{rclarray}
&
\begin{rclarray}
    \opset \addO (\etW, \addr, \val) & \defeq & \left( \opset \setminus \Set{(\etW, \addr, \stub)} \right) \uplus \Set{(\etW, \addr, \val)} \\
    \opset \addO \emptyop & \defeq & \opset \\
\end{rclarray}
\end{array}
\]

\hrule\vspace{5pt}
\begin{flushleft}
Given the set of stacks \( \Stacks \) (\cref{def:stacks}), heaps \( \Heaps \) (\cref{def:heaps}) and transactions \( \Transactions \) (\cref{def:language}) and the arithmetic expression evaluation \( \evalE{\expr} \) (\cref{def:language}), the \emph{operational semantics of transactions}:
\end{flushleft}
\[
\begin{rclarray}
\toL & : & ((\Stacks \times \Heaps \times \Opsets) \times \Transactions) \times ((\Stacks \times \Heaps \times \Opsets) \times \Transactions)
\end{rclarray}
\]

\begin{mathpar}
    \inferrule[\rl{TPrimitive}]{%
        (\stk, \h) \toLTS{\transpri} (\stk', \h')
        \\ \op = \func{fp}{\stk, \h, \transpri}
    }{%
        (\stk, \h, \opset) , \transpri \ \toL \  (\stk', \h', \opset \addO \op) , \pskip \rangle
    }
    \and
    \inferrule[\rl{TChoice}]{
        i \in \Set{1,2}
    }{%
        (\stk, \h, \opset) , \trans_{1} \pchoice \trans_{2} \ \toL \  (\stk, \h, \opset) , \trans_{i}
    }
    \and
    \inferrule[\rl{TIter}]{ }{%
        (\stk, \h, \opset),  \trans\prepeat \ \toL \  (\stk, \h, \opset), \pskip \pchoice (\trans \pseq \trans\prepeat)
    } 
    \and
    \inferrule[\rl{TSeqSkip}]{ }{%
        (\stk, \h, \opset), \pskip \pseq \trans \ \toL \  (\stk, \h, \opset), \trans
    }
    \and
    \inferrule[\rl{TSeq}]{%
        (\stk, \h, \opset), \trans_{1} \ \toL \  (\stk', \h', \opset'), \trans_{1}'
    }{%
        (\stk, \h, \opset), \trans_{1} \pseq \trans_{2} \ \toL \  (\stk', \h', \opset'), \trans_{1}' \pseq \trans_{2}
    }
\end{mathpar}
\hrule
\caption{Operational semantics for transactions}
\label{fig:transaction_semantics}
\end{figure}

