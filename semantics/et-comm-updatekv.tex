For technical reasons, it will be convenient to adopt a reduction strategy for inferring kv-stores induced by an 
execution test: such an execution strategy require that clients only commit transactions with non-empty fingerprints, 
and a client updates its view only immediately before committing a transaction. 
The next proposition states that all kv-stores induced by an execution test $\ET$ can be 
obtained via a sequence of reductions that adhere to the reduction strategy outlined above. 
\begin{definition}
Let $\ET$ be an execution test. The $\ET$-trace
\[
\conf_0 \xrightarrowtriangle{\alpha_0}_{\ET} \conf_1 \xrightarrowtriangle{\alpha_1}_{\ET} \cdots \xrightarrowtriangle{\alpha_{2n}}_{\ET} \conf_{2n + 1}
\]
is in \emph{normal form} if \textbf{(i)} $\conf_0$ is initial, and 
\textbf{(ii)} $\forall i=0,\cdots, n$ there exists a client $\cl_i$ and set of operations $\opset_{i}$ such that 
$\alpha_{2 \cdot i} = (\cl_{i}, \varepsilon)$, and $\alpha_{2 \cdot i + 1}$ is defined and equal to $(\cl_{i}, \opset_{i})$ where \( \f_i \neq \emptyset \).
\end{definition}

\begin{proposition}
\label{prop:et.normalform}
Let $\ET$ be an execution test, and suppose that $\hh \in \CMs(\ET)$. Then there exists a $\ET$-trace  
\[
(\hh_0, \viewFun_0) \xrightarrowtriangle{\stub}_{\ET} \cdots \xrightarrowtriangle{\stub}_{\ET} (\hh_n, \viewFun_{n})
\]
that is in normal form, and such that $\hh_{n} = \hh$.
\end{proposition}
\begin{proof}
    See \cref{sec:normal-form-exist}.
\end{proof}


The \cref{prop:updatekv.comm} captures that
if two different clients $\cl_1$ and $\cl_2$ commit transactions 
whose fingerprints $\opset_1$ and $\opset_2$ do not contain a write 
to the same key, then the order in which the updates are executed is 
not relevant. 
\begin{proposition}
\label{prop:updatekv.comm}
\label{prop:swap-update}
Let $\hh \in \HisHeaps$, $\vi_1, \vi_2 \in \Views(\hh)$ and let $\cl_1, \cl_2 \in \Clients$ 
be such that $\cl_1 \neq \cl_2$. 
Let also $\opset_1, \opset_2 \in \powerset{\Ops}$ be such that 
whenever $(\otW, \ke, \_) \in \opset_1$ for some key $\ke$, then 
$(\otW, \ke, \val) \notin \opset_2$ for all $\val \in \Val$. Then 
\[
\begin{array}{l}
\{ \updateKV(\hh_1, \vi_2, \cl_2, \opset_2) \mid \hh_1 \in \updateKV(\hh, \vi_1, \cl_1, \opset_1)\} = \\
\{ \updateKV(\hh_2, \vi_1, \cl_1, \opset_1) \mid \hh_2 \in \updateKV(\hh, \vi_2, \cl_2, \opset_2)\}\\
\end{array}
\]
\end{proposition}
\begin{proof}
    See \cref{sec:comm-updatekv}.
\end{proof}

A desirable property that one would request from execution 
test is compositionality: the consistency model induced by 
a composite execution test can be recovered from the consistency 
models generated by each execution test: that is, 
\[ 
\forall \ET_1, \ET_2. \CMs(\ET_1 \cap \ET_2) = \CMs(\ET_1) \cap \CMs(\ET_2).
\]
Unfortunately, this property is not satisfied by execution tests in their 
most general setting, as the following example shows: 
\begin{example}
\label{ex:noncompositional.et}
Define the following terms: 
\[
\begin{array}{lcl}
\hh_0 &=& [\ke_1 \mapsto (\val_0, \txid_0, \emptyset) , \ke_2 \mapsto (\val_0, \txid_0, \emptyset)]\\
\hh_1 &=& \big[\ke_1 \mapsto \big( (\val_0, \txid_0, \emptyset) \lcat (\val_2, \txid_{\cl_1}^{1}, \emptyset)\big) , \ke_2 \mapsto (\val_0, \txid_0, \emptyset) \big]\\
\hh_2 &=& \big[\ke_1, \mapsto (\val_0, \txid_0, \emptyset), \ke_2 \mapsto \big( (\val_0, \txid_0, \emptyset) \lcat (\val_2, \txid_{\cl_2}^{1}, \emptyset) \big) \big]\\
\hh_3 &=& \big[\ke_1 \mapsto \big( (\val_0, \txid_0, \emptyset) \lcat (\val_2, \txid_{\cl_1}^{1}, \emptyset)\big), 
                         \ke_2 \mapsto \big( (\val_0, \txid_0, \emptyset) \lcat (\val_2, \txid_{\cl_2}^{1}, \emptyset) \big) \big]\\
&&\\
\vi_0 &=& [\ke_1 \mapsto \{0\}, \ke_2 \mapsto \{0\}]\\
\viewFun_0 &=& [\cl_1 \mapsto \vi_0, \cl_2 \mapsto \vi_0]\\
&&\\
\ET_1 &\vdash& (\hh_0, \vi_0) \triangleright \{(\otW, \ke_1, \val_1)\} : \vi_0\\
\ET_1 &\vdash& (\hh_1, \vi_0) \triangleright \{(\otW, \ke_2, \val_2)\} : \vi_0\\
&&\\
\ET_2 &\vdash& (\hh_0, \vi_0) \triangleright \{(\otW, \ke_2, \val_2)\} : \vi_0\\
\ET_2 &\vdash& (\hh_2, \vi_0) \triangleright \{(\otW, \ke_1, \val_1)\} : \vi_0.
\end{array}
\]
There are no further constraints on $\ET_1, \ET_2$.
For $\ET_1$ and $\ET_2$, we have that 
\[
\begin{array}{l}
(\hh_0, \viewFun_0) \xrightarrowtriangle{(\cl_1, \{(\otW, \ke_1, \val_1)\})}_{\ET_1} 
(\hh_1, \viewFun_0) \xrightarrowtriangle{(\cl_2, \{(\otW, \ke_2, \val_2)\})}_{\ET_1} (\hh_3, \viewFun_0), \\
(\hh_0, \viewFun_0) \xrightarrowtriangle{(\cl_2, \{(\otW, \ke_2, \val_2)\})}_{\ET_2} 
(\hh_2, \viewFun_0) \xrightarrowtriangle{(\cl_1, \{(\otW, \ke_1, \val_1)\})}_{\ET_2} (\hh_3, \viewFun_0).\\
\end{array}
\] 
Therefore, we have that $\hh_3 \in \CMs(\ET_1) \cap \CMs(\ET_2)$. On the other hand, it is immediate 
to observe that $\ET_1 \cap \ET_2 = \emptyset$, and therefore $\hh_3 \notin \CMs(\ET_1 \cap \ET_2)$.
\end{example}
The reason why compositionality fails, for the execution tests of \cref{ex:noncompositional.et}, 
is that both the execution tests $\ET_1, \ET_2$ require that the fingerprints 
$\{(\otW, \ke_1, \_)\}, \{(\otW, \ke_2, \_)\}$ commit in different order: in $\ET_1$, the write to $\ke_1$ must commit 
before the write to $\ke_2$, and vice versa for $\ET_2$. On the other hand, 
because the two fingerprints above do not write to the same key, 
the order in which they are committed should not be relevant: by changing the order 
in which different clients commit such fingerprints to a kv-store, the result stays the same. 
\begin{definition}
Two triples $(\cl_1, \opset_1)$ and $(\cl_2, \opset_2)$ are 
conflicting if either $\cl_1 = \cl_2$, or there exists a key $\ke$ such that 
$(\otW, \ke, \_) \in \opset_1, (\otW, \ke, \_) \in \opset_2$. 

An execution test is $\ET$ is \emph{commutative} if, whenever $(\cl_1, \vi_1, \opset_1)$, 
$(\cl_2, \vi_2, \opset_2)$ are non-conflicting, and $\vi_1, \vi_2 \in \Views(\hh_0)$,  
then for any $\hh_0, \hh', \viewFun, \viewFun'$ we have that 
\[
\begin{array}{lr}
(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_1, \opset_1)}
\_ \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} (\hh', \viewFun') &\implies \\
(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} 
\_ \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} (\hh', \viewFun')
\end{array}
\]
\end{definition}
\ac{Note that the views are not part of actions anymore. Furthermore, the definition 
of $\ET$-reduction has been changed, so that no view shifts can be made prior to 
committing a transaction, in the reductions above.}

Requiring execution tests to be commutative is a necessary step for ensuring 
that the specification of consistency models are compositional. However, it 
is not sufficient. The next example shows how compositionality fails 
for commutative execution tests. 

\begin{example}
\label{ex:noblindwrites}
For any $n \in \Nat$, let $[n] = \{0,\cdots, n\}$.
Consider the execution tests $\ET_1, \ET_2$ defined below: 
\[
\begin{array}{lcl}
\ET_1 \vdash (\hh, \vi) \triangleright \opset : \vi' &\iff& 
\forall \ke.\;(\otW, \ke, \_) \in \opset \implies \vi(\ke) = \vi'(\ke) = [0]\\
\ET_2 \vdash (\hh, \vi) \triangleright \opset : \vi'(\ke) &\iff& 
\forall \ke. \;(\otW, \ke, \_ ) \in \opset \implies \vi(\ke) = [ \lvert \hh(\ke) \rvert - 1] \wedge \vi'(\ke) = [\lvert \hh(\ke) \rvert ] \\
\end{array}
\]
It is immediate to observe that both $\ET_1$ and $\ET_2$ are commutative. However, 
consider the kv-store $\hh_2 = [\ke \mapsto (\val_0, \txid_0, \emptyset) \lcat (\val_1, \txid_{\cl}^1, \emptyset) \lcat (\val_2, \txid_{\cl}^2, \emptyset)]$. 
We have that $\hh \in \CMs(\ET_1)$ and $\hh \in \CMs(\ET_2)$.
Let in fact $\hh_1 = [\ke \mapsto (\val_0, \txid_0, \emptyset) \lcat (\val_1, \txid_{\cl}^1, \emptyset)]$, $\vi_{i} = [\ke \mapsto [i] ]$.
\ac{Seriously, square brackets are being used everywhere (though all of this is standard notation. Maybe $\langle n \rangle$ for $\{0,\cdots, n\}$ is 
a better notation?
\sx{  \( \ke \mapsto \langle n \rangle \) is cool. }
}
We have the following sequences of reductions: 
\[
\begin{array}{l}
(\hh_0, \vi_0) \xrightarrowtriangle{(\cl, \{(\otW, \ke, \val_1)\})}_{\ET_1} 
(\hh_1, \vi_0) \xrightarrowtriangle{(\cl,\{(\otW, \ke, \val_2)\})}_{\ET_1} (\hh_2, \vi_0)\\
(\hh_0, \vi_0) \xrightarrow{(\cl, \{(\otW, \ke, \val_1)\})}_{\ET_2} (\hh_1, \vi_1) \xrightarrow{(\cl, \{(\otW, \ke, \val_2)\})}_{\ET_2} 
(\hh_2, \vi_2)
\end{array}
\]
On the other hand, we can observe that $\hh_2 \notin \CMs(\ET_1 \cap \ET_2)$. $\ET_1$ allows a client to 
commit a transaction if its view only includes the initial version of each key it writes. $\ET_2$ allows a client 
to commit a transaction when its view include all the versions for each key it writes. In $\ET_1 \cap \ET_2$ 
a client can commit a transaction only if the initial version of each key it writes is also the only version in the kv-store: 
as a result, $\CMs(\ET_1 \cap \ET_2)$ never contains a  kv-stores $\hh$ such that $\hh(\ke) > 1$ for some key $\ke$; 
in particular, $\hh_2 \notin \CMs(\ET_1 \cap \ET_2)$.
\end{example}
\ac{Two possible reasons why compositionality fails: because of blind writes, or because the test $\ET_1$ hinders progress, 
i.e. it is not possible to replace a view with a more up-to-date one to enable progress. We must choose which assumption 
we make on the consistency model.}

One reason why compositionality fails in \cref{ex:noblindwrites} is that the execution tests $\ET_1$ and $\ET_2$ do not contain 
any information about the the views that client $\cl$ used to commit the transactions $\txid_{\cl}^1, \txid_{\cl}^2$. 
To solve this problem we adopt the \emph{no blind writes} assumption, that requires that a client never commits 
a transaction that writes a key, without reading such a key beforehand. Many implementations of consistency models 
in distributed key-value stores respect the no blind writes assumption. 

\begin{definition}
\label{def:noblidwrites}
An execution test $\ET$ has \emph{no blind writes} if, whenever $\ET \vdash (\hh, \vi) \triangleright \opset \cup \{(\otW, \ke, \_)\} : \vi'$, 
then $(\otR, \ke, \_) \in \opset$.
\end{definition}

\begin{definition}
\label{def:et-minimum-footprint}
An execution test $\ET$ has \emph{minimum footprints} if for any \( \hh, \vi, \vi',\vi'', \f \),
\[
\begin{array}{@{}l@{}}
    ( \fora{ \ke} (\stub, \ke, \stub) \in \f \implies \vi(\ke) = \vi'(\ke) ) \land {} \\
    \quad \ET \vdash (\hh, \vi) \triangleright \opset : \vi'' \implies \ET \vdash (\hh, \vi') \triangleright \opset : \vi''
\end{array}
\]
\end{definition}

\begin{definition}
\label{def:et-continuous-postview}
An execution test $\ET$ has \emph{continuous post-views} if for any \( \hh, \vi, \vi',\vi'', \f \),
\[
\begin{array}{@{}l@{}}
    \quad \ET \vdash (\hh, \vi) \triangleright \opset : \vi' \land \vi' \sqsubseteq \vi'' \implies \ET \vdash (\hh, \vi) \triangleright \opset : \vi''
\end{array}
\]
\end{definition}

\begin{theorem}                                                                            
\label{thm:et-comm}                          
Let $\ET_1, \ET_2$ be two execution tests has no blind writes, minimum footprints and continuous post-views.
If $\ET_1$ is commutative, 
then $\CMs(\ET_1 \cap \ET_2) = \CMs(\ET_1) \cap \CMs(\ET_2)$. 
Furthermore, if $\ET_1, \ET_2$ are commutative, then $\ET_1 \cap \ET_2$ 
is commutative.
\end{theorem}
\begin{proof}
    See \cref{sec:et-comm}.
\end{proof}


\subsection{Proof of \cref{prop:updatekv.comm}}
\label{sec:comm-updatekv}

\begin{lemma}
\label{lem:updatekv.explicit}
Let $\hh$ be a kv-store, $\vi \in \Views(\hh)$, $\txid \in \TxID$ and $\opset \in \powerset{\Ops}$. 
Let also $\ke \in \Keys$. Then
\begin{enumerate}
\item\label{item:updatekv.explicit.none} $(\forall \val.\;(\otR, \ke, \val) \notin \opset \wedge (\otW, \ke, \val)) \notin \opset \implies \updateKV(\hh, \vi, \txid, \opset)(\ke) = \hh(\ke)$, 
\item\label{item:updatekv.explicit.rd} $(\otR, \ke, \_) \in \opset \wedge \forall \val.\;( (\otW, \ke, \val) \notin \opset) \implies \updateKV(\hh, \vi, \txid, \opset)(\ke) = 
\text{ let } (\val', \txid', \T') = \hh(\ke, \max(\vi(\ke))) \text{ in } \hh(\ke)\rmto{\max(\vi(\ke))}{(\val', \txid', \T' \cup \{\txid\})}$, 
\item\label{item:updatekv.explicit.wr} $\forall \val.\; (\forall \val'.\;(\otR, \ke, \val) \notin \opset) \wedge (\otW, \ke, \val) \in \opset \implies \updateKV(\hh, \vi, \txid, \opset)(\ke) = 
\hh(\ke) \lcat \List{(\val, \txid, \emptyset)}$, 
\item\label{item:updatekv.explicit.rdwr} $\forall \val.\;(\otR, \ke, \_) \in \opset \wedge (\otW, \ke, \val) \in \opset \implies \updateKV(\hh,\vi,\txid,\opset)(\ke) = 
\mathtt{ let } (\val', \txid', \T') = \hh(\ke, \max(\vi(\ke))) \in \hh(\ke)\rmto{\max(\vi(\ke))}{(\val', \txid', \T' \cup \{\txid\})} \lcat \List{(\val, \txid, \emptyset)}.$
\end{enumerate}
\end{lemma}

\begin{proof}
All the four statements are proved by induction on $\opset$, by keeping the variable $\hh$ universally quantified in the inductive hypothesis. 
Statement \eqref{item:updatekv.explicit.rd} and \eqref{item:updatekv.explicit.wr} requires 
proving \eqref{item:updatekv.explicit.none} first, while Statement \eqref{item:updatekv.explicit.rdwr} requires proving all the other statements. 
Fix then an arbitrary $\ke \in \Keys$.
\begin{enumerate}
	\item 
	Suppose that for any $\val$, $(\otR, \ke, \val) \notin \opset$ and $(\otW, \ke, \val)) \notin \opset$. We prove that $\updateKV(\hh, \vi, \txid, \opset)(\ke) = 
	\hh(\ke)$.
	\begin{itemize}
		\item Base case: $\opset = \emptyset$; in this case we have that 
		\[
		\updateKV(\hh, \vi, \txid, \emptyset)(\ke) \stackrel{\eqref{eq:updatekv}}{=} \hh(\ke).
		\]
		
		\item Suppose that $\opset = \opset' \uplus \{(\otR, \ke', \val')\}$ for some $\ke', \val'$. Because we are assuming that 
		$(\otR, \ke, \val) \notin \opset$ for any $\val \in \Val$, then it must be the case that 
		\begin{equation}
		\label{eq:updatekv.explicit.none.keneqkepRD}
		\ke \neq \ke'.
		\end{equation}
		Also, we have that $(\otR,\ke, \val) \notin \opset'$ and $(\otW, \ke, \val) \notin \opset$ for any $\val \in \Val$. 
		By inductive hypothesis we can assume 
		\begin{equation}
		\forall \hh'.\;\updateKV(\hh', \vi, \txid, \opset')(\ke) = \hh'(\ke).
		\label{eq:updatekv.explicit.none.IHrd}
		\end{equation} 
		Therefore we have 
		\[
		\begin{array}{lr}
		\updateKV(\hh, \vi, \txid, \opset)(\ke) = \updateKV(\hh, \vi, \txid, \opset' \uplus \{(\otR, \ke', \val')\})(\ke) &\stackrel{\eqref{eq:updatekv}}{=}\\ &\\
		\text{let } (\val', \txid', \T') = \hh(\ke', \max(\vi(\ke))) \text{ in } & \\ 
		\;\;\;\;\updateKV(\hh\rmto{\ke'}{\hh(\ke')\rmto{\max(\vi(\ke'))}{(\val', \txid', \T' \cup \{\txid\})}}, \vi, \txid, \opset')(\ke) &			\stackrel{\eqref{eq:updatekv.explicit.none.IHrd}}{=}\\ &\\
		\text{let } (\val', \txid', \T') = \hh(\ke', \max(\vi(\ke'))) \text{ in } \hh\rmto{\ke'}{\hh(\ke')\rmto{\max(\vi(\ke'))}{(\val', \txid', \T' \{\txid\}}}(\ke) &\stackrel{\eqref{eq:updatekv.explicit.none.keneqkepRD}}{=}\\
		\big( \text{let } (\val', \txid', \T') = \hh(\ke', \max(\vi(\ke'))) \text{ in } \hh(\ke) \big) = \hh(\ke)
		\end{array}
		\]
		
		\item Suppose that $\opset = \opset' \uplus \{(\otW, \ke', \val')\}$ for some $\val' \in \Val$. Then it must be the 
		case that 
		\begin{equation}
		\label{eq:updatekv.explicit.none.keneqkepWR}
		\ke \neq \ke'.
		\end{equation}
		Also, we have that $(\otR,\ke, \val) \notin \opset'$ and $(\otW, \ke, \val) \notin \opset$ for any $\val \in \Val$. 
		By inductive hypothesis we can assume 
		\begin{equation}
		\forall \hh'.\;\updateKV(\hh', \vi, \txid, \opset')(\ke) = \hh'(\ke).
		\label{eq:updatekv.explicit.none.IHwr}
		\end{equation}
		Therefore we have 
		\[
		\begin{array}{lr}
		\updateKV(\hh, \ke, \txid, \opset)(\ke) = \updateKV(\hh, \ke, \txid, \opset \uplus \{(\otW, \ke', \val')\})(\ke) &\stackrel{\eqref{eq:updatekv}}{=}\\
		\updateKV(\hh\rmto{\ke'}{\hh(\ke')\lcat \List{(\val', \txid, \emptyset)}}, vi, \txid,\opset)(\ke) &\stackrel{\eqref{eq:updatekv.explicit.none.IHwr}}{=}\\
		\hh\rmto{\ke'}{\hh(\ke') \lcat \List{(\val', \txid, \emptyset)}}, \vi, \txid, \opset)(\ke) & \stackrel{\eqref{eq:updatekv.explicit.none.keneqkepWR}}{=}\\
		\hh(\ke)
		\end{array}
		\]
	\end{itemize}

	\item Suppose now that, $(\otR, \ke, \_) \in \opset$, and $(\otW, \ke, \val) \notin \opset$ for all $\val \in \Val$. 
	Let $(\val, \txid', \T) = \hh(\ke, \max(\vi(\ke)))$. We prove that $\updateKV(\hh, \vi, \txid, \opset)(\ke) = 
	\hh(\ke)\rmto{\vi(\ke)}{(\val, \txid', \T \cup \{\txid\})}$.
		\begin{itemize}
		\item Base case: $\opset = \emptyset$; this case is vacuous, as $(\otR, \ke, \val) \notin \opset$ for all $\val \in \Val$, 
		against the assumption that $(\otR, \ke, \_) \in \opset$. 

		\item Suppose that $\opset = \opset' \cup \{(\otR, \ke', \_)\}$ for some $\ke'$. We have two possible cases: 
			\begin{enumerate}
			\item $\ke = \ke'$, in which case we know that $(\otR, \ke, \val') \notin \opset'$ for all $\val' \in \Val$ because of 
			the assumptions that we make on the structure of $\opset$. By \cref{lem:updatekv.explicit}\eqref{item:updatekv.explicit.none} we have that
			\begin{equation}
			\forall \hh'.\; \updateKV(\hh', \vi, \txid, \opset')(\ke) = \hh'(\ke).
			\label{eq:updatekv.explicit.rd.applynone}
			\end{equation}
			In this case we have that 
			\[
			\begin{array}{lr}
			\updateKV(\hh, \vi, \txid, \opset)(\ke) = \updateKV(\hh,\vi, \txid, \opset' \uplus \{(\otR, \ke, \val')\})(\ke) &\stackrel{\eqref{eq:updatekv}}{=}\\
			\updateKV(\hh\rmto{\ke}{\hh(\ke)\rmto{\max(\vi(\ke))}{(\val, \txid', \T \cup \{\txid\})}}, \vi, \txid, \opset')(\ke) &\stackrel{\eqref{eq:updatekv.explicit.rd.applynone}}{=} \\
			\hh\rmto{\ke}{\hh(\ke)\rmto{\max(\vi(\ke))}{(\val, \txid', \T \cup \{\txid\})}}(\ke) &=\\ 
			\hh(\ke)\rmto{\max(\vi(\ke))}{(\val, \txid', \T \cup \{\txid\})}.
			\end{array}
			\]

			\item \begin{equation}
			\ke \neq \ke'.
			\label{eq:updatekv.explicit.rd.keneqkepRD}
			\end{equation} 
			In this case we know that because $(\otR, \ke, \_) \in \opset$, then 
			it must be $(\otR, \ke, \_) \in \opset'$. We also know that $\forall \val.(\otW, \ke, \val) \notin \opset$. 
			By the inductive hypothesis, we have that 
			\begin{equation}
			\label{eq:updatekv.explicit.rd.IHrd}
			\forall \hh'.\; \updateKV(\hh', \vi, \txid, \opset')(\ke) = \hh'(\ke)\rmto{\max(\vi(\ke))}{(\val, \txid', \T \cup \{(\txid)\})}.
			\end{equation}
			In this case we have 
%			\[
%			\begin{array}{lr}
%			\updateKV(\hh, \vi, \txid, \opset)(\ke) = \updateKV(\hh, \vi, \txid, \opset' \uplus \{(\otR, \ke', \_)\})(\ke) &\stackrel{\eqref{eq:updatekv}}{=}\\
%			\text{let } (\val'', \txid'', \T'') = \hh(\ke', \max(\vi(\ke'))) \text{ in } \updateKV(\hh\rmto{\ke'}{\hh(\ke')\rmto{\max(\vi(\ke'))}{(\val'', \txid'', \T'' \cup \{\txid\})}}, \vi, \txid, \opset)(\ke) 			&
%			\stackrel{\eqref{eq:updatekv.explicit.rd.IHrd}}{=} \\
%			\text{let } (\val'', \txid'', \T'') = \hh(\ke', \max(\vi(\ke'))) \text{ in } &\\
%			\big(\hh\rmto{\ke'}{(\hh(\ke')\rmto{\max(\vi(\ke'))}{(\val'', \txid'', \T'' \cup \{\txid\})}}(\ke)\big) 
%			\rmto{\max(\vi(\ke))}{(\val, \txid', \T' \cup \{(\txid)\})} &\stackrel{\eqref{eq:updatekv.explicit.rd.keneqkepRD}}{=}\\
%			\hh(\ke)\rmto{\max(\vi(\ke))}{(\val, \txid', \T' \cup \{(\txid)\}}
%			\end{array}
%			\]
			\[
			\begin{array}{lr}
			\updateKV(\hh, \vi, \txid, \opset)(\ke) = \updateKV(\hh, \vi, \txid, \opset' \uplus \{(\otR, \ke', \_)\})(\ke) &\stackrel{\eqref{eq:updatekv}}{=}\\
			\updateKV(\hh\rmto{\ke'}{\_}, \vi, \txid, \opset)(\ke) 			&
			\stackrel{\eqref{eq:updatekv.explicit.rd.IHrd}}{=} \\
			\big(\hh\rmto{\ke'}{\_}(\ke)\big) 
			\rmto{\max(\vi(\ke))}{(\val, \txid', \T' \cup \{(\txid)\})} &\stackrel{\eqref{eq:updatekv.explicit.rd.keneqkepRD}}{=}\\
			\hh(\ke)\rmto{\max(\vi(\ke))}{(\val, \txid', \T' \cup \{(\txid)\}}
			\end{array}
			\]
		\end{enumerate}

		\item $\opset = \opset' \uplus \{(\otW, \ke', \val')\}$ for some $\val' \in \Val$. Because $(\otW, \ke, \val) \notin \opset$ 
		for any $\val \in \Val$, it must be the case that 
		\begin{equation}
		\ke \neq \ke'
		\label{eq:updatekv.explicit.rd.keneqkepWR}
		\end{equation}
		Because $(\otR, \ke, \_) \in \opset$, it must also be the case that $(\otR, \ke, \_) \in \opset'$. By the inductive hypothesis, 
		we have that 
		\begin{equation}
		\forall \hh'.\;\updateKV(\hh', \vi,\txid, \opset')(\ke) = \hh(\ke)\rmto{\max(\vi(\ke))}{(\val, \txid', \T \cup \{(\txid)\})}
		\label{eq:updatekv.explicit.rd.IHwr}
		\end{equation}
		It follows that 
%		\[
%		\begin{array}{lr}
%		\updateKV(\hh, \vi, \txid, \opset)(\ke) = \updateKV(\hh, \vi, \txid, \opset' \uplus \{(\otW, \ke', \val')\})(\ke) &\stackrel{\eqref{eq:updatekv}}{=}\\
%		\updateKV(\hh\rmto{\ke'}{\hh(\ke') \lcat \List{(\val', \txid, \emptyset)}}, \vi, \txid, \opset')(\ke) &\stackrel{\eqref{eq:updatekv.explicit.rd.IHwr}}{=}\\
%		\hh(\rmto{\ke'}{\hh(\ke') \lcat \List{(\val', \txid, \emptyset)}}(\ke)\rmto{\vi(\ke)}{(\val, \txid', \T \cup \{\txid\})} &
%		\stackrel{\eqref{eq:updatekv.explicit.rd.keneqkepWR}}{=}\\
%		\hh(\ke)\rmto{\vi(\ke)}{(\val, \txid', \T \cup \{\txid\})}
%		\end{array}
%		\]
		\[
		\begin{array}{lr}
		\updateKV(\hh, \vi, \txid, \opset)(\ke) = \updateKV(\hh, \vi, \txid, \opset' \uplus \{(\otW, \ke', \val')\})(\ke) &\stackrel{\eqref{eq:updatekv}}{=}\\
		\updateKV(\hh\rmto{\ke'}{\_}, \vi, \txid, \opset')(\ke) &\stackrel{\eqref{eq:updatekv.explicit.rd.IHwr}}{=}\\
		\hh(\rmto{\ke'}{\_}(\ke)\rmto{\max(\vi(\ke))}{(\val, \txid', \T \cup \{\txid\})} &
		\stackrel{\eqref{eq:updatekv.explicit.rd.keneqkepWR}}{=}\\
		\hh(\ke)\rmto{\max(\vi(\ke))}{(\val, \txid', \T \cup \{\txid\})}
		\end{array}
		\]
	\end{itemize}
	
	\item Suppose that $(\otW, \ke, \val) \in \opset$ for some $\val \in \Val$, and 
	$(\otR, \ke, \val') \notin \opset$ for any $\val' \in \Val$. We prove that 
	$\updateKV(\hh, \vi, \txid, \opset)(\ke) = \hh(\ke) \lcat \List{(\val, \txid, \emptyset)}$. 
		\begin{itemize}
		\item Base case: $\opset = \emptyset$. This case is vacuous, as we are assuming 
		that $(\otW, \ke, \val) \in \opset$.
		\item Suppose that $\opset = \opset' \uplus \{(\otR, \ke', \_)\}$ for some 
		$\ke'$. Note that, because we are assuming that $\{(\otR, \ke, \val')\} \notin \opset$ 
		for all $\val' \in \Val$, then it must be the case that 
		\begin{equation}
		\ke \neq \ke'.
		\label{eq:updatekv.explicit.wr.kenqkepRD}
		\end{equation}	
		We also have that $\{(\otR, \ke, \val')\} \notin \opset'$ for all $\val' \in \Val$, and 
		$(\otW, \ke, \val) \in \opset'$. By the inductive hypothesis we have that 
		\begin{equation}
		\forall \hh'.\; \updateKV(\hh', \vi, \txid, \opset')(\ke) = \hh'(\ke) \lcat \List{(\val, \txid, \emptyset)}.
		\label{eq:updatekv.explicit.wr.IHrd}
		\end{equation}
		Therefore, we have that 
		\[
		\begin{array}{lr}
		\updateKV(\hh, \vi, \txid, \opset)(\ke) = \updateKV(\hh, \vi, \txid, \opset' \uplus \{(\otR, \ke', \_)\})(\ke) &\stackrel{\eqref{eq:updatekv}}{=}\\
		\updateKV(\hh\rmto{\ke'}{\_}, \vi ,\txid, \opset')(\ke) \stackrel{\eqref{eq:updatekv.explicit.wr.IHrd}}{=} \hh\rmto{\ke'}{\_}(\ke) \lcat \List{(\val, \txid, \emptyset)} 
		& \stackrel{\eqref{eq:updatekv.explicit.wr.kenqkepRD}}{=} \\
		\hh(\ke) \lcat \List{(\val, \txid, \emptyset)}
		\end{array}
		\]
		
		\item Suppose that $\opset = \opset' \uplus \{(\otW, \ke', \val')\}$ 
		for some $\ke'$. We distinguish two possible cases:
			\begin{enumerate}
			\item $\ke = \ke'$. In this case the structure of $\opset$ also imposes that $\val = \val'$, 
			and $(\otW, \ke, \val'') \notin \opset'$ for any $\val'' \in \Val$. Furthermore, we have 
			that $(\otR, \ke, \val'') \notin \opset'$ for any $\val'' \in \Val$. 
			By \cref{lem:updatekv.explicit}\eqref{item:updatekv.explicit.none}, we have that 
			\begin{equation}
			\forall \hh'.\updateKV(\hh', \vi, \txid, \opset')(\ke) = \hh(\ke)
			\label{eq:updatekv.explicit.wr.applynone}
			\end{equation}
			from which it follows 
			\[
			\begin{array}{lr}
			\updateKV(\hh, \vi, \txid, \opset)(\ke) = 
			\updateKV(\hh, \vi, \txid, \opset' \uplus \{(\otW, \ke', \val')\})(\ke) &=\\ 
			\updateKV(\hh, \vi, \txid, \opset' \uplus \{(\otW, \ke, \val)\})(\ke) &\stackrel{\eqref{eq:updatekv}}{=}\\
			\updateKV(\hh\rmto{\ke}{\hh(\ke) \lcat \List{(\val, \txid, \emptyset)}}, \vi, \txid, \opset')(\ke) &\stackrel{\eqref{eq:updatekv.explicit.wr.applynone}}{=}\\
			\hh\rmto{\ke}{\hh(\ke) \lcat \List{(\val, \txid, \emptyset)}}(\ke) = \hh(\ke) \lcat \List{(\val, \txid, \emptyset)}
			\end{array}
			\]
			
			\item 
			\begin{equation}
			\ke \neq \ke'
			\label{eq:updatekv.explicit.wr.keneqkepWR}
			\end{equation}
			In this case we have that, because $(\otW, \ke, \val) \in \opset$, then it must 
			be $(\otW, \ke, \val) \in \opset'$. Furthermore, we also have that $(\otR, \ke, \val'') \notin \opset'$ 
			for any $\val'' \in \Val$. By the inductive hypothesis, we have that 
			\begin{equation}
			\forall \hh'.\; \updateKV(\hh', \vi, \txid, \opset')(\ke) = \hh(\ke) \lcat \List{(\val, \txid, \emptyset)}
			\label{eq:updatekv.explicit.wr.IHwr}
			\end{equation}
			from which it follows 
%			\[
%			\begin{array}{lr}
%			\updateKV(\hh, \vi, \txid, \opset)(\ke) = \updateKV(\hh, \vi, \txid, \opset' \uplus \{(\otW,\ke', \val')\}) &\stackrel{\eqref{eq:updatekv}}{=}\\
%			\updateKV(\hh\rmto{\ke'}{\hh(\ke') \lcat \List{(\val', \txid, \emptyset)}}, \vi, \txid, \opset)(\ke) &\stackrel{\eqref{eq:updatekv.explicit.wr.IHwr}}{=}\\
%			\hh\rmto{\ke'}{\_}(\ke) \lcat \List{(\val, \txid, \emptyset)} \stackrel{\eqref{eq:updatekv.explicit.wr.keneqkepWR}}{=} \hh(\ke) \lcat \List{(\val, \txid, \emptyset)}
%			\end{array}
%			\]
			\[
			\begin{array}{lr}
			\updateKV(\hh, \vi, \txid, \opset)(\ke) = \updateKV(\hh, \vi, \txid, \opset' \uplus \{(\otW,\ke', \val')\}) &\stackrel{\eqref{eq:updatekv}}{=}\\
			\updateKV(\hh\rmto{\ke'}{\_}, \vi, \txid, \opset)(\ke) &\stackrel{\eqref{eq:updatekv.explicit.wr.IHwr}}{=}\\
			\hh\rmto{\ke'}{\_}(\ke) \lcat \List{(\val, \txid, \emptyset)} \stackrel{\eqref{eq:updatekv.explicit.wr.keneqkepWR}}{=} \hh(\ke) \lcat \List{(\val, \txid, \emptyset)}
			\end{array}
			\]
			\end{enumerate}
		\end{itemize}
		
		\item Suppose that $(\otW, \ke, \val) \in \opset$ for some $\val \in \Val$, and $(\otR, \ke, \_) \in \opset$. 
		Let $\hh(\ke, \vi) = (\val', \txid', \T')$. We prove that $\updateKV(\hh, \vi, \txid, \opset)(\ke) = 
		\hh(\ke)\rmto{\vi(\ke)}{(\val', \txid', \T' \cup \{\txid\}} \lcat \List{(\val, \txid, \emptyset)}$ 
		by induction on $\opset$:
			\begin{itemize}
			\item $\opset = \emptyset$; this case is vacuous.
			\item $\opset = \opset' \uplus \{(\otR, \ke', \_)\}$. We distinguish two cases, according to 
			whether $\ke = \ke'$ or $\ke \neq \ke'$. If $\ke = \ke'$, then we know that 
			$(\otW, \ke, \val) \in \opset'$ and $(\otR, \ke, \val'') \notin \opset$ for any $\val'' \in \Val$. 
			By Lemma \cref{lem:updatekv.explicit}\eqref{item:updatekv.explicit.wr} we have that 
			\begin{equation}
			\forall \hh'.\;\updateKV(\hh,\vi,\txid,\opset')(\ke) = \hh(\ke) \lcat \List{(\val, \txid, \emptyset)}
			\label{eq:updateKV.explicit.rdwr.applyWR}
			\end{equation}
			from which it follows that 
			\[
			\begin{array}{lr}
			\updateKV(\hh, \vi, \txid, \opset)(\ke) = \updateKV(\hh, \vi, \txid, \opset' \uplus \{(\otR, \ke', \_)\})(\ke) &=\\
			\updateKV(\hh, \vi, \txid, \opset' \uplus \{(\otR, \ke, \_)\})(\ke) &\stackrel{\eqref{eq:updatekv}}{=}\\
			\updateKV(\hh\rmto{\ke}{\hh(\ke)\rmto{\max(\vi(\ke))}{(\val', \txid', \T' \cup \{\txid\}}}, \vi, \txid, \opset')(\ke) &\stackrel{\eqref{eq:updateKV.explicit.rdwr.applyWR}}{=}\\
			\hh\rmto{\ke}{\hh(\ke)\rmto{\max(\vi(\ke))}{(\val', \txid', \T' \cup \{\txid\}}}(\ke) \lcat \List{(\val, \txid, \emptyset)}\\
			\hh(\ke)\rmto{\max(\vi(\ke))}{(\val' \txid', \T' \cup \{\txid\}} \lcat \List{(\val, \txid, \emptyset)}
			\end{array}
			\]
			If $\ke \neq \ke'$, then we have that both $(\otR, \ke, \_) \in \opset'$ and 
			$(\otW, \ke, \val) \in \opset'$. In this case, by the inductive hypothesis we have that 
			\begin{equation}
			\forall \hh'.\;\updateKV(\hh,\vi,\txid,\opset')(\ke) = \hh'(\ke)\rmto{\max(\vi(\ke))}{(\val', \txid', \T' \cup \{\txid\})} \lcat \List{(\val, \txid, \emptyset)}
			\label{eq:updatekv.explicit.rdwr.IHrd}
			\end{equation}
			from which it follows that 
			\[
			\begin{array}{lr}
			\updateKV(\hh, \vi, \txid, \opset)(\ke) = \updateKV(\hh, \vi, \txid, \opset' \uplus \{(\otR, \ke', \_)\})(\ke) &\stackrel{\eqref{eq:updatekv}}{=}\\
			\updateKV(\hh\rmto{\ke'}{\_}, \vi, \txid, \opset')(\ke) &\stackrel{\eqref{eq:updatekv.explicit.rdwr.IHrd}}{=}\\
			\hh\rmto{\ke'}{\_}(\ke)\rmto{\max(\vi(\ke))}{(\val', \txid', \T' \cup \{\txid\})} \lcat \List{(\val, \txid, \emptyset)} &=\\
			\hh(\ke)\rmto{\max(\vi(\ke))}{(\val', \txid', \T' \cup \{\txid\})} \lcat \List{(\val, \txid, \emptyset)}
			\end{array}
			\]
			
			\item $\opset = \opset' \uplus \{(\otW, \ke'', \val'')\}$ for some $\ke'', \val''$. Again, 
			there are two possible cases to consider. If $\ke = \ke''$, then $\val = \val''$ because of the structure imposed on $\opset$.
			Furthermore, we have that 
			$(\otR, \ke, \_) \in \opset'$ and $(\otW, \ke, \val''') \notin \opset$ for all $\val''' \in \Val$.
			By \cref{lem:updatekv.explicit}\eqref{item:updatekv.explicit.rd} we have that 
			\begin{equation}
			\forall \hh'.\;\updateKV(\hh', \vi, \txid, \opset')(\ke) = \hh'(\ke)\rmto{\max(\vi(\ke))}{(\val', \txid', \T' \cup \{\txid\})}
			\label{eq:updatekv.explicit.rdwr.applyRD}
			\end{equation}
			We have that 
			\[
			\begin{array}{lr}
			\updateKV(\hh,\vi,\txid, \opset)(\ke) = \updateKV(\hh, \vi, \txid, \opset' \cup \{(\otW, \ke'', \val'')\})(\ke) &= \\
			\updateKV(\hh,\vi, \txid, \opset' \cup \{(\otW, \ke, \val)\})(\ke) &\stackrel{\eqref{eq:updatekv}}{=}\\
			\updateKV(\hh\rmto{\ke}{\hh(\ke) \lcat \List{(\val, \txid, \emptyset)}}, \vi, \txid, \opset')(\ke) &\stackrel{\eqref{eq:updatekv.explicit.rdwr.applyRD}}{=}\\
			\hh\rmto{\ke}{\hh(\ke) \lcat \List{(\val, \txid, \emptyset)}}(\ke)\rmto{\max(\vi(\ke))}{(\val', \txid', \T' \cup \{\txid\})} &=\\
			(\hh(\ke) \lcat\List{(\val, \txid, \emptyset)})\rmto{\max(\vi(\ke))}{(\val', \txid', \T' \cup \{(\txid\})} &=\\
			\hh(\ke)\rmto{\max(\vi(\ke))}{(\val',\txid', \T' \cup \{(\txid)\})} \lcat \List{(\val, \txid, \emptyset)}
			\end{array}
			\]
			Finally, if $\ke \neq \ke'$, then we have that $(\otR, \ke, \_) \in \opset'$ and $(\otW, \ke, \val) \in \opset'$. 
			By the inductive hypothesis, we obtain 
			\begin{equation}
			\forall \hh'.\;\updateKV(\hh', \vi, \txid, \opset')(\ke) = \hh'(\ke)\rmto{\max(\vi(\ke))}{(\val', \txid', \T' \cup \{\txid\})} \lcat \List{(\val, \txid, \emptyset)}.
			\label{eq:updatekv.explicit.rdwr.IHwr}
			\end{equation}
			It follows that 
			\[
			\begin{array}{lr}
			\updateKV(\hh, \vi, \txid, \opset)(\ke) = \updateKV(\hh, \vi, \txid, \opset' \uplus \{(\otW, \ke', \_)\}) &\stackrel{\eqref{eq:updatekv}}{=}\\
			\updateKV(\hh\rmto{\ke'}{\_}, \vi, \txid, \opset')(\ke) &\stackrel{\eqref{eq:updatekv.explicit.rdwr.IHwr}}{=}\\
			\hh\rmto{\ke'}{\_}(\ke)\rmto{\max(\vi(\ke))}{(\val', \txid', \T' \cup \{\txid\})} \lcat \List{(\val, \txid, \emptyset)} &=\\
			\hh\rmto{\max(\vi(\ke))}{(\val', \txid', \T' \cup \{\txid\})} \lcat \List{(\val, \txid, \emptyset)}
			\end{array}
			\]
			\end{itemize}
\end{enumerate}
\end{proof}
%\begin{lemma}
%\ac{This Lemma was wrong}
%Let $\hh \in \HisHeaps$, $\vi \in \Views(\hh)$, 
%$\txid \in \TxID$ and $\opset \in \powerset{\Ops}$. 
%Let also $\ke \in \Keys$ be such that 
%$\forall \val \in \Val.\;(\otR, \ke, \val) \notin \opset$. Then 
%for any versions $\ver$, 
%\[
%\updateKV(\hh, \vi, \txid, \opset)\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}} = 
%\updateKV(\hh\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}}, \vi, \txid, \opset)
%\] 
%\end{lemma}
%
%\begin{proof}
%By induction on $\opset$. 
%\begin{itemize}
%\item Base case: $\opset = \emptyset$. In this case we have that 
%\[
%\begin{array}{lr}
%\updateKV(\hh, \vi, \txid, \emptyset)\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}} &=\\
%\hh\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}} &\\
%&\\
%\updateKV(\hh\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}}, \vi ,\txid, \opset) &=\\
%\hh\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}}
%\end{array}
%\]
%and there is nothing left to prove.
%\item Suppose that 
%\begin{equation}
%\label{eq:opset.read.def}
%\opset = \opset' \uplus \{(\otR, \ke', \val')\}. 
%\end{equation} 
%By assumption we have that $\forall \val \in \Val.\;(\otR,\ke, \val) \notin \opset$, which implies that 
%\begin{equation}
%\label{eq:kep.neq.ke}
%\ke' \neq \ke, 
%\end{equation}
%and $\forall \val \in \Val.\; (\otR, \ke, \val) \notin \opset'$. 
%%Also, because we are assuming that $\opset$ contains at most a read operation for key $\ke'$, 
%%it must be the case that $\forall \val \in \Val.\;(\otR, \ke', \val) \notin \opset'$.
%By inductive hypothesis, we have that for any kv-store $\hh'$, then 
%\begin{equation}
%\label{eq:updatekv.rd.extract}
%\updateKV(\hh', \vi, \txid, \opset')\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}} = 
%\updateKV(\hh'\rmto{\ke}{\hh'(\ke)\rmto{\vi(\ke)}{\ver'}}, \vi, \txid, \opset').
%\end{equation}
%To prove the claim, we will need the following facts, which are trivial to prove: 
%\begin{equation}
%\label{eq:fsubst.same}
%\forall f: X \rightarrow Y.\; \forall x_1,x_2 \in X.\;\forall y \in Y. x_1 \neq x_2 \implies f\rmto{x_2}{y}(x_1) = f(x_1).
%\end{equation}
%\begin{equation}
%\label{eq:fsubst.swap}
%\forall f: X \rightarrow Y. \forall x_1, x_2 \in X.\; \forall y_1, y_2 \in Y. x_1 \neq x_2 \implies f\rmto{x_1}{y_1}\rmto{x_2}{y_2} = 
%f\rmto{x_2}{y_2}\rmto{x_1}{y_1}.
%\end{equation}
%%We then have that 
%%\[
%%\begin{array}{lr}
%%\updateKV(\hh, \vi, \txid, \opset) =
%%\mathtt{ let } (\val, \txid', \T) = \hh(\ke', \vi) \mathtt{ in } &\\  
%% \updateKV(\hh\rmto{\ke'}{\hh(\ke')\rmto{\vi(\ke')}{(\val, \txid', \T \cup \{ t \})}}, \vi, \txid, \opset') &=\\
%% & \\
%% \mathtt{ let } (\val, \txid', \T) = \hh(\ke, \vi) \mathtt{ in } &\\ 
%% \updateKV(\hh, \vi, \txid, \opset')\rmto{\ke'}{\hh(\ke')\rmto{\vi(\ke')}{(\val, \txid', \T \cup \{ t \})}}
%%\end{array}
%%\]
%%from which it follows that \
%We then have that 
%\[
%\begin{array}{lr}
%\updateKV(\hh, \vi, \txid, \opset)\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}} &\stackrel{\eqref{eq:opset.read.def}}{=}\\ 
%&\\
%\updateKV(\hh, \vi, \txid, \opset' \cup \{(\otR, \ke', \val')\})\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}} &\stackrel{\eqref{eq:updatekv}}{=}\\ 
%&\\
%\mathtt{ let } (\val, \txid', \T) = \hh(\ke', \vi) \mathtt{ in } & \\
% \updateKV(\hh\rmto{\ke'}{\hh(\ke')\rmto{\vi(\ke')}{(\val, \txid', \T \cup \{ t \})}}, \vi, \txid, \opset')\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}} &\stackrel{\eqref{eq:updatekv.rd.extract}}{=}\\
%% &\\
%% \mathtt{ let } (\val, \txid', \T) = \hh(\ke', \vi') \mathtt { in } &\\
%% \updateKV(\hh, \vi, \txid, \opset')\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}}\rmto{\ke'}{\hh(\ke')\rmto{\vi(\ke')}{(\val, \txid', \T \cup \{ t \})}} &=\\
%% &\\
%% \mathtt{ let } (\val, \txid', \T) = \hh(\ke, \vi') \mathtt{ in } &\\
%% \updateKV(\hh\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}}, \vi, \txid, \opset')\rmto{\ke'}{\hh(\ke')\rmto{\vi(\ke')}{(\val, \txid', \T \cup \{ t \})}} &=\\ 
%&\\
%\mathtt{ let } (\val, \txid', \T) = \hh(\ke', \vi) \mathtt{ in } &\\
% \updateKV(\hh\rmto{\ke'}{\hh(\ke')\rmto{\vi(\ke')}{(\val, \txid', \T \cup \{ t \})}}\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}}, \vi, \txid, \opset') &\stackrel{\eqref{eq:fsubst.swap}}{=}\\ 
%&\\
%\mathtt{ let } (\val, \txid', \T) = \hh(\ke', \vi) \mathtt{ in } &\\
% \updateKV(\hh\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}}\rmto{\ke'}{\hh(\ke')\rmto{\vi(\ke')}{(\val, \txid', \T \cup \{ t \})}}, \vi, \txid, \opset') &\stackrel{\eqref{eq:fsubst.same}}{=}\\ 
%&\\
%\mathtt{ let } (\val, \txid', \T) = \hh\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}}(\ke', \vi) \mathtt{ in } &\\
% \updateKV(\hh\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}}\rmto{\ke'}{\hh(\ke')\rmto{\vi(\ke')}{(\val, \txid', \T \cup \{ t \})}}, \vi, \txid, \opset') &\stackrel{\eqref{eq:updatekv}}{=}\\ 
%&\\ 
%\updateKV(\hh\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}}, \vi, \txid, \opset' \cup \{(\otR, \ke', \val')\} &\stackrel{\eqref{eq:opset.read.def}}{=}\\
%&\\
%\updateKV(\hh\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}}, \vi, \txid, \opset)
%\end{array}
%\]
%\item Suppose that 
%\begin{equation}
%\label{eq:opset.wr.def}
%\opset = \opset' \uplus \{(\otW, \ke', \val)\}
%\end{equation}
%Then we have that 
%\[
%\begin{array}{lr}
%\updateKV(\hh, \vi, \txid, \opset)\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}} = 
%\updateKV(\hh, \vi, \txid, \opset' \uplus \{(\otW, \ke', \val)\} &=\\
%&\\
%\updateKV(\hh\rmto{\ke}{\hh(\ke) \lcat \List{(\val, \txid, \emptyset)}}, \vi, \txid, \opset')\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}} &=\\
%&\\
%\updateKV(\hh\rmto{\ke}{\hh(\ke) \lcat \List{(\varl, \txid, \emptyset)}}\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}}
%\end{array}
%\]
%\end{itemize}
%\end{proof}

In the following, given a version $\ver = (\val, \txid', \T)$ and a set of 
transaction identifiers $\T'$, we let $\ver \oplus \T' = (\val, \txid', \T \cup \T')$. 
Clearly the operator $\oplus$ is commutative over sets of transactions: 
$\forall \ver, \T, \T'.\; (\ver \oplus \T) \oplus \T' = (\ver \oplus \T') \oplus \T = 
\ver \oplus (\T \cup \T')$.

\begin{corollary}
\label{cor:updatekv.singlecell}
Let $\hh$ be a kv-store, $\vi \in \Views(\hh)$, $\txid \in \TxID$ and $\opset \in \powerset{\Ops}$. 
Let also $\ke \in \Keys$. Then 
\begin{enumerate}
\item\label{item:updatekv.singlecell.noview} $\forall i=0,\cdots, \lvert \hh(\ke) \rvert -1.\; i \neq \max(\vi(\ke)) \implies \updateKV(\hh, \vi, \txid, \opset)(\ke, i) = 
\hh(\ke, i)$, 
\item\label{item:updatekv.singlecell.rd} $\forall \val. (\otR, \ke, \_) \in \opset \implies \updateKV(\hh,\vi,\txid, \opset)(\ke, \vi) = \hh(\ke, \max(\vi(\ke))) \oplus \{\txid\}$; 
\item\label{item:updatekv.singlecell.nord} $(\forall \val.(\otR,\ke, \val) \notin \opset) \implies \updateKV(\hh,\vi,\txid, \opset)(\ke,\vi) = \hh(\ke, \max(\vi(\ke)))$;
\item\label{item:updatekv.singlecell.wr} $\forall \val.(\otW, \ke, \val) \in \opset \implies (\lvert \updateKV(\hh,\vi,\txid,\opset)(\ke) \rvert = 
\lvert \hh(\ke) \rvert + 1) \wedge \updateKV(\hh,\vi,\txid,\opset)(\ke, \lvert \hh(\ke) \rvert) = (\val, \txid, \emptyset)$.
\item\label{item:updatekv.singlecell.nowr} $(\forall \val.(\otW, \ke, \val) \notin \opset) \implies \lvert \updateKV(\hh,\vi,\txid,\opset)(\ke) \rvert = \lvert \hh(\ke) \rvert$.
\end{enumerate}
\end{corollary}

\begin{proof}
A simple consequence of \cref{lem:updatekv.explicit}.
\end{proof}
\ac{For the moment I will assume that I have proved this, though it should be a simple consequence of Lemma 
\ref{lem:updatekv.explicit}.}

\begin{proposition}
Let $\hh \in \HisHeaps$, $\vi_1, \vi_2 \in \Views(\hh)$, 
$\txid_1, \txid_2 \in \TxID$. 
Let also $\opset_1, \opset_2$ be such that whenever 
$(\otW, \ke, \_) \in \opset_1$, then $(\otW, \ke, \val) \notin \opset_2$ 
for all $\val \in \Val$. Then we have that
\[
\begin{array}{l}
\mathtt{let } \hh_1 = \updateKV(\hh, \vi_1, \txid_1, \opset_1) \mathtt{ in } \updateKV(\hh_1, \vi_2, \txid_2, \opset_2) = \\
\mathtt{let } \hh_2 = \updateKV(\hh, \vi_2, \txid_2, \opset_2) \mathtt{ in } \updateKV(\hh_2, \vi_1, \txid_1, \opset_1).
\end{array}
\]
\end{proposition}

\begin{proof}
Let $\hh_1 = \updateKV(\hh, \vi_1, \txid_1, \opset_1)$, $\hh_2 = \updateKV(\hh, \vi_2, \txid_2, \opset_2)$. It 
suffices to show that for any $\ke \in \Keys$, $\lvert \updateKV(\hh_1, \vi_2, \txid_2, \opset_2)(\ke) \rvert = \lvert 
\updateKV(\hh_2, \vi_1, \txid_1, \opset_1)(\ke) \rvert$, and for any $i=0,\cdots, \lvert \updateKV(\hh_1, \vi_2, \txid_2, \opset_2)(\ke) \rvert$, 
$\updateKV(\hh_1, \vi_2, \txid_2,\opset_2)(\ke, i) = \updateKV(\hh_2, \vi_1, \txid_1, \opset_1)(\ke_1)$. 
\ac{Note that this proof - and also the proof of the lemma before it- requires proves the equivalence of two functions by proving the equivalence of their values 
for each element in their domains; in other words, this proof uses the axiom of extensionality. I am pretty sure 
that a proof that reduces the two terms to the same normal form exists, though it has way too many details 
and would not be feasible without using a theorem prover.}

First, fix a key $\ke \in \Keys$. Note that if $(\otW, \ke, \_) \in \opset_1$, then 
by Corollary \ref{cor:updatekv.singlecell} we have that $\lvert \updateKV(\hh, \vi_1, \txid_1, \opset_1)(\ke) \rvert = 
\lvert \hh(\ke) \rvert$. Because $\opset_1$ is not conflicting with $\opset_2$, it must be the case 
that $\forall \val.(\otW,\ke,\val) \notin \opset_2$, and therefore by \cref{cor:updatekv.singlecell} 
we have that 
\[
\lvert \updateKV(\hh_1, \vi_2, \txid_2, \opset_2)(\ke) \rvert = \lvert \hh_1(\ke) \rvert = \lvert \hh(\ke) \rvert + 1.
\] 
Similarly, because $\forall \val.(\otW,\ke,\val)\notin \opset_2$ 
and $(\otW,\ke,\_) \in \opset_1$, then 
\[
\lvert \updateKV(\hh_2, \vi_1, \txid_1, \opset_1)(\ke) \rvert = \lvert \hh_2(\ke) \rvert + 1 = 
\lvert \updateKV(\hh, \vi_2, \txid_2, \opset_2)(\ke) \rvert = \lvert \hh(\ke) \rvert + 1.
\]
Therefore, if $(\otW, \ke, \_) \in \opset_1$, we have that 
$\lvert \updateKV(\hh_2, \vi_1, \txid_1, \opset_1)(\ke) \rvert = 
\lvert \updateKV(\hh_1(\ke), \vi_2, \txid_2, \opset_2)(\ke) \rvert$.
Analogously, we can prove that this claim holds also when $(\otW, \ke, \_) \in \opset_2$. 
Finally, if $(\forall \val.(\otW,\ke,\_) \notin \opset_1) \wedge (\forall \val.(\otW,\ke,\val) \notin \opset_2)$, 
then by \cref{cor:updatekv.singlecell} we have that 
\[
\lvert \updateKV(\hh_1, \vi_2, \txid_2, \opset_2)(\ke) \rvert = 
\lvert \hh_1(\ke) \rvert = \lvert \updateKV(\hh, \vi_1, \txid_1, \opset_1)(\ke) \rvert = \lvert \hh(\ke) \rvert,
\]
\[
\lvert \updateKV(\hh_2, \vi_1, \txid_1, \opset_1)(\ke) \rvert = 
\lvert \hh_2(\ke) \rvert = \lvert \updateKV(\hh, \vi_2, \txid_2, \opset_2)(\ke) \rvert = \lvert \hh(\ke) \rvert.
\]
This concludes the proof that, for any $\ke \in \Keys$, $\lvert \updateKV(\hh_1,\vi_2,\txid_2,\opset_2) \rvert = 
\lvert \updateKV(\hh_2,\vi_1,\txid_1,\opset_1) \rvert$.

Next, fix a key $\ke$ and a index $i =0, \cdots, \lvert \hh(\ke) \rvert - 1$. 
We show that $\updateKV(\hh_1,\vi_2,\txid_2,\opset_2)(\ke, i) = \updateKV(\hh_2, \vi_1, \txid_1, \opset_1)(\ke, i)$ 
by performing a case analysis on $\vi_1$: 
\begin{enumerate}
\item $i \neq \max(\vi_1(\ke))$: in this case, by \cref{cor:updatekv.singlecell}\eqref{item:updatekv.singlecell.noview}, 
we have that 
\begin{equation}
\hh_1(\ke, i) = \updateKV(\hh, \vi_1, \txid_1, \opset_1)(\ke, i) = \hh(\ke, i), 
\label{eq:v1.nord.hh1}
\end{equation}
and 
\begin{equation}
\updateKV(\hh_2, \vi_1, \txid_1, \opset_1)(\ke, i) = \hh_2(\ke, i).
\label{eq:v1.nord.uhh2}
\end{equation}
We have three possible sub-cases: 
\begin{enumerate}
\item $i \neq \max(\vi_2(\ke))$: in this case, by \cref{cor:updatekv.singlecell}\eqref{item:updatekv.singlecell.noview} we have that 
\[\updateKV(\hh_1, \vi_2, \txid_2, \opset_2)(\ke, i) = 
\hh_1(\ke, i) \stackrel{\eqref{eq:v1.nord.hh1}}{=} \hh(\ke, i), 
\]
\[
\updateKV(\hh_2, \vi_1, \txid_1, \opset_1) \stackrel{\eqref{eq:v1.nord.uhh2}}{=} \hh_2(\ke,i) = 
\updateKV(\hh, \vi_2, \txid_2, \opset_2)(\ke, i) = \hh(\ke, i).
\]
\item $i = \max(\vi_2(\ke))$, and $(\otR, \ke, \_) \notin \opset_2$. In this case the proof is analogous to the previous case, 
only \cref{cor:updatekv.singlecell}\eqref{item:updatekv.singlecell.nord} needs to be applied in place 
of \cref{cor:updatekv.singlecell}\eqref{item:updatekv.singlecell.noview}.
\item $i = \max(\vi_2(\ke))$, and $(\otR, \ke, \_) \in \opset_2$. In this case we can apply \cref{cor:updatekv.singlecell}\eqref{item:updatekv.singlecell.rd}, 
and deduce that 
\begin{equation}
\updateKV(\hh_1, \vi_2, \txid_2, \opset_2)(\ke, i) = \hh_1(\ke, i) \oplus \{\txid_2\}
\label{eq:v1.nord.v2.rd.uhh1}
\end{equation}
\begin{equation}
\hh_2(\ke, i) = \updateKV(\hh, \vi_2, \txid_2, \opset_2)(\ke, i) = \hh(\ke,i) \oplus \{\txid_2\}
\label{eq:v1.nord.v2.rd.hh2}
\end{equation}
It follows that 
\[
\begin{array}{l}
\updateKV(\hh_1, \vi_2, \txid_2, \opset_2)(\ke, i) \stackrel{\eqref{eq:v1.nord.v2.rd.uhh1}}{=} \hh_1(\ke, i) \oplus \{\txid_2 \} \stackrel{\eqref{eq:v1.nord.hh1}} \hh(\ke, i) \oplus \{\txid_2\}\\
\updateKV(\hh_2,\vi_1, \txid_1,\opset_1)(\ke, i) \stackrel{\eqref{eq:v1.nord.uhh2}}{=} \hh_2(\ke, i) \stackrel{\eqref{eq:v1.nord.v2.rd.hh2}} = \hh(\ke, i) \oplus \{\txid_2\}
\end{array}
\]
\end{enumerate}
\item $i = \max(\vi_1(\ke))$, $(\otR, \ke, \_) \notin \opset_1$. This case is similar to the previous one: we can infer 
that Equations \eqref{eq:v1.nord.hh1} and \eqref{eq:v1.nord.uhh2} are valid in this case using \cref{cor:updatekv.singlecell}
\eqref{item:updatekv.singlecell.nord}, then we can proceed by performing a case analysis on $\vi_2$ and $\opset_2$ as in the previous case.
\item $i = \max(\vi_1(\ke))$, $\otR,\ ke, \_) \in \opset_1$. We can apply \cref{cor:updatekv.singlecell}\eqref{item:updatekv.singlecell.rd} 
to deduce the following: 
\begin{equation}
\hh_1(\ke, i) = \updateKV(\hh, \vi_1, \txid_1, \opset_1)(\ke, i) = \hh(\ke, i) \oplus \{\txid_1\},
\label{eq:v1.rd.hh1}
\end{equation}
\begin{equation}
\updateKV(\hh_2, \vi_1, \txid_1, \opset_1)(\ke, i) = \hh_2(\ke, i) \oplus \{\txid_1\}. 
\label{eq:v1.rd.uhh2}
\end{equation}
We have two different sub-cases to consider: 
\begin{enumerate}
\item $i \neq \max(\vi_2(\ke))$, or $i = \max(\vi_2(\ke))$ with $(\otR,\ke,\_) \notin \opset_2$. In this case, we can apply either 
\cref{cor:updatekv.singlecell}\eqref{item:updatekv.singlecell.noview} (if $i \neq \max(\vi_2(\ke))$ ), or 
\cref{cor:updatekv.singlecell} \eqref{item:updatekv.singlecell.nord} (if $i = \max(\vi_2(\ke))$ and $(\otR, \ke, \_) \notin \opset_2$), 
to obtain 
\[
\updateKV(\hh_1, \vi_2, \txid_2, \opset_2)(\ke, i) = \hh_1(\ke, i) \stackrel{\eqref{eq:v1.rd.hh1}}{=} \hh(\ke, i) \oplus \{\txid_1\},
\]
\[
\updateKV(\hh_2, \vi_1, \txid_1, \opset_1)(\ke, i) \stackrel{\eqref{eq:v1.rd.uhh2}}{=} \hh_2(\ke, i) \oplus \{ \txid_1 \} = 
\hh(\ke, i) \oplus \{ \txid_1 \}.
\]
\item if $i = \max(\vi_2(\ke))$ and $(\otR, \ke, \_) \in \opset_2$, then by \cref{cor:updatekv.singlecell}\eqref{item:updatekv.singlecell.rd} 
we obtain that 
\begin{equation}
\hh_2(\ke, i) = \updateKV(\hh, \vi_2, \txid_2, \opset_2)(\ke, i) = \hh(\ke, \i) \oplus \{\txid_2\},
\label{eq:v1.rd.v2.rd.hh2}
\end{equation}
\begin{equation}
\updateKV(\hh_1, \vi_2, \txid_2, \opset_2)(\ke, i) = \hh_1(\ke, i) \oplus \{ \txid_2\}.
\label{eq:v1.rd.v2.rd.uhh1}
\end{equation}
From these facts it follows that
\[
\begin{array}{l}
\updateKV(\hh_1, \vi_2, \txid_2, \opset_2)(\ke, i) \stackrel{\eqref{eq:v1.rd.v2.rd.uhh1}}{=} \hh_1(\ke, i) \oplus \{\txid_2\} \stackrel{\eqref{eq:v1.rd.hh1}}{=} 
(\hh(\ke, i) \oplus \{\txid_1\}) \oplus \{\txid_2 \} = \hh(\ke, i) \oplus \{\txid_1, \txid_2\}\\
\updateKV(\hh_2, \vi_1, \txid_1, \opset_1)(\ke, i) \stackrel{\eqref{eq:v1.rd.uhh2}}{=} \hh_2(\ke, i) \oplus \{\txid_1\} 
\stackrel{\eqref{eq:v1.rd.v2.rd.hh2}}{=} (\hh(\ke, i) \oplus \{\txid_2\}) \oplus \{\txid_1\} = \hh(\ke, i) \oplus \{\txid_1, \txid_2\}
\end{array}
\]
\end{enumerate}
\end{enumerate}

Next, note that if $\forall \val \in \Val.\;(\otW,\ke,\val) \notin \opset_1 \wedge (\otW, \ke, \val) \notin 
\opset_2$, then $\lvert \updateKV(\hh_1, \vi_2, \txid_2, \opset_2)(\ke) \rvert = \lvert \hh(\ke) \rvert 
= \lvert \updateKV(\hh_2, \vi_1, \txid_1, \opset_1)(\ke) \rvert$. 
Because we have already proved that $\forall i = 0,\cdots, \lvert \hh(\ke) \rvert.\; \updateKV(\hh_1, 
\vi_2, \txid_2, \opset_2)(\ke, i) = \updateKV(\hh_2, \vi_1, \txid_1, \opset_1)(\ke, i)$, it follows 
that $\updateKV(\hh_1, \vi_2, \txid_2, \opset_2)(\ke) = \updateKV(\hh_2,\vi_1,\txid_1,\opset_1)(\ke)$, 
and there is nothing left to prove.

Suppose then that  either $(\otW, \ke, \val) \in \opset_1$ or $(\otW,\ke, \val) \in \opset_2$ 
for some $\val$. Without loss of generality, let $(\otW,\ke,\val) \in \opset_1$ for some $\val \in \Val$; 
because we are assuming that $\opset_1$ does not conflict with $\opset_2$, then 
it must be the case that $\forall \val' \in \Val.\;(\otW,\ke,\val') \notin \opset_2$. 
Using \cref{cor:updatekv.singlecell}\eqref{item:updatekv.singlecell.nowr} and 
\cref{cor:updatekv.singlecell}\eqref{item:updatekv.singlecell.wr}, 
\[
\begin{array}{l}
\updateKV(\hh_1, \vi_2, \txid_2, \opset_2)(\ke, \lvert \hh(\ke) \rvert) = 
\hh_1(\ke, \lvert \hh(\ke) \rvert) = \updateKV(\hh, \vi_1, \txid_1, \opset_1)(\lvert \hh(\ke) \rvert) = (\val, \txid_1, \emptyset)\\
\updateKV(\hh_2, \vi_1, \txid_1,\ opset_1)(\ke, \lvert, \hh(\ke) \rvert) = (\val, \txid_1, \emptyset)
\end{array}
\]
We have now proved that if $(\otW,\ke,\val) \in \opset_1$, then $\lvert \updateKV(\hh_1, \vi_2, \txid_2, \opset_2) \rvert = 
\lvert \updateKV(\hh_2, \vi_1, \txid_1, \opset_1) \rvert$, and for all 
$i=0,\cdots, \lvert \updateKV(\hh_1, \vi_2, \txid_2, \opset_2) \rvert - 1$, 
$\updateKV(\hh_1,\vi_2, \txid_2, \opset_2)(\ke, i) = \updateKV(\hh_2, \vi_1, \txid_1, \opset_1)(\ke, i)$. 
This concludes the proof that $\forall \ke \in \Keys.\updateKV(\hh_1,\vi_2,\txid_2,\opset_2)(\ke) = 
\updateKV(\hh_2,\vi_1,\txid_1,\opset_1)(\ke)$, and therefore 
$\updateKV(\hh_1, \vi_2, \txid_2, \opset_2) = \updateKV(\hh_2, \vi_1,\txid_1,\opset_1)$.
\end{proof}
%
%\begin{proof}
%, $\updateKV(\hh_1, \vi_2, \txid_2, \opset_2)(\ke) = 
%\updateKV(\hh_1,\vi_2, \txid_2,\opset_1)(\ke)$. Fix then $\ke \in \Keys$, and let 
%$(\val_1, \txid_1, \T_1) = \hh(\ke, \vi_1), (\val_2,\txid_2, \T_2) = \hh(\ke, \vi_2)$. We perform a case analysis on $\opset_1$.
%
%\begin{proof}
%\ac{4 cases for $\opset_1$, each of which requires 4 cases for $\opset_2$. 16 sub-cases in total. I hate when 
%this happens.} 
%Let $\hh_1 = \updateKV(\hh, \vi_1, \txid_1, \opset_1)$, $\hh_2 = \updateKV(\hh, \vi_2, \txid_2, \opset_2)$. It 
%suffices to show that for any $\ke \in \Keys$, $\updateKV(\hh_1, \vi_2, \txid_2, \opset_2)(\ke) = 
%\updateKV(\hh_1,\vi_2, \txid_2,\opset_1)(\ke)$. Fix then $\ke \in \Keys$, and let 
%$(\val_1, \txid_1, \T_1) = \hh(\ke, \vi_1), (\val_2,\txid_2, \T_2) = \hh(\ke, \vi_2)$. We perform a case analysis on $\opset_1$.
%\begin{itemize}
%\item Suppose that $\forall \val.\;(\otR, \ke, \val) \notin \opset_1 \wedge (\otW, \ke, \val) \notin \opset_1$. 
%In this case, by \cref{lem:updatekv.explicit}\eqref{item:updatekv.explicit.none} we have that 
%$\hh_1(\ke) = \updateKV(\hh, \vi_1, \txid_1, \opset_1)(\ke) = \hh(\ke)$, 
%and $\updateKV(\hh_2, \vi_1, txid_1, \opset_1)(\ke) = \hh_2(\ke)$. It follows that 
%\[
%\begin{array}{l}
%\updateKV(\hh_1, \vi_2, \txid_2, \opset_2)(\ke) = \updateKV(\hh, \vi_2, \txid_2, \opset_2)(\ke)\\
%\updateKV(\hh_2, \vi_1\ txid_2, \opset_2)(\ke) = \hh_2(\ke) = \updateKV(\hh,\vi_2, \txid_2, \opset_2)(\ke)
%\end{array}
%\]
%\item Suppose now that $(\otR, \ke, \_) \in \opset_1$, and $\forall \val.(\otW,\ke,\val) \notin \opset_1$. 
%By \cref{lem:updatekv.explicit}\eqref{item:updatekv.explicit.rd} we have the following: 
%\begin{align}
%\hh_1(\ke) = \updateKV(\hh, \vi_1, \txid_1, \opset_1)(\ke) = 
%\big( \text{let } (\val_1, \txid_1', \T_1) = \hh(\ke, \vi_1) \text{ in } \hh(\ke)\rmto{\vi_1(\ke)}{(\val_1, \txid_1', \T_1 \cup \{\txid_1\})} \big)
%\label{eq:updatekv.swap.rd11}\\
%\nonumber\updateKV(\hh_2, \vi_1, \txid_1, \opset_1)(\ke) = big( \text{let } (\val_2, \txid_2', \T_2) = \hh_2(\ke, \vi_1) 
%\text{ in } \hh_2(\ke)\rmto{\vi_1(\ke)}{(\val_2, \txid_2', \T_2 \cup \{\txid_1\})} \big) = \\
%\text{let } (\val_2, \txid_2, \T_2) = \hh_2(\ke, \vi_1) \text{ in } \updateKV(\hh, \vi_2, \txid_2, \opset_2)(\ke)\rmto{\vi_1(\ke)}{(\val_2, \txid_2,', \T_2 \cup \{\txid_1\})}
%\label{eq:updatekv.swap.rd12}
%\end{align}
%\ac{The let statement here is necessary (in the second equation, I kept it in the first one for the sake of 
%conformity) because the contents of $\val_2, \txid_2, \T_2$ are going to change according to 
%the values of $\opset_2$ and $\vi_2(\ke)$. Lazy evaluation here helps in not repeating lots of details in 
%the rest of the proof.}
%We now perform a second case analysis on $\opset_2$. 
%\begin{itemize}
%\item $\forall \vi.\;(\otR, \ke, \val) \notin \opset_2 \wedge (\otW, \ke, \val) \notin \opset_2$. 
%By \cref{lem:updatekv.explicit}\eqref{item:updatekv.explicit.none} we have that 
%\begin{align}
%\hh_2(\ke) = \updateKV(\hh, \vi_2, \txid_2, \opset_2)(\ke) = \hh(\ke) 
%\label{eq:updatekv.swap.rd.none1}\\
%\updateKV(\hh_1, \vi_2, \txid_2, \opset_2)(\ke) = \hh_1(\ke)
%\label{eq:updatekv.swap.rd.none2}
%\end{align}
%from which it follows 
%\[
%\begin{array}{lr}
%\updateKV(\hh_1, \vi_2, \txid_2, \opset_2)(\ke) \stackrel{\eqref{eq:updatekv.swap.rd.none2}}{=} 
%\hh_1(\ke) & \stackrel{\eqref{eq:updatekv.swap.rd11}}{=}\\
%\text{let } (\val_1, \txid_1', \T_1) = \hh(\ke, \vi_1) \text{ in } \hh(\ke)\rmto{\vi_1(\ke)}{(\val_1, \txid_1', \T_1 \cup \{\txid_1\})} \big) &\\
%&\\
%\updateKV(\hh_2, \vi_1, \txid_1, \opset_1)(\ke) &\stackrel{\eqref{eq:updatekv.swap.rd12}}{=}\\ 
%\text{let } (\val_2, \txid_2', \T_2) = \hh_2(\ke, \vi_1) \text{ in } \updateKV(\hh, \vi_2, \txid_2, \opset_2)(\ke)\rmto{\vi_1(\ke)}{(\val_2, \txid_2', \T_2 \cup \{\txid_1\})} 
%&\stackrel{\eqref{eq:updatekv.swap.rd.none1}}{=} \\
%\text{let } (\val_2, \txid_2', \T_2) = \hh(\ke, \vi_1) \text{ in } \hh(\ke)\rmto{\vi_1(\ke)}{(\val_2, \txid_2', \T_2 \cup \{\txid_1\})}
%\end{array}
%\]
%
%\item $(\otR, \ke, \_) \in \opset_2 \wedge \forall (\otW, \ke, \val) \notin \opset_2$. 
%By \cref{lem:updatekv.explicit}\eqref{item:updatekv.explicit.rd} we have that 
%\begin{align}
%\nonumber\hh_2(\ke) = \updateKV(\hh, \vi_2, \txid_2) =\\ 
%\text{let } (\val_2, \txid_2', \T_2) = \hh(\ke, \vi_2) \text{ in } \hh(\ke)\rmto{\vi_2(\ke)}{(\val_2, \txid_2', \T_2 \cup \{\txid_2\})}
%\label{eq:updatekv.swap.rd.rd1}\\
%~\\
%\nonumber\updateKV(\hh_1, \vi_2, \txid_2, \opset_2)(\ke) = \\
%\nonumber \text{let } (\val_2, \txid_2', \T_2) = \hh_1(\ke, \vi_2) 
%\text{ in } \hh_1(\ke)\rmto{\vi_2(\ke)}{(\val_2, \txid_2', \T_2 \cup \{\txid_2\})}
%\label{eq:updatekv.swap.rd.rd2}
%\end{align}
%We now distinguish between two cases, according to whether $\vi_1(\ke) = \vi_2(\ke)$ or 
%$\vi_1(\ke) \neq \vi_2(\ke)$. 
%\begin{enumerate} 
%\item If $\vi_1(\ke) = \vi_2(\ke)$, then we have the following: 
%\begin{equation}
%\begin{array}{lr}
%\hh_1(\ke, \vi_2) = \hh_1(\ke, \vi_1) = \hh_1(\ke)(\vi_1(\ke))&\stackrel{\eqref{eq:updatekv.swap.rd11}}{=}\\
%\text{let } (\val_1, \txid_1', \T_1)  = \hh(\ke, \vi_1) \text{ in } 
%\left(\hh(\ke)\rmto{\vi_1(\ke)}{(\val_1, \txid_1', \T_1 \cup \{\txid_1\})}\right)(\vi_1(\ke)) &=\\
%\text{let } (\val_1, \txid_1', \T_1) = \hh(\ke, \vi_1) \text{ in } (\val_1, \txid_1', \T_1 \cup \{\txid_1\})
%\end{array}
%\label{eq:updatekv.swap.rd.rd.aux1}
%\end{equation}
%
%\begin{equation}
%\begin{array}{lr}
%\hh_2(\ke, \vi_1) = \hh_2(\ke, \vi_2) = \hh_2(\ke)(\vi_2(\ke)) &\stackrel{\eqref{eq:updatekv.swap.rd.rd2}}{=}\\
%\text{let } (\val_2, \txid_2', \T_2) = \hh(\ke, \vi_2) \text{ in } \left(\hh(\ke)\rmto{\vi_2(\ke)}{(\val_2, \txid_2', \T_2 \cup \{\txid_2\})}\right)(\vi_2(\ke)) &=\\
%\text{let } (\val_2, \txid_2', \T_2) = \hh(\ke, \vi_2) \text{ in } (\val_2, \txid_2', \T_2 \cup \{\txid_2\})
%\end{array}
%\label{eq:updatekv.swap.rd.rd.aux2}
%\end{equation}
%The two facts above can be used to prove the following:
%\[
%\begin{array}{lr}
%\updateKV(\hh_1, \vi_2, \txid_2, \opset_2)(\ke) \stackrel{\eqref{eq:updatekv.swap.rd.rd2}}{=}
%\big(\text{let } (\val_2, \txid_2', \T_2) = \hh_1(\ke, \vi_2) 
%\text{ in } \hh_1(\ke)\rmto{\vi_2(\ke)}{(\val_2, \txid_2', \T_2 \cup \{\txid_2\})}\big) &\stackrel{\eqref{eq:updatekv.swap.rd.rd.aux1}}{=} \\
%\text{let } (\val_2, \txid_2', \T_2) = ( \text{let } (\val_1, \txid_1', \T_1) = \hh(\ke, \vi_1) \text{in } (\val_1, \txid_1', \T_1 \cup \{\txid_1\}) ) &\\
%\hspace{10pt} \text{ in } \hh_1(\ke)\rmto{\vi_1(\ke)}{(\val_2, \txid_2', \T_2 \cup \{\txid_2\})} &=\\
%\text{let } (\val_1, \txid_1', \T_1) = \hh(\ke, \vi_1) \text{in } \hh_1(\ke)\rmto{\vi_1(\ke)}{(\val_1, \txid_1', \T_2 \cup \{\txid_1, \txid_2\})} &\\
%&\\
%\updateKV(\hh_2, \vi_1, \txid_1, \opset_1)(\ke) &\stackrel{\eqref{eq:updateKV.swap.rd12}}{=}\\
%\text{let } (\val_1, \txid'_1, \T_1) = \hh_2(\ke, \vi_1) \text{ in } \updateKV(\hh, \vi_2, \txid_2, \opset_2)(\ke)\rmto{\vi_1(\ke)}{(\val_1, \txid_1', \T_1 \cup \{\txid_1\})} 
%&\stackrel{\eqref{eq:updatekv.swap.rd.rd.aux2}}{=}\\
%\text{let } (\val_1, \txid'_1, \T_1) = ( \text{let } (\val_2, \txid_2', \T_2) = \hh(\ke, \vi_2) \text{ in } (\val_2, \txid_2', \T_2 \cup \{\txid_2\}) ) \text{ in } &\\
%\updateKV(\hh, \vi_2, \txid_2, \opset_2)(\ke)\rmto{\vi_1(\ke)}{(\val_1, \txid_1', \T_1 \cup \{\txid_1\})} &=\\
%\text{let } (\val_1, \txid'_1, \T_1) = \hh(\ke, \vi_2) \text{ in } &\\
%\updateKV(\hh, \vi_2, \txid_2, \opset_2)(\ke)\rmto{\vi_1(\ke)}{(\val_1, \txid_1', \T_1 \cup \{\txid_1, \txid_2\})} &\stackrel{(\ref{lem:updatekv.explicit}-\ref{item:updatekv.explicit.rd})}{=}\\
%\hh(\ke)\rmto{\vi_2(\ke)}{\_}\rmto{\vi_1(\ke)}{(\val_1, \txid_1', \T_1 \cup \{\txid_1, \txid_2\})} &=\\
%\hh(\ke)\rmto{\vi_1(\ke)}{\_}\rmto{\vi_1(\ke)}{(\val_1, \txid_1', \T_1 \cup \{\txid_1, \txid_2\})} &=\\
%\hh(\ke)\rmto{\vi_1(\ke)}{(\val_1,\txid_1', \T_1, \cup \{(\txid_1, \txid_2\})}
%\end{array}
%\]
%\end{enumerate}
%
%\end{itemize}
%%Let $\hh(\ke, \vi) = (\val_1, \txid_1', \T)$ for 
%%some $\val_1, \txid_1', \T_1$.
%%By \cref{lem:updatekv.explicit}\eqref{item:updatekv.explicit.rd}
%%it follows that 
%%\begin{align}
%%\hh_1(\ke) = \updateKV(\hh,\vi_1,\txid_1,\opset_1)(\ke) = \hh(\ke)\rmto{\vi_1(\ke)}{(\val_1, \txid_1', \T_1 \cup \{\txid_1\})}
%%\label{eq:updatekv.swap.rd11} \\
%%\nonumber \\
%%\nonumber \updateKV(\hh_2, \vi_1, \txid_1, \opset_1)(\ke) = \hh_2(\ke)\rmto{\vi_1(\ke)}{(\val_1, \txid_1', \T_1 \cup \{\txid_1\})} = \\
%%\updateKV(\hh, \vi_2, \txid_2, \opset_2)(\ke)\rmto{\vi_1(\ke)}{(\val_1, \txid_1', \T_1 \cup \{\txid_1\})}
%%\label{eq:updatekv.swap.rd12}
%%\end{align}
%%We perform a second analysis on $\opset_2$ 
%%\begin{itemize}
%%\item $\forall \val.(\otR, \ke, \val) \notin \opset_2 \wedge (\otW,\ke,\val) \notin \opset_2$. 
%%By \cref{lem:updatekv.explicit}\eqref{item:updatekv.explicit.none} we have that 
%%\[
%%\hh_2(\ke) = \updateKV(\hh, \vi_2, \txid_2, \opset_2)(\ke) = \hh(\ke),
%%\]
%%and 
%%\[\updateKV(\hh, \vi_2, \txid_2, \opset_2)(\ke) = \hh(\ke).
%%\] 
%%It follows that 
%%\[
%%\begin{array}{l}
%%\updateKV(\hh_1, \vi_2, \txid_2, \opset_2)(\ke) = \hh_1(\ke) \stackrel{\eqref{eq:updatekv.swap.rd11}}{=} 
%%\hh(\ke)\rmto{\vi_1(\ke)}{(\val_1, \txid_1', \T_1 \cup \{\txid_1\}}\\
%%~\\
%%\updateKV(\hh_2, \vi_1, \txid_1, \opset_1)(\ke) \stackrel{\eqref{eq:updatekv.swap.rd12}}{=} 
%%\updateKV(\hh, \vi_2, \txid_2, \opset_2)(\ke)\rmto{\vi_1(\ke)}{(\val_1, \txid_1', \T_1 \cup \{\txid_1\})} = \\
%%\hh(\ke)\rmto{\vi_1(\ke)}{(\val_1, \txid_1', \T_1 \cup \{\txid_1\})}
%%\end{array}
%%\]
%%\item $(\otR, \ke, \_) \in \opset_2$, and $\forall \val.\;(\otW,\ke,\val) \notin \opset_2)$. 
%%Let $(\val_2, \txid_2', \T_2)$. We need to distinguish between two cases, according to whether 
%%$\vi_1(\ke) = \vi_2(\ke)$ or $\vi_1(\ke) \neq \vi_2(\ke)$. 
%%\begin{enumerate}
%%\item if $\vi_1(\ke) = \vi_2(\ke)$,  recall that by Equation \eqref{eq:updatekv.swap.rd11} $\hh_1(\ke, \vi_2) = 
%%\hh_1(\ke, \vi_1) = (\val_1, \txid_1', \T_1 \cup \{\txid_1\})$. Recall also that $\hh(\ke, \vi_2) = \hh(\ke, \vi_1) = 
%%(\val_1, \txid_1', \T_1)$. 
%%By \cref{lem:updatekv.explicit}\eqref{item:updatekv.explicit.rd} we have the following: 
%%\begin{align}
%%\hh_2(\ke) = \updateKV(\hh, \vi_2, \txid_2, \opset_2)(\ke) = \hh(\ke)\rmto{(\vi_2(\ke)}{(\val_1, \txid_1', \T_1 \cup \{\txid_2\})}
%%\label{eq:updatekv.swap.rd1.rd21.eq}\\
%%\nonumber\\
%%\nonumber \updateKV(\hh_1, \vi_2, \txid_2, \opset_2)(\ke) = \hh_1(\ke)\rmto{(\vi_2(\ke)}{(\val_1, \txid_1', \T_1 \cup \{\txid_1\} \cup \{\txid_2\})} = \\
%%\updateKV(\hh, \vi_1, \txid_1, \opset_1)(\ke)\rmto{(\vi_2(\ke)}{(\val_1,\ txid_1', \T_1 \cup \{\txid_1, \txid_2\})}
%%\label{eq:updatekv.swap.rd1.rd22.eq}
%%\end{align}
%%In this case we have that
%%\[
%%\begin{lr}
%%\updateKV(\hh_1, \vi_2, \txid_2, \opset_2)(\ke) \stackrel{\eqref{eq:updatekv.swap.rd1.rd22}}{=} 
%%\updateKV(\hh, \vi_1, \txid_1,\opset_1)(\ke)\rmto{(\vi_2(\ke)}{(\val_1, \txid_1', \T_1 \cup \{\txid_1, \txid_2\})} &\stackrel{\eqref{eq:updatekv.swap.rd11}}{=}\\
%%(\hh(\ke)\rmto{\vi_1(\ke)}{(\val_1, \txid_1', \T_1 \cup \{\txid_1\})})\rmto{(\vi_2(\ke)}{(\val_1, \txid_1', \T_1 \cup \{\txid_1, \txid_2\})} &=\\
%%\hh(\ke)|rmto{(\vi_2(\ke)}{(\val_1, \txid_1', \T_1 \cup \{\txid_1, \txid_2\})}\\
%%&\\
%%\updateKV(\hh_2, \vi_1, \txid_1,\ opset_1)(\ke) 
%%\end{lr}
%%\]
%%\end{enumerate}
%%
%%be such that $\hh_1(\vi_2(\ke)) = (\val_2, \txid_2', \T_2)$. 
%%By \cref{lem:updatekv.explicit}\eqref{item:updatekv.explicit.rd} we have the following: 
%%
%%We distinguish between two cases, according to whether $\vi_1(\ke) = \vi_2(\ke)$ or $\vi_1(\ke) \neq \vi_2(\ke)$.
%%
%%\end{itemize}
%\end{itemize}
%\end{proof}
%%
%%\begin{proof}
%%By induction on $\opset_1$. 
%%\begin{itemize}
%%\item Base case: $\opset_1 = \emptyset$. Then we have that 
%%\[
%%\begin{array}{lr}
%%\mathtt{let } \hh_1 = \updateKV(\hh, \vi_1, \txid_1, \emptyset) \mathtt{ in } \updateKV(\hh_1, \vi_2, \txid_2, \opset_2) &= \\
%%\mathtt{let } \hh_1 = \hh \mathtt{ in } \updateKV(\hh_1, \vi_2, \txid_2, \opset_2) &= \\
%%\updateKV(\hh, \vi_2, \txid_2, \opset_2)
%%\end{array}
%%\]
%%Similarly, we have that 
%%\[
%%\begin{array}{lr}
%%\mathtt{let } \hh_2 = \updateKV(\hh, \vi_2, \txid_2, \opset_2) \mathtt{ in } \updateKV(\hh_2, \vi_1, \txid_1, \opset_1) &=\\
%%\mathtt{let } \hh_2 = \updateKV(\hh, \vi_2, \txid_2, \opset_2) \mathtt{ in } \hh_2 &=\\
%%\updateKV(\hh, \vi_2, \txid_2, \opset_2)
%%\end{array}
%%\]
%%\item Let $\opset_1 = \opset_1' \uplus \{(\otR, \ke_1, \val_1)\}$, and assume that for all $\hh'$,
%%\begin{equation}
%%\label{eq:updatekv.comm.rd}
%%\begin{array}{l}
%%\mathtt{let } \hh_1' = \updateKV(\hh', \vi_1, \txid_1, \opset'_1) \mathtt{ in } \updateKV(\hh_1, \vi_2, \txid_2, \opset_2) = \\
%%\mathtt{let } \hh_2 = \updateKV(\hh', \vi_2, \txid_2, \opset_2) \mathtt{ in } \updateKV(\hh_2, \vi_1, \txid_1, \opset'_1).
%%\end{array}
%%\end{equation}
%%We perform an inner induction on the structure of $\opset_2$. 
%%\begin{itemize}
%%\item Base case: $\opset_2 = \emptyset$. 
%%In this case we have that 
%%\[
%%\begin{array}{l}
%%\mathtt{let } \hh_1 = \updateKV(\hh, \vi_1, \txid_1, \opset_1) \mathtt{ in } \updateKV(\hh_1, \vi_2, \txid_2, \emptyset) = \\
%%\mathtt{let } \hh_1 = \updateKV(\hh, \vi_1, \txid_1, \opset_1) \mathtt{ in } \hh_1 = \\
%%\updateKV(\hh, \vi_1, \txid_1, \opset_1)
%%\end{array}
%%\]
%%and 
%%\[
%%\begin{array}{l}
%%\mathtt{let } \hh_2 = \updateKV(\hh, \vi_2, \txid_2, \emptyset) \mathtt{ in } \updateKV(\hh_2, \vi_1, \txid_1, \opset_1) = \\
%%\mathtt{let } \hh_2 = \hh \mathtt{ in } \updateKV(\hh, \vi_1, \txid_1, \opset_1) = \\
%%\updateKV(\hh, \vi_1, \txid_1, \opset_1).
%%\end{array}
%%\]
%%There is nothing left to prove in this case.
%%\item Suppose that $\opset_2 = \opset_2' \uplus \{(\otR, \ke_2, \val_2)\}$.
%%\end{itemize}
%%
%%Let $\hh_1 = \updateKV(\hh, \vi_1, \txid_1, \opset_1)$. Let also $(\val, \txid', \T) = \hh(\ke, \vi_1)$, 
%%and $V_{\ke} = \hh_1(\ke)$. By definition, we have that 
%%%\[
%%%\hh_1 = \updateKV(\hh\rmto{\ke}{\V_{ke}\rmto{\vi_1(\ke)}{(\val, \txid', \T \cup \{ \txid_1\}}}, \vi_1, \txid_1, \opset'_1).
%%%\]
%%
%%\end{itemize}
%%\end{proof}

\subsection{Proof of \cref{prop:mono-et} }
\label{sec:mono-et}
It is sufficient to prove that \(\ET_1 \subseteq \ET_2 \implies \Confs(\ET_1) \subseteq\ Confs(\ET_2) \).
We prove it by induction on the length of the traces, \( n \).

\caseB{n = 0}
We have \( \conf_0 \in \Confs(\ET_1) \) and \( \conf_0 \in \Confs(\ET_2)\).
\caseI(n = i + 1)
Suppose identical traces of \( \ET_1 \) and \( \ET_2 \) respectively with length \( i \).
Let the final configuration be \( \conf_i = ( \mkvs_i, \viewFun_i ) \).
If the next step is a view shift or a step with empty fingerprint, it trivially holds.
If the next step is a step by a client \( \cl \) with fingerprint \( \f \),
we have \( \ET_1 \vdash \mkvs_i, \viewFun_i(\cl) \csat \f : vi' \).
The next configuration from \( \ET_1 \) is \( \conf_{i+1} = (\updateKV{ \mkvs_i, \viewFun_i(\cl), \f, \txid_\cl}) \).
Since \( \ET_1 \subseteq \ET_2 \), so \( \ET_1 \vdash \mkvs_i, \viewFun_i(\cl) \csat \f : vi' \) holds.
It is possible for \( \ET_2 \) to have the exactly same next configuration \( \conf_{n+1}\).

\subsection{Proof of \cref{prop:et.normalform}}
\label{sec:normal-form-exist}
\ac{Note to self - Results needed: (i) you can merge two consecutive view shifts from the same client into a single action. (ii) 
you can remove commit of empty-fingerprints from a sequence of reductions - not true for consistency models 
without monotonic reads. (iii) You can push a view 
shift of client $\cl$ - i.e. an action of the form $(\cl, \varepsilon)$ to the right, as long as the action that immediately precedes it has not the form 
$(\cl, \_)$. (Note that you cannot move a view-shift to the right of another view-shift from the same 
client, but you can merge them together and keep pushing the resulting view-shift to the left.}
Throughout this section, we assume that the execution test $\ET$ is fixed.

\begin{lemma}[Absorption]
\label{lem:et.absorb}
If $\conf \xrightarrowtriangle{(\cl, \varepsilon)}_{\ET} \conf' \xrightarrowtriangle{(\cl, \varepsilon)} \conf''$, then 
$\conf \xrightarrowtriangle{(\cl, \varepsilon)}_{\ET} \conf''$.
\end{lemma}

\begin{proof}
Let $\conf = (\hh, \viewFun)$, $\conf' = (\hh', \viewFun')$, $\conf'' = (\hh', \viewFun'')$. 
By \cref{def:reductions} it must be the case that $\hh = \hh'$, and $\viewFun' = \viewFun\rmto{\cl}{\vi'}$ 
for some $\vi' : \vi \sqsubseteq \vi'$. It must also be the case that $\hh' = \hh''$, and $\viewFun'' = \viewFun'\rmto{\cl}{\vi''}$ 
for some $\vi'': \vi' \sqsubseteq \vi''$. Therefore we have that $\hh'' = \hh' = \hh$, and 
$\viewFun'' = \viewFun'\rmto{\cl}{\vi''} = (\viewFun\rmto{\cl}{\vi'})\rmto{\cl}{\vi''} = viewFun\rmto{\cl}{\vi''}$, 
and $\vi \sqsubseteq \vi''$. By \cref{def:reductions}, it follows that 
$\conf = (\hh, \viewFun) \xrightarrowtriangle{(\cl, \varepsilon)} (\hh'', \viewFun'') = \conf''$.
\end{proof}

\begin{lemma}
\label{lem:viewshift.rightmover}
Let $\conf \xrightarrowtriangle{(\cl, \varepsilon)}_{\ET} \conf_1 \xrightarrowtriangle{(\cl', \mu)}_{\ET} \conf'$ 
for some $\conf, \conf_1, \conf''$ and $\cl, \cl'$ such that $\cl' \neq \cl$. 
Then $\conf \xrightarrowtriangle{(\cl', \mu)}_{\ET} \conf_2 \xrightarrowtriangle{(\cl, \varepsilon)}_{\ET} \conf'$ 
\end{lemma}

\begin{proof}
We only consider the case where $\mu = \opset$ for some fingerprint $\opset$. The case where 
$\mu = \varepsilon$ is simpler to prove.
Let $\conf = (\hh, \viewFun)$, $\conf_1 = (\hh_1, \viewFun_1)$, $\conf' = (\hh', \viewFun')$. 
Let also $\vi = \viewFun(\cl)$.
By \cref{def:reductions} we have that $\hh_1 = \hh, \viewFun_1 = \viewFun\rmto{\cl}{\vi_1}$ for 
some $\vi_1: \vi_1 \sqsubseteq \vi_1$. Let $\vi' = \viewFun(\cl')$: then we have that $\viewFun_1(\cl') = 
\vi'$. Because $(\hh_1, \viewFun_1) \xrightarrowtriangle{(\cl', \opset)}_{\ET} (\hh', \viewFun')$, we have that 
$\ET \vdash \hh_1, \vi' \triangleright \opset : \vi''$, where $\vi'' = \viewFun'(\cl')$. Because $\hh_1 = \hh$, 
that means that $\ET \vdash \hh, \vi' \triangleright \opset: \vi''$: by \cref{def:reductions} it follows that 
$(\hh, \viewFun) \xrightarrowtriangle{(\cl', \opset)}_{\ET} (\hh', \viewFun\rmto{\cl'}{\vi''}) 
\xrightarrowtriangle{(\cl, \varepsilon)}_{\ET} (\hh', \viewFun\rmto{\cl'}{\vi''}\rmto{\cl}{\vi_1}) = 
(\hh', \viewFun\rmto{\cl}{\vi_1}\rmto{\cl'}{\vi''}) = (\hh', \viewFun_1\rmto{\cl'}{\vi''}) = 
(\hh', \viewFun')$, as we wanted to prove.
\end{proof}

\mypar{Proof of \cref{prop:et.normalform}}
Let $\hh \in \CMs(\ET)$. By definition, there exists a sequence of reductions 
\begin{equation}
\label{eq:normalform.sequence}
(\hh_{0}, \viewFun_{0}) \xrightarrowtriangle{(\cl_0, \mu_0)}_{\ET} \cdots \xrightarrowtriangle{(\cl_{n-1}, \mu_{n-1})}_{\ET} (\hh_n, \viewFun_{n})
\end{equation}
such that $\hh_{n} = \hh$. Given an index $i = 1,\cdots, n-1$, we say that the action $(\cl_{i}, \mu_{i})$ is \emph{in place} 
if, $\mu_{i} = \opset_{i}$ for some $\opset_{i}$, $\cl_{i-1} = \cl_{i}$, $\mu_{i-1} = \varepsilon$, and if $(\cl_{j}, \mu_{j}) = (\cl_{i}, \varepsilon)$, 
for some  $j = 0,\cdots, i-2$, then there exists $j': j < j' < i$ such that $(\cl_{j'}, \mu_{j'}) = (\cl_i, \opset_{j'})$. An action of the 
form $(\cl_{i}, \mu_{i})$ is \emph{out of place} if it is not in place. 

Given the sequence of reductions in \cref{eq:normalform.sequence}, we show the following: 
\begin{enumerate}
\item if the sequence has no action out of place, then there exists a sequence 
\[
(\hh'_{0}, \viewFun'_{0}) \xrightarrowtriangle{(\cl'_{0}, \mu'_{0})}_{\ET} \cdots \xrightarrowtriangle{(\cl'_{m-1}, \mu'_{m-1})}_{\ET} (\hh'_{m}, \viewFun'_{m})
\]
that is in normal form, and such that $\hh'_{m} = \hh_{n}$, and 
\item if the sequence has $h$ actions out of place, for some $h > 0$, then there exists a sequence 
\[
(\hh'_{0}, \viewFun'_{0}) \xrightarrowtriangle{(\cl'_{0}, \mu'_{0})}_{\ET} \cdots \xrightarrowtriangle{(\cl'_{m-1}, \mu'_{m-1})}_{\ET} (\hh'_{m}, \viewFun'_{m})
\]
that has $h-1$ actions out of place, and such that $\hh'_{m} = \hh_{n}$.
\end{enumerate}
Combining the two facts above, we obtain that if $\hh \in \CMs(\ET)$, then there exists a sequence of reductions in formal form whose final 
configuration is $(\hh, \_)$, as we wanted to prove.

\begin{enumerate}
\item Suppose that the sequence of reductions from \cref{eq:normalform.sequence} has no action out of place. 
Let $i=0,\cdots, n-1$, and consider the greatest index $i=0,\cdots, n-1$ such that  
$\mu_{i} = \varepsilon$, and either $i = n-1$, or 
$\forall \opset.\; (\cl_{i+1}, \mu_{i+1}) \neq (\cl_{i}, \opset)$. 
If such an index does not exist, then the sequence of transitions from \cref{eq:normalform.sequence} is in 
normal form, and there is nothing to prove. Otherwise, note that for any $j = i+1,\cdots, n-1$, 
$\forall \opset.\;(\cl_{j}, \mu_{j}) \neq (\cl_{i}, \opset)$. 

Suppose in fact that there existed 
an index $j = i+1,\cdots, n-1$ such that $(\cl_{j}, \mu_{j}) = (\cl_{i}, \opset_{j})$ for some 
$\opset_{j}$, and without loss of generality assume that $j$ is the smallest such index. This implies that 
there exists no index $j': i < j' < j$ such that $(\cl_{j'}, \mu_{j'}) = (\cl_{i}, \opset_{j'})$ for some 
$\opset_{j'}$. Also, it cannot be $j = i+1$, because we are assuming that $\forall \opset.\;(\cl_{i+1}, \mu_{i+1}) \neq 
(\cl_{i}, \opset)$.  We have that $j \geq i+2$; we also have that  $(\cl_{j}, \mu_{j}) = (\cl_{i}, \opset_{j})$, 
$(\cl_{i}, \mu_{i}) = (\cl_{i}, \varepsilon)$, $\forall j': i < j < j'.\forall \opset.\; (\cl_{j'}, \mu_{j'}) \neq (\cl_{i}, \opset)$. 
By definition, the action $(\cl_{j}, \mu_{j})$ is out of place, contradicting the assumption that the sequence of 
reduction of \cref{eq:normalform.sequence} has no actions out of place.

We have proved that $\forall j = i+1, \cdots, n-1.\;\forall \opset.\;(\cl_{j}, \mu_{j}) \neq (\cl_{i}, \opset)$. 
Also, because we are assuming that $\mu_{i}$ is the greatest index such that $\mu_{i} = \varepsilon$, 
and either $i= n-1$ or $\forall \opset.\;(\cl_{i+1},\mu_{i+1}) \neq (\cl_{i}, \opset)$, 
then $\forall j=i+1,\cdots, n-1\;\forall \mu.\;(\cl_{j}, \mu_{j}) \neq (\cl_{i}, \mu)$. 
Consider the transition 
\[
(\hh_{i}, \viewFun_{i}) \xrightarrowtriangle{(\cl_{i}, \mu_{i})}_{\ET} (\hh_{i+1}, \viewFun_{i+1}).
\]
Let $\vi = \viewFun_{i}(\cl)$. Because $\mu_{i} = \varepsilon$, then it must be the case that 
$\hh_{i} = \hh_{i+1}$, $\viewFun_{i+1} = \viewFun_{i}\rmto{\cl}{\vi'}$ for some $\vi' : \vi \sqsubseteq \vi'$. 
For any $j \geq i$, we have that $\cl_{j} \neq \cl_{i}$. We can replace the transition 
\[
(\hh_{j}, \viewFun_{j}) \xrightarrowtriangle{(\cl_{j}, \mu_{j})}_{\ET} (\hh_{j+1}, \viewFun_{j+1})
\]
with 
\[
(\hh_{j}, \viewFun_{j}\rmto{\cl_{i}}{\vi}) \xrightarrowtriangle{(\cl_{j}, \mu_{j})}_{\ET} (\hh_{j+1}, \viewFun_{j+1}\rmto{\cl_{i}}{\vi}.
\]
It follows that the sequence of transitions 
\[ 
(\hh_{0}, \viewFun_{0}) \xrightarrowtriangle{(\cl_{0}, \mu_{0})}_{\ET} \cdots \xrightarrowtriangle{(\cl_{i-1},\mu_{i-1})} 
(\hh_{i}, \viewFun_{i}) = (\hh_{i+1}, \viewFun_{i+1}\rmto{\cl_{i},\vi}) \xrightarrowtriangle{(\cl_{i+1}, \mu_{i+1})}_{\ET} \cdots 
\xrightarrowtriangle{(\cl_{n-1}, \mu_{n-1})}_{\ET} (\cl_{n}, \viewFun_{n}\rmto{\cl_{i}, \vi})
\]
Note that this sequence has one reduction less than the original sequence from \eqref{eq:normalform.sequence} (specifically, 
the reduction $(\hh_{i}, \viewFun_{i}) \xrightarrowtriangle{(\cl_{i}, \mu_{i})} (\hh_{i+1}, \viewFun_{i+1})$ has 
been removed). We can repeat this procedure until the resulting sequence of reductions has no index $i=0,\cdots, n-1$ such that  
$\mu_{i} = \varepsilon$, and either $i = n-1$, or 
$\forall \opset.\; (\cl_{i+1}, \mu_{i+1}) \neq (\cl_{i}, \opset)$. That is, the resulting sequence of reductions is in normal form, 
and its final configuration is $(\hh_{n}, \_)$.

\item Suppose that the sequence from \cref{eq:normalform.sequence} has $h$ actions out of place, 
where $h > 0$. Let $i$ be the smallest index such that $(\cl_{i}, \mu_{i})$ is out of place. 
This means that either $i = 0$, or $(\cl_{i-1}, \mu_{i-1}) \neq (\cl_{i}, \varepsilon)$, 
or there exists an index $j < i -1 $ such that $(\cl_{j}, \mu_{j}) = (\cl_{i}, \varepsilon)$ 
and, $\forall j': j < j' < i.\;\forall \opset.\;(\cl_{j'}, \mu_{j'}) \neq (\cl_{i}, \opset)$. 
Without loss of generality, we can assume that $i \neq 0$ and $(\cl_{i-1}, \mu_{i-} = (\cl_{i}, \varepsilon)$. 
This is because we can always transform the sequence of reductions of \cref{eq:normalform.sequence} by 
introducing a transition of the form $(\hh_{i}, \viewFun_{i}) \xrightarrowtriangle{(\cl_{i}, \varepsilon)}_{\ET}
(\hh_{i}, \viewFun_{i})$, leading to the sequence of reductions
\[
(\hh_{0}, \viewFun_{0}) \xrightarrowtriangle{(\cl_{0}, \mu_{0})}_{\ET} \cdots \xrightarrowtriangle{(\cl_{i-1}, \mu_{i-1})}_{\ET}
(\hh_{i}, \viewFun_{i}) \xrightarrowtriangle{(\cl_{i}, \varepsilon)}_{\ET} (\hh_{i}, \viewFun_{i}) \xrightarrowtriangle{(\cl_{i+1}, \mu_{i+1})}_{\ET} 
\cdots \xrightarrowtriangle{(\cl_{n-1}, \mu_{n-1})}_{\ET} (\hh_{n}, \viewFun_{n}).
\]

Therefore, it must be the case that there exists an index $j < i-1$ such that $(\cl_{j}, \mu_{j}) = (\cl_{i}, \varepsilon)$, 
and $\forall j': j< j' < i.\;\forall \opset.\;(\cl_{j'}, \mu_{j'}) \neq (\cl_{i}, \opset)$. Let then $j$ be the smallest such index. 
Let $d = (i-1)-j$ be the number of reductions that separate the configuration $(\hh_{j}, \mu_{j})$ from 
$(\hh_{i-1}, \mu_{i-1})$ in \cref{eq:normalform.sequence}. Note that it must be the case that $d > 0$. We show that we can 
construct a sequence of reductions where the distance between these two configurations is reduced to $0$: 
a consequence of this fact is such a sequence of reductions would have exactly $h-1$ actions out of place.
Consider the following fragment in the sequence of reductions from \cref{eq:normalform.sequence}:
\[
(\hh_{j}, \viewFun_{j}) \xrightarrowtriangle{(\cl_{j}, \mu_{j})}_{\ET} (\hh_{j+1}, \viewFun_{j+1}) 
\xrightarrowtriangle{(\cl_{j+1}, \mu_{j+1})}_{\ET} (\hh_{j+2}, \viewFun_{j+2}).
\]
We have two possible cases: 
\begin{itemize}
\item $\cl_{j+1} \neq \cl_{j}$. In this case we can apply \cref{lem:viewshift.rightmover} and infer the sequence of 
reductions 
\[
(\hh_{j}, \viewFun_{j}) \xrightarrowtriangle{(\cl_{j+1}, \mu_{j+1}}_{\ET} (\hh_{j+1}', \viewFun_{j+1}') 
\xrightarrowtriangle{(\cl_{j}, \mu_{j})}_{\ET} (\hh_{j+1}, \viewFun_{j+1}).
\]
which leads to the whole sequence of reductions 
\[
(\hh_{0}, \viewFun_{0}){(\cl_{0}, \mu_{0})}_{\ET} \cdots 
\xrightarrowtriangle{(\cl_{j-1}, \mu_{j-1})}_{\ET} (\cl_{j}, \mu_{j}) \xrightarrowtriangle{(\cl_{j+1}, \mu_{j+1})}_{\ET} 
(\hh'_{j+1}, \viewFun'_{j+1}) \xrightarrowtriangle{(\cl_{j}, \mu_{j})}_{\ET} (\hh_{j+1}, \viewFun_{j+1}) 
\xrightarrowtriangle{(\cl_{j+2}, \mu_{j+2})}_{\ET} \cdots \xrightarrowtriangle{(\cl_{n-1}, \mu_{n-1})} \hh_{n}, \viewFun_{n}.
\]
\item $\cl_{j+1} = \cl_{j}$. In this case we can apply \cref{lem:et.absorb} and infer the reduction 
\[
(\hh_{j}, \viewFun_{j}) \xrightarrowtriangle{(\cl_{j}, \varepsilon)}_{\ET} (\hh_{j+2}, \viewFun_{j+2}),
\]
which leads to the sequence of reductions 
\[
(\hh_{0}, \viewFun_{0}){(\cl_{0}, \mu_{0})}_{\ET} \cdots 
\xrightarrow{(\cl_{j-1}, \mu_{j-1})}_{\ET} (\cl_{j}, \mu_{j}) \xrightarrowtriangle{(\cl_{j}, \varepsilon)}_{\ET} 
(\hh_{j+2}, \viewFun_{j+2}) \xrightarrowtriangle{(\cl_{j+2}, \mu_{j+2})}_{\ET} \cdots 
\xrightarrowtriangle{(\cl_{n-1}, \mu_{n-1})}_{\ET} (\hh_{n}, \viewFun_{n}).
\]
\end{itemize}
In both cases, in the resulting sequence of reductions the number of reductions that separate 
the configuration $(\hh_{j}, \viewFun_{j})$ from $(\hh_{i-1}, \viewFun_{i-1})$ is strictly 
less than $d$. We can repeating applying the procedure outlined above until there are 
no reductions that separate the configuration $(\hh_{j}, \viewFun_{j})$ from 
$(\hh_{i}, \viewFun_{i})$.
\end{enumerate}
\ac{This was more of a proof sketch, rather than a real proof. For the moment it will suffice, though 
I will need to go back at it when all the other results are sorted.}
