\subsection{Serialisability}
\emph{Serialisability} is  the strongest consistency model that we consider. 
Informally, under serialisability transactions appear in a sequential order. 
Consider the following program know as \emph{write skew},
\[
\begin{session}
\prog_5 \equiv
\begin{array}{@{}c || c@{}}
\begin{transaction}
\pderef{\pvar{a}}{\vy};\\
\pifs{\pvar{a} = 0};\\
    \quad \pmutate{\vx}{1};\\
    \quad \passign{\retvar}{\sadface};
\pife
\end{transaction}
&
\begin{transaction}
\pderef{\pvar{a}}{\vx};\\
\pifs{\pvar{a} = 0};\\
\quad \pmutate{\vy}{1};\\
\quad \passign{\retvar}{\sadface};
\pife
\end{transaction}
\end{array}
\end{session}
\]


\begin{figure}[!t]
\hrule
\begin{center}
\begin{tabular}{@{}c c c@{}}
\begin{halfsubfig}
\begin{centertikz}
\begin{pgfonlayer}{foreground}

%Location x
\node(locx) {$\ke_{\vx} \mapsto$};

\matrix(versionx) [version list] 
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ \\ 
    {a} & $\emptyset$ \\
};  
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{0};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_\vy \mapsto$};
\matrix(versiony) [version list] 
    at ([xshift=\tikzkvspace]locy.east) {
    {a} & $\txid_0$ \\
    {a} & $\emptyset$ \\
};
\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{0};

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
([xshift=-3pt, yshift=20pt]locx-v0.north east) node (tid1start) {} -- 
([xshift=-3pt, yshift=-5pt]locy-v0.south east);
 
\path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\thid_1$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
([xshift=-16pt, yshift=5pt]locx-v0.north east) node (tid2start) {}-- 
([xshift=-16pt, yshift=-5pt]locy-v0.south east) node {};
 
\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\thid_2$};

\end{pgfonlayer}
\end{centertikz}
\caption{Initial state}
\label{fig:ser-init}
\end{halfsubfig}
&
\begin{halfsubfig}
\begin{centertikz}
\begin{pgfonlayer}{foreground}

%Location x
\node(locx) {$\ke_{\vx} \mapsto$};

\matrix(versionx) [version list] 
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\txid_1$\\
    {a} & $\emptyset$ & {a} & $\emptyset$ \\
};  
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{0};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{1};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_\vy \mapsto$};
\matrix(versiony) [version list] 
    at ([xshift=\tikzkvspace]locy.east) {
    {a} & $\txid_0$ \\
    {a} & $\Set{\txid_1}$ \\
};
\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{0};

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
([xshift=-3pt, yshift=20pt]locx-v1.north east) node (tid1start) {} -- 
([xshift=-3pt, yshift=-5pt]locx-v1.south east) --
([xshift=-3pt, yshift=5pt]locy-v0.north east) -- 
([xshift=-3pt, yshift=-5pt]locy-v0.south east);

\path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\thid_1$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
([xshift=-16pt, yshift=5pt]locx-v0.north east) node (tid2start) {}-- 
([xshift=-16pt, yshift=-5pt]locy-v0.south east) node {};
 
\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\thid_2$};

\end{pgfonlayer}
\end{centertikz}
\caption{after \( \txid_1 \)}
\label{fig:ser-after-tx1}
\end{halfsubfig}
&
\begin{halfsubfig}
\begin{centertikz}
\begin{pgfonlayer}{foreground}

%Location x
\node(locx) {$\ke_{\vx} \mapsto$};

\matrix(versionx) [version list] 
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\txid_1$\\
    {a} & $\Set{\txid_2}$ & {a} & $\emptyset$ \\
};  
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{0};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{1};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_\vy \mapsto$};
\matrix(versiony) [version list] 
    at ([xshift=\tikzkvspace]locy.east) {
    {a} & $\txid_0$ & {a} & $\tsid_2$ \\
    {a} & $\Set{\txid_1}$ & {a} & $\emptyset$\\
};
\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{0};
\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{1};

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
([xshift=-3pt, yshift=20pt]locx-v1.north east) node (tid1start) {} -- 
([xshift=-3pt, yshift=-5pt]locx-v1.south east) --
([xshift=-3pt, yshift=5pt]locy-v0.north east) -- 
([xshift=-3pt, yshift=-5pt]locy-v0.south east);

\path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\thid_1$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
([xshift=-16pt, yshift=5pt]locx-v1.north east) node (tid2start) {}-- 
([xshift=-16pt, yshift=-5pt]locy-v1.south east) node {};
 
\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\thid_2$};

\end{pgfonlayer}
\end{centertikz}
\caption{Both \( \txid_1 \) and \( \txid_2 \) returning \(\sadface\)}
\label{fig:ser-sadface}
\end{halfsubfig}
\\
\begin{halfsubfig}
\begin{centertikz}
\begin{pgfonlayer}{foreground}

%Location x
\node(locx) {$\ke_{\vx} \mapsto$};

\matrix(versionx) [version list] 
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\txid_1$\\
    {a} & $\emptyset$ & {a} & $\emptyset$ \\
};  
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{0};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{1};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_\vy \mapsto$};
\matrix(versiony) [version list] 
    at ([xshift=\tikzkvspace]locy.east) {
    {a} & $\txid_0$ \\
    {a} & $\Set{\txid_1}$ \\
};
\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{0};

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
([xshift=-3pt, yshift=20pt]locx-v1.north east) node (tid1start) {} -- 
([xshift=-3pt, yshift=-5pt]locx-v1.south east) --
([xshift=-3pt, yshift=5pt]locy-v0.north east) -- 
([xshift=-3pt, yshift=-5pt]locy-v0.south east);

\path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\thid_1$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
([xshift=-16pt, yshift=5pt]locx-v1.north east) node (tid2start) {}-- 
([xshift=-16pt, yshift=-3pt]locx-v1.south east) --
([xshift=-16pt, yshift=7pt]locy-v0.north east) -- 
([xshift=-16pt, yshift=-5pt]locy-v0.south east) node {};

\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\thid_2$};

\end{pgfonlayer}
\end{centertikz}
\caption{\( \cl_2 \) updating the view when executing \( \txid_2\)}
\label{fig:ser-update-view}
\end{halfsubfig}
&
\begin{halfsubfig}
\begin{centertikz}
\begin{pgfonlayer}{foreground}

%Location x
\node(locx) {$\ke_{\vx} \mapsto$};

\matrix(versionx) [version list] 
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\txid_1$\\
    {a} & $\emptyset$ & {a} & $\Set{\txid_2}$ \\
};  
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{0};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{1};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_\vy \mapsto$};
\matrix(versiony) [version list] 
    at ([xshift=\tikzkvspace]locy.east) {
    {a} & $\txid_0$ \\
    {a} & $\Set{\txid_1}$ \\
};
\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{0};

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
([xshift=-3pt, yshift=20pt]locx-v1.north east) node (tid1start) {} -- 
([xshift=-3pt, yshift=-5pt]locx-v1.south east) --
([xshift=-3pt, yshift=5pt]locy-v0.north east) -- 
([xshift=-3pt, yshift=-5pt]locy-v0.south east);

\path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\thid_1$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
([xshift=-16pt, yshift=5pt]locx-v1.north east) node (tid2start) {}-- 
([xshift=-16pt, yshift=-3pt]locx-v1.south east) --
([xshift=-16pt, yshift=7pt]locy-v0.north east) -- 
([xshift=-16pt, yshift=-5pt]locy-v0.south east) node {};
 
\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\thid_2$};

\end{pgfonlayer}
\end{centertikz}
\caption{After \( \txid_2\)}
\label{fig:ser-after-tx2}
\end{halfsubfig}
\end{tabular}
\end{center}
\hrule
\caption{Graphical representation of configurations obtained by executing $\prog_5$.}
\label{fig:ser.exec}
\end{figure}

If we execute the program $\prog_5$ under any of the consistency model presented so far, it is possible to infer an execution in which both clients $\thid_1$ and $\thid_2$ return $\sadface$.
First, client $\thid_1$ executes \( \txid_1 \) in the configuration shown in \cref{fig:ser-init}.
The snapshot under which the transaction is executed is given by $\Set{\ke_\vx \mapsto 0, \ke_\vy \mapsto 0}$, hence the transaction \( \txid_1 \) return \( \sadface \) (\cref{fig:ser-after-tx1}). 
Next, client $\thid_2$ executes transaction \( \txid_2 \) in the initial view. 
The snapshot under which the transaction is executed is again $\Set{\ke_\vx \mapsto 0, \ke_\vy \mapsto 0}$.
After the transaction has been executed, it also returns  ${\sadface}$ (\cref{fig:ser-sadface}). 
This is called \emph{write skew anomaly}.

To avoid the \emph{write skew} anomaly, it suffices to ensure that, prior to executing a transaction, the view of a thread is always up-to-date for all keys. 
\begin{definition}[Serialisibility]
The \emph{serialisibility} requires a transaction starts with a view that is up-to-date for all keys,
\[
\begin{rclarray}
(\hh, \vi) \csat[\mathsf{SER}] \opset : \vi' & \defeq & \fora{\addr \in \dom(\hh)} \vi(\addr) = \left| \hh(\addr) \right | - 1
\end{rclarray}
\]
\end{definition}

Consider again the program $\prog_5$, this time to be executed under $\mathsf{SER}$. 
The client \( \cl_2 \) cannot execute \( \txid_2 \) under the view shown in \cref{fig:ser-after-tx1}.
This is because such a view does not point to the most up-to-date version for key $\ke_\vx$. 
Instead, before executing its transaction $\thid_2$, updates its view to point to the most up-to-date version of each key (\cref{fig:ser-update-view}). 
Thus, thread $\thid_2$ will execute its transaction using the snapshot $\Set{\ke_\vx \mapsto 1, \ke_\vy \mapsto 0}$, and in this case it will not return \( \sadface \).
The final configuration is given in \cref{fig:ser-after-tx2}.

\ac{Contents: Read Atomic, Causal Consistency, Update Atomic, Consistent Prefix, Parallel Snapshot Isolation, Snapshot Isolation, 
Serializability. Well-formedness constraint to be placed on consistency models: progress must always be possible - i.e. it is 
always possible to execute a transaction if the view of all threads are up-to-date.}  
