\begin{defn}[Serialisability]
The \emph{serialisability} requires  a transaction starts with a view that is up-to-date for all addresses,
\[
\begin{rclarray}
(\hh, \vi) \csat[\mathsf{SER}] \opset : \vi' & \defeq & \fora{\addr \in \dom(\hh)} \vi(\addr) = \left| \hh(\addr) \right|
\end{rclarray}
\]
\sx{
$(\hh, V) \triangleright_{\mathsf{SER}} \mathcal{O} : V'$ iff, for any location $[\loc_x]$, 
$V([\loc_x]) = \lvert \hh([\loc_x]) \rvert -1$. 
}
\end{defn}

Consider again the program $\prog_5$, this time to be executed under $\mathsf{SER}$. 
Similar as for $\mathsf{SI}$, after thread $\thid_1$ has executed its transaction, 
we end up with the variable $\retvar$ of such a thread to be set to value ${\Large \frownie{}}$, 
and with the configuration of Figure \ref{fig:ser.exec}(b). However, at this point we can 
not execute the transaction of thread $\thid_2$ without updating his view beforehand. 
This is because such a view does not point to the most up-to-date version for location 
$[\loc_x]$. Instead, before executing its transaction $\thid_2$, updates its view to 
point to the most up-to-date version of each location, Figure \ref{fig:ser.exec}(d). 
Thus, thread $\thid_2$ will execute its transaction using the snapshot $[[\loc_x] \mapsto 1, [\loc_y] \mapsto 0]$. 
A consequence of this fact is that the thread-local variable $\retvar$ of $\thid_2$ will not be 
set to ${\Large \frownie{}}$, and no new version for location $[\loc_y]$ will be created 
by the execution of the transaction. The final configuration is given in Figure \ref{fig:ser.exec}(e).

\ac{Contents: Read Atomic, Causal Consistency, Update Atomic, Consistent Prefix, Parallel Snapshot Isolation, Snapshot Isolation, 
Serializability. Well-formedness constraint to be placed on consistency models: progress must always be possible - i.e. it is 
always possible to execute a transaction if the view of all threads are up-to-date.}  
