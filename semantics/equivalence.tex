\section{Correctness of the Specifications.}
It remains to prove that our specifications given using execution tests 
capture the intended consistency models. 
In this section we relate the consistency models induced by execution tests with 
the axiomatic specifications of consistency models given in terms of abstract executions 
\cite{framework-concur,laws}. 

Abstract executions are a framework originally introduced in \cite{ev-transactions} 
to capture the run-time behaviour of clients interacting with a database. In this 
formalism, two relations between transactions are introduced: the first one, \emph{visibility}, 
establishes when a transaction observes the effects of another transaction; the 
second one,  \emph{arbitration}, is used to determine the value of a key $\ke$ read by 
a transaction, in the case that it observes multiple updates to $\ke$ performed by different 
transactions. 
\begin{definition}
\label{def:absexec}
An abstract execution is a triple $\aexec = (\TtoOp{T}, \VIS, \AR)$, where 
\begin{itemize}
\item $\TtoOp{T}: (\TxID \setminus \{\txid_0\}) \parfun \powerset{\Ops}$ is a partial, 
finite function mapping transaction identifiers to the set of operations that they perform,
\item $\VIS \subseteq \dom(\TtoOp{T}) \times \dom(\TtoOp{T})$ is an irreflexive relation, 
called \emph{visibility}, 
\item $\AR \subseteq \dom(\TtoOp{T}) \times \dom(\TtoOp{T})$ is a strict, total order 
such that $\VIS \subseteq \AR$, and whenever $\txid_{\cl}^{n} \xrightarrow{\AR} 
\txid_{\cl}^{m}$, then $n < m$.
\end{itemize} 
\end{definition}
Given an abstract execution $\aexec = (\TtoOp{T}, \VIS, \AR)$, we let 
$\TtoOp{T}_{\aexec} = \TtoOp{T}$, $\T_{\aexec} = \dom(\TtoOp{T})$, $\VIS_{\aexec} = \VIS$ 
and $\AR_{\aexec} = \AR$. We also let $\PO_{\aexec} = \{(\txid_{\cl}^{n}, \txid_{\cl}^{m} \mid \cl \in \Clients 
\wedge  \txid_{\cl}^{n} \in \T_{\aexec} \wedge \txid_{\cl}^{m} \in \T_{\aexec} \wedge n < m\}$. 
We also use the notation $\_ \in_{\aexec} \txid$ for $(\otR, \ke, \val) \in \TtoOp{T}_{\aexec}(\txid)$.
An abstract execution satisfies the \emph{last write win} policy if, whenever $(\otR, \ke, \val) \in_{\aexec} \txid$, 
then either $\val = \val_0$ or $(\otW, \ke, \val) \in_{\aexec} \txid'$, where $\txid' = 
\max_{\AR_{\aexec}}(\VIS_{\aexec}^{-1}(\txid))$.

In this framework, specifications of consistency models are given by placing \emph{axioms} that the 
arbitration and visibility relations of abstract executions must satisfy. Such axioms usually 
have the form $\mathscr{F}(\aexec) \subseteq \VIS_{\aexec}$, 
where $\mathscr{F}$ maps abstract executions into relations between transactions \cite{laws}. 
For example, let $[(\otW, \ke, \_)]_{\aexec} = \{(\txid, \txid) \mid (\otW, \ke, \_) \in \TtoOp{T}(\T_{\aexec}(\txid) \}$. 
Then (strong session) snapshot isolation can be described as the set of abstract executions $\aexec$ that 
satisfy the axioms $\PO_{\aexec} \subseteq \VIS_{\aexec}$, $\AR_{\aexec} ; \VIS_{\aexec} \subseteq \VIS_{\aexec}$, 
and for each $\ke$, $[(\otW, \ke, \_)]_{\aexec} ; \AR_{\aexec} ; [(\otW, \ke, \_)]_{\aexec} \subseteq \VIS_{\aexec}$. 
Actual specifications of consistency models using this formalism are outside the scope of this article, and we 
refer the reader to \cite{laws} for a comprehensive list of axioms for specifying different consistency models.

In the same way dependency graphs are isomorphic to kv-stores, abstract executions that satisfy 
the last write win resolution policy are isomorphic 
to \emph{kv-traces}. These are sequences of the form 
\[ 
\conf_0 \xrightarrowtriangle{\_}_{\ET_{\bot}} \cdots \xrightarrowtriangle{\_}_{\ET_{\bot}} \conf_n.
\]
Let then $\aexec$ be an abstract execution that satisfies the last write win policy. We now show 
how to construct the kv-trace $\KVtrace(\aexec)$.
\begin{definition}
Let $\aexec$ be an abstract execution, and let $\txid^{0} \xrightarrowtriangle{\AR_{\aexec}} \txid^{n-1} \xrightarrow{\AR_{\aexec}} \txid^{n}$. 
We recursively define $\KVtrace(\aexec, m)$ for all $m \leq n$, and we let $\KVtrace(\aexec) = \KVtrace(\aexec, n)$. 
For $m = 0$, we let $\KVtrace(\aexec, m) = \hh_0$, where $\hh_0 = \lambda \ke. (\val_0, \txid_0, \emptyset)$. 
Assuming that $\KVtrace(\aexec, m) = \conf_0 \xrightarrowtriangle{(\cl^{0}, \vi^{0},\opset^{0})}_{\ET_{\bot}} \cdots \xrightarrowtriangle{
(\cl^{m-1}, \vi^{m-1}, \opset^{m-1})}_{\ET_{\bot}} \conf_{m}$ 
has been defined for some $m < n$, consider the set of transactions $\VIS^{-1}(\txid_{m})$. Let 
$\vi^{m} = \lambda \ke. \lvert \VIS^{-1}(\ke) \cap \{ \txid \mid (\otW, \ke, \_) \in_{\aexec} \txid \} \rvert$ 
{\color{red} basically I am counting the number of versions of that $\txid_{m}$ sees, for each $\ke$.}, 
and define $\hh_{m+1} = \updateKV(\hh_{m}, \vi, \txid, \opset)$. Finally, suppose that 
$\txid^{m} = \txid_{\cl}^{\_}$ for some $\cl$, and let $m: m < m' \leq n$ be the smallest 
index (if any) such that $\txid_{m'} = \txid_{\cl}^{\_}$. Define $\vi'_{m} = \lambda \ke. \lvert 
\VIS^{-1}(\txid_{m'}) \cap (\AR^{-1}(\txid_{m}) \cup \{\txid_m\}) \cap \{ \txid \mid (\otW, \ke, \_) \in_{\aexec} \txid \} \rvert$. 
If such an $m'$ does not exist, then let $\vi'_{m} = \lambda \ke. \lvert \hh_{m+1}(\ke) \rvert -1$. 
{\color{red} basically I select the final view after committing $\txid_{m}$ by looking at 
the versions of each $\ke$ that are already present in the kv-store at the moment 
$\txid_{m}$ committed, and which are going to be observed by the next transaction in the same session. If there 
are no future tranactions for the current session, just shift the view to the end, it's never going to be used again.} 
Then we let $\conf_{m+1} = \hh_{m+1}, \viewFun_{m}\rmto{\cl}{\vi'_{m}}$, and define 
\[
\KVtrace(\aexec, m) = \conf_0 \xrightarrowtriangle{(\cl^{0}, \vi^{0},\opset^{0})}_{\ET_{\bot}} \cdots \xrightarrowtriangle{
(\cl^{m-1}, \vi^{m-1}, \opset^{m-1})}_{\ET_{\bot}} \conf_{m} \xrightarrowtriangle{(\cl, \vi^{m}, \TtoOp(\txid_{m})} 
\conf^{m+1}.
\]
\end{definition}
