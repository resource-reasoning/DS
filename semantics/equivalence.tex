\section{Encoding into Abstract Executions}
It remains to prove that our specifications given using execution tests 
capture the intended consistency models. 
In this section we relate the consistency models induced by execution tests with 
the axiomatic specifications of consistency models given in terms of abstract executions 
\cite{framework-concur,laws}. 

Abstract executions are a framework originally introduced in \cite{ev-transactions} 
to capture the run-time behaviour of clients interacting with a database. In this 
formalism, two relations between transactions are introduced: the first one, \emph{visibility}, 
establishes when a transaction observes the effects of another transaction; the 
second one,  \emph{arbitration}, is used to determine the value of a key $\ke$ read by 
a transaction, in the case that it observes multiple updates to $\ke$ performed by different 
transactions. 
\begin{definition}
\label{def:absexec}
An abstract execution is a triple $\aexec = (\TtoOp{T}, \VIS, \AR)$, where 
\begin{itemize}
\item $\TtoOp{T}: (\TxID \setminus \{\txid_0\}) \parfun \powerset{\Ops}$ is a partial, 
finite function mapping transaction identifiers to the set of operations that they perform,
\item $\VIS \subseteq \dom(\TtoOp{T}) \times \dom(\TtoOp{T})$ is an irreflexive relation, 
called \emph{visibility}, 
\item $\AR \subseteq \dom(\TtoOp{T}) \times \dom(\TtoOp{T})$ is a strict, total order 
such that $\VIS \subseteq \AR$, and whenever $\txid_{\cl}^{n} \xrightarrow{\AR} 
\txid_{\cl}^{m}$, then $n < m$.
\end{itemize} 
\end{definition}
The set of abstract executions is denoted by $\aeset$.
Given an abstract execution $\aexec = (\TtoOp{T}, \VIS, \AR)$, we let 
$\TtoOp{T}_{\aexec} = \TtoOp{T}$, $\T_{\aexec} = \dom(\TtoOp{T})$, $\VIS_{\aexec} = \VIS$ 
and $\AR_{\aexec} = \AR$. We also let $\PO_{\aexec}(\cl) = \{(\txid_{\cl}^{n}, \txid_{\cl}^{m} \mid \cl \in \Clients 
\wedge  \txid_{\cl}^{n} \in \T_{\aexec} \wedge \txid_{\cl}^{m} \in \T_{\aexec} \wedge n < m\}$, and 
$\PO_{\aexec} = \bigcup_{\cl \in \Clients} \PO_{\aexec}(\cl)$.
We also use the notation $(\otR, \ke, \val) \in_{\aexec} \txid$ for $(\otR, \ke, \val) \in \TtoOp{T}_{\aexec}(\txid)$, 
and similarly for write operations. 
Given an abstract execution $\aexec$, a transaction $\txid \in \T_{\aexec}$, and a key $\ke$, 
we let $\visibleWrites_{\aexec}(\ke, \txid) = \{ \txid' \mid \txid' \xrightarrow{\VIS_{\aexec}} \txid \wedge 
(\otW, \ke, \_) \in_{\aexec} \txid'\}$.

Let $\aexec_1, \aexec_2 \in \aeset$, let $\T \subseteq \T_{\aexec_1} \cap \T_{\aexec_2}$: 
$\aexec_1$ and $\aexec_2$ \emph{agree} on $\T$ if, and only if 
\[
\forall \txid, \txid' \in \T.\;\TtoOp{T}_{\aexec_1}(\txid) = \TtoOp{T}_{\aexec_2}(\txid) \wedge 
((\txid \xrightarrow{\VIS_{\aexec_1}} \txid') \iff (\txid \xrightarrow{\VIS_{\aexec_2}} \txid'))
\wedge ((\txid \xrightarrow{\AR_{\aexec_1}} \txid') \iff (\txid \xrightarrow{\AR_{\aexec_2}} \txid')).
\]
 
\begin{definition}
\label{def:rp}
A resolution policy $\RP$ is a function $\RP: \aeset \times \powerset{\TxID} \rightarrow \powerset{\Snapshots}$ 
such that, for any $\aexec_1, \aexec_2$ that agree on a subset of transactions $\T$, then 
$\RP(\aexec_1, \T) = \RP(\aexec_2, \T)$.

An abstract execution $\aexec$ satisfied the execution policy $\RP$ if, 
\[
\forall \txid \in \T_{\aexec}. \exists \h \in \RP(\aexec, \VIS_{\aexec}^{-1}(\txid)) \mid \forall \ke \in \Keys.\forall \val \in \Val.\; (\otR, \ke, \val) \in_{\aexec} \txid 
\implies \h(\ke) = \val.
\]
\end{definition}

Throughout this report we will work mainly with the \emph{Last Write Wins} resolution policy, 
defined below. When discussing operational semantics for transactions and their adequacy, we will also 
introduce the \emph{Anarchic} resolution policy.

\begin{definition}
\label{def:lww}
For a given 
The Last Write Wins resolution policy $\RP_{\LWW}$ is defined by letting 
$\RP_{\LWW}(\aexec, \T) = \{h\}$, where
\[
h = \lambda \ke. \text{let } \T_{\ke} = ( \T \cap \{\txid \mid (\otW,\ke, \_) \in_{\aexec} \txid\})  \text{ in }
\begin{cases}
\val_{0} &\impliedby \T_{\ke} =  \emptyset\\
\val &\impliedby (\otW, \ke, \val) \in_{\aexec} \max_{\AR_{\aexec}} \T_{\ke}
\end{cases}
\]
\end{definition}
%
%An abstract execution satisfies the \emph{last write win} policy if, whenever $(\otR, \ke, \val) \in_{\aexec} \txid$, 
%then either $\val = \val_0$ or $(\otW, \ke, \val) \in_{\aexec} \txid'$, where $\txid' = 
%\max_{\AR_{\aexec}}(\VIS_{\aexec}^{-1}(\txid))$.

%\begin{definition}
%\label{def:anarchic}
%The Anarchic resolution policy $\RP_{\anarchic}$ is defined by letting $\RP_{\anarchic}(\aexec, \T) = \Snapshots$.
%\end{definition}
%\ac{I know that the symbol $\anarchic$ will change in the future. This is just a comment to let you know that, when it 
%will happen, I will be very sad.}

\subparagraph{Compatibility of kv-Stores and Abstract Executions.}
Throughout this section we focus on abstract executions that satisfy the 
resolution policy $\RP_{\LWW}$.
Such abstract executions can be converted into dependency graphs \cite{podc2016,laws}, 
which in turn are isomorphic to kv-stores (\cref{thm:kv2graph}). For the sake of completeness, 
we include the definition of the kv-store induced by an abstract execution below: 

\begin{definition}
\label{def:aexec2graph}
Let $\aexec$ be an abstract execution that satsifies the last write wins policy. 
The dependency graph $\graphof(\aexec) = (\TtoOp{T}_{\aexec}, \RF_{\aexec}, 
\VO_{\aexec}, \AD_{\aexec})$ is defined by letting
\begin{itemize}
\item $\txid \xrightarrow{\RF_{\aexec}(\ke)} \txid'$ if and only if 
$\txid = \max_{\AR_{\aexec}}(\visibleWrites_{\aexec}(\ke, \txid'))$, 
\item $\txid \xrightarrow{\VO_{\aexec}(\ke)} \txid'$ if and only 
$\txid, \txid' \in_{\aexec} (\WR\;\ke: \_)$ 
and $\txid \xrightarrow{\AR_{\aexec}} \txid'$,
\item $\txid \xrightarrow{\AD_{\aexec}(\ke)} \txid'$ if and only if either 
$(\otR, \ke, \_) \in_{\aexec} \txid, (\otW, \ke, \_) \in_{\aexec} \txid'$ and 
whenever $\txid'' \xrightarrow{\RF_{\aexec}(\ke)} \txid$, 
then $\txid'' \xrightarrow{\VO_{\aexec}(\ke)} \txid'$.
\end{itemize}
\end{definition}

On the other hand, 
abstract executions are endowed with more information than kv-stores, namely the total 
arbitration order of transactions: for our purposes, this may be considered to be the order in which transactions 
are executed by all clients.

Although abstract executions contain more information than kv-stores, 
we can define a notion of \emph{compatibility} between such data structures. Roughly speaking, 
this notion is based on the intuition that clients can make observations over kv-stores and abstract 
executions, in terms of snapshots. In kv-stores, 
observations are snapshots induced by views of clients over the kv-store. 
In abstract executions, observations correspond to the snapshots induced by the subsets of
of transactions of the abstract executions, according to some resolution policy (in this 
case, $\RP_{\LWW}$): this approach is analogous to the one used by 
opetation contexts in \cite{repldatatypes}. Thus a kv-store $\hh$ is 
compatible with an abstract execution $\aexec$ if any observation 
made on $\hh$ can be replicated by an observation made on 
$\aexec$, and vice-versa. 

\begin{definition}
Let $\aexec$ be an abstract execution, $\hh$ be a key-value store. 
We say that $\aexec$ is compatible with $\hh$, written 
$\aexec \compatible \hh$, if and only if there exists a  mapping 
$f: \powerset{\T_{\aexec}} \rightarrow \Views(\hh)$
such that  
\begin{itemize}
\item for any subset $\T \subseteq \T_{\aexec}$, then $\RP_{\LWW}(\aexec, \T) = \{\snapshot(\hh, f(\T))\}$; 
\item for any view $\vi \in \VIews(\hh)$, there exists a subset $\T \subseteq \T_{\aexec}$ 
such that $f(\T) = \vi$, and $\RP_{\LWW}(\aexec, \T) = \{\snapshot(\hh_{\aexec}, \vi)\}$.
\end{itemize}
\end{definition}


\subparagraph{Specification of Consistency Models via Abstract Executions.}
In the abstract execution framework, specifications of consistency models are given by placing \emph{axioms} that the 
arbitration and visibility relations of abstract executions must satisfy. Such axioms usually 
have the form $\mathscr{F}(\aexec) \subseteq \VIS_{\aexec}$, 
where $\mathscr{F}$ maps abstract executions into relations between transactions \cite{laws}. 
For example, let $[(\otW, \ke, \_)]_{\aexec} = \{(\txid, \txid) \mid (\otW, \ke, \_) \in \TtoOp{T}(\T_{\aexec}(\txid) \}$. 
Then (strong session) snapshot isolation can be described as the set of abstract executions $\aexec$ that 
satisfy the axioms $\PO_{\aexec} \subseteq \VIS_{\aexec}$, $\AR_{\aexec} ; \VIS_{\aexec} \subseteq \VIS_{\aexec}$, 
and for each $\ke$, $[(\otW, \ke, \_)]_{\aexec} ; \AR_{\aexec} ; [(\otW, \ke, \_)]_{\aexec} \subseteq \VIS_{\aexec}$. 
Actual specifications of consistency models using this formalism are outside the scope of this article, and we 
refer the reader to \cite{laws} for a comprehensive list of axioms for specifying different consistency models.

In the same way dependency graphs are isomorphic to kv-stores, abstract executions that satisfy 
the last write win resolution policy are isomorphic 
to \emph{kv-traces}. These are sequences of the form 
\[ 
\conf_0 \xrightarrowtriangle{\_}_{\ET_{\bot}} \cdots \xrightarrowtriangle{\_}_{\ET_{\bot}} \conf_n.
\]
Let then $\aexec$ be an abstract execution that satisfies the last write win policy. We now show 
how to construct the kv-trace $\KVtrace(\aexec)$.
\begin{definition}
Let $\aexec$ be an abstract execution, and let $\txid^{0} \xrightarrowtriangle{\AR_{\aexec}} \txid^{n-1} \xrightarrow{\AR_{\aexec}} \txid^{n}$. 
We recursively define $\KVtrace(\aexec, m)$ for all $m \leq n$, and we let $\KVtrace(\aexec) = \KVtrace(\aexec, n)$. 
For $m = 0$, we let $\KVtrace(\aexec, m) = \hh_0$, where $\hh_0 = \lambda \ke. (\val_0, \txid_0, \emptyset)$. 
Assuming that $\KVtrace(\aexec, m) = \conf_0 \xrightarrowtriangle{(\cl^{0}, \vi^{0},\opset^{0})}_{\ET_{\bot}} \cdots \xrightarrowtriangle{
(\cl^{m-1}, \vi^{m-1}, \opset^{m-1})}_{\ET_{\bot}} \conf_{m}$ 
has been defined for some $m < n$, consider the set of transactions $\VIS^{-1}(\txid_{m})$. Let 
$\vi^{m} = \lambda \ke. \lvert \VIS^{-1}(\ke) \cap \{ \txid \mid (\otW, \ke, \_) \in_{\aexec} \txid \} \rvert$ 
{\color{red} basically I am counting the number of versions of that $\txid_{m}$ sees, for each $\ke$.}, 
and define $\hh_{m+1} = \updateKV(\hh_{m}, \vi, \txid, \opset)$. Finally, suppose that 
$\txid^{m} = \txid_{\cl}^{\_}$ for some $\cl$, and let $m: m < m' \leq n$ be the smallest 
index (if any) such that $\txid_{m'} = \txid_{\cl}^{\_}$. Define $\vi'_{m} = \lambda \ke. \lvert 
\VIS^{-1}(\txid_{m'}) \cap (\AR^{-1}(\txid_{m}) \cup \{\txid_m\}) \cap \{ \txid \mid (\otW, \ke, \_) \in_{\aexec} \txid \} \rvert$. 
If such an $m'$ does not exist, then let $\vi'_{m} = \lambda \ke. \lvert \hh_{m+1}(\ke) \rvert -1$. 
{\color{red} basically I select the final view after committing $\txid_{m}$ by looking at 
the versions of each $\ke$ that are already present in the kv-store at the moment 
$\txid_{m}$ committed, and which are going to be observed by the next transaction in the same session. If there 
are no future tranactions for the current session, just shift the view to the end, it's never going to be used again.} 
Then we let $\conf_{m+1} = \hh_{m+1}, \viewFun_{m}\rmto{\cl}{\vi'_{m}}$, and define 
\[
\KVtrace(\aexec, m) = \conf_0 \xrightarrowtriangle{(\cl^{0}, \vi^{0},\opset^{0})}_{\ET_{\bot}} \cdots \xrightarrowtriangle{
(\cl^{m-1}, \vi^{m-1}, \opset^{m-1})}_{\ET_{\bot}} \conf_{m} \xrightarrowtriangle{(\cl, \vi^{m}, \TtoOp(\txid_{m})} 
\conf^{m+1}.
\]
\end{definition}
