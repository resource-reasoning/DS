\subsection{Specifications of Consistency Models}
\begin{figure}
\begin{tabular}{ l @{} r }
\hline
\textbf{Consistency Model} & \textbf{Execution Test}\\
\hline
\MRd & $\vi \viewleq \vi'$\\
\MW & 
$j \in \vi(\ke) \wedge \WTx(\hh(\ke', i)) \xrightarrow{\PO?} \WTx(\hh(\ke, j)) 
\implies i \in \vi(\ke')$
\\
\RYW & $ \mkvs' = \updateKV(\hh, \vi, \txid, \opset) \implies $\\
\multicolumn{2}{r}{ \qquad $\WTx( \mkvs'(\ke, i) ) \leq \txid \implies i \in \vi'(\ke) $}\\
\WFR & $j \in \vi(\ke) \wedge \txid \in \RTx(\hh(\ke', i)) \wedge \txid {\xrightarrow{\PO?}}
\WTx(\ke, j) ) \implies i \in \vi(\ke')$\\
\CC & $\ET_{\CC} = \ET_{\MRd} \cap \ET_{\MW} \cap \ET_{\RYW} \cap \ET_{\WFR}$\\
\hline
\hline
\UA & $(\otW, \ke,  \stub) \in \opset \implies \fora{ i : 0 \leq i < \lvert \hh(\ke) \rvert } i \in \vi(\ke) $\\
\CP & \( \Setcon{(\mkvs, \vi, \f, \vi')}{\ddagger} \cap \ET_\MRd \cap \ET_\RYW \) \\
\PSI & $\ET_{\PSI} = \ET_{\CC} \cap \ET_{\UA}$\\
$\SI$ & $\Setcon{(\mkvs, \vi, \f, \vi')}{\dagger} \cap \ET_\MRd \cap \ET_\RYW  \cap \ET_\UA $\\
\SER & $\fora{ i : 0 \leq i < \lvert \hh(\ke) \rvert } i \in \vi(\ke) $\\
\hline
\end{tabular}

Given \( \txid \) that is the writer of a version \((k,i)\) observed by the view \( \vi \) or has a \( \AD \) edge to a version \( (\ke,i) \), 
the version \( (\ke',j) \) written by \( \txid' \) must be observed by the view \( \vi \), if \( (\txid', \txid) \in ((\PO \cup \VO \cup \RF) ; \AD ?)^{+}\).

\[
    \begin{rclarray}
        \func{RW^{-1}}{\mkvs, \ke, i} & \defeq & \Setcon{\txid}{\exsts{ j \leq i } \txid \in \RTx(\mkvs(\ke,j))} \\
        \func{SO^{-1}}{\txid} & \defeq & \Setcon{\txid'}{ \exsts{ \cl, m, n } \txid = \txid_{\cl}^{n} \land \txid' = \txid_{\cl}^{m} \land m < n } \\
        \dagger & \equiv &
        \begin{array}[t]{@{}l@{}}
            \fora{\ke, \ke', i, j, m, \txid, \txid', \txid''} \\
            \begin{array}{@{}l@{}}
            i \in \vi(\ke) 
            \land \txid \in \Set{\WTx(\mkvs(\ke,i))} \cup \func{RW^{-1}}{\mkvs, \ke, i} \land {} \\
            \quad \left(
                \begin{array}{@{}l @{}}
                    \left( \begin{array}{@{}l@{}}
                        \txid' \in \func{SO^{-1}}{\txid}
                        \land \txid' \in \Set{\WTx(\mkvs(\ke',j))} \cup  \RTx(\mkvs(\ke',j))
                    \end{array} \right)  \lor {} \\
                    \left( \begin{array}{@{}l@{}}
                        \txid \in \RTx(\mkvs(\ke',j)) 
                        \land \txid' = \WTx(\mkvs(\ke',j))
                    \end{array} \right) \lor {} \\ 
                    \left( \begin{array}{@{}l@{}}
                        \txid = \WTx(\mkvs(\ke',m)) 
                        \land \txid' = \WTx(\mkvs(\ke',j)) \land m > j
                    \end{array} \right) 
                \end{array}
                \right)  \\
            \qquad \implies j \in \vi(\ke') 
            \end{array}
        \end{array} \\

        \ddagger & \equiv &
        \begin{array}[t]{@{}l@{}}
            \fora{\ke, \ke', i, j, m, \txid, \txid', \txid''} \\
            \left( \begin{array}{@{}l@{}}
            i \in \vi(\ke) 
            \land \txid \in \Set{\WTx(\mkvs(\ke,i))} \cup \func{RW^{-1}}{\mkvs, \ke, i} \land {} \\
            \quad \left(
                \begin{array}{@{}l @{}}
                    \left( \begin{array}{@{}l@{}}
                        \txid' \in \func{SO^{-1}}{\txid}
                        \land \txid' \in \Set{\WTx(\mkvs(\ke',j))} \cup  \RTx(\mkvs(\ke',j))
                    \end{array} \right)  \lor {} \\
                    \left( \begin{array}{@{}l@{}}
                            \txid \in \RTx(\mkvs(\ke',j)) \land \txid' = \WTx(\mkvs(\ke',j))
                    \end{array} \right)
                    \end{array} \right) 
                \end{array}
                \right)  \\
                {} \lor \left( \begin{array}{@{}l@{}}
                        i \in \vi(\ke) \land \ke = \ke' \land j < i
                \end{array} \right) \\
                \qquad \implies j \in \vi(\ke') 
        \end{array} \\
    \end{rclarray}
\]
\caption{Execution tests for both client-centric and data-centric consistency models. 
The condition column define a necessary and sufficient condition for inferring $\ET_{\CM} \vdash \hh, \vi \triangleright \opset : \vi'$,  
where $\CM$ is the consistency model from the left column.
All the variables in the formulas above are universally quantified.
All the key \( \ke, \ke' \) are restricted to those that appear in the fingerprint \( \f \), \ie  \( (\stub, \ke, \stub) \in \f \).
}
\label{fig:execution.tests}
\end{figure}

\begin{figure}
\hrule
\begin{subfigure}{0.3\textwidth}
\begin{centertikz}
\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\ke_1 \mapsto$};

\matrix(versionx) [version list]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\txid_1$\\
    {a} & $\left\{\txid_{\cl}^{2}\right\}$ & {a} & $\left\{\txid_{\cl}^{1} \right\}$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$v_0$};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$v_1$};
%\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
%\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};
\end{pgfonlayer}

\end{centertikz}
\caption{Disallowed by \(\MRd\)}
\label{fig:mr-disallowed}
\end{subfigure}
\quad
\begin{subfigure}{0.3\textwidth}
\begin{centertikz}
\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\ke_1 \mapsto$};

\matrix(versionx) [version list]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\txid_{\cl}^{1}$\\
    {a} & $\left\{\txid' \right\}$ & {a} & $\emptyset$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$v_0$};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$v_1$};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_2 \mapsto$};
\matrix(versiony) [version list]
   at ([xshift=\tikzkvspace]locy.east) {
 {a} & $\txid_0$ & {a} & $\txid_{\cl}^2$ \\
  {a} & $\emptyset$ & {a} & $\{\txid'\}$\\
};

\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$v_0$};
\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{$v_2$};
\end{pgfonlayer}

\end{centertikz}
\caption{Disallowed by \(\MW\)}
\label{fig:mw-disallowed}
\end{subfigure}
\quad
\begin{subfigure}{0.3\textwidth}
\begin{centertikz}
\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\ke_1 \mapsto$};

\matrix(versionx) [version list]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\txid'$\\
    {a} & $\{\txid\}$ & {a} & $\left\{ \txid_{\cl}^1 \right\}$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$\val_0$};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$\val_1$};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_2 \mapsto$};
\matrix(versiony) [version list]
   at ([xshift=\tikzkvspace]locy.east) {
 {a} & $\txid_0$ & {a} & $\txid_{\cl}^2$ \\
  {a} & $\emptyset$ & {a} & $\{\txid\}$\\
};

\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$v_0$};
\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{$v_2$};
\end{pgfonlayer}
\end{centertikz}
\caption{Disallowed by \(\WFR\)}
\label{fig:wfr-disallowed}
\end{subfigure}

\begin{subfigure}{0.47\textwidth}
\begin{centertikz}
\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\ke_1 \mapsto$};

\matrix(versionx) [version list, column 2/.style={text width=14mm}]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\txid_{\cl}^{1}$ & {a} & $\txid_{\cl}^{2}$\\
    {a} & $\left\{\txid_{\cl}^{1}, \txid_{\cl}^{2}\right\}$ & {a} & $\emptyset$ & {a} & $\emptyset$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$0$};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$1$};
\tikzvalue{versionx-1-5}{versionx-2-5}{locx-v2}{$1$};
%\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
%\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};
\end{pgfonlayer}
\end{centertikz}
\caption{Disallowed by \(\RYW\)}
\label{fig:ryw-disallowed}
\end{subfigure}
\quad
\begin{subfigure}{0.47\textwidth}
\begin{centertikz}
\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);
%Location x
\node(locx) {$\ke_1 \mapsto$};

\matrix(versionx) [version list, column 2/.style={text width=14mm}]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\txid$ & {a} & $\txid'$\\
    {a} & $\{\txid, \txid'\}$ & {a} & $\emptyset$ & {a} & $\emptyset$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$0$};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$1$};
\tikzvalue{versionx-1-5}{versionx-2-5}{locx-v2}{$1$};
%\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
%\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};
\end{pgfonlayer}
\end{centertikz}
\caption{Disallowed by \(\UA\)}
\label{fig:ua-disallowed}
\end{subfigure}

\begin{tabular}{@{}c @{} c @{}}
\begin{minipage}{0.4\textwidth}
\begin{subfigure}{\textwidth}
\begin{centertikz}
\begin{pgfonlayer}{foreground}
%Location x
\node(locx) {$\ke_1 \mapsto$};

\matrix(versionx) [version list]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\txid_1$\\
    {a} & $\left\{\txid_3\right\}$ & {a} & $\left\{ \txid_4 \right\}$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$\val_0$};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$\val_1$};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_2 \mapsto$};
\matrix(versiony) [version list]
   at ([xshift=\tikzkvspace]locy.east) {
 {a} & $\txid_0$ & {a} & $\txid_2$ \\
  {a} & $\left\{\txid_4\right\}$ & {a} & $\left\{\txid_3\right\}$\\
};

\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$\val_0$};
\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{$\val_2$};
\end{pgfonlayer}
\end{centertikz}
\caption{Disallowed by \(\CP\) - 1}
\label{fig:cp-disallowed-1}
\end{subfigure}

\begin{subfigure}{\textwidth}
\begin{centertikz}
\begin{pgfonlayer}{foreground}
%Location x
\node(locx) {$\ke_1 \mapsto$};

\matrix(versionx) [version list]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\txid_{\cl}^{1}$\\
    {a} & $\left\{\txid_{\cl'}^{2}\right\}$ & {a} & $\emptyset$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$\val_0$};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$\val_1$};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_2 \mapsto$};
\matrix(versiony) [version list]
   at ([xshift=\tikzkvspace]locy.east) {
 {a} & $\txid_0$ & {a} & $\txid_{\cl'}^1$ \\
  {a} & $\left\{\txid_{cl}^{2}\right\}$ & {a} & $\emptyset$\\
};

\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$\val_0$};
\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{$\val_2$};

%\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
%\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};
\end{pgfonlayer}
\end{centertikz}
\caption{Disallowed by \(\CP\) - 2}
\label{fig:cp-disallowed-2}
\end{subfigure}
\end{minipage}
&
\begin{subfigure}{0.55\textwidth}%
\begin{centertikz}%
\begin{pgfonlayer}{foreground}%
%Location x
\node(locx) {$\ke_1 \mapsto$};

\matrix(versionx) [version list]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\txid_1$ & {a} & $\txid_2$\\
    {a} & $\emptyset$ & {a} & $\emptyset$ & {a} & $\emptyset$\\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$\val_0$};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$\val_1$};
\tikzvalue{versionx-1-5}{versionx-2-5}{locx-v1}{$\val_2$};
%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_2 \mapsto$};
\matrix(versiony) [version list]
   at ([xshift=\tikzkvspace]locy.east) {
 {a} & $\txid_0$ & {a} & $\txid_3$ \\
  {a} & $\left\{\txid_2\right\}$ & {a} & $\emptyset$\\
};

\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$\val_0$};
\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{$\val_1$};

%Location z
\path (locy.south) + (0,\tikzkeyspace) node (locz) {$\ke_3 \mapsto$};
\matrix(versionz) [version list]
   at ([xshift=\tikzkvspace]locz.east) {
 {a} & $\txid_0$ & {a} & $\txid_3$ & {a} & $\txid_4$ \\
  {a} & $\emptyset$ & {a} & $\emptyset$ & {a} & $\emptyset$\\
};

\tikzvalue{versionz-1-1}{versionz-2-1}{locz-v0}{$\val_0$};
\tikzvalue{versionz-1-3}{versionz-2-3}{locz-v1}{$\val_1$};
\tikzvalue{versionz-1-5}{versionz-2-5}{locz-v2}{$\val_2$};

%Location w
\path (locz.south) + (0,\tikzkeyspace) node (locw) {$\ke_4 \mapsto$};
\matrix(versionw) [version list]
    at ([xshift=\tikzkvspace]locw.east) {
    {a} & $\txid_0$ & {a} & $\txid_1$ \\
    {a} & $\{\txid_4\}$ & {a} & $\emptyset$ \\
};
\tikzvalue{versionw-1-1}{versionw-2-1}{locw-v0}{$\val_0$};
\tikzvalue{versionw-1-3}{versionw-2-3}{locw-v1}{$\val_1$};
%\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
%\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};
\end{pgfonlayer}%
\end{centertikz}%
\caption{Disallowed by \(\SI\)}%
\label{fig:si-disallowed}%
\end{subfigure} \\
\end{tabular}
\hrule
\end{figure}

We conclude this section by giving the execution tests for widely adopted 
consistency models of distributed and replicated databases. These are summarised 
in \cref{fig:execution.tests}.
Following \cite{distrprinciples}, we distinguish between client-centric and data-centric consistency models. 
The former constrain the versions of keys that individual clients can observe. 
%such consistency models  
%include the session guarantees from \cite{terry1994sessions}, namely \emph{monotonic reads} (\MRd), \emph{monotonic writes} (\MW), \emph{read your writes} (\RYW) and \emph{write follows reads} (\WFR).
%The client-centric consistency model is also known as \emph{session guarantees} \cite{terry1994sessions}.
The latter impose conditions on the shape of the state of the database, in our case the structure of the kv-store.
%The data-centric consistency models include \emph{update atomic} (\UA), \emph{consistent prefix} (\CP) and \emph{serialisibility} (\SER).
%The remained models are combinations of both types, including \emph{causal consistency} (\CC), \emph{parallel snapshot Isolation} (\PSI) and \emph{snapshot Isolation} (\(\SI\)).
%Both kinds of models can be induced by execution tests. 
In \cref{sec:equivalence} we prove that specification of consistency models using execution tests are both sound and complete 
with respect to alternative specifications from the literature. Due to space constraints, we only give 
examples of allowed and disallowed kv-stores for relevant consistency models. A full account 
of the anomalous behaviours permitted by each consistency model is deferred to \cref{app:?}.

\subsubsection{Monotonic Reads ($\MRd$)}
A client ensures the monotonic reads consistency guarantee if subsequent read operations always 
return versions from a more up-to-date state of the system. For example, the kv-store from \cref{fig:mr-disallowed} is disallowed 
by $\MRd$.
Because client $\cl$ first observes the latest version of $\ke$ in $\txid_{\cl}^{1}$, then it
observes the initial version of $\ke$ in $\txid_{\cl}^{2}$.
%Because the versions observed by a client of a kv-store 
%are determined by the view of the former, monotonic reads can be enforced in our framework by ensuring that 
%a client can never replace its view with an older one. According to the definition of $\CMs(\_)$, 
%a client can only update its view to an older one upon committing a transaction. 
The execution test $\ET_{\MRd}$ (\cref{fig:execution.tests}) prevents this scenario by 
forcing clients to always update their views to newer ones. 
%$\ET_{\MRd}$ in \cref{fig:execution.tests} forces clients to always update their views to newer ones.

\subsubsection{Monotonic Writes ($\MW$)}
It states that whenever a transaction observes the effects of a version installed by some client $\cl$, then 
the transaction observes all the transactions executed by the client. It prevents 
the scenario of \cref{fig:mw-disallowed}, where transaction $\txid'$ observes the 
second version of $\ke_2$ carrying value $\val_2$, written by client $\cl$; but it does not observe the second version 
of $\ke_1$ carrying value $\val_1$, previously written by the same client.
%The order of updates of transaction identifiers is embedded in the set of transaction identifiers, 
%and it is given by $\txid \xrightarrow{\PO} \txid' \iff \exists \cl, n,m. n < m \wedge \txid = \txid_{\cl}^{n} \wedge 
%\txid' = \txid_{\cl}^{m}$. 
The execution test $\ET_{\MW}$ (\cref{fig:execution.tests}) ensures 
that, prior to executing a transaction, the set of versions included in the view of the client 
must be prefix-closed with respect to the relation $\xrightarrow{\PO}$.

\subsubsection{Read Your Writes (\RYW)}
It states that a client must always be able to read any version 
of a key that was previously written by the same client. This prevents the kv-store of \cref{fig:ryw-disallowed}. 
In there, assuming that the initial version of $\ke$ carries value $0$, the client $\cl$ tries to increment the value of $\ke$ by $1$ twice, 
by first reading its value $\nat$ and then installing a new version carrying  value $\nat+1$ within a single transaction.
However, if the client does not read its 
own writes, the client might read the initial version of $\ke$ in the second increment 
(corresponding to the transaction $\txid_{\cl}^2$), and install a new version carrying value $1$.
%A client always appends the version of a key written by  
%a transaction at the tail of the version list for such a key. Therefore, to enforce the 
The Read your Writes ($\RYW$) (\cref{fig:execution.tests}) enforces that after committing a transaction, 
a client advances its view to the latest version for each key it wrote.  

\subsubsection{Write Follows Reads (\WFR)}
It states that if a client writes some version $\ver$ following (or in the same transaction of ) 
a read of some version $\ver'$, 
then a second client may observe version $\ver$ only if it also observes $\ver'$. The Write Follow Reads ($\WFR$) 
consistency guarantee disallows the scenario depicted in  \cref{fig:wfr-disallowed} 
where a transaction $\txid$ observes the version $\ver_2$ of $\ke_2$ carrying value $\val_2$ written by client $\cl$,
but the same transaction $\txid$ does not observe 
the version of $\ke_1$ carrying value $\val_1$, read by $\cl$ prior to writing $\ver$. 
The execution test $\ET_{\WFR}$ (\cref{fig:execution.tests}) prevents this and similar scenarios to occur.

\subsubsection{Causal Consistency (\CC)}
Causal Consistency requires that if a client observes a version 
$\ver$ of some key $\ke$, then it must also observe any version $\ver'$ of some key $\ke'$ 
from which $\ver$ potentially depends \cite{cops}. A necessary and sufficient condition 
for ensuring causal consistency is that of enforcing the four session guarantees $\MRd, \MW, \RYW$ and $\WFR$ 
discussed above \cite{session2causal}. Therefore, we let $\ET_{\CC} = \ET_{\MRd} \cap \ET_{\MW} 
\cap \ET_{\RYW} \cap \ET_{\WFR}$. 
%By \cref{prop:et.compositional}, 
%kv-stores disallowed by causal consistency are exactly the kv-stores disallowed by at least one of the 
%four session guarantees.
%However, for the sake of completeness we prefer to 
%give a definition of execution test for causal consistency after the standard definition. 
%The notion of \emph{potential dependency} $\xrightrrow{\pdep}$ between versions is defined by 
%letting $\ver \xrightarrow{\pdep} \ver'$ if  
%$\exists \txid, \txid'. \txid \in \{\WTx(\ver)\} \cup \RTx(\ver) \wedge 
%\txid' \in \{\WTx(\ver')\} \cup \RTx(\ver') \wedge \txid \xrightarrow{\SO} \txid'$: 
%this corresponds to the intuition that operations within a session potentially depends from previous operations in the same session.
%The notion of \emph{potential data dependency} between versions is given 
%by $\ver \xrightarrow{\ddep} \ver'$ if $\WTx(\ver') \in  \RTx(\ver)$.

\subsubsection{Update Atomic ($\UA$).}
This consistency model has been proposed in \cite{framework-concur}, though we 
are not aware of any implementation. However, many implemented consistency models 
can be obtained by strengthening Update Atomic. Roughly speaking, in Update Atomic 
concurrent transactions writing to the same key cannot execute concurrently. This property 
is known as \emph{write conflict detection}. For example, $\UA$ prevents the kv-store to 
the right to occur. There, two transactions $\txid, \txid'$ concurrently increment the initial 
version of $\ke$ by $1$. Note that this scenario is more general than the one exhibited by 
$\RYW$, in that we do not require $\txid, \txid'$ to be executed by the same client 
(in fact, the kv-store to the right is allowed by causal consistency and monotonic writes).
To prevent this scenario from happening, the execution test $\ET_{\UA}$ requires 
that a client $\cl$ can write to key $\ke$ in a transaction, only if its view prior 
to the execution of the transaction pointed to the last version of $\ke$.

%framework, we can compute the set of transactions that are concurrent by transaction $\txid$ 
%immediately before executing such a transaction. At the moment a client $\cl$ tries to 
%commit the effects of transaction $\txid$, then any transaction $\txid'$ that read or wrote versions not included 
%in the view of $\cl$ is concurrent to $\txid$. Following this intuition, we can enforce write 
%conflict detection by requiring that whenever a client $\cl$ wants to commit the effect of 
%transactions writing key $\ke$ in the kv-store $\hh$, then the view of $\cl$ must include all the versions of $\ke$. 
%Formally, this leads to the execution test $\ET_{\UA}$ defined in \cref{fig:execution.tests}

\subsubsection{Consistent Prefix ($\CP$).}
In centralised databases, where there is a total order in which transactions commit, 
consistent prefix is described  by the following property: if a client 
observes the effects of a transaction $\txid$, then it also observe the effects 
of any transaction $\txid'$ that commits before $\txid$. This property is 
difficult to formulate in our setting, because kv-stores do not contain any 
information about the total order in which transactions committed. 
As an alternative, we can specify $\CP$ via two different properties: 
first, clients agree on the 
order in which transactions install versions in a kv-store; and a client $\cl$ always 
observes all the transactions that executed before its last transaction. This property 
disallow disallows the kv-store depicted to the right: there 
transaction $\txid_{3}$ observes that the 
update of $\ke_2$ carrying value $\val_2$ happens before 
the update of $\ke_1$ carrying value $\val_2$; vice versa , 
$\txid_{4}$ observes that the update of $\ke_1$ carrying value $\val_1$ 
happens before the update of $\ke_2$ carrying value  $\val_2$. 
The second property required by $\CP$ is that at any given time, 
a client observes the effects of all the transactions that  
executed before the last transaction that such a client executed. 
This property prevents a scenario like the one depicted to the 
right: client $\cl$ does not observe the update to $\ke_2$ performed 
by $\cl'$, and $\cl'$ does not observe the update to $\ke_1$ performed 
by $\cl$. This property can be formalised by requiring that, after 
a client executes a transaction, its view is shifted to the most recent 
view of the data. The execution test $\ET_{\CP}$ is defined formally 
in \cref{fig:execution.tests}; in \cref{sec:?} we prove that our specification  
of $\CP$ using execution tests is precise. 


%Recall that in our setting clients shift their view upon executing the 
%transaction: the initial view abstracts the starting point of the 
%transaction, while the final view abstracts its commit point.
%Following this intuition, we compute an 
%under-approximation $\CBef_{\CP}(\cl, \vi, \hh, \opset)$ 
%of the set of transactions that a client $\cl$ with view $u$ 
%must observe to have committed, when executing a transaction with 
%fingerprint $\opset$. The definition of $\CBef_{\CP}$ is recursive, 
%and follows an approach similar to the one proposed in \cite{laws}.
%Formally, we let $\CBef_{\CP}(\cl, \vi, \hh, \opset)$ 
%be the smallest set such that for all $i, j, j', n, m \in \Nat$, $\ke, \ke' \in \Keys$, 
%$\val \in \Val$ and $\cl' \in \Clients$:
%\[
%\begin{array}{l}
%%Base Cases
%(\otR, \ke, \val) \in  \opset \implies   \WTx(\hh(\ke, \vi)) \in \CBef_{\CP}(\cl, \vi, \hh, \opset)\\
%%(\oTW, \ke, \val) \in \opset \implies  \WTx(\hh(\ke, i)) \in \CBef_{\CP}(\cl, \vi, \hh, \opset)\\
%\txid_{\cl}^{n} \text{ appears in } \hh \implies \txid_{\cl}^{n} \in \CBef_{\CP}(\cl, \vi, \hh \opset)\\
%%Inductive Cases
%% \WR \subseteq \AR
%(\RTx(\hh(\ke, i)) \cap \CBef_{\CP}(\cl, \vi, \hh, \opset) \neq \emptyset \implies  \WTx(\hh(\ke,i)) \in \CBef_{\CP}(\cl, \vi, \hh, \opset)\\
%%\VO \subseteq \AR
%i < j \wedge \WTx(\hh(\ke,j)) \in \CBef_{\CP}(\cl, \vi, \hh, \opset) \implies  \WTx(\hh(\ke, i)) \in \CBef_{\CP}(\cl, \vi, \hh, \opset)\\
%% PO \subseteq \AR 
%m \leq n \wedge \txid_{\cl}^{n} \in \CBef_{\CP}(\cl, \vi, \hh, \opset) \implies  \txid_{\cl}^{m} \in \CBef_{\CP}(\cl, \vi, \hh, \opset)\\
%% RF;RW \subseteq \AR
%\txid \in \RTx(\hh(\ke, i)) \cap \RTx(\hh(\ke', j)) \wedge j < j' \wedge \WTx(\hh(\ke', j')) \in \CBef_{\CP}(\cl, \vi, \hh, \opset) 
%\implies \\ \hspace{20pt} \WTx(\hh(\ke, i)) \in \CBef_{\CP}(\cl, \vi, \hh, \opset)\\
%%\PO;RW \subseteq \AR 
%m < n \wedge \txid_{\cl}^{n} \in \RTx(\hh(\ke,i)) \wedge i < j \wedge \WTx(\hh(\ke, j)) \in \CBef_{\CP}(\cl, \vi, \hh, \opset) 
%\implies \\ \hspace{20pt} \txid_{\cl}^{m} \in \CBef_{\CP}(\cl, \vi, \hh, \opset)
%\end{array}
%\]
%\begin{itemize}
%\item if $(\oTR, \ke, \_) \in \opset$, then $\WTx(\hh(\ke, u)) \in \CB(\hh, \vi, \opset)$: 
%because the $\txid_{\mathsf{now}}$ reads the version of 
%$\ke$ at $\hh(\ke, \vi)$, then the transaction $\txid$ that wrote such 
%a version must commit before $\txid_{\mathsf{now}}$,
%\item for any $\txid_{\cl}^{n}$ appearing in the kv-store, $\txid_{\cl}^{n} 
%\in \CB(\cl, \vi, \hh, \opset)$: any previous transaction executed by $\cl$ 
%must commit before $\txid_{\mathsf{now}}$, 
%\item 
%\end{itemize}
%However, suppose that in the kv-store $\hh$, a client $\cl$ with view $\vi$
%wants to execute a transaction with fingerprint $\opset$. In the case 
%that $(\otR, \ke, ) \in \opset$, then we can observe the following: 
%\begin{itemize}
%\item{\color{red} note to self: in CP $\AR_{\CP} = (\PO \cup \RF \cup \VO \cup \PO;\AD \cup \RF;\AD)^{+}$}
%\item the client will read the value of $\ke$ from the version $\hh(\ke,u)$. 
%For this to be possible, the transaction $\WTx(\hh(\ke,u))$ must have committed 
%before the transaction to be executed by $\cl$, {\color{red} Note to self: base case}, 
%\item for any client $\cl'$ and index $n$, $\txid_{\cl'}^{m}$ commits before $\txid_{\cl}^{n}$ 
%for all $m < n$, {\color{red} - case $\PO \subseteq \AR_{\CP}$}
%\item for any key $\ke'$ and index $i$, the transaction $\WTx(\hh(\ke', i))$ commits 
%before all of the transactions in $\RTx(\hh(\ke', i))$, {\color{red} - case $\RF \subseteq \AR_{\CP}$}, 
%\item for any $\ke'$ and index $i$, then $\WTx(\hh(ke', j))$ commits before $\WTx(\hh(\ke', i))$ for 
%any $j < i$,  {\color{red} - case $\VO \subseteq \AR_{\CP}$}
%\item for any $\ke'$ and integers $i,n$, if $\txid_{\cl'}^{n} \in \RTx(\hh(\ke', i))$, 
%then for any $j: i < j \leq \lvert \hh(\ke') \rvert - 1$, and index $m < n$, then 
%$\txid_{\cl'}^{m}$ commits before $\WTx(\hh(\ke,j))$ {\color{red} - to be explained 
%why: intuitively if $\txid_{\cl'}^{m}$ committed after $\WTx(\hh(\ke, j))$, 
%then $\txid_{\cl}^{m}$ would start after $\WTx(\hh(\ke, j))$ committed, 
%hence it would not be able to read a former version of $\ke$. This case corresponds 
%to $\PO; \AD \subseteq \AR_{\CP}$},
%\item for any $\ke',\ke''$ and indexes $i,j$, if $\txid \in \RTx(\hh(\ke', i)) \cap 
%\RTx(\hh(\ke'', j))$, then for any $j': j < j' \leq \lvert \hh(\ke'') \rvert - 1$, 
%$\WTx(\hh(\ke',i))$ comitted before $\WTx(\hh(\ke'', j'))$ {\color{red} 
%explanation similar to the case above - this is the case $\RF ; \AD \subseteq \AR_{\CP}$}, 
%\item if $\txid$ committed before $\txid'$, and $\txid'$ committed before $\txid''$, 
%then $\txid$ committed before $\txid''$.
%\end{itemize}
%We can define a relation $\mathsf{CommitBefore}_{\CP}(\hh, \cl, \vi, \ke)$ that 
%includes all the transactions that we know must have committed prior to the 
%execution of a transaction from client $\cl$, whose view on $\hh$ is $\vi$, 
%assuming that said transaction will read value $\ke$.
%Using a technique similar to the one proposed in \cite{laws}, it is possible to prove 
%that for $\cl$ to execute safely a transaction with fingerprint $\opset$, 
%then for each $\ke$ that is read in $\opset$, the view of $\cl$ must include 
%at least the transactions in $\mathsf{CommitsBefore}_{\CP}$. Following this intuition, 
%we let 
%\[ 
%\ET_{\CP} \vdash \hh, \vi \triangleright \opset: \vi' \iff 
%\forall (\otR, \ke, \_) \in \opset.\; \forall \ke', j. \WTx(\hh(\ke', j)) \in \mathsf{CommitBefore}_{\CP}(\hh, \cl, \vi, \ke) 
%\implies j \leq \vi(\ke)
%\]

%{\color{red} the execution test as it is right now does not enforce consistent 
%prefix. An alternative would be to encode kv-stores into dependency graphs, 
%define the relation $\mathsf{CB} = 
%((\PO \cup \RF) ; \AD?) \cup \VO)^{+}$ - I know, it does not make any sense, 
%will try to explain at the meeting - and require that if $\txid$ is included 
%in a view $\vi$, then all the transactions $\txid'$ such that $\txid' \xrightarrow{\mathsf{CB}} 
%\txid$ must also be included in $\txid$. This works, but the problem is going to be how 
%to explain it to people.}
%An alternative 
%formulation is that concurrent transactions never observe updates on the kv-store 
%in different order. Consistent Prefix prevents the scenario depicted to the right: 
%transactions $\txid_4$ reads the up-to-date version of $\ke_1$ and a stale version 
%of $\ke_2$; in contrast, transaction $\txid_3$ reads a stale version of $\ke_2$ and 
%an up-to-date version of $\ke_1$.
%The execution test $\ET_{\CP}$ prevents this scenario by requiring that, immediately 
%after committing a transaction $\txid$, a client $\cl$ brings its view to point to the 
%most recent version of each key: this amount to require that the next time that $\cl$ 
%executes a transaction, it will observe at least the effects of all the transactions that 
%committed before $\txid$.
%By Looking at the structure 
%of a kv-store, it is not immediate to infer a total order in which transactions have been 
%executed (this problem has been analysed in a slightly different setting, see \cite{SIanalysis,laws} 
%for details). An equivalent definition of consistent prefix requires that different clients 
%never see updates to the kv-stores performed in different order. We can enforce this property 
%by strengthening causal consistency with the requirement that clients, 
%after committing the effects of a transaction, always shift their view to 
%the most recent version of each key.  
%The execution $\ET_{\CP}$ for consistent 
%prefix is defined in \cref{fig:execution.tests}.

\subsubsection{Parallel Snapshot Isolation (PSI)} 
These two consistency models are obtained by combining causal consistency with update atomic, 
and consistent prefix with update atomic, respectively. Formally, we have 
$\ET_{\PSI} = \ET_{\CC} \cap \ET_{\UA}$, and $\ET_{\SI} = \ET_{\CC} \cap \ET_{\UA}$.
%\textbf{\color{red} Here is where things go awry. Even if we replace $\CP$ with the right specification, 
%we cannot encode $\ET_\SI$ as $\ET_{\CP} \cap \ET_{\UA}$. The alternative would be to 
%encode $SI$ directly using dependency graphs, similarly as for the $\CP$ case.} 

\subsubsection{Snapshot Isolation (SI)}
When the total order in which transactions commit is known, SI 
can be specified as the weakest consistency model that guarantees both 
prefix consistency and update atomic \cite{gsi,framework-concur}. 
On the other hand, the same is not true in our framework, where 
transactions are not totally ordered: for example, the kv-store to 
the right is included both in $\CMs(\ET_{\CP})$ and $\CMs(\ET_{\UA})$, 
but it is forbidden by SI.\footnote{This problem is not 
limited to our setting: because kv-stores are isomorphic to Adya's dependency 
graph, the same problem arises there.} 
\textbf{\color{red} This is going to be difficult to be put in words: 
both SI and CP require that the snapshot taken by clients are monotonically 
increasing (at least for transactions that write to at least one key). 
In both SI and CP, we enforce this property by computing, at the moment 
of trying to commit a transaction, a view of all the transactions that executed before 
(and hence appear in the kv-store); then we require that such views do not cross 
with the one that is being used to commit the current transaction. Here is where 
the twist happens: the way in which the relevant fragment of a view of 
a transaction is obtained is different for $\CP$ and $\SI$. 
For $\CP$, this relevant fragment is obtained 
by looking at the version reads for a transaction. If transaction $\txid$ read the 
$i$-th version of $\ke$, then we can be sure that the view $\vi_{\txid}$ 
that was used to execute $\txid$ was such that $\vi_{\txid}(\ke) = i$. 
For $\SI$ we also know that if transaction $\txid$ wrote the $i$-th version 
of key $\ke$, then because of write conflict detection, $\vi_{\txid}$ pointed 
to the previous version of $\ke$ i.e. $\vi_{\txid}(\ke) = i - 1$. 
In \cref{fig:execution.tests}, the execution test $\ET_{\SI}$ enforces three properties: 
the check on the first line mandates that  if a transaction wants to write key $\ke$, then the view of the client wishing 
to execute such a transaction must be up-to-date for that client; the check 
on the second line mandates that upon committing 
a transaction, a client shifts its view to the most up-to-date version of each 
key (this is done to ensure both $\RYW$ and $\MRd$); 
the check on the last two lines ensures that, in order to commit a transaction, the 
view of a client must not be crossing the view that was used to commit a previous 
transactions $\txid'$, at least for the objects that were accessed by $\txid'$.\\
Following a chat with Shale: it looks that there is a check on the program order missing 
here. I need to correct this.}
%We basically compute the relevant fragment of the view that we
%To overcome this problem, we place in 
%$\ET_{\SI}$ one more constraint in addition to the ones that 
%define $\ET_{\CP}$ and $\ET_{\UA}$: if a version read by transaction $\txid$ 
%is to the left of the view $\vi$ of the client wishing to update a transaction, then 
%all the versions written by $\txid$ must be to the left of $\vi$. In \cref{sec:?} 
%we prove that the execution test $\ET_{\SI}$, defined in \cref{fig:execution.tests}, 
%precisely capture SI.

\subsubsection{(Strict) Serialisibility (\SER)}
The last consistency model that we consider is serialisability. This consistency model 
requires that there exists a serial, or sequential schedule of transaction. 
This prevents scenarios like the kv-store of \cref{fig:hheap-a}, which is instead allowed 
by all the other execution tests that we have presented.
The execution test $\ET_{\SER}$ enforces serialisability by requiring clients to 
execute transactions only when their view of the kv-store is up-to-date.

%The execution test $\ET_{\SER}$ of \cref{fig:exec.tests} models exactly this scenario.
