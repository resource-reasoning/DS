\subsection{Execution Tests and Consistency Models}
Formally, a \emph{consistency model} $\CMs$ is a 
set of kv-stores. Each $\hh \in \CMs$ represents a possible scenario that 
can be obtained as a result of multiple clients committing transactions. 
For example, \emph{serialisability} can be described as the set 
of kv-stores for which it is possible to recover a total schedule of transactions, 
such that each read operation on key $\ke$ fetches its value from the 
most recent write on the same key \cite{??????}.
In this sense, the kv-store $\hh$ from \cref{fig:hheap-a} is not serialisable: 
transaction $\txid_1$ reads the initial version carrying value $\val'_0$ for key $\ke_{2}$, 
and installs a new version of $\ke_{2}$ carrying value $\val_1$. The transaction $\txid_2$ 
reads the initial version carrying value $\val'_0$, and therefore, 
cannot be scheduled after $\txid_1$. Similarly, $\txid_2$ cannot be scheduled after $\txid_1$.

To specify consistency models we introduce the notion of \emph{execution tests}. 
\begin{definition}
\label{def:execution.test}
\emph{An execution test} is a set of tuples $\ET \subseteq \HisHeaps \times \Views \times \powerset{\Ops} \times \Views$ 
such that whenever $(\hh, \vi, \opset, \vi') \in \ET$, then 
\textbf{(i)} for any read operations $(\otR, \ke, \val) \in \opset$ then $\hh(\ke, \max(\vi(\ke))) = \val$, 
and \textbf{(ii)}  $\forall \ke. \; \vi(\ke) \neq \vi'(\ke) \implies ( (\otR, \ke, \_) \in \opset \vee (\otW, \ke, \_)) \in \opset)$.
%\textbf{(iii)} $\forall \opset' \subseteq \opset.\; (\hh, \vi, \opset', \vi') \in \ET$
\end{definition}
\sx{The definition has a problem that for the subset \( \f'\) the post-view \( \vi' \) might point to an undefined version, I also thing it should satisfy \( \fora{\vi''} \vi \sqsubseteq \vi'' \implies (\hh, \vi, \opset', \vi'') \)}.
\ac{I removed this condition, as I do not think that it was used anywhere. The new definition requires that 
you cannot change the view for keys that you do not read nor write.}
\sx{The current \CP will not satisfy the \textbf{(ii)}. }
Let $\ET$ be an execution test, and then $(\hh, \vi, \opset, \vi') \in \ET$ means 
that a client whose view over the kv-store $\hh$ is $\vi$, can commit a 
transaction whose fingerprint is $\opset$; as a result of this operation, the 
view of the client must be updated to $\vi'$.
Henceforth, we adopt the 
more suggestive notation $\ET \vdash (\hh, \vi) \triangleright \opset: \vi'$ 
in lieu of $(\hh, \vi, \opset, \vi') \in \ET$.

Execution tests induce \emph{consistency models} \( \CMs(\ET) \) as defined in \cref{def:cm}.
\begin{definition}
\label{def:reduction}
Let $\cl$ be a client and $\opset$ be a fingerprint. 
An \emph{action} has either the form $(\cl, \varepsilon)$, 
or $(\cl, \opset)$. 
Let $\mathsf{Act}$ be the set of actions.
Given an execution test $\ET$, for any action $\alpha \in \Act$ the action-labelled 
relation $\xrightarrowtriangle{\alpha}_{\ET} \subseteq \Confs \times \Confs$ is defined
as the smallest relation such that:
\begin{itemize}
\item $\forall \vi, \vi', \cl, \hh, \viewFun.\; \viewFun(\cl) = \vi \wedge \vi \sqsubseteq \vi' \implies (\hh, \viewFun) \xrightarrowtriangle{(\cl, \varepsilon)}_{\ET} 
(\hh, \viewFun\rmto{\cl}{\vi'})$, 
\item $\forall \vi, \vi', \cl, \opset, \hh, \hh', \viewFun.\; \viewFun(\cl) = \vi \wedge (\ET \vdash (\hh, \vi) \triangleright \opset: \vi') \wedge 
\hh' \in \updateKV(\hh, \vi, \cl, \opset) \implies (\hh, \viewFun) \xrightarrowtriangle{(\cl, \opset)}_{\ET} (\hh', \viewFun\rmto{\cl}{\vi'})$.
\end{itemize}
Such relations take the name of $\ET$-reductions, or simply reductions.
\end{definition}
Given an execution test $\ET$, sequences of $\ET$-reductions of the form $\conf_{0} \xrightarrowtriangle{\alpha_{0}}_{\ET} \cdots 
\xrightarrow{\alpha_{n-1}} \conf_{n}$ take the name of \emph{$\ET$-traces}.
\begin{definition}
\label{def:cm}
Given an execution test $\ET$, the set of configurations induced by $\ET$ is given by:
\[
\Confs(\ET) \defeq \Setcon{ \conf}{ \exsts{\conf_0} \conf_0 \text{ is initial } \wedge \conf_0 \xrightarrowtriangle{\stub}_{\ET} \cdots \xrightarrowtriangle{\stub}_{\ET} \conf }
\]
The \emph{consistency model} induced by $\ET$ is defined as:
\( 
\CMs(\ET) \defeq \Setcon{ \hh }{ (\hh, \stub) \in \Confs(\ET) }
\)
\end{definition}
Thus, consistency models are computed from execution tests by closing the set of initial kv-stores with 
respect to two operations: \textbf{(i)} replacing the view of a client on the kv-store with a more up-to-date one, 
and \textbf{(ii)} committing the effects of a transaction. 

Consistency models induced by execution tests are monotonic in the following sense.
\begin{proposition}
\label{prop:mono-et}
Let $\ET_1 \subseteq \ET_2$. Then $\CMs(\ET_1) \subseteq \CMs(\ET_2)$.
\end{proposition}
\begin{proof}
    See \cref{sec:mono-et}.
\end{proof}

