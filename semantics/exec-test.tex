\subsection{Consistency Models and Execution Tests}

Formally, a \emph{consistency model} $\CMs$ is a set of key-value stores. 
Each $\hh \in \CMs$ represents a possible scenario that 
can be obtained as a result of multiple clients committing transactions. 
To specify consistency models we introduce the notion of \emph{execution tests}. 
\ac{
For example, \emph{serialisability} can be described as the set 
of key-value stores for which it is possible to recover a total schedule of transactions, 
such that each read operation on key $\ke$ fetches its value from the 
most recent write on the same key \cite{??????}.
In this sense, the kv-store $\hh$ from \cref{fig:hheap-a} is not serialisable: 
transaction $\txid_1$ reads the initial version carrying value $\val'_0$ for key $\ke_{2}$, 
and installs a new version of $\ke_{2}$ carrying value $\val_1$. The transaction $\txid_2$ 
reads the initial version carrying value $\val'_0$, and therefore, 
cannot be scheduled after $\txid_1$. Similarly, $\txid_2$ cannot be scheduled after $\txid_1$.
}
\begin{definition}
\label{def:execution.test}
An \emph{execution test} is a set of tuples $\ET \subseteq \HisHeaps \times \Views \times \powerset{\Ops} \times \Views$ 
such that for every element $(\hh, \vi, \opset, \vi') \in \ET$,
\textbf{(i)} for any read operations $(\otR, \ke, \val) \in \opset$ then $\hh(\ke, \max_{<}(\vi(\ke))) = \val$, 
and \textbf{(ii)}  for any key \( \ke \) such that $\vi(\ke) \neq \vi'(\ke)$, 
then $( (\otR, \ke, \_) \in \opset \vee (\otW, \ke, \_)) \in \opset)$.
\end{definition}

Given an execution test $\ET$, 
then $(\hh, \vi, \opset, \vi') \in \ET$ means that 
a client whose view over the key-value store $\hh$ is $\vi$, 
can commit a transaction whose fingerprint is $\opset$;
as a result of this operation, the view of the client must be updated to $\vi'$.
Henceforth, we adopt the more suggestive notation $\ET \vdash (\hh, \vi) \triangleright \opset: \vi'$ 
in lieu of $(\hh, \vi, \opset, \vi') \in \ET$.
Execution tests induce \emph{consistency models} \( \CMs(\ET) \) as defined in \cref{def:reduction,def:cm}.
\begin{definition}[$\ET$-reductions]
\label{def:reduction}
Let $\cl$ be a client and $\opset$ be a fingerprint. 
An \emph{action} $\alpha \in \Act$ has either the form $(\cl, \varepsilon)$, 
or $(\cl, \opset)$. 
Given an execution test $\ET$ the action-labelled relation 
$\xrightarrowtriangle{}_{\ET} \subseteq \Confs \times \Act \times \Confs$ 
is defined as the smallest relation such that:
\begin{itemize}
\item 
    $\forall \vi, \vi', \cl, \hh, \viewFun.\; 
    \viewFun(\cl) = \vi 
    \wedge \vi \sqsubseteq \vi' 
    \implies (\hh, \viewFun) \xrightarrowtriangle{(\cl, \varepsilon)}_{\ET} 
    (\hh, \viewFun\rmto{\cl}{\vi'})$
\item 
    $\begin{array}[t]{@{}l@{}}
        \forall \vi, \vi', \cl, \opset, \hh, \hh', \viewFun.\; 
        \viewFun(\cl) = \vi
        \wedge (\ET \vdash (\hh, \vi) \triangleright \opset: \vi')  \\
        \quad {} \wedge \hh' \in \updateKV(\hh, \vi, \cl, \opset) 
        \implies (\hh, \viewFun) \xrightarrowtriangle{(\cl, \opset)}_{\ET} (\hh', \viewFun\rmto{\cl}{\vi'})
    \end{array}$
\end{itemize}
Such relations take the name of $\ET$-reductions, or simply reductions.
\end{definition}
Given an execution test $\ET$, sequences of $\ET$-reductions of the form $\conf_{0} \xrightarrowtriangle{\alpha_{0}}_{\ET} \cdots 
\xrightarrow{\alpha_{n-1}} \conf_{n}$ take the name of \emph{$\ET$-traces}.
\begin{definition}[Consistency Models]
\label{def:cm}
Given an execution test $\ET$, the set of configurations induced by $\ET$ is given by:
\[
\Confs(\ET) \defeq \Setcon{ \conf}{ \exsts{\conf_0} \conf_0 \text{ is initial } \wedge \conf_0 \xrightarrowtriangle{\stub}_{\ET} \cdots \xrightarrowtriangle{\stub}_{\ET} \conf }
\]
The \emph{consistency model} induced by $\ET$ is:
\( 
\CMs(\ET) \defeq \Setcon{ \hh }{ (\hh, \stub) \in \Confs(\ET) }
\)
\end{definition}
Thus, consistency models are computed from execution tests by closing the set of initial key-value stores with respect to two operations: 
\textbf{(i)} advancing the view of a client, 
and \textbf{(ii)} committing a fingerprint of a transaction. 

Last, for sanity check, consistency models induced by execution tests are monotonic in the following sense.
\begin{proposition}
\label{prop:mono-et}
Let $\ET_1 \subseteq \ET_2$. Then $\CMs(\ET_1) \subseteq \CMs(\ET_2)$.
\end{proposition}
\begin{proof}
    \ifTechReport
    \input{\RootPath/semantics/et-mono.tex}
    \else
    See \cref{sec:mono-et}.
    \fi
\end{proof}
