\subsection{Transactional Causal Consistency}
\begin{figure}
\centering
\hrule\vspace{5pt}
\begin{tabular}{@{} c @{} c @{}}
\begin{halfsubfig}
\begin{centertikz}

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines

%Location x
\node(locx) {$\ke_\vx \mapsto$};

\matrix(versionx) [version list]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ \\
    {a} & $\emptyset$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{0};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_{\vy} \mapsto$};
\matrix(versiony) [version list]
    at ([xshift=\tikzkvspace]locy.east) {
    {a} & $\txid_0$ \\
    {a} & $\emptyset$ \\
};
\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{0};

% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
([xshift=-2pt, yshift=20pt]locx-v0.north east) node (tid1start) {} -- 
([xshift=-2pt, yshift=-5pt]locy-v0.south east);
 
\path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\thid_3$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
([xshift=-5pt, yshift=5pt]locx-v0.north east) -- 
([xshift=-5pt, yshift=-10pt]locy-v0.south east) node (tid2start) {};
 
\path (tid2start) node[anchor=north, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\thid_2$};
 
 %green view
\draw[-, DarkGreen, very thick, rounded corners = 10pt]
([xshift=-16pt, yshift=8pt]locx-v0.north east) node (tid3start) {}-- 
([xshift=-16pt, yshift=-5pt]locy-v0.south east);
 
\path (tid3start) node[anchor=south, rectangle, fill=DarkGreen!20, draw=DarkGreen, font=\small, inner sep=1pt] {$\thid_1$};

\end{pgfonlayer}
\end{centertikz}
\caption{}
\label{fig:cc-exec-a}
\end{halfsubfig}
&

\begin{halfsubfig}
\begin{centertikz}

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\ke_{\vx} \mapsto$};

\matrix(versionx) [version list]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\tsid_0$ & {a} & $\tsid_1$\\
    {a} & $\emptyset$ & {a} & $\emptyset$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{0};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{1};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_{\vy} \mapsto$};
\matrix(versiony) [version list]
   at ([xshift=\tikzkvspace]locy.east) {
 {a} & $\tsid_0$ \\
   {a} & $\emptyset$ \\
};
\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{0};

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
([xshift=-2pt, yshift=20pt]locx-v0.north east) node (tid1start) {} -- 
([xshift=-2pt, yshift=-5pt]locy-v0.south east);
 
\path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\thid_3$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
([xshift=-5pt, yshift=5pt]locx-v0.north east) -- 
([xshift=-5pt, yshift=-10pt]locy-v0.south east) node (tid2start) {};
 
\path (tid2start) node[anchor=north, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\thid_2$};
 
 %green view
\draw[-, DarkGreen, very thick, rounded corners = 10pt]
([xshift=-16pt, yshift=8pt]locx-v1.north east) node (tid3start) {}-- 
([xshift=-16pt, yshift=-5pt]locx-v1.south east) --
([xshift=-16pt, yshift=5pt]locy-v0.north east) -- 
([xshift=-16pt, yshift=-5pt]locy-v0.south east);
 
\path (tid3start) node[anchor=south, rectangle, fill=DarkGreen!20, draw=DarkGreen, font=\small, inner sep=1pt] {$\thid_1$};

\end{pgfonlayer}
\end{centertikz}
\caption{}
\label{fig:cc-exec-b}
\end{halfsubfig}
\\
\begin{halfsubfig}
\begin{centertikz}
\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\ke_{\vx} \mapsto$};

\matrix(versionx) [version list]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\tsid_0$ & {a} & $\tsid_1$\\
    {a} & $\emptyset$ & {a} & $\emptyset$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{0};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{1};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_{\vy} \mapsto$};
\matrix(versiony) [version list]
   at ([xshift=\tikzkvspace]locy.east) {
 {a} & $\tsid_0$ \\
   {a} & $\emptyset$ \\
};
\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{0};

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
([xshift=-2pt, yshift=20pt]locx-v0.north east) node (tid1start) {} -- 
([xshift=-2pt, yshift=-5pt]locy-v0.south east);
 
\path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\thid_3$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
([xshift=-5pt, yshift=5pt]locx-v1.north east) -- 
([xshift=-5pt, yshift=-5pt]locx-v1.south east) --
([xshift=-5pt, yshift=3pt]locy-v0.north east) -- 
([xshift=-5pt, yshift=-10pt]locy-v0.south east) node (tid2start) {};
 
\path (tid2start) node[anchor=north, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\thid_2$};
 
%green view
\draw[-, DarkGreen, very thick, rounded corners = 10pt]
([xshift=-16pt, yshift=8pt]locx-v1.north east) node (tid3start) {}-- 
([xshift=-16pt, yshift=-5pt]locx-v1.south east) --
([xshift=-16pt, yshift=5pt]locy-v0.north east) -- 
([xshift=-16pt, yshift=-5pt]locy-v0.south east);
 
\path (tid3start) node[anchor=south, rectangle, fill=DarkGreen!20, draw=DarkGreen, font=\small, inner sep=1pt] {$\thid_1$};

\end{pgfonlayer}
\end{centertikz}
\caption{}
\label{fig:cc-exec-c}
\end{halfsubfig}
&
\begin{halfsubfig}
\begin{centertikz}

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\ke_{\vx} \mapsto$};

\matrix(versionx) [version list]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\tsid_0$ & {a} & $\tsid_1$\\
    {a} & $\emptyset$ & {a} & $\Set{\txid_{2}}$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{0};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{1};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_{\vy} \mapsto$};
\matrix(versiony) [version list]
    at ([xshift=\tikzkvspace]locy.east) {
    {a} & $\tsid_0$ & {a} & $\tsid_2$ \\
    {a} & $\emptyset$ & {a} & $\emptyset$\\
};
\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{0};
\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{1};

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
([xshift=-2pt, yshift=20pt]locx-v0.north east) node (tid1start) {} -- 
([xshift=-2pt, yshift=-5pt]locy-v0.south east);
 
\path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\thid_3$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
([xshift=-5pt, yshift=5pt]locx-v1.north east) -- 
([xshift=-5pt, yshift=-10pt]locy-v1.south east) node (tid2start) {};
 
\path (tid2start) node[anchor=north, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\thid_2$};
 
 %green view
\draw[-, DarkGreen, very thick, rounded corners = 10pt]
([xshift=-16pt, yshift=8pt]locx-v1.north east) node (tid3start) {}-- 
([xshift=-16pt, yshift=-5pt]locx-v1.south east) --
([xshift=-16pt, yshift=5pt]locy-v0.north east) -- 
([xshift=-16pt, yshift=-5pt]locy-v0.south east);
 
\path (tid3start) node[anchor=south, rectangle, fill=DarkGreen!20, draw=DarkGreen, font=\small, inner sep=1pt] {$\thid_1$};

\end{pgfonlayer}
\end{centertikz}
\caption{}
\label{fig:cc-exec-d}
\end{halfsubfig}
\\
\begin{halfsubfig}
\begin{centertikz}

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\ke_{\vx} \mapsto$};

\matrix(versionx) [version list]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\tsid_0$ & {a} & $\tsid_1$\\
    {a} & $\emptyset$ & {a} & $\Set{\txid_{2}}$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{0};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{1};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_{\vy} \mapsto$};
\matrix(versiony) [version list]
    at ([xshift=\tikzkvspace]locy.east) {
    {a} & $\tsid_0$ & {a} & $\tsid_2$ \\
    {a} & $\emptyset$ & {a} & $\emptyset$\\
};
\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{0};
\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{1};

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
([xshift=-2pt, yshift=20pt]locx-v0.north east) node (tid1start) {} -- 
([xshift=-2pt, yshift=-5pt]locx-v0.south east) --
([xshift=-2pt, yshift=5pt]locy-v1.north east) -- 
([xshift=-2pt, yshift=-5pt]locy-v1.south east);
 
\path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\thid_3$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
([xshift=-5pt, yshift=5pt]locx-v1.north east) -- 
([xshift=-5pt, yshift=-10pt]locy-v1.south east) node (tid2start) {};
 
\path (tid2start) node[anchor=north, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\thid_2$};
 
%green view
\draw[-, DarkGreen, very thick, rounded corners = 10pt]
([xshift=-16pt, yshift=8pt]locx-v1.north east) node (tid3start) {}-- 
([xshift=-16pt, yshift=-5pt]locx-v1.south east) --
([xshift=-16pt, yshift=5pt]locy-v0.north east) -- 
([xshift=-16pt, yshift=-5pt]locy-v0.south east);
 
\path (tid3start) node[anchor=south, rectangle, fill=DarkGreen!20, draw=DarkGreen, font=\small, inner sep=1pt] {$\thid_1$};

\end{pgfonlayer}
\end{centertikz}
\caption{}
\label{fig:cc-exec-e}
\end{halfsubfig}
&
\begin{halfsubfig}
\begin{centertikz}

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\ke_{\vx} \mapsto$};

\matrix(versionx) [version list]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\tsid_0$ & {a} & $\tsid_1$\\
    {a} & $\Set{\txid_{3}}$ & {a} & $\Set{\txid_{2}}$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{0};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{1};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_{\vy} \mapsto$};
\matrix(versiony) [version list]
    at ([xshift=\tikzkvspace]locy.east) {
    {a} & $\tsid_0$ & {a} & $\tsid_2$ \\
    {a} & $\emptyset$ & {a} & $\Set{\txid_{3}}$\\
};
\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{0};
\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{1};

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
([xshift=-2pt, yshift=20pt]locx-v0.north east) node (tid1start) {} -- 
([xshift=-2pt, yshift=-5pt]locx-v0.south east) --
([xshift=-2pt, yshift=5pt]locy-v1.north east) -- 
([xshift=-2pt, yshift=-5pt]locy-v1.south east);
 
\path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\thid_3$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
([xshift=-5pt, yshift=5pt]locx-v1.north east) -- 
([xshift=-5pt, yshift=-10pt]locy-v1.south east) node (tid2start) {};
 
\path (tid2start) node[anchor=north, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\thid_2$};
 
%green view
\draw[-, DarkGreen, very thick, rounded corners = 10pt]
([xshift=-16pt, yshift=8pt]locx-v1.north east) node (tid3start) {}-- 
([xshift=-16pt, yshift=-5pt]locx-v1.south east) --
([xshift=-16pt, yshift=5pt]locy-v0.north east) -- 
([xshift=-16pt, yshift=-5pt]locy-v0.south east);
 
\path (tid3start) node[anchor=south, rectangle, fill=DarkGreen!20, draw=DarkGreen, font=\small, inner sep=1pt] {$\thid_1$};

\end{pgfonlayer}
\end{centertikz}
\caption{}
\label{fig:cc-exec-f}
\end{halfsubfig}
\end{tabular}
\hrule\vspace{5pt}
\caption{History heaps obtained in a execution of $\prog_2$.}
\label{fig:cc.exec}
\label{fig:cc-exec}
\end{figure}


\sx{Should we give intuition about causal dependencies here ?}
The next consistency model that we are interested is \emph{transactional causal consistency} \cite{cops}. 
Intuitively, it ensures that versions read by transactions are closed with respect to \emph{causal dependencies}. 
Consider for example the following program: 
\[
    \prog_2 \equiv \begin{session}
        \begin{array}{@{}c || c || c@{}}
            \txid_{1} : 
            \begin{transaction}
                \pmutate{\vx}{1};\\
            \end{transaction} &
            \txid_{2} : 
            \begin{transaction} 
                \pderef{\pvar{a}}{\vx};\\
                \pmutate{\vy}{\pvar{a}};\\
            \end{transaction} &
            \txid_{3} :
             \begin{transaction}
               	   \pderef{\pvar{a}}{\vx};\\
               	   \pderef{\pvar{b}}{\vy};\\
               	   \pifs{\pvar{a}=0 \wedge \pvar{b}=1}\\
               			\quad \passign{\retvar}{\sadface}
               		\pife
             \end{transaction}
        \end{array}
    \end{session}
 \]
For the sake of simplicity, we label the code of the three transactions above as $\txid_{1}, \txid_2, \txid_3$ from left to right.
It is easy to see that, if no constraints or even under read atomic, the third transaction $\txid_{3}$ can return ${\sadface{}}$. 
%The same is true even if the consistency model specification $\mathsf{RA}$ is assumed. 
Informally, the return of value ${\sadface}$ by $\txid_3$ can be obtained from the execution outlined below. 
\begin{itemize}
\item The initial configuration of this execution is depicted in \figref{fig:cc-exec-a}.
\item The transaction $\txid_{1}$ executes with the initial view, which points to the initial (and only) version for each location; after this executing the transaction, a new version $( 1, \txid_1, \emptyset )$ is appended to \( \ke_\vx\) (\figref{fig:cc-exec-b}).
\item The second thread $\thid_2$ updates its view as to see the last version of $\ke_\vx$ installed by $\thid_1$ (\figref{fig:cc-exec-c}), after which it proceeds to execute transaction $\txid_{2}$. 
This results in a new version with value $1$ to be installed to the end of $\ke_\vy$ (\figref{fig:cc-exec-d}). 
\item Finally, the thread $\thid_3$ updates its view so to observe the update of location $\ke_{\vy}$, but not the update of 
location $\ke_{\vx}$ (\figref{fig:cc-exec-e}).
Then, it executes $\txid_{3}$ which will return the value ${\sadface{}}$ (\figref{fig:cc-exec-f}).
\end{itemize}

In the last step, the thread to the right commits the transaction $\txid_3$ in a state where its initial view observes the second version of the address $\vy$, which is created by \( \txid_{2} \).
However, because the transaction \( \txid_{2} \) read the second version of \( \ke_\vx \) and create the second version of \( \ke_\vy \), this means the latter depends on the former.
Yet the transaction \( \txid_{3} \) does not read from the second version of \( \ke_\vx \), which is disallowed by \emph{transactional causal consistency}.
Summarising, under transactional causal consistency if a transaction sees updates for a key \( \ke \), it should also observes those keys that \( \ke \) depends on.

\ac{
but not the update to address $\vx$.
However, the update of $[\vy]$ committed by $\txid_{2}$, consisted in copying the value of the update 
of $\ke_{\vy}$: that is, the update of $\ke_{\vy}$ \textbf{depends} from the update of $\ke_{\vx}$. 
Summarising, the execution of transaction $\ptrans{\trans_3}$ resulted in a violation of 
causality: the update of $\ke_{\vy}$ is observed, but not the update of $\ke_{\vx}$ on which 
it depends.
}

\sx{What do you mean by the word above??

RA and  here  both use the consistent

maybe just use a predicate \( \pred{ccview}{\hh, \vi} \).

The arrow occupy unnecessary space, change it to a predicate.
}
To formally specify \emph{transactional causal consistency}, we inductively define the set of views that are consistent with respect to a history heap $\hh$. 
The definition below models the fact that, if we start from a causally consistent view, and we wish to update the view for some location $\txid_2$, 

\begin{defn}[Transactional causal dependency]
\label{def:causal}
Given two versions $\ver_{1} = (\val_1, \txid_1, \txidset_1)$, $\ver_2 = (\val_2, \txid_2, \txidset_2)$, $\ver_{1}$ \emph{directly depends on} $\ver_2$, written $\pred{ddep}{\ver_{1}, \ver_{2}}$, if $\txid_1 \in \txidset_2$. 
\ac{Note to self: the notion of directly depends here has little to do with dependencies 
between transactions. $\nu_1 \xrightarrow{\mathsf{ddep}} \nu_2$ means that 
some transaction $\tsid$ touches both versions. However, it reads $\nu_2$ and 
writes $\nu_1$.}
Given $\hh \in \HisHeaps$, the set of views that are \emph{causally consistent} with the history heap $\hh$, $\func{CCViews}{\hh}$, is defined as the smallest set such that: 
\begin{itemize} 
\item the initial view \( \vi_0\)  is in the set, \ie $\vi_0 \in \func{CCViews}{\hh}$ where \( \fora{\ke \in \dom(\hh)} \vi_{0}(\ke) = 1 \),
\item assume any view $\vi \in \pred{CCViews}{\hh}$ and a new view \( \vi' \) by observing one more version for an address $\vi' = \vi\rmto{\ke}{\vi(\ke) + 1}$, where \( \vi'(\ke) \leq \left| \hh(\ke) \right| \).
If some versions directly depend on the version corresponding to \( \vi'(\ke)\) and those versions are aware by \( \vi'\), the new view is included in \( \func{CCViews}{\hh}\),
\[
\begin{array}{@{}l}
\fora{\vi,\vi'} \exsts{\ke}
\vi \in \func{CCViews}{\hh} 
\land \ke \in \dom(\vi)
\land \vi' = \vi\rmto{\ke}{\vi(\ke) + 1}
\land \vi'(\ke) \leq \left| \hh(\ke) \right|  \\
\quad {} \land 
\begin{B}
\fora{\ke', i}  
1 \leq i \leq \left| \hh(\ke') \right|
\land \pred{ddep}{\hh(\ke')(i), \hh(\ke)(\vi'(\ke))}
\implies i \leq \vi(\ke')
\end{B} \\
\qquad {} \implies \vi' \in \func{CCViews}{\hh}
\end{array}
\]

\end{itemize}
Causal consistency is stronger than read atomic (\defref{def:readatomic}) by further ensuring that a transaction can only observe a causally consistent state of the database, i.e. the view when the transaction starts is causally consistent with the history heap,
\[
\begin{rclarray}
    (\hh, \vi) \csat[\mathsf{CC}] \opset : \vi' & \defeq & (\hh, \vi) \csat[\mathsf{CC}] \opset : \vi' \land \vi \in \func{CCViews}{\hh}
\end{rclarray}
\]
\end{defn}

\begin{figure}
\centering
\hrule\vspace{5pt}
\begin{tabular}{@{} c @{} c @{}} 


\begin{halfsubfig}
\begin{centertikz}

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\ke_{\vx} \mapsto$};

\matrix(versionx) [version list]
   at ([xshift=\tikzkvspace]locx.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_1$\\
  {a} & $\emptyset$ & {a} & $\Set{\tsid_2}$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{\stub};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{\stub};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_{\vy} \mapsto$};
\matrix(versiony) [version list]
    at ([xshift=\tikzkvspace]locy.east) {
    {a} & $\tsid_0$ & {a} & $\tsid_2$ \\
    {a} & $\emptyset$ & {a} & $\Set{\tsid_3}$\\
};

\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{\stub};
\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{\stub};

%Location z

\path (locy.south) + (0,\tikzkeyspace) node (locz) {$\ke_\vz \mapsto$};
\matrix(versionz) [version list]
    at ([xshift=\tikzkvspace]locz.east) {
    {a} & $\tsid_0$ & {a} & $\tsid_3$ \\
    {a} & $\emptyset$ & {a} & $\emptyset$\\
};

\tikzvalue{versionz-1-1}{versionz-2-1}{locz-v0}{\stub};
\tikzvalue{versionz-1-3}{versionz-2-3}{locz-v1}{\stub};

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
([xshift=-5pt, yshift=5pt]locx-v0.north east) node (tid1start) {} -- 
([xshift=-5pt, yshift=-5pt]locz-v0.south east);
 
% \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\thid_3$};
\end{pgfonlayer}
\end{centertikz}
\caption{}
\label{fig:cc-view-a}
\end{halfsubfig}
&
\begin{halfsubfig}
\begin{centertikz}

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\ke_{\vx} \mapsto$};

\matrix(versionx) [version list]
   at ([xshift=\tikzkvspace]locx.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_1$\\
  {a} & $\emptyset$ & {a} & $\Set{\tsid_2}$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{\stub};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{\stub};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_{\vy} \mapsto$};
\matrix(versiony) [version list]
    at ([xshift=\tikzkvspace]locy.east) {
    {a} & $\tsid_0$ & {a} & $\tsid_2$ \\
    {a} & $\emptyset$ & {a} & $\Set{\tsid_3}$\\
};

\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{\stub};
\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{\stub};

%Location z

\path (locy.south) + (0,\tikzkeyspace) node (locz) {$\ke_\vz \mapsto$};
\matrix(versionz) [version list]
    at ([xshift=\tikzkvspace]locz.east) {
    {a} & $\tsid_0$ & {a} & $\tsid_3$ \\
    {a} & $\emptyset$ & {a} & $\emptyset$\\
};

\tikzvalue{versionz-1-1}{versionz-2-1}{locz-v0}{\stub};
\tikzvalue{versionz-1-3}{versionz-2-3}{locz-v1}{\stub};

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
([xshift=-5pt, yshift=5pt]locx-v1.north east) node (tid1start) {} -- 
([xshift=-5pt, yshift=-5pt]locx-v1.south east) --
([xshift=-5pt, yshift=5pt]locy-v0.north east) -- 
([xshift=-5pt, yshift=-5pt]locz-v0.south east);
 
% \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\thid_3$};
\end{pgfonlayer}
\end{centertikz}
\caption{}
\label{fig:cc-view-b}
\end{halfsubfig}
\\
\begin{halfsubfig}
\begin{centertikz}

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\ke_{\vx} \mapsto$};

\matrix(versionx) [version list]
   at ([xshift=\tikzkvspace]locx.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_1$\\
  {a} & $\emptyset$ & {a} & $\Set{\tsid_2}$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{\stub};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{\stub};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_{\vy} \mapsto$};
\matrix(versiony) [version list]
    at ([xshift=\tikzkvspace]locy.east) {
    {a} & $\tsid_0$ & {a} & $\tsid_2$ \\
    {a} & $\emptyset$ & {a} & $\Set{\tsid_3}$\\
};

\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{\stub};
\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{\stub};

%Location z

\path (locy.south) + (0,\tikzkeyspace) node (locz) {$\ke_\vz \mapsto$};
\matrix(versionz) [version list]
    at ([xshift=\tikzkvspace]locz.east) {
    {a} & $\tsid_0$ & {a} & $\tsid_3$ \\
    {a} & $\emptyset$ & {a} & $\emptyset$\\
};

\tikzvalue{versionz-1-1}{versionz-2-1}{locz-v0}{\stub};
\tikzvalue{versionz-1-3}{versionz-2-3}{locz-v1}{\stub};

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
([xshift=-5pt, yshift=5pt]locx-v1.north east) node (tid1start) {} -- 
([xshift=-5pt, yshift=-5pt]locy-v1.south east) --
([xshift=-5pt, yshift=5pt]locz-v0.north east) -- 
([xshift=-5pt, yshift=-5pt]locz-v0.south east);
 
% \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\thid_3$};
\end{pgfonlayer}
\end{centertikz}
\caption{}
\label{fig:cc-view-c}
\end{halfsubfig}
&
\begin{halfsubfig}
\begin{centertikz}

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\ke_{\vx} \mapsto$};

\matrix(versionx) [version list]
   at ([xshift=\tikzkvspace]locx.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_1$\\
  {a} & $\emptyset$ & {a} & $\Set{\tsid_2}$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{\stub};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{\stub};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_{\vy} \mapsto$};
\matrix(versiony) [version list]
    at ([xshift=\tikzkvspace]locy.east) {
    {a} & $\tsid_0$ & {a} & $\tsid_2$ \\
    {a} & $\emptyset$ & {a} & $\Set{\tsid_3}$\\
};

\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{\stub};
\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{\stub};

%Location z

\path (locy.south) + (0,\tikzkeyspace) node (locz) {$\ke_\vz \mapsto$};
\matrix(versionz) [version list]
    at ([xshift=\tikzkvspace]locz.east) {
    {a} & $\tsid_0$ & {a} & $\tsid_3$ \\
    {a} & $\emptyset$ & {a} & $\emptyset$\\
};

\tikzvalue{versionz-1-1}{versionz-2-1}{locz-v0}{\stub};
\tikzvalue{versionz-1-3}{versionz-2-3}{locz-v1}{\stub};

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
([xshift=-5pt, yshift=5pt]locx-v1.north east) node (tid1start) {} -- 
([xshift=-5pt, yshift=-5pt]locz-v1.south east);
 
% \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\thid_3$};
\end{pgfonlayer}
\end{centertikz}
\caption{}
\label{fig:cc-view-d}
\end{halfsubfig}
\end{tabular}
\hrule\vspace{5pt}
\caption{Building a causally consistent view.}
\label{fig:cc.view}
\label{fig:cc-view}
\end{figure}

\ac{Note to self: I got this example and the definition wrong several times before getting them
right. Which means that inductive definition of causally dependent views is not really that 
intuitive after all...}
Let consider the history $\hh$ in \figref{fig:cc-view-a}, where $\pred{ddep}{\hh(\ke_\vz)(1),\hh(\ke_{\vy})(1)}$, and $\pred{ddep}{\hh(\ke_{\vy})(1) ,\hh(\ke_{\vx})(1)}$.
Since the values are irrelevant, we ignore the values.
We want to find a view $\vi$ that is causal consistent and is up-to-date with the last version of key $[\ke_{\vz}]$, \ie \( \vi(\ke_\vz) = 1\).
We can construct such a view incrementally by the definition of \( \funcn{CCViews} \) function.

We start from the initial view $\vi_0$ pointing to initial versions of all keys (\figref{fig:cc-view-a}).
This view is causally consistent by definition.
As a first try, one could immediately consider a view $\vi'= \vi_0\rmto{\ke_\vz}{1}$ where the index of version for key $\ke_\vz$ is updated to $1$, but this view is not causally consistent due to \( \pred{ddep}{\hh(\ke_\vz)(1),\hh(\ke_{\vy})(1)} \) and \( \vi'(\ke_\vy) = 0\).
That is, the version of $\ke_\vz$ observed by $\vi'$ directly depends on the second version of $\ke_\vy$ that is not observed by $\vi'$.
Similarly one cannot advance the view to observe the latest version of \( \ke_\vy\) without knowing the latest version of \( \ke_\vx\).
Therefore we can only update the view $V_0$ by including the second version of $\ke_{\vx}$, \ie the new view \(\vi_1 = \vi_0\rmto{\ke_\vx}{1} \) (\figref{fig:cc-view-b}).
The new view \( \vi_1\) is causally consistent as no version directly depend on the second version of \( \ke_\vx\).
We can now update the view $\vi_1$ to include the latest version of $\ke_{\vy}$, resulting in the view $\vi_2 = \vi_1\rmto{\ke_{\vy}}{1}$ (\figref{fig:cc-view-c}). 
The view \( \vi_2\) is causally consistent as the second version of \( \ke_\vx\) is already included in the view.
Finally, the view includes the latest version of \( \ke_\vz \) (\figref{fig:cc-view-d}).
The view \( \vi_3\) is causally consistent as the second version of \( \ke_\vy\) is already included in the view.

%Because the view $\vi_0$ is causally consistent, and because all the versions on which $\hh(\ke_{\vy})(V_2(\ke_{\vy}))$ directly depends
%are observed by $V_1$, then $V_2$ is also causally consistent. Similarly, we can define 
%the view $V_3 := V_2[[\loc_z] \mapsto 1]$, depicted in Figure \ref{fig:cc.view}(d), 
%and prove that it casually consistent. 

\ac{Note to self: here there is something subtle going on. We also need to ensure that dependencies 
caused by the information flow of the program are tracked down. For example, we could have a 
transaction returning the value of a location $\ke_{\vx}$, and then another transaction copy such a value 
into another location $\ke_{\vy}$. There is a notion of dependency between $\ke_{\vx}, \ke_{\vy}$ that 
is not captured by the notion of \emph{directly depends}. On the other hand, the fact that 
stacks are thread local, and we have per-thread view monotonicity, should ensure that also program 
dependencies are preserved. A definitive proof that $\mathsf{CC}$ is equivalent to caual consistency 
specified either in terms of abstract executions or dependency graphs, would settle the argument.}

Note that, the view of $\thid_3$ in \figref{fig:cc-exec-e} is not causally consistent.
This is because $V(\ke_{\vy}) = 1$, and $V(\ke_{\vx}) = 0$. However, $\hh(\ke_{\vy})(1)$ directly depends 
on $\hh(\ke_{\vx})(1)$, which is not included in the view. 
\sx{Not sure we need the follows}
In general, the only case in which an execution of $\prog_2$ causes transaction $\ptrans{\trans_3}$ to return value $\sadface$ is when such a transaction is executed using a snapshot determined by a non-causally consistent view. 
There exists no execution of $\prog_2$ under $\mathsf{CC}$ that causes $\ptrans{\trans_3}$ to return value $\sadface$.
%if we execute the program $\prog_2$, illustrated previously in this section, under $\mathsf{CCViews}$,
%it is not possible any more to have the transaction $\ptrans{\trans_3}$ return value ${\sadface}$. 
%This is because, in order for $\ptrans{\trans_3}$ to return such a value, it must be executed in a 
%configuration such as the one of Figure \ref{fig:cc.view}(e) (only the view of $\thid_3$ is relevant here), 
%%state where the view thread of $\thid_3$ observes the update to location $\ke_{\vy}$, but not the 
%%update of $\ke_{\vx}$ from which the latter causally depends. 

%\ac{In theory, I can do better, and require that I see only the causal dependencies 
%of what I read. But at the end of the day, who cares?}

%\begin{definition}
%Let $\hh, V$ and $\ke_{\vx}$ be a history heap, a view, and a location, respectively. 
%Given two transactions $\tsid_1, \tsid_2$, we say that $\tsid_2$ write-read depends 
%on $\tsid_1$ via $\ke_{\vx}$, written $\tsid_1 \xrightarrow{\RF(\ke_{\vx})_{\hh}} \tsid_2$, 
%if there exists an index $i = 0,\cdots, \llvert \hh, \rvert -1$ such that $\hh([\loc_n])(x) = 
%(\_, \tsid_1, \mathcal{T})$, and $\tsid_2 \in \mathcal{T}$.
%\end{definition}
%
%\begin{definition}
%Let $\hh$ be a history heap, and $V$ be a view.
%Let $\ke_{\vx}$ be a location, and let 
%$(\_, \tsid, \_) := \hh([\loc_{n}])(V([\loc_{x}]))$. 
%We say that $V$ respects causality for $[\loc_{x}]$ if, 
%whenever $\tsid' \xrightarrow{\RF([\loc_{x}])}_{\tsid}'$, 
%$\hh(\ke_{\vx})(i)$ as follows: 
%\begin{enumerate}
%\end{definition}
