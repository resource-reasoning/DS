\subsection{Specification of Consistency Models using Key-value Stores}
\label{sec:execution.tests}

In this section we model how key-value stores evolve when a client commits 
the effects of a transaction.
Because we want to model different consistency models, 
this notion is parametrised by an \emph{execution test}, which determine whether 
a client may commit the effects of a transaction to the kv-store, at a given time.
Because we want to model different consistency models.

\mypar{Fingerprints} 
Formally, the effects of transactions are modelled as sets of reads \( \otR \) and writes \( \otW \)
over keys; we assume a set of \emph{operations} $\Ops \defeq \Setcon{(\otR, \ke, \val), (\otW, \ke, \val) }{ \ke \in \Keys \wedge 
\val \in \Val }$. The \emph{fingerprint} of a transaction is a set of operations $\opset \subseteq \Ops$, such that any key $\ke \in \Keys$,
\textbf{(i)} whenever $(\otR, \ke, \val_1) \in \opset$, $(\otR, \ke, \val_2) \in \opset$, then $\val_1 = \val_2$, 
and \textbf{(ii)} whenever $(\otW, \ke, \val_1) \in \opset$, $(\otW, \ke, \val_2) \in \opset$, then $\val_1 = \val_2$. 
Intuitively, $(\otR, \ke, \val) \in \opset$ means that the transaction requested to read key $\ke$ from the kv-store, 
and it fetched a version carrying value $\val$. Condition \textbf{(i)} states that there is at most one read operation per key; it  
formalises the intuition that, in our setting, 
transactions always read from an atomic snapshot of the kv-store, hence only one version will be read for key $\ke$. 
\ac{Note that I now require fingerprints to be non-empty sets of transactions. This simplifies a lot the development of 
the theory of kv-stores, and it fixes a problem that was spotted by Shale, that breaks the compositionality of 
execution tests (see later). The main reason why we allowed empty fingerprints is that in the semantics, a client can 
execute a transaction with no access to the memory. In practice, in the semantics we can require that at least 
one access to the database must be performed in transactions. This can be checked syntactically, and nobody 
should complain about that. I can put a remark about how this is a natural requirement that, if violated, 
breaks the compositionality of consistency models.\\ 
\textbf{Update 02/08/2018}: empty fingerprints are now allowed again. We still had some problems with compositionality, 
one of which has to do with the fact that we allow the view of a client over some key to move freely after executing a transaction, 
even if such a key was not accessed by the transaction. Later, I forbid this behaviour by requiring in execution tests that the 
view of an client for a given key cannot be shifted if the transaction executed by the client did not access such a key.}
%$(\otW, \ke, \val) \in \opset$ means that the transaction writes a new version, carrying value $\val$, for key $\ke$. 
Condition \textbf{(ii)} above is needed because we assume that a client either observes none or all the updates 
of a transaction; consequently, in the fingerprint of a transaction we require at most one write operation per key. 

\mypar{Committing Transactions.}
First we introduce how a client committing the effects of a transaction affects the kv-store. 
Suppose that a client $\cl$, with view $\vi$ in the kv-store $\hh$,
wants to commit the effects of a transaction whose fingerprint is $\opset$.
We model this via the function $\updateKV: \HisHeaps \times \Views \times \TxID \times \powerset{\Ops} 
\to \HisHeaps$, defined recursively below:
\begin{equation}
\begin{rclarray}         
%	 \func{updateMKVS}{., ., ., .} & : & \MKVSs \times \Views \times  \\                        
    \updateKV(\hh, \vi, \txid, \emptyset) &\defeq & \hh \\
    \updateKV(\hh, \vi, \txid, \opset \uplus \Set{(\otR, \ke, \stub)}) & \defeq &  
    \begin{array}[t]{@{}l}
        \texttt{let } (\val, \txid', \txidset) = \hh(\ke, \max_{<}(\vi(\ke))), \\
        \vilist = \hh(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val, \txid', \txidset \uplus \{ t \})}\\
        \quad \texttt{in } \updateKV(\hh\rmto{\ke}{\vilist}, \vi, \txid, \opset)
    \end{array} \\
    \updateKV(\hh, \vi, \txid, \opset \uplus \Set{(\otW, \ke, \val)} )& \defeq &  
    \begin{array}[t]{@{}l}
        \texttt{let } \hh' = \hh\rmto{\ke}{ ( \hh(\ke) \lcat (\val, \txid, \emptyset) ) } \\
        \quad \texttt{in } \updateKV(\hh', \vi, \txid, \opset)
    \end{array} 
%
\end{rclarray}
\label{eq:updatekv}
\end{equation}
In the definition above, the operator $\lcat$ is used to append a new version at the tail of 
a list of versions. Given a list of versions $\vilist = \ver_0\cdots \ver_n$ and $i=0,\cdots,n$, 
$\vilist[i \mapsto \ver]$ denotes the list of versions $\vilist' = \ver_0 \cdots \ver_{i-1} \ver \ver_{i+1} \cdots 
\ver_{n}$. 
Note that, under the assumption that fingerprints contain at most one read and one write 
operation for each key, and assuming that $\txid \notin \hh$\footnote{
Here we are committing an abuse of notation, and let $\txid \in \hh$ if there exists a key 
$\ke$ and an index $i=0,\cdots, \lvert \hh(\ke) \rvert -1$ such that $\txid \in \{\WTx(\hh(\ke, i)\} 
\cup \RTx(\hh(\ke, i))$.}, 
the function $\updateKV$ is well defined. Furthermore, 
let $\nextTxId(\cl, \hh) \defeq
\Setcon{\txid_{\cl}^{n}}{\fora{m} \txid_{\cl}^{m} \in \hh \implies m < n }$, 
and suppose that $\txid \in \nextTxId(\cl, \hh)$ for some $\cl$;
then $\updateKV(\hh, \ver, \txid, \opset)$ produces a valid kv-store according to \cref{def:mkvs}.
In the following, we commit an abuse of notation and write $\updateKV(\hh, \vi, \cl, \opset)$ 
for the set $\{\hh' \mid \exsts { \txid \in \nextTxId(\cl, \mkvs) } \hh' = \updateKV(\hh, \vi, \txid, \opset)\}$.

Let us discuss how kv-stores in $\updateKV(\hh, \vi, \cl, \opset)$ are computed. 
Suppose that client \( \cl \) wants to commit a transaction.
First, we select a fresh transaction identifier $\txid \in \nextTxId(\cl, \hh)$ that we associate 
with the fingerprint to be committed into the kv-store. We choose any $\txid$ to be 
greater (w.r.t. the session order $\xrightarrow{\PO}$) than any transaction identifier 
of the form $\txid_{\cl}^{n}$ (indexed by the same client) appearing in $\hh$,
as to reflect the fact that $\txid$ is the most recent transaction executed by $\cl$.
Then for every read operation $(\otR, \ke, \stub)$ in $\opset$,
the set of transactions reading the  $\max_{<}(\vi(\ke))$-th version of $\ke$ is extended with $\txid$.
Because a transaction reads the values of keys from the atomic 
snapshot determined by the view of the client, the version read by $\txid$ for key $\ke$ 
corresponds to $\hh(\ke, \max_{<}(\vi(\ke)))$.
For every write operation $(\otW, \ke, \val)$ in fingerprint $\opset$, 
the list of versions $\mkvs(\ke)$ is extended with a new version $(\val, \txid, \emptyset)$, 
denoting that $\txid$ is responsible for creating this version which has no readers as of yet. 
Note that the assumption that versions of 
a given key are totally ordered and consistent with the order in which 
transactions commit is standard \cite{adya,framework-concur,seebelieve}. 

The \cref{prop:updatekv.comm} captures that
if two different clients $\cl_1$ and $\cl_2$ commit transactions 
whose fingerprints $\opset_1$ and $\opset_2$ do not contain a write 
to the same key, then the order in which the updates are executed is 
not relevant. 
\begin{proposition}
\label{prop:updatekv.comm}
\label{prop:swap-update}
Let $\hh \in \HisHeaps$, $\vi_1, \vi_2 \in \Views(\hh)$ and let $\cl_1, \cl_2 \in \Clients$ 
be such that $\cl_1 \neq \cl_2$. 
Let also $\opset_1, \opset_2 \in \powerset{\Ops}$ be such that 
whenever $(\otW, \ke, \_) \in \opset_1$ for some key $\ke$, then 
$(\otW, \ke, \val) \notin \opset_2$ for all $\val \in \Val$. Then 
\[
\begin{array}{l}
\{ \updateKV(\hh_1, \vi_2, \cl_2, \opset_2) \mid \hh_1 \in \updateKV(\hh, \vi_1, \cl_1, \opset_1)\} = \\
\{ \updateKV(\hh_2, \vi_1, \cl_1, \opset_1) \mid \hh_2 \in \updateKV(\hh, \vi_2, \cl_2, \opset_2)\}\\
\end{array}
\]
\end{proposition}
\begin{proof}
    See \cref{sec:comm-updatekv}.
\end{proof}

\mypar{Execution Tests and Specification of Consistency Models.}
Formally, a \emph{consistency model} $\CMs$ is a 
set of kv-stores. Each $\hh \in \CMs$ represents a possible scenario that 
can be obtained as a result of multiple clients committing transactions. 
For example, \emph{serialisability} can be described as the set 
of kv-stores for which it is possible to recover a total schedule of transactions, 
such that each read operation on key $\ke$ fetches its value from the 
most recent write on the same key \cite{??????}.
In this sense, the kv-store $\hh$ from \cref{fig:hheap-a} is not serialisable: 
transaction $\txid_1$ reads the initial version carrying value $\val'_0$ for key $\ke_{2}$, 
and installs a new version of $\ke_{2}$ carrying value $\val_1$. The transaction $\txid_2$ 
reads the initial version carrying value $\val'_0$, and therefore, 
cannot be scheduled after $\txid_1$. Similarly, $\txid_2$ cannot be scheduled after $\txid_1$.

To specify consistency models we introduce the notion of \emph{execution tests}. 
\begin{definition}
\label{def:execution.test}
\emph{An execution test} is a set of tuples $\ET \subseteq \HisHeaps \times \Views \times \powerset{\Ops} \times \Views$ 
such that whenever $(\hh, \vi, \opset, \vi') \in \ET$, then 
\textbf{(i)} for any read operations $(\otR, \ke, \val) \in \opset$ then $\hh(\ke, \max(\vi(\ke))) = \val$, 
and \textbf{(ii)}  $\forall \ke. \; \vi(\ke) \neq \vi'(\ke) \implies ( (\otR, \ke, \_) \in \opset \vee (\otW, \ke, \_)) \in \opset)$.
%\textbf{(iii)} $\forall \opset' \subseteq \opset.\; (\hh, \vi, \opset', \vi') \in \ET$
\end{definition}
\sx{The definition has a problem that for the subset \( \f'\) the post-view \( \vi' \) might point to an undefined version, I also thing it should satisfy \( \fora{\vi''} \vi \sqsubseteq \vi'' \implies (\hh, \vi, \opset', \vi'') \)}.
\ac{I removed this condition, as I do not think that it was used anywhere. The new definition requires that 
you cannot change the view for keys that you do not read nor write.}
\sx{The current \CP will not satisfy the \textbf{(ii)}. }
Let $\ET$ be an execution test, and then $(\hh, \vi, \opset, \vi') \in \ET$ means 
that a client whose view over the kv-store $\hh$ is $\vi$, can commit a 
transaction whose fingerprint is $\opset$; as a result of this operation, the 
view of the client must be updated to $\vi'$.
Henceforth, we adopt the 
more suggestive notation $\ET \vdash (\hh, \vi) \triangleright \opset: \vi'$ 
in lieu of $(\hh, \vi, \opset, \vi') \in \ET$.

Execution tests induce \emph{consistency models} \( \CMs(\ET) \) as defined in \cref{def:cm}.
\begin{definition}
\label{def:reduction}
Let $\cl$ be a client and $\opset$ be a fingerprint. 
An \emph{action} has either the form $(\cl, \varepsilon)$, 
or $(\cl, \opset)$. 
Let $\mathsf{Act}$ be the set of actions.
Given an execution test $\ET$, for any action $\alpha \in \Act$ the action-labelled 
relation $\xrightarrowtriangle{\alpha}_{\ET} \subseteq \Confs \times \Confs$ is defined
as the smallest relation such that:
\begin{itemize}
\item $\forall \vi, \vi', \cl, \hh, \viewFun.\; \viewFun(\cl) = \vi \wedge \vi \sqsubseteq \vi' \implies (\hh, \viewFun) \xrightarrowtriangle{(\cl, \varepsilon)}_{\ET} 
(\hh, \viewFun\rmto{\cl}{\vi'})$, 
\item $\forall \vi, \vi', \cl, \opset, \hh, \hh', \viewFun.\; \viewFun(\cl) = \vi \wedge (\ET \vdash (\hh, \vi) \triangleright \opset: \vi') \wedge 
\hh' \in \updateKV(\hh, \vi, \cl, \opset) \implies (\hh, \viewFun) \xrightarrowtriangle{(\cl, \opset)}_{\ET} (\hh', \viewFun\rmto{\cl}{\vi'})$.
\end{itemize}
Such relations take the name of $\ET$-reductions, or simply reductions.
\end{definition}
Given an execution test $\ET$, sequences of $\ET$-reductions of the form $\conf_{0} \xrightarrowtriangle{\alpha_{0}}_{\ET} \cdots 
\xrightarrow{\alpha_{n-1}} \conf_{n}$ take the name of \emph{$\ET$-traces}.
\begin{definition}
\label{def:cm}
Given an execution test $\ET$, the set of configurations induced by $\ET$ is given by:
\[
\Confs(\ET) \defeq \Setcon{ \conf}{ \exsts{\conf_0} \conf_0 \text{ is initial } \wedge \conf_0 \xrightarrowtriangle{\stub}_{\ET} \cdots \xrightarrowtriangle{\stub}_{\ET} \conf }
\]
The \emph{consistency model} induced by $\ET$ is defined as:
\( 
\CMs(\ET) \defeq \Setcon{ \hh }{ (\hh, \stub) \in \Confs(\ET) }
\)
\end{definition}
Thus, consistency models are computed from execution tests by closing the set of initial kv-stores with 
respect to two operations: \textbf{(i)} replacing the view of a client on the kv-store with a more up-to-date one, 
and \textbf{(ii)} committing the effects of a transaction. 

Consistency models induced by execution tests are monotonic in the following sense.
\begin{proposition}
\label{prop:mono-et}
Let $\ET_1 \subseteq \ET_2$. Then $\CMs(\ET_1) \subseteq \CMs(\ET_2)$.
\end{proposition}
\begin{proof}
    See \cref{sec:mono-et}.
\end{proof}

For technical reasons, it will be convenient to adopt a reduction strategy for inferring kv-stores induced by an 
execution test: such an execution strategy require that clients only commit transactions with non-empty fingerprints, 
and a client updates its view only immediately before committing a transaction. 
The next proposition states that all kv-stores induced by an execution test $\ET$ can be 
obtained via a sequence of reductions that adhere to the reduction strategy outlined above. 
\begin{definition}
Let $\ET$ be an execution test. The $\ET$-trace
\[
\conf_0 \xrightarrowtriangle{\alpha_0}_{\ET} \conf_1 \xrightarrowtriangle{\alpha_1}_{\ET} \cdots \xrightarrowtriangle{\alpha_{2n}}_{\ET} \conf_{2n + 1}
\]
is in \emph{normal form} if \textbf{(i)} $\conf_0$ is initial, and 
\textbf{(ii)} $\forall i=0,\cdots, n$ there exists a client $\cl_i$ and set of operations $\opset_{i}$ such that 
$\alpha_{2 \cdot i} = (\cl_{i}, \varepsilon)$, and $\alpha_{2 \cdot i + 1}$ is defined and equal to $(\cl_{i}, \opset_{i})$ where \( \f_i \neq \emptyset \).
\end{definition}

\begin{proposition}
\label{prop:et.normalform}
Let $\ET$ be an execution test, and suppose that $\hh \in \CMs(\ET)$. Then there exists a $\ET$-trace  
\[
(\hh_0, \viewFun_0) \xrightarrowtriangle{\stub}_{\ET} \cdots \xrightarrowtriangle{\stub}_{\ET} (\hh_n, \viewFun_{n})
\]
that is in normal form, and such that $\hh_{n} = \hh$.
\end{proposition}
\begin{proof}
    See \cref{sec:normal-form-exist}.
\end{proof}

%Note that specifications of consistency models using execution tests 
%are compositional in the following way: 
%
%\begin{proposition}
%\label{prop:et.compositional}
%Let $\ET_1, \ET_2$ be two execution tests. Then $\CMs(\ET_1 \cap \ET_2) = \CMs(\ET_1) \cap \CMs(\ET_2)$.
%\end{proposition}
%
%\begin{example}
%Let $\ET_{\top} = \HisHeaps \times \viewSet \times \powerset{\Ops} \times \viewSet$ 
%be the most permissive execution test. Note that \cref{prop:et.compositional} ensures 
%that, for any execution test $\ET$, then $\CMs(\ET) \subseteq \CMs(\ET_{\top})$. 
%Consider the kv-store $\hh$ from \cref{fig:hheap-a}. 
%If we assume that $\val'_0 = \val_0$, and $\val_0$ is the initial value of kv-stores, 
%then $\hh$ is included in $\CMs(\ET_{\top})$. 
%In fact, let $\opset_1 = \{(\otR, \ke_2, \val'_0), (\otW, \ke_1, \val_1)\}$, 
%$\opset_2 = \{(\otR, \ke_1, \val_0), (\otW, \ke_2, \val'_1)\}$, and 
%$\vi = [\ke_1 \mapsto 0, \ke_2 \mapsto 0]$. Assuming that 
%$\hh_0$ is the initial kv-store with $\dom(\hh_0) = \{ \ke_1, \ke_2\}$, 
%then $\updateKV(\updateKV(\hh_0, \vi, \_, \opset_1), \vi, \_, \opset_2)$ 
%generates exactly the kv-store $\hh$, provided that transaction identifiers 
%$\txid, \txid'$ are consistent with the clients that committed $\opset_1, \opset_2$, 
%respectively.
%\end{example}
%\ac{Looking at compositionality gets us into problems that we will never solve before 
%the deadline.}

\mypar{Compositionality for Execution Tests.} 
A desirable property that one would request from execution 
test is compositionality: the consistency model induced by 
a composite execution test can be recovered from the consistency 
models generated by each execution test: that is, 
\[ 
\forall \ET_1, \ET_2. \CMs(\ET_1 \cap \ET_2) = \CMs(\ET_1) \cap \CMs(\ET_2).
\]
Unfortunately, this property is not satisfied by execution tests in their 
most general setting, as the following example shows: 
\begin{example}
\label{ex:noncompositional.et}
Define the following terms: 
\[
\begin{array}{lcl}
\hh_0 &=& [\ke_1 \mapsto (\val_0, \txid_0, \emptyset) , \ke_2 \mapsto (\val_0, \txid_0, \emptyset)]\\
\hh_1 &=& \big[\ke_1 \mapsto \big( (\val_0, \txid_0, \emptyset) \lcat (\val_2, \txid_{\cl_1}^{1}, \emptyset)\big) , \ke_2 \mapsto (\val_0, \txid_0, \emptyset) \big]\\
\hh_2 &=& \big[\ke_1, \mapsto (\val_0, \txid_0, \emptyset), \ke_2 \mapsto \big( (\val_0, \txid_0, \emptyset) \lcat (\val_2, \txid_{\cl_2}^{1}, \emptyset) \big) \big]\\
\hh_3 &=& \big[\ke_1 \mapsto \big( (\val_0, \txid_0, \emptyset) \lcat (\val_2, \txid_{\cl_1}^{1}, \emptyset)\big), 
                         \ke_2 \mapsto \big( (\val_0, \txid_0, \emptyset) \lcat (\val_2, \txid_{\cl_2}^{1}, \emptyset) \big) \big]\\
&&\\
\vi_0 &=& [\ke_1 \mapsto \{0\}, \ke_2 \mapsto \{0\}]\\
\viewFun_0 &=& [\cl_1 \mapsto \vi_0, \cl_2 \mapsto \vi_0]\\
&&\\
\ET_1 &\vdash& (\hh_0, \vi_0) \triangleright \{(\otW, \ke_1, \val_1)\} : \vi_0\\
\ET_1 &\vdash& (\hh_1, \vi_0) \triangleright \{(\otW, \ke_2, \val_2)\} : \vi_0\\
&&\\
\ET_2 &\vdash& (\hh_0, \vi_0) \triangleright \{(\otW, \ke_2, \val_2)\} : \vi_0\\
\ET_2 &\vdash& (\hh_2, \vi_0) \triangleright \{(\otW, \ke_1, \val_1)\} : \vi_0.
\end{array}
\]
There are no further constraints on $\ET_1, \ET_2$.
For $\ET_1$ and $\ET_2$, we have that 
\[
\begin{array}{l}
(\hh_0, \viewFun_0) \xrightarrowtriangle{(\cl_1, \{(\otW, \ke_1, \val_1)\})}_{\ET_1} 
(\hh_1, \viewFun_0) \xrightarrowtriangle{(\cl_2, \{(\otW, \ke_2, \val_2)\})}_{\ET_1} (\hh_3, \viewFun_0), \\
(\hh_0, \viewFun_0) \xrightarrowtriangle{(\cl_2, \{(\otW, \ke_2, \val_2)\})}_{\ET_2} 
(\hh_2, \viewFun_0) \xrightarrowtriangle{(\cl_1, \{(\otW, \ke_1, \val_1)\})}_{\ET_2} (\hh_3, \viewFun_0).\\
\end{array}
\] 
Therefore, we have that $\hh_3 \in \CMs(\ET_1) \cap \CMs(\ET_2)$. On the other hand, it is immediate 
to observe that $\ET_1 \cap \ET_2 = \emptyset$, and therefore $\hh_3 \notin \CMs(\ET_1 \cap \ET_2)$.
\end{example}
The reason why compositionality fails, for the execution tests of \cref{ex:noncompositional.et}, 
is that both the execution tests $\ET_1, \ET_2$ require that the fingerprints 
$\{(\otW, \ke_1, \_)\}, \{(\otW, \ke_2, \_)\}$ commit in different order: in $\ET_1$, the write to $\ke_1$ must commit 
before the write to $\ke_2$, and vice versa for $\ET_2$. On the other hand, 
because the two fingerprints above do not write to the same key, 
the order in which they are committed should not be relevant: by changing the order 
in which different clients commit such fingerprints to a kv-store, the result stays the same. 
\begin{definition}
Two triples $(\cl_1, \opset_1)$ and $(\cl_2, \opset_2)$ are 
conflicting if either $\cl_1 = \cl_2$, or there exists a key $\ke$ such that 
$(\otW, \ke, \_) \in \opset_1, (\otW, \ke, \_) \in \opset_2$. 

An execution test is $\ET$ is \emph{commutative} if, whenever $(\cl_1, \vi_1, \opset_1)$, 
$(\cl_2, \vi_2, \opset_2)$ are non-conflicting, and $\vi_1, \vi_2 \in \Views(\hh_0)$,  
then for any $\hh_0, \hh', \viewFun, \viewFun'$ we have that 
\[
\begin{array}{lr}
(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_1, \opset_1)}
\_ \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} (\hh', \viewFun') &\implies \\
(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} 
\_ \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} (\hh', \viewFun')
\end{array}
\]
\end{definition}
\ac{Note that the views are not part of actions anymore. Furthermore, the definition 
of $\ET$-reduction has been changed, so that no view shifts can be made prior to 
committing a transaction, in the reductions above.}

Requiring execution tests to be commutative is a necessary step for ensuring 
that the specification of consistency models are compositional. However, it 
is not sufficient. The next example shows how compositionality fails 
for commutative execution tests. 

\begin{example}
\label{ex:noblindwrites}
For any $n \in \Nat$, let $[n] = \{0,\cdots, n\}$.
Consider the execution tests $\ET_1, \ET_2$ defined below: 
\[
\begin{array}{lcl}
\ET_1 \vdash (\hh, \vi) \triangleright \opset : \vi' &\iff& 
\forall \ke.\;(\otW, \ke, \_) \in \opset \implies \vi(\ke) = \vi'(\ke) = [0]\\
\ET_2 \vdash (\hh, \vi) \triangleright \opset : \vi'(\ke) &\iff& 
\forall \ke. \;(\otW, \ke, \_ ) \in \opset \implies \vi(\ke) = [ \lvert \hh(\ke) \rvert - 1] \wedge \vi'(\ke) = [\lvert \hh(\ke) \rvert ] \\
\end{array}
\]
It is immediate to observe that both $\ET_1$ and $\ET_2$ are commutative. However, 
consider the kv-store $\hh_2 = [\ke \mapsto (\val_0, \txid_0, \emptyset) \lcat (\val_1, \txid_{\cl}^1, \emptyset) \lcat (\val_2, \txid_{\cl}^2, \emptyset)]$. 
We have that $\hh \in \CMs(\ET_1)$ and $\hh \in \CMs(\ET_2)$.
Let in fact $\hh_1 = [\ke \mapsto (\val_0, \txid_0, \emptyset) \lcat (\val_1, \txid_{\cl}^1, \emptyset)]$, $\vi_{i} = [\ke \mapsto [i] ]$.
\ac{Seriously, square brackets are being used everywhere (though all of this is standard notation. Maybe $\langle n \rangle$ for $\{0,\cdots, n\}$ is 
a better notation?
\sx{  \( \ke \mapsto \langle n \rangle \) is cool. }
}
We have the following sequences of reductions: 
\[
\begin{array}{l}
(\hh_0, \vi_0) \xrightarrowtriangle{(\cl, \{(\otW, \ke, \val_1)\})}_{\ET_1} 
(\hh_1, \vi_0) \xrightarrowtriangle{(\cl,\{(\otW, \ke, \val_2)\})}_{\ET_1} (\hh_2, \vi_0)\\
(\hh_0, \vi_0) \xrightarrow{(\cl, \{(\otW, \ke, \val_1)\})}_{\ET_2} (\hh_1, \vi_1) \xrightarrow{(\cl, \{(\otW, \ke, \val_2)\})}_{\ET_2} 
(\hh_2, \vi_2)
\end{array}
\]
On the other hand, we can observe that $\hh_2 \notin \CMs(\ET_1 \cap \ET_2)$. $\ET_1$ allows a client to 
commit a transaction if its view only includes the initial version of each key it writes. $\ET_2$ allows a client 
to commit a transaction when its view include all the versions for each key it writes. In $\ET_1 \cap \ET_2$ 
a client can commit a transaction only if the initial version of each key it writes is also the only version in the kv-store: 
as a result, $\CMs(\ET_1 \cap \ET_2)$ never contains a  kv-stores $\hh$ such that $\hh(\ke) > 1$ for some key $\ke$; 
in particular, $\hh_2 \notin \CMs(\ET_1 \cap \ET_2)$.
\end{example}
\ac{Two possible reasons why compositionality fails: because of blind writes, or because the test $\ET_1$ hinders progress, 
i.e. it is not possible to replace a view with a more up-to-date one to enable progress. We must choose which assumption 
we make on the consistency model.}

One reason why compositionality fails in \cref{ex:noblindwrites} is that the execution tests $\ET_1$ and $\ET_2$ do not contain 
any information about the the views that client $\cl$ used to commit the transactions $\txid_{\cl}^1, \txid_{\cl}^2$. 
To solve this problem we adopt the \emph{no blind writes} assumption, that requires that a client never commits 
a transaction that writes a key, without reading such a key beforehand. Many implementations of consistency models 
in distributed key-value stores respect the no blind writes assumption. 

\begin{definition}
\label{def:noblidwrites}
An execution test $\ET$ has \emph{no blind writes} if, whenever $\ET \vdash (\hh, \vi) \triangleright \opset \cup \{(\otW, \ke, \_)\} : \vi'$, 
then $(\otR, \ke, \_) \in \opset$.
\end{definition}

\begin{definition}
\label{def:et-minimum-footprint}
An execution test $\ET$ has \emph{minimum footprints} if for any \( \hh, \vi, \vi',\vi'', \f \),
\[
\begin{array}{@{}l@{}}
    ( \fora{ \ke} (\stub, \ke, \stub) \in \f \implies \vi(\ke) = \vi'(\ke) ) \land {} \\
    \quad \ET \vdash (\hh, \vi) \triangleright \opset : \vi'' \implies \ET \vdash (\hh, \vi') \triangleright \opset : \vi''
\end{array}
\]
\end{definition}

\begin{definition}
\label{def:et-continuous-postview}
An execution test $\ET$ has \emph{continuous post-views} if for any \( \hh, \vi, \vi',\vi'', \f \),
\[
\begin{array}{@{}l@{}}
    \quad \ET \vdash (\hh, \vi) \triangleright \opset : \vi' \land \vi' \sqsubseteq \vi'' \implies \ET \vdash (\hh, \vi) \triangleright \opset : \vi''
\end{array}
\]
\end{definition}

\begin{theorem}                                                                            
\label{thm:et-comm}                          
Let $\ET_1, \ET_2$ be two execution tests has no blind writes, minimum footprints and continuous post-views.
If $\ET_1$ is commutative, 
then $\CMs(\ET_1 \cap \ET_2) = \CMs(\ET_1) \cap \CMs(\ET_2)$. 
Furthermore, if $\ET_1, \ET_2$ are commutative, then $\ET_1 \cap \ET_2$ 
is commutative.
\end{theorem}
\begin{proof}
    See \cref{sec:et-comm}.
\end{proof}


