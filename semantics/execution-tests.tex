\subsection{Specification of Consistency Models using Key-value Stores}
\label{sec:execution.tests}

In this Section we model how key-value stores can evolve when a client tries to update 
the effects of a transaction. Because we want to model different consistency models, 
this notion is parameterised by an \emph{execution test}, which determine whether 
a client may apply the effects of a transaction to the kv-store, at a given time.

\paragraph{Fingerprints} 
Formally, the effects of transactions are modelled as sets of reads and writes 
over keys; we assume a set of $\Ops = \{(\otR, \ke, \val), (\otW, \ke, \val) \mid \ke \in \Keys \wedge 
\val \in \Val \}$ of operations. The \emph{fingerprint} of a transaction consists of a 
set of operations $\opset \subseteq \Ops$, such that 
\textbf{(i)} whenever $(\otR, \ke, \val_1) \in \opset$, $(\otR, \ke, \val_2) \in \opset$, then $\val_1 = \val_2$, 
and \textbf{(ii)} whenever $(\otW, \ke, \val_1) \in \opset$, $(\otW, \ke, \val_2) \in \opset$, then $\val_1 = \val_2$. 
Intuitively, $(\otR, \ke, \val) \in \opset$ means that the transaction requested to \textsf{R}ead key $\ke$ from the kv-store, 
and it fetched a version carrying value $\val$. Condition \textbf{(i)} above formalises the intuition that, in our setting, 
transactions always read from an atomic snapshot of the kv-store, hence only one version will be read for key $\ke$. 
$(\otW, \ke, \val) \in \opset$ means that the transaction writes a new version, carrying value $\val$, for key $\ke$. 
Condition \textbf{(ii)} above follows from the fact that we assume that a client either observes none or all the updates 
of a transaction, consequently we require at most one write operation per key, in the fingerprint of a transaction. 

\paragraph{Committing Transactions.}
%To model how a kv-store can evolve, we introduce two different operations over configurations: view-shifting, and transaction commit. 
%Given a configuration $(\hh, \viewFun)$, view-shifting amounts to replace the view $\vi$ of one 
%or more clients $\cl \in \dom(\viewFun)$, with a newer view $\vi'$. That is, newer versions of some key are 
%made available to clients. Formally, we let 
%\[
%\shift(\hh, \viewFun) = \{ (\hh, \viewFun') \mid \forall \cl \in \dom(\viewFun) = \dom(\viewFun') \wedge \forall \cl \in \dom(\viewFun). 
%\viewFun(\cl) \viewleq \viewFun'(\cl) \}.
%\]

The first step in describing how a kv-store can evolve under a given consistency model, 
is that of specifying howa client  committing the effects of a transaction affects the kv-store. 
Suppose that a client $\cl$, with view $\vi$ in the kv-store $\hh$,
wants to apply to said kv-store the effects of a transaction, modelled by the fingerprint $\opset$. 
We model this via the function $\updateKV: \HisHeaps \times \Views \times \Clients \times \powerset{\Ops}) 
\rightarrow \HisHeaps$, defined recursively below and discussed presently. In the following, $\nextTxId(\cl, \hh)$ denotes 
the set of transaction identifiers $\{\txid_{\cl}^{n} \mid \forall m \geq n.\; txid_{\cl}^{m} \text{ does not appear in } \hh \}$.
\[
\begin{rclarray}         
%	 \func{updateMKVS}{., ., ., .} & : & \MKVSs \times \Views \times  \\                        
    \updateKV(\hh, \vi, \txid, \emptyset) & = & \hh \\
    \updateKV(\hh, \vi, \txid, \opset \uplus \Set{(\otR, \ke, \stub)}) & = &  
    \begin{array}[t]{@{}l}
        \texttt{let } \txid \in \nextTxId(\cl, \hh), (\val, \txid', \txidset) = \hh(\ke, \vi(\ke)),  \\
        \vilist_{\ke} = \hh(\ke)\rmto{\vi(\ke)}{(\val, \txid', \txidset \uplus \{ t \})}\\
        %\hh\rmto{\ke}{%
        %   \hh(\ke)\rmto{\vi(\addr)}{%
        %      (\val, \txid', \txidset \uplus \Set{\txid}) } } \\
        \texttt{ in } \updateKV(\hh\rmto{\ke}{\vilist_{\ke}}, \vi, \txid, \opset)
    \end{array} \\
    \updateKV(\hh, \vi, \txid, \opset \uplus \Set{(\otW, \ke, \val)} & \defeq &  
    \begin{array}[t]{@{}l}
        \texttt{let } \txid \in \nextTxId(\cl, \hh), \hh' = \hh\rmto{\ke}{ ( \hh(\ke) \lcat \List{(\val, \txid, \emptyset)} ) } \\
        \texttt{ in } \updateKV(\hh', \vi, \txid, \opset)
    \end{array} 
%
\end{rclarray}
\]
In the definition above, the operator $\lcat$ is used to append a new version at the tail of 
a list of versions, while given a list of versions $\vilist = \ver_0\cdots \ver_n$ and $i=0,\cdots,n$, 
$\vilist[i \mapsto \vi]$ denotes the list of versions $\vilist' = \ver_0 \cdots \ver_{i-1} \ver \ver_{i+1} \cdots 
\ver_{n}$
Note that, under the assumption that fingerprint contain at most one read and one write 
operation for each key $\ke$, the function $\updateKV$ is well defined. Furthermore, 
$\updateKV(\hh, \ver, \txid, \opset)$ is a valid 
kv-store according to \cref{def:mkvs}.

Let us discuss how the kv-store $\updateKV(\hh, \vi, \cl, \opset)$ is computed. 
First, we select a transaction identifier $\txid \in \nextTxId(\cl, \hh)$ that we associate 
with the fingerprint to be committed into the kv-store. The fact that $\txid$ is greater, 
according to the partial order $\xrightarrow{\PO}$, than any of the transaction identifier 
of the form $\txid_{\cl}^{n}$ appearing in $\hh$, denotes the fact that $\txid$ is the 
most recent transactions executed by $\cl$.
For each read operation $(\otR, \ke, \val) \in \opset$, we need to select in $\hh$ the version 
from which $\txid$ read its value, and update the set of read transactions to include $\txid$. 
Because clients reads the values of keys in transaction, from the atomic 
snapshot determined by the view of the client, the version read by $\txid$ for key $\ke$ 
corresponds to $\hh(\ke, \vi)$. For write operations of the form $(\otW, \ke, \val)$, 
we create a new version, carrying value $\val$ and written by the transaction $\txid$, 
which is appended to the tail of $\hh(\ke)$. The assumption that versions of 
a given key are totally ordered and consistent with the order in which 
transactions commit is standard \cite{adya,framework-concur,seebelieve}. 

\paragraph{Execution Tests and Specification of Consistency Models.}
Formally, a \emph{consistency model} $\CMs$ is a 
set of kv-store. Each $\hh \in \CM$ represents a possible scenario that 
can be obtained as a result of multiple clients committing a transactions. 
For example, \emph{serialisability} can be described as the set 
of kv-stores for which it is possible to recover a total schedule of transactions, 
such that each read operation on key $\ke$ fetches its value from the 
most recent write on the same key.
In this sense, the kv-store $\hh_0$ from \cref{fig:hheap-a} is not serialisable: 
transaction $\txid_1$ reads the initial version $\val'_0$ for key $\ke_{2}$, 
and installs a new version fof $\ke_{2}$ carrying value $\val_1$. Similarly, transaction $\txid_2$ 
reads the initial version $\val'_0$, and therefore (assuming $\val_1 \neq \val'_0$), 
cannot be scheduled after $\txid_1$. Similarly, $\txid_2$ cannot be scheduled after $\txid_1$.

In implementation of protocols of distributed databases, transactions can 
commit only upon passing a \emph{commit test}. 
The nature of the commit test determines the consistency model of 
the key-value store.
Similarly, to specify consistency models we adopt the notion of 
\emph{execution tests}. An execution test 
$\ET \subseteq \HisHeaps \times \Views \times \powerset{\Ops} \times \Views$ 
is a set of tuples of the form $(\hh, \vi, \opset, \vi')$, 
which is downward-closed with respect to set inclusion over fingerprints: 
if $(\hh, \vi, \opset, \vi') \in \ET$ and $\opset' \subseteq \opset$, then 
$(\hh, \vi, \opset', \vi') \in \ET$.
Intuitively, 
$(\hh, \vi, \opset, \vi') \in \ET$ means that, under the execution test 
$\ET$, a client whose view on the kv-store $\hh$ is $\vi$ can safely 
commit a transaction with fingerprint $\opset$, and the resulting 
view for the client is updated to $\vi'$. If $\cl$ is the client executing 
the transaction, and $\txid$ is the identifier of the transaction, we can think of the view 
$\vi$ as including the versions that $\cl$ is aware of immediately before 
executing $\txid$, and of $\vi'$ as including the versions that $\cl$ is 
aware of immediately after executing $\txid$.
Henceforth, we use the more 
suggestive notation $\ET \vdash \hh, \vi \triangleright \opset : \vi'$, 
in lieu of $(\hh, \vi, \opset, \vi') \in \ET$.
Execution tests induce consistency models in the following way: 
\begin{definition}
\label{def:cm}
A kv-store $\hh$ is \emph{initial} if for any key $\ke \in \dom(\hh)$, 
$\hh(\ke) = (\val_0, \txid_0, \_)$. A configuration $\conf$ is 
initial  if $\conf = (\hh, \viewFun)$ for some initial $\hh$.
\ac{Initial kv-stores should have been defined before.}
Let $\ET$ be an execution test. The set of all configurations 
induced by $\ET$ is the smallest set $\mathsf{Configs}(\ET)$ 
such that 
\[
\begin{array}{l}
\forall \conf. \conf \text{ is initial} \implies \conf \in \mathsf{Configs}(\ET)\\
\forall \hh, \cl \viewFun,\vi'.\; (\hh, \viewFun) \in \mathsf{Configs}(\ET) \wedge \viewFun(\cl) \viewleq \vi' \implies (\hh, \viewFun\rmto{\cl}{\vi'}) \in \mathsf{Configs}(\ET)\\
\forall \hh, \cl, \viewFun, \opset, \vi, \vi'.\; \vi = (\viewFun(\cl) \wedge \ET \vdash (\hh, \vi) \triangleright \opset : \vi') \implies {}\\
\hspace{15pt}
((\updateKV(\hh, \vi, \cl, \opset), \viewFun\rmto{\cl}{\vi'} \in \mathsf{Configs}(\ET) 
\end{array}
\]

The \emph{consistency model} induced by $\ET$ is defined as 
\[
\CMs(\ET) = \{ \hh \mid \exists \vi.\; (\hh, \vi) \in \mathsf{Configs}(\ET) \}.
\]
\end{definition}

Thus, consistency models are computed from execution tests by closing the set of initial kv-stores with 
respect to two operations: replacing the view of a client on the kv-store with a newer one, and committing 
the effects of a transaction.

\paragraph{Examples of Execution Tests and Consistency Models.}

\begin{figure}
\begin{tabular}{| lr |}
\hline
\multicolumn{2}{|c|}{
Client-centric Consistency Models} \\
\hline
\textbf{Consistency Model} & \textbf{Execution Test}\\
\hline
\MRd & $\vi \viewleq \vi'$\\
%\textbf{Causal Consistency: } & $\ET_{\CC}$ & $\causalView(\vi)$\\
\MW & 
$j \leq \vi(\ke) \wedge \WTx(\hh(\ke', i)) \xrightarrow{\PO} \WTx(\hh(\ke, j)) 
\implies i \leq \vi(\ke')$
\\
\RYW & $(\otW, \ke, \_) \in \opset \implies \vi'(\ke) = \lvert \hh(\ke) \rvert$\\
\WFR & $j \leq \vi(\ke) \wedge \txid \in \RTx(\hh(\ke', i)) \wedge \txid \xrightarrow{\PO} 
\WTx(\ke, j) ) \implies i \leq \vi(\ke')$\\
\hline
\hline
\multicolumn{2}{|c|}{ Data-centric Consistency Models }\\
\hline
\textbf{Consistency Model} & \textbf{Execution Test}\\
\hline
\UA & $(\otW, \ke,  \_) \in \opset \implies \vi(\ke) = \lvert \hh(\ke) \rvert - 1$\\
%$j \leq \vi(\ke) \wedge \WTx(\hh(\ke', i)) \xrightarrow{\PO(\cl)} \WTx(\hh(\ke, j)) 
%\implies i \leq \vi(\ke')$  
\CP & $(\otW, \ke, \_) \in \opset \implies \vi'(\ke) = \lvert \hh(\ke) \rvert$\\
\SER & $\vi(\ke) = \lvert \hh(\ke) \rvert -1$\\
\hline
%\multicolumn{3}{|c|}{Composite Execution Tests}\\
%\hline
%\textbf{Consistency Model} & \textbf{Execution Test} & \textbf{Condition}\\
%\hline
%\textbf{Causal Consistency (CC)} & $\ET_{\CC}$ & $(\ET_{\MRd} \cap \ET_{\MW} \cap \ET_{\RYW} \cap \ET_{\WFR})$\\
%\textbf{Parallel Snapshot Isolation (CC)} & $\ET_{\PSI}$ & $\ET_{\CC} \cap \ET_{\UA}$\\
%\textbf{Snapshot Isolation} & $\ET_{\SI}$ & $\ET_{\CP} \cap \ET_{\UA}$\\ 
%\hline
\end{tabular}
\caption{Execution tests for both client-centric and data-centric consistency models. 
The condition column define a necessary and sufficient condition for inferring $\ET_{\CM} \vdash \hh, \vi \triangleright \opset : \vi'$,  
where $\CM$ is the consistency model from the left column.
All the variables in the formulas above are universally quantified.}
\label{fig:execution.tests}
\end{figure}

We conclude this section by analysing the consistency tests for widely adopted 
consistency models of distributed and replicated databases. These are summarised 
in \cref{fig:execution.tests}.
Following \cite{}, we distinguish among client-centric and data-centric consistency models. 
The former constrain the versions of keys that individual clients can observe, while the latter 
impose conditions on the shape of the state of the database, in our case the structure of 
the kv-store. Both kinds of models can be induced by execution tests. In \cref{sec:?} 
we prove that specification of consistency models using execution tests are both sound and complete 
with respect to alternative specifications from the literature. Due to space constraints, we only give 
examples of allowed and disallowed kv-stores for relevant consistency models. A full account 
of the anomalous behaviours permitted by each consistency model is deferred to \cref{app:?}.

\subparagraph{Monotonic Reads.} 
This is the first of four \emph{session guarantees} \cite{terry1994sessions}, i.e. guarantees on the individual behaviour of 
clients.  A client ensures the monotonic read consistency guarantee (MR) if subsequent read operations always 
return versions from a more up-to-date state of the system. Because the versions observed by a client of a kv-store 
are determined by the view of the former, monotonic reads can be enforced in our framework by ensuring that 
a client can never replace their view with an older one. According to the definition of $\CMs(\_)$, 
a client can only update its view to an older one upon committing a transaction. The definition of 
$\ET_{\MRd}$ in \cref{fig:execution.tests} forces clients to always update their views to newer ones.

\subparagraph{Monotonic Writes.}
The second session guarantee that we formalise is given by \emph{monotonic writes.} This states that 
whenever a transaction observes the effects of a version installed by some client $\cl$, then 
it must be able to observe all the previous updates performed by such a client. 
The order of updates of transaction identifiers is embedded in the set of transaction identifiers, 
and it is given by $\txid \xrightarrow{\PO} \txid' \iff \exists \cl, n,m. n < m \wedge \txid = \txid_{\cl}^{n} \wedge 
\txid' = \txid_{\cl}^{m}$. The execution test $\ET_{\MW}$ from \cref{fig:execution.tests} ensures 
that, prior to executing a transaction, the set of versions included in the view of the client 
must be prefix-closed with respect to the relation $\xrightarrow{\PO}$, thus modelling 
monotonic writes.

\subparagraph{Read Your Writes.}
The third session guarantees states that a client must always been able to read any version 
of a key that he previously wrote. Because a client always appends the version written by  
a transaction as the latest of a kv-store, to enforce this consistency guarantee we require from 
the execution test $\ET_{\RYW}$ of \cref{fig:execution.tests} that, after committing a transaction, 
a client brings its view to the latest version of each key it wrote.  

\subparagraph{Write Follow Reads}
The last session guarantee states that if a write of some version $\nu$ follows (or is performed by the same transaction performing ) 
a read of a version $\nu'$ in a session, 
then any client observing the version $\nu$ must also observe the version $\nu'$. This consistency guarantee is 
captured by th execution test $\ET_{\WFR}$ from Figure \cref{fig:execution.tests}

\ac{The session guarantees must be explained better. But for now this will do.}

\subparagraph{Causal Consistency: }
Causal Consistency requires that the observations made if a client observes a version 
$\ver$ of some key $\ke$, then it must also observe any version $\ver'$ of some key $\ke'$ 
from which $\ver$ potentially depends \cite{cops}. A necessary and sufficient condition to enforce 
causal consistency is that of enforcing the consistency guarantees $\MRd, \MW, \RYW, \WFR$ 
discussed above \cite{session2causal}. Therefore, we let $\ET_{\CC} = \ET_{\MRd} \cap \ET_{\MW} 
\cap \ET_{\RYW} \cap \ET_{\WFR}$.
%However, for the sake of completeness we prefer to 
%give a definition of execution test for causal consistency after the standard definition. 
%The notion of \emph{potential dependency} $\xrightrrow{\pdep}$ between versions is defined by 
%letting $\ver \xrightarrow{\pdep} \ver'$ if  
%$\exists \txid, \txid'. \txid \in \{\WTx(\ver)\} \cup \RTx(\ver) \wedge 
%\txid' \in \{\WTx(\ver')\} \cup \RTx(\ver') \wedge \txid \xrightarrow{\SO} \txid'$: 
%this corresponds to the intuition that operations within a session potentially depends from previous operations in the same session.
%The notion of \emph{potential data dependency} between versions is given 
%by $\ver \xrightarrow{\ddep} \ver'$ if $\WTx(\ver') \in  \RTx(\ver)$.

\subparagraph{Update Atomic.} 
This consistency model has been proposed in \cite{framework-concur}, though we 
are not aware of any implementation. However, many implemented consistency models 
can be obtained by strengthening Update Atomic. Roughly speaking, in Update Atomic 
concurrent transactions writing to the same key cannot execute concurrently; this property 
is known as write conflict detection. In the kv-stores 
framework, we can compute the set of transactions that are concurrent by transaction $\txid$ 
immediately before executing such a transaction. At the moment a client $\cl$ tries to 
commit the effects of transaction $\txid$, then any transaction $\txid'$ that read or wrote versions not included 
in the view of $\cl$ is concurrent to $\txid$. Following this intuition, we can enforce write 
conflict detection by requiring that whenever a client $\cl$ wants to commit the effect of 
transactions writing key $\ke$ in the kv-store $\hh$, then the view of $\cl$ must include all the versions of $\ke$. 
Formally, this leads to the execution test $\ET_{\UA}$ defined in \cref{fig:execution.tests}

\subparagraph{Consistent Prefix.}
This consistency model strengthens causal consistency by requiring that if a client 
sees observes the effects of a transaction $\txid$, then it also observe the effects 
of any transaction $\txid'$ that committed before $\txid$. By Looking at the structure 
of a kv-store, it is not immediate to infer a total order in which transactions have been 
executed (this problem has been analysed in a slightly different setting, see \cite{SIanalysis,laws} 
for details). An equivalent definition of consistent prefix requires that different clients 
never see updates to the kv-stores performed in different order. We can enforce this property 
by strengthening causal consistency with the requirement that clients, 
after committing the effects of a transaction, always shift their view to 
the most recent version of each key.  The execution $\ET_{\CP}$ for consistent 
prefix is defined in \cref{fig:execution.tests}.

\subparagraph{Parallel Snapshot Isolation and Snapshot Isolation.} 
These two consistency models are obtained by combining causal consistency with update atomic, 
and consistent prefix with update atomic, respectively. Formally, we have 
$\ET_{\PSI} = \ET_{\CC} \cap \ET_{\UA}$, and $\ET_{\SI} = \ET_{\CC} \cap \ET_{\UA}$.
\ac{There should be one sentence saying that we actually capture strong-session SI. 
Also, I need to check which of the four consistency guarantees are embedded in $\ET_{\UA}$. 
MR and MW are immediate; RYW and WFR should also be guaranteed.}

\subparagraph{(Strict) Serialisability}
The last consistency model that we consider is serialisability. This consistency model 
requires that there exist a serial, or sequential schedule of transaction. It can be 
enforced by requiring that clients always see the most up-to-date version of a key, 
i.e. that the view of a client before executing a transaction is always the newest one. 
The execution test $\ET_{\SER}$ of \cref{fig:exec.tests} models exactly this scenario.