\subsection{Specification of Consistency Models using Key-value Stores}
\label{sec:execution.tests}

In this section we model how key-value stores evolve when a client commits 
the effects of a transaction.
Because we want to model different consistency models, 
this notion is parametrised by an \emph{execution test}, which determine whether 
a client may commit the effects of a transaction to the kv-store, at a given time.
Because we want to model different consistency models.
%We use \emph{execution test{\color{red}s}} to model a consistency model, which determine whether 
%a client can commit the effects of a transaction to the kv-store, at a given time.

\mypar{Fingerprints} 
Formally, the effects of transactions are modelled as sets of reads \( \otR \) and writes \( \otW \)
over keys; we assume a set of \emph{operations} $\Ops = \Setcon{(\otR, \ke, \val), (\otW, \ke, \val) }{ \ke \in \Keys \wedge 
\val \in \Val }$. The \emph{fingerprint} of a transaction is a set of operations $\opset \subseteq \Ops$, such that any key $\ke \in \Keys$,
\textbf{(i)} whenever $(\otR, \ke, \val_1) \in \opset$, $(\otR, \ke, \val_2) \in \opset$, then $\val_1 = \val_2$, 
and \textbf{(ii)} whenever $(\otW, \ke, \val_1) \in \opset$, $(\otW, \ke, \val_2) \in \opset$, then $\val_1 = \val_2$. 
Intuitively, $(\otR, \ke, \val) \in \opset$ means that the transaction requested to read key $\ke$ from the kv-store, 
and it fetched a version carrying value $\val$. Condition \textbf{(i)} states that there is at most one read operation per key; it  
formalises the intuition that, in our setting, 
transactions always read from an atomic snapshot of the kv-store, hence only one version will be read for key $\ke$. 
\ac{Note that I now require fingerprints to be non-empty sets of transactions. This simplifies a lot the development of 
the theory of kv-stores, and it fixes a problem that was spotted by Shale, that breaks the compositionality of 
execution tests (see later). The main reason why we allowed empty fingerprints is that in the semantics, a client can 
execute a transaction with no access to the memory. In practice, in the semantics we can require that at least 
one access to the database must be performed in transactions. This can be checked syntactically, and nobody 
should complain about that. I can put a remark about how this is a natural requirement that, if violated, 
breaks the compositionality of consistency models.\\ 
\textbf{Update 02/08/2018}: empty fingerprints are now allowed again. We still had some problems with compositionality, 
one of which has to do with the fact that we allow the view of a client over some key to move freely after executing a transaction, 
even if such a key was not accessed by the transaction. Later, I forbid this behaviour by requiring in execution tests that the 
view of an client for a given key cannot be shifted if the transaction executed by the client did not access such a key.}
%$(\otW, \ke, \val) \in \opset$ means that the transaction writes a new version, carrying value $\val$, for key $\ke$. 
Condition \textbf{(ii)} above is needed because we assume that a client either observes none or all the updates 
of a transaction; consequently, in the fingerprint of a transaction we require at most one write operation per key. 

\mypar{Committing Transactions.}
%To model how a kv-store can evolve, we introduce two different operations over configurations: view-shifting, and transaction commit. 
%Given a configuration $(\hh, \viewFun)$, view-shifting amounts to replace the view $\vi$ of one 
%or more clients $\cl \in \dom(\viewFun)$, with a newer view $\vi'$. That is, newer versions of some key are 
%made available to clients. Formally, we let 
%\[
%\shift(\hh, \viewFun) = \{ (\hh, \viewFun') \mid \forall \cl \in \dom(\viewFun) = \dom(\viewFun') \wedge \forall \cl \in \dom(\viewFun). 
%\viewFun(\cl) \viewleq \viewFun'(\cl) \}.
%\]

%The first step in describing how a kv-store evolves under a given consistency model, 
%is that of specifying 
First we introduce how a client committing the effects of a transaction affects the kv-store. 
Suppose that a client $\cl$, with view $\vi$ in the kv-store $\hh$,
wants to commit the effects of a transaction whose fingerprint is $\opset$.
We model this via the function $\updateKV: \HisHeaps \times \Views \times \TxID \times \powerset{\Ops} 
\to \HisHeaps$, defined recursively below:
%In the following, $\nextTxId(\cl, \hh) = 
%\min(\{\txid_{\cl}^{n} \mid \forall m \geq n.\; \txid_{\cl}^{m} \text{ does not appear in } \hh \})$.
%% denotes the set of transaction identifiers that client $\cl$ can associate to the fingerprint $\opset$
%\ac{I changed the definition of nextTxID to contain exactly one transacion identifier. In this way, 
%the function updateKV is well-defined - otherwise its codomain should be a set of kv-stores.}
\begin{equation}
\begin{rclarray}         
%	 \func{updateMKVS}{., ., ., .} & : & \MKVSs \times \Views \times  \\                        
    \updateKV(\hh, \vi, \txid, \emptyset) &\defeq & \hh \\
    \updateKV(\hh, \vi, \txid, \opset \uplus \Set{(\otR, \ke, \stub)}) & \defeq &  
    \begin{array}[t]{@{}l}
        \texttt{let } (\val, \txid', \txidset) = \hh(\ke, \max(\vi(\ke))), \\
        \vilist_{\ke} = \hh(\ke)\rmto{\max(\vi(\ke))}{(\val, \txid', \txidset \uplus \{ t \})}\\
        %\hh\rmto{\ke}{%
        %   \hh(\ke)\rmto{\vi(\addr)}{%
        %      (\val, \txid', \txidset \uplus \Set{\txid}) } } \\
        \texttt{ in } \updateKV(\hh\rmto{\ke}{\vilist_{\ke}}, \vi, \txid, \opset)
    \end{array} \\
    \updateKV(\hh, \vi, \txid, \opset \uplus \Set{(\otW, \ke, \val)} & \defeq &  
    \begin{array}[t]{@{}l}
        \texttt{let } \hh' = \hh\rmto{\ke}{ ( \hh(\ke) \lcat \List{(\val, \txid, \emptyset)} ) } \\
        \texttt{ in } \updateKV(\hh', \vi, \txid, \opset)
    \end{array} 
%
\end{rclarray}
\label{eq:updatekv}
\end{equation}
In the definition above, the operator $\lcat$ is used to append a new version at the tail of 
a list of versions. Given a list of versions $\vilist = \ver_0\cdots \ver_n$ and $i=0,\cdots,n$, 
$\vilist[i \mapsto \ver]$ denotes the list of versions $\vilist' = \ver_0 \cdots \ver_{i-1} \ver \ver_{i+1} \cdots 
\ver_{n}$. 
Note that, under the assumption that fingerprints contain at most one read and one write 
operation for each key, and assuming that $\txid \notin \hh$\footnote{
Here we are committing an abuse of notation, and let $\txid \in \hh$ if there exists a key 
$\ke$ and an index $i=0,\cdots, \lvert \hh(\ke) \rvert -1$ such that $\txid \in \{\WTx(\hh(\ke, i)\} 
\cup \RTx(\hh(\ke, i))$.}, 
the function $\updateKV$ is well defined. Furthermore, 
let $\nextTxId(\cl, \hh) \defeq
\Setcon{\txid_{\cl}^{n}}{\fora{m} \txid_{\cl}^{m} \in \hh \implies m < n }$, 
and suppose that $\txid \in \nextTxId(\cl, \hh)$ for some $\cl$;
then $\updateKV(\hh, \ver, \txid, \opset)$ produces a valid kv-store according to \cref{def:mkvs}.
In the following, we commit an abuse of notation and write $\updateKV(\hh, \vi, \cl, \opset)$ 
for the set $\{\hh' \mid \exsts { \txid \in \nextTxId(\cl, \mkvs) } \hh' = \updateKV(\hh, \vi, \txid, \opset)\}$.

Let us discuss how kv-stores in $\updateKV(\hh, \vi, \cl, \opset)$ are computed. 
Suppose that client \( \cl \) wants to commit a transaction.
First, we select a fresh transaction identifier $\txid \in \nextTxId(\cl, \hh)$ that we associate 
with the fingerprint to be committed into the kv-store. We choose any $\txid$ to be 
greater (w.r.t. the session order $\xrightarrow{\PO}$) than any transaction identifier 
of the form $\txid_{\cl}^{n}$ (indexed by the same client) appearing in $\hh$,
as to reflect the fact that $\txid$ is the most recent transaction executed by $\cl$.
%according to the partial order $\xrightarrow{\PO}$, than any of the transaction identifier 
%of the form $\txid_{\cl}^{n}$ appearing in $\hh$, denotes the fact that 
Then for every read operation $(\otR, \ke, \stub)$ in $\opset$,
the set of transactions reading the  $\max(\vi(\ke))$-th version of $\ke$ is extended with $\txid$.
%For each read operation $(\otR, \ke, \val) \in \opset$, we need to select in $\hh$ the version 
%from which $\txid$ read its value, and update the set of read transactions to include $\txid$. 
Because a transaction reads the values of keys from the atomic 
snapshot determined by the view of the client, the version read by $\txid$ for key $\ke$ 
corresponds to $\hh(\ke, \max(\vi(\ke)))$.
For every write operation $(\otW, \ke, \val)$ in fingerprint $\opset$, 
the list of versions $\mkvs(\ke)$ is extended with a new version $(\val, \txid, \emptyset)$, 
denoting that $\txid$ is responsible for creating this version which has no readers as of yet. 
%For write operations of the form $(\otW, \ke, \val)$, 
%we create a new version, carrying value $\val$ and written by the transaction $\txid$, 
%which is appended to the tail of $\hh(\ke)$.
Note that the assumption that versions of 
a given key are totally ordered and consistent with the order in which 
transactions commit is standard \cite{adya,framework-concur,seebelieve}. 

Note also that if two different clients $\cl_1$ and $\cl_2$ commit transactions 
whose fingerprints $\opset_1$ and $\opset_2$ do not contain a write 
to the same key, then the order in which the updates are executed is 
not relevant. 
%\begin{proposition}
%Let $\hh \in \HisHeaps$, $\vi_1, \vi_2 \in \Views(\hh)$ and let $\txid_1, \txid_2 \in \TxID$ 
%be two transaction identifiers that do not appear in $\hh$.
%Let also $\opset_1, \opset_2 \in \powerset{\Ops}$ be such that 
%whenever $(\otW, \ke, \_) \in \opset_1$ for some key $\ke$, then 
%$(\otW, \ke, \val) \notin \opset_2$ for all $\val \in \Val$. Then 
%\[
%\begin{array}{l}
%\big( \texttt{ let } \hh_1 = \updateKV(\hh, \vi_1, \txid_1, \opset_1) 
%\texttt{ in } \updateKV(\hh_1, \vi_2, \txid_2, \opset_2) \big) = \\
%\big( \texttt{ let } \hh_2 = \updateKV(\hh, \vi_2, \txid_2, \opset_2) 
%\texttt{ in } \updateKV(\hh_1, \vi_1, \txid_1, \opset_1) \big)
%\end{array}
%\]
%\end{proposition}
\begin{proposition}
\label{prop:updatekv.comm}
\label{prop:swap-update}
Let $\hh \in \HisHeaps$, $\vi_1, \vi_2 \in \Views(\hh)$ and let $\cl_1, \cl_2 \in \Clients$ 
be such that $\cl_1 \neq \cl_2$. 
Let also $\opset_1, \opset_2 \in \powerset{\Ops}$ be such that 
whenever $(\otW, \ke, \_) \in \opset_1$ for some key $\ke$, then 
$(\otW, \ke, \val) \notin \opset_2$ for all $\val \in \Val$. Then 
\[
\begin{array}{l}
\{ \updateKV(\hh_1, \vi_2, \cl_2, \opset_2) \mid \hh_1 \in \updateKV(\hh, \vi_1, \cl_1, \opset_1)\} = \\
\{ \updateKV(\hh_2, \vi_1, \cl_1, \opset_1) \mid \hh_2 \in \updateKV(\hh, \vi_2, \cl_2, \opset_2)\}\\
\end{array}
\]
\end{proposition}

\mypar{Execution Tests and Specification of Consistency Models.}
Formally, a \emph{consistency model} $\CMs$ is a 
set of kv-stores. Each $\hh \in \CMs$ represents a possible scenario that 
can be obtained as a result of multiple clients committing transactions. 
For example, \emph{serialisability} can be described as the set 
of kv-stores for which it is possible to recover a total schedule of transactions, 
such that each read operation on key $\ke$ fetches its value from the 
most recent write on the same key \cite{}.
In this sense, the kv-store $\hh$ from \cref{fig:hheap-a} is not serialisable: 
transaction $\txid_1$ reads the initial version carrying value $\val'_0$ for key $\ke_{2}$, 
and installs a new version of $\ke_{2}$ carrying value $\val_1$. The transaction $\txid_2$ 
reads the initial version carrying value $\val'_0$, and therefore, 
cannot be scheduled after $\txid_1$. Similarly, $\txid_2$ cannot be scheduled after $\txid_1$.

%In implementation of protocols of distributed databases, transactions can 
%commit when they pass a \emph{commit test}. 
%The nature of the commit test determines the consistency model of 
%the key-value store.
To specify consistency models we adopt the notion of \emph{execution tests}. 
%\ac{I start believing that \emph{commit test} may be more appropriate}
\begin{definition}
\label{def:execution.test}
An execution test is a set of tuples $\ET \subseteq \HisHeaps \times \Views \times \powerset{\Ops} \times \Views$ 
such that whenever $(\hh, \vi, \opset, \vi') \in \ET$, then 
\textbf{(i)} whenever $(\otR, \ke, \val) \in \opset$ then $\hh(\ke, \max(\vi(\ke))) = \val$, 
and \textbf{(ii)}  $\forall \ke. \; \vi(\ke) \neq \vi'(\ke) \implies ( (\otR, \ke, \_) \in \opset \vee (\otW, \ke, \_)) \in \opset)$.
%\textbf{(iii)} $\forall \opset' \subseteq \opset.\; (\hh, \vi, \opset', \vi') \in \ET$
\end{definition}
\sx{The definition has a problem that for the subset \( \f'\) the post-view \( \vi' \) might point to an undefined version, I also thing it should satisfy \( \fora{\vi''} \vi \sqsubseteq \vi'' \implies (\hh, \vi, \opset', \vi'') \)}.
\ac{I removed this condition, as I do not think that it was used anywhere. The new definition requires that 
you cannot change the view for keys that you do not read nor write.}
Let $\ET$ be an execution test: $(\hh, \vi, \opset, \vi') \in \ET$ means 
that a client whose view over the kv-store $\hh$ is $\vi$, can commit a 
transaction whose fingerprint is $\opset$; as a result of this operation, the 
view of the client is updated to $\vi'$. Henceforth, we adopt the 
more suggestive notation $\ET \vdash (\hh, \vi) \triangleright \opset: \vi'$ 
in lieu of $(\hh, \vi, \opset, \vi') \in \ET$.
%\begin{itemize}
%\item $\mkvs$ denotes the kv-store, 
%\item $\vi$ denotes the \emph{initial} view, recorded at the beginning of the transactions; 
%\item $\opset$ denotes the fingerprint of the transaction; and 
%\item $\vi'$ denotes the \emph{final} view of the transaction, obtained after committing the transaction.
%\end{itemize}
%Tuples from an execution test satisfy that
%\textbf{(i)} whenever $(\otR, \ke, \val) \in \opset$ then $\hh(\ke, \vi) = \val$, and \textbf{(ii)} 
%it is downward-closed with respect to inclusion over fingerprints: 
%if $(\hh, \vi, \opset, \vi') \in \ET$, $\opset' \subseteq \opset$, then 
%$(\hh, \vi, \opset', \vi') \in \ET$.
%Intuitively, 
%$(\hh, \vi, \opset, \vi') \in \ET$ means that, under the execution test 
%$\ET$, provided that the overall set of views of other clients is $\viewSet$, 
%a client with a view on the kv-store $\hh$ is $\vi$ can safely 
%execute a transaction with fingerprint $\opset$, commit the transaction,
%and then obtain an updated view $\vi'$. 
%Even though in our framework transactions execute atomically, by applying 
%the function $\updateKV$, one may think of $\vi$ in $(\hh, \vi, \opset, \vi') \in \ET$, 
%as the view of the client at the moment it starts executing a transaction with fingerprint 
%$\opset$. Similarly, $\vi'$ represent the view of the client at the moment the transaction 
%commits.
%If $\cl$ is the client executing 
%the transaction, and $\txid$ is the identifier of the transaction, we can think of the view 
%$\vi$ as including the versions that $\cl$ is aware of immediately before 
%executing $\txid$, and of $\vi'$ as including the versions that $\cl$ is 
%aware of immediately after executing $\txid$.
%Henceforth, we use the more 
%suggestive notation $\ET \vdash \hh, \vi \csat \opset : \vi'$, 
%in lieu of $(\hh, \vi, \opset, \vi') \in \ET$.

Execution tests induce consistency models as defined in \cref{def:cm}.
\ac{I am shifting back to having two different operations for updating configurations: 
one for shifting the view of a client to the right, one for committing a transaction. 
I believe that using these two operations makes it more intuitive for the reader 
to understand what the kv-store framework is about.
Then a separate result state that each configurations that can be obtained 
using these two operations, can also be obtained using a strategy 
where the view of a client is shifted to the right only before that clients 
commit a transaction. Furthermore, empty fingerprints are never committed.}
\begin{definition}
\label{def:reduction}
Let $\cl$ be a client and $\opset$ be a fingerprint. 
An \emph{action} has either the form $(\cl, \varepsilon)$, 
or $(\cl, \opset)$. We let $\mathsf{Act}$ be 
the set of actions.
Given an execution test $\ET$, for any action $\alpha \in \Act$ we define the action-labelled 
relation $\xrightarrowtriangle{\alpha}_{\ET} \subseteq \Confs \times \Confs$ 
as the smallest relation such that
\begin{itemize}
\item $\forall \vi, \vi', \cl, \hh, \viewFun.\; \viewFun(\cl) = \vi \wedge \vi \sqsubseteq \vi' \implies (\hh, \viewFun) \xrightarrowtriangle{(\cl, \varepsilon)}_{\ET} 
(\hh, \viewFun\rmto{\cl}{\vi'})$, 
\item $\forall \vi, \vi', \cl, \opset, \hh, \hh', \viewFun.\; \viewFun(\cl) = \vi \wedge (\ET \vdash (\hh, \vi) \triangleright \opset: \vi') \wedge 
\hh' \in \updateKV(\hh, \vi, \cl, \opset) \implies (\hh, \viewFun) \xrightarrowtriangle{(\cl, \opset)}_{\ET} (\hh', \viewFun\rmto{\cl}{\vi'})$.
\end{itemize}
Such relations take the name of $\ET$-reductions, or simply reductions.
\end{definition}
Given an execution test $\ET$, sequences of $\ET$-reductions of the form $\conf_{0} \xrightarrowtriangle{\alpha_{0}}_{\ET} \cdots 
\xrightarrow{\alpha_{n-1}} \conf_{n}$ take the name of \emph{$\ET$-traces}.
%we define the relation $\xrightarrowtriangle{cl, \opset, \vi}_{\ET}
%\subseteq \Confs \times \Confs$ by letting 
%the relation $(\hh_1, \viewFun_1) \xrightarrowtriangle{cl,\vi, \opset}_{\ET} 
%(\hh_2, \viewFun_2)$ is defined iff $\viewFun_1(\cl) \sqsubseteq \vi$, 
%$\viewFun_2 = \viewFun_1\rmto{\cl}{\vi'}$ for some client view \( \vi' \) such that
%$ \hh_2 \in \updateKV(\hh_1, \vi, \cl, \opset)$ and 
%$\ET \vdash (\hh_1, \vi) \triangleright \opset: \vi'$.
\begin{definition}
\label{def:cm}
Let $\ET$ be an execution test.
The set of configurations induced by $\ET$ is given by:
\[
\Confs(\ET) = \Setcon{ \conf}{ \exsts{\conf_0} \conf_0 \text{ is initial } \wedge \conf_0 \xrightarrowtriangle{\stub}_{\ET} \cdots \xrightarrowtriangle{\stub}_{\ET} \conf }
\]
The consistency model induced by $\ET$ is given by:
\[ 
\CMs(\ET) = \Setcon{ \hh }{ (\hh, \stub) \in \Confs(\ET) }
\]
%A kv-store $\hh$ is \emph{initial} if for any key $\ke \in \dom(\hh)$, 
%$\hh(\ke) = (\val_0, \txid_0, \_)$. A configuration $\conf$ is 
%initial  if $\conf = (\hh, \viewFun)$ for some initial $\hh$. 
%\ac{Initial kv-stores should have been defined before.}
%Let $\ET$ be an execution test: the set of all configurations 
%induced by $\ET$ is the smallest set $\mathsf{Configs}(\ET)$ 
%such that 
%\[
%\begin{array}{l}
%\forall \conf. \conf \text{ is initial} \implies \conf \in \mathsf{Configs}(\ET)\\
%%\forall \hh, \cl, \vi'.\; (\hh, \viewFun) \in \mathsf{Configs}(\ET) \wedge \viewFun(\cl) \viewleq \vi' \implies (\hh, \viewFun\rmto{\cl}{\vi'}) \in \mathsf{Configs}(\ET)\\
%\forall \hh, \cl, \opset, \vi, \vi', \vi''.\; \vi = (\viewFun(\cl) \wedge \vi \viewleq \vi' \wedge \ET \vdash (\hh, \vi') \triangleright \opset : \vi'') \implies {}\\
%\hfill \forall \hh' \in (\updateKV(\hh, \vi', \cl, \opset). (\hh', \viewFun\rmto{\cl}{\vi''}) \in \mathsf{Configs}(\ET) 
%\end{array}
%\]
%
%The \emph{consistency model} induced by $\ET$ is defined as 
%\[
%\CMs(\ET) = \{ \hh \mid \exists \vi.\; (\hh, \vi) \in \mathsf{Configs}(\ET) \}.
%\]
\end{definition}
Thus, consistency models are computed from execution tests by closing the set of initial kv-stores with 
respect to two operations: replacing the view of a client on the kv-store with a more up-to-date one, and committing 
the effects of a transaction. 

Consistency models induced by execution tests are monotonic in the following sense.
\begin{proposition}
\label{prop:mono-et}
Let $\ET_1 \subseteq \ET_2$. Then $\CMs(\ET_1) \subseteq \CMs(\ET_2)$.
\end{proposition}
%In particular, let $\ET_{\bot} = \HisHeaps \times \Views \times \powerset{\Ops} \times \Views$ 
%be the most permissive execution test. Then for any execution test $\ET_{\bot}$, we have that 
%$\CMs(\ET) \subseteq \CMs(\ET_{\bot})$. Intuitively, we expect that any kv-store 
%$\hh$ is allowed by $\ET_{\bot}$. This is stated formally in the next result. 
%\begin{proposition}
%\label{prop:et.bot}
%$\CMs(\ET_{\bot}) = \HisHeaps$.
%\end{proposition}
%
%\begin{example}
%As we will see later, Proposition \ref{prop:et.bot} plays an important role in ensuring 
%that specification of consistency models given using execution tests are equivalent 
%to those previously defined in the literature. 
%\end{example}

For technical reasons, it will be convenient to adopt a reduction strategy for inferring kv-stores induced by an 
execution test: such an execution strategy require that clients only commit transactions with non-empty fingerprints, 
and a client updates its view only immediately before committing a transaction. 
The next proposition states that all kv-stores induced by an execution test $\ET$ can be 
obtained via a sequence of reductions that adhere to the reduction strategy outlined above. 
\begin{definition}
Let $\ET$ be an execution test. The $\ET$-trace
\[
\conf_0 \xrightarrowtriangle{\alpha_0}_{\ET} \conf_1 \xrightarrowtriangle{\alpha_1}_{\ET} \cdots \xrightarrowtriangle{\alpha_{n-1}}_{\ET} \conf_{n}
\]
is in \emph{normal form} if $\conf_0$ is initial, and 
$\forall i=0,\cdots, \lfloor\frac{n-1}{2} \rfloor$ there exists a client $\cl_i$ and set of operations $\opset_{i}$ such that 
$\alpha_{2 \cdot i} = (\cl_{i}, \varepsilon)$, and $\alpha_{2 \cdot i + 1}$ is defined and equal to $(\cl_{i}, \opset_{i})$.
\end{definition}


\ac{Note that the fact that $\alpha_{2 \cdot \lfloor{\frac{n-1}{2}}\rfloor + 1}$ is defined implies that $n-1$ must be odd, or alternatively that 
the number of reductions in the $\ET$-trace must be even.}

\begin{proposition}
\label{prop:et.normalform}
Let $\ET$ be an execution test, and suppose that $\hh \in \CMs(\ET)$. Then there exists a $\ET$-trace  
\[
(\hh_0, \viewFun_0) \xrightarrowtriangle{\stub}_{\ET} \cdots \xrightarrowtriangle{\stub}_{\ET} (\hh_n, \viewFun_{n})
\]
that is in normal form, and such that $\hh_{n} = \hh$.
\end{proposition}


%Note that specifications of consistency models using execution tests 
%are compositional in the following way: 
%
%\begin{proposition}
%\label{prop:et.compositional}
%Let $\ET_1, \ET_2$ be two execution tests. Then $\CMs(\ET_1 \cap \ET_2) = \CMs(\ET_1) \cap \CMs(\ET_2)$.
%\end{proposition}
%
%\begin{example}
%Let $\ET_{\top} = \HisHeaps \times \viewSet \times \powerset{\Ops} \times \viewSet$ 
%be the most permissive execution test. Note that \cref{prop:et.compositional} ensures 
%that, for any execution test $\ET$, then $\CMs(\ET) \subseteq \CMs(\ET_{\top})$. 
%Consider the kv-store $\hh$ from \cref{fig:hheap-a}. 
%If we assume that $\val'_0 = \val_0$, and $\val_0$ is the initial value of kv-stores, 
%then $\hh$ is included in $\CMs(\ET_{\top})$. 
%In fact, let $\opset_1 = \{(\otR, \ke_2, \val'_0), (\otW, \ke_1, \val_1)\}$, 
%$\opset_2 = \{(\otR, \ke_1, \val_0), (\otW, \ke_2, \val'_1)\}$, and 
%$\vi = [\ke_1 \mapsto 0, \ke_2 \mapsto 0]$. Assuming that 
%$\hh_0$ is the initial kv-store with $\dom(\hh_0) = \{ \ke_1, \ke_2\}$, 
%then $\updateKV(\updateKV(\hh_0, \vi, \_, \opset_1), \vi, \_, \opset_2)$ 
%generates exactly the kv-store $\hh$, provided that transaction identifiers 
%$\txid, \txid'$ are consistent with the clients that committed $\opset_1, \opset_2$, 
%respectively.
%\end{example}
%\ac{Looking at compositionality gets us into problems that we will never solve before 
%the deadline.}

\mypar{Compositionality for Execution Tests.} 
A desirable property that one would request from execution 
test is compositionality: the consistency model induced by 
a composite execution test can be recovered from the consistency 
models generated by each execution test: that is, 
\[ 
\forall \ET_1, \ET_2. \CMs(\ET_1 \cap \ET_2) = \CMs(\ET_1) \cap \CMs(\ET_2).
\]
Unfortunately, this property is not satisfied by execution tests in their 
most general setting, as the following example shows: 
\begin{example}
\label{ex:noncompositional.et}
Define the following terms: 
\[
\begin{array}{lcl}
\hh_0 &=& [\ke_1 \mapsto (\val_0, \txid_0, \emptyset) , \ke_2 \mapsto (\val_0, \txid_0, \emptyset)]\\
\hh_1 &=& \big[\ke_1 \mapsto \big( (\val_0, \txid_0, \emptyset) \lcat (\val_2, \txid_{\cl_1}^{1}, \emptyset)\big) , \ke_2 \mapsto (\val_0, \txid_0, \emptyset) \big]\\
\hh_2 &=& \big[\ke_1, \mapsto (\val_0, \txid_0, \emptyset), \ke_2 \mapsto \big( (\val_0, \txid_0, \emptyset) \lcat (\val_2, \txid_{\cl_2}^{1}, \emptyset) \big) \big]\\
\hh_3 &=& \big[\ke_1 \mapsto \big( (\val_0, \txid_0, \emptyset) \lcat (\val_2, \txid_{\cl_1}^{1}, \emptyset)\big), 
                         \ke_2 \mapsto \big( (\val_0, \txid_0, \emptyset) \lcat (\val_2, \txid_{\cl_2}^{1}, \emptyset) \big) \big]\\
&&\\
\vi_0 &=& [\ke_1 \mapsto \{0\}, \ke_2 \mapsto \{0\}]\\
\viewFun_0 &=& [\cl_1 \mapsto \vi_0, \cl_2 \mapsto \vi_0]\\
&&\\
\ET_1 &\vdash& (\hh_0, \vi_0) \triangleright \{(\otW, \ke_1, \val_1)\} : \vi_0\\
\ET_1 &\vdash& (\hh_1, \vi_0) \triangleright \{(\otW, \ke_2, \val_2)\} : \vi_0\\
&&\\
\ET_2 &\vdash& (\hh_0, \vi_0) \triangleright \{(\otW, \ke_2, \val_2)\} : \vi_0\\
\ET_2 &\vdash& (\hh_2, \vi_0) \triangleright \{(\otW, \ke_1, \val_1)\} : \vi_0.
\end{array}
\]
There are no further constraints on $\ET_1, \ET_2$.
For $\ET_1$ and $\ET_2$, we have that 
\[
\begin{array}{l}
(\hh_0, \viewFun_0) \xrightarrowtriangle{(\cl_1, \{(\otW, \ke_1, \val_1)\})}_{\ET_1} 
(\hh_1, \viewFun_0) \xrightarrowtriangle{(\cl_2, \{(\otW, \ke_2, \val_2)\})}_{\ET_1} (\hh_3, \viewFun_0), \\
(\hh_0, \viewFun_0) \xrightarrowtriangle{(\cl_2, \{(\otW, \ke_2, \val_2)\})}_{\ET_2} 
(\hh_2, \viewFun_0) \xrightarrowtriangle{(\cl_1, \{(\otW, \ke_1, \val_1)\})}_{\ET_2} (\hh_3, \viewFun_0).\\
\end{array}
\] 
Therefore, we have that $\hh_3 \in \CMs(\ET_1) \cap \CMs(\ET_2)$. On the other hand, it is immediate 
to observe that $\ET_1 \cap \ET_2 = \emptyset$, and therefore $\hh_3 \notin \CMs(\ET_1 \cap \ET_2)$.
\end{example}
The reason why compositionality fails, for the execution tests of \cref{ex:noncompositional.et}, 
is that both the execution tests $\ET_1, \ET_2$ require that the fingerprints 
$\{(\otW, \ke_1, \_)\}, \{(\otW, \ke_2, \_)\}$ commit in different order: in $\ET_1$, the write to $\ke_1$ must commit 
before the write to $\ke_2$, and vice versa for $\ET_2$. On the other hand, 
because the two fingerprints above do not write to the same key, 
the order in which they are committed should not be relevant: by changing the order 
in which different clients commit such fingerprints to a kv-store, the result stays the same. 
\begin{definition}
Two triples $(\cl_1, \opset_1)$ and $(\cl_2, \opset_2)$ are 
conflicting if either $\cl_1 = \cl_2$, or there exists a key $\ke$ such that 
$(\otW, \ke, \_) \in \opset_1, (\otW, \ke, \_) \in \opset_2$. 

An execution test is $\ET$ is \emph{commutative} if, whenever $(\cl_1, \vi_1, \opset_1)$, 
$(\cl_2, \vi_2, \opset_2)$ are non-conflicting, and $\vi_1, \vi_2 \in \Views(\hh_0)$,  
then for any $\hh_0, \hh', \viewFun, \viewFun'$ we have that 
\[
\begin{array}{lr}
(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_1, \opset_1)}
\_ \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} (\hh', \viewFun') &\implies \\
(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} 
\_ \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} (\hh', \viewFun')
\end{array}
\]
\end{definition}
\ac{Note that the views are not part of actions anymore. Furthermore, the definition 
of $\ET$-reduction has been changed, so that no view shifts can be made prior to 
committing a transaction, in the reductions above.}

Requiring execution tests to be commutative is a necessary step for ensuring 
that the specification of consistency models are compositional. However, it 
is not sufficient. The next example shows how compositionality fails 
for commutative execution tests. 

\begin{example}
\label{ex:noblindwrites}
For any $n \in \Nat$, let $[n] = \{0,\cdots, n\}$.
Consider the execution tests $\ET_1, \ET_2$ defined below: 
\[
\begin{array}{lcl}
\ET_1 \vdash (\hh, \vi) \triangleright \opset : \vi' &\iff& 
\forall \ke.\;(\otW, \ke, \_) \in \opset \implies \vi(\ke) = \vi'(\ke) = [0]\\
\ET_2 \vdash (\hh, \vi) \triangleright \opset : \vi'(\ke) &\iff& 
\forall \ke. \;(\otW, \ke, \_ ) \in \opset \implies \vi(\ke) = [ \lvert \hh(\ke) \rvert - 1] \wedge \vi'(\ke) = [\lvert \hh(\ke) \rvert ] \\
\end{array}
\]
It is immediate to observe that both $\ET_1$ and $\ET_2$ are commutative. However, 
consider the kv-store $\hh_2 = [\ke \mapsto (\val_0, \txid_0, \emptyset) \lcat (\val_1, \txid_{\cl}^1, \emptyset) \lcat (\val_2, \txid_{\cl}^2, \emptyset)]$. 
We have that $\hh \in \CMs(\ET_1)$ and $\hh \in \CMs(\ET_2)$.
Let in fact $\hh_1 = [\ke \mapsto (\val_0, \txid_0, \emptyset) \lcat (\val_1, \txid_{\cl}^1, \emptyset)]$, $\vi_{i} = [\ke \mapsto [i] ]$.
\ac{Seriously, square brackets are being used everywhere (though all of this is standard notation. Maybe $\langle n \rangle$ for $\{0,\cdots, n\}$ is 
a better notation?}
We have the following sequences of reductions: 
\[
\begin{array}{l}
(\hh_0, \vi_0) \xrightarrowtriangle{(\cl, \{(\otW, \ke, \val_1)\})}_{\ET_1} 
(\hh_1, \vi_0) \xrightarrowtriangle{(\cl,\{(\otW, \ke, \val_2)\})}_{\ET_1} (\hh_2, \vi_0)\\
(\hh_0, \vi_0) \xrightarrow{(\cl, \{(\otW, \ke, \val_1)\})}_{\ET_2} (\hh_1, \vi_1) \xrightarrow{(\cl, \{(\otW, \ke, \val_2)\})}_{\ET_2} 
(\hh_2, \vi_2)
\end{array}
\]
On the other hand, we can observe that $\hh_2 \notin \CMs(\ET_1 \cap \ET_2)$. $\ET_1$ allows a client to 
commit a transaction if its view only includes the initial version of each key it writes. $\ET_2$ allows a client 
to commit a transaction when its view include all the versions for each key it writes. In $\ET_1 \cap \ET_2$ 
a client can commit a transaction only if the initial version of each key it writes is also the only version in the kv-store: 
as a result, $\CMs(\ET_1 \cap \ET_2)$ never contains a  kv-stores $\hh$ such that $\hh(ke) > 1$ for some key $\ke$; 
in particular, $\hh_2 \notin \CMs(\ET_1 \cap \ET_2)$.
\end{example}
\ac{Two possible reasons why compositionality fails: because of blind writes, or because the test $\ET_1$ hinders progress, 
i.e. it is not possible to replace a view with a more up-to-date one to enable progress. We must choose which assumption 
we make on the consistency model.}

{\color{red} One reason why compositionality fails in \cref{ex:noblindwrites} is that the execution tests $\ET_1$ and $\ET_2$ do not contain 
any information about the the views that client $\cl$ used to commit the transactions $\txid_{\cl}^1, \txid_{\cl}^2$. 
To solve this problem we adopt the \emph{no blind writes} assumption, that requires that a client never commits 
a transaction that writes a key, without reading such a key beforehand. Many implementations of consistency models 
in distributed key-value stores respect the no blind writes assumption. 

\begin{definition}
\label{def:noblidwrites}
An execution test $\ET$ has \emph{no blind writes} if, whenever $\ET \vdash (\hh, \vi) \triangleright \opset \cup \{(\otW, \ke, \_)\} : \vi'$, 
then $(\otR, \ke, \_) \in \opset$.
\end{definition}

\begin{theorem}
Let $\ET_1, \ET_2$ be two execution tests with no blind writes. If $\ET_1$ is commutative, 
then $\CMs(\ET_1 \cap \ET_2) = \CMs(\ET_1) \cap \CMs(\ET_2)$. 
Furthermore, if $\ET_1, \ET_2$ are commutative, then $\ET_1 \cap \ET_2$ 
is commutative.
\end{theorem}
%\begin{proof}
%See \cref{thm:appendix-et-composition-1} and \cref{thm:appendix-et-composition-2}.
%\end{proof}
}


\mypar{Examples of Execution Tests and Consistency Models.}
{\color{red} Did not proofread this section, we know it's going to change eventually.}
\begin{figure}
\begin{tabular}{ l @{} r }
\hline
\textbf{Consistency Model} & \textbf{Execution Test}\\
\hline
%\multicolumn{2}{c}{
%Client-centric Consistency Models} \\
%\hline
\MRd & $\vi \viewleq \vi'$\\
%\textbf{Causal Consistency: } & $\ET_{\CC}$ & $\causalView(\vi)$\\
\MW & 
$j \leq \vi(\ke) \wedge \WTx(\hh(\ke', i)) \xrightarrow{\PO?} \WTx(\hh(\ke, j)) 
\implies i \leq \vi(\ke')$
\\
\RYW & $(\otW, \ke, \stub) \in \opset \implies \vi'(\ke) = \lvert \hh(\ke) \rvert$\\
\WFR & $j \leq \vi(\ke) \wedge \txid \in \RTx(\hh(\ke', i)) \wedge \txid {\xrightarrow{\PO?}}
\WTx(\ke, j) ) \implies i \leq \vi(\ke')$\\
\hline
%\multicolumn{2}{c}{ Data-centric Consistency Models }\\
%\hline
%\textbf{Consistency Model} & \textbf{Execution Test}\\
\hline
\UA & $(\otW, \ke,  \stub) \in \opset \implies \vi(\ke) = \lvert \hh(\ke) \rvert - 1$\\
%$j \leq \vi(\ke) \wedge \WTx(\hh(\ke', i)) \xrightarrow{\PO(\cl)} \WTx(\hh(\ke, j)) 
%\implies i \leq \vi(\ke')$  
\CP & $\vi'(\ke) = \lvert \updateKV(\hh, \vi, \_, \opset) \rvert - 1 \wedge{}$\\
& $i < \vi(\ke) \wedge \vi(\ke') < j \implies \RTx(\hh(\ke, i)) \cap \RTx(\hh(\ke', j)) = \emptyset$\\
\SER & $\vi(\ke) = \lvert \hh(\ke) \rvert -1$\\
\hline
%\multicolumn{2}{c}{ Composite Consistency Models }\\
\hline
%\textbf{Consistency Model} & \textbf{Execution Test}\\
%\hline
\CC & $\ET_{\CC} = \ET_{\MRd} \cap \ET_{\MW} \cap \ET_{\RYW} \cap \ET_{\WFR}$\\
\PSI & $\ET_{\PSI} = \ET_{\CC} \cap \ET_{\UA}$\\
$\SI$ & $(\otW, \ke,  \stub) \in \opset \implies \vi(\ke) = \lvert \hh(\ke) \rvert - 1 \wedge{}$\\
& $\vi'(\ke) = \lvert \updateKV(\hh, \vi, \stub, \opset) \rvert - 1 \wedge {}$\\ 
\multicolumn{2}{r}{\qquad $\Big( \big( \txid \in \RTx(\hh(\ke, j)) \wedge \vi(\ke) < j) \vee (\txid = \WTx(\hh(\ke, j)) \wedge \vi(k) < j -1) \big) \implies {}$}\\
\multicolumn{2}{r}{\qquad %$\txid'  (\xrightarrow{\PO})^{*} \txid' \land 
$\big( (\txid \in \RTx(\mkvs(\ke', i)) \implies \vi(\ke') \leq i) \wedge (\txid' = \WTx(\mkvs(\ke',i)) \implies \vi(\ke') < i \big) \Big)$}\\
%$\vi'(\ke) = \lvert \updateKV(\hh, \vi, \stub, \opset) \rvert - 1 \wedge \big( i < \vi(\ke) \wedge \vi(\ke') < j \implies $\\
%& $ \RTx(\hh(\ke, i)) \cap \left( \RTx(\hh(\ke', j)) \cup \Set{\WTx(\hh(\ke', j + 1))} \right) = \emptyset \wedge {}$\\
%& $(\otW, \ke,  \stub) \in \opset \implies \vi(\ke) = \lvert \hh(\ke) \rvert - 1$\\
\hline
%\multicolumn{3}{|c|}{Composite Execution Tests}\\
%\hline
%\textbf{Consistency Model} & \textbf{Execution Test} & \textbf{Condition}\\
%\hline
%\textbf{Causal Consistency (CC)} & $\ET_{\CC}$ & $(\ET_{\MRd} \cap \ET_{\MW} \cap \ET_{\RYW} \cap \ET_{\WFR})$\\
%\textbf{Parallel Snapshot Isolation (CC)} & $\ET_{\PSI}$ & $\ET_{\CC} \cap \ET_{\UA}$\\
%\textbf{Snapshot Isolation} & $\ET_{\SI}$ & $\ET_{\CP} \cap \ET_{\UA}$\\ 
%\hline
\end{tabular}
\caption{Execution tests for both client-centric and data-centric consistency models. 
The condition column define a necessary and sufficient condition for inferring $\ET_{\CM} \vdash \hh, \vi \triangleright \opset : \vi'$,  
where $\CM$ is the consistency model from the left column.
All the variables in the formulas above are universally quantified.}
\label{fig:execution.tests}
\end{figure}

\begin{figure}
\hrule
\begin{subfigure}{0.3\textwidth}
\begin{centertikz}
\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\ke_1 \mapsto$};

\matrix(versionx) [version list]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\txid_1$\\
    {a} & $\left\{\txid_{\cl}^{2}\right\}$ & {a} & $\left\{\txid_{\cl}^{1} \right\}$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$v_0$};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$v_1$};
%\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
%\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};
\end{pgfonlayer}

\end{centertikz}
\caption{Disallowed by \(\MRd\)}
\label{fig:mr-disallowed}
\end{subfigure}
\quad
\begin{subfigure}{0.3\textwidth}
\begin{centertikz}
\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\ke_1 \mapsto$};

\matrix(versionx) [version list]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\txid_{\cl}^{1}$\\
    {a} & $\left\{\txid' \right\}$ & {a} & $\emptyset$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$v_0$};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$v_1$};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_2 \mapsto$};
\matrix(versiony) [version list]
   at ([xshift=\tikzkvspace]locy.east) {
 {a} & $\txid_0$ & {a} & $\txid_{\cl}^2$ \\
  {a} & $\emptyset$ & {a} & $\{\txid'\}$\\
};

\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$v_0$};
\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{$v_2$};
\end{pgfonlayer}

\end{centertikz}
\caption{Disallowed by \(\MW\)}
\label{fig:mw-disallowed}
\end{subfigure}
\quad
\begin{subfigure}{0.3\textwidth}
\begin{centertikz}
\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\ke_1 \mapsto$};

\matrix(versionx) [version list]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\txid'$\\
    {a} & $\{\txid\}$ & {a} & $\left\{ \txid_{\cl}^1 \right\}$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$\val_0$};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$\val_1$};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_2 \mapsto$};
\matrix(versiony) [version list]
   at ([xshift=\tikzkvspace]locy.east) {
 {a} & $\txid_0$ & {a} & $\txid_{\cl}^2$ \\
  {a} & $\emptyset$ & {a} & $\{\txid\}$\\
};

\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$v_0$};
\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{$v_2$};
\end{pgfonlayer}
\end{centertikz}
\caption{Disallowed by \(\WFR\)}
\label{fig:wfr-disallowed}
\end{subfigure}

\begin{subfigure}{0.47\textwidth}
\begin{centertikz}
\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\ke_1 \mapsto$};

\matrix(versionx) [version list, column 2/.style={text width=14mm}]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\txid_{\cl}^{1}$ & {a} & $\txid_{\cl}^{2}$\\
    {a} & $\left\{\txid_{\cl}^{1}, \txid_{\cl}^{2}\right\}$ & {a} & $\emptyset$ & {a} & $\emptyset$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$0$};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$1$};
\tikzvalue{versionx-1-5}{versionx-2-5}{locx-v2}{$1$};
%\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
%\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};
\end{pgfonlayer}
\end{centertikz}
\caption{Disallowed by \(\RYW\)}
\label{fig:ryw-disallowed}
\end{subfigure}
\quad
\begin{subfigure}{0.47\textwidth}
\begin{centertikz}
\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);
%Location x
\node(locx) {$\ke_1 \mapsto$};

\matrix(versionx) [version list, column 2/.style={text width=14mm}]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\txid$ & {a} & $\txid'$\\
    {a} & $\{\txid, \txid'\}$ & {a} & $\emptyset$ & {a} & $\emptyset$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$0$};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$1$};
\tikzvalue{versionx-1-5}{versionx-2-5}{locx-v2}{$1$};
%\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
%\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};
\end{pgfonlayer}
\end{centertikz}
\caption{Disallowed by \(\UA\)}
\label{fig:ua-disallowed}
\end{subfigure}

\begin{tabular}{@{}c @{} c @{}}
\begin{minipage}{0.4\textwidth}
\begin{subfigure}{\textwidth}
\begin{centertikz}
\begin{pgfonlayer}{foreground}
%Location x
\node(locx) {$\ke_1 \mapsto$};

\matrix(versionx) [version list]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\txid_1$\\
    {a} & $\left\{\txid_3\right\}$ & {a} & $\left\{ \txid_4 \right\}$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$\val_0$};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$\val_1$};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_2 \mapsto$};
\matrix(versiony) [version list]
   at ([xshift=\tikzkvspace]locy.east) {
 {a} & $\txid_0$ & {a} & $\txid_2$ \\
  {a} & $\left\{\txid_4\right\}$ & {a} & $\left\{\txid_3\right\}$\\
};

\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$\val_0$};
\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{$\val_2$};
\end{pgfonlayer}
\end{centertikz}
\caption{Disallowed by \(\CP\) - 1}
\label{fig:cp-disallowed-1}
\end{subfigure}

\begin{subfigure}{\textwidth}
\begin{centertikz}
\begin{pgfonlayer}{foreground}
%Location x
\node(locx) {$\ke_1 \mapsto$};

\matrix(versionx) [version list]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\txid_{\cl}^{1}$\\
    {a} & $\left\{\txid_{\cl'}^{2}\right\}$ & {a} & $\emptyset$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$\val_0$};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$\val_1$};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_2 \mapsto$};
\matrix(versiony) [version list]
   at ([xshift=\tikzkvspace]locy.east) {
 {a} & $\txid_0$ & {a} & $\txid_{\cl'}^1$ \\
  {a} & $\left\{\txid_{cl}^{2}\right\}$ & {a} & $\emptyset$\\
};

\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$\val_0$};
\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{$\val_2$};

%\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
%\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};
\end{pgfonlayer}
\end{centertikz}
\caption{Disallowed by \(\CP\) - 2}
\label{fig:cp-disallowed-2}
\end{subfigure}
\end{minipage}
&
\begin{subfigure}{0.55\textwidth}%
\begin{centertikz}%
\begin{pgfonlayer}{foreground}%
%Location x
\node(locx) {$\ke_1 \mapsto$};

\matrix(versionx) [version list]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\txid_1$ & {a} & $\txid_2$\\
    {a} & $\emptyset$ & {a} & $\emptyset$ & {a} & $\emptyset$\\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$\val_0$};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$\val_1$};
\tikzvalue{versionx-1-5}{versionx-2-5}{locx-v1}{$\val_2$};
%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_2 \mapsto$};
\matrix(versiony) [version list]
   at ([xshift=\tikzkvspace]locy.east) {
 {a} & $\txid_0$ & {a} & $\txid_3$ \\
  {a} & $\left\{\txid_2\right\}$ & {a} & $\emptyset$\\
};

\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$\val_0$};
\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{$\val_1$};

%Location z
\path (locy.south) + (0,\tikzkeyspace) node (locz) {$\ke_3 \mapsto$};
\matrix(versionz) [version list]
   at ([xshift=\tikzkvspace]locz.east) {
 {a} & $\txid_0$ & {a} & $\txid_3$ & {a} & $\txid_4$ \\
  {a} & $\emptyset$ & {a} & $\emptyset$ & {a} & $\emptyset$\\
};

\tikzvalue{versionz-1-1}{versionz-2-1}{locz-v0}{$\val_0$};
\tikzvalue{versionz-1-3}{versionz-2-3}{locz-v1}{$\val_1$};
\tikzvalue{versionz-1-5}{versionz-2-5}{locz-v2}{$\val_2$};

%Location w
\path (locz.south) + (0,\tikzkeyspace) node (locw) {$\ke_4 \mapsto$};
\matrix(versionw) [version list]
    at ([xshift=\tikzkvspace]locw.east) {
    {a} & $\txid_0$ & {a} & $\txid_1$ \\
    {a} & $\{\txid_4\}$ & {a} & $\emptyset$ \\
};
\tikzvalue{versionw-1-1}{versionw-2-1}{locw-v0}{$\val_0$};
\tikzvalue{versionw-1-3}{versionw-2-3}{locw-v1}{$\val_1$};
%\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
%\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};
\end{pgfonlayer}%
\end{centertikz}%
\caption{Disallowed by \(\SI\)}%
\label{fig:si-disallowed}%
\end{subfigure} \\
\end{tabular}
\hrule
\end{figure}

We conclude this section by giving the execution tests for widely adopted 
consistency models of distributed and replicated databases. These are summarised 
in \cref{fig:execution.tests}.
Following \cite{distrprinciples}, we distinguish between client-centric and data-centric consistency models. 
The former constrain the versions of keys that individual clients can observe. 
%such consistency models  
%include the session guarantees from \cite{terry1994sessions}, namely \emph{monotonic reads} (\MRd), \emph{monotonic writes} (\MW), \emph{read your writes} (\RYW) and \emph{write follows reads} (\WFR).
%The client-centric consistency model is also known as \emph{session guarantees} \cite{terry1994sessions}.
The latter impose conditions on the shape of the state of the database, in our case the structure of the kv-store.
%The data-centric consistency models include \emph{update atomic} (\UA), \emph{consistent prefix} (\CP) and \emph{serialisibility} (\SER).
%The remained models are combinations of both types, including \emph{causal consistency} (\CC), \emph{parallel snapshot Isolation} (\PSI) and \emph{snapshot Isolation} (\(\SI\)).
%Both kinds of models can be induced by execution tests. 
In \cref{sec:equivalence} we prove that specification of consistency models using execution tests are both sound and complete 
with respect to alternative specifications from the literature. Due to space constraints, we only give 
examples of allowed and disallowed kv-stores for relevant consistency models. A full account 
of the anomalous behaviours permitted by each consistency model is deferred to \cref{app:?}.

\paragraph{Monotonic Reads ($\MRd$)}
A client ensures the monotonic reads consistency guarantee if subsequent read operations always 
return versions from a more up-to-date state of the system. For example, the kv-store from \cref{fig:mr-disallowed} is disallowed 
by $\MRd$.
Because client $\cl$ first observes the latest version of $\ke$ in $\txid_{\cl}^{1}$, then it
observes the initial version of $\ke$ in $\txid_{\cl}^{2}$.
%Because the versions observed by a client of a kv-store 
%are determined by the view of the former, monotonic reads can be enforced in our framework by ensuring that 
%a client can never replace its view with an older one. According to the definition of $\CMs(\_)$, 
%a client can only update its view to an older one upon committing a transaction. 
The execution test $\ET_{\MRd}$ (\cref{fig:execution.tests}) prevents this scenario by 
forcing clients to always update their views to newer ones. 
%$\ET_{\MRd}$ in \cref{fig:execution.tests} forces clients to always update their views to newer ones.

\paragraph{Monotonic Writes ($\MW$)}
It states that whenever a transaction observes the effects of a version installed by some client $\cl$, then 
the transaction observes all the transactions executed by the client. It prevents 
the scenario of \cref{fig:mw-disallowed}, where transaction $\txid'$ observes the 
second version of $\ke_2$ carrying value $\val_2$, written by client $\cl$; but it does not observe the second version 
of $\ke_1$ carrying value $\val_1$, previously written by the same client.
%The order of updates of transaction identifiers is embedded in the set of transaction identifiers, 
%and it is given by $\txid \xrightarrow{\PO} \txid' \iff \exists \cl, n,m. n < m \wedge \txid = \txid_{\cl}^{n} \wedge 
%\txid' = \txid_{\cl}^{m}$. 
The execution test $\ET_{\MW}$ (\cref{fig:execution.tests}) ensures 
that, prior to executing a transaction, the set of versions included in the view of the client 
must be prefix-closed with respect to the relation $\xrightarrow{\PO}$.

\paragraph{Read Your Writes (\RYW)}
It states that a client must always be able to read any version 
of a key that was previously written by the same client. This prevents the kv-store of \cref{fig:ryw-disallowed}. 
In there, assuming that the initial version of $\ke$ carries value $0$, the client $\cl$ tries to increment the value of $\ke$ by $1$ twice, 
by first reading its value $\nat$ and then installing a new version carrying  value $\nat+1$ within a single transaction.
However, if the client does not read its 
own writes, the client might read the initial version of $\ke$ in the second increment 
(corresponding to the transaction $\txid_{\cl}^2$), and install a new version carrying value $1$.
%A client always appends the version of a key written by  
%a transaction at the tail of the version list for such a key. Therefore, to enforce the 
The Read your Writes ($\RYW$) (\cref{fig:execution.tests}) enforces that after committing a transaction, 
a client advances its view to the latest version for each key it wrote.  

\paragraph{Write Follows Reads (\WFR)}
It states that if a client writes some version $\ver$ following (or in the same transaction of ) 
a read of some version $\ver'$, 
then a second client may observe version $\ver$ only if it also observes $\ver'$. The Write Follow Reads ($\WFR$) 
consistency guarantee disallows the scenario depicted in  \cref{fig:wfr-disallowed} 
where a transaction $\txid$ observes the version $\ver_2$ of $\ke_2$ carrying value $\val_2$ written by client $\cl$,
but the same transaction $\txid$ does not observe 
the version of $\ke_1$ carrying value $\val_1$, read by $\cl$ prior to writing $\ver$. 
The execution test $\ET_{\WFR}$ (\cref{fig:execution.tests}) prevents this and similar scenarios to occur.

\paragraph{Causal Consistency (\CC)}
Causal Consistency requires that if a client observes a version 
$\ver$ of some key $\ke$, then it must also observe any version $\ver'$ of some key $\ke'$ 
from which $\ver$ potentially depends \cite{cops}. A necessary and sufficient condition 
for ensuring causal consistency is that of enforcing the four session guarantees $\MRd, \MW, \RYW$ and $\WFR$ 
discussed above \cite{session2causal}. Therefore, we let $\ET_{\CC} = \ET_{\MRd} \cap \ET_{\MW} 
\cap \ET_{\RYW} \cap \ET_{\WFR}$. 
%By \cref{prop:et.compositional}, 
%kv-stores disallowed by causal consistency are exactly the kv-stores disallowed by at least one of the 
%four session guarantees.
%However, for the sake of completeness we prefer to 
%give a definition of execution test for causal consistency after the standard definition. 
%The notion of \emph{potential dependency} $\xrightrrow{\pdep}$ between versions is defined by 
%letting $\ver \xrightarrow{\pdep} \ver'$ if  
%$\exists \txid, \txid'. \txid \in \{\WTx(\ver)\} \cup \RTx(\ver) \wedge 
%\txid' \in \{\WTx(\ver')\} \cup \RTx(\ver') \wedge \txid \xrightarrow{\SO} \txid'$: 
%this corresponds to the intuition that operations within a session potentially depends from previous operations in the same session.
%The notion of \emph{potential data dependency} between versions is given 
%by $\ver \xrightarrow{\ddep} \ver'$ if $\WTx(\ver') \in  \RTx(\ver)$.

\paragraph{Update Atomic ($\UA$).}
This consistency model has been proposed in \cite{framework-concur}, though we 
are not aware of any implementation. However, many implemented consistency models 
can be obtained by strengthening Update Atomic. Roughly speaking, in Update Atomic 
concurrent transactions writing to the same key cannot execute concurrently. This property 
is known as \emph{write conflict detection}. For example, $\UA$ prevents the kv-store to 
the right to occur. There, two transactions $\txid, \txid'$ concurrently increment the initial 
version of $\ke$ by $1$. Note that this scenario is more general than the one exhibited by 
$\RYW$, in that we do not require $\txid, \txid'$ to be executed by the same client 
(in fact, the kv-store to the right is allowed by causal consistency and monotonic writes).
To prevent this scenario from happening, the execution test $\ET_{\UA}$ requires 
that a client $\cl$ can write to key $\ke$ in a transaction, only if its view prior 
to the execution of the transaction pointed to the last version of $\ke$.

%framework, we can compute the set of transactions that are concurrent by transaction $\txid$ 
%immediately before executing such a transaction. At the moment a client $\cl$ tries to 
%commit the effects of transaction $\txid$, then any transaction $\txid'$ that read or wrote versions not included 
%in the view of $\cl$ is concurrent to $\txid$. Following this intuition, we can enforce write 
%conflict detection by requiring that whenever a client $\cl$ wants to commit the effect of 
%transactions writing key $\ke$ in the kv-store $\hh$, then the view of $\cl$ must include all the versions of $\ke$. 
%Formally, this leads to the execution test $\ET_{\UA}$ defined in \cref{fig:execution.tests}

\paragraph{Consistent Prefix ($\CP$).}
In centralised databases, where there is a total order in which transactions commit, 
consistent prefix is described  by the following property: if a client 
observes the effects of a transaction $\txid$, then it also observe the effects 
of any transaction $\txid'$ that commits before $\txid$. This property is 
difficult to formulate in our setting, because kv-stores do not contain any 
information about the total order in which transactions committed. 
As an alternative, we can specify $\CP$ via two different properties: 
first, clients agree on the 
order in which transactions install versions in a kv-store; and a client $\cl$ always 
observes all the transactions that executed before its last transaction. This property 
disallow disallows the kv-store depicted to the right: there 
transaction $\txid_{3}$ observes that the 
update of $\ke_2$ carrying value $\val_2$ happens before 
the update of $\ke_1$ carrying value $\val_2$; vice versa , 
$\txid_{4}$ observes that the update of $\ke_1$ carrying value $\val_1$ 
happens before the update of $\ke_2$ carrying value  $\val_2$. 
The second property required by $\CP$ is that at any given time, 
a client observes the effects of all the transactions that  
executed before the last transaction that such a client executed. 
This property prevents a scenario like the one depicted to the 
right: client $\cl$ does not observe the update to $\ke_2$ performed 
by $\cl'$, and $\cl'$ does not observe the update to $\ke_1$ performed 
by $\cl$. This property can be formalised by requiring that, after 
a client executes a transaction, its view is shifted to the most recent 
view of the data. The execution test $\ET_{\CP}$ is defined formally 
in \cref{fig:execution.tests}; in \cref{sec:?} we prove that our specification  
of $\CP$ using execution tests is precise. 


%Recall that in our setting clients shift their view upon executing the 
%transaction: the initial view abstracts the starting point of the 
%transaction, while the final view abstracts its commit point.
%Following this intuition, we compute an 
%under-approximation $\CBef_{\CP}(\cl, \vi, \hh, \opset)$ 
%of the set of transactions that a client $\cl$ with view $u$ 
%must observe to have committed, when executing a transaction with 
%fingerprint $\opset$. The definition of $\CBef_{\CP}$ is recursive, 
%and follows an approach similar to the one proposed in \cite{laws}.
%Formally, we let $\CBef_{\CP}(\cl, \vi, \hh, \opset)$ 
%be the smallest set such that for all $i, j, j', n, m \in \Nat$, $\ke, \ke' \in \Keys$, 
%$\val \in \Val$ and $\cl' \in \Clients$:
%\[
%\begin{array}{l}
%%Base Cases
%(\otR, \ke, \val) \in  \opset \implies   \WTx(\hh(\ke, \vi)) \in \CBef_{\CP}(\cl, \vi, \hh, \opset)\\
%%(\oTW, \ke, \val) \in \opset \implies  \WTx(\hh(\ke, i)) \in \CBef_{\CP}(\cl, \vi, \hh, \opset)\\
%\txid_{\cl}^{n} \text{ appears in } \hh \implies \txid_{\cl}^{n} \in \CBef_{\CP}(\cl, \vi, \hh \opset)\\
%%Inductive Cases
%% \WR \subseteq \AR
%(\RTx(\hh(\ke, i)) \cap \CBef_{\CP}(\cl, \vi, \hh, \opset) \neq \emptyset \implies  \WTx(\hh(\ke,i)) \in \CBef_{\CP}(\cl, \vi, \hh, \opset)\\
%%\VO \subseteq \AR
%i < j \wedge \WTx(\hh(\ke,j)) \in \CBef_{\CP}(\cl, \vi, \hh, \opset) \implies  \WTx(\hh(\ke, i)) \in \CBef_{\CP}(\cl, \vi, \hh, \opset)\\
%% PO \subseteq \AR 
%m \leq n \wedge \txid_{\cl}^{n} \in \CBef_{\CP}(\cl, \vi, \hh, \opset) \implies  \txid_{\cl}^{m} \in \CBef_{\CP}(\cl, \vi, \hh, \opset)\\
%% RF;RW \subseteq \AR
%\txid \in \RTx(\hh(\ke, i)) \cap \RTx(\hh(\ke', j)) \wedge j < j' \wedge \WTx(\hh(\ke', j')) \in \CBef_{\CP}(\cl, \vi, \hh, \opset) 
%\implies \\ \hspace{20pt} \WTx(\hh(\ke, i)) \in \CBef_{\CP}(\cl, \vi, \hh, \opset)\\
%%\PO;RW \subseteq \AR 
%m < n \wedge \txid_{\cl}^{n} \in \RTx(\hh(\ke,i)) \wedge i < j \wedge \WTx(\hh(\ke, j)) \in \CBef_{\CP}(\cl, \vi, \hh, \opset) 
%\implies \\ \hspace{20pt} \txid_{\cl}^{m} \in \CBef_{\CP}(\cl, \vi, \hh, \opset)
%\end{array}
%\]
%\begin{itemize}
%\item if $(\oTR, \ke, \_) \in \opset$, then $\WTx(\hh(\ke, u)) \in \CB(\hh, \vi, \opset)$: 
%because the $\txid_{\mathsf{now}}$ reads the version of 
%$\ke$ at $\hh(\ke, \vi)$, then the transaction $\txid$ that wrote such 
%a version must commit before $\txid_{\mathsf{now}}$,
%\item for any $\txid_{\cl}^{n}$ appearing in the kv-store, $\txid_{\cl}^{n} 
%\in \CB(\cl, \vi, \hh, \opset)$: any previous transaction executed by $\cl$ 
%must commit before $\txid_{\mathsf{now}}$, 
%\item 
%\end{itemize}
%However, suppose that in the kv-store $\hh$, a client $\cl$ with view $\vi$
%wants to execute a transaction with fingerprint $\opset$. In the case 
%that $(\otR, \ke, ) \in \opset$, then we can observe the following: 
%\begin{itemize}
%\item{\color{red} note to self: in CP $\AR_{\CP} = (\PO \cup \RF \cup \VO \cup \PO;\AD \cup \RF;\AD)^{+}$}
%\item the client will read the value of $\ke$ from the version $\hh(\ke,u)$. 
%For this to be possible, the transaction $\WTx(\hh(\ke,u))$ must have committed 
%before the transaction to be executed by $\cl$, {\color{red} Note to self: base case}, 
%\item for any client $\cl'$ and index $n$, $\txid_{\cl'}^{m}$ commits before $\txid_{\cl}^{n}$ 
%for all $m < n$, {\color{red} - case $\PO \subseteq \AR_{\CP}$}
%\item for any key $\ke'$ and index $i$, the transaction $\WTx(\hh(\ke', i))$ commits 
%before all of the transactions in $\RTx(\hh(\ke', i))$, {\color{red} - case $\RF \subseteq \AR_{\CP}$}, 
%\item for any $\ke'$ and index $i$, then $\WTx(\hh(ke', j))$ commits before $\WTx(\hh(\ke', i))$ for 
%any $j < i$,  {\color{red} - case $\VO \subseteq \AR_{\CP}$}
%\item for any $\ke'$ and integers $i,n$, if $\txid_{\cl'}^{n} \in \RTx(\hh(\ke', i))$, 
%then for any $j: i < j \leq \lvert \hh(\ke') \rvert - 1$, and index $m < n$, then 
%$\txid_{\cl'}^{m}$ commits before $\WTx(\hh(\ke,j))$ {\color{red} - to be explained 
%why: intuitively if $\txid_{\cl'}^{m}$ committed after $\WTx(\hh(\ke, j))$, 
%then $\txid_{\cl}^{m}$ would start after $\WTx(\hh(\ke, j))$ committed, 
%hence it would not be able to read a former version of $\ke$. This case corresponds 
%to $\PO; \AD \subseteq \AR_{\CP}$},
%\item for any $\ke',\ke''$ and indexes $i,j$, if $\txid \in \RTx(\hh(\ke', i)) \cap 
%\RTx(\hh(\ke'', j))$, then for any $j': j < j' \leq \lvert \hh(\ke'') \rvert - 1$, 
%$\WTx(\hh(\ke',i))$ comitted before $\WTx(\hh(\ke'', j'))$ {\color{red} 
%explanation similar to the case above - this is the case $\RF ; \AD \subseteq \AR_{\CP}$}, 
%\item if $\txid$ committed before $\txid'$, and $\txid'$ committed before $\txid''$, 
%then $\txid$ committed before $\txid''$.
%\end{itemize}
%We can define a relation $\mathsf{CommitBefore}_{\CP}(\hh, \cl, \vi, \ke)$ that 
%includes all the transactions that we know must have committed prior to the 
%execution of a transaction from client $\cl$, whose view on $\hh$ is $\vi$, 
%assuming that said transaction will read value $\ke$.
%Using a technique similar to the one proposed in \cite{laws}, it is possible to prove 
%that for $\cl$ to execute safely a transaction with fingerprint $\opset$, 
%then for each $\ke$ that is read in $\opset$, the view of $\cl$ must include 
%at least the transactions in $\mathsf{CommitsBefore}_{\CP}$. Following this intuition, 
%we let 
%\[ 
%\ET_{\CP} \vdash \hh, \vi \triangleright \opset: \vi' \iff 
%\forall (\otR, \ke, \_) \in \opset.\; \forall \ke', j. \WTx(\hh(\ke', j)) \in \mathsf{CommitBefore}_{\CP}(\hh, \cl, \vi, \ke) 
%\implies j \leq \vi(\ke)
%\]

%{\color{red} the execution test as it is right now does not enforce consistent 
%prefix. An alternative would be to encode kv-stores into dependency graphs, 
%define the relation $\mathsf{CB} = 
%((\PO \cup \RF) ; \AD?) \cup \VO)^{+}$ - I know, it does not make any sense, 
%will try to explain at the meeting - and require that if $\txid$ is included 
%in a view $\vi$, then all the transactions $\txid'$ such that $\txid' \xrightarrow{\mathsf{CB}} 
%\txid$ must also be included in $\txid$. This works, but the problem is going to be how 
%to explain it to people.}
%An alternative 
%formulation is that concurrent transactions never observe updates on the kv-store 
%in different order. Consistent Prefix prevents the scenario depicted to the right: 
%transactions $\txid_4$ reads the up-to-date version of $\ke_1$ and a stale version 
%of $\ke_2$; in contrast, transaction $\txid_3$ reads a stale version of $\ke_2$ and 
%an up-to-date version of $\ke_1$.
%The execution test $\ET_{\CP}$ prevents this scenario by requiring that, immediately 
%after committing a transaction $\txid$, a client $\cl$ brings its view to point to the 
%most recent version of each key: this amount to require that the next time that $\cl$ 
%executes a transaction, it will observe at least the effects of all the transactions that 
%committed before $\txid$.
%By Looking at the structure 
%of a kv-store, it is not immediate to infer a total order in which transactions have been 
%executed (this problem has been analysed in a slightly different setting, see \cite{SIanalysis,laws} 
%for details). An equivalent definition of consistent prefix requires that different clients 
%never see updates to the kv-stores performed in different order. We can enforce this property 
%by strengthening causal consistency with the requirement that clients, 
%after committing the effects of a transaction, always shift their view to 
%the most recent version of each key.  
%The execution $\ET_{\CP}$ for consistent 
%prefix is defined in \cref{fig:execution.tests}.

\paragraph{Parallel Snapshot Isolation (PSI)} 
These two consistency models are obtained by combining causal consistency with update atomic, 
and consistent prefix with update atomic, respectively. Formally, we have 
$\ET_{\PSI} = \ET_{\CC} \cap \ET_{\UA}$, and $\ET_{\SI} = \ET_{\CC} \cap \ET_{\UA}$.
%\textbf{\color{red} Here is where things go awry. Even if we replace $\CP$ with the right specification, 
%we cannot encode $\ET_\SI$ as $\ET_{\CP} \cap \ET_{\UA}$. The alternative would be to 
%encode $SI$ directly using dependency graphs, similarly as for the $\CP$ case.} 

\paragraph{Snapshot Isolation (SI)}
When the total order in which transactions commit is known, SI 
can be specified as the weakest consistency model that guarantees both 
prefix consistency and update atomic \cite{gsi,framework-concur}. 
On the other hand, the same is not true in our framework, where 
transactions are not totally ordered: for example, the kv-store to 
the right is included both in $\CMs(\ET_{\CP})$ and $\CMs(\ET_{\UA})$, 
but it is forbidden by SI.\footnote{This problem is not 
limited to our setting: because kv-stores are isomorphic to Adya's dependency 
graph, the same problem arises there.} 
\textbf{\color{red} This is going to be difficult to be put in words: 
both SI and CP require that the snapshot taken by clients are monotonically 
increasing (at least for transactions that write to at least one key). 
In both SI and CP, we enforce this property by computing, at the moment 
of trying to commit a transaction, a view of all the transactions that executed before 
(and hence appear in the kv-store); then we require that such views do not cross 
with the one that is being used to commit the current transaction. Here is where 
the twist happens: the way in which the relevant fragment of a view of 
a transaction is obtained is different for $\CP$ and $\SI$. 
For $\CP$, this relevant fragment is obtained 
by looking at the version reads for a transaction. If transaction $\txid$ read the 
$i$-th version of $\ke$, then we can be sure that the view $\vi_{\txid}$ 
that was used to execute $\txid$ was such that $\vi_{\txid}(\ke) = i$. 
For $\SI$ we also know that if transaction $\txid$ wrote the $i$-th version 
of key $\ke$, then because of write conflict detection, $\vi_{\txid}$ pointed 
to the previous version of $\ke$ i.e. $\vi_{\txid}(\ke) = i - 1$. 
In \cref{fig:execution.tests}, the execution test $\ET_{\SI}$ enforces three properties: 
the check on the first line mandates that  if a transaction wants to write key $\ke$, then the view of the client wishing 
to execute such a transaction must be up-to-date for that client; the check 
on the second line mandates that upon committing 
a transaction, a client shifts its view to the most up-to-date version of each 
key (this is done to ensure both $\RYW$ and $\MRd$); 
the check on the last two lines ensures that, in order to commit a transaction, the 
view of a client must not be crossing the view that was used to commit a previous 
transactions $\txid'$, at least for the objects that were accessed by $\txid'$.\\
Following a chat with Shale: it looks that there is a check on the program order missing 
here. I need to correct this.}
%We basically compute the relevant fragment of the view that we
%To overcome this problem, we place in 
%$\ET_{\SI}$ one more constraint in addition to the ones that 
%define $\ET_{\CP}$ and $\ET_{\UA}$: if a version read by transaction $\txid$ 
%is to the left of the view $\vi$ of the client wishing to update a transaction, then 
%all the versions written by $\txid$ must be to the left of $\vi$. In \cref{sec:?} 
%we prove that the execution test $\ET_{\SI}$, defined in \cref{fig:execution.tests}, 
%precisely capture SI.

\paragraph{(Strict) Serialisibility (\SER)}
The last consistency model that we consider is serialisability. This consistency model 
requires that there exists a serial, or sequential schedule of transaction. 
This prevents scenarios like the kv-store of \cref{fig:hheap-a}, which is instead allowed 
by all the other execution tests that we have presented.
The execution test $\ET_{\SER}$ enforces serialisability by requiring clients to 
execute transactions only when their view of the kv-store is up-to-date.

%The execution test $\ET_{\SER}$ of \cref{fig:exec.tests} models exactly this scenario.
