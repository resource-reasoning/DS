\subsection{Multi-version Key-value Stores and Views}
\label{sec:mkvs-view}

\subsubsection{Multi-version Key-value Stores} 

We assume a countably infinite set of \emph{keys} $\Keys \defeq \Set{\ke, \ke', \cdots}$, 
a set of \emph{values} $\Val \defeq \{\val, \val', \cdots\}$ 
which for simplicity we instantiate to be $\Nat \uplus \Keys$, 
and a set of clients $\Clients \defeq \Set{\cl, \cl',\cdots}$. 
We also assume a set of transaction identifiers 
$\TxID \defeq \Set{ \txid_{\cl}^{n} \mid \cl \in \Clients \wedge n \geq 0 } \uplus \Set{\txid_{0}}$,
each of which is either a special transaction identifier $\txid_0$ for initialisation, 
or it is indexed by a client identifier and a natural number. 
Elements of $\TxID$ are ranged over by $\txid, \txid', \cdots$, 
while subsets of $\TxID$ are ranged over $\txidset, \txidset', \cdots$. 
We let $\TxID_{0} \defeq \TxID \setminus \{ \txid_0\}$.
The structure of the set $\TxID$  
embeds the order in which transactions are executed by individual clients, or \emph{session order}. 
Specifically, the session order is defined as
$\PO \defeq \Set{ (\txid, \txid') \mid \exsts{ \cl, n,m } \txid = \txid_{\cl}^{n} \wedge \txid' = \txid_{\cl}^{m} \wedge n < m}$; 
thus $(\txid, \txid') \in \PO$ means that 
some client $\cl$ has executed $\txid$ prior to $\txid'$.
For readability, we often adopt the more graphic notation as
$\txid \xrightarrow{\PO} \txid'$ in lieu of $(\txid, \txid') \in \PO$.

Given a set $X$, then $\powerset{X}$ denotes 
the powerset of $X$, while $X^{\ast}$ is the free monoid induced by $X$.
The \emph{multi-version key-value store} is defined as the following (\cref{def:mkvs}).


\begin{definition}[Multi-version Key-value Stores]
\label{def:his_heap}
\label{def:mkvs}
A \emph{version} is a triple $\ver \in \Versions \defeq \Val \times \TxID \times \powerset{\TxID_{0}}$. 
%The set of versions is denoted by $$.
A \emph{key-value store} is a mapping $\hh \in \MKVSs \defeq \Keys \rightarrow \Versions^{\ast}$. 
%\ac{ The superscript fin over the $\rightharpoonup$ needs to be fixed. You may want to look at the package extpfeil.}
\end{definition}

A \emph{version} $\ver = (\val, \txid, \txidset)$ consists of a value $\val$,
and the meta-data of the transactions that accessed the version; 
specifically, the \emph{writer} $\txid$ is the identifier of the transaction that wrote such a version, 
and the \emp{readers} $\txidset$ is the set of identifiers of transactions that read the version.
Given a version $\ver = (\val, \txid, \txidset)$, let $\valueOf(\ver) \defeq \val$,
$\WTx(\ver) \defeq \txid$ and $\RTx(\ver) \defeq \txidset$.
Lists of versions, that is elements of $\Versions^{\ast}$, are ranged over by $\vilist, \vilist',\cdots$.

A \emph{multi-version key-value store}, or \emph{kv-store}, 
is a mapping from keys to lists of versions. 
For a given kv-store $\hh$, key $\ke$ and index $i \geq 0$, 
the notation $\hh(\ke, i)$ denotes the $i$-th version (starting from $0$) installed for $\ke$;
that is, if $\hh(\ke) = \ver_0 \cdots\ver_{n}$, then $\hh(\ke, i) \defeq \ver_{i}$ if $i \leq n$, it is undefined otherwise. 
We also let $\lvert \hh(\ke) \rvert \defeq n +1 $ denote the length of $\hh(\ke)$.

In this paper we focus on key-value stores whose consistency model enforces the \emph{atomic visibility} of transactions \cite{framework-concur}. 
We also assume that each key has an initial version carrying a default value $\val_0 \in \Val$, 
written by the special transaction identifies $\txid_0$.
A \emph{well-formed} kv-store $\hh$ requires that:
\begin{enumerate}[(i)]
\item\label{kv:wf.init} 
    for each key $\ke \in \dom(\hh)$, $\hh(\ke, 0) = (\val_0, \txid_0, \stub)$, where $\val_0$ is a default value from $\Val$;
\item\label{kv:wf.onewrite} 
    transactions never write more than one version per key:
\[
\fora{\ke, i,j }
0 \leq i, j < \abs{ \hh(\ke) }
\land \WTx(\hh(\ke, i)) = \WTx(\hh(\ke, j))
\implies i = j 
\]
\item\label{kv:wf.oneread} 
    transactions never read different versions for the same key:
\[
\fora{\ke, i,j } 
0 \leq i, j < \abs{ \hh(\ke) }
\land \RTx(\hh(\ke, i)) \cap \RTx(\hh(\ke, j)) \neq \emptyset 
\implies i = j
\]
\item\label{kv:wf.so} 
    the order in which transactions issued by the same client install different versions for a key $\ke$, 
    is consistent with the session order;
    also, a client can read a version, if the writer of such version comes from the same client, only after it is installed:
\begin{multline*}
    \fora{ \ke, \cl, i,j, n, m} 
    0 \leq i < j < \abs{\hh(\ke)} 
    \land \txid_{\cl}^{n} = \WTx(\hh(\ke,i)) \\
    {} \wedge \txid_{\cl}^{m} \in \Set{\WTx(\hh(\ke,j))} \cup \RTx(\hh(\ke, i))
    \implies n < m.
\end{multline*}
\end{enumerate}
We always assume that kv-stores are well-formed, and let $\HisHeaps$ be the set of well-formed kv-stores.

\subsubsection{Views and Configurations}

The key-value store tracks the global state, 
but when executing transactions,
different \emph{clients} may observe different versions of the same key. 
To keep track of the versions they observe,
clients are associated with \emph{views} (\cref{def:view}). 

\begin{definition}[Views and configurations]
\label{def:view}
\label{def:cuts}
\label{def:views}
\label{def:configuration}
Given a key-value store $\hh$, a \emph{view} of $\hh$ is a mapping  
$\vi \in \Views(\mkvs) \defeq \dom(\hh) \to\powerset{\Nat}$ such that  
\[
    \fora{ \ke } 
    0 \in \vi(\ke) 
    \wedge \fora{ i \in \vi(\ke) } 
    i < \abs{ \hh(\ke) }
    %\Set{0} \subseteq \vi(\ke) \subseteq \Setcon{i}{ 0 \leq i < \abs{\mkvs(\ke)}}
\]
and 
\begin{equation}
\label{eq:view.atomic}
\begin{array}{@{}l@{}}
\fora{ \ke,\ke', i,j} \\
\quad j \in \vi(\ke) 
\wedge \WTx(\hh(\ke, j)) = \WTx(\hh(\ke', i) 
\implies i \in \vi(\ke')
\end{array}
\tag{Atomic}
\end{equation}
\emph{The set of views} is defined as:
\[
\Views \defeq \bigcup_{\hh \in \HisHeaps} \Views(\hh)
\]
A \emph{configuration} $\conf \in \Confs$ is a pair $(\hh, \viewFun)$, 
where $\viewFun : \Clients \parfinfun \Views(\hh)$. 
The configuration $\conf_{0} = (\hh_{0}, \viewFun_{0})$ is 
initial if, for any key $\ke$, $\hh_{0}(\ke) = (\val_0, \txid_0, \emptyset)$, 
for some initial value $\val_0$. 
\end{definition}

\emph{A configuration} includes a kv-store and a partial mapping from clients to views.
The view of the client $\cl$ in $\hh$ reflects the set of versions for each key 
that the client \(\cl \) observes upon executing a transaction. 
The constraint of \cref{eq:view.atomic} establishes that if a client observes 
a version of some key written by a transaction $\txid$, then it must observe all the versions of 
all keys that $\txid$ wrote. This constraint captures the \emph{atomic visibility} of transactions.

Given a kv-store $\hh$ and two views $\vi, \vi' \in \Views(\hh)$, 
let $\vi \viewleq \vi'$ if, for any key $\ke$, $\vi(k) \subseteq \vi'(\ke)$. 
Also, we commit an abuse of notation and write $\hh(\ke, \vi)$ as a shorthand 
for $\hh(\ke, \max_{<}(\vi(\ke)))$. Note that such a version is well-defined because 
we are assuming that $\vi(\ke) \neq \emptyset$.

\subsubsection{Snapshots and Fingerprints}
Transactions are executed relatively to a \emph{snapshot} of a kv-store, 
which maps each key to a single value.
The snapshot \( \h \) is defined as the follows (\cref{def:snapshot}).
A view $\vi$ naturally induces the initial state of \emph{snapshot} of a transaction
by extracting the value of the latest observable version for each key $\ke \in \dom(\hh)$. 
%Views are used to determine the snapshot in which a transaction 
%is executed, according to the following definition.


\begin{definition}[Snapshots]
\label{def:heaps}
\label{def:snapshot}
A snapshot is a mapping from keys to values \( \ss \in \Snapshots  \defeq \Keys \to \Val\).
Given $\hh \in \HisHeaps$ and $\vi \in \Views(\hh)$, the \emph{snapshot} of $\vi$ in 
$\hh$ is defined as $\snapshot(\hh, \vi) \defeq \lambda \ke \ldotp \valueOf(\hh(\ke, \max_{<}(\vi(\ke)))$.
\end{definition}

A transaction only commits its effect to the key-value store.
The effects of transactions are modelled as \emph{a fingerprint},
which is a set of reads \( \otR \) and writes \( \otW \) operations over keys.

\begin{definition}[Fingerprints]
Assuming a set of \emph{operations}
$\Ops \defeq \Setcon{(\otR, \ke, \val), (\otW, \ke, \val) }{ \ke \in \Keys \wedge \val \in \Val }$.
The \emph{fingerprint} of a transaction is a subset of operations $\opset \subseteq \Ops$, 
such that for any key $\ke \in \Keys$ and label \( l \in \Set{\otW, \otR} \),
if $(l, \ke, \val_1) \in \opset$ and $(l, \ke, \val_2) \in \opset$, then $\val_1 = \val_2$.
\end{definition}

Intuitively, $(\otR, \ke, \val) \in \opset$ means that 
the transaction requested to read key $\ke$ from the kv-store, 
and it fetched a version carrying value $\val$.
There is at most one read operation per key; 
it formalises the intuition that, in our setting, 
transactions always read from an atomic snapshot of the key-value store. 
Similarly, there is at msot one write operation per key;
because a client either observes none or all the updates of a transaction.


%\ac{Note that I now require fingerprints to be non-empty sets of transactions. This simplifies a lot the development of 
%the theory of kv-stores, and it fixes a problem that was spotted by Shale, that breaks the compositionality of 
%execution tests (see later). The main reason why we allowed empty fingerprints is that in the semantics, a client can 
%execute a transaction with no access to the memory. In practice, in the semantics we can require that at least 
%one access to the database must be performed in transactions. This can be checked syntactically, and nobody 
%should complain about that. I can put a remark about how this is a natural requirement that, if violated, 
%breaks the compositionality of consistency models.\\ 
%\textbf{Update 02/08/2018}: empty fingerprints are now allowed again. We still had some problems with compositionality, 
%one of which has to do with the fact that we allow the view of a client over some key to move freely after executing a transaction, 
%even if such a key was not accessed by the transaction. Later, I forbid this behaviour by requiring in execution tests that the 
%view of an client for a given key cannot be shifted if the transaction executed by the client did not access such a key.}
%$(\otW, \ke, \val) \in \opset$ means that the transaction writes a new version, carrying value $\val$, for key $\ke$. 




%of $\vi$ by accessing the value of 
%A view $\vi$ in $\hh$ naturally defines a snapshot $\snapshot(\hh, \nu)$
%A MKVS tracks the global state of the system; however, different \emph{clients} may observe different versions of the same key. 
%To model this, we introduce the notion of \emph{views} (\cref{def:views}). 
%A view $V$ reflects the particular version for each key that a client observes upon executing a transaction. 
%%We present an example of views in \cref{fig:hheap-a} with two views: $\client_1$ in red and $\client_2$ in blue.
%More concretely, the view for \( \client_1 \) is given formally as $\vi_1 = \Set{\key{k}_1 \mapsto 1, \key{k}_2 \mapsto 0}$.
%That is, the client with view $\vi_1$ observes the second version (at index 1) of key \( \ke_{1} \) with value $v_1$, and the first version (at index 0) of key \( \ke_2 \) with value $v'_0$.
%%, and 
%%the first version of $\key{k}_2$, carrying value $0$. Similarly, according to its view 
%%$V_2 = [\key{k}_1 \mapsto 2, \key{k}_2 \mapsto 2]$, the client $\txid_2$ observes 
%%in $\hh$the second and most up-to-date version for both $\key{k}_1$ and $\key{k}_2$.
%
%\begin{definition}[Views]
%\label{def:view}
%\label{def:cuts}
%\label{def:views}
%\emph{A view} is a partial finite function from keys to indexes:
%$
%\vi \in \Views \defeq \Addr \parfinfun \Nat 
%%\begin{rclarray}
%%    \vi \in \Views & \defeq & \Addr \parfinfun \Nat 
%%\end{rclarray}
%$.                                                                 
%The \emph{view composition}, $\composeVI: \Views \times \Views \rightharpoonup \Views$ is defined as the standard disjoint function union: $\composeVI \eqdef \uplus$. 
%% \( \vi \composeVI \vi' \defeq \vi \uplus \vi'\) 
%The \emph{unit view}, $\unitVI \in \Views$, is a function with an empty domain: $\unitVI \eqdef \emptyset$. 
%% and the unit is \( \unitVI \defeq \emptyset\).
%The \emph{order relation} on views, $\orderVI: \Views \times \Views$, is defined between two views with the same domain as the point-wise comparison of their indexes for each entry: 
%\[
%\begin{rclarray}
%    \vi \orderVI \vi' & \defiff & \dom(\vi) = \dom(\vi') \land \fora{\ke} \cu(\ke) \leq \cu'(\ke) \\
%\end{rclarray}
%\]
%\end{definition}
%%
%We say view $\vi$ is \emph{older} than view $\vi'$ (or $\vi'$ is \emph{newer} than $\vi$) whenever $\vi \orderVI \vi'$ holds.
%
%
%\mypar{Configurations} A \emph{configuration} comprises an MKVS, and the views associated with clients.
%In \cref{fig:hheap-a} we present an example of a configuration comprising an MKVS and the two views associated with clients $\client_1$ and $\client_2$. 
%We write $\version(\hh, \ke, \vi)$ for $\hh(\ke, \vi(\ke))$; 
%and write $\valueOf(\hh, \ke, \vi)$ as a shorthand for $ \valueOf(\version(\hh, \key{k}, V))$; similarly for $\WTx, \RTx$.
%%we commit an abuse of notation and often write $\valueOf(\hh, \ke, \vi)$ in lieu of $ \valueOf(\version(\hh, \key{k}, V))$, and similarly for $\WTx, \RTx$.
%When $\ver = \version(\hh, \ke, \vi)$, we say that \emph{$\vi$ $\ke$-points to $\ver$ in $\hh$}. 
%When $\ver = \hh(\ke, i)$ for some $0 \leq i \le \vi(\ke)$, we say that \emph{$\vi$ $\ke$-includes $\ver$ in $\hh$}.
%Lastly, we always assume that MKVSs, views, and configurations are well-formed, unless otherwise stated.
%
%
%
%\begin{definition}[Configurations]
%A view $\vi$ is \emph{well-formed with respect to an MKVS} $\mkvs$, written \( \wfV{\mkvs, \vi} \),  iff they have the same domain and every index from $\vi$ is within the range of the corresponding entry in $\mkvs$ and the view is \emph{atomic} with  respect to the key-value store: 
%\[
%\begin{rclarray}
%    \wfV{\mkvs, \vi} & \defeq & \dom(\mkvs) = \dom(\vi) \land \fora{\ke \in \dom(\vi)} 0 \leq \vi(\ke) < \lvert \mkvs(\ke) \rvert \\
%    \pred{atomic}{\vi ,\hh} & \eqdef & \fora{\txid } \exsts{\ke, i} i \leq \vi(\ke) \land \hh(\ke,i) = (\stub, \txid, \stub) \implies \pred{visible}{\txid, \vi, \hh} \\ 
%    \pred{visible}{\txid, \vi, \hh} & \eqdef & \fora{\ke, i} \hh(\ke,i) = (\stub, \txid, \stub) \implies i \leq \vi(\ke) 
%\end{rclarray}
%\]
%%
%\azalea{We need a symbol for this to fill the ???? above. Also ???? below. \sx{Done}}
%A \emph{configuration} $\conf$ is a pair of the form $(\hh, \viewFun)$, where $\hh$ denotes an MKVS, and $\viewFun: \Clients \parfinfun \Views$ is a partial finite function from clients to views. 
%A configuration $\conf = (\hh, \viewFun)$ is \emph{well-formed}, written \( \wfC{\conf}\), iff for all clients $\cl \in \dom(\viewFun)$, the view $\viewFun(\txid)$ is well-formed with respect to $\hh$. 
%%We say that a view $V$ is well-defined with respect to the 
%%MKVS $\hh$ if, $\forall \key{k} \in \ke. 0 < V(\key{k}) \leq 
%%\lvert \hh(\key{k}) \rvert$. 
%%Given a view $V$ that is well-defined 
%%with respect to a 
%
%\end{definition}
%
%\mypar{Snapshots} When a client executes a transaction on the $\mkvs$ MKVS, it extracts a \emph{snapshot} of it via the \( \func{snapshot}{\mkvs, \vi} \) function, extracting the values corresponding to the versions indexed by its view \( \vi \) (\cref{def:snapshot}).
%For instance, for client \( \client_1 \) in \cref{fig:hheap-a}, the $\func{snapshot}{\cdots}$ functions yields a state where key $\ke_1$ carries value $v_1$ and second key \( \ke_2 \) carries value $v'_0$.
%%The concrete state extracted in this way takes the name of the \emph{snapshot} of the transaction.
%%In general, the process of determining the view of a client, hence the snapshot in which such a client executes transactions, is non-deterministic.
%
%\azalea{Before in MKVSs we had values drawn from $\Nat$ in \cref{def:mkvs}. Now we use $\Val$. I think you mean to use $\Val$ in both places? \sx{I would say so} }
%\begin{definition}[Snapshots]
%\label{def:heaps}
%\label{def:snapshot}
%Given the sets of values $\Val$  and keys \( \Addr\)  (\cref{def:mkvs}), the set of \emph{snapshots} is:
%$
%    \h \in \Heaps \eqdef \Addr \parfinfun \Val
%$. 
%%\[
%%\begin{rclarray}
%%    \h \in \Heaps & \eqdef & \Addr \parfinfun \Val
%%\end{rclarray}
%%\]
%The \emph{snapshot composition function}, $\composeH: \Heaps \times \Heaps \parfun \Heaps$, is defined as $\composeH \eqdef \uplus$, where $\uplus$ denotes the standard disjoint function union. The \emph{ snapshot unit element} is $\unitH \eqdef \emptyset$, denoting a function with an empty domain.
%The \emph{partial commutative monoid of snapshots} is $(\Heaps, \composeH, \{\unitH\})$.
%Given an MKVS $\hh$ and a view $\vi$, the snapshot of $\vi$ in $\hh$, written $\snapshot(\hh, \vi) $, is defined as:
%$
%    \snapshot(\hh, \vi) \defeq \lambda \ke \ldotp \valueOf(\hh, \ke, \vi)
%$.
%%\[
%%\begin{rclarray}
%%    \snapshot(\hh, \vi) & \defeq & \lambda \ke \ldotp \valueOf(\hh, \ke, \vi).
%%\end{rclarray}
%%\]
%\end{definition}
%
%\sx{Need some explanation}
%\ac{General Comment on this Section: it is too abstract. We 
%should give either here or in the introduction an example of computation - 
%the write skew program should be okay that helps the reader understanding 
%what's going on. Also, it could be also good to illustrate the notions 
%of execution tests and consistency models.}
%
%\sx{From Andrea: introduce the execution test here with a table, also introduce fingerprint here}

