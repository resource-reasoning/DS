\subsection{Multi-version Key-value Stores and Views}
\label{sec:mkvs-view}
\ac{I'm going to leave this comment here, I know it's going to be harsh but needs to be said: 
If you are going to change the main text, please be sure that the English is correct, and that the 
writing is consistent! It took me several days to get this in a good shape, and now I have to go over all of it again!}
%\ac{
%We focus on a computational model where multiple client programs can access and update 
%locations in a key-value store using atomic transactions. Transactions in our model execute atomically, 
%though the consistency guarantees that they provide do not necessarily correspond to \emph{serialisability}. 
%This means that, at the moment of executing, a transaction may not observe the most up-to-date value 
%of a location. 

%To overcome this issue, we model the state of the system using \emph{multi-version key-value stores} 
%(MKVSs) and \emph{views}. A 
%MKVS keeps track of all the versions written for any key, as well as the information 
%about the transactions that read and wrote such versions.  Views keep track of the version observed 
%for each key by clients. 
%}

%\sx{ Value as natural number or natural number + key index? Is partial mkvs is a problem here??}


%We often depict MKVSs graphically. 
%One example is given by the MKVS $\hh_0$ of Figure \ref{fig:hheap}(a) (ignore for the moment 
%the straight lines labelled $\txid_1$ and $\txid_2$).

%\ac{\sx{Partial is better for logic}Maybe it's better to keep $\ke$ fixed and say that we look at only a 
%fragment of the key value store. Alternatively, we can go for partial mappings to 
%represent MKVSs, but still avoiding allocation and deallocation of keys.}



%\ac{
%We often depict MKVSs graphically. 
%One example is given by the MKVS $\hh_0$ of Figure \ref{fig:hheap}(a) (ignore for the moment 
%the straight lines labelled $\txid_1$ and $\txid_2$).

%To the left 
%we have the set of keys stored y $\hh_0$, in this case $\key{k}_1$ and 
%$\key{k}_2$. To the right, on the same line of a key, a matrix containing the
 %list of versions stored by such a key in $\hh_0$. Starting from the first column, 
 %each version is represented by two adjacent columns in the matrix: the 
 %column to the left gives the value of the version, while the column to the 
 %right contains the identifier of the transaction that wrote the version to the 
 %top, and the identifiers of the transactions that read such a version to the bottom.
%In the case of $\hh_0$, there are two versions stored for $\key{k}_1$: 
%the first one with value $0$, written by $\txid_0$ and read by $\txid_2$; 
%and the second one with value $1$, written by $\txid_2$ and read by no 
%transaction. 
%}
\azalea{I have changed the values to $v_0$ and $v_1$ (from $0$ and $1$) to help clarify the distinction between indexes and values.
I have also paraphrased, please double check.  }

\subsubsection{Key-value Stores} 

We assume a countably infinite set of \emph{keys} $\Keys \defeq \Set{\ke, \ke', \cdots}$, 
a set of \emph{values} $\Val \defeq \{\val, \val', \cdots\}$ which for simplicity we instantiate to be 
$\Nat \uplus \Keys$, a set of clients $\Clients \defeq \Set{\cl, \cl',\cdots}$. 
We also assume a set of transaction identifiers $\TxID \defeq \Set{ \txid_{\cl}^{n} \mid \cl \in \Clients \wedge n \geq 0 } 
\uplus \Set{\txid_{0}}$,
each of which is either a special transaction identifier $\txid_0$, 
or it is indexed by a client identifier and a natural number. 
Elements of $\TxID$ are ranged over by $\txid, \txid', \cdots$, 
while subsets of $\TxID$ are ranged over $\txidset, \txidset', \cdots$. 
We let $\TxID_{0} \defeq \TxID \setminus \{ \txid_0\}$.
The structure of the set $\TxID$  
embeds the order in which transactions are executed by individual clients, or \emph{session order}. 
Specifically, we let $\PO \defeq \Set{ (\txid, \txid') \mid \exsts{ \cl, n,m } \txid = \txid_{\cl}^{n} \wedge \txid' = \txid_{\cl}^{m} \wedge n < m}$; 
$(\txid, \txid') \in \PO$ means that 
some client $\cl$ has executed $\txid$ prior to $\txid'$. For $\PO$ (and in general  
for relations between transaction identifiers) we will often adopt the more graphic notation 
$\txid \xrightarrow{\PO} \txid'$ in lieu of $(\txid, \txid') \in \PO$.

Given a set $X$, then $\powerset{X}$ denotes 
the powerset of $X$, while $X^{\ast}$ is the free monoid induced by $X$.


\begin{definition}[Multi-version Key-value Stores]
\label{def:his_heap}
\label{def:mkvs}
A \emph{version} is a triple $\ver = (\val, \txid, \txidset)$. The set of versions is denoted by $\Versions \defeq \Val \times \TxID \times \powerset{\TxID_{0}}$, 
and a \emph{key-value store} is a mapping $\hh \in \MKVSs \defeq \Keys \rightarrow \Versions^{\ast}$. 
\ac{ The superscript fin over the $\rightharpoonup$ needs to be fixed. You may want to look at the package extpfeil.}
%The set of key-value stores is denoted as $\HisHeaps$.
\end{definition}

\emph{A version} $\ver = (\val, \txid, \txidset)$ consists of a value $\val$, and the meta-data of the transactions 
that accessed the version; specifically, $\txid$ is the identifier of the transaction that wrote such a version, 
and $\txidset$ is the set of identifiers of transactions that read the version.
Given a version $\ver = (\val, \txid, \txidset)$, we let $\valueOf(\ver) \defeq \val$. 
$\WTx(\ver) \defeq \txid$ and $\RTx(\ver) \defeq \txidset$.
Lists of versions, that is elements of $\Versions^{\ast}$, are ranged over by $\vilist, \vilist',\cdots$.

\emph{A multi-version key-value store}, or \emph{kv-store}, 
is a mapping from keys to lists of versions. 
For a given kv-store $\hh$, key $\ke$ and index $i \geq 0$, we use the notation $\hh(\ke, i)$ 
to denote the $i$-th version (starting from $0$) installed for $\ke$; that is, if $\hh(\ke) = \ver_0 \cdots\ver_{n}$, then 
$\hh(\ke, i) \defeq \ver_{i}$ if $i \leq n$, it is undefined otherwise. We also let $\lvert \hh(\ke) \rvert \defeq n +1 $ denote 
the length of $\hh(\ke)$.

{\color{red} 
It will be often convenient to depict key-value stores graphically: an 
example is given by the kv-store $\hh$ depicted in \cref{fig:hheap-a}
{\color{red} (ignore for the moment the vertical lines labelled $\client$ and $\client'$)}. 
It comprises two keys \( \ke_1\) and \( \ke_2 \), 
each of which is associated with two versions carrying values $\val_0$ and $\val_1$, and $\val'_0$ and $\val'_1$, respectively.
The versions of a key are listed in order from left to right. 
We represent each version as a three-cell box, with the left cell storing the value, the top right cell recording the writer, and the bottom right cell recording the readers. 
For example, the version carrying value $\val_0$ in $\ke_1$ has been written by $\txid_0$, and has been read by $\txid_{\cl'}^1$.
}

In this paper we focus on key-value stores whose consistency model enforces the  
\emph{atomic visibility} of transactions \cite{framework-concur}. 
We also assume that in kv-stores, keys with a defined list of versions, have an initial version carrying  a default value $\val_0 \in \Val$, 
written by the special transaction identifies $\txid_0$.
A \emph{well-formed} kv-store $\hh$ requires that:
\begin{enumerate}[(i)]
\item\label{kv:wf.init} for each key $\ke \in \dom(\hh)$, $\hh(\ke, 0) = (\val_0, \txid_0, \stub)$, where $\val_0$ is a default value from $\Val$;
\item\label{kv:wf.onewrite} transactions never write more than one version per key,  
\[
\fora{\ke \in \dom(\hh), i,j : 0 \leq i, j < \abs{ \hh(\ke) }}
\WTx(\hh(\ke, i)) = \WTx(\hh(\ke, j)) \implies i = j 
\]
\item\label{kv:wf.oneread} transactions never read different versions for the same key, 
\[
\fora{\ke \in \dom(\hh), i,j : 0 \leq i, j < \abs{ \hh(\ke) }} 
\RTx(\hh(\ke, i)) \cap \RTx(\hh(\ke, j)) \neq \emptyset \implies i = j
\]
\item\label{kv:wf.so} the order 
in which transactions issued by the same client install different versions for some key $\ke$, is consistent with the order in which 
such transactions have been invoked; similarly, a client can read the version of a key $\ke$ only after it installed it. 
\begin{multline*}
    \fora{ \ke \in \dom(\hh), \cl \in \Clients, i,j: 0 \leq i < j < \abs{\hh(\ke)}, n, m} \\
(\txid_{\cl}^{n} = \WTx(\hh(\ke,i)) \wedge \txid_{\cl}^{m} \in \{\WTx(\hh(\ke,j))\} \cup \RTx(\hh(\ke, i)) \implies n < m.
\end{multline*}
\end{enumerate}
We always assume that kv-stores are well-formed, and let $\HisHeaps$ be the set of well-formed kv-stores.


\begin{figure}
\begin{center}
\hrule
\begin{tabular}{@{}c @{\qquad} c@{}}
\begin{halfsubfig}
\begin{tikzpicture}
\begin{pgfonlayer}{foreground}
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\ke_1 \mapsto$};

\matrix(versionx) [version list]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\txid_{\cl}^{1}$\\
    {a} & $\left\{\txid_{\cl'}^{1}\right\}$ & {a} & $\emptyset$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$v_0$};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$v_1$};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_2 \mapsto$};
\matrix(versiony) [version list]
   at ([xshift=\tikzkvspace]locy.east) {
 {a} & $\txid_0$ & {a} & $\txid_{\cl'}^{1}$ \\
  {a} & $\left\{\txid_{\cl}^1\right\}$ & {a} & $\emptyset$\\
};

\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$v'_0$};
\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{$v'_1$};

% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
 ([xshift=-3pt, yshift=20pt]locx-v1.north east) node (tid1start) {} -- 
 ([xshift=-3pt, yshift=-5pt]locx-v1.south east) --
 ([xshift=-3pt, yshift=5pt]locy-v0.north east) -- 
 ([xshift=-3pt, yshift=-5pt]locy-v0.south east);
 
 \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\client$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
 ([xshift=-16pt, yshift=5pt]locx-v1.north east) node (tid2start) {}-- 
% ([xshift=-16pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-16pt, yshift=5pt]locy-v1.north east) -- 
 ([xshift=-16pt, yshift=-5pt]locy-v1.south east) node {};
 
\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\client'$};

\end{pgfonlayer}
\end{tikzpicture}
\caption{A configuration with a well-formed kv-store $\hh$ and two views $\vi,\vi'$.}
\label{fig:hheap-a}
\end{halfsubfig}
&

\begin{halfsubfig} 
\begin{center}
\begin{tikzpicture}[scale=0.85, every node/.style={transform shape}]
%\draw[help lines] grid(6,4);

\node(t0wx) at (-1,2) {$(\otW, \ke_1, \val_0)$}; 
\path (t0wx.south) + (0,-0.2) node[anchor=north] (t0wy) {$(\otW, \ke_2, \val'_0)$};
\path (t0wx.north east) + (1,0.5) node[anchor = west] (t1ry) {$(\otR, \ke_2, \val'_0)$}; 
\path (t1ry.east) + (0.2,0) node[anchor = west] (t1wx) {$(\otW, \ke_1, \val_1)$};
\path (t0wy.south east) + (1,-0.5) node[anchor = west] (t2rx) {$(\otR, \ke_1, \val_0)$};
\path (t2rx.east) + (0.2,0) node[anchor = west] (t2wy) {$(\otW, \ke_2, \val'_1$)};

\begin{pgfonlayer}{background}
\node[background, fit=(t0wx) (t0wy)] (t0) {};
\node[background, fit= (t1ry) (t1wx)] (t1) {};
\node[background, fit= (t2rx) (t2wy)] (t2) {};

\path(t0.west) node[anchor=east] (t0lbl) {$\txid_0$};
\path(t1.north) node[anchor=south] (t1lbl) {$\txid_1$};
\path(t2.south) node[anchor=north] (t2lbl) {$\txid_2$};

\path[->]
(t0.north) edge[bend left=70] node[above, yshift=7pt, xshift=-1pt, pos=0.3] {$\RF(\ke_2), \VO(\ke_1)$} (t1.west)
(t0.south) edge[bend right=70] node[below, yshift=-8pt, xshift=-1pt, pos=0.3] {$\RF(\ke_1), \VO(\ke_2)$} (t2.west)
([xshift=-8pt]t2.north) edge[bend left=40] node[left] {$\AD(\ke_1)$} ([xshift=-8pt]t1.south) 
([xshift=8pt]t1.south) edge[bend left=40] node[right] {$\AD(\ke_2)$} ([xshift=8pt]t2.north);
\end{pgfonlayer}

\end{tikzpicture}
\end{center}
\caption{The dependency graph induced by $\hh$.}
\label{fig:hheap-b}
\end{halfsubfig} \\
\end{tabular}
\end{center}
\hrule
\caption{Multi-version key-value stores}
\label{fig:hheap}
\end{figure}

\mypar{Views, Configurations and Snapshots.}
The key-value store tracks the global state, 
but when executing transactions, different \emph{clients} may observe 
different versions of the same key. To keep track of 
the versions they observe, clients are associated with \emph{views} (\cref{def:view}). 

\begin{definition}[Views and configurations]
\label{def:view}
\label{def:cuts}
\label{def:views}
\label{def:configuration}
Given a key-value store $\hh$, \emph{a view} of $\hh$ is a function  
$\vi: \dom(\hh) \to\powerset{\Nat}$ such that  
\[
\forall \ke \in \dom(\hh).\; 0 \in \vi(\ke) \wedge \forall i \in \vi(\ke).\; i < \lvert \hh(\ke) \rvert.
\]
and 
\begin{equation}
\label{eq:view.atomic}
\begin{array}{@{}l@{}}
\fora{ \ke,\ke' \in \dom(\hh), i,j \in \Nat} \\
\quad (j \in \vi(\ke) \wedge \WTx(\hh(\ke, j)) = \WTx(\hh(\ke', i)) \implies i \in \vi(\ke')
\end{array}
\tag{Atomic}
\end{equation}

\ac{ ALL THE FIGURES THAT USED VIEWS MUST BE DRAWN AGAIN. WE ALSO NEED A 
GRAPHIC FORMALISM FOR THE NEW NOTION OF VIEWS.}

The set of views of $\hh$ is denoted 
as $\Views(\hh)$, and \emph{the set of views} is defined as:
\[
\Views \defeq \bigcup_{\hh \in \HisHeaps} \Views(\hh)
\]
A \emph{configuration} $\conf$ is a pair $(\hh, \viewFun)$, where $\viewFun: 
\Clients \parfinfun \Views(\hh)$. The configuration $\conf_{0} = (\hh_{0}, \viewFun_{0})$ is 
initial if, for any $\ke$, $\hh_{0}(\ke) = (\val_0, \txid_0, \emptyset)$, for some 
initial value $\val_0$. 
The set of configurations is denoted as $\Confs$.
\end{definition}
Given $\hh \in \HisHeaps$ and two views $\vi, \vi' \in \Views(\hh)$, 
we let $\vi \viewleq \vi'$ if, for any $\ke \in \dom(\hh)$, $\vi(k) \subseteq \vi'(\ke)$. 

\emph{A configuration} includes a kv-store and a partial mapping from clients from clients to views.
The view of the client $\cl$ in $\hh$ reflects the set of versions for each key 
that the client \(\cl \) observes upon executing a transaction. 
The constraint of \cref{eq:view.atomic} establishes that if a client observes 
a version of some key written by a transaction $\txid$, then it must observe all the versions of 
all keys that $\txid$ wrote. This constraint captures the \emph{atomic visibility} of transactions.

{\color{red} We often depict views of clients graphically by drawing client-labelled lines crossing 
versions of key-value stores. A line crossing the $i$-th version of key $\ke$ defines a view 
$\vi$ for client $\cl$, with $\vi(\ke) = i$. One example is given by \cref{fig:hheap-a} where the configuration is
$\conf_0 = (\hh_0, \Set{\cl_1 \mapsto \vi_1, \cl_2 \mapsto \vi_2})$. 
There are two clients, 
$\cl_1$ and $\cl_2$, with views $\vi_1$, and $\vi_2$ respectively. $\vi_1$ crosses $\ke_1$ at its $0$-th 
version, and $\ke_2$ at its $1$-st version. Therefore we have $\vi_1 = \Set{\ke_1 \mapsto 0, \ke_2 \mapsto 1}$. 
Similarly, we have $\vi_2 = \Set{\ke_1 \mapsto 1, \ke_2 \mapsto 0}$. }

Given a kv-store $\hh$, a view $\vi$ and a key $\ke \in \dom(\hh)$, 
we commit an abuse of notation and write $\hh(\ke, \vi)$ as a shorthand 
for $\hh(\ke, \max_{<}(\vi(\ke)))$. Note that such a version is well-defined because 
we are assuming that $\vi(\ke) \neq \emptyset$.
The view $\vi$ naturally induces a \emph{snapshot} 
by extracting the value of the most up-to-date version it observes for each key $\ke \in \dom(\hh)$. 
As we will see presently, transactions are executed relatively 
to a snapshot of a kv-store, which maps each key to a single value.
Views are used to determine the snapshot in which a transaction 
is executed, according to the following definition.
\begin{definition}[Snapshots]
\label{def:heaps}
\label{def:snapshot}
Given $\hh \in \HisHeaps$ and $\vi \in \Views(\hh)$, the \emph{snapshot} of $\vi$ in 
$\hh$ is defined as $\snapshot(\hh, \vi) \defeq \lambda \ke \ldotp \valueOf(\hh(\ke, \max_{<}(\vi(\ke)))$.
\end{definition}

%of $\vi$ by accessing the value of 
%A view $\vi$ in $\hh$ naturally defines a snapshot $\snapshot(\hh, \nu)$
%A MKVS tracks the global state of the system; however, different \emph{clients} may observe different versions of the same key. 
%To model this, we introduce the notion of \emph{views} (\cref{def:views}). 
%A view $V$ reflects the particular version for each key that a client observes upon executing a transaction. 
%%We present an example of views in \cref{fig:hheap-a} with two views: $\client_1$ in red and $\client_2$ in blue.
%More concretely, the view for \( \client_1 \) is given formally as $\vi_1 = \Set{\key{k}_1 \mapsto 1, \key{k}_2 \mapsto 0}$.
%That is, the client with view $\vi_1$ observes the second version (at index 1) of key \( \ke_{1} \) with value $v_1$, and the first version (at index 0) of key \( \ke_2 \) with value $v'_0$.
%%, and 
%%the first version of $\key{k}_2$, carrying value $0$. Similarly, according to its view 
%%$V_2 = [\key{k}_1 \mapsto 2, \key{k}_2 \mapsto 2]$, the client $\txid_2$ observes 
%%in $\hh$the second and most up-to-date version for both $\key{k}_1$ and $\key{k}_2$.
%
%\begin{definition}[Views]
%\label{def:view}
%\label{def:cuts}
%\label{def:views}
%\emph{A view} is a partial finite function from keys to indexes:
%$
%\vi \in \Views \defeq \Addr \parfinfun \Nat 
%%\begin{rclarray}
%%    \vi \in \Views & \defeq & \Addr \parfinfun \Nat 
%%\end{rclarray}
%$.                                                                 
%The \emph{view composition}, $\composeVI: \Views \times \Views \rightharpoonup \Views$ is defined as the standard disjoint function union: $\composeVI \eqdef \uplus$. 
%% \( \vi \composeVI \vi' \defeq \vi \uplus \vi'\) 
%The \emph{unit view}, $\unitVI \in \Views$, is a function with an empty domain: $\unitVI \eqdef \emptyset$. 
%% and the unit is \( \unitVI \defeq \emptyset\).
%The \emph{order relation} on views, $\orderVI: \Views \times \Views$, is defined between two views with the same domain as the point-wise comparison of their indexes for each entry: 
%\[
%\begin{rclarray}
%    \vi \orderVI \vi' & \defiff & \dom(\vi) = \dom(\vi') \land \fora{\ke} \cu(\ke) \leq \cu'(\ke) \\
%\end{rclarray}
%\]
%\end{definition}
%%
%We say view $\vi$ is \emph{older} than view $\vi'$ (or $\vi'$ is \emph{newer} than $\vi$) whenever $\vi \orderVI \vi'$ holds.
%
%
%\mypar{Configurations} A \emph{configuration} comprises an MKVS, and the views associated with clients.
%In \cref{fig:hheap-a} we present an example of a configuration comprising an MKVS and the two views associated with clients $\client_1$ and $\client_2$. 
%We write $\version(\hh, \ke, \vi)$ for $\hh(\ke, \vi(\ke))$; 
%and write $\valueOf(\hh, \ke, \vi)$ as a shorthand for $ \valueOf(\version(\hh, \key{k}, V))$; similarly for $\WTx, \RTx$.
%%we commit an abuse of notation and often write $\valueOf(\hh, \ke, \vi)$ in lieu of $ \valueOf(\version(\hh, \key{k}, V))$, and similarly for $\WTx, \RTx$.
%When $\ver = \version(\hh, \ke, \vi)$, we say that \emph{$\vi$ $\ke$-points to $\ver$ in $\hh$}. 
%When $\ver = \hh(\ke, i)$ for some $0 \leq i \le \vi(\ke)$, we say that \emph{$\vi$ $\ke$-includes $\ver$ in $\hh$}.
%Lastly, we always assume that MKVSs, views, and configurations are well-formed, unless otherwise stated.
%
%
%
%\begin{definition}[Configurations]
%A view $\vi$ is \emph{well-formed with respect to an MKVS} $\mkvs$, written \( \wfV{\mkvs, \vi} \),  iff they have the same domain and every index from $\vi$ is within the range of the corresponding entry in $\mkvs$ and the view is \emph{atomic} with  respect to the key-value store: 
%\[
%\begin{rclarray}
%    \wfV{\mkvs, \vi} & \defeq & \dom(\mkvs) = \dom(\vi) \land \fora{\ke \in \dom(\vi)} 0 \leq \vi(\ke) < \lvert \mkvs(\ke) \rvert \\
%    \pred{atomic}{\vi ,\hh} & \eqdef & \fora{\txid } \exsts{\ke, i} i \leq \vi(\ke) \land \hh(\ke,i) = (\stub, \txid, \stub) \implies \pred{visible}{\txid, \vi, \hh} \\ 
%    \pred{visible}{\txid, \vi, \hh} & \eqdef & \fora{\ke, i} \hh(\ke,i) = (\stub, \txid, \stub) \implies i \leq \vi(\ke) 
%\end{rclarray}
%\]
%%
%\azalea{We need a symbol for this to fill the ???? above. Also ???? below. \sx{Done}}
%A \emph{configuration} $\conf$ is a pair of the form $(\hh, \viewFun)$, where $\hh$ denotes an MKVS, and $\viewFun: \Clients \parfinfun \Views$ is a partial finite function from clients to views. 
%A configuration $\conf = (\hh, \viewFun)$ is \emph{well-formed}, written \( \wfC{\conf}\), iff for all clients $\cl \in \dom(\viewFun)$, the view $\viewFun(\txid)$ is well-formed with respect to $\hh$. 
%%We say that a view $V$ is well-defined with respect to the 
%%MKVS $\hh$ if, $\forall \key{k} \in \ke. 0 < V(\key{k}) \leq 
%%\lvert \hh(\key{k}) \rvert$. 
%%Given a view $V$ that is well-defined 
%%with respect to a 
%
%\end{definition}
%
%\mypar{Snapshots} When a client executes a transaction on the $\mkvs$ MKVS, it extracts a \emph{snapshot} of it via the \( \func{snapshot}{\mkvs, \vi} \) function, extracting the values corresponding to the versions indexed by its view \( \vi \) (\cref{def:snapshot}).
%For instance, for client \( \client_1 \) in \cref{fig:hheap-a}, the $\func{snapshot}{\cdots}$ functions yields a state where key $\ke_1$ carries value $v_1$ and second key \( \ke_2 \) carries value $v'_0$.
%%The concrete state extracted in this way takes the name of the \emph{snapshot} of the transaction.
%%In general, the process of determining the view of a client, hence the snapshot in which such a client executes transactions, is non-deterministic.
%
%\azalea{Before in MKVSs we had values drawn from $\Nat$ in \cref{def:mkvs}. Now we use $\Val$. I think you mean to use $\Val$ in both places? \sx{I would say so} }
%\begin{definition}[Snapshots]
%\label{def:heaps}
%\label{def:snapshot}
%Given the sets of values $\Val$  and keys \( \Addr\)  (\cref{def:mkvs}), the set of \emph{snapshots} is:
%$
%    \h \in \Heaps \eqdef \Addr \parfinfun \Val
%$. 
%%\[
%%\begin{rclarray}
%%    \h \in \Heaps & \eqdef & \Addr \parfinfun \Val
%%\end{rclarray}
%%\]
%The \emph{snapshot composition function}, $\composeH: \Heaps \times \Heaps \parfun \Heaps$, is defined as $\composeH \eqdef \uplus$, where $\uplus$ denotes the standard disjoint function union. The \emph{ snapshot unit element} is $\unitH \eqdef \emptyset$, denoting a function with an empty domain.
%The \emph{partial commutative monoid of snapshots} is $(\Heaps, \composeH, \{\unitH\})$.
%Given an MKVS $\hh$ and a view $\vi$, the snapshot of $\vi$ in $\hh$, written $\snapshot(\hh, \vi) $, is defined as:
%$
%    \snapshot(\hh, \vi) \defeq \lambda \ke \ldotp \valueOf(\hh, \ke, \vi)
%$.
%%\[
%%\begin{rclarray}
%%    \snapshot(\hh, \vi) & \defeq & \lambda \ke \ldotp \valueOf(\hh, \ke, \vi).
%%\end{rclarray}
%%\]
%\end{definition}
%
%\sx{Need some explanation}
%\ac{General Comment on this Section: it is too abstract. We 
%should give either here or in the introduction an example of computation - 
%the write skew program should be okay that helps the reader understanding 
%what's going on. Also, it could be also good to illustrate the notions 
%of execution tests and consistency models.}
%
%\sx{From Andrea: introduce the execution test here with a table, also introduce fingerprint here}

\mypar{Relationship between kv-stores and dependency graphs.}
\ac{It could be that this subsection gets moved to a different section, where 
we also relate specifications of consistency models using dependency graphs
with execution tests.}
\emph{Dependency graphs} are a formalism  introduced by Adya to specify 
consistency models of transactional databases \cite{adya}. 
They are directed graphs consisting of transactions as nodes, 
each of which is labelled with a set of read and write operations, 
$\Ops \defeq \Setcon{(\otR, \ke, \val), (\otW, \ke, \val) }{ \ke \in \Keys \wedge \val \in \Val }$
and labelled edges between transactions for specifying how information flows within a computation. 
Specifically, a transaction $\txid$ may read a version for a key $\ke$ that has been written by another transaction $\txid'$ 
(\emph{write-read dependency} \( \WR\)), overwrite a version of $\ke$ written by $\txid'$ (\emph{write-write dependency} \( \WW \)), or 
read a version of $\ke$ that is later overwritten by $\txid'$ (\emph{read-write anti-dependency} \( \RW \)).
\begin{definition}
A \emph{dependency graph} is a quadruple $\Gr = (\TtoOp{T}, \RF, \VO, \AD)$, where
\begin{itemize}
\item $\TtoOp{T}: \TxID_{0} \parfinfun \powerset{\Ops}$ is a partial finite function 
mapping transaction identifiers to the set of operations they perform, where there are at most one read operation and one write operation for each key,
\item $\RF : \Keys \to \pset{\dom(\TtoOp{T}) \times \dom(\TtoOp{T})}$ is a function that 
maps each key $\ke$ into a relation between transactions, such that for any $\txid, \txid_1, \txid_2, 
\ke, \cl, m, n$: 
\begin{itemize}
\item if $(\otR, \ke, \val) \in \TtoOp{T}(\txid)$, either $\val = \val_0$ 
and there exists no $\txid'$ such that $\txid' \xrightarrow{\RF(\ke)} \txid$,  
or there exists $\txid'$ such that $(\otW, \ke, \val) \in \TtoOp{T}(\txid')$, and $\txid' \xrightarrow{\RF(\ke)} \txid$, 
\item if $\txid_1 \xrightarrow{\RF(\ke)} \txid$ and $\txid_2 \xrightarrow{\RF(\ke)} \txid$, then 
$\txid_2 = \txid_1$, 
\item if $\txid_{\cl}^{m} \xrightarrow{\RF(\ke)} \txid_{\cl}^{n}$, then $m < n$.
\end{itemize}
\item $\VO: \Keys \to \pset{\dom(\TtoOp{T}) \times \dom(\TtoOp{T})}$ is a function 
that maps each key into an irreflexive relation between transactions, such that for any $\txid, \txid', \ke, \cl, m, n$, 
\begin{itemize}
\item if $\txid \xrightarrow{\VO(\ke)} \txid'$, then $(\otW, \ke, \_) \in \TtoOp{T}(\txid), (\otW, \ke, \_) \in \TtoOp{T}(\txid')$, 
\item if $(\otW, \ke, \_) \in \TtoOp{T}(\txid), (\otW, \ke, \_) \in \TtoOp{T}(\txid')$, then either $\txid = \txid'$, 
$\txid \xrightarrow{\VO(\ke)} \txid'$, or $\txid' \xrightarrow{\VO(\ke)} \txid$, 
\item if $\txid_{\cl}^{m} \xrightarrow{\RF(\ke)} \txid_{\cl}^{n}$, then $m < n$.
\end{itemize}
\item $\AD: \Keys \to \pset{\dom(\TtoOp{T}) \times \dom(\TtoOp{T})}$ is defined 
by letting $\txid \xrightarrow{\AD(\ke)} \txid'$ if and only if $(\otR, \ke, \_) \in \TtoOp{T}(\txid)$, 
$(\otW, \ke, \_) \in \TtoOp{T}(\txid')$ and 
either there exists no $\txid''$ such that $\txid'' \xrightarrow{\RF(\ke)} \txid$, or 
$\txid'' \xrightarrow{\RF(\ke)} \txid$, $\txid'' \xrightarrow{\VO(\ke)} \txid'$ for 
some $\txid''$.
\end{itemize}
\end{definition}
Given a dependency graph $\Gr = (\TtoOp{T}, \RF, \VO, \AD)$, we often 
commit an abuse of notation and use $\RF$ to denote the relation 
$\bigcup\limits_{\ke \in \Keys} \RF(\ke)$; a similar notation is adopted for $\VO, \AD$. 
It will always be clear from the context whether the symbol $\RF$ refers to a function 
from keys to relations, or to a relation between transactions. 

%A dependency graph $\Gr = (\TtoOp{T}, \RF, \VO, \AD)$ is well-formed if 
%$(\PO \cup \RF \cup \VO)$ is acyclic, i.e. its transitive closure is irreflexive. 
%Henceforth, we always assume that dependency graphs are well-formed, 
%and we let 
We let $\Dgraphs$ be the set of all dependency graphs.
It is always possible to convert a kv-store $\hh$ into a well-formed dependency 
graph. For example, \cref{fig:hheap-b} illustrates the dependency graph constructed 
from the kv-store depicted in \cref{fig:hheap-a}.

\begin{definition}
\label{def:kv2graph}
Given a kv-store $\hh$, the \emph{dependency graph} $\Gr_{\hh} = (\TtoOp{T}_{\hh}, \RF_{\hh}, 
\VO_{\hh}, \AD_{\hh})$ is defined as follows: 
\begin{itemize}
\item for any $\txid \neq \txid_0$, $\TtoOp{T}_{\hh}(\txid)$ is defined if and only if there exists an index $i$ and a key 
$\ke$ such that either $\txid = \WTx(\hh(\ke, i))$, or $\txid \in \RTx(\hh(\ke,i))$; furthermore, 
$(\otW, \ke, \val) \in \TtoOp{T}(\txid)$ if and only 
if $\txid = \WTx(\hh(\ke, i))$ for some $i$, and 
$(\otR, \ke, \val) \in \TtoOp{T}(\txid)$ if and only if $\txid \in \RTx(\hh(\ke, i))$ for some $i$, 
\item $\txid \xrightarrow{\RF(\ke)} \txid'$ if and only if there exists an index $i: 0 < i < \lvert \hh(\ke) \rvert$ 
such that $\txid = \WTx(\hh(\ke, i))$, and $\txid' \in \RTx(\hh(\ke, i))$, 
\item $\txid \xrightarrow{\VO(\ke)} \txid'$ if and only if there exist two indexes $i,j$: $0 < i < j < \lvert \hh(\ke) \rvert$ 
such that $\txid = \WTx(\ke, i)$, $\txid' = \WTx(\ke, j)$, 
\item $\txid \xrightarrow{\AD(\ke)} \txid'$ if and only if there exist two indexes $i,j$: $0 < i < j < \lvert \hh(\ke) \rvert$ 
such that $\txid \in \RTx(\ke, i)$ and $\txid' = \WTx(\ke, j)$.
\end{itemize}
\end{definition}

\begin{theorem}
\label{thm:kv2graph}
The function $\Gr_{(\stub)}$ is a bijection between kv-stores and well-formed dependency graphs.
\end{theorem}
\begin{proof}
See \cref{sec:kv2graph-proof}.
\end{proof}

\ac{Both the formal definition of dependency graph and the function $\graphof$ will need to go in the appendix.}
