\subsection{Multi-version Key-value Stores and Views}
\label{sec:mkvs-view}
\azalea{I rewrote most of this section. Please make sure you are happy with this.}
%\ac{
%We focus on a computational model where multiple client programs can access and update 
%locations in a key-value store using atomic transactions. Transactions in our model execute atomically, 
%though the consistency guarantees that they provide do not necessarily correspond to \emph{serialisability}. 
%This means that, at the moment of executing, a transaction may not observe the most up-to-date value 
%of a location. 

%To overcome this issue, we model the state of the system using \emph{multi-version key-value stores} 
%(MKVSs) and \emph{views}. A 
%MKVS keeps track of all the versions written for any key, as well as the information 
%about the transactions that read and wrote such versions.  Views keep track of the version observed 
%for each key by clients. 
%}

%\sx{ Value as natural number or natural number + key index? Is partial mkvs is a problem here??}


%We often depict MKVSs graphically. 
%One example is given by the MKVS $\hh_0$ of Figure \ref{fig:hheap}(a) (ignore for the moment 
%the straight lines labelled $\txid_1$ and $\txid_2$).
\ac{\sx{Partial is better for logic}Maybe it's better to keep $\ke$ fixed and say that we look at only a 
fragment of the key value store. Alternatively, we can go for partial mappings to 
represent MKVSs, but still avoiding allocation and deallocation of keys.}



%\ac{
%We often depict MKVSs graphically. 
%One example is given by the MKVS $\hh_0$ of Figure \ref{fig:hheap}(a) (ignore for the moment 
%the straight lines labelled $\txid_1$ and $\txid_2$).

%To the left 
%we have the set of keys stored y $\hh_0$, in this case $\key{k}_1$ and 
%$\key{k}_2$. To the right, on the same line of a key, a matrix containing the
 %list of versions stored by such a key in $\hh_0$. Starting from the first column, 
 %each version is represented by two adjacent columns in the matrix: the 
 %column to the left gives the value of the version, while the column to the 
 %right contains the identifier of the transaction that wrote the version to the 
 %top, and the identifiers of the transactions that read such a version to the bottom.
%In the case of $\hh_0$, there are two versions stored for $\key{k}_1$: 
%the first one with value $0$, written by $\txid_0$ and read by $\txid_2$; 
%and the second one with value $1$, written by $\txid_2$ and read by no 
%transaction. 
%}
\azalea{I have changed the values to $v_0$ and $v_1$ (from $0$ and $1$) to help clarify the distinction between indexes and values.
I have also paraphrased, please double check.  }

\mypar{Key-value Stores} 

%We model the state of a system using \emph{multi-version key-value stores} (MKVSs). 
We assume a countably infinite set of \emph{keys} $\Keys = \{\ke, \ke', \cdots\}$, 
a set of \emph{values} $\Val = \{\val, \val', \cdots\}$, a set of clients $\Clients = \{\cl, \cl',\cdots\}$. 
We also assume a set of transaction identifiers $\TxID = \{ \txid_{\cl}^{n} \mid \cl \in \Clients \wedge n \geq 0 \} 
\uplus \{\txid_{0}\}$,
each of which is either a special transaction identifier $\txid_0$, 
or it is indexed by a client identifier and a natural number. This particular structure is chosen to 
embed the session order of transactions executed by individual clients (\cref{sec:exectest}). Elements 
of $\TxID$ are ranged over by $\txid, \txid', \cdots$, while subsets of $TxID$ are ranged over 
$\txidset, \txidset', \cdots$. Given a set $X$, then $\powerset{X}$ denotes 
the powerset of $X$, while $X^{\ast}$ is the free monoid induced by $X$.

\begin{definition}[Multi-version key-value stores]
\label{def:his_heap}
\label{def:mkvs}
%Assuming a countably infinite set of keys $\Keys = \Set{\ke_1, \cdots}$, \emph{transactions identifiers} \( \TxID \defeq \Set{\txid_{1}, \cdots}\) and natural numbers \(\nat \in \Nat \), 
A \emph{version} is a triple $\ver = (\val, \txid, \txidset)$. The set of versions is denoted by $\Versions \defeq \Val \times \TxID \times \powerset{\TxID}$, 
where $\powerset{\cdot}$ is the powerset operator. 

A \emph{key-value store} is a partial, finite mapping $\hh : \Keys \parfinfun \Versions^{\ast}$. 
%The set of key-value stores is denoted as $\HisHeaps$.
\end{definition}
Elements of $\Versions^{\ast}$ are ranged over by $\vilist, \vilist',\cdots$.
\ac{Is it safe to assume that key-value stores are partial functions? What happens if we execute a program 
that tries to access a key that is not in the key-value store? In his Thesis, Viktor had the notion of fault to distinguish cases 
where non-allocated variables were used. Check.}
Intuitively, a version $\ver = (\val, \txid, \txidset)$ consists of a value and the meta-data of the transactions 
that accessed such a version; specifically, $\txid = \WTx(\ver)$ denotes the transaction identifier corresponding to the 
writer of the version, while $\txidset = \RTx(\ver)$ contains the set of the transaction identifier that read a version. 
A key-value store is then a mapping from keys to the list of versions that have been installed by 
transactions for such a key. For a given kv-store, $\hh$, key $\ke$ and index $i \geq 0$, we use the notation $\hh(\ke, i)$ 
the $i$-th version (starting from $0$) installed for $\ke$; that is, if $\hh(\ke) = \ver_0 \cdots\ver_{n}$, then 
$\hh(\ke, i) = \ver_{i}$ if $i \leq n$, it is undefined otherwise. We also let $\lvert \hh(\ke) \rvert = n +1 $ denote 
the length of $\hh(\ke)$.

It will be often convenient to depict key-value stores graphically: an 
example is given by the kv-store $\hh_{0}$ of Figure \cref{fig:hheap-a}.
Ignoring the lines labelled $\client_1$ and $\client_2$, $\hh_{0}$ contains two keys \( \ke_1\) and \( \ke_2 \), 
each of which associated with two versions (with values $v_0$ and $v_1$ for $\ke_1$, and values $v'_0$ and $v'_1$ for $\ke_2$).
The versions of a key are listed in %chronological 
order from left to right. 
We represent each version as a three-cell box, with the left cell storing the value, the top right cell recording the writer, and the bottom right cell recording the readers. 

In this paper we only focus on kv-stores whose consistency model ensures that transactions enjoy 
\emph{atomic visibility} \cite{framework-concur}. We also assume that the special transaction identifier $\tsid_0$ is used 
to install the initial version of a key. This amounts to require from a kv-store $\hh$ that \textbf{(i)} for each 
key $\ke \in \dom(\hh)$, $\hh(\ke, 0) = (v_0, \txid_0, \_)$ for some initial value $v_0$,
\textbf{(ii)} transactions never write more than one version per key - $\forall \ke \in \dom(\hh)\; \forall i,j : 0 \leq i, j < \lvert \hh(\ke) \rvert.\; 
\WTx(\ke, i) = \WTx(\ke, j) \implies i = j$, \textbf{(iii)} transactions never read different versions 
for the same key - $\forall \ke \in \dom(\hh).\; \forall i,j : 0 \leq i, j < \lvert \hh(\ke) \rvert.\; 
\RTx(\ke, i) \cap \RTx(\ke, j) \neq \emptyset \implies i = j$, and 
\textbf{(iv)} all the reads of a transactions precede the writes of the same transaction. $\forall \ke \in \dom(\hh). 
\forall i : 0 \leq i < \lvert \hh(k) \rvert.\; \WTx(\hh, k) \notin \RTx(\hh,k)$. We also require that \textbf{(v)} the order 
in which transactions issued by the same client install different versions for some key $\ke$, is consistent with the order in which 
such transactions have been invoked by the client  - $\forall \ke \in \dom(\hh), \cl \in \Clients.\;\forall i,j; 0 \leq i < j < \lvert \hh(\ke) \rvert. 
\forall n, m \geq 0.\; (\WTx(\ke(k,i)) = \txid_{\cl}^{n} \wedge \WTx(\ke(k,j)) = \txid_{\cl}^{m}) \implies n < m$.
We call kv-stores that satisfy the conditions (i-v) \emph{well-formed}. Henceforth, we always assume that kv-stores 
are well formed, and let $\HisHeaps$ be the set of well-formed kv-stores.


%A\emph{multi-version key-value store (MKVS)}, \( \mkvs \in \MKVSs \), is a partial finite function from keys to lists of \emph{versions}.
%A \emph{version} is a triple containing a program value \( \val \), a transaction identifier \( \txid \) and a set of transactions identifiers \( \txidset \):
%\[
%\begin{rclarray}
%    \ver \in \Versions & \defeq &  \Setcon{(\val, \txid, \txidset)}{\val \in \Val \land \txid \in \TxID \land \txidset \subseteq \TxID \land \txid \notin \txidset} \\
%    \HisHeaps & \defeq & 
%    \Setcon{ \mkvs }{%
%        \mkvs \in \Keys \parfinfun \Versions^{*} 
%        \land \fora{\ke, \txid, i, j} 
%        \WTx(\hh(\ke, i)) = \WTx(\hh(\ke, j)) \lor {} \\
%        (\txid \in \RTx(\hh(\ke, i)) \land \txid \in \RTx(\hh(\ke, j))
%        \implies i = j 
%    }
%\end{rclarray}
%\]
%
%We model a kv-store $\hh$ as a map from keys to lists of versions.
%%where each key is associated with a list \emph{versions} from the initial one to the latest one (\defref{def:mkvs}).
%%More concretely, versions associated with a key $\ke$ 
%Versions are tuples of the form \( \ver =( \val, \txid, \txidset ) \), where $\val$ denotes the \emph{current value} of $\ke$, 
%$\txid$ is the identifier of the transaction that wrote such a version, 
%%, identifying its \emph{writer}, i.e.\ the transaction responsible for writing value $\val$, 
%and $\txidset$ is the set of identifiers of transactions that read the version.
%%, denoting its \emph{readers}, i.e.\ those transactions who read from $\ke$ 
%(see \cref{def:mkvs}).
%
%\cref{fig:hheap-a} depicts an example of an MKVS. 
%Ignoring the lines labelled $\client_1$ and $\client_2$, the depicted MKVS contains two keys \( \ke_1\) and \( \ke_2 \), each of which associated with two versions (with values $v_0$ and $v_1$ for $\ke_1$, and values $v'_0$ and $v'_1$ for $\ke_2$).
%The versions of a key are listed in chronological order from left to right.
%We represent each version as a three-cell box, with the left cell storing the value, the top right cell recording the writer, and the bottom right cell recording the readers. 
%
%
%Given a version $\ver = (\val, \txid, \txidset)$, we write $\valueOf(\ver)$ for its value ($n$), $\WTx(\ver)$ for its writer ($\txid$), $\RTx(\ver)$ for its readers ($\txidset$), and \( \txid' \in \ver \) for \( \txid' = \txid \lor \txid' \in \txidset \).
%%A \emph{Multi-version Key-value Store (MKVS)} is a mapping $\hh : \Keys \parfinfun \Versions^{\ast}$ from keys to lists of versions. 
%Given a list of versions $L = \List{\ver_0, \cdots, \ver_{s-1}}$, we write  $\lvert L\rvert$ for its length ($s$). 
%Given an MKVS $\hh$ and a key $\ke$, we write $\hh(\ke)$ for the list of versions associated with $\ke$ in $\hh$, and write \(\hh(\ke,i) \) for the $i$\textsuperscript{th} entry (indexed from $0$) in $\hh(\ke)$. 
%%We assume the index starts from 0, so \( \hh(\ke)(\left|\hh(\ke)\right| - 1)\) is the latest versions of the key \( \ke \).
%
%\azalea{I think $\hh$ is too close to $\ke$ and we should use a different symbol. Maybe $H$? }
%
%We assume a countably infinite set of \emph{keys}, $\Keys $,
%a set of countably infinite set of \emph{program values}, \( \val \in \Val \),
%a countably infinite set of \emph{client identifiers}, \( \cl \in \Clients \),
%and a countably infinite set of \emph{transactions identifiers indexed by client}, $\txid^{\cl} \in \TxID$
%We also assume there are countably infinite elements for every client, and elements for each client are ordered.
%We use \( \txid^{\cl}_{i}\) for the \emph{i-th} identifier among the total order and it is indexed by the client \( \cl \). 
%For a client, the order among transaction identifiers corresponds to the session order of them.
%Sometime we omit the order and/or client index when they are irrelevant.
%We use $\ke$ and its variants (e.g.\ $\ke_1$, $\ke'$ and so forth) as meta-variables for keys in $\Keys$.
%%and use $\txid$ and its variants as meta-variables for transaction identifiers in $\TxID$. 
%
%A key-value store is \emph{well-formed} iff 
%a transaction identifier appears in all versions of a key at most twice, once as the writer and once as a reader.
%%(i) it does not contain circular dependencies across its versions; and 
%%
%%Given two versions $\ver_1, \ver_2$ in an MKVS $\hh$, the $\ver_2$ \emph{directly depends} on $\ver_1$, written $\ver_1 \xrightarrow{\ddep} \ver_2$, iff:
%%\[ 
%%\begin{rclarray}
%%\ver_1 \xrightarrow{\ddep} \ver_2 & \defeq &
%%\begin{array}[t]{@{}l}
%%\WTx(\ver_2) \in \RTx(\ver_1) 
%%%\exsts{\cl,i,j,\txid_{i}^{\cl},\txid_{j}^{\cl}} \\
%%%\quad \txid_{i}^{\cl} < \txid_{j}^{\cl}
%%%\land \txid_{i}^{\cl} \in \ver_{1}
%%%\land \txid_{j}^{\cl} \in \ver_{2}
%%\end{array}
%%\end{rclarray}
%%\]
%%that is, a transaction $\txid$ wrote the version $\ver_2$ after reading $\ver_1$;
%%%or two transactions from the same client access
%%%The $\ver_1 \xrightarrow{\ddep(\hh)} \ver_2$ denotes that $\ver_1, \ver_2$ appear as versions from the same KVMS $\hh$ and \( \ver_1\) depends on \(\ver_2 \).
%
%%A key-value store is \emph{well-formed}, written $\pred{wfMKVS}{\hh}$, iff 
%%(i) it does not contain circular dependencies across its versions; and 
%%(ii) a transaction identifier appears in all versions of a key at most twice, once as the writer and once as a reader.
%%% a transaction identifier appears in all the versions for an key at most twice, one as the writer and one as a reader.
%%%
%%%Also there are no circular dependencies in versions. 
%%%More concretely, the first well-formedness condition (i) of an KVMS ensures that the \emph{transitive closure} of the direct dependency relation $\left(\xrightarrow{\ddep(\hh)}\right)^{+}$ is acyclic:
%%%in $\hh$, i.e. $\left(\xrightarrow{\ddep(\hh)} \right)^{+} \cap \text{Id} = \emptyset$ (where $\text{Id}$ is 
%%%the identity relation).
%%%\[
%%%\begin{rclarray}
%    %%\pred{wfMKVS}{\hh} & \defeq &
%    %%\begin{array}[t]{@{}l}
%        %%\pred{acyclic}{\left(\xrightarrow{\ddep(\hh)}\right)^{+}}
%        %%\land \fora{\ke, \txid, i, j}
%        %%\begin{B}
%        %%\WTx(\hh(\ke, i)) = \WTx(\hh(\ke, j)) \lor {} \\ (\txid \in \RTx(\hh(\ke, i)) \land \txid \in \RTx(\hh(\ke, j))
%        %%\end{B} 
%        %%\implies i = j 
%    %%\end{array}
%%%\end{rclarray}
%%%\]
%%%
%The \emph{partial commutative monoid (pcm) of MKVSs} is $(\MKVSs, \composeHH, \{\unitHH\})$, where 
%$\composeHH:  \MKVSs \times \MKVSs \rightharpoonup \MKVSs$ denotes the \emph{pcm composition} defined as the standard function disjointed union: $\composeHH \eqdef \uplus$; and
%%\( \hh \composeHH \hh' \defeq \hh \uplus \hh' \)
%$\unitHH \in \MKVSs$ denotes the \emph{pcm unit element}:  $\unitHH \eqdef \emptyset$, where $\emptyset$ denotes a function with an empty domain.
%\end{definition}
%
%\ac{A point that this does not ensure a real causal dependency between the two versions, yet it is consistent with the notion of causality employed in databases, should be made}. 
%

\begin{figure}
\begin{center}
\hrule\vspace{5pt}
\begin{tabular}{@{}c c@{}}
\begin{halfsubfig}
\begin{centertikz}

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\ke_1 \mapsto$};

\matrix(versionx) [version list]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\txid_1$\\
    {a} & $\{\txid_2\}$ & {a} & $\emptyset$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$v_0$};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$v_1$};
%\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
%\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_2 \mapsto$};
\matrix(versiony) [version list]
   at ([xshift=\tikzkvspace]locy.east) {
 {a} & $\txid_0$ & {a} & $\txid_2$ \\
  {a} & $\{\txid_1\}$ & {a} & $\emptyset$\\
};

\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$v'_0$};
\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{$v'_1$};
%\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
%\node[version node, fit=(locycells-1-3) (locycells-2-3), fill=white, inner sep=0cm, font=\Large] (locy-v1) {$1$};

% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
 ([xshift=-3pt, yshift=20pt]locx-v1.north east) node (tid1start) {} -- 
 ([xshift=-3pt, yshift=-5pt]locx-v1.south east) --
 ([xshift=-3pt, yshift=5pt]locy-v0.north east) -- 
 ([xshift=-3pt, yshift=-5pt]locy-v0.south east);
 
 \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\client_1$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
 ([xshift=-16pt, yshift=5pt]locx-v1.north east) node (tid2start) {}-- 
% ([xshift=-16pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-16pt, yshift=5pt]locy-v1.north east) -- 
 ([xshift=-16pt, yshift=-5pt]locy-v1.south east) node {};
 
\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\client_2$};

%%Stack for clients tid_1 and tid_2
%
%\draw[-, dashed] let 
%   \p1 = ([xshift=0pt]locy.west),
%   \p2 = ([yshift=-5pt]locycells.south),
%   \p3 = ([xshift=10pt]locycells.east) in
%   (\x1, \y2) -- (\x3, \y2);
%   
%\matrix(stacks) [
%   matrix of nodes,
%   anchor=north, 
%   text=blue, 
%   font=\normalsize, 
%   row 1/.style = {text = blue}, 
%   row 2/.style = {text = red}, 
%   text width= 13mm ] 
%   at ([xshift=-10pt,yshift=-8pt]locycells.south) {
%   $\txid_1:$ & $\retvar = 0$\\
%   $\txid_2:$ & $\retvar = 0$\\
%   };
\end{pgfonlayer}
\end{centertikz}
\caption{A configuration with a well-formed MSKV and two views}
\label{fig:hheap-a}
\end{halfsubfig}
&

\begin{halfsubfig} 
\begin{centertikz}

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\ke_1 \mapsto$};

\matrix(versionx) [version list, text width=7mm, anchor=west]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\txid_1$\\
    {a} & $\emptyset$ & {a} & $\{\txid_2\}$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$v_0$};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$v_1$};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_2 \mapsto$};
\matrix(versiony) [version list, text width=7mm, anchor=west]
    at ([xshift=\tikzkvspace]locy.east) {
    {a} & $\txid_0$ & {a} & $\txid_2$ \\
    {a} & $\emptyset$ & {a} & $\{\txid_1\}$\\
};
\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$v'_0$};
\tikzvalue{versiony-1-3}{versiony-2-3}{locu-v1}{$v'_1$};

% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
%\draw[-, blue, very thick, rounded corners=10pt]
% ([xshift=-3pt, yshift=20pt]locx-v1.north east) node (tid1start) {} -- 
% ([xshift=-3pt, yshift=-5pt]locx-v1.south east) --
% ([xshift=-3pt, yshift=5pt]locy-v0.north east) -- 
% ([xshift=-3pt, yshift=-5pt]locy-v0.south east);
% 
% \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\txid_1$};
%
%%red view
%\draw[-, red, very thick, rounded corners = 10pt]
% ([xshift=-16pt, yshift=5pt]locx-v1.north east) node (tid2start) {}-- 
%% ([xshift=-16pt, yshift=-5pt]locx-v0.south east) --
%% ([xshift=-16pt, yshift=5pt]locy-v1.north east) -- 
% ([xshift=-16pt, yshift=-5pt]locy-v1.south east) node {};
% 
%\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\txid_2$};

%%Stack for clients tid_1 and tid_2
%
%\draw[-, dashed] let 
%   \p1 = ([xshift=0pt]locy.west),
%   \p2 = ([yshift=-5pt]locycells.south),
%   \p3 = ([xshift=10pt]locycells.east) in
%   (\x1, \y2) -- (\x3, \y2);
%   
%\matrix(stacks) [
%   matrix of nodes,
%   anchor=north, 
%   text=blue, 
%   font=\normalsize, 
%   row 1/.style = {text = blue}, 
%   row 2/.style = {text = red}, 
%   text width= 13mm ] 
%   at ([xshift=-10pt,yshift=-8pt]locycells.south) {
%   $\txid_1:$ & $\retvar = 0$\\
%   $\txid_2:$ & $\retvar = 0$\\
%   };
\end{pgfonlayer}
\end{centertikz}
\caption{An ill-formed MKVS}
\label{fig:hheap-b}
\end{halfsubfig} \\
\end{tabular}
\end{center}
\hrule\vspace{5pt}
\ac{Remove ill-formed heap. Insert Configuration with non-atomic view. Refer to the figure 
when explaining the notion of atomic view.}
\caption{Multi-version key-value stores}
\label{fig:hheap}
\end{figure}

%Formally speaking, we assume a countably infinite set of keys $\ke = \{\key{k}_1, \cdots\}$, a set of transaction identifiers $\TxID = 
%\{ \txid_1, \cdots \}$, 
%a set of clients $\txidset = \{\txid_1, \cdots \}$.
%We also assume values to be natural numbers from the set $\nat$. 
%\ac{from now on, the sort font is used for sets.}
%\begin{definition}
%\label{def:hheap}
%A \emph{version} is a triple $\ver = ( n, \txid, \T)$, where, 
%$n$ is the value of the version, $\txid$ is the identifier of the transaction 
%that wrote the version, and $\T$ is a (possibly empty) set of identifiers of 
%the transactions that read the version.
%Given a version $\ver = (n, \txid, \T)$, 
%we let $\valueOf(\ver) = n$, $\WTx(\ver) = \txid$, $\RTx(\ver) = \T$. 
%The set of versions is denoted as $\Versions$.

%A \emph{Multi-version Key-value Store}, or MKVS, is a mapping  
%$\hh : \ke \rightarrow \Versions^{\ast}$ from keys to lists of versions. 
%\end{definition}
%Given a list of versions $\ver_1 \cdots \ver_{n}$, 
%we let $\lvert \ver_1 \cdots \ver_{n} \rvert = n$ be 
%its length. Also, let $\hh$ be a MKVS, $\key{k}$ be a key 
%such that $\hh(\key{k}) = \ver_1 \cdots \ver_n$, and 
%$i \leq n$ be a strictly positive natural number; then we let 
%$\hh(\key{k}, i) = \ver_i$. 

%\ac{Maybe it's better to keep $\ke$ fixed and say that we look at only a 
%fragment of the key value store. Alternatively, we can go for partial mappings to 
%represent MKVSs, but still avoiding allocation and deallocation of keys.}. To the left 
%we have the set of keys stored y $\hh_0$, in this case $\key{k}_1$ and 
%$\key{k}_2$. To the right, on the same line of a key, a matrix containing the
 %list of versions stored by such a key in $\hh_0$. Starting from the first column, 
 %each version is represented by two adjacent columns in the matrix: the 
 %column to the left gives the value of the version, while the column to the 
 %right contains the identifier of the transaction that wrote the version to the 
 %top, and the identifiers of the transactions that read such a version to the bottom.
%In the case of $\hh_0$, there are two versions stored for $\key{k}_1$: 
%the first one with value $0$, written by $\txid_0$ and read by $\txid_2$; 
%and the second one with value $1$, written by $\txid_2$ and read by no 
%transaction. 

%\ac{
%Throughout this paper, we focus on MKVSs that can be obtained in 
%databases whose consistency guarantees enjoy atomic visibility 
%\cite{framework-concur,SIanalysis,laws}. To this end, we impose 
%some well-formedness constraints on the MKVSs.

%\begin{definition}
%\label{def:hh.wellformed}
%\label{def:ddep}
%A MKVS $\hh$ is \emph{well-formed} if and only if 
%\begin{itemize}
%\item a transaction does not write two different versions for the same key: 
%$\forall \key{k} \in \ke.\;\forall i, j = 1,\cdots, \lvert \hh(\key{k}) \rvert. 
%\WTx(\hh(\key{k}, i)) = \WTx(\hh(\key{k}, j)) \implies i = j$, 
%\item a transaction does not read two different versions for the same key:  
%$\forall \key{k} \in \ke.\;\forall i, j = 1,\cdots, \lvert \hh(\key{k}) \rvert. 
%(\RTx(\hh(\key{k},i) \cap \RTx(\hh(\key{k}, j)) \neq \emptyset) \implies i = j$.
%\item There are no circular dependencies in versions. Given two versions 
%$\ver_1, \ver_2$, we say that $\ver_2$ \emph{direct dependency} from 
%$\ver_1$, written $\ver_1 \xrightarrow{\ddep} \ver_2$, if $\WTx(nu_2) \in \RTx(\ver_1)$; 
%that is, some transaction $\txid$ wrote the version $\ver_2$ after reading $\ver_1$ 
%\ac{A point that this does not ensure a real causal dependency between the 
%two versions, yet it is consistent with the notion of causality employed in databases, 
%should be made}. If $\ver_1, \ver_2$ appear as versions of some object in 
%$\hh$, then we write $\ver_1 \xrightarrow{\ddep(\hh)} \ver_2$. Then the relation $\left(\xrightarrow{\ddep(\hh)}\right)^{+}$ is acyclic in $\hh$, 
%i.e. $\left(\xrightarrow{\ddep(\hh)} \right)^{+} \cap \text{Id} = \emptyset$ (where $\text{Id}$ is 
%the identity relation).
%\end{itemize}
%\end{definition}
%}

%Let us elaborate on the first well-formedness constraint of an MKVS \( \mkvs \) in \cref{def:mkvs}. As stated above, this states that there is no circularity in the dependency relation.
%This in turn ensures that no versions are created \emph{out of thin-air}.
%An example of the out of thin-air anomaly is given in \cref{fig:hheap-b}, where
%transaction $\txid_2$ reads the value of $\ke_1$ written by $\txid_1$;
%conversely, transaction $\txid_1$ reads the value of $\ke_2$ written by $\txid_2$. 
%As we assume transactions read a state of the key-value store from an atomic snapshot fixed at the moment they execute, this situation cannot arise. 
%For $\txid_2$ to read the version written by $\txid_1$, transaction $\txid_2$ must start after $\txid_1$, \ie \( \hh(\ke_2, 1) \xrightarrow{\ddep(\hh_1)} \hh(\ke_1, 1) \).
%Similarly, $\txid_1$ must starts after $\txid_2$, \ie \( \hh(\ke_1, 1) \xrightarrow{\ddep(\hh_1)} \hh_1(\ke_2, 1) \).
%This however violates the well-formedness of MKVSs that $\xrightarrow{\ddep(\hh_1)}$ is acyclic. 

%\azalea{Why $\hh_1$ for the store and not $\hh$? Also I thought the versions are indexed from $0$ in which case index $2$ does not make sense here? \sx{\( \mkvs \) and index starts from 0.}}

%\azalea{common Latin abbreviations such as \ie, \eg, and et al. do not need to be italicised. I have adjusted the macros. I have also rephrased the definitions quite a bit. Make sure you're happy with this.}
%When introducing our semantics of clients in \S \ref{sec:semantics}, we show that (under reasonable conditions) it generates only well-formed MKVSs.

%\ac{
%A view $V$ defines the particular version of each key that a client 
%will observe when executing a transaction. A configuration consists 
%of a MKVS, and the views that a set of clients have each on the state 
%of the MKVS. An example of configuration is given in Figure \ref{fig:hheap}(a). 
%There are two clients, $\txid_1$ and $\txid_2$, each with their own view 
%(represented in the Figure by labelled lines crossing the MKVS at each location). 
%According to the view of $\txid_1$, formally defined as $V_1 = [\key{k}_1 \mapsto 2], 
%\key{k}_2 \mapsto 1]$, this client observes in $\hh$ the second version of key $\key{k}_1$, carrying 
%value $1$, and 
%the first version of $\key{k}_2$, carrying value $0$. Similarly, according to its view 
%$V_2 = [\key{k}_1 \mapsto 2, \key{k}_2 \mapsto 2]$, the client $\txid_2$ observes 
%in $\hh$the second and most up-to-date version for both $\key{k}_1$ and $\key{k}_2$.
%}

\mypar{Views, Configurations and Snapshots.}
\ac{Configurations are trivial once that view are defined.}
The main idea behind our formal notion of key-value stores is that, 
when executing a transaction, different clients may observe 
different version of the same key, at any given time. To keep track of 
the versions they observe, clients are associated with a \emph{view}. 
\begin{definition}
\label{def:view}
\label{def:cuts}
\label{def:views}
\label{def:configuration}
Let $\hh$ be a key-value store; a view in $\hh$ is function  
$V: \dom(\hh) \rightarrow \Nat$ such that, for any $\ke \in \dom(\hh)$, 
$V(\ke) < \lvert \hh(\ke) \rvert$, and 
\begin{equation}
\label{eq:view.atomic}
\forall \ke,\ke' \in \dom(\hh), i,j \in \Nat.\; (j \leq  \vi(\ke) \wedge 
\WTx(\hh(\ke, v(\ke))) = \WTx(\hh(\ke', i)) \implies i \leq \vi(\ke').
\tag{AtomicView}
\end{equation}
The set of views of $\hh$ is denoted 
as $\Views_{\hh}$, and we let $\Views = \bigcup_{\hh \in \HisHeaps} 
\Views_{\hh}$.

A configuration $\conf$ is a pair $(\hh, \viewFun)$, where $\viewFun: 
\Clients \parfinfun \Views_{\hh}$.
\end{definition}
Given $\hh \in \HisHeaps$ and two views $\vi, \vi' \in \Views_{\hh}$, 
we let $\vi \viewleq \vi'$ if, for any $\ke \in \dom(\hh)$, $\vi(k) \leq \vi'(\ke)$. 
In this case we say that $\vi$ is older than $\vi'$ ($\vi'$ is newer than $\vi$).

Simply put, a configuration augments the notion of kv-stores with the information 
about the version observed by each client of its clients. The view of a client $\cl$ in $\hh$ 
keeps track of the most recent version of $\hh$ that $\cl$ can access when executing a 
transaction. The constraint of \cref{eq:view.atomic} establishes that clients observe 
either none or all the updates performed by a transaction, thus modelling atomic 
visibility.
We often depict configurations graphically by depicting views as client-labelled lines crossing 
versions  of key-value stores. A line labelled $\cl$ crossing the $i$-th version of key $\ke$ defines a view 
$\vi$ for client $\cl$, with $\vi(\ke) = i$. One example is given by the configuration 
$\conf_0 = (\hh_0, [\cl_1 \mapsto \vi_1, \cl_2 \mapsto \vi_2])$ of \cref{fig:hheap-a}. 
There are two clients, 
$\cl_1$ and $\cl_2$, with views $\vi_1, \vi_2$ respectively. $\vi_1$ Crosses $\ke_1$ at its $0$-th 
version, and $\ke_2$ at its $1$-st version. Therefore we have $\vi_1 = [\ke_1 \mapsto 0, \ke_2 \mapsto_1]$. 
Similarly, $\vi_2 = [\ke_1 \mapsto 1, \ke_2 \mapsto 0]$. 
\ac{Never refer to colors in text. People may read in black and white.}

Given a kv-store $\hh$, a view $\vi$ and a key $\ke \in \dom(\hh)$, 
we commit an abuse of notation and write $\hh(\ke, \vi)$ as a shorthand 
for $\hh(\ke, \vi(\ke))$. The view $\vi$ naturally induces a \emph{snapshot} 
by extracting the value of the $\vi(\ke)$-th version for each key $\ke \in \dom(\hh)$. 
As we will see presently, snapshots are used to determine the value of keys returned 
by read operations of transactions. 
\begin{definition}
\label{def:heaps}
\label{def:snapshot}
Let $\hh \in \HisHeaps, \vi \in \Views_{\hh}$. The snapshot of $\vi$ in 
$\hh$ is defined as $\snapshot(\hh, \vi) = \lambda \ke. \valueOf(\hh(\ke, \vi))$.
\end{definition}

\ac{General comment: the explanations should be okay, but I wonder whether we now have 
too many definitions. We may consider putting all the definitions in a table, and 
go through there in the text. Though I am for using tables with notations and 
definitions only as a last resort - they tend to be scary.}

%of $\vi$ by accessing the value of 
%A view $\vi$ in $\hh$ naturally defines a snapshot $\snapshot(\hh, \nu)$
%A MKVS tracks the global state of the system; however, different \emph{clients} may observe different versions of the same key. 
%To model this, we introduce the notion of \emph{views} (\cref{def:views}). 
%A view $V$ reflects the particular version for each key that a client observes upon executing a transaction. 
%%We present an example of views in \cref{fig:hheap-a} with two views: $\client_1$ in red and $\client_2$ in blue.
%More concretely, the view for \( \client_1 \) is given formally as $\vi_1 = \Set{\key{k}_1 \mapsto 1, \key{k}_2 \mapsto 0}$.
%That is, the client with view $\vi_1$ observes the second version (at index 1) of key \( \ke_{1} \) with value $v_1$, and the first version (at index 0) of key \( \ke_2 \) with value $v'_0$.
%%, and 
%%the first version of $\key{k}_2$, carrying value $0$. Similarly, according to its view 
%%$V_2 = [\key{k}_1 \mapsto 2, \key{k}_2 \mapsto 2]$, the client $\txid_2$ observes 
%%in $\hh$the second and most up-to-date version for both $\key{k}_1$ and $\key{k}_2$.
%
%\begin{definition}[Views]
%\label{def:view}
%\label{def:cuts}
%\label{def:views}
%\emph{A view} is a partial finite function from keys to indexes:
%$
%\vi \in \Views \defeq \Addr \parfinfun \Nat 
%%\begin{rclarray}
%%    \vi \in \Views & \defeq & \Addr \parfinfun \Nat 
%%\end{rclarray}
%$.                                                                 
%The \emph{view composition}, $\composeVI: \Views \times \Views \rightharpoonup \Views$ is defined as the standard disjoint function union: $\composeVI \eqdef \uplus$. 
%% \( \vi \composeVI \vi' \defeq \vi \uplus \vi'\) 
%The \emph{unit view}, $\unitVI \in \Views$, is a function with an empty domain: $\unitVI \eqdef \emptyset$. 
%% and the unit is \( \unitVI \defeq \emptyset\).
%The \emph{order relation} on views, $\orderVI: \Views \times \Views$, is defined between two views with the same domain as the point-wise comparison of their indexes for each entry: 
%\[
%\begin{rclarray}
%    \vi \orderVI \vi' & \defiff & \dom(\vi) = \dom(\vi') \land \fora{\ke} \cu(\ke) \leq \cu'(\ke) \\
%\end{rclarray}
%\]
%\end{definition}
%%
%We say view $\vi$ is \emph{older} than view $\vi'$ (or $\vi'$ is \emph{newer} than $\vi$) whenever $\vi \orderVI \vi'$ holds.
%
%
%\mypar{Configurations} A \emph{configuration} comprises an MKVS, and the views associated with clients.
%In \cref{fig:hheap-a} we present an example of a configuration comprising an MKVS and the two views associated with clients $\client_1$ and $\client_2$. 
%We write $\version(\hh, \ke, \vi)$ for $\hh(\ke, \vi(\ke))$; 
%and write $\valueOf(\hh, \ke, \vi)$ as a shorthand for $ \valueOf(\version(\hh, \key{k}, V))$; similarly for $\WTx, \RTx$.
%%we commit an abuse of notation and often write $\valueOf(\hh, \ke, \vi)$ in lieu of $ \valueOf(\version(\hh, \key{k}, V))$, and similarly for $\WTx, \RTx$.
%When $\ver = \version(\hh, \ke, \vi)$, we say that \emph{$\vi$ $\ke$-points to $\ver$ in $\hh$}. 
%When $\ver = \hh(\ke, i)$ for some $0 \leq i \le \vi(\ke)$, we say that \emph{$\vi$ $\ke$-includes $\ver$ in $\hh$}.
%Lastly, we always assume that MKVSs, views, and configurations are well-formed, unless otherwise stated.
%
%
%
%\begin{definition}[Configurations]
%A view $\vi$ is \emph{well-formed with respect to an MKVS} $\mkvs$, written \( \wfV{\mkvs, \vi} \),  iff they have the same domain and every index from $\vi$ is within the range of the corresponding entry in $\mkvs$ and the view is \emph{atomic} with  respect to the key-value store: 
%\[
%\begin{rclarray}
%    \wfV{\mkvs, \vi} & \defeq & \dom(\mkvs) = \dom(\vi) \land \fora{\ke \in \dom(\vi)} 0 \leq \vi(\ke) < \lvert \mkvs(\ke) \rvert \\
%    \pred{atomic}{\vi ,\hh} & \eqdef & \fora{\txid } \exsts{\ke, i} i \leq \vi(\ke) \land \hh(\ke,i) = (\stub, \txid, \stub) \implies \pred{visible}{\txid, \vi, \hh} \\ 
%    \pred{visible}{\txid, \vi, \hh} & \eqdef & \fora{\ke, i} \hh(\ke,i) = (\stub, \txid, \stub) \implies i \leq \vi(\ke) 
%\end{rclarray}
%\]
%%
%\azalea{We need a symbol for this to fill the ???? above. Also ???? below. \sx{Done}}
%A \emph{configuration} $\conf$ is a pair of the form $(\hh, \viewFun)$, where $\hh$ denotes an MKVS, and $\viewFun: \Clients \parfinfun \Views$ is a partial finite function from clients to views. 
%A configuration $\conf = (\hh, \viewFun)$ is \emph{well-formed}, written \( \wfC{\conf}\), iff for all clients $\cl \in \dom(\viewFun)$, the view $\viewFun(\txid)$ is well-formed with respect to $\hh$. 
%%We say that a view $V$ is well-defined with respect to the 
%%MKVS $\hh$ if, $\forall \key{k} \in \ke. 0 < V(\key{k}) \leq 
%%\lvert \hh(\key{k}) \rvert$. 
%%Given a view $V$ that is well-defined 
%%with respect to a 
%
%\end{definition}
%
%\mypar{Snapshots} When a client executes a transaction on the $\mkvs$ MKVS, it extracts a \emph{snapshot} of it via the \( \func{snapshot}{\mkvs, \vi} \) function, extracting the values corresponding to the versions indexed by its view \( \vi \) (\cref{def:snapshot}).
%For instance, for client \( \client_1 \) in \cref{fig:hheap-a}, the $\func{snapshot}{\cdots}$ functions yields a state where key $\ke_1$ carries value $v_1$ and second key \( \ke_2 \) carries value $v'_0$.
%%The concrete state extracted in this way takes the name of the \emph{snapshot} of the transaction.
%%In general, the process of determining the view of a client, hence the snapshot in which such a client executes transactions, is non-deterministic.
%
%\azalea{Before in MKVSs we had values drawn from $\Nat$ in \cref{def:mkvs}. Now we use $\Val$. I think you mean to use $\Val$ in both places? \sx{I would say so} }
%\begin{definition}[Snapshots]
%\label{def:heaps}
%\label{def:snapshot}
%Given the sets of values $\Val$  and keys \( \Addr\)  (\cref{def:mkvs}), the set of \emph{snapshots} is:
%$
%    \h \in \Heaps \eqdef \Addr \parfinfun \Val
%$. 
%%\[
%%\begin{rclarray}
%%    \h \in \Heaps & \eqdef & \Addr \parfinfun \Val
%%\end{rclarray}
%%\]
%The \emph{snapshot composition function}, $\composeH: \Heaps \times \Heaps \parfun \Heaps$, is defined as $\composeH \eqdef \uplus$, where $\uplus$ denotes the standard disjoint function union. The \emph{ snapshot unit element} is $\unitH \eqdef \emptyset$, denoting a function with an empty domain.
%The \emph{partial commutative monoid of snapshots} is $(\Heaps, \composeH, \{\unitH\})$.
%Given an MKVS $\hh$ and a view $\vi$, the snapshot of $\vi$ in $\hh$, written $\snapshot(\hh, \vi) $, is defined as:
%$
%    \snapshot(\hh, \vi) \defeq \lambda \ke \ldotp \valueOf(\hh, \ke, \vi)
%$.
%%\[
%%\begin{rclarray}
%%    \snapshot(\hh, \vi) & \defeq & \lambda \ke \ldotp \valueOf(\hh, \ke, \vi).
%%\end{rclarray}
%%\]
%\end{definition}
%
%\sx{Need some explanation}
%\ac{General Comment on this Section: it is too abstract. We 
%should give either here or in the introduction an example of computation - 
%the write skew program should be okay that helps the reader understanding 
%what's going on. Also, it could be also good to illustrate the notions 
%of execution tests and consistency models.}
%
%\sx{From Andrea: introduce the execution test here with a table, also introduce fingerprint here}
