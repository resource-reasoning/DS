\subsection{Multi-version Key-value Stores and Views}
\label{sec:mkvs-view}
\azalea{I rewrote most of this section. Please make sure you are happy with this.}
%\ac{
%We focus on a computational model where multiple client programs can access and update 
%locations in a key-value store using atomic transactions. Transactions in our model execute atomically, 
%though the consistency guarantees that they provide do not necessarily correspond to \emph{serialisability}. 
%This means that, at the moment of executing, a transaction may not observe the most up-to-date value 
%of a location. 

%To overcome this issue, we model the state of the system using \emph{multi-version key-value stores} 
%(MKVSs) and \emph{views}. A 
%MKVS keeps track of all the versions written for any key, as well as the information 
%about the transactions that read and wrote such versions.  Views keep track of the version observed 
%for each key by clients. 
%}

%\sx{ Value as natural number or natural number + key index? Is partial mkvs is a problem here??}


%We often depict MKVSs graphically. 
%One example is given by the MKVS $\hh_0$ of Figure \ref{fig:hheap}(a) (ignore for the moment 
%the straight lines labelled $\txid_1$ and $\txid_2$).
\ac{\sx{Partial is better for logic}Maybe it's better to keep $\ke$ fixed and say that we look at only a 
fragment of the key value store. Alternatively, we can go for partial mappings to 
represent MKVSs, but still avoiding allocation and deallocation of keys.}.



%\ac{
%We often depict MKVSs graphically. 
%One example is given by the MKVS $\hh_0$ of Figure \ref{fig:hheap}(a) (ignore for the moment 
%the straight lines labelled $\txid_1$ and $\txid_2$).

%To the left 
%we have the set of keys stored y $\hh_0$, in this case $\key{k}_1$ and 
%$\key{k}_2$. To the right, on the same line of a key, a matrix containing the
 %list of versions stored by such a key in $\hh_0$. Starting from the first column, 
 %each version is represented by two adjacent columns in the matrix: the 
 %column to the left gives the value of the version, while the column to the 
 %right contains the identifier of the transaction that wrote the version to the 
 %top, and the identifiers of the transactions that read such a version to the bottom.
%In the case of $\hh_0$, there are two versions stored for $\key{k}_1$: 
%the first one with value $0$, written by $\txid_0$ and read by $\txid_2$; 
%and the second one with value $1$, written by $\txid_2$ and read by no 
%transaction. 
%}
\azalea{I have changed the values to $v_0$ and $v_1$ (from $0$ and $1$) to help clarify the distinction between indexes and values.
I have also paraphrased, please double check.  }

\mypar{MKVSs} We model the state of a system using \emph{multi-version key-value stores} (MKVSs). An MKVS is a map from keys to lists of versions.
%where each key is associated with a list \emph{versions} from the initial one to the latest one (\defref{def:mkvs}).
More concretely, each version associated with a key $\ke$ is a tuple of the form \( \ver =( \val, \txid, \txidset ) \), where $\val$ denoting the \emph{current value} of $\ke$, 
the $\txid$ is a transaction identifier \( \txid \), identifying its \emph{writer}, i.e.\ the transaction responsible for writing value $\val$, and 
$\txidset$ is a set of transaction identifiers, denoting its \emph{readers}, i.e.\ those transactions who read from $\ke$ (see \cref{def:mkvs}).
\cref{fig:hheap-a} depicts an example of an MKVS. 
Ignoring the lines labelled $\client_1$ and $\client_2$, the depicted MKVS contains two keys \( \ke_1\) and \( \ke_2 \), each of which associated with two versions (with values $v_0$ and $v_1$ for $\ke_1$, and values $v'_0$ and $v'_1$ for $\ke_2$).
The versions of a key are listed in chronological order from left to right.
We represent each version as a three-cell box, with the left cell storing the value, the top right cell recording the writer, and the bottom right cell recording the readers. 


Given a version $\ver = (\val, \txid, \txidset)$, we write $\valueOf(\ver)$ for its value ($n$), $\WTx(\ver)$ for its writer ($\txid$), $\RTx(\ver)$ for its readers ($\txidset$), and \( \txid' \in \ver \) for \( \txid' = \txid \lor \txid' \in \txidset \).
%A \emph{Multi-version Key-value Store (MKVS)} is a mapping $\hh : \Keys \parfinfun \Versions^{\ast}$ from keys to lists of versions. 
Given a list of versions $L = \List{\ver_0, \cdots, \ver_{s-1}}$, we write  $\lvert L\rvert$ for its length ($s$). 
Given an MKVS $\hh$ and a key $\ke$, we write $\hh(\ke)$ for the list of versions associated with $\ke$ in $\hh$, and write \(\hh(\ke,i) \) for the $i$\textsuperscript{th} entry (indexed from $0$) in $\hh(\ke)$. 
%We assume the index starts from 0, so \( \hh(\ke)(\left|\hh(\ke)\right| - 1)\) is the latest versions of the key \( \ke \).

\azalea{I think $\hh$ is too close to $\ke$ and we should use a different symbol. Maybe $H$? }

We assume a countably infinite set of \emph{keys}, $\Keys $,
a set of countably infinite set of \emph{program values}, \( \Val \),
a countably infinite set of \emph{transactions identifiers}, $\TxID$,
and a countably infinite set of \emph{client identifiers}, \( \Clients \).
The transaction identifiers \( \TxID \) are totally ordered, and we also assume there are countably infinite elements for every client.
We use \( \txid^{\cl}_{i}\) for the \emph{i-th} identifier among the total order and it is indexed by the client \( \cl \). 
For a client, the order among transaction identifiers corresponds to the session order of them.
Sometime we omit the order and/or client index when they are irrelevant.
We use $\ke$ and its variants (e.g.\ $\ke_1$, $\ke'$ and so forth) as meta-variables for keys in $\Keys$.
%and use $\txid$ and its variants as meta-variables for transaction identifiers in $\TxID$. 
\begin{definition}[Multi-version key-value stores]
\label{def:his_heap}
\label{def:mkvs}
%Assuming a countably infinite set of keys $\Keys = \Set{\ke_1, \cdots}$, \emph{transactions identifiers} \( \TxID \defeq \Set{\txid_{1}, \cdots}\) and natural numbers \(\nat \in \Nat \), 
A\emph{multi-version key-value store (MKVS)}, \( \mkvs \in \MKVSs \), is a partial finite function from keys to lists of \emph{versions}.
A \emph{version} is a triple containing a program value \( \val \), a transaction identifier \( \txid \) and a set of transactions identifiers \( \txidset \):
\[
\begin{rclarray}
    \ver \in \Versions & \defeq &  \Setcon{(\val, \txid, \txidset)}{\val \in \Val \land \txid \in \TxID \land \txidset \subseteq \TxID \land \txid \notin \txidset} \\
    \hh \in \HisHeaps & \defeq & \Keys \parfinfun \Versions^{*}
\end{rclarray}
\]
%
\sx{This is not stronger enough}
Given two versions $\ver_1, \ver_2$ in an MKVS $\hh$, the $\ver_2$ \emph{directly depends} on $\ver_1$, written $\ver_1 \xrightarrow{\ddep} \ver_2$, iff:
\[ 
\begin{rclarray}
\ver_1 \xrightarrow{\ddep} \ver_2 & \defeq &
\begin{array}[t]{@{}l}
\WTx(\ver_2) \in \RTx(\ver_1) 
%\exsts{\cl,i,j,\txid_{i}^{\cl},\txid_{j}^{\cl}} \\
%\quad \txid_{i}^{\cl} < \txid_{j}^{\cl}
%\land \txid_{i}^{\cl} \in \ver_{1}
%\land \txid_{j}^{\cl} \in \ver_{2}
\end{array}
\end{rclarray}
\]
that is, a transaction $\txid$ wrote the version $\ver_2$ after reading $\ver_1$;
%or two transactions from the same client access
%The $\ver_1 \xrightarrow{\ddep(\hh)} \ver_2$ denotes that $\ver_1, \ver_2$ appear as versions from the same KVMS $\hh$ and \( \ver_1\) depends on \(\ver_2 \).

A key-value store is \emph{well-formed}, written $\pred{wfMKVS}{\hh}$, iff 
(i) it does not contain circular dependencies across its versions; and 
(ii) a transaction identifier appears in all versions of a key at most twice, once as the writer and once as a reader.
% a transaction identifier appears in all the versions for an key at most twice, one as the writer and one as a reader.
%
%Also there are no circular dependencies in versions. 
More concretely, the first well-formedness condition (i) of an KVMS ensures that the \emph{transitive closure} of the direct dependency relation $\left(\xrightarrow{\ddep(\hh)}\right)^{+}$ is acyclic:
%in $\hh$, i.e. $\left(\xrightarrow{\ddep(\hh)} \right)^{+} \cap \text{Id} = \emptyset$ (where $\text{Id}$ is 
%the identity relation).
\[
\begin{rclarray}
    \pred{wfMKVS}{\hh} & \defeq &
    \begin{array}[t]{@{}l}
        \pred{acyclic}{\left(\xrightarrow{\ddep(\hh)}\right)^{+}}
        \land \fora{\ke, \txid, i, j}
        \begin{B}
        \WTx(\hh(\ke, i)) = \WTx(\hh(\ke, j)) \lor {} \\ (\txid \in \RTx(\hh(\ke, i)) \land \txid \in \RTx(\hh(\ke, j))
        \end{B} 
        \implies i = j 
    \end{array}
\end{rclarray}
\]
%
The \emph{partial commutative monoid (pcm) of MKVSs} is $(\MKVSs, \composeHH, \{\unitHH\})$, where 
$\composeHH:  \MKVSs \times \MKVSs \rightharpoonup \MKVSs$ denotes the \emph{pcm composition} defined as the standard function disjointed union: $\composeHH \eqdef \uplus$; and
%\( \hh \composeHH \hh' \defeq \hh \uplus \hh' \)
$\unitHH \in \MKVSs$ denotes the \emph{pcm unit element}:  $\unitHH \eqdef \emptyset$, where $\emptyset$ denotes a function with an empty domain.
\end{definition}

\ac{A point that this does not ensure a real causal dependency between the two versions, yet it is consistent with the notion of causality employed in databases, should be made}. 


\begin{figure}
\begin{center}
\hrule\vspace{5pt}
\begin{tabular}{@{}c c@{}}
\begin{halfsubfig}
\begin{centertikz}

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\ke_1 \mapsto$};

\matrix(versionx) [version list]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\txid_1$\\
    {a} & $\{\txid_2\}$ & {a} & $\emptyset$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$v_0$};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$v_1$};
%\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
%\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_2 \mapsto$};
\matrix(versiony) [version list]
   at ([xshift=\tikzkvspace]locy.east) {
 {a} & $\txid_0$ & {a} & $\txid_2$ \\
  {a} & $\{\txid_1\}$ & {a} & $\emptyset$\\
};

\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$v'_0$};
\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{$v'_1$};
%\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
%\node[version node, fit=(locycells-1-3) (locycells-2-3), fill=white, inner sep=0cm, font=\Large] (locy-v1) {$1$};

% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
 ([xshift=-3pt, yshift=20pt]locx-v1.north east) node (tid1start) {} -- 
 ([xshift=-3pt, yshift=-5pt]locx-v1.south east) --
 ([xshift=-3pt, yshift=5pt]locy-v0.north east) -- 
 ([xshift=-3pt, yshift=-5pt]locy-v0.south east);
 
 \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\client_1$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
 ([xshift=-16pt, yshift=5pt]locx-v1.north east) node (tid2start) {}-- 
% ([xshift=-16pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-16pt, yshift=5pt]locy-v1.north east) -- 
 ([xshift=-16pt, yshift=-5pt]locy-v1.south east) node {};
 
\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\client_2$};

%%Stack for threads tid_1 and tid_2
%
%\draw[-, dashed] let 
%   \p1 = ([xshift=0pt]locy.west),
%   \p2 = ([yshift=-5pt]locycells.south),
%   \p3 = ([xshift=10pt]locycells.east) in
%   (\x1, \y2) -- (\x3, \y2);
%   
%\matrix(stacks) [
%   matrix of nodes,
%   anchor=north, 
%   text=blue, 
%   font=\normalsize, 
%   row 1/.style = {text = blue}, 
%   row 2/.style = {text = red}, 
%   text width= 13mm ] 
%   at ([xshift=-10pt,yshift=-8pt]locycells.south) {
%   $\txid_1:$ & $\retvar = 0$\\
%   $\txid_2:$ & $\retvar = 0$\\
%   };
\end{pgfonlayer}
\end{centertikz}
\caption{A configuration with a well-formed MSKV and two views}
\label{fig:hheap-a}
\end{halfsubfig}
&

\begin{halfsubfig} 
\begin{centertikz}

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\ke_1 \mapsto$};

\matrix(versionx) [version list, text width=7mm, anchor=west]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\txid_1$\\
    {a} & $\emptyset$ & {a} & $\{\txid_2\}$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$v_0$};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$v_1$};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_2 \mapsto$};
\matrix(versiony) [version list, text width=7mm, anchor=west]
    at ([xshift=\tikzkvspace]locy.east) {
    {a} & $\txid_0$ & {a} & $\txid_2$ \\
    {a} & $\emptyset$ & {a} & $\{\txid_1\}$\\
};
\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$v'_0$};
\tikzvalue{versiony-1-3}{versiony-2-3}{locu-v1}{$v'_1$};

% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
%\draw[-, blue, very thick, rounded corners=10pt]
% ([xshift=-3pt, yshift=20pt]locx-v1.north east) node (tid1start) {} -- 
% ([xshift=-3pt, yshift=-5pt]locx-v1.south east) --
% ([xshift=-3pt, yshift=5pt]locy-v0.north east) -- 
% ([xshift=-3pt, yshift=-5pt]locy-v0.south east);
% 
% \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\txid_1$};
%
%%red view
%\draw[-, red, very thick, rounded corners = 10pt]
% ([xshift=-16pt, yshift=5pt]locx-v1.north east) node (tid2start) {}-- 
%% ([xshift=-16pt, yshift=-5pt]locx-v0.south east) --
%% ([xshift=-16pt, yshift=5pt]locy-v1.north east) -- 
% ([xshift=-16pt, yshift=-5pt]locy-v1.south east) node {};
% 
%\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\txid_2$};

%%Stack for threads tid_1 and tid_2
%
%\draw[-, dashed] let 
%   \p1 = ([xshift=0pt]locy.west),
%   \p2 = ([yshift=-5pt]locycells.south),
%   \p3 = ([xshift=10pt]locycells.east) in
%   (\x1, \y2) -- (\x3, \y2);
%   
%\matrix(stacks) [
%   matrix of nodes,
%   anchor=north, 
%   text=blue, 
%   font=\normalsize, 
%   row 1/.style = {text = blue}, 
%   row 2/.style = {text = red}, 
%   text width= 13mm ] 
%   at ([xshift=-10pt,yshift=-8pt]locycells.south) {
%   $\txid_1:$ & $\retvar = 0$\\
%   $\txid_2:$ & $\retvar = 0$\\
%   };
\end{pgfonlayer}
\end{centertikz}
\caption{An ill-formed MKVS}
\label{fig:hheap-b}
\end{halfsubfig} \\
\end{tabular}
\end{center}
\hrule\vspace{5pt}
\caption{Multi-version key-value stores}
\label{fig:hheap}
\end{figure}

%Formally speaking, we assume a countably infinite set of keys $\ke = \{\key{k}_1, \cdots\}$, a set of transaction identifiers $\TxID = 
%\{ \txid_1, \cdots \}$, 
%a set of clients $\txidset = \{\txid_1, \cdots \}$.
%We also assume values to be natural numbers from the set $\nat$. 
%\ac{from now on, the sort font is used for sets.}
%\begin{definition}
%\label{def:hheap}
%A \emph{version} is a triple $\ver = ( n, \txid, \T)$, where, 
%$n$ is the value of the version, $\txid$ is the identifier of the transaction 
%that wrote the version, and $\T$ is a (possibly empty) set of identifiers of 
%the transactions that read the version.
%Given a version $\ver = (n, \txid, \T)$, 
%we let $\valueOf(\ver) = n$, $\WTx(\ver) = \txid$, $\RTx(\ver) = \T$. 
%The set of versions is denoted as $\Versions$.

%A \emph{Multi-version Key-value Store}, or MKVS, is a mapping  
%$\hh : \ke \rightarrow \Versions^{\ast}$ from keys to lists of versions. 
%\end{definition}
%Given a list of versions $\ver_1 \cdots \ver_{n}$, 
%we let $\lvert \ver_1 \cdots \ver_{n} \rvert = n$ be 
%its length. Also, let $\hh$ be a MKVS, $\key{k}$ be a key 
%such that $\hh(\key{k}) = \ver_1 \cdots \ver_n$, and 
%$i \leq n$ be a strictly positive natural number; then we let 
%$\hh(\key{k}, i) = \ver_i$. 

%\ac{Maybe it's better to keep $\ke$ fixed and say that we look at only a 
%fragment of the key value store. Alternatively, we can go for partial mappings to 
%represent MKVSs, but still avoiding allocation and deallocation of keys.}. To the left 
%we have the set of keys stored y $\hh_0$, in this case $\key{k}_1$ and 
%$\key{k}_2$. To the right, on the same line of a key, a matrix containing the
 %list of versions stored by such a key in $\hh_0$. Starting from the first column, 
 %each version is represented by two adjacent columns in the matrix: the 
 %column to the left gives the value of the version, while the column to the 
 %right contains the identifier of the transaction that wrote the version to the 
 %top, and the identifiers of the transactions that read such a version to the bottom.
%In the case of $\hh_0$, there are two versions stored for $\key{k}_1$: 
%the first one with value $0$, written by $\txid_0$ and read by $\txid_2$; 
%and the second one with value $1$, written by $\txid_2$ and read by no 
%transaction. 

%\ac{
%Throughout this paper, we focus on MKVSs that can be obtained in 
%databases whose consistency guarantees enjoy atomic visibility 
%\cite{framework-concur,SIanalysis,laws}. To this end, we impose 
%some well-formedness constraints on the MKVSs.

%\begin{definition}
%\label{def:hh.wellformed}
%\label{def:ddep}
%A MKVS $\hh$ is \emph{well-formed} if and only if 
%\begin{itemize}
%\item a transaction does not write two different versions for the same key: 
%$\forall \key{k} \in \ke.\;\forall i, j = 1,\cdots, \lvert \hh(\key{k}) \rvert. 
%\WTx(\hh(\key{k}, i)) = \WTx(\hh(\key{k}, j)) \implies i = j$, 
%\item a transaction does not read two different versions for the same key:  
%$\forall \key{k} \in \ke.\;\forall i, j = 1,\cdots, \lvert \hh(\key{k}) \rvert. 
%(\RTx(\hh(\key{k},i) \cap \RTx(\hh(\key{k}, j)) \neq \emptyset) \implies i = j$.
%\item There are no circular dependencies in versions. Given two versions 
%$\ver_1, \ver_2$, we say that $\ver_2$ \emph{direct dependency} from 
%$\ver_1$, written $\ver_1 \xrightarrow{\ddep} \ver_2$, if $\WTx(nu_2) \in \RTx(\ver_1)$; 
%that is, some transaction $\txid$ wrote the version $\ver_2$ after reading $\ver_1$ 
%\ac{A point that this does not ensure a real causal dependency between the 
%two versions, yet it is consistent with the notion of causality employed in databases, 
%should be made}. If $\ver_1, \ver_2$ appear as versions of some object in 
%$\hh$, then we write $\ver_1 \xrightarrow{\ddep(\hh)} \ver_2$. Then the relation $\left(\xrightarrow{\ddep(\hh)}\right)^{+}$ is acyclic in $\hh$, 
%i.e. $\left(\xrightarrow{\ddep(\hh)} \right)^{+} \cap \text{Id} = \emptyset$ (where $\text{Id}$ is 
%the identity relation).
%\end{itemize}
%\end{definition}
%}

Let us elaborate on the first well-formedness constraint of an MKVS \( \mkvs \) in \cref{def:mkvs}. As stated above, this states that there is no circularity in the dependency relation.
This in turn ensures that no versions are created \emph{out of thin-air}.
An example of the out of thin-air anomaly is given in \cref{fig:hheap-b}, where
transaction $\txid_2$ reads the value of $\ke_1$ written by $\txid_1$;
conversely, transaction $\txid_1$ reads the value of $\ke_2$ written by $\txid_2$. 
As we assume transactions read a state of the key-value store from an atomic snapshot fixed at the moment they execute, this situation cannot arise. 
For $\txid_2$ to read the version written by $\txid_1$, transaction $\txid_2$ must start after $\txid_1$, \ie \( \hh(\ke_2, 1) \xrightarrow{\ddep(\hh_1)} \hh(\ke_1, 1) \).
Similarly, $\txid_1$ must starts after $\txid_2$, \ie \( \hh(\ke_1, 1) \xrightarrow{\ddep(\hh_1)} \hh_1(\ke_2, 1) \).
This however violates the well-formedness of MKVSs that $\xrightarrow{\ddep(\hh_1)}$ is acyclic. 

\azalea{Why $\hh_1$ for the store and not $\hh$? Also I thought the versions are indexed from $0$ in which case index $2$ does not make sense here? \sx{\( \mkvs \) and index starts from 0.}}

\azalea{common Latin abbreviations such as \ie, \eg, and et al. do not need to be italicised. I have adjusted the macros. I have also rephrased the definitions quite a bit. Make sure you're happy with this.}
%When introducing our semantics of clients in \S \ref{sec:semantics}, we show that (under reasonable conditions) it generates only well-formed MKVSs.

%\ac{
%A view $V$ defines the particular version of each key that a client 
%will observe when executing a transaction. A configuration consists 
%of a MKVS, and the views that a set of clients have each on the state 
%of the MKVS. An example of configuration is given in Figure \ref{fig:hheap}(a). 
%There are two clients, $\txid_1$ and $\txid_2$, each with their own view 
%(represented in the Figure by labelled lines crossing the MKVS at each location). 
%According to the view of $\txid_1$, formally defined as $V_1 = [\key{k}_1 \mapsto 2], 
%\key{k}_2 \mapsto 1]$, this client observes in $\hh$ the second version of key $\key{k}_1$, carrying 
%value $1$, and 
%the first version of $\key{k}_2$, carrying value $0$. Similarly, according to its view 
%$V_2 = [\key{k}_1 \mapsto 2, \key{k}_2 \mapsto 2]$, the client $\txid_2$ observes 
%in $\hh$the second and most up-to-date version for both $\key{k}_1$ and $\key{k}_2$.
%}

\mypar{Views}
An MKVS tracks the the global state of the system; however, different \emph{clients} may observe different versions of the same key. 
To model this, we introduce the notion of \emph{views} (\cref{def:views}). 
A view $V$ reflects the particular version for each key that a client observes upon executing a transaction. 
We present an example of views in \cref{fig:hheap-a} with two views: $\client_1$ in red and $\client_2$ in blue.
More concretely, the view for \( \client_1 \) is given formally as $\vi_1 = \Set{\key{k}_1 \mapsto 1, \key{k}_2 \mapsto 0}$.
That is, the client with view $\vi_1$ observes the second version (at index 1) of key \( \ke_{1} \) with value $v_1$, and the first version (at index 0) of key \( \ke_2 \) with value $v'_0$.
%, and 
%the first version of $\key{k}_2$, carrying value $0$. Similarly, according to its view 
%$V_2 = [\key{k}_1 \mapsto 2, \key{k}_2 \mapsto 2]$, the client $\txid_2$ observes 
%in $\hh$the second and most up-to-date version for both $\key{k}_1$ and $\key{k}_2$.

\begin{definition}[Views]
\label{def:view}
\label{def:cuts}
\label{def:views}
\emph{A view} is a partial finite function from keys to indexes:
$
\vi \in \Views \defeq \Addr \parfinfun \Nat 
%\begin{rclarray}
%    \vi \in \Views & \defeq & \Addr \parfinfun \Nat 
%\end{rclarray}
$ .                                                                 
The \emph{view composition}, $\composeVI: \Views \times \Views \rightharpoonup \Views$ is defined as the standard disjoint function union: $\composeVI \eqdef \uplus$. 
% \( \vi \composeVI \vi' \defeq \vi \uplus \vi'\) 
The \emph{unit view}, $\unitVI \in \Views$, is a function with an empty domain: $\unitVI \eqdef \emptyset$. 
% and the unit is \( \unitVI \defeq \emptyset\).

The \emph{order relation} on views, $\orderVI: \Views \times \Views$, is defined between two views with the same domain as the point-wise comparison of their indexes for each entry: 
\[
\begin{rclarray}
    \vi \orderVI \vi' & \defiff & \dom(\vi) = \dom(\vi') \land \fora{\ke} \cu(\ke) \leq \cu'(\ke) \\
\end{rclarray}
\]
\end{definition}
%
We say view $\vi$ is \emph{older} than view $\vi'$ (or $\vi'$ is \emph{newer} than $\vi$) whenever $\vi \orderVI \vi'$ holds.

\mypar{Configurations} A \emph{configuration} comprises an MKVS, and the views associated with clients.
In \cref{fig:hheap-a} we present an example of a configuration comprising an MKVS and the two views associated with clients $\client_1$ and $\client_2$. 
For brevity, we write $\version(\hh, \ke, \vi)$ for $\hh(\ke, \vi(\ke))$; 
and write $\valueOf(\hh, \ke, \vi)$ as a shorthand for $ \valueOf(\version(\hh, \key{k}, V))$; similarly for $\WTx, \RTx$.
%we commit an abuse of notation and often write $\valueOf(\hh, \ke, \vi)$ in lieu of $ \valueOf(\version(\hh, \key{k}, V))$, and similarly for $\WTx, \RTx$.
When $\ver = \version(\hh, \ke, \vi)$, we say that \emph{$\vi$ $\ke$-points to $\ver$ in $\hh$}. 
When $\ver = \hh(\ke, i)$ for some $0 \leq i \le \vi(\ke)$, we say that \emph{$\vi$ $\ke$-includes $\ver$ in $\hh$}.
Lastly, we always assume that MKVSs, views, and configurations are well-formed, unless otherwise stated.



\begin{definition}[Configurations]
A view $\vi$ is \emph{well-formed with respect to an MKVS} $\mkvs$, written \( \wfV{\mkvs, \vi} \),  iff they have the same domain and every index from $\vi$ is within the range of the corresponding entry in $\mkvs$: 
\[
\begin{rclarray}
    \wfV{\mkvs, \vi} & \defeq & \dom(\mkvs) = \dom(\vi) \land \fora{\ke \in \dom(\vi)} 0 \leq \vi(\ke) < \lvert \mkvs(\ke) \rvert
\end{rclarray}
\]
%
\azalea{We need a symbol for this to fill the ???? above. Also ???? below. \sx{Done}}
A \emph{configuration} $\conf$ is a pair of the form $(\hh, \viewFun)$, where $\hh$ denotes an MKVS, and $\viewFun: \Clients \parfinfun \Views$ is a partial finite function from clients to views. 
A configuration $\conf = (\hh, \viewFun)$ is \emph{well-formed}, written \( \wfC{\conf}\), iff for all clients $\cl \in \dom(\viewFun)$, the view $\viewFun(\txid)$ is well-formed with respect to $\hh$. 
%We say that a view $V$ is well-defined with respect to the 
%MKVS $\hh$ if, $\forall \key{k} \in \ke. 0 < V(\key{k}) \leq 
%\lvert \hh(\key{k}) \rvert$. 
%Given a view $V$ that is well-defined 
%with respect to a 

\end{definition}

\mypar{Snapshots} When a client executes a transaction on the $\mkvs$ MKVS, it extracts a \emph{snapshot} of it via the \( \func{snapshot}{\mkvs, \vi} \) function, extracting the values corresponding to the versions indexed by its view \( \vi \) (\cref{def:snapshot}).
For instance, for client \( \client_1 \) in \cref{fig:hheap-a}, the $\func{snapshot}{\cdots}$ functions yields a state where key $\ke_1$ carries value $v_1$ and second key \( \ke_2 \) carries value $v'_0$.
%The concrete state extracted in this way takes the name of the \emph{snapshot} of the transaction.
%In general, the process of determining the view of a client, hence the snapshot in which such a client executes transactions, is non-deterministic.

\azalea{Before in MKVSs we had values drawn from $\Nat$ in \cref{def:mkvs}. Now we use $\Val$. I think you mean to use $\Val$ in both places? \sx{I would say so} }
\begin{definition}[Snapshots]
\label{def:heaps}
\label{def:snapshot}
Given the sets of values $\Val$  and keys \( \Addr\)  (\cref{def:mkvs}), the set of \emph{snapshots} is:
$
    \h \in \Heaps \eqdef \Addr \parfinfun \Val
$. 
%\[
%\begin{rclarray}
%    \h \in \Heaps & \eqdef & \Addr \parfinfun \Val
%\end{rclarray}
%\]
The \emph{snapshot composition function}, $\composeH: \Heaps \times \Heaps \parfun \Heaps$, is defined as $\composeH \eqdef \uplus$, where $\uplus$ denotes the standard disjoint function union. The \emph{ snapshot unit element} is $\unitH \eqdef \emptyset$, denoting a function with an empty domain.
The \emph{partial commutative monoid of snapshots} is $(\Heaps, \composeH, \{\unitH\})$.
Given an MKVS $\hh$ and a view $\vi$, the snapshot of $\vi$ in $\hh$, written $\snapshot(\hh, \vi) $, is defined as:
$
    \snapshot(\hh, \vi) \defeq \lambda \ke \ldotp \valueOf(\hh, \ke, \vi)
$.
%\[
%\begin{rclarray}
%    \snapshot(\hh, \vi) & \defeq & \lambda \ke \ldotp \valueOf(\hh, \ke, \vi).
%\end{rclarray}
%\]
\end{definition}

\sx{Need some explanation}
\ac{General Comment on this Section: it is too abstract. We 
should give either here or in the introduction an example of computation - 
the write skew program should be okay that helps the reader understanding 
what's going on. Also, it could be also good to illustrate the notions 
of execution tests and consistency models.}

