\subsection{Multi-version Key-value Stores and Views}
\label{sec:mkvs-view}
\ac{I'm going to leave this comment here, I know it's going to be harsh but needs to be said: 
If you are going to change the main text, please be sure that the English is correct, and that the 
writing is consistent! It took me several days to get this in a good shape, and now I have to go over all of it again!}
%\ac{
%We focus on a computational model where multiple client programs can access and update 
%locations in a key-value store using atomic transactions. Transactions in our model execute atomically, 
%though the consistency guarantees that they provide do not necessarily correspond to \emph{serialisability}. 
%This means that, at the moment of executing, a transaction may not observe the most up-to-date value 
%of a location. 

%To overcome this issue, we model the state of the system using \emph{multi-version key-value stores} 
%(MKVSs) and \emph{views}. A 
%MKVS keeps track of all the versions written for any key, as well as the information 
%about the transactions that read and wrote such versions.  Views keep track of the version observed 
%for each key by clients. 
%}

%\sx{ Value as natural number or natural number + key index? Is partial mkvs is a problem here??}


%We often depict MKVSs graphically. 
%One example is given by the MKVS $\hh_0$ of Figure \ref{fig:hheap}(a) (ignore for the moment 
%the straight lines labelled $\txid_1$ and $\txid_2$).

%\ac{\sx{Partial is better for logic}Maybe it's better to keep $\ke$ fixed and say that we look at only a 
%fragment of the key value store. Alternatively, we can go for partial mappings to 
%represent MKVSs, but still avoiding allocation and deallocation of keys.}



%\ac{
%We often depict MKVSs graphically. 
%One example is given by the MKVS $\hh_0$ of Figure \ref{fig:hheap}(a) (ignore for the moment 
%the straight lines labelled $\txid_1$ and $\txid_2$).

%To the left 
%we have the set of keys stored y $\hh_0$, in this case $\key{k}_1$ and 
%$\key{k}_2$. To the right, on the same line of a key, a matrix containing the
 %list of versions stored by such a key in $\hh_0$. Starting from the first column, 
 %each version is represented by two adjacent columns in the matrix: the 
 %column to the left gives the value of the version, while the column to the 
 %right contains the identifier of the transaction that wrote the version to the 
 %top, and the identifiers of the transactions that read such a version to the bottom.
%In the case of $\hh_0$, there are two versions stored for $\key{k}_1$: 
%the first one with value $0$, written by $\txid_0$ and read by $\txid_2$; 
%and the second one with value $1$, written by $\txid_2$ and read by no 
%transaction. 
%}
\azalea{I have changed the values to $v_0$ and $v_1$ (from $0$ and $1$) to help clarify the distinction between indexes and values.
I have also paraphrased, please double check.  }

\mypar{Key-value Stores} 

%We model the state of a system using \emph{multi-version key-value stores} (MKVSs). 
We assume a countably infinite set of \emph{keys} $\Keys \defeq \Set{\ke, \ke', \cdots}$, 
a set of \emph{values} $\Val \defeq \{\val, \val', \cdots\}$ which for simplicity we instantiate to be 
$\Nat \uplus \Keys$, a set of clients $\Clients \defeq \Set{\cl, \cl',\cdots}$. 
We also assume a set of transaction identifiers $\TxID \defeq \Set{ \txid_{\cl}^{n} \mid \cl \in \Clients \wedge n \geq 0 } 
\uplus \Set{\txid_{0}}$,
each of which is either a special transaction identifier $\txid_0$, 
or it is indexed by a client identifier and a natural number. 
Elements of $\TxID$ are ranged over by $\txid, \txid', \cdots$, 
while subsets of $\TxID$ are ranged over $\txidset, \txidset', \cdots$. 
We let $\TxID_{0} = \TxID \setminus \{ \txid_0\}$.
The structure of the set $\TxID$  
embeds the order in which transactions are executed by individual clients, or \emph{session order}. 
Specifically, we let $\PO = \Set{ (\txid, \txid') \mid \exsts{ \cl, n,m } \txid = \txid_{\cl}^{n} \wedge 
\txid' = \txid_{\cl}^{m} \wedge n < m}$; 
\ac{Put some space between the existential quantifier and the quantified variable in the \textbackslash exsts macro. 
Same for \textbackslash fora.}
$(\txid, \txid') \in \PO$ means that 
some client $\cl$ has executed $\txid$ prior to $\txid'$. For $\PO$ (and in general  
for relations between transaction identifiers) we will often adopt the more graphic notation 
$\txid \xrightarrow{\PO} \txid'$ in lieu of $(\txid, \txid') \in \PO$.

Given a set $X$, then $\powerset{X}$ denotes 
the powerset of $X$, while $X^{\ast}$ is the free monoid induced by $X$.
%We define \( \Versions \) and \( \MKVSs \) in \cref{def:mkvs}.


\begin{definition}[Multi-version Key-value Stores]
\label{def:his_heap}
\label{def:mkvs}
%Assuming a countably infinite set of keys $\Keys = \Set{\ke_1, \cdots}$, \emph{transactions identifiers} \( \TxID \defeq \Set{\txid_{1}, \cdots}\) and natural numbers \(\nat \in \Nat \), 
A \emph{version} is a triple $\ver = (\val, \txid, \txidset)$. The set of versions is denoted by $\Versions \defeq \Val \times \TxID \times \powerset{\TxID}$, 
and a \emph{key-value store} is a partial, finite mapping $\hh \in \MKVSs \defeq \Keys \parfinfun \Versions^{\ast}$. 
\ac{ The superscript fin over the $\rightharpoonup$ needs to be fixed. You may want to look at the package extpfeil.}
%The set of key-value stores is denoted as $\HisHeaps$.
\end{definition}
\ac{Also, I am not sure whether we want the kv-store to be a partial mapping. What happens if you try to access a location not 
defined in the kv-store in the semantics? Viktor in his Thesis had the notion of faulty programs, and triples of the form 
$\{P\} C \{Q\}$ in RGsep also imply that the command $C$ is not faulty. If this point  does not get clarified, 
I suggest that we keep kv-stores as total mappings from keys to lists of versions. Shale, 
your previous comment. \textbf{I think it has no semantics in our case} is not a clarification.}
%\ac{Is it safe to assume that key-value stores are partial functions? What happens if we execute a program 
%that tries to access a key that is not in the key-value store? In his Thesis, Viktor had the notion of fault to distinguish cases 
%where non-allocated variables were used. Check. \sx{I think it has no semantics in our case.}}
%\ac{Also, in $\parfinfun$ the text above is out of sync. Fix. You may want to look at the extensible arrow package 
%(I think it's extpfeil, but I'm not sure and I am currently on a plane with no internet. Will Check.}
\emph{A version} $\ver = (\val, \txid, \txidset)$ consists of a value $\val$, and the meta-data of the transactions 
that accessed the version; specifically, $\txid$ is the identifier of the transaction that wrote such a version, 
and $\txidset$ is the set of identifiers of transactions that read the version.
Given a version $\ver = (\val, \txid, \txidset)$, we let $\valueOf(\ver) = \val$. 
$\WTx(\ver) = \txid$ and $\RTx(\ver) = \txidset$.
% for its value ($n$),
%$\WTx(\ver)$ for its writer ($\txid$) and $\RTx(\ver)$ for its readers ($\txidset$).
%, $\txid = \WTx(\ver)$ denotes the transaction identifier corresponding to the 
%writer of the version, while $\txidset = \RTx(\ver)$ contains the set of the transaction identifiers that read a version. 
Lists of versions, that is elements of $\Versions^{\ast}$, are ranged over by $\vilist, \vilist',\cdots$.

\emph{A multi-version key-value store}, or \emph{kv-store}, 
is a mapping from keys to lists of versions. 
For a given kv-store, $\hh$, key $\ke$ and index $i \geq 0$, we use the notation $\hh(\ke, i)$ 
to denote the $i$-th version (starting from $0$) installed for $\ke$; that is, if $\hh(\ke) = \ver_0 \cdots\ver_{n}$, then 
$\hh(\ke, i) = \ver_{i}$ if $i \leq n$, it is undefined otherwise. We also let $\lvert \hh(\ke) \rvert = n +1 $ denote 
the length of $\hh(\ke)$.

It will be often convenient to depict key-value stores graphically: an 
example is given by the kv-store $\hh$ depicted in \cref{fig:hheap-a}
(ignore for the moment the vertical lines labelled $\client$ and $\client'$). 
It comprises two keys \( \ke_1\) and \( \ke_2 \), 
each of which is associated with two versions carrying values $\val_0$ and $\val_1$, and $\val'_0$ and $\val'_1$, respectively.
The versions of a key are listed in order from left to right. 
We represent each version as a three-cell box, with the left cell storing the value, the top right cell recording the writer, and the bottom right cell recording the readers. 
For example, the version carrying value $\val_0$ in $\ke_1$ has been written by $\txid_0$, and has been read by $\txid_{\cl'}^1$.

In this paper we focus on key-value stores whose consistency model enforces the  
\emph{atomic visibility} of transactions \cite{framework-concur}. 
We also assume that in kv-stores, keys with a defined list of versions, have an initial version carrying  a default value $\val_0 \in \Val$, 
written by the special transaction identifies $\txid_0$.
% an initial 
%initialised by the special transaction identifier $\tsid_0$, i.e.  
%install the initial version of each key. 
A \emph{well-formed} kv-store $\hh$ requires that:
\begin{enumerate}[(i)]
\item\label{kv:wf.init} for each key $\ke \in \dom(\hh)$, $\hh(\ke, 0) = (\val_0, \txid_0, \stub)$, where $\val_0$ is a default value from $\Val$;
\item\label{kv:wf.onewrite} transactions never write more than one version per key,  
\[
\fora{\ke \in \dom(\hh)} \fora{ i,j : 0 \leq i, j < \lvert \hh(\ke) \rvert}
\WTx(\hh(\ke, i)) = \WTx(\hh(\ke, j)) \implies i = j \]
\ac{Before the text $\WTx(\hh(\ke, i))$ was changed to $\WTx(\ke, i)$. The latter form is wrong, 
as there is no reference to the kv-store that we are considering.}
%\item transactions never read different versions 
%for the same key $\fora{ \ke \in \dom(\hh)} \fora{ i,j : 0 \leq i, j < \lvert \hh(\ke) \rvert}
%\RTx(\ke, i) \cap \RTx(\ke, j) \neq \emptyset \implies i = j$;
\item\label{kv:wf.oneread} transactions never read different versions for the same key, 
\[
\fora{\ke \in \dom(\hh)} \fora{ i,j : 0 \leq i, j < \lvert \hh(\ke) \rvert} 
\RTx(\hh(\ke, i)) \cap \RTx(\hh(\ke, j)) \neq \emptyset \implies i = j
\]
\ac{I am leaving this comment here: to change the macro from the standard \textbackslash forall 
to \textbackslash fora, you elided the comma that separated the formula from the rest of the text. 
This is bad writing. If you need to make changes, please be sure that the text remains consistent 
and nicely written. This happened also in the previous item.}
\ac{Also, why do you insist on using the \textbackslash fora and \textbackslash exsts macros, when LaTeX has 
its own predefined ones (that everybody understands and knows)? Remember that you are working with other people, 
that will prefer the standard, well-known alternative.}
%\item all the reads of a transaction precede the writes of the same transaction, 
%\[\fora{ \ke \in \dom(\hh)}
%\fora{ i : 0 \leq i < \lvert \hh(k) \rvert} \WTx(\hh, k) \notin \RTx(\hh,k)
%\]
\item\label{kv:wf.so} the order 
in which transactions issued by the same client install different versions for some key $\ke$, is consistent with the order in which 
such transactions have been invoked; similarly, a client can read the version of a key $\ke$ only after it installed it. 
\begin{multline*}
\fora{ \ke \in \dom(\hh), \cl \in \Clients} \fora{ i,j; 0 \leq i < j < \lvert \hh(\ke) \rvert}
\fora{ n, m \geq 0}\\ (\txid_{\cl}^{n} = \WTx(\hh(\ke,i)) \wedge \txid_{\cl}^{m} \in \{\WTx(\hh(\ke,j))\} \cup \RTx(\hh(\ke, i)) \implies n < m.
\end{multline*}
\end{enumerate}
We always assume that kv-stores are well-formed, and let $\HisHeaps$ be the set of well-formed kv-stores.

%A\emph{multi-version key-value store (MKVS)}, \( \mkvs \in \MKVSs \), is a partial finite function from keys to lists of \emph{versions}.
%A \emph{version} is a triple containing a program value \( \val \), a transaction identifier \( \txid \) and a set of transactions identifiers \( \txidset \):
%\[
%\begin{rclarray}
%    \ver \in \Versions & \defeq &  \Setcon{(\val, \txid, \txidset)}{\val \in \Val \land \txid \in \TxID \land \txidset \subseteq \TxID \land \txid \notin \txidset} \\
%    \HisHeaps & \defeq & 
%    \Setcon{ \mkvs }{%
%        \mkvs \in \Keys \parfinfun \Versions^{*} 
%        \land \fora{\ke, \txid, i, j} 
%        \WTx(\hh(\ke, i)) = \WTx(\hh(\ke, j)) \lor {} \\
%        (\txid \in \RTx(\hh(\ke, i)) \land \txid \in \RTx(\hh(\ke, j))
%        \implies i = j 
%    }
%\end{rclarray}
%\]
%
%We model a kv-store $\hh$ as a map from keys to lists of versions.
%%where each key is associated with a list \emph{versions} from the initial one to the latest one (\defref{def:mkvs}).
%%More concretely, versions associated with a key $\ke$ 
%Versions are tuples of the form \( \ver =( \val, \txid, \txidset ) \), where $\val$ denotes the \emph{current value} of $\ke$, 
%$\txid$ is the identifier of the transaction that wrote such a version, 
%%, identifying its \emph{writer}, i.e.\ the transaction responsible for writing value $\val$, 
%and $\txidset$ is the set of identifiers of transactions that read the version.
%%, denoting its \emph{readers}, i.e.\ those transactions who read from $\ke$ 
%(see \cref{def:mkvs}).
%
%\cref{fig:hheap-a} depicts an example of an MKVS. 
%Ignoring the lines labelled $\client_1$ and $\client_2$, the depicted MKVS contains two keys \( \ke_1\) and \( \ke_2 \), each of which associated with two versions (with values $v_0$ and $v_1$ for $\ke_1$, and values $v'_0$ and $v'_1$ for $\ke_2$).
%The versions of a key are listed in chronological order from left to right.
%We represent each version as a three-cell box, with the left cell storing the value, the top right cell recording the writer, and the bottom right cell recording the readers. 
%
%
%Given a version $\ver = (\val, \txid, \txidset)$, we write $\valueOf(\ver)$ for its value ($n$), $\WTx(\ver)$ for its writer ($\txid$), $\RTx(\ver)$ for its readers ($\txidset$), and \( \txid' \in \ver \) for \( \txid' = \txid \lor \txid' \in \txidset \).
%%A \emph{Multi-version Key-value Store (MKVS)} is a mapping $\hh : \Keys \parfinfun \Versions^{\ast}$ from keys to lists of versions. 
%Given a list of versions $L = \List{\ver_0, \cdots, \ver_{s-1}}$, we write  $\lvert L\rvert$ for its length ($s$). 
%Given an MKVS $\hh$ and a key $\ke$, we write $\hh(\ke)$ for the list of versions associated with $\ke$ in $\hh$, and write \(\hh(\ke,i) \) for the $i$\textsuperscript{th} entry (indexed from $0$) in $\hh(\ke)$. 
%%We assume the index starts from 0, so \( \hh(\ke)(\left|\hh(\ke)\right| - 1)\) is the latest versions of the key \( \ke \).
%
%\azalea{I think $\hh$ is too close to $\ke$ and we should use a different symbol. Maybe $H$? }
%
%We assume a countably infinite set of \emph{keys}, $\Keys $,
%a set of countably infinite set of \emph{program values}, \( \val \in \Val \),
%a countably infinite set of \emph{client identifiers}, \( \cl \in \Clients \),
%and a countably infinite set of \emph{transactions identifiers indexed by client}, $\txid^{\cl} \in \TxID$
%We also assume there are countably infinite elements for every client, and elements for each client are ordered.
%We use \( \txid^{\cl}_{i}\) for the \emph{i-th} identifier among the total order and it is indexed by the client \( \cl \). 
%For a client, the order among transaction identifiers corresponds to the session order of them.
%Sometime we omit the order and/or client index when they are irrelevant.
%We use $\ke$ and its variants (e.g.\ $\ke_1$, $\ke'$ and so forth) as meta-variables for keys in $\Keys$.
%%and use $\txid$ and its variants as meta-variables for transaction identifiers in $\TxID$. 
%
%A key-value store is \emph{well-formed} iff 
%a transaction identifier appears in all versions of a key at most twice, once as the writer and once as a reader.
%%(i) it does not contain circular dependencies across its versions; and 
%%
%%Given two versions $\ver_1, \ver_2$ in an MKVS $\hh$, the $\ver_2$ \emph{directly depends} on $\ver_1$, written $\ver_1 \xrightarrow{\ddep} \ver_2$, iff:
%%\[ 
%%\begin{rclarray}
%%\ver_1 \xrightarrow{\ddep} \ver_2 & \defeq &
%%\begin{array}[t]{@{}l}
%%\WTx(\ver_2) \in \RTx(\ver_1) 
%%%\exsts{\cl,i,j,\txid_{i}^{\cl},\txid_{j}^{\cl}} \\
%%%\quad \txid_{i}^{\cl} < \txid_{j}^{\cl}
%%%\land \txid_{i}^{\cl} \in \ver_{1}
%%%\land \txid_{j}^{\cl} \in \ver_{2}
%%\end{array}
%%\end{rclarray}
%%\]
%%that is, a transaction $\txid$ wrote the version $\ver_2$ after reading $\ver_1$;
%%%or two transactions from the same client access
%%%The $\ver_1 \xrightarrow{\ddep(\hh)} \ver_2$ denotes that $\ver_1, \ver_2$ appear as versions from the same KVMS $\hh$ and \( \ver_1\) depends on \(\ver_2 \).
%
%%A key-value store is \emph{well-formed}, written $\pred{wfMKVS}{\hh}$, iff 
%%(i) it does not contain circular dependencies across its versions; and 
%%(ii) a transaction identifier appears in all versions of a key at most twice, once as the writer and once as a reader.
%%% a transaction identifier appears in all the versions for an key at most twice, one as the writer and one as a reader.
%%%
%%%Also there are no circular dependencies in versions. 
%%%More concretely, the first well-formedness condition (i) of an KVMS ensures that the \emph{transitive closure} of the direct dependency relation $\left(\xrightarrow{\ddep(\hh)}\right)^{+}$ is acyclic:
%%%in $\hh$, i.e. $\left(\xrightarrow{\ddep(\hh)} \right)^{+} \cap \text{Id} = \emptyset$ (where $\text{Id}$ is 
%%%the identity relation).
%%%\[
%%%\begin{rclarray}
%    %%\pred{wfMKVS}{\hh} & \defeq &
%    %%\begin{array}[t]{@{}l}
%        %%\pred{acyclic}{\left(\xrightarrow{\ddep(\hh)}\right)^{+}}
%        %%\land \fora{\ke, \txid, i, j}
%        %%\begin{B}
%        %%\WTx(\hh(\ke, i)) = \WTx(\hh(\ke, j)) \lor {} \\ (\txid \in \RTx(\hh(\ke, i)) \land \txid \in \RTx(\hh(\ke, j))
%        %%\end{B} 
%        %%\implies i = j 
%    %%\end{array}
%%%\end{rclarray}
%%%\]
%%%
%The \emph{partial commutative monoid (pcm) of MKVSs} is $(\MKVSs, \composeHH, \{\unitHH\})$, where 
%$\composeHH:  \MKVSs \times \MKVSs \rightharpoonup \MKVSs$ denotes the \emph{pcm composition} defined as the standard function disjointed union: $\composeHH \eqdef \uplus$; and
%%\( \hh \composeHH \hh' \defeq \hh \uplus \hh' \)
%$\unitHH \in \MKVSs$ denotes the \emph{pcm unit element}:  $\unitHH \eqdef \emptyset$, where $\emptyset$ denotes a function with an empty domain.
%\end{definition}
%
%\ac{A point that this does not ensure a real causal dependency between the two versions, yet it is consistent with the notion of causality employed in databases, should be made}. 
%

\begin{figure}
\begin{center}
\hrule
\begin{tabular}{@{}c @{\qquad} c@{}}
\begin{halfsubfig}
\begin{tikzpicture}
\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\ke_1 \mapsto$};

\matrix(versionx) [version list]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\txid_{\cl}^{1}$\\
    {a} & $\left\{\txid_{\cl'}^{1}\right\}$ & {a} & $\emptyset$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$v_0$};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$v_1$};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_2 \mapsto$};
\matrix(versiony) [version list]
   at ([xshift=\tikzkvspace]locy.east) {
 {a} & $\txid_0$ & {a} & $\txid_{\cl'}^{1}$ \\
  {a} & $\left\{\txid_{\cl}^1\right\}$ & {a} & $\emptyset$\\
};

\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$v'_0$};
\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{$v'_1$};

% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
 ([xshift=-3pt, yshift=20pt]locx-v1.north east) node (tid1start) {} -- 
 ([xshift=-3pt, yshift=-5pt]locx-v1.south east) --
 ([xshift=-3pt, yshift=5pt]locy-v0.north east) -- 
 ([xshift=-3pt, yshift=-5pt]locy-v0.south east);
 
 \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\client$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
 ([xshift=-16pt, yshift=5pt]locx-v1.north east) node (tid2start) {}-- 
% ([xshift=-16pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-16pt, yshift=5pt]locy-v1.north east) -- 
 ([xshift=-16pt, yshift=-5pt]locy-v1.south east) node {};
 
\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\client'$};

\end{pgfonlayer}
\end{tikzpicture}
\caption{A configuration with a well-formed kv-store $\hh$ and two views $\vi,\vi'$.}
\label{fig:hheap-a}
\end{halfsubfig}
&

\begin{halfsubfig} 
\begin{center}
\begin{tikzpicture}[scale=0.85, every node/.style={transform shape}]
%\draw[help lines] grid(6,4);

\node(t0wx) at (-1,2) {$(\otW, \ke_1, \val_0)$}; 
\path (t0wx.south) + (0,-0.2) node[anchor=north] (t0wy) {$(\otW, \ke_2, \val'_0)$};
\path (t0wx.north east) + (1,0.5) node[anchor = west] (t1ry) {$(\otR, \ke_2, \val'_0)$}; 
\path (t1ry.east) + (0.2,0) node[anchor = west] (t1wx) {$(\otW, \ke_1, \val_1)$};
\path (t0wy.south east) + (1,-0.5) node[anchor = west] (t2rx) {$(\otR, \ke_1, \val_0)$};
\path (t2rx.east) + (0.2,0) node[anchor = west] (t2wy) {$(\otW, \ke_2, \val'_1$)};

\begin{pgfonlayer}{background}
\node[background, fit=(t0wx) (t0wy)] (t0) {};
\node[background, fit= (t1ry) (t1wx)] (t1) {};
\node[background, fit= (t2rx) (t2wy)] (t2) {};

\path(t0.west) node[anchor=east] (t0lbl) {$\txid_0$};
\path(t1.north) node[anchor=south] (t1lbl) {$\txid_1$};
\path(t2.south) node[anchor=north] (t2lbl) {$\txid_2$};

\path[->]
(t0.north) edge[bend left=70] node[above, yshift=7pt, xshift=-1pt, pos=0.3] {$\RF(\ke_2), \VO(\ke_1)$} (t1.west)
(t0.south) edge[bend right=70] node[below, yshift=-8pt, xshift=-1pt, pos=0.3] {$\RF(\ke_1), \VO(\ke_2)$} (t2.west)
([xshift=-8pt]t2.north) edge[bend left=40] node[left] {$\AD(\ke_1)$} ([xshift=-8pt]t1.south) 
([xshift=8pt]t1.south) edge[bend left=40] node[right] {$\AD(\ke_2)$} ([xshift=8pt]t2.north);
\end{pgfonlayer}

%\begin{pgfonlayer}{foreground}
%%Uncomment line below for help lines
%%\draw[help lines] grid(5,4);
%
%%Location x
%\node(locx) {$\ke_1 \mapsto$};
%
%\matrix(versionx) [version list, text width=7mm, anchor=west]
%    at ([xshift=\tikzkvspace]locx.east) {
%    {a} & $\txid_0$ & {a} & $\txid_1$\\
%    {a} & $\emptyset$ & {a} & $\{\txid_2\}$ \\
%};
%\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$v_0$};
%\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$v_1$};
%
%%Location y
%\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_2 \mapsto$};
%\matrix(versiony) [version list, text width=7mm, anchor=west]
%    at ([xshift=\tikzkvspace]locy.east) {
%    {a} & $\txid_0$ & {a} & $\txid_2$ \\
%    {a} & $\emptyset$ & {a} & $\{\txid_1\}$\\
%};
%\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$v'_0$};
%\tikzvalue{versiony-1-3}{versiony-2-3}{locu-v1}{$v'_1$};
%
%% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);
%
%%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
%%\draw[-, blue, very thick, rounded corners=10pt]
%% ([xshift=-3pt, yshift=20pt]locx-v1.north east) node (tid1start) {} -- 
%% ([xshift=-3pt, yshift=-5pt]locx-v1.south east) --
%% ([xshift=-3pt, yshift=5pt]locy-v0.north east) -- 
%% ([xshift=-3pt, yshift=-5pt]locy-v0.south east);
%% 
%% \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\txid_1$};
%%
%%%red view
%%\draw[-, red, very thick, rounded corners = 10pt]
%% ([xshift=-16pt, yshift=5pt]locx-v1.north east) node (tid2start) {}-- 
%%% ([xshift=-16pt, yshift=-5pt]locx-v0.south east) --
%%% ([xshift=-16pt, yshift=5pt]locy-v1.north east) -- 
%% ([xshift=-16pt, yshift=-5pt]locy-v1.south east) node {};
%% 
%%\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\txid_2$};
%
%%%Stack for clients tid_1 and tid_2
%%
%%\draw[-, dashed] let 
%%   \p1 = ([xshift=0pt]locy.west),
%%   \p2 = ([yshift=-5pt]locycells.south),
%%   \p3 = ([xshift=10pt]locycells.east) in
%%   (\x1, \y2) -- (\x3, \y2);
%%   
%%\matrix(stacks) [
%%   matrix of nodes,
%%   anchor=north, 
%%   text=blue, 
%%   font=\normalsize, 
%%   row 1/.style = {text = blue}, 
%%   row 2/.style = {text = red}, 
%%   text width= 13mm ] 
%%   at ([xshift=-10pt,yshift=-8pt]locycells.south) {
%%   $\txid_1:$ & $\retvar = 0$\\
%%   $\txid_2:$ & $\retvar = 0$\\
%%   };
%\end{pgfonlayer}
\end{tikzpicture}
\end{center}
\caption{The dependency graph induced by $\hh$.}
\label{fig:hheap-b}
\end{halfsubfig} \\
\end{tabular}
\end{center}
\hrule
\caption{Multi-version key-value stores}
\label{fig:hheap}
\end{figure}

%Formally speaking, we assume a countably infinite set of keys $\ke = \{\key{k}_1, \cdots\}$, a set of transaction identifiers $\TxID = 
%\{ \txid_1, \cdots \}$, 
%a set of clients $\txidset = \{\txid_1, \cdots \}$.
%We also assume values to be natural numbers from the set $\nat$. 
%\ac{from now on, the sort font is used for sets.}
%\begin{definition}
%\label{def:hheap}
%A \emph{version} is a triple $\ver = ( n, \txid, \T)$, where, 
%$n$ is the value of the version, $\txid$ is the identifier of the transaction 
%that wrote the version, and $\T$ is a (possibly empty) set of identifiers of 
%the transactions that read the version.
%Given a version $\ver = (n, \txid, \T)$, 
%we let $\valueOf(\ver) = n$, $\WTx(\ver) = \txid$, $\RTx(\ver) = \T$. 
%The set of versions is denoted as $\Versions$.

%A \emph{Multi-version Key-value Store}, or MKVS, is a mapping  
%$\hh : \ke \rightarrow \Versions^{\ast}$ from keys to lists of versions. 
%\end{definition}
%Given a list of versions $\ver_1 \cdots \ver_{n}$, 
%we let $\lvert \ver_1 \cdots \ver_{n} \rvert = n$ be 
%its length. Also, let $\hh$ be a MKVS, $\key{k}$ be a key 
%such that $\hh(\key{k}) = \ver_1 \cdots \ver_n$, and 
%$i \leq n$ be a strictly positive natural number; then we let 
%$\hh(\key{k}, i) = \ver_i$. 

%\ac{Maybe it's better to keep $\ke$ fixed and say that we look at only a 
%fragment of the key value store. Alternatively, we can go for partial mappings to 
%represent MKVSs, but still avoiding allocation and deallocation of keys.}. To the left 
%we have the set of keys stored y $\hh_0$, in this case $\key{k}_1$ and 
%$\key{k}_2$. To the right, on the same line of a key, a matrix containing the
 %list of versions stored by such a key in $\hh_0$. Starting from the first column, 
 %each version is represented by two adjacent columns in the matrix: the 
 %column to the left gives the value of the version, while the column to the 
 %right contains the identifier of the transaction that wrote the version to the 
 %top, and the identifiers of the transactions that read such a version to the bottom.
%In the case of $\hh_0$, there are two versions stored for $\key{k}_1$: 
%the first one with value $0$, written by $\txid_0$ and read by $\txid_2$; 
%and the second one with value $1$, written by $\txid_2$ and read by no 
%transaction. 

%\ac{
%Throughout this paper, we focus on MKVSs that can be obtained in 
%databases whose consistency guarantees enjoy atomic visibility 
%\cite{framework-concur,SIanalysis,laws}. To this end, we impose 
%some well-formedness constraints on the MKVSs.

%\begin{definition}
%\label{def:hh.wellformed}
%\label{def:ddep}
%A MKVS $\hh$ is \emph{well-formed} if and only if 
%\begin{itemize}
%\item a transaction does not write two different versions for the same key: 
%$\forall \key{k} \in \ke.\;\forall i, j = 1,\cdots, \lvert \hh(\key{k}) \rvert. 
%\WTx(\hh(\key{k}, i)) = \WTx(\hh(\key{k}, j)) \implies i = j$, 
%\item a transaction does not read two different versions for the same key:  
%$\forall \key{k} \in \ke.\;\forall i, j = 1,\cdots, \lvert \hh(\key{k}) \rvert. 
%(\RTx(\hh(\key{k},i) \cap \RTx(\hh(\key{k}, j)) \neq \emptyset) \implies i = j$.
%\item There are no circular dependencies in versions. Given two versions 
%$\ver_1, \ver_2$, we say that $\ver_2$ \emph{direct dependency} from 
%$\ver_1$, written $\ver_1 \xrightarrow{\ddep} \ver_2$, if $\WTx(nu_2) \in \RTx(\ver_1)$; 
%that is, some transaction $\txid$ wrote the version $\ver_2$ after reading $\ver_1$ 
%\ac{A point that this does not ensure a real causal dependency between the 
%two versions, yet it is consistent with the notion of causality employed in databases, 
%should be made}. If $\ver_1, \ver_2$ appear as versions of some object in 
%$\hh$, then we write $\ver_1 \xrightarrow{\ddep(\hh)} \ver_2$. Then the relation $\left(\xrightarrow{\ddep(\hh)}\right)^{+}$ is acyclic in $\hh$, 
%i.e. $\left(\xrightarrow{\ddep(\hh)} \right)^{+} \cap \text{Id} = \emptyset$ (where $\text{Id}$ is 
%the identity relation).
%\end{itemize}
%\end{definition}
%}

%Let us elaborate on the first well-formedness constraint of an MKVS \( \mkvs \) in \cref{def:mkvs}. As stated above, this states that there is no circularity in the dependency relation.
%This in turn ensures that no versions are created \emph{out of thin-air}.
%An example of the out of thin-air anomaly is given in \cref{fig:hheap-b}, where
%transaction $\txid_2$ reads the value of $\ke_1$ written by $\txid_1$;
%conversely, transaction $\txid_1$ reads the value of $\ke_2$ written by $\txid_2$. 
%As we assume transactions read a state of the key-value store from an atomic snapshot fixed at the moment they execute, this situation cannot arise. 
%For $\txid_2$ to read the version written by $\txid_1$, transaction $\txid_2$ must start after $\txid_1$, \ie \( \hh(\ke_2, 1) \xrightarrow{\ddep(\hh_1)} \hh(\ke_1, 1) \).
%Similarly, $\txid_1$ must starts after $\txid_2$, \ie \( \hh(\ke_1, 1) \xrightarrow{\ddep(\hh_1)} \hh_1(\ke_2, 1) \).
%This however violates the well-formedness of MKVSs that $\xrightarrow{\ddep(\hh_1)}$ is acyclic. 

%\azalea{Why $\hh_1$ for the store and not $\hh$? Also I thought the versions are indexed from $0$ in which case index $2$ does not make sense here? \sx{\( \mkvs \) and index starts from 0.}}

%\azalea{common Latin abbreviations such as \ie, \eg, and et al. do not need to be italicised. I have adjusted the macros. I have also rephrased the definitions quite a bit. Make sure you're happy with this.}
%When introducing our semantics of clients in \S \ref{sec:semantics}, we show that (under reasonable conditions) it generates only well-formed MKVSs.

%\ac{
%A view $V$ defines the particular version of each key that a client 
%will observe when executing a transaction. A configuration consists 
%of a MKVS, and the views that a set of clients have each on the state 
%of the MKVS. An example of configuration is given in Figure \ref{fig:hheap}(a). 
%There are two clients, $\txid_1$ and $\txid_2$, each with their own view 
%(represented in the Figure by labelled lines crossing the MKVS at each location). 
%According to the view of $\txid_1$, formally defined as $V_1 = [\key{k}_1 \mapsto 2], 
%\key{k}_2 \mapsto 1]$, this client observes in $\hh$ the second version of key $\key{k}_1$, carrying 
%value $1$, and 
%the first version of $\key{k}_2$, carrying value $0$. Similarly, according to its view 
%$V_2 = [\key{k}_1 \mapsto 2, \key{k}_2 \mapsto 2]$, the client $\txid_2$ observes 
%in $\hh$the second and most up-to-date version for both $\key{k}_1$ and $\key{k}_2$.
%}

\mypar{Views, Configurations and Snapshots.}
%\ac{Configurations are trivial once that view are defined.}
%A MKVS tracks the global state of the system; however, different \emph{clients} may observe different versions of the same key. 
The key-value store tracks the global state, 
but when executing transactions, different \emph{clients} may observe 
different versions of the same key. To keep track of 
the versions they observe, clients are associated with \emph{views} (\cref{def:view}). 

%\begin{definition}[Views and configurations]
%\label{def:view}
%\label{def:cuts}
%\label{def:views}
%\label{def:configuration}
%Given a key-value store $\hh$, \emph{a view} in $\hh$ is a function  
%$\vi: \dom(\hh) \to \Nat$ such that, for any $\ke \in \dom(\hh)$, 
%$\vi(\ke) < \lvert \hh(\ke) \rvert$ and 
%\begin{equation}
%\label{eq:view.atomic}
%\fora{ \ke,\ke' \in \dom(\hh)} \fora{ i,j \in \Nat} (j \leq \vi(\ke) \wedge 
%\WTx(\hh(\ke, v(\ke))) = \WTx(\hh(\ke', i)) \implies i \leq \vi(\ke')
%\tag{Atomic}
%\end{equation}

\begin{definition}[Views and configurations]
\label{def:view}
\label{def:cuts}
\label{def:views}
\label{def:configuration}
Given a key-value store $\hh$, \emph{a view} in $\hh$ is a function  
$\vi: \dom(\hh) \to\powerset{\Nat}$ such that  
\[
\forall \ke \in \dom(\hh).\; 0 \in \vi(\ke) \wedge \forall i \in \vi(\ke).\; i < \lvert \hh(\ke) \rvert.
\]
and 
\begin{equation}
\label{eq:view.atomic}
\fora{ \ke,\ke' \in \dom(\hh)} \fora{ i,j \in \Nat} (j \in \vi(\ke) \wedge 
\WTx(\hh(\ke, \vi(\ke))) = \WTx(\hh(\ke', i)) \implies i \in \vi(\ke')
\tag{Atomic}
\end{equation}

\ac{Now views map keys to sets of indexes. In plain terms, we lifted 
an assumption in the model that required that once a client observes 
a version for key $\ke$, it must also observe any transaction that 
installed a previous version for $\ke$.\\
ALL THE FIGURES THAT USED VIEWS MUST BE DRAWN AGAIN. WE ALSO NEED A 
GRAPHIC FORMALISM FOR THE NEW NOTION OF VIEWS.}


%and \( \pred{atomic}{\mkvs,\vi} \),
%\[
%\begin{rclarray}
%\pred{atomic}{\mkvs,\vi} & \defeq &
%\begin{array}[t]{@{}l@{}}
%\fora{ \ke,\ke' \in \dom(\hh), i,j \in \Nat} \\
%\quad (j \leq \vi(\ke) \wedge 
%\WTx(\hh(\ke, v(\ke))) = \WTx(\hh(\ke', i)) \implies i \leq \vi(\ke')
%\end{array}
%\end{rclarray}
%\]
The set of views of $\hh$ is denoted 
as $\Views(\hh)$, and \emph{the set of views} is defined as:
\[
\Views \defeq \bigcup_{\hh \in \HisHeaps} \Views(\hh)
\]
A \emph{configuration} $\conf$ is a pair $(\hh, \viewFun)$, where $\viewFun: 
\Clients \parfinfun \Views(\hh)$. The configuration $\conf = (\hh, \stub)$ is 
initial if, for any $\ke$, $\hh(\ke) = (\val_0, \txid_0, \emptyset)$, for some 
initial value $\val_0$. The set of configurations is denoted as 
$\Confs$.
\end{definition}
\ac{Before I edited the definition was this one: 
Given a key-value store $\hh$, \emph{a view} in $\hh$ is function  
$\vi: \dom(\hh) \to \Nat$ such that, for any $\ke \in \dom(\hh)$, 
$\vi(\ke) < \lvert \hh(\ke) \rvert$ 
and \( \pred{atomic}{\mkvs,\vi} \),
\[
\begin{rclarray}
\pred{atomic}{\mkvs,\vi} & \defeq &
\begin{array}[t]{@{}l@{}}
\fora{ \ke,\ke' \in \dom(\hh), i,j \in \Nat} \\
\quad (j \leq \vi(\ke) \wedge 
\WTx(\hh(\ke, v(\ke))) = \WTx(\hh(\ke', i)) \implies i \leq \vi(\ke')
\end{array}
\end{rclarray}
\]
Before you used two different universal quantifiers for variables of different types, 
now you use a single universal quantifier for all variables. Make a choice, and be consistent 
with it. I don't think it is necessary to introduce the predicate atomic for the views, 
but we can just have a tagged equation. The less notation we have, the better it is. 
If you insist on using atomic as a predicate, then it should be introduced properly. 
For example: [..] and \( \pred{atomic}{\mkvs, \vi} \), \textbf{WHERE} \( \pred{atomic}{\mkvs, \vi} \defeq \cdots \)
}
Given $\hh \in \HisHeaps$ and two views $\vi, \vi' \in \Views(\hh)$, 
we let $\vi \viewleq \vi'$ if, for any $\ke \in \dom(\hh)$, $\vi(k) \subseteq \vi'(\ke)$. 
\ac{Note that the definition of $\viewleq$ has been changed to reflect the new definition of views.}
%In this case we say that $\vi$ is older than $\vi'$ ($\vi'$ is newer than $\vi$).

%\emph{A configuration} (\cref{def:configuration} augments the notion of kv-stores with the information 
%about the version observed by each client. 
\emph{A configuration}
includes a kv-store and a partial mapping from clients from clients to views.
\ac{Before it was: \emph{A configuration} (\cref{def:configuration}).\\
Configurations were introduced literally two lines ago. Do not include references when 
they are not necessary.}
%about the version observed by each client of its clients. 
The view of the client $\cl$ in $\hh$ reflects the set of versions for each key 
that the client \(\cl \) observes upon executing a transaction. 
The constraint of \cref{eq:view.atomic} establishes that if a client observes 
a version of some key written by a transaction $\txid$, then it must observe all the versions of 
all keys that $\txid$ wrote. This constraint captures the \emph{atomic visibility} of transactions.

{\color{red} We often depict views of clients graphically by drawing client-labelled lines crossing 
versions of key-value stores. A line crossing the $i$-th version of key $\ke$ defines a view 
$\vi$ for client $\cl$, with $\vi(\ke) = i$. One example is given by \cref{fig:hheap-a} where the configuration is
$\conf_0 = (\hh_0, \Set{\cl_1 \mapsto \vi_1, \cl_2 \mapsto \vi_2})$. 
There are two clients, 
$\cl_1$ and $\cl_2$, with views $\vi_1$, and $\vi_2$ respectively. $\vi_1$ crosses $\ke_1$ at its $0$-th 
version, and $\ke_2$ at its $1$-st version. Therefore we have $\vi_1 = \Set{\ke_1 \mapsto 0, \ke_2 \mapsto 1}$. 
Similarly, we have $\vi_2 = \Set{\ke_1 \mapsto 1, \ke_2 \mapsto 0}$. }
\ac{Paragraph Above must be rewritten when we decide on a graphic notation for 
the new notion of views.}
%\ac{Never refer to colors in text. People may read in black and white.}

Given a kv-store $\hh$, a view $\vi$ and a key $\ke \in \dom(\hh)$, 
we commit an abuse of notation and write $\hh(\ke, \vi)$ as a shorthand 
for $\hh(\ke, \max(\vi(\ke)))$. Note that such a version is well-defined because 
we are assuming that $\vi(\ke) \neq \emptyset$.
The view $\vi$ naturally induces a \emph{snapshot} 
by extracting the value of the most up-to-date version it observes for each key $\ke \in \dom(\hh)$. 
%As we will see presently, snapshots are used to determine the value of keys returned 
%by read operations of transactions. 
As we will see presently, transactions operate on their own snapshots.
Because of atomicity, the value of keys returned 
by read operations of transactions. 
\begin{definition}[Snapshots]
\label{def:heaps}
\label{def:snapshot}
Given $\hh \in \HisHeaps$ and $\vi \in \Views(\hh)$, the snapshot of $\vi$ in 
$\hh$ is defined as $\snapshot(\hh, \vi) = \lambda \ke. \valueOf(\hh(\ke, \vi))$.
\end{definition}

\ac{General comment: the explanations should be okay, but I wonder whether we now have 
too many definitions. We may consider putting all the definitions in a table, and 
go through there in the text. Though I am for using tables with notations and 
definitions only as a last resort - they tend to be scary.}

%of $\vi$ by accessing the value of 
%A view $\vi$ in $\hh$ naturally defines a snapshot $\snapshot(\hh, \nu)$
%A MKVS tracks the global state of the system; however, different \emph{clients} may observe different versions of the same key. 
%To model this, we introduce the notion of \emph{views} (\cref{def:views}). 
%A view $V$ reflects the particular version for each key that a client observes upon executing a transaction. 
%%We present an example of views in \cref{fig:hheap-a} with two views: $\client_1$ in red and $\client_2$ in blue.
%More concretely, the view for \( \client_1 \) is given formally as $\vi_1 = \Set{\key{k}_1 \mapsto 1, \key{k}_2 \mapsto 0}$.
%That is, the client with view $\vi_1$ observes the second version (at index 1) of key \( \ke_{1} \) with value $v_1$, and the first version (at index 0) of key \( \ke_2 \) with value $v'_0$.
%%, and 
%%the first version of $\key{k}_2$, carrying value $0$. Similarly, according to its view 
%%$V_2 = [\key{k}_1 \mapsto 2, \key{k}_2 \mapsto 2]$, the client $\txid_2$ observes 
%%in $\hh$the second and most up-to-date version for both $\key{k}_1$ and $\key{k}_2$.
%
%\begin{definition}[Views]
%\label{def:view}
%\label{def:cuts}
%\label{def:views}
%\emph{A view} is a partial finite function from keys to indexes:
%$
%\vi \in \Views \defeq \Addr \parfinfun \Nat 
%%\begin{rclarray}
%%    \vi \in \Views & \defeq & \Addr \parfinfun \Nat 
%%\end{rclarray}
%$.                                                                 
%The \emph{view composition}, $\composeVI: \Views \times \Views \rightharpoonup \Views$ is defined as the standard disjoint function union: $\composeVI \eqdef \uplus$. 
%% \( \vi \composeVI \vi' \defeq \vi \uplus \vi'\) 
%The \emph{unit view}, $\unitVI \in \Views$, is a function with an empty domain: $\unitVI \eqdef \emptyset$. 
%% and the unit is \( \unitVI \defeq \emptyset\).
%The \emph{order relation} on views, $\orderVI: \Views \times \Views$, is defined between two views with the same domain as the point-wise comparison of their indexes for each entry: 
%\[
%\begin{rclarray}
%    \vi \orderVI \vi' & \defiff & \dom(\vi) = \dom(\vi') \land \fora{\ke} \cu(\ke) \leq \cu'(\ke) \\
%\end{rclarray}
%\]
%\end{definition}
%%
%We say view $\vi$ is \emph{older} than view $\vi'$ (or $\vi'$ is \emph{newer} than $\vi$) whenever $\vi \orderVI \vi'$ holds.
%
%
%\mypar{Configurations} A \emph{configuration} comprises an MKVS, and the views associated with clients.
%In \cref{fig:hheap-a} we present an example of a configuration comprising an MKVS and the two views associated with clients $\client_1$ and $\client_2$. 
%We write $\version(\hh, \ke, \vi)$ for $\hh(\ke, \vi(\ke))$; 
%and write $\valueOf(\hh, \ke, \vi)$ as a shorthand for $ \valueOf(\version(\hh, \key{k}, V))$; similarly for $\WTx, \RTx$.
%%we commit an abuse of notation and often write $\valueOf(\hh, \ke, \vi)$ in lieu of $ \valueOf(\version(\hh, \key{k}, V))$, and similarly for $\WTx, \RTx$.
%When $\ver = \version(\hh, \ke, \vi)$, we say that \emph{$\vi$ $\ke$-points to $\ver$ in $\hh$}. 
%When $\ver = \hh(\ke, i)$ for some $0 \leq i \le \vi(\ke)$, we say that \emph{$\vi$ $\ke$-includes $\ver$ in $\hh$}.
%Lastly, we always assume that MKVSs, views, and configurations are well-formed, unless otherwise stated.
%
%
%
%\begin{definition}[Configurations]
%A view $\vi$ is \emph{well-formed with respect to an MKVS} $\mkvs$, written \( \wfV{\mkvs, \vi} \),  iff they have the same domain and every index from $\vi$ is within the range of the corresponding entry in $\mkvs$ and the view is \emph{atomic} with  respect to the key-value store: 
%\[
%\begin{rclarray}
%    \wfV{\mkvs, \vi} & \defeq & \dom(\mkvs) = \dom(\vi) \land \fora{\ke \in \dom(\vi)} 0 \leq \vi(\ke) < \lvert \mkvs(\ke) \rvert \\
%    \pred{atomic}{\vi ,\hh} & \eqdef & \fora{\txid } \exsts{\ke, i} i \leq \vi(\ke) \land \hh(\ke,i) = (\stub, \txid, \stub) \implies \pred{visible}{\txid, \vi, \hh} \\ 
%    \pred{visible}{\txid, \vi, \hh} & \eqdef & \fora{\ke, i} \hh(\ke,i) = (\stub, \txid, \stub) \implies i \leq \vi(\ke) 
%\end{rclarray}
%\]
%%
%\azalea{We need a symbol for this to fill the ???? above. Also ???? below. \sx{Done}}
%A \emph{configuration} $\conf$ is a pair of the form $(\hh, \viewFun)$, where $\hh$ denotes an MKVS, and $\viewFun: \Clients \parfinfun \Views$ is a partial finite function from clients to views. 
%A configuration $\conf = (\hh, \viewFun)$ is \emph{well-formed}, written \( \wfC{\conf}\), iff for all clients $\cl \in \dom(\viewFun)$, the view $\viewFun(\txid)$ is well-formed with respect to $\hh$. 
%%We say that a view $V$ is well-defined with respect to the 
%%MKVS $\hh$ if, $\forall \key{k} \in \ke. 0 < V(\key{k}) \leq 
%%\lvert \hh(\key{k}) \rvert$. 
%%Given a view $V$ that is well-defined 
%%with respect to a 
%
%\end{definition}
%
%\mypar{Snapshots} When a client executes a transaction on the $\mkvs$ MKVS, it extracts a \emph{snapshot} of it via the \( \func{snapshot}{\mkvs, \vi} \) function, extracting the values corresponding to the versions indexed by its view \( \vi \) (\cref{def:snapshot}).
%For instance, for client \( \client_1 \) in \cref{fig:hheap-a}, the $\func{snapshot}{\cdots}$ functions yields a state where key $\ke_1$ carries value $v_1$ and second key \( \ke_2 \) carries value $v'_0$.
%%The concrete state extracted in this way takes the name of the \emph{snapshot} of the transaction.
%%In general, the process of determining the view of a client, hence the snapshot in which such a client executes transactions, is non-deterministic.
%
%\azalea{Before in MKVSs we had values drawn from $\Nat$ in \cref{def:mkvs}. Now we use $\Val$. I think you mean to use $\Val$ in both places? \sx{I would say so} }
%\begin{definition}[Snapshots]
%\label{def:heaps}
%\label{def:snapshot}
%Given the sets of values $\Val$  and keys \( \Addr\)  (\cref{def:mkvs}), the set of \emph{snapshots} is:
%$
%    \h \in \Heaps \eqdef \Addr \parfinfun \Val
%$. 
%%\[
%%\begin{rclarray}
%%    \h \in \Heaps & \eqdef & \Addr \parfinfun \Val
%%\end{rclarray}
%%\]
%The \emph{snapshot composition function}, $\composeH: \Heaps \times \Heaps \parfun \Heaps$, is defined as $\composeH \eqdef \uplus$, where $\uplus$ denotes the standard disjoint function union. The \emph{ snapshot unit element} is $\unitH \eqdef \emptyset$, denoting a function with an empty domain.
%The \emph{partial commutative monoid of snapshots} is $(\Heaps, \composeH, \{\unitH\})$.
%Given an MKVS $\hh$ and a view $\vi$, the snapshot of $\vi$ in $\hh$, written $\snapshot(\hh, \vi) $, is defined as:
%$
%    \snapshot(\hh, \vi) \defeq \lambda \ke \ldotp \valueOf(\hh, \ke, \vi)
%$.
%%\[
%%\begin{rclarray}
%%    \snapshot(\hh, \vi) & \defeq & \lambda \ke \ldotp \valueOf(\hh, \ke, \vi).
%%\end{rclarray}
%%\]
%\end{definition}
%
%\sx{Need some explanation}
%\ac{General Comment on this Section: it is too abstract. We 
%should give either here or in the introduction an example of computation - 
%the write skew program should be okay that helps the reader understanding 
%what's going on. Also, it could be also good to illustrate the notions 
%of execution tests and consistency models.}
%
%\sx{From Andrea: introduce the execution test here with a table, also introduce fingerprint here}

\mypar{Relationship between kv-stores and dependency graphs.}
\ac{It could be that this subsection gets moved to a different section, where 
we also relate specifications of consistency models using dependency graphs
with execution tests.}
\emph{Dependency graphs} are a formalism  introduced by Adya to specify 
consistency models of transactional databases \cite{adya}. They are direct graphs consisting of transactions as nodes, 
each of which is labelled with the respective fingerprint, and labelled edges 
between transactions for specifying how information flows within a computation. 
Specifically, a transaction $\txid$ may read a version for a key $\ke$ that has been written by another transaction $\txid'$ 
(\emph{write-read dependency}), overwrite a version of $\ke$ written by $\txid'$ (\emph{write-write dependency}), or 
read a version of $\ke$ that is later overwritten by $\txid'$ (\emph{read-write anti-dependency}).
\begin{definition}
A \emph{dependency graph} is a quadruple $\Gr = (\TtoOp{T}, \RF, \VO, \AD)$, where
\begin{itemize}
\item $\TtoOp{T}: \TxID_{0} \rightharpoonup \powerset{\Ops}$ is a partial function 
mapping transaction identifiers to the set of operations they perform, 
\item $\RF : \Keys \rightarrow \dom(\TtoOp{T}) \times \dom(\TtoOp{T})$ is a function that 
maps each key $\ke$ into a relation between transactions, such that for any $\txid, \txid_1, \txid_2, 
\ke, \cl, m, n$: 
\begin{itemize}
\item if $(\otR, \ke, \val) \in \TtoOp{T}(\txid)$, either $\val = \val_0$ 
and there exists no $\txid'$ such that $\txid' \xrightarrow{\RF(\ke)} \txid$,  
or there exists $\txid'$ such that $(\otW, \ke, \val) \in \TtoOp{T}(\txid')$, and $\txid' \xrightarrow{\RF(\ke)} \txid$, 
\item if $\txid_1 \xrightarrow{\RF(\ke)} \txid$ and $\txid_2 \xrightarrow{\RF(\ke)} \txid$, then 
$\txid_2 = \txid_1$, 
\item if $\txid_{\cl}^{m} \xrightarrow{\RF(\ke)} \txid_{\cl}^{n}$, then $m < n$.
\end{itemize}
\item $\VO: \Keys \rightarrow \dom(\TtoOp{T}) \times \dom(\TtoOp{T})$ is a function 
that maps each key into an irreflexive relation between transactions, such that for any $\txid, \txid', \ke, \cl, m, n$, 
\begin{itemize}
\item if $\txid \xrightarrow{\VO(\ke)} \txid'$, then $(\otW, \ke, \_) \in \TtoOp{T}(\txid), (\otW, \ke, \_) \in \TtoOp{T}(\txid')$, 
\item if $(\otW, \ke, \_) \in \TtoOp{T}(\txid), (\otW, \ke, \_) \in \TtoOp{T}(\txid')$, then either $\txid = \txid'$, 
$\txid \xrightarrow{\VO(\ke)} \txid'$, or $\txid' \xrightarrow{\VO(\ke)} \txid$, 
\item if $\txid_{\cl}^{m} \xrightarrow{\RF(\ke)} \txid_{\cl}^{n}$, then $m < n$.
\end{itemize}
\item $\AD: \Keys \rightarrow \dom(\TtoOp{T}) \times \dom(\TtoOp{T})$ is defined 
by letting $\txid \xrightarrow{\AD(\ke)} \txid'$ if and only if $(\otR, \ke, \_) \in \TtoOp{T}(\txid)$, 
$(\otW, \ke, \_) \in \TtoOp{T}(\txid')$ and 
either there exists no $\txid''$ such that $\txid'' \xrightarrow{\RF(\ke)} \txid$, or 
$\txid'' \xrightarrow{\RF(\ke)} \txid$, $\txid'' \xrightarrow{\VO(\ke)} \txid'$ for 
some $\txid''$.
\end{itemize}
\end{definition}
Given a dependency graph $\Gr = (\TtoOp{T}, \RF, \VO, \AD)$, we often 
commit an abuse of notation and use $\RF$ to denote the relation 
$\bigcup_{\ke \in \Keys} \RF_{\ke}$; a similar notation is adopted for $\VO, \AD$. 
It will always be clear from the context whether the symbol $\RF$ refers to a function 
from keys to relations, or to a relation between transactions. 

%A dependency graph $\Gr = (\TtoOp{T}, \RF, \VO, \AD)$ is well-formed if 
%$(\PO \cup \RF \cup \VO)$ is acyclic, i.e. its transitive closure is irreflexive. 
%Henceforth, we always assume that dependency graphs are well-formed, 
%and we let 
We let $\Dgraphs$ be the set of all dependency graphs.
It is always possible to convert a kv-store $\hh$ into a well-formed dependency 
graph. For example, \cref{fig:hheap-b} illustrates the dependency graph constructed 
from the kv-store depicted in \cref{fig:hheap-a}.

\begin{definition}
\label{def:kv2graph}
Given a kv-store $\hh$, the \emph{dependency graph} $\Gr_{\hh} = (\TtoOp{T}_{\hh}, \RF_{\hh}, 
\VO_{\hh}, \AD_{\hh})$ is defined as follows: 
\begin{itemize}
\item for any $\txid \neq \txid_0$, $\TtoOp{T}_{\hh}(\txid)$ is defined if and only if there exists an index $i$ and a key 
$\ke$ such that either $\txid = \WTx(\hh(\ke, i))$, or $\txid \in \RTx(\hh(\ke,i))$; furthermore, 
$(\otW, \ke, \val) \in \TtoOp{T}(\txid)$ if and only 
if $\txid = \WTx(\hh(\ke, i))$ for some $i$, and 
$(\otR, \ke, \val) \in \TtoOp{T}(\txid)$ if and only if $\txid \in \RTx(\hh(\ke, i))$ for some $i$, 
\item $\txid \xrightarrow{\RF(\ke)} \txid'$ if and only if there exists an index $i: 0 < i < \lvert \hh(\ke) \rvert$ 
such that $\txid = \WTx(\hh(\ke, i))$, and $\txid' \in \RTx(\hh(\ke, i))$, 
\item $\txid \xrightarrow{\VO(\ke)} \txid'$ if and only if there exist two indexes $i,j$: $0 < i < j < \lvert \hh(\ke) \rvert$ 
such that $\txid = \WTx(\ke, i)$, $\txid' = \WTx(\ke, j)$, 
\item $\txid \xrightarrow{\AD(\ke)} \txid'$ if and only if there exist two indexes $i,j$: $0 < i < j < \lvert \hh(\ke) \rvert$ 
such that $\txid \in \RTx(\ke, i)$ and $\txid' = \WTx(\ke, j)$.
\end{itemize}
\end{definition}

\begin{theorem}
\label{thm:kv2graph}
The function $\Gr_{(\stub)}$ is a bijection between kv-stores and well-formed dependency graphs.
\end{theorem}

\ac{Both the formal definition of dependency graph and the function $\graphof$ will need to go in the appendix.}
