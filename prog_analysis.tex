\section{Program Analysis}

Contents: \\
transactional implementation of a counter. \\
Counter is not robust when a 
weak consistency model (i.e. causal consistency, in practice anything that does not 
guarantee both write-conflict detection and monotonic reads) is assumed. \\
A single counter is robust as long as the consistency model used by the database 
guarantees both write-conflict detection and monotonic reads.\\
Multiple counters are not robust even when monotonic reads and write-conflict 
detection are guaranteed by the database. In particular, multiple counters are 
not robust when PSI is guaranteed by the database.\\
Multiple counters are robust if a stronger consistency models, such as SI, is employed 
by the database.

\paragraph{Counter Code}
\[
\begin{array}{lrlr}
\mathsf{inc}(\ke) = &
\begin{session}
\begin{transaction}
\pderef{\pv{a}}{\ke};\\
\pmutate{\ke}{\pv{a}+1};
\end{transaction}
\end{session}
&
\hspace{10pt}\mathsf{read}(\ke) = &
\begin{session}
\begin{transaction}
\pderef{\pv{a}}{\ke};\\
\end{transaction}
\end{session}
\end{array}
\]

%For the moment, we assume that the key-value store contains a single object $\ke$. 
Also, clients can interact with the key-value store only by invoking the $\mathsf{inc}(\ke)$ and 
$\mathsf{read}(\ke)$ operations.
Given the transactional code 
$\ptrans{\trans}$, we define $\opset(\hh, \vi, \ptrans{\trans})$ 
to be the fingerprint that would be produced by a client that has view $\vi$ 
over the kv-store $\hh$, upon executing $\ptrans{\trans}$.
For example, we have that 
%$\opset(\hh, \vi, \mathsf{inc}(\ke))$ is the fingerprint generated 
%by a client $\cl$ with view $\vi$ after executing the operation $\mathsf{inc}(\ke)$. 
%Specifically, 
$\opset(\hh, \vi, \mathsf{inc}(\ke)) = \{(\otR, \ke, n), (\otW, \ke, n+1) \mid 
n = \snapshot(\hh, \vi)\}$. Similarly, $\opset(\hh, \vi ,\mathsf{read}(\ke)) = 
\{(otR, \ke, n) \mid n = \snapshot(\hh, \vi)\}$.
A transactional module is a set of transaction codes $\{\ptrans{\trans_i}_{i \in I}\}$.
Given an execution test $\ET$, and a transactional module $\{\ptrans{\trans_i}\}_{i \in I}$, 
we define the set of valid $\ET$-traces for the transactional module as the set 
$\mathsf{Traces}(\ET, \{\ptrans{\trans_i}\}_{i \in I})$ 
of $\ET$-traces in which only $\ET$-reductions of the form 
\[
(\hh, \viewFun) \xrightarrowtriangle{\left(\cl, \opset\left(\hh, \viewFun(\cl), \ptrans{\trans_{i}}\right)\right)}_{\ET} (\hh', \viewFun')
\]
are allowed. 
We also let $\mathsf{KVStores}(\ET, \{\ptrans{\trans_i}\}_{i \in I})$ be the set of kv-stores 
that can be obtained when clients can only perform operations from $\{\ptrans{\trans_i}\}_{i \in I}$ 
under the execution test $\ET$. Specifically, 
\[
\mathsf{KVStores}(\ET, \{\ptrans{\trans_i}\}_{i \in I}) = \{ \hh \mid \left( (\hh_0, \viewFun_{0}) \xrightarrowtriangle{\cdot}_{\ET} \cdots 
\xrightarrowtriangle{\cdot}_{\ET} (\hh, \_)\right) \in \mathsf{Traces}(\ET, \{\ptrans{\trans_{i}}\}_{i \in I}) \}.
\]

\paragraph{Anomaly under Causal Consistency.}
It is well known that even when the key-value store consists of a single object $\ke$, which 
can be manipulated via the $\mathsf{inc}(\ke)$ and $\mathsf{read}(\ke)$ transactions, 
then it is possible to obtain non-serialisable executions over the kv-store. Henceforth, 
we write $(\hh, \viewFun) \xrightarrowtriangle{(\cl, \ptrans{\trans})}_{\ET} (\hh', \viewFun')$ 
as a shorthand for $(\hh, \viewFun) \xrightarrowtriangle{\left(\cl, \opset\left(\hh, \viewFun(\cl), \ptrans{\trans}\right)\right)}_{\ET} (\hh', \viewFun')$. 
For simplicity, let us assume that $\Keys = \ke$.
Let $\hh_{0} = [\ke \mapsto (0, \txid_{0}, \emptyset)]$,  
$\hh_1 = [\ke \mapsto (0, \txid_{0}, \{\txid_{\cl_1}^{1}\} \lcat (0, \txid_{\cl_1}^{1}, \emptyset)$, 
$\hh_2 = [\ke \mapsto (0, \txid_{0}, \{\txid_{\cl_1}^{1}, \txid_{\cl_2}^{1}\}) \lcat (0, \txid_{\cl_1}^{1}, \emptyset) 
\lcat (0, \txid_{\cl_2}^{1}, \emptyset)$. Let also
$\vi_{0} = [\ke \mapsto {0}]$. Then we have that 
\[
(\hh_{0}, [\cl_1 \mapsto \vi_0, \cl_2 \mapsto \vi_0]) \xrightarrowtriangle{(\cl_1, \mathsf{inc(\ke)})}_{\ET_{\CC}} 
(\hh_1, [\cl_1 \mapsto \_, \cl_2 \mapsto \vi_0]) \xrightarrowtriangle{(\cl_1, \mathsf{inc(\ke)})}_{\ET_{\CC}} 
(\hh_2, \_).
\]
If we now draw the dependency graph $\graphof(\hh_2)$, we immediately find a cycle of the form 
$\txid_{\cl_1}^{1} \xrightarrow{\AD(\ke)} \txid_{\cl_2}^{1} \xrightarrow{\AD(\ke)} \txid_{\cl_1}^{1}$, 
which proves that $\hh_2$ cannot be obtained in any serialisable execution.

\paragraph{Robustness of a Single counter under Parallel Snapshot Isolation.}
In practice we show that a single counter is robust under any consistency model 
that guarantees both write conflict detection (formalised by the execution test 
$\ET_{\UA}$) and monotonic reads (formalised by the execution test $\ET_{\MRd}$). 
\begin{proposition}
\label{prop:counter_hhshape}
Let $\mathsf{Counter} = \{\mathsf{inc}(\ke), \mathsf{read}(\ke)\}$.
Let $\hh$ be in $\mathsf{KVStores}(\ET_{\UA} \cap \ET_{\MRd} \cap \ET_{\RYW}, \mathsf{Counter})$. Then we have that 
there exist $\{\txid_i\}_{i = 1}^{n}$ and $\{\T_{i}\}_{i = 0}^{n}$ such that 
\begin{align}
\forall i=0,\cdots,n.\T_{i} \cap \{\txid_{i}\}_{i=0}^{n} = \emptyset \label{eq:psi_counter_rwtxs}\\
\hh(\ke) = \left( (0, \txid_{0}, \T_{0} \uplus \{\txid_1\}) \lcat \cdots \lcat (n-1, \txid_{n-1}, \T_{n-1} \uplus \{\txid_{n}\}) \right) 
\lcat (n, \txid_{n}, \T_{n}) \label{eq:psi_counter_shape}\\
\forall \txid, \txid'.\;\forall i,j=0,\cdots, n.\; \txid \xrightarrow{\PO} \txid' 
\wedge \txid \in \{\txid_{i}\} \cup \T_{i} \implies 
\left(\begin{array}{l}
(\txid' = \txid_{j} \implies i < j) \wedge {} \\
(\txid' \in \T_{j} \implies i \leq j) \\
%(\txid \in \T_{i} \wedge \txid' = \txid_{j} \implies i < j) \wedge {} \\
%(\txid \in \T_{i} \wedge \txid' \in \T_{j} \implies i \leq j)
\end{array}\right) \label{eq:psi_counter_so}
\end{align}
%
%
%
%for any $i = 1,\cdots, n$, $\T_{i} \cap \{\txid_i\}_{i=0}^{n} = \emptyset$, and 
%$\hh(\ke) = \left(\prod_{i=0}^{n-1} (i, \txid_{i}, \T_{i} \uplus \{\txid_{i+1}\}) \right) \lcat 
%(n, \txid_{n}, \T_{n})$. Furthermore, if there exist four indexes $i,j, p, q$ such that 
%$\txid_{\cl}^{p} \in \WTx(\hh(\ke, i) \cup \RTx(\hh(\ke, i))$ and 
%$\txid_{\cl}^{q} \in \WTx(\hh(\ke, j) \cup \RTx(\hh(\ke, j))$, then 
%$i < j \implies p < q$.
\end{proposition}

\begin{proof}
First we prove that the properties \eqref{eq:psi_counter_rwtxs}, \eqref{eq:psi_counter_shape} 
\eqref{eq:psi_counter_so} given in \cref{prop:counter_hhshape}, are invariant under 
$\ET$-reductions of the form 
\begin{align*}
(\hh, \viewFun) \xrightarrow{(\cl, \mathsf{inc}(\ke))}_{\ET_{\UA} \cap \ET_{\MRd} \cap \ET_{\RYW}} (\hh', \viewFun')\\
(\hh, \viewFun) \xrightarrow{(\cl, \mathsf{read}(\ke))}_{\ET_{\UA} \cap \ET_{\MRd} \cap \ET_{\RYW}} (\hh', \viewFun)
\end{align*}
In fact, we also prove an auxiliary invariant property of configurations $(\hh, \viewFun)$ under $\ET$-reduction of the form above, 
which can be expressed as 
\begin{equation}
\forall i, n.\; \forall \cl.\; \txid_{\cl}^{n} \in \{\WTx(\hh(\ke, i))\} \cup \RTx(\hh(\ke, i)) \implies 
\exists j \geq i.\;\viewFun(\cl) = [\ke \mapsto \{0, \cdots, j\}] \label{eq:psi_counter_view}
\end{equation} 

Suppose that $(\hh, \viewFun)$ satisfy the properties \eqref{eq:psi_counter_rwtxs}-\eqref{eq:psi_counter_view}; 
assume also that 
\[
(\hh, \viewFun) \xrightarrow{(\cl, \mathsf{inc}(\ke))}_{\ET_{\UA} \cap \ET_{\MRd} \cap \cap \ET_{\RYW}} (\hh', \viewFun')
\]
for some $\cl, \hh', \viewFun'$. Let $n+1 = \lvert \hh(\ke) \rvert$. Because of the definition of 
$\ET_{\UA}$, we must have that $\viewFun(\cl) = [\ke \mapsto \{0, \cdots, n\}]$. Also, 
because $\hh$ satisfies \eqref{eq:psi_counter_shape}, we have that $\snapshot(\hh, \viewFun(\cl))(\ke) = n$. 
In particular, $\opset(\ke, \viewFun(\cl), \mathsf{inc}(\ke)) = \{(\otR, \ke, n), (\otW, \ke, n+1)\}$. 
Thus we have that $\hh' \in \updateKV(\hh, \viewFun(\cl), \cl, \{(\otR, \ke, n), (\otW, \ke, n+1)\})$. 
We can now prove the following: 
\begin{itemize}
\item $\hh'$ satisfies Property \eqref{eq:psi_counter_shape}. 
Recall that $\hh' \in \updateKV(\hh, \viewFun(\cl), \cl, \{(\otR, \ke, n), (\otW, \ke, n+1)\}$. By \eqref{eq:psi_counter_shape}, 
we know that $\hh(\ke) = \left( (0, \txid_{0}, \T_{0} \uplus \{\txid_1\}) \lcat \cdots \lcat (n-1, \txid_{n-1}, \T_{n-1} \uplus \{\txid_{n}\}) \right) 
\lcat (n, \txid_{n}, \T_{n})$ 
for some $\{\txid_{i}\}_{i=1}^{n}$ and $\{\T_{i}\}_{i=0}^{n}$. Let $\txid_{n+1}$ be the transaction identifier 
chosen to update $\hh$, i.e. $\hh' = \updateKV(\hh, \viewFun(\cl), \txid_{n+1}, \{(\otR, \ke, n), (\otW, \ke, n+1)\})$. 
It follows that $\hh' = \left( (0, \txid_{0}, \T_{0} \uplus \{\txid_1\}) \lcat \cdots \lcat (n-1, \txid_{n-1}, \T_{n} \uplus \{\txid_{n+1}\}) \right) 
\lcat (n+1, \txid_{n+1}, \emptyset)$. If we let $\T_{n+1} = \emptyset$, then we have that $\hh'$ satisfies \eqref{eq:psi_counter_shape}, 
\item $\hh'$ satisfies Property \eqref{eq:psi_counter_rwtxs}; in fact, let $i =0, \cdots, n+1$. If $i = n+1$, then 
$\T_{i} = \emptyset$, from which $\T_{i} \cap \{\txid_{j}\}_{j=0}^{n+1} = \emptyset$ follows. If $i < n+1$, then 
because $\hh$ satisfies Property \eqref{eq:psi_counter_rwtxs}, then $\T_{i} \cap \{\txid_{j}\}_{j=0}^{n} = \emptyset$. 
Finally, because $\txid_{n+1}$ was chosen to be fresh with respect to the transaction identifiers appearing in 
$\hh$, and $\T_{i} \subseteq \RTx(\hh(\ke, i)$, then  we also have that $\T_{i} \cap \{\txid_{n+1}\} = \emptyset$. 
By combining all these facts, we obtain that $\hh'$ satisfies Property \eqref{eq:psi_counter_rwtxs}.
\item $\hh'$ satisfies Property $\eqref{eq:psi_counter_so}$. To prove this, let 
$\txid, \txid'$ be such that $\txid \xrightarrow{\PO} \txid'$. Choose two aribtary indexes $i,j=0,\cdots, n+1$, 
and assume that $\txid \in \{\txid_{i}\} \cup \T_{i}$. Note that if $i \leq n$, $j \leq n$, then 
because $\hh$ satisfies Property $\eqref{eq:psi_counter_so}$, then 
if $\txid' = \txid_{j}$ it follows that $i < j$, and if $\txid' \in \T_{j}$ it follows that $i \leq j$, as 
we wanted to prove. 
If $\txid \in \{\txid_{n+1} \cup \T_{n+1}$, then it must be $\txid = \txid_{n+1}$ because 
$\T_{n+1} = \emptyset$. Recall that $\txid_{n+1}$ is the transaction identifier that was used 
to update $\hh$ to $\hh'$, i.e. $\hh' = \updateKV(\hh, \viewFun(\cl), \txid_{n+1}, \_)$. By 
definition of $\updateKV$, it follows that $\txid_{n+1} \in \nextTxId(\hh, \cl)$, thus for no 
%$\txid'' \in \{\txid_{j}\}_{j=0}^{n+1} \cup \bigcup \{\T_{j}\}_{j=0}^{n+1}$, we have that 
$\txid \xrightarrow{\PO} \txid'$. Finally, if $\txid' \in \{\txid_{n+1}\} \cup \T_{n+1}$, then 
it must be the case that $\txid' = \txid_{n+1}$. If $\txid = \txid_{j}$, because 
$\txid \xrightarrow{\SO} \txid'$ and $\txid' = \txid_{n+1}$, it cannot b $\txid = \txid_{n+1}$, 
hence it must be $j \leq n < n+1$. If $\txid \in \T_{j}$, because $\T_{n+1} = \emptyset$ it 
follows that $j < i$. 
\item $(\hh', \viewFun')$ satisfies Property \eqref{eq:psi_counter_view}.  
Consider an arbitrary client $\cl'$. If $\cl' \neq \cl$, $\viewFun'(\cl') = \viewFun(\cl')$: if $\txid_{\cl'}^{m} \in \{\WTx(\hh'(\ke, i))\} 
\cup \RTx(\hh'(\ke, i))$ for some $i = 0,\cdots, n+1$, then because $\RTx(\hh'(\ke, n+1)) = \emptyset$, $\cl' \neq \cl$ and $\txid_{n+1} = \txid_{\cl}^{\cdot}$, 
then it must be the case that $i \leq n$. Because $(\hh, \viewFun)$ satisfies Property \eqref{eq:psi_counter_view}, 
then there exists an index $j \geq i$ such that $\viewFun'(\cl') = \viewFun(\cl') = [\ke \mapsto \{0,\cdots, j\}]$. 
Finally, suppose that $\cl' = \cl$. 
By definition of $\ET_{\UA}$, $\viewFun(\cl) = [\ke \mapsto \{0,\cdots, n\}]$, and the definition 
of $\ET_{\MRd}$ and $\ET_{\RYW}$ imply that $\viewFun'(\cl) = [\ke \mapsto \{0,\cdots, n+1\}]$. 
Clearly, whenever $\txid_{\cl}^{\cdot} \in  \{\WTx(\hh'(\ke, i))\} 
\cup \RTx(\hh'(\ke, i))$ for some $i$, then it must be the case that $i \leq n$.
\end{itemize}
%%It suffices to prove that, given a reduction of the form 
%%\[
%%(\hh, \viewFun) \xrightarrow{(\cl, \mathsf{inc}(\ke))}_{\ET_{\UA} \cap \ET_{\MRd}} (\hh', \viewFun)
%%\]
%%then if $\hh$ has the shape described in \cref{prop:counter_hhshape}, then so has $\hh'$, 
%%and similarly for $\mathsf{read}(\ke)$ operations. In practice, we can show that the result holds for 
%%$\ET$-reductions of the form 
%%\[
%%(\hh, \viewFun) \xrightarrow{(\cl, \mathsf{inc}(\ke))}_{\ET_{\UA}} (\hh', \viewFun)
%%\]
%%and $\ET$-reductions of the form 
%%\[
%%(\hh, \viewFun) \xrightarrow{(\cl, \mathsf{read}(\ke))}_{\ET_{\MRd}} (\hh', \viewFun)
%%\]
%%Proving this second result also requires to place an invariant on $\viewFun(\cl)$, which states 
%%that if $\txid_{\cl}^{n} \in \WTx(\hh) \cup \RTx(\hh)$, then there exists $m \geq n$ such that 
%%$\viewFun(\cl) = \{i \mid i \leq m\}$.
\end{proof}

%\begin{corollary}
%Given $\hh \in \mathsf{KVStores}(\ET_{\UA} \cap \ET_{\MRd} \cap \ET_{\RYW}, \mathsf{Counter})$, 
%then $\graphof(\hh)$ is acyclic.
%\end{corollary}