\section{Program Analysis}

Contents: \\
transactional implementation of a counter. \\
Counter is not robust when a 
weak consistency model (i.e. causal consistency, in practice anything that does not 
guarantee both write-conflict detection and monotonic reads) is assumed. \\
A single counter is robust as long as the consistency model used by the database 
guarantees both write-conflict detection and monotonic reads.\\
Multiple counters are not robust even when monotonic reads and write-conflict 
detection are guaranteed by the database. In particular, multiple counters are 
not robust when PSI is guaranteed by the database.\\
Multiple counters are robust if a stronger consistency models, such as SI, is employed 
by the database.

\paragraph{Counter Code}
\[
\begin{array}{lrlr}
\mathsf{inc}(\ke) = &
\begin{session}
\begin{transaction}
\pderef{\pv{a}}{\ke};\\
\pmutate{\ke}{\pv{a}+1};
\end{transaction}
\end{session}
&
\hspace{10pt}\mathsf{read}(\ke) = &
\begin{session}
\begin{transaction}
\pderef{\pv{a}}{\ke};\\
\end{transaction}
\end{session}
\end{array}
\]

%For the moment, we assume that the key-value store contains a single object $\ke$. 
Also, clients can interact with the key-value store only by invoking the $\mathsf{inc}(\ke)$ and 
$\mathsf{read}(\ke)$ operations.
Given the transactional code 
$\ptrans{\trans}$, we define $\opset(\hh, \vi, \ptrans{\trans})$ 
to be the fingerprint that would be produced by a client that has view $\vi$ 
over the kv-store $\hh$, upon executing $\ptrans{\trans}$.
For example, we have that 
%$\opset(\hh, \vi, \mathsf{inc}(\ke))$ is the fingerprint generated 
%by a client $\cl$ with view $\vi$ after executing the operation $\mathsf{inc}(\ke)$. 
%Specifically, 
$\opset(\hh, \vi, \mathsf{inc}(\ke)) = \{(\otR, \ke, n), (\otW, \ke, n+1) \mid 
n = \snapshot(\hh, \vi)\}$. Similarly, $\opset(\hh, \vi ,\mathsf{read}(\ke)) = 
\{(otR, \ke, n) \mid n = \snapshot(\hh, \vi)\}$.
A transactional module is a set of transaction codes $\{\ptrans{\trans_i}_{i \in I}\}$.
Given an execution test $\ET$, and a transactional module $\{\ptrans{\trans_i}\}_{i \in I}$, 
we define the set of valid $\ET$-traces for the transactional module as the set 
$\mathsf{Traces}(\ET, \{\ptrans{\trans_i}\}_{i \in I})$ 
of $\ET$-traces in which only $\ET$-reductions of the form 
\[
(\hh, \viewFun) \xrightarrowtriangle{\left(\cl, \opset\left(\hh, \viewFun(\cl), \ptrans{\trans_{i}}\right)\right)}_{\ET} (\hh', \viewFun')
\]
are allowed. 
We also let $\mathsf{KVStores}(\ET, \{\ptrans{\trans_i}\}_{i \in I})$ be the set of kv-stores 
that can be obtained when clients can only perform operations from $\{\ptrans{\trans_i}\}_{i \in I}$ 
under the execution test $\ET$. Specifically, 
\[
\mathsf{KVStores}(\ET, \{\ptrans{\trans_i}\}_{i \in I}) = \{ \hh \mid \left( (\hh_0, \viewFun_{0}) \xrightarrowtriangle{\cdot}_{\ET} \cdots 
\xrightarrowtriangle{\cdot}_{\ET} (\hh, \_)\right) \in \mathsf{Traces}(\ET, \{\ptrans{\trans_{i}}\}_{i \in I}) \}.
\]

\paragraph{Anomaly under Causal Consistency.}
It is well known that even when the key-value store consists of a single object $\ke$, which 
can be manipulated via the $\mathsf{inc}(\ke)$ and $\mathsf{read}(\ke)$ transactions, 
then it is possible to obtain non-serialisable executions over the kv-store. Henceforth, 
we write $(\hh, \viewFun) \xrightarrowtriangle{(\cl, \ptrans{\trans})}_{\ET} (\hh', \viewFun')$ 
as a shorthand for $(\hh, \viewFun) \xrightarrowtriangle{\left(\cl, \opset\left(\hh, \viewFun(\cl), \ptrans{\trans}\right)\right)}_{\ET} (\hh', \viewFun')$. 
For simplicity, let us assume that $\Keys = \ke$.
Let $\hh_{0} = [\ke \mapsto (0, \txid_{0}, \emptyset)]$,  
$\hh_1 = [\ke \mapsto (0, \txid_{0}, \{\txid_{\cl_1}^{1}\} \lcat (0, \txid_{\cl_1}^{1}, \emptyset)$, 
$\hh_2 = [\ke \mapsto (0, \txid_{0}, \{\txid_{\cl_1}^{1}, \txid_{\cl_2}^{1}\}) \lcat (0, \txid_{\cl_1}^{1}, \emptyset) 
\lcat (0, \txid_{\cl_2}^{1}, \emptyset)$. Let also
$\vi_{0} = [\ke \mapsto {0}]$. Then we have that 
\[
(\hh_{0}, [\cl_1 \mapsto \vi_0, \cl_2 \mapsto \vi_0]) \xrightarrowtriangle{(\cl_1, \mathsf{inc(\ke)})}_{\ET_{\CC}} 
(\hh_1, [\cl_1 \mapsto \_, \cl_2 \mapsto \vi_0]) \xrightarrowtriangle{(\cl_1, \mathsf{inc(\ke)})}_{\ET_{\CC}} 
(\hh_2, \_).
\]
If we now draw the dependency graph $\graphof(\hh_2)$, we immediately find a cycle of the form 
$\txid_{\cl_1}^{1} \xrightarrow{\AD(\ke)} \txid_{\cl_2}^{1} \xrightarrow{\AD(\ke)} \txid_{\cl_1}^{1}$, 
which proves that $\hh_2$ cannot be obtained in any serialisable execution.

\paragraph{Robustness of a Single counter under Parallel Snapshot Isolation.}
In practice we show that a single counter is robust under any consistency model 
that guarantees both write conflict detection (formalised by the execution test 
$\ET_{\UA}$) and monotonic reads (formalised by the execution test $\ET_{\MRd}$). 
\begin{proposition}
\label{prop:counter_hhshape}
Let $\mathsf{Counter} = \{\mathsf{inc}(\ke), \mathsf{read}(\ke)\}$.
Let $\hh$ be in $\mathsf{KVStores}(\ET_{\UA} \cap \ET_{\MRd} \cap \ET_{\RYW}, \mathsf{Counter})$. Then we have that 
there exist $\{\txid_i\}_{i = 1}^{n}$ and $\{\T_{i}\}_{i = 0}^{n}$ such that 
\begin{align}
\hh(\ke) = \left( (0, \txid_{0}, \T_{0} \uplus \{\txid_1\}) \lcat \cdots \lcat (n-1, \txid_{n-1}, \T_{n-1} \uplus \{\txid_{n}\}) \right) 
\lcat (n, \txid_{n}, \T_{n}) \label{eq:psi_counter_shape}\\
\forall i=0,\cdots,n.\T_{i} \cap \{\txid_{i}\}_{i=0}^{n} = \emptyset \label{eq:psi_counter_rwtxs}\\
\forall \txid, \txid'.\;\forall i,j=0,\cdots, n.\; \txid \xrightarrow{\PO} \txid' 
\wedge \txid \in \{\txid_{i}\} \cup \T_{i} \implies 
\left(\begin{array}{l}
(\txid' = \txid_{j} \implies i < j) \wedge {} \\
(\txid' \in \T_{j} \implies i \leq j) \\
%(\txid \in \T_{i} \wedge \txid' = \txid_{j} \implies i < j) \wedge {} \\
%(\txid \in \T_{i} \wedge \txid' \in \T_{j} \implies i \leq j)
\end{array}\right) \label{eq:psi_counter_so}
\end{align}
%
%
%
%for any $i = 1,\cdots, n$, $\T_{i} \cap \{\txid_i\}_{i=0}^{n} = \emptyset$, and 
%$\hh(\ke) = \left(\prod_{i=0}^{n-1} (i, \txid_{i}, \T_{i} \uplus \{\txid_{i+1}\}) \right) \lcat 
%(n, \txid_{n}, \T_{n})$. Furthermore, if there exist four indexes $i,j, p, q$ such that 
%$\txid_{\cl}^{p} \in \WTx(\hh(\ke, i) \cup \RTx(\hh(\ke, i))$ and 
%$\txid_{\cl}^{q} \in \WTx(\hh(\ke, j) \cup \RTx(\hh(\ke, j))$, then 
%$i < j \implies p < q$.
\end{proposition}

\begin{proof}
It suffices to prove that the properties \eqref{eq:psi_counter_rwtxs}, \eqref{eq:psi_counter_shape} 
\eqref{eq:psi_counter_so} given in \cref{prop:counter_hhshape}, are invariant under 
$\ET$-reductions of the form 
\begin{align}
(\hh, \viewFun) \xrightarrow{(\cl, \mathsf{inc}(\ke))}_{\ET_{\UA} \cap \ET_{\MRd} \cap \ET_{\RYW}} (\hh', \viewFun') \label{eq:psi_counter_inc}\\
(\hh, \viewFun) \xrightarrow{(\cl, \mathsf{read}(\ke))}_{\ET_{\UA} \cap \ET_{\MRd} \cap \ET_{\RYW}} (\hh', \viewFun) \label{eq:psi_counter_read}
\end{align}
to this end, we will need the following auxiliary result which holds for any configuration $(\hh, \viewFun)$ 
that can be obtained under the execution test $\ET_{\RYW} \cap \ET_{\MRd}$:
%\begin{equation}
%\forall i, n.\; \forall \cl.\; \txid_{\cl}^{n} \in \{\WTx(\hh(\ke, i))\} \cup \RTx(\hh(\ke, i)) \implies 
%\exists j \geq i.\;\viewFun(\cl) = [\ke \mapsto \{0, \cdots, j\}] \label{eq:psi_counter_view}
%\end{equation} 

\begin{equation}
\forall i, n.\; \forall \cl.\; \txid_{\cl}^{n} \in \{\WTx(\hh(\ke, i))\} \cup \RTx(\hh(\ke, i)) \implies 
i \in \viewFun(\cl)\label{eq:psi_counter_view}
\end{equation} 
Suppose that there exist two sets $\{\txid_{i}\}_{i=1}^{n}$ and 
$\{\T_{i}\}_{i=0}^{n}$ such that $(\hh, \{\txid_{i}\}_{i=1}^{n}, \{\T_{i}\}_{i=1}^{n})$ 
satisfies the properties \eqref{eq:psi_counter_shape}-\eqref{eq:psi_counter_so}. 
We prove that, for transitions of the form \eqref{eq:psi_counter_inc}-\eqref{eq:psi_counter_read}, 
there exist an index $m$ and two collections $\{\txid_{i}\}_{i=1}^{m}$, $\{\T'_{i}\}_{i=0}^{m}$ 
such that $(\hh', \{\txid_{i}\}_{i=1}^{m}, \{\T'_{i}\}_{i=0}^{m})$ satisfies the properties 
\eqref{eq:psi_counter_shape}-\eqref{eq:psi_counter_so}. We consider the two transitions separately.

\begin{itemize}
\item 
Assume that
\[
(\hh, \viewFun) \xrightarrow{(\cl, \mathsf{inc}(\ke))}_{\ET_{\UA} \cap \ET_{\MRd} \cap \cap \ET_{\RYW}} (\hh', \viewFun')
\]
for some $\cl, \hh', \viewFun'$. Let $n+1 = \lvert \hh(\ke) \rvert$. Because of the definition of 
$\ET_{\UA}$, we must have that $\viewFun(\cl) = [\ke \mapsto \{0, \cdots, n\}]$. Also, 
because $\hh$ satisfies \eqref{eq:psi_counter_shape}, we have that $\snapshot(\hh, \viewFun(\cl))(\ke) = n$. 
In particular, $\opset(\ke, \viewFun(\cl), \mathsf{inc}(\ke)) = \{(\otR, \ke, n), (\otW, \ke, n+1)\}$. 
Thus we have that $\hh' \in \updateKV(\hh, \viewFun(\cl), \cl, \{(\otR, \ke, n), (\otW, \ke, n+1)\})$. 
Let $\txid_{n+1}$ be the transaction identifier 
chosen to update $\hh$, i.e. $\hh' = \updateKV(\hh, \viewFun(\cl), \txid_{n+1}, \{(\otR, \ke, n), (\otW, \ke, n+1)\})$, 
where $\txid_{n+1} \in \nextTxId(\hh, \cl)$; 
let also $\T_{n+1} = \emptyset$. Then we have the following: 
\begin{itemize}
\item  $(\hh', \{\txid_{i}\}_{i=1}^{n+1}, \{\T_{i}\}_{i=0}^{n+1})$ satisfies Property \eqref{eq:psi_counter_shape}. 
%Recall that $\hh' \in \updateKV(\hh, \viewFun(\cl), \cl, \{(\otR, \ke, n), (\otW, \ke, n+1)\}$. 
Recall that $(\hh, \{\txid_{i}\}_{i=1}^{n}, \{\T_{i}\}_{i=0}^{n})$ satisfies \eqref{eq:psi_counter_shape}, 
i.e.
\[\hh(\ke) = \left( (0, \txid_{0}, \T_{0} \uplus \{\txid_1\}) \lcat \cdots \lcat (n-1, \txid_{n-1}, \T_{n-1} \uplus \{\txid_{n}\}) \right) 
\lcat (n, \txid_{n}, \T_{n}).
\]
%for some $\{\txid_{i}\}_{i=1}^{n}$ and $\{\T_{i}\}_{i=0}^{n}$. 
%Let $\txid_{n+1}$ be the transaction identifier 
%chosen to update $\hh$, i.e. $\hh' = \updateKV(\hh, \viewFun(\cl), \txid_{n+1}, \{(\otR, \ke, n), (\otW, \ke, n+1)\})$, 
%where $\txid_{n+1} \in \nextTxId(\hh, \cl)$. 
It follows that $\hh'(\ke) = \left( (0, \txid_{0}, \T_{0} \uplus \{\txid_1\}) \lcat \cdots \lcat (n-1, \txid_{n-1}, \T_{n} \uplus \{\txid_{n+1}\}) \right) 
\lcat (n+1, \txid_{n+1}, \T_{n+1})$, 
where we recall that $\T_{n+1} = \emptyset$.
%By choosing $\T_{n+1} := \emptyset$, then we have that $(\hh', \{\txid_{i}_{i=1}^{n+1}, \{\T_{i}\}_{i=0}^{n+1})$ 
%satisfies Property \eqref{eq:psi_counter_shape}, 

\item $(\hh', \{\txid_{i}\}_{i=1}^{n+1}, \{\T_{i}\}_{i=0}^{n+1})$ 
satisfies Property \eqref{eq:psi_counter_rwtxs}. Let $i =0, \cdots, n+1$. If $i = n+1$, then 
$\T_{i} = \emptyset$, from which $\T_{i} \cap \{\txid_{j}\}_{j=0}^{n+1} = \emptyset$ follows. If $i < n+1$, then 
because $(\hh, \{\txid_{i}\}_{i=1}^{n}, \{\T_{i}\}_{i=0}^{n})$ 
satisfies Property \eqref{eq:psi_counter_rwtxs}, then $\T_{i} \cap \{\txid_{j}\}_{j=0}^{n} = \emptyset$. 
Finally, because $\txid_{n+1}$ was chosen to be fresh with respect to the transaction identifiers appearing in 
$\hh$, and $\T_{i} \subseteq \RTx(\hh(\ke, i))$, then  we also have that $\T_{i} \cap \{\txid_{n+1}\} = \emptyset$. 
%By combining all these facts, we obtain that $\hh'$ satisfies Property \eqref{eq:psi_counter_rwtxs}.
\item $(\hh', \{\txid_{i}\}_{i=1}^{n+1}, \{\T_{i}\}_{i=0}^{n+1})$ satisfies Property \eqref{eq:psi_counter_so}. Let 
$\txid, \txid'$ be such that $\txid \xrightarrow{\PO} \txid'$. Choose two arbitrary indexes $i,j=0,\cdots, n+1$, 
and assume that $\txid \in \{\txid_{i}\} \cup \T_{i}$. Note that if $i \leq n$, $j \leq n$, then 
because $(\hh, \{\txid_{i}\}_{i=1}^{n}, \{\T_{i}\}_{i=0}^{n})$ satisfies Property $\eqref{eq:psi_counter_so}$, then 
if $\txid' = \txid_{j}$ it follows that $i < j$, and if $\txid' \in \T_{j}$ it follows that $i \leq j$, as 
we wanted to prove. 
If $\txid \in \{\txid_{n+1}\} \cup \T_{n+1}$, then it must be $\txid = \txid_{n+1}$ because 
$\T_{n+1} = \emptyset$. Recall that $\txid_{n+1}$ is the transaction identifier that was used 
to update $\hh$ to $\hh'$, i.e. $\hh' = \updateKV(\hh, \viewFun(\cl), \txid_{n+1}, \_)$. By 
definition of $\updateKV$, it follows that $\txid_{n+1} \in \nextTxId(\hh, \cl)$, 
and because $\txid_{n+1} \xrightarrow{\PO} \txid'$, then $\txid'$ cannot appear in $\hh'$. 
In particular, 
$\txid' \notin \{\txid_{j}\}_{j=0}^{n+1} \cup \bigcup \{\T_{j}\}_{j=0}^{n+1}$, hence in this case there is nothing to prove. 
Finally, if $\txid' \in \{\txid_{n+1}\} \cup \T_{n+1}$, then 
it must be the case that $\txid' = \txid_{n+1}$. If $\txid = \txid_{j}$, because 
$\txid \xrightarrow{\SO} \txid'$ and $\txid' = \txid_{n+1}$, it cannot be $\txid = \txid_{n+1}$, 
hence it must be $i \leq n < n+1$. 
%If $\txid \in \T_{i}$, because $\T_{n+1} = \emptyset$ it 
%follows that $j < i$. 
%\item $(\hh', \viewFun')$ satisfies Property \eqref{eq:psi_counter_view}.  
%Consider an arbitrary client $\cl'$. If $\cl' \neq \cl$, $\viewFun'(\cl') = \viewFun(\cl')$: if $\txid_{\cl'}^{m} \in \{\WTx(\hh'(\ke, i))\} 
%\cup \RTx(\hh'(\ke, i))$ for some $i = 0,\cdots, n+1$, then because $\RTx(\hh'(\ke, n+1)) = \emptyset$, $\cl' \neq \cl$ and $\txid_{n+1} = \txid_{\cl}^{\cdot}$, 
%then it must be the case that $i \leq n$. Because $(\hh, \viewFun)$ satisfies Property \eqref{eq:psi_counter_view}, 
%then there exists an index $j \geq i$ such that $\viewFun'(\cl') = \viewFun(\cl') = [\ke \mapsto \{0,\cdots, j\}]$. 
%Finally, suppose that $\cl' = \cl$. 
%By definition of $\ET_{\UA}$, $\viewFun(\cl) = [\ke \mapsto \{0,\cdots, n\}]$, and the definition 
%of $\ET_{\MRd}$ and $\ET_{\RYW}$ imply that $\viewFun'(\cl) = [\ke \mapsto \{0,\cdots, n+1\}]$. 
%Clearly, whenever $\txid_{\cl}^{\cdot} \in  \{\WTx(\hh'(\ke, i))\} 
%\cup \RTx(\hh'(\ke, i))$ for some $i$, then it must be the case that $i \leq n$.
\end{itemize}

\item Suppose that $(\hh, \viewFun)$ satisfies the properties \eqref{eq:psi_counter_rwtxs}-\eqref{eq:psi_counter_view}; 
assume also that 
\[
(\hh, \viewFun) \xrightarrow{(\cl, \mathsf{read}(\ke))}_{\ET_{\UA} \cap \ET_{\MRd} \cap \cap \ET_{\RYW}} (\hh', \viewFun')
\]
As in the previous case, we have that $\hh' = \updateKV(\hh, \viewFun(\cl), \txid, \{(\otR, \ke, m)\})$, where 
$m = \snapshot(\hh, \viewFun(\cl))(\ke)$ and $\txid \in \nextTxId(\hh, \cl)$. 
We also have that $\viewFun'(\cl') = \viewFun(\cl')$ for any $\cl' \neq \cl$, and 
from the definition of $\ET_{\MRd}$ we also have that $\viewFun(\cl) \viewleq \viewFun'(\cl)$. 
Henceforth, we let $i = \max_{<}\viewFun(\cl)(\ke)$.
Putting all these facts together, we obtain the following: 
\begin{itemize}
\item $\hh'$ satisfies Property \eqref{eq:psi_counter_shape}. 
Because $\hh$ satisfies $\eqref{eq:psi_counter_shape}$, then if $i < n$, then $\hh(\ke, i) = 
(i, \txid_{i}, \T_{i} \cup \{\txid_{i+1}\})$;  
otherwise $i = n$ and $\hh(\ke, i) = \hh(\ke, n) = (n, \txid_{n}, \T_{n})$. 
In both cases we have that 
hence $m = \snapshot(\hh(\ke), \viewFun(\cl)) = \valueOf(i, \_, \_) = i$.

Because $\hh' = \updateKV(\hh, \viewFun(\cl), \txid, \{(\otR, \ke, n)\}$, 
then $\lvert \hh'(\ke) \rvert = \lvert \hh(\ke) \rvert = n+1$. 
By definition of $\updateKV$, we have that for any $j=0,\cdots, n$, 
$j \neq i$, then $\hh(\ke, j) = \hh'(\ke, j)$; without loss of generality, 
let us assume that $i \neq n$: we also have that 
\[
\begin{array}{l}
\hh'(\ke, i) = \text{let } (v, \txid', \T) = \hh(\ke, i) \text{ in } (v, \txid', \T \cup \{\txid\}) = \\
\text{let } (v, \txid', \T) = (i, \txid_{i}, \T_{i} \cup \{\txid_{i+1}\}) \text{ in } 
(v, \txid', \T \cup \{\txid\}) = (n ,\txid', \T_{i} \cup \{\txid \} \cup \{\txid_{i+1}\}.
\end{array}
\]
Similarly, in the case that $i = n$, we have that $\hh'(\ke, i) =(i, \txid_{i}, \T_{i} \cup \{\txid\})$.
If we let $\T'_{j} := \T_{j}$ for any $j \neq i$, and $\T'_{i} := \T_{i} \cup \{ \txid \}$, then 
we have that $\hh'$ satisfies Property \ref{eq:psi_counter_shape}, relatively to the sets 
$\{\txid_{i}\}_{i=1}^{n}$ and $\{\T'_{j}\}_{j = 0}^{n}$.

\item $\hh'$ satisfies Property \eqref{eq:psi_counter_rwtxs}. To this end, let $j =0,\cdots, n$, 
and consider the set of transactions $\T'_{i}$. Let again $i = \max_{<}\viewFun(\cl)(\ke)$ . 
If $j \neq i$, then $\T'_{j} = \T_{j}$, and because $\hh$ satisfies Property \eqref{eq:psi_counter_rwtxs} 
we have that $\T'_{j} \cap \{\txid_{i}\}_{i=0}^{n} = \emptyset$. If $j = i$, then 
we have that $\T'_{j} = \T'_{i} = \T_{i} \cup \{\txid\}$, where we recall that $\txid \in \nextTxId(\hh, \cl)$. 
Because $\hh$ satisfies Property \eqref{eq:psi_counter_rwtxs}, we have that $\T_{i} \cap \{\txid_{i}\}_{i=0}^{n} 
= \emptyset$. Finally, because $\txid \in \nextTxId(\hh,\cl)$, then it must be the case that 
for any $h = 0,\cdots, n$, $\txid \notin \{\WTx(\hh(\ke,h))\}$,  from which it follows that $\{\txid\} 
\cap \{\txid_{i}\}_{i=0}^{n} = \emptyset$. By putting these two facts together, we obtain that 
$\T'_{i} \cap \{\txid_{i}\}_{i=0}^{n} = (\T_{i} \cup \{\txid\}) \cap \{\txid_{i}\}_{i=0}^{n} = 
emptyset$. 

\item $\hh'$ satisfies Property \eqref{eq:psi_counter_so}. By assumption, we know 
that $(\hh, \viewFun)$ satisfies properties \eqref{eq:psi_counter_so} and \eqref{eq:psi_counter_view}. 
Let $\txid', \txid''$ be such that $\txid \xrightarrow{\PO} \txid'$. 
Suppose also that $\txid' \in \{\txid_{h}\} \cup \T'_{h}$ for some $h = 0,\cdots, n$. We consider two different cases:
\begin{itemize}
\item $\txid' = \txid_{h}$. Suppose then that $\txid' = \txid_{j}$ for some $j = 0, \cdots, n$. Because 
$\hh$ satisfies Property \eqref{eq:psi_counter_so}, then it must be the case that $h < j$. Otherwise, 
suppose that $\txid'' \in \T'_{j}$ for some $j=0,\cdots,n$. If $j \neq i$, then $\T'_{j} = \T_{j}$, 
and because $\hh$ satisfies Property \eqref{eq:psi_counter_so}, we have that $h \leq j$. 
Otherwise, $\T'_{j} = \T_{j} \cup \{\txid\}$. Without loss of generality, in this case 
we can assume that $\txid'' = \txid$ (we have already shown that if $\txid'' \in \T_{j}$, then 
it must be $h \leq j$. Recall that $j = i = \max(\viewFun(\cl)(\ke))$, and by Definition of 
$\ET_{\UA}$ it must be the case that $\viewFun(\cl) = [\ke \mapsto \{0,\cdots, j\}]$. 
It also follows that $\txid = \txid_{\cl}^{p}$ for some $p \geq 0$, and because $\txid' \xrightarrow{\PO} \txid'' = \txid$, 
then $\txid' = \txid_{\cl}^{q}$ for some $q > 0$. Because $(\hh, \viewFun)$ satisfies Property 
\eqref{eq:psi_counter_view}, and because $\txid' = \txid_{h} = \WTx(\hh(\ke, h))$, then it must be the case that 
$h \leq j$.
\item $\txid' \in \T'_{h}$. We need to distinguish whether $h \neq i$, in which case $\T'_{h} = \T_{h}$, 
or $h = i$, in which case $\T'_{h} = \T_{h} \cup \{\txid\}$. If either $h \neq i$, or $h = i$ and $\txid \in 
\T_{h}$, then we can proceed as in the case $\txid' = \txid_{h}$. Otherwise, suppose that $h = i$ and 
$\txid' = \txid$. Then, because $\txid' \xrightarrow{\PO} \txid''$, and $\txid \in \nextTxId(\hh,\cl)$, 
it must be the case that $\txid = \txid_{\cl}^{p}$ for some $p \geq 0$, and whenever 
$\txid_{\cl}^{q} \in \ke$, then $\txid_{\cl}^{q} \xrightarrow{\PO} \txid$. In particular 
we cannot have that $\txid'' \in \ke$, because $\txid \xrightarrow{\PO} \txid''$, which 
concludes the proof.
\end{itemize}

\item $(\hh', \viewFun')$ satisfies Property \eqref{eq:psi_counter_view}.

\end{itemize}

\end{itemize}
%%It suffices to prove that, given a reduction of the form 
%%\[
%%(\hh, \viewFun) \xrightarrow{(\cl, \mathsf{inc}(\ke))}_{\ET_{\UA} \cap \ET_{\MRd}} (\hh', \viewFun)
%%\]
%%then if $\hh$ has the shape described in \cref{prop:counter_hhshape}, then so has $\hh'$, 
%%and similarly for $\mathsf{read}(\ke)$ operations. In practice, we can show that the result holds for 
%%$\ET$-reductions of the form 
%%\[
%%(\hh, \viewFun) \xrightarrow{(\cl, \mathsf{inc}(\ke))}_{\ET_{\UA}} (\hh', \viewFun)
%%\]
%%and $\ET$-reductions of the form 
%%\[
%%(\hh, \viewFun) \xrightarrow{(\cl, \mathsf{read}(\ke))}_{\ET_{\MRd}} (\hh', \viewFun)
%%\]
%%Proving this second result also requires to place an invariant on $\viewFun(\cl)$, which states 
%%that if $\txid_{\cl}^{n} \in \WTx(\hh) \cup \RTx(\hh)$, then there exists $m \geq n$ such that 
%%$\viewFun(\cl) = \{i \mid i \leq m\}$.
\end{proof}

%\begin{corollary}
%Given $\hh \in \mathsf{KVStores}(\ET_{\UA} \cap \ET_{\MRd} \cap \ET_{\RYW}, \mathsf{Counter})$, 
%then $\graphof(\hh)$ is acyclic.
%\end{corollary}