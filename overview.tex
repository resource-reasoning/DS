\newcommand{\Counter}{\ensuremath{\mathsf{Counter}}}
\newcommand{\ctrinc}{\ensuremath{\mathsf{inc}}}
\newcommand{\ctrread}{\ensuremath{\mathsf{read}}}

\section{Overview}
\label{sec:overview}

Consider a simple counter object, $\mathsf{Counter}(\ke)$, 
defined over a key-value store: 
clients can manipulate the value of key $\ke$ via two operations, 
$\ctrinc(\ke)$ and $\ctrread(\ke)$, defined below:
\[
\begin{array}{r @{\hspace{2pt}} l @{\hspace{20pt}} r @{\hspace{2pt}} l}
\ctrinc(\ke) \eqdef 
&
\begin{session}
\begin{transaction}
\pderef{\pv{x}}{\ke};\\
\pmutate{\ke}{\pv{x}+1}
\end{transaction}
\end{session}
&
\ctrread(\ke) \eqdef &
\begin{session}
\begin{transaction}
\pderef{\pv{x}}{\ke}\\
\end{transaction}
\end{session}
\end{array}
\]
The code of each operation is wrapped in square brackets, denoting that the enclosed code 
must be executed \emph{atomically} as a \emph{transaction}. 
Command \( \pderef{\pv{x}}{\ke} \) reads the value of key \( \ke \) to local variable \( \vx \),
and \( \pmutate{\ke}{\pv{x}+1} \) writes \( \pv{x}+1 \) to key \( \ke \) when the transaction commits.
At first glance, one may think that this implementation is correct; 
in reality, however, correctness depends heavily on implementation details of the key-value store, 
and in particular on the \emph{consistency model} it provides. 

\mypar{Consistency Models}
A well-known consistency model is that of \emph{serialisability}, where transactions appear to execute in a sequential (serial) order, one after another. 
However, implementing serialisability comes at a significant performance cost, 
especially when the key-value store may be distributed across several \emph{replicas} (copies)%
\footnote{Another technique is sharding that a key is hosted in a specific shard.}. 
In such replicated key-value stores, clients run each operation on an arbitrary replica, 
and then propagate the operation effects (if any) to other replicas.
%To overcome the performance cost of serialisability, the database community has turned to \emph{weaker} consistency models. 
In such replicated settings, concurrent calls to counter operations can lead to \emph{weak} behaviours not present under serialisability. 
For instance, consider the program below where the $\cl_1$, $\cl_2$ clients run $\ctrinc(\ke)$ concurrently: 
\begin{align}
	\cl_1: \ctrinc(\ke)
	\;\; || \;\;
	\cl_2: \ctrinc(\ke)
	\tag{\textsc{LU}}
	\label{prog:inc2}
\end{align}
Let us assume that  $\ke$ initially holds value $0$.
Intuitively, since transactions are executed atomically, after both calls to $\ctrinc(\ke)$ have terminated, the counter must hold $2$.
This is indeed the only outcome allowed under serialisability. 
However, when clients execute $\ctrinc(\ke)$ at different replicas, 
if the underlying key-value store provides no synchronisation mechanism, 
both clients may read the same initial value for $\ke$ ($0$) at their distinct replicas and update it to $1$. 
Consequently, propagating the effect of each transaction (\ie the update of $\ke$ to $1$) to the other replica leaves the replicas unchanged. 
As such, once both calls to $\ctrinc(\ke)$ have terminated and their effects have been propagated, 
both replicas hold $1$ for $\ke$, 
%If at Clients performing a 
%$\ctrread(\ke)$ operation will read a final value of $1$ for the counter, 
despite two separate increments on $\ke$. 
This weak behaviour is known as the \emph{lost update} anomaly, allowed under causal consistency but serialisability. 

\mypar{KV-Stores and Views}
The number of replicas in distributed key-value stores may be very high; 
as such, reasoning about client programs interacting with such key-value 
stores may be cumbersome and error-prone. 
To overcome this, we model key-value store as global, centralised entities, and 
we abstract from replication through two mechanisms: \emph{multi-versioning} and \emph{client views}. 
Multi-versioning mandates that we record all versions of each key written, 
together with the meta-data of the transactions that access it. 
This then yields a history of each key, and may be thought as projecting the local state of each replica into a global, centralised state. 
Client views (or simply views) allow different clients to observe only a subset of the versions available in 
the key-value store: this makes it possible for different clients to observe different states 
of the key-value store, thus allowing for weak behaviours such as the lost update anomaly. 

\begin{figure*}[t]
\captionsetup[subfigure]{aboveskip=-5pt, belowskip=5pt}
\begin{tabular}{@{} c | c | c | c@{}}
\hline
\phantom{-}& \phantom{-}& \phantom{-}& \phantom{-}\\
\begin{subfigure}{0.15\textwidth}
\begin{centertikz}
%Location x
\node(locx) {$\ke \mapsto$};

\matrix(versionx) [version list]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ \\
    {a} & $\emptyset$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$0$};
\end{centertikz}\vspace{5pt}%
\caption{Initial state}
\label{fig:counter_kv_initial}
\end{subfigure}
&
\begin{subfigure}{0.22\textwidth}
\begin{centertikz}

%Location x
\node(locx) {$\ke_1 \mapsto$};

\matrix(versionx) [version list, column 2/.style={text width=6mm}, column 4/.style={text width=6mm}]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\txid$\\
    {a} & $\left\{\txid \right\}$ & {a} & $\emptyset$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$0$};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$1$};

\end{centertikz}\vspace{5pt}
\caption{After \(\txid \)}
\label{fig:counter_kv_first_inc}
\end{subfigure}
&
\begin{subfigure}{0.22\textwidth}
\begin{centertikz}

%Location x
\node(locx) {$\ke \mapsto$};

\matrix(versionx) [version list, column 2/.style={text width=6mm}, column 3/.style={dotted}, column 4/.style={text width=6mm,dotted}]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\color{gray}\txid$\\
    {a} & $\left\{\txid \right\}$ & {a} & $\color{gray}\emptyset$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$0$};
\node[version node,fit=(versionx-1-3) (versionx-2-3),fill=white,inner sep=0pt,draw=none] (locx-v1) {\color{gray}$1$};

\end{centertikz}\vspace{5pt}
\caption{View of \( \txid' \)}
\label{fig:counter_kv_view}
\end{subfigure} 
&
\begin{subfigure}{0.30\textwidth}
\begin{centertikz}
\node(locx) {$\ke \mapsto$};
\matrix(versionx) [version list, column 2/.style={text width=10mm}]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\txid$ & {a} & $\txid'$\\
    {a} & $\{\txid, \txid'\}$ & {a} & $\emptyset$ & {a} & $\emptyset$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$0$};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$1$};
\tikzvalue{versionx-1-5}{versionx-2-5}{locx-v2}{$1$};
\end{centertikz}
\vspace{5pt}
\caption{Final state}
\label{fig:counter_kv_final}
\end{subfigure}\\
\hline
\end{tabular}
\caption{Example key-value stores (\subref{fig:counter_kv_initial}, \subref{fig:counter_kv_first_inc}, \subref{fig:counter_kv_final}); a client view (\subref{fig:counter_kv_view})}
\end{figure*}

Let us illustrate how we can produce the lost update anomaly in \eqref{prog:inc2} using our key-value stores. 
The initial key value store comprises a single key $\ke$, with only one 
version denoted as $(0, \txid_{0}, \emptyset)$, stating that $\ke$ holds value $0$, 
that the version \emph{writer} is the initialising transaction $\txid_0$ (this version has been written by $\txid_0$), 
and that the version \emph{reader set} is empty (no transactions have read this version as of yet). 
\Cref{fig:counter_kv_initial} depicts this initial key-value store, with the version
%We represent this key-value store graphically in \cref{fig:counter_kv_initial}. 
%A version is 
represented as a box sub-divided to three sections. 
Proceeding clockwise from the left, these sections represent the version value, writer and reader set, respectively.

Suppose that $\cl_1$ first invokes $\ctrinc$ on \cref{fig:counter_kv_initial}. 
In order to mark the versions that $cl_1$ reads and writes while executing the underlying transaction of $\ctrinc$,  
$\cl_1$ first obtains a unique transaction identifier, $\txid$, 
and then proceeds with $\ctrinc$. 
It then reads the (only) version of $\ke$ (with value $0$), 
and installs a new value $1$ for $\ke$. 
The resulting key-value store is depicted in \cref{fig:counter_kv_first_inc}.
Note that the initial version of $\ke$ is updated to reflect that it has been read by $\txid$; 
moreover, versions are ordered (left to right), from the oldest to the newest.

Next, client $\cl_2$ invokes $\ctrinc$ on \cref{fig:counter_kv_first_inc}. 
As there are now two versions available for $\ke$, 
we need to determine the version from which $\cl_2$ fetches its value, before running $\ctrinc(\ke)$.
This is where \emph{client views} come into play.
Intuitively, a view of client $\cl_2$ comprises those versions in the key-value store that are \emph{visible} to $\cl_2$, 
\ie those whose values can be read by $\cl_2$. 
If more than one version is visible, then the newest (right-most) such version is selected, 
modelling the \emph{last writer wins} resolution policy used by several key-value stores~\cite{\todo}. 
In our example, there are two possible view candidates for $\cl_2$ when running $\ctrinc(\ke)$ on \cref{fig:counter_kv_first_inc}: 
one containing only the initial version of $\ke$, 
another containing both versions of $\ke$.%
\footnote{In fact, if no restrictions on the views are given, there 
are four possible view candidates. 
However, as we explain in \cref{sec:full-semantics}, we always require the view of a client 
to have the initial version of each key marked as visible.}
In the former case, the view is depicted in \cref{fig:counter_kv_view};
running $\ctrinc(\ke)$ on this view reads value $0$ and writes a new version with value $1$, as depicted in \cref{fig:counter_kv_final}.
In the latter case, running $\ctrinc(\ke)$ reads the latest value ($1$) and writes a new version with value $2$.
As before, in the former case the resulting key-value store (\cref{fig:counter_kv_final}) does not contain a version with value $2$, despite two increments on $\ke$, producing the lost update anomaly.

\mypar{Execution Tests}
To avoid the lost update anomaly, distributed key-value stores introduce a check at commit time to ensure that 
at most one of concurrent transactions writing to the same key commits. 
This property is known as \emph{write conflict freedom}. 
In our framework, we can simulate this behaviour by introducing the notion of \emph{execution tests}. 
Intuitively, an execution test determines whether a client with a given view can execute a transaction. 
For example, write-conflict freedom can be enforced by requiring that a client commit a transaction writing to $\ke$ 
only if its view contains all versions available in the global state for such a view. 
In our \eqref{prog:inc2} example, this prevents $\cl_2$ from running $\ctrinc(\ke)$ on \cref{fig:counter_kv_first_inc}
if its view only contains the initial version of $\ke$. 
Instead, the $\cl_2$ view must contain both versions of $\ke$, 
thus enforcing $\cl_2$ to install a version with value $2$ after running $\ctrinc(\ke)$
In \cref{sec:program-analysis}, we prove that if the key-value store 
ensures write-conflict freedom as well as a few other properties, then clients can increment 
and read from a single counter as if the key-value store were (strictly) serialisable.

However, the situation becomes more complicated if the key-value store contains multiple counters. 
In this case, as each client has its own view on the key-value store, and since the views 
of clients are independent from each other, it is possible for two 
clients to observe the increments on two distinct counters, $\Counter(\ke_1)$ and $\Counter(\ke_2)$, in different orders. 
%This scenario cannot be replicated in a strictly serialisable key-value store. 
For instance, consider the following program
\begin{align}
	\begin{array}[t]{@{} r @{\hspace{2pt}} l || r @{\hspace{2pt}} l || r @{\hspace{2pt}} l @{}}
		\cl_0: 
		& \ctrinc(\ke_1) 
		& \cl_1: 
		& \ctrread(\ke_1)
		& \cl_2: 
		& \ctrread(\ke_1)\\
%
		& \ctrinc(\ke_2) 
		&& \ctrread(\ke_2)
		&& \ctrread(\ke_2)
	\end{array}
	\tag{\textsc{LF}}
	\label{prog:LF}
\end{align}
Suppose that $\cl_0$ executes first and increments $\ke_1$, $\ke_2$. 
Both $\ke_1$ and $\ke_2$ then have two versions with values $0$ and $1$. 
Let us assume that the $\cl_1$ view contains both versions of $\ke_1$, but only 
the initial version of $\ke_2$ (value $0$). 
When next client $\cl_1$ executes, it thus reads $1$ for $\ke_1$ and $0$ for $\ke_2$; 
that is, from the point of view of $\cl_1$, the increment of $\ke_1$ 
happens before the increment of $\ke_2$. 
Conversely, let us assume that the $\cl_2$ view contains both versions for $\ke_2$, but only 
the initial version of $\ke_1$ (value $0$). 
As such, when $\cl_2$ executes , it reads $0$ for $\ke_1$ and $1$ for $\ke_2$;
that is, from the point of view of $\cl_2$, the increment of $\ke_2$ 
happens before the increment of $\ke_1$. 
This behaviour is known as the \emph{long fork} anomaly. 

The long fork anomaly is disallowed under strong models \eg serialisability and SI (snapshot isolation), 
but allowed under weak models \eg PSI (parallel SI). 
As such, the execution test for PSI does not need additional constraints/ 
However, to rule out long-fork under strong models such as serialisability and SI, 
we must strengthen the execution test associated with the key-value store.
Informally, as we discuss in \cref{sec:cm}, the candidate execution test recovers the order in which 
updates of versions have been observed by different clients (\eg $\cl_1$), 
and allows a transaction to commit only if the observations made by the committing client (\eg $\cl_2$) 
are consistent with previous clients (\ie $\cl_1$). 
%In \cref{sec:cm} we give an example of such an execution test, that ensures that the underlying key-value 
%store guarantees the (strong session) snapshot isolation consistency model. 
%For example, 
Under this strengthened execution test, in the \eqref{prog:LF} example $\cl_2$ cannot
observe $1$ for $\ke_2$ after observing $0$ for $\ke_1$; 
this is because $\cl_1$ has already established that the increment on $\ke_2$ happens after 
the one of $\ke_1$. 
In \cref{sec:program-analysis}, we prove that if the key-value store consists of multiple counter objects, and the execution test employed by transactions guarantees SI, then the key-value store behaves as is it were strictly serialisable.
%
As we demonstrate in \cref{sec:cm}, using execution tests on key-value stores, we can specify all well-known consistency models (weak or strong) subject to a few basic conditions. 
%
Moreover, in \cref{sec:verify-impl} we encode two implementations, COPS and Clock-SI, to kv-stores and views,
and verify them against our specification using execution tests.


%Suppose that we have an integer valued key-value store. Four different 
%clients from the set $\{\cl_i\}_{i=1}^{4}$ interact with the key-value store by requesting 
%to execute transactions from the set $\{\trans_{i}\}_{i=1}^{4}$, 
%whose code is defined below, respectively:
%
%\sx{
%    Maybe present in the following way, and we can say that
%    we assume the allocated transaction identifiers \( \txid \) are the ones shown in the code.
%    Also clients are like threads etc.
%\[
%\begin{array}{@{} l @{} }
%\begin{array}{@{} c ||  c @{} }
%\begin{session}
%\txid_1 :
%\begin{transaction}
%\pmutate{\ke_{1}}{1}
%\end{transaction} 
%\end{session}
%&
%\begin{session}
%\txid_2 :
%\begin{transaction}
%\pmutate{\ke_2}{1}
%\end{transaction}
%\end{session}
%\end{array} \\[1em]
%\qqqquad \begin{array}{@{} || c || c @{} }
%\txid_3 :
%\begin{session}
%\begin{transaction}
%\pderef{\pv{a}}{\ke_1};
%\quad \pderef{\pv{b}}{\ke_2};\\
%\pifs{\pv{a} = 0 \wedge \pv{b} = 1} \\
%\quad \pmutate{\ke_{3}}{1}
%\pife
%\end{transaction}
%\end{session}
%&
%\txid_4 :
%\begin{session}
%\begin{transaction}
%\pderef{\pv{a}}{\ke_1};
%\quad \pderef{\pv{b}}{\ke_2};\\
%\pifs{\pv{a} = 1 \wedge \pv{b} = 0}  \\
%\quad \pmutate{\ke_{4}}{1}
%\pife
%\end{transaction}
%\end{session}
%\end{array}
%\end{array}
%\]
%}
%\[
%\begin{array}{lrlr}
%\trans_{1} = &
%\begin{session}
%\begin{transaction}
%\pmutate{\ke_{1}}{1}
%\end{transaction}
%\end{session}
%&
%\trans_{2} = &
%\begin{session}
%\begin{transaction}
%\pmutate{\ke_2}{1}
%\end{transaction}
%\end{session}
%\\[5pt]
%\trans_{3} = &
%\begin{session}
%\begin{transaction}
%\pderef{\pv{a}}{\ke_1};\\
%\pderef{\pv{b}}{\ke_2};\\
%\pifs{\pv{a} = 0 \wedge \pv{b} = 1} 
% \pmutate{\ke_{3}}{1}
%\pife
%\end{transaction}
%\end{session}
%&
%\trans_{4} = &
%\begin{session}
%\begin{transaction}
%\pderef{\pv{a}}{\ke_1};\\
%\pderef{\pv{b}}{\ke_2};\\
%\pifs{\pv{a} = 1 \wedge \pv{b} = 0} 
% \pmutate{\ke_{4}}{1}
%\pife
%\end{transaction}
%\end{session}
%\end{array}
%\]
%Here and in the rest of the paper, we use 
%brackets to wrap fragments of code into transactions, 
%which should appear as being executed atomically by the clients of the key-value store. 
%Assume that initially $\ke_{i} = 0$ for $i=1,\cdots,4$.
%The semantics of the set of transactions above 
%depends from the data consistency model guaranteed by the key-value store. 
%For example, if the key-value store is serialisable \cite{papadimitriou}, i.e. 
%transactions are executed according to some serial order $\rightarrow$, 
%then it is impossible to schedule the execution of the transactions $\{\trans_{i}\}_{i=1}^{4}$ 
%as to obtain $\ke_3 = \ke_4 = 1$. 
%If $\ke_3$ is updated to value $1$, then it must be the case that 
%$\trans_3$ has been executed after  $\trans_2$, but before $\trans_1$: 
%$\trans_2 \rightarrow \trans_{3} \rightarrow \trans_1$.
%Similarly, the value of $\ke_4$ is updated 
%to $1$ only if $\trans_4$ 
%is executed after $\trans_1$, 
%but before $\trans_2$: $\trans_{1} \rightarrow \trans{4} \rightarrow \trans_{2}$. 
%Then, when both $\ke_3, \ke_4$ are updated to value $1$, we must have that 
%$\trans_1 \rightarrow \trans_4 \rightarrow \trans_2 \rightarrow \trans_3 
%\rightarrow \trans_1$, thus violating the serialisability requirement imposed by 
%the key-value store. 
%%A similar argument applies even it the key-value stores 
%%is assumed to guarantee \emph{Snapshot Isolation} \cite{ansisql}, a weaker consistency model 
%%provided by several centralised, geo-replicated and distributed databases \cite{ansisql,dias-tm,gsi,clocksi,distrsi}.
%
%However, executing the set of transactions $\{\trans_{i}\}_{i=1}^{4}$ depicted above 
%may lead to both $\ke_3 = 1$ and $\ke_4 = 1$ if a weaker consistency model than 
%serialisability is employed by the key-value store. This is true especially in the case 
%that the key-value store is replicated at several sites, and little to no coordination 
%between replicas is present when clients commit transactions: examples of such geo-replicated 
%datastores are those that provide the \emph{Causal Consistency} model \cite{cops}. 
%For example, transactions $\trans_1$ and $\trans_4$ may be executed sequentially 
%on a replica of the key value store, leading to $\ke_4 = 1$, while transactions 
%$\trans_2$ and $\trans_3$ may be executed sequentially on a different replica, leading to $\ke_3 = 1$. 
%When each replica communicates the state updates to the other, both of them will 
%end up in a state where $\ke_3 = \ke_4 = 1$. 
%
%
%\begin{figure*}[t]
%\begin{center}
%%
%%\hrulefill
%\begin{subfigure}{0.32\textwidth}
%\begin{tikzpicture}
%\begin{pgfonlayer}{foreground}
%%\draw[help lines] grid(5,4);
%
%%Location x
%\node(locx) {$\ke_1 \mapsto$};
%\matrix(versionx) [version list]
%    at ([xshift=\tikzkvspace]locx.east) {
%    {a} & $\txid_0$ \\
%    {a} & $\emptyset$ \\
%};
%\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$0$};
%
%%Location y
%\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_2 \mapsto$};
%\matrix(versiony) [version list]
%   at ([xshift=\tikzkvspace]locy.east) {
% {a} & $\txid_0$\\
%  {a} & $\emptyset$ \\
%};
%\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$0$};
%
%\path (locy.south) + (0,\tikzkeyspace) node (locz) {$\ke_3 \mapsto$};
%\matrix(versionz) [version list]
%   at ([xshift=\tikzkvspace]locz.east) {
% {a} & $\txid_0$\\
%  {a} & $\emptyset$ \\
%};
%\tikzvalue{versionz-1-1}{versionz-2-1}{locz-v0}{$0$};
%
%\path (locz.south) + (0,\tikzkeyspace) node (locm) {$\ke_4 \mapsto$};
%\matrix(versionm) [version list]
%   at ([xshift=\tikzkvspace]locm.east) {
% {a} & $\txid_0$\\
%  {a} & $\emptyset$ \\
%};
%\tikzvalue{versionm-1-1}{versionm-2-1}{locm-v0}{$0$};
%
%\end{pgfonlayer}
%\end{tikzpicture}
%\caption{Key-value store}
%\label{fig:hheap-a}
%\label{fig:key-value-store}
%\label{fig:initial-kv}
%\end{subfigure}
%%
%%
%\begin{subfigure}{0.32\textwidth}
%\begin{tikzpicture}
%\begin{pgfonlayer}{foreground}
%%\draw[help lines] grid(5,4);
%
%%Location x
%\node(locx) {$\ke_1 \mapsto$};
%\matrix(versionx) [version list, column 2/.style={text width=8mm}, column 4/.style={text width=8mm}]
%    at ([xshift=\tikzkvspace]locx.east) {
%        {a} & $\txid_0$   & {a} & $\txid_1$ \\
%        {a} & $\emptyset$ & {a} & $\Set{\txid_{\cl_4}}$\\
%};
%\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$0$};
%\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$1$};
%
%%Location y
%\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_2 \mapsto$};
%\matrix(versiony) [version list, column 2/.style={text width=8mm}]
%   at ([xshift=\tikzkvspace]locy.east) {
% {a} & $\txid_0$\\
%  {a} & $\Set{\txid_{\cl_4}}$ \\
%};
%\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$0$};
%
%\path (locy.south) + (0,\tikzkeyspace) node (locz) {$\ke_3 \mapsto$};
%\matrix(versionz) [version list, column 2/.style={text width=8mm}]
%   at ([xshift=\tikzkvspace]locz.east) {
% {a} & $\txid_0$\\
%  {a} & $\emptyset$ \\
%};
%\tikzvalue{versionz-1-1}{versionz-2-1}{locz-v0}{$0$};
%
%\path (locz.south) + (0,\tikzkeyspace) node (locm) {$\ke_4 \mapsto$};
%\matrix(versionm) [version list, column 2/.style={text width=8mm}, column 4/.style={text width=8mm}]
%   at ([xshift=\tikzkvspace]locm.east) {
%  {a} & $\txid_0$ & {a} & $\txid_{\cl_4}$ \\              
%  {a} & $\emptyset$  & {a} & $\emptyset$\\  
%};
%\tikzvalue{versionm-1-1}{versionm-2-1}{locm-v0}{$0$};
%\tikzvalue{versionm-1-3}{versionm-2-3}{locm-v0}{$1$};
%
%\end{pgfonlayer}
%\end{tikzpicture}
%\caption{\( \txid_4 \)}
%\label{fig:long-fork-t4}
%\end{subfigure}
%%
%%
%%
%\begin{subfigure}{0.32\textwidth}
%\begin{tikzpicture}
%\begin{pgfonlayer}{foreground}
%%\draw[help lines] grid(5,4);
%
%%Location x
%\node(locx) {$\ke_1 \mapsto$};
%\matrix(versionx) [version list, column 2/.style={text width=8mm}, column 4/.style={text width=8mm}]
%    at ([xshift=\tikzkvspace]locx.east) {
%        {a} & $\txid_0$   & {a} & $\txid_1$ \\
%        {a} & $\emptyset$ & {a} & $\Set{\txid_{\cl_4}}$\\
%};
%\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$0$};
%\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$1$};
%
%%Location y
%\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_2 \mapsto$};
%\matrix(versiony) [version list, column 2/.style={text width=8mm}, column 4/.style={text width=8mm}]
%   at ([xshift=\tikzkvspace]locy.east) {
%       {a} & $\txid_0$ & {a} & $\txid_{\cl_2}$ \\
%       {a} & $\Set{\txid_{\cl_4}}$ & {a} & $\emptyset$ \\
%};
%\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$0$};
%\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{$1$};
%
%\path (locy.south) + (0,\tikzkeyspace) node (locz) {$\ke_3 \mapsto$};
%\matrix(versionz) [version list, column 2/.style={text width=8mm}]
%   at ([xshift=\tikzkvspace]locz.east) {
% {a} & $\txid_0$\\
%  {a} & $\emptyset$ \\
%};
%\tikzvalue{versionz-1-1}{versionz-2-1}{locz-v0}{$0$};
%
%\path (locz.south) + (0,\tikzkeyspace) node (locm) {$\ke_4 \mapsto$};
%\matrix(versionm) [version list, column 2/.style={text width=8mm}, column 4/.style={text width=8mm}]
%   at ([xshift=\tikzkvspace]locm.east) {
%  {a} & $\txid_0$ & {a} & $\txid_{\cl_4}$ \\              
%  {a} & $\emptyset$  & {a} & $\emptyset$\\  
%};
%\tikzvalue{versionm-1-1}{versionm-2-1}{locm-v0}{$0$};
%\tikzvalue{versionm-1-3}{versionm-2-3}{locm-v0}{$1$};
%
%\end{pgfonlayer}
%\end{tikzpicture}
%\caption{\( \txid_2 \)}
%\label{fig:long-fork-t2}
%\end{subfigure}
%%
%%
%%
%\begin{subfigure}{0.32\textwidth}
%\begin{tikzpicture}
%\begin{pgfonlayer}{foreground}
%%\draw[help lines] grid(5,4);
%
%%Location x
%\node(locx) {$\ke_1 \mapsto$};
%\matrix(versionx) [version list, column 2/.style={text width=8mm}, column 3/.style={dotted}, column 4/.style={dotted,text width=8mm}]
%    at ([xshift=\tikzkvspace]locx.east) {
%        {a} & $\txid_0$   & {a} & \color{gray}$\txid_1$ \\
%        {a} & $\emptyset$ & {a} & \color{gray}$\Set{\txid_{\cl_4}}$\\
%};
%\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$0$};
%\node[version node,draw=none,fit=(versionx-1-3) (versionx-2-3),fill=white, inner sep=0pt] (locx-v1) {\color{gray}$1$};
%
%%Location y
%\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_2 \mapsto$};
%\matrix(versiony) [version list, column 2/.style={text width=8mm}, column 4/.style={text width=8mm}]
%   at ([xshift=\tikzkvspace]locy.east) {
%       {a} & $\txid_0$ & {a} & $\txid_{\cl_2}$ \\
%       {a} & $\Set{\txid_{\cl_4}}$ & {a} & $\emptyset$ \\
%};
%\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$0$};
%\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{$1$};
%
%\path (locy.south) + (0,\tikzkeyspace) node (locz) {$\ke_3 \mapsto$};
%\matrix(versionz) [version list, column 2/.style={text width=8mm}]
%   at ([xshift=\tikzkvspace]locz.east) {
% {a} & $\txid_0$\\
%  {a} & $\emptyset$ \\
%};
%\tikzvalue{versionz-1-1}{versionz-2-1}{locz-v0}{$0$};
%
%\path (locz.south) + (0,\tikzkeyspace) node (locm) {$\ke_4 \mapsto$};
%\matrix(versionm) [version list, column 2/.style={text width=8mm}, column 3/.style={dotted}, column 4/.style={text width=8mm,dotted}]
%   at ([xshift=\tikzkvspace]locm.east) {
%  {a} & $\txid_0$ & {a} & \color{gray}$\txid_{\cl_4}$ \\              
%  {a} & $\emptyset$  & {a} &  \color{gray}$\emptyset$\\  
%};
%\tikzvalue{versionm-1-1}{versionm-2-1}{locm-v0}{$0$};
%\node[version node,draw=none,fit=(versionm-1-3) (versionm-2-3),fill=white, inner sep=0pt] (locx-v1) {\color{gray}$1$};
%
%\end{pgfonlayer}
%\end{tikzpicture}
%\caption{view of \( \txid_3 \)}
%\label{fig:view-of-cl-prime}
%\label{fig:long-fork-t3-view}
%\end{subfigure}
%%
%%
%%
%%
%\begin{subfigure}{0.32\textwidth}
%\begin{tikzpicture}
%\begin{pgfonlayer}{foreground}
%%\draw[help lines] grid(5,4);
%
%%Location x
%\node(locx) {$\ke_1 \mapsto$};
%\matrix(versionx) [version list, column 2/.style={text width=8mm}, column 4/.style={text width=8mm}]
%    at ([xshift=\tikzkvspace]locx.east) {
%        {a} & $\txid_0$   & {a} & $\txid_1$ \\
%        {a} & $\Set{\txid_{\cl_3}}$ & {a} & $\Set{\txid_{\cl_4}}$\\
%};
%\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$0$};
%\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$1$};
%
%%Location y
%\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_2 \mapsto$};
%\matrix(versiony) [version list, column 2/.style={text width=8mm}, column 4/.style={text width=8mm}]
%   at ([xshift=\tikzkvspace]locy.east) {
%       {a} & $\txid_0$ & {a} & $\txid_{\cl_2}$ \\
%       {a} & $\Set{\txid_{\cl_4}}$ & {a} & $\Set{\txid_{\cl_3}}$ \\
%};
%\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$0$};
%\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{$1$};
%
%\path (locy.south) + (0,\tikzkeyspace) node (locz) {$\ke_3 \mapsto$};
%\matrix(versionz) [version list, column 2/.style={text width=8mm}, column 4/.style={text width=8mm}]
%   at ([xshift=\tikzkvspace]locz.east) {
%       {a} & $\txid_0$ & {a} & $\txid_{\cl_3}$ \\
%       {a} & $\emptyset$ & {a} & $\emptyset$ \\
%};
%\tikzvalue{versionz-1-1}{versionz-2-1}{locz-v0}{$0$};
%\tikzvalue{versionz-1-3}{versionz-2-3}{locz-v1}{$1$};
%
%\path (locz.south) + (0,\tikzkeyspace) node (locm) {$\ke_4 \mapsto$};
%\matrix(versionm) [version list, column 2/.style={text width=8mm}, column 4/.style={text width=8mm}]
%   at ([xshift=\tikzkvspace]locm.east) {
%  {a} & $\txid_0$ & {a} & $\txid_{\cl_4}$ \\              
%  {a} & $\emptyset$  & {a} & $\emptyset$\\  
%};
%\tikzvalue{versionm-1-1}{versionm-2-1}{locm-v0}{$0$};
%\tikzvalue{versionm-1-3}{versionm-2-3}{locm-v0}{$1$};
%
%\end{pgfonlayer}
%\end{tikzpicture}
%\caption{\( \txid_3 \)}
%\label{fig:long-fork-t3}
%\label{fig:cp-disallowed-1}
%\end{subfigure}
%
%\end{center}
%
%\hrulefill
%
%\caption{Multi-version key-value stores and views}
%\label{fig:hheap}
%\label{fig:key-value-and-view}
%\end{figure*}
%
%It has been observed before that reasoning about the behaviour of a replicated data-store at a low level 
%may be excessively complicated, as it requires the knowledge of the state of each 
%replica, as well as understanding the synchronisation protocol among replicas \cite{framework-concur,adya,seebelieve}. 
%\ac{After trying to write this paragraph several time, comparing with the three proposals in the references: 
%do not apologise here about why another framework when there are already other three around. This should 
%be done in introduction and conclusions. Just give the details about how we do stuff.} 
%We propose an approach where we study the semantics to programs in a setting where 
%clients interact with a centralised (i.e. non-replicated, non-distributed), multi-version key value store, 
%using a mechanism that we refer to as \emph{views}: in \cref{fig:view-of-cl} we show that this approach 
%is sufficient to capture the behaviour of programs under several consistency models 
%employed by distributed transactional storage systems.
%
%Let us show how, in our model, it is possible to exhibit a computation of 
%the set of transactions $\{\trans_{i}\}_{i=1}^{4}$ that leads to updating 
%both $\ke_3$ and $\ke_4$ to $1$.
%In our model, when a piece of code corresponding to a transaction executes, 
%it gets assigned a \emph{transaction identifier} $\txid, \txid',\cdots$. 
%As we will see, transaction identifiers 
%embed the information about the client that executes them. 
%The state of the system consists of a mapping from keys to non-empty lists of versions, each 
%of which comprises value and the meta-data of the transaction identifiers 
%that read and wrote such a version. Initially, each key is initialised to a singleton carrying 
%value $0$, written by a special initialisation transaction $\txid_0$ that is not associated 
%with any client. This key-value store is depicted graphically in \cref{fig:key-value-store}. Versions are represented graphically
%as boxes divided in three containers: the leftmost container contains the value of the version, 
%the right-top container contains the identifier of the transaction that wrote the version, 
%and the right-bottom container contains the set of transaction identifiers that read the version. 
%Initially, one of the four clients from $\{\cl_{i}\}_{i=1}^{4}$, say 
%$\cl_1$, executes the transaction $\trans_1$. To do so, the client 
%must first select the portion of state that it observes from the key-value store: 
%specifically, it must select a non-empty sub-list of versions of each key that it observes from 
%the key-value store. The portion of state selected by the client is referred to as its view, 
%and it determines the local state in which the transactional code $\trans_1$ is executed.
%Because there is only one version for each key, each carrying value $0$, 
%the choice of view for $\cl_1$ is compulsory, 
%and it leads to client $\cl_1$ executing the transaction $\trans_1$ in the local state 
%where $\ke_1 = \ke_2 = \ke_3 = \ke_4 = 0$. This transaction gets assigned an identifier 
%that also carries the information about the client that executes the transaction $\txid_{\cl_{1}}^{1}$ 
%(ignore for the moment the superscript $1$). Upon executing $\trans_1$ 
%atomically, a new version carrying value $1$ and written by $\txid_{\cl_{1}}^{1}$ 
%is created for $\ke_1$. 
%
%Next, client $\cl_4$ is scheduled to execute a transaction. As for $\cl_1$, 
%we must select a view for $\cl_4$, which we use to determine the state in which $\trans_4$ 
%is executed. The choice for which versions to observe for $\ke_2, \ke_3, \ke_4$ is compulsory, 
%and it leads to execute $\trans_4$ in a state where $\ke_2 = \ke_3 = \ke_4 = 0$.
%Because we have two versions for $\ke_1$, carrying values $0$ and $1$ respectively, 
%there are three different choices for selecting the view that $\cl_4$ has on $\ke_1$: 
%only the initial version carrying value $0$ is observed, in which case $\trans_4$ executes in 
%a state where $\ke_1 = 0$; or the final version carrying value $1$ is observed, in which 
%case $\trans_4$ executes in a state where $\ke_1 = 1$; orboth versions for 
%$\ke_1$ are observed: because the version of $\ke_1$, carrying value $1$ is more recent than the one 
%carrying value $0$ (i.e. it appears after in the list of versions for $\ke_1$), then $\trans_4$ 
%executes in a state in which $\ke_1 = 1$. This approach models the \emph{Last Write Wins} 
%policy employed by many transactional key-value stores \cite{cassandra,...........}. If we assume that the view 
%of $\trans_4$ comprises both versions for $\ke_1$, then the execution of $\trans_4$ 
%results in reading the only version available for $\ke_2$ (carrying value $0$), the last version available 
%for $\ke_1$, and in the creation of a new version for $\ke_4$ carrying value $1$. If we associate 
%the transaction identifier $\txid_{\cl_{4}}^1$ to the execution of $\trans_4$, the resulting 
%key-value store is the one depicted in \cref{fig:long-fork-t4}.
%
%Next, client $\cl_2$ executes transaction $\trans_2$. Independently from the view that 
%$\cl_2$ chooses to execute this transaction, the outcome will be a new version carrying 
%value $1$ to be installed for value $\ke_1$. The identifier of the transaction installing such 
%a version is given by $\txid_{\cl_2}{1}$. The resulting key-value store is given in \cref{fig:long-fork-t2}. 
%Finally, client $\cl_3$ executes transaction $\trans_3$. Prior to executing a transaction, client 
%$\cl_3$ selects a view of the key-value store where that comprises only the initial version of $\ke_1$, 
%and both versions for $\ke_2$. In \cref{fig:long-fork-t3-view} we show the same key-value store from \cref{fig:long-fork-t2},  
%where we highlight the versions that are included in the view of $\cl_3$. The choice of view for $\cl_3$ 
%mandates that the transaction $\txid_3$ is executed in a state where $\ke_1 = 0, \ke_2 = 1$, which 
%means that a new version carrying value $1$ for $\ke_4$ is installed by the execution of $\trans_3$. 
%If $\txid_{\cl_3}^{1}$ is the transaction identifier associated with the execution of $\trans_3$, then the resulting 
%key value store is given in \cref{fig:long-fork-t3}.
%
%The example above implicitly assumes that the key-value store employs a very weak consistency model, 
%where transactions are always allowed to execute. To express stronger consistency models, 
%we introduce a notion of \emph{execution tests}, which restrict the set of possible scenarios in which 
%a transaction is allowed to execute in a given initial state. For example, the execution test for 
%(strict) serialisability mandates that the only view that a client can select, prior to executing a transaction, 
%is the one that comprises all versions of all keys: this amounts to requiring that the client observes the totality 
%of the state of the key-value store. If we were to replay the example from above using the execution test 
%for serialisability, we would notice that the execution of transaction $\trans_3$ starting from a state 
%where $\ke_1 = 0, \ke_2 = 1$, would not be possible anymore: because at the moment $\trans_3$ is 
%executed the key-value store contains a version carrying value $1$ for $\ke_1$, this version must be 
%included in the view used by $\cl_3$ to determine the state in which $\trans_3$ is executed, leading 
%to $\trans_3$ being executed in a state where $\ke_1 = \ke_2 = 1$. A consequence of this fact is 
%that the execution of $\trans_3$ will not install a new version for $\ke_4$ anymore. Furthermore, 
%if the execution test for serialisability is enforced by the key-value store, there exists no scheduling 
%of the transactions $\{\trans_i\}_{i=1}^{4}$ that leads to installing a version carrying value 
%$1$ for both $\ke_3$ and $\ke_4$.
%
%%\ac{
%%
%%    \sx{Done}
%%    Pictures will need to be drawn: Shale, do you mind doing this? 
%%For each figure I describe the updates that need to be made w.r.t to the previous 
%%Figure.\\
%%First picture: 4 keys $\ke_1, \ke_2, \ke_3, \ke_4$, 
%%all initialised to 0 by $\txid_{0}$ and with no read transactions.\\
%%Second picture: a version with value $1$, written by $\txid_{\cl^{1}}^1$ 
%%and read by no transaction, is inserted for $\ke_1$. Second picture: $\txid_4$.
%%reads value $1$ for $\ke_1$, value $0$ for $\ke_2$, and writes value $1$ for $\ke_4$. 
%%Third picture: transaction $\txid_{\cl_2}^{1}$ writes value $1$ for $\ke_2$. 
%%Fourth picture: same as the third picture, but the version with value $1$ of $\ke_1$ 
%%should be dotted (as to represent the view of $\txid_{\cl_3}^{3}$. \\
%%Fifth picture: $\txid_{\cl_3}^{1}$ reads value $1$ for $\ke_2$, value $0$ for $\ke_1$, 
%%and updates $\ke_4$ to $1$.}
%
%
%%\input{\RootPath/logic/long-fork-proof.tex}
%
%%We build a programming logic based on the multi-version key-value stores and views.
%%The syntax is close to concurrent-abstract-predicate (CAP) \cite{cap}, 
%%we generalise the meaning of the assertions and the \emph{atomic update rule}.
%%\cref{fig:long-fork-proof} is the sketch proof for the long fork.
%
%%The transactional assertions are normal separation assertions with read (\(\otR\)) and write (\(\otW\)) labels.
%%There are four forms of transactional assertions for a key:
%%\( \ke \fpI 1 \), \( \ke \fpR 1\), \( \ke \fpW 1 \) means that the current state of the key \( \ke \) 
%%in the local snapshot is 1 and it has no operation, has been read with value 1 or has been overwritten to value 1;
%%\( \ke \fpRW (1,2) \) means the state of the key is 2 and 
%%the first read before write fetched 1 and then has been overwritten to 2.
%%The rules for reasoning the transaction are extension of standard sequential separation logic rules by 
%%adding read label to the assertion when reading from keys and write label when writing to keys.
%
%%The assertions in the form \( \boxass{\bar{\lpre}}{\lrid}{\intass}\) 
%%are \emph{shared region assertions}, which describe the local views on the shared key-value stores.
%%Each share region has a unique region identifier \( \lrid \) and a interference \( \intass \)
%%that specifies what operations are allowed to commit, 
%%together with some transformation of \emph{capabilities}, ghost resources for reasoning purpose.
%%For example, \( \CB{L1}  :  \ke_1 \fpW 1 \sep \null \fpA \cass{\CB{L1}}{\lrid} \) in \cref{fig:long-fork-proof} 
%%means if a client holds \( \CB{L1} \), it is allowed to commit a transaction with fingerprint \(  \ke_1 \fpW 1 \),
%%and afterwards by \( \null \fpA \cass{\CB{L1}}{\lrid}\) the capability \( \CB{L1} \) should return to the shared region.
%%The interference \( \intass \)  induces a invariant of the region that 
%%includes all states reachable from the initial states shown in \cref{fig:initial-kv}.
%%This means, even though the assertions describe the local views, but they also provide information about possible key-value store
%%if taking the invariant into account.
%
%%The notation of stable assertions is generalised: if assertions are stable under a consistency model,  
%%then the assertions are close under the portion of invariant where each step satisfies the consistency model.
%%The \emph{update atomic rule} is similar to the one from CAP.
%%We generalise the repartitioning \( \repartition[]{\gpre}{\gpost}{\lpre}{\lpost}\):
%%for any initial view and key-value stores satisfying the precondition \( \gpre \),
%%any final view and key-value stores that are yielded by committing the fingerprints satisfying \( \gpost \) under the consistency model, should satisfy the postcondition \( \lpost \).
%
%
%%\sx{
%%    \begin{itemize}
%%        \item long-fork example
%%        \item Multi-version Key-value, View.
%%        \item how does the semantics work on long fork example
%%        \item a sketch proof for long fork 
%%    \end{itemize}
%%}
%%
%%
%%\begin{wrapfigure}[7]{r}{0.33\textwidth}
%%\vspace{-10pt}
%%\begin{verbatim}
%%interface Transaction {
%%    Start(); 
%%    Read(Key k);
%%    Write(Key k, Value v); 
%%    Commit();    }
%%\end{verbatim}
%%\vspace{-10pt}
%%\caption{Example of Transaction API.}
%%\label{fig:api}
%%\end{wrapfigure}
%%We focus on an abstract computational model where multiple client programs can access and update keys in a key-value store using atomic transactions. 
%%In general, clients are provided with a simple \textit{API} such as the one depicted in \cref{fig:api} \cite{gdur,physicsnmsi,clockSI}\footnote{It is 
%%often the case that key-value stores provide a mechanism to wrap more transactions inside a session, and give 
%%provide appropriate APIs to handle sessions. For the sake of simplicity, in this paper we assume that each client executes transactions 
%%within a single session.}, while both the implementation details and the system architecture are hidden from clients. 
%%Because (distributed) key-value stores only give weak consistency guarantees of the data to their clients, the latter are 
%%not ensured to read the most up-to-date version of a key.
%%%In an ideal world, when executing a transaction clients would read the most up-to-date version of a key. In a distributed setting 
%%%this approach, known as (strict) serialisability, would require a continuous synchronisation between the different components of 
%%%the system, which impacts performance and limits scalability. To this end, the database only provides weak consistency model
%%%\ac{This sentence should probably be in the introduction.}
%%
%%Following these intuitions, we model a key-value stores, or \emph{kv-store}, as a centralised unit where multiple versions 
%%are stored for each key (\cref{sec:mkvs-view}). Versions consist of a value and the meta-data of the transactions that wrote and 
%%read such a version. In practical, distributed systems, the meta-data is usually encoded using either timestamps 
%%\cite{physicsnmsi,clockSI} or vector clocks \cite{gdur}. We focus on key-value stores whose transactions 
%%enjoy \emph{atomic visibility}, meaning that \textbf{(i)} transactions read their data from an atomic 
%%snapshot of the key-value store, and \textbf{(ii)} a transaction can observe either none or all 
%%of the updates performed by another transaction. In other words, a transaction only reads (writes) at most 
%%one version for each key.
%%Because clients may observe potentially out-of-date versions of the system, we introduce the notion of \emph{views}. 
%%Intuitively, a view records the version of each key that a client observes at a given time. We use views 
%%to determine the snapshot taken by transactions executed by clients.
%%
%%A consistency model is a contract between the key-value store and its clients. We distinguish 
%%between \emph{client-centric} consistency models \cite{terry1994session}, 
%%which impose constraints on the observations and updates made by a single client, 
%%and \emph{data-centric} consistency models \cite{framework-concur}, which impose constraints 
%%on the structure of the key value store.
%%To specify weak consistency models, 
%%we introduce the notion of \emph{execution tests} (\cref{sec:execution.tests}). An execution test
%% specifies when a client is allowed to execute a transaction carrying a given 
%%set of read and write operations, or \emph{fingerprint}. Therefore, an execution 
%%test constrains how the state of the key-value store may evolve;
%%by considering all the possible evolutions of the key-value store under said execution test, 
%%we determine a consistency model. For example, an execution test for (strict) serialisability 
%%requires that a transaction can be executed by a client only if it observes the most up-to-date 
%%version for each key. 
%%We give several examples of execution tests that capture both client-centric and 
%%data-centric consistency models. 
%%
%%The idea of specifying consistency models using execution tests has been 
%%already proposed in \cite{seebelieve}; however, their notion of execution 
%%test is intrinsically more complex than ours: to determine 
%%whether a transaction can commit, the total order in which all past transactions 
%%have committed must be known. This knowledge is not needed in our setting.
%%
%%
%%\begin{figure}[t]
%%\begin{center}
%%
%%\hrulefill
%%
%%\begin{onethirdsubfig}
%%\begin{tikzpicture}
%%\begin{pgfonlayer}{foreground}
%%%\draw[help lines] grid(5,4);
%%
%%%Location x
%%\node(locx) {$\ke_1 \mapsto$};
%%
%%\matrix(versionx) [version list, column 2/.style={text width=8mm}]
%%    at ([xshift=\tikzkvspace]locx.east) {
%%    {a} & $\txid_0$ & {a} & $\txid_{\cl}^{1}$\\
%%    {a} & $\left\{\txid_{\cl'}^{1}\right\}$ & {a} & $\emptyset$ \\
%%};
%%\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$v_0$};
%%\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$v_1$};
%%
%%%Location y
%%\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_2 \mapsto$};
%%\matrix(versiony) [version list, column 2/.style={text width=8mm}]
%%   at ([xshift=\tikzkvspace]locy.east) {
%% {a} & $\txid_0$ & {a} & $\txid_{\cl'}^{1}$ \\
%%  {a} & $\left\{\txid_{\cl}^1\right\}$ & {a} & $\emptyset$\\
%%};
%%
%%\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$v'_0$};
%%\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{$v'_1$};
%%
%%% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%%%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);
%%
%%%%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
%%%\draw[-, blue, very thick, rounded corners=10pt]
%% %([xshift=-3pt, yshift=20pt]locx-v1.north east) node (tid1start) {} -- 
%% %([xshift=-3pt, yshift=-5pt]locx-v1.south east) --
%% %([xshift=-3pt, yshift=5pt]locy-v0.north east) -- 
%% %([xshift=-3pt, yshift=-5pt]locy-v0.south east);
%% 
%% %\path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\client$};
%%
%%%%red view
%%%\draw[-, red, very thick, rounded corners = 10pt]
%% %([xshift=-16pt, yshift=5pt]locx-v1.north east) node (tid2start) {}-- 
%% %([xshift=-16pt, yshift=-5pt]locy-v1.south east) node {};
%% 
%%%\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\client'$};
%%
%%\end{pgfonlayer}
%%\end{tikzpicture}
%%\caption{A key-value store $\hh$}
%%\label{fig:hheap-a}
%%\label{fig:key-value-store}
%%\label{fig:ser-disallowed}
%%\end{onethirdsubfig}
%%%
%%\begin{onethirdsubfig}
%%\begin{tikzpicture}
%%\begin{pgfonlayer}{foreground}
%%%\draw[help lines] grid(5,4);
%%
%%%Location x
%%\node(locx) {$\ke_1 \mapsto$};
%%
%%\matrix(versionx) [version list, column 2/.style={text width=8mm}]
%%    at ([xshift=\tikzkvspace]locx.east) {
%%    {a} & $\txid_0$ & {a} & $\txid_{\cl}^{1}$\\
%%    {a} & $\left\{\txid_{\cl'}^{1}\right\}$ & {a} & $\emptyset$ \\
%%};
%%\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$v_0$};
%%\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$v_1$};
%%
%%%Location y
%%\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_2 \mapsto$};
%%\matrix(versiony) [version list, column 2/.style={text width=8mm}, column 3/.style={dotted}, column 4/.style={dotted}]
%%   at ([xshift=\tikzkvspace]locy.east) {
%%       {a} & $\txid_0$ & {a} & \color{gray}$\txid_{\cl'}^{1}$ \\
%%  {a} & $\left\{\txid_{\cl}^1\right\}$ & {a} & \color{gray}$\emptyset$\\
%%};
%%
%%\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$v'_0$};
%%\node[version node,draw=none,fit=(versiony-1-3) (versiony-2-3),fill=white, inner sep=0pt] (locy-v1) {\color{gray}$v'_1$};
%%
%%\end{pgfonlayer}
%%\end{tikzpicture}
%%\caption{A view for client \( \cl \)}
%%\label{fig:view-of-cl}
%%\end{onethirdsubfig}
%%%
%%\begin{onethirdsubfig}
%%\begin{tikzpicture}
%%\begin{pgfonlayer}{foreground}
%%%\draw[help lines] grid(5,4);
%%
%%%Location x
%%\node(locx) {$\ke_1 \mapsto$};
%%
%%\matrix(versionx) [version list, column 2/.style={text width=8mm}, column 3/.style={dotted}, column 4/.style={dotted}]
%%    at ([xshift=\tikzkvspace]locx.east) {
%%    {a} & $\txid_0$ & {a} & \color{gray}$\txid_{\cl}^{1}$\\
%%    {a} & $\left\{\txid_{\cl'}^{1}\right\}$ & {a} & \color{gray}$\emptyset$ \\
%%};
%%\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$v_0$};
%%\node[version node,draw=none,fit=(versionx-1-3) (versionx-2-3),fill=white, inner sep=0pt] (locx-v1) {\color{gray}$v_1$};
%%
%%%Location y
%%\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_2 \mapsto$};
%%\matrix(versiony) [version list, column 2/.style={text width=8mm}]
%%   at ([xshift=\tikzkvspace]locy.east) {
%% {a} & $\txid_0$ & {a} & $\txid_{\cl'}^{1}$ \\
%%  {a} & $\left\{\txid_{\cl}^1\right\}$ & {a} & $\emptyset$\\
%%};
%%
%%\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$v'_0$};
%%\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{$v'_1$};
%%
%%\end{pgfonlayer}
%%\end{tikzpicture}
%%\caption{A view for client \( \cl' \)}
%%\label{fig:view-of-cl-prime}
%%\end{onethirdsubfig}
%%
%%\end{center}
%%
%%\hrulefill
%%
%%\caption{Multi-version key-value stores and views}
%%\label{fig:hheap}
%%\label{fig:key-value-and-view}
%%\end{figure}
%%\ac{
%%It will be often convenient to depict key-value stores graphically: an 
%%example is given by the kv-store $\hh$ depicted in \cref{fig:hheap-a}
%%(ignore for the moment the vertical lines labelled $\client$ and $\client'$).
%%It comprises two keys \( \ke_1\) and \( \ke_2 \), 
%%each of which is associated with two versions carrying values $\val_0$ and $\val_1$, and $\val'_0$ and $\val'_1$, respectively.
%%The versions of a key are listed in order from left to right. 
%%We represent each version as a three-cell box, with the left cell storing the value, the top right cell recording the writer, and the bottom right cell recording the readers. 
%%For example, the version carrying value $\val_0$ in $\ke_1$ has been written by $\txid_0$, and has been read by $\txid_{\cl'}^1$.
%%}
%%
%%%the author require 
%%%the knowledge of the total order in which all past transactions have been 
%%%executed, to determine whether a new transaction can commit.
%%
%%%%\ac{Can't cite documentations of real databases, as they usually have a much more complicated API.}
%%%
%%%%Transactions in our model execute atomically, though they have different effects on the key-value stores depending on their associated \emph{consistency model}.
%%%%A consistency model controls how the key-value store evolves.
%%%%A common model is \emph{serialisability}, where transactions appear to execute one after another in a sequential order.
%%%%This notion of sequential execution is however not necessary for many weaker models. As such, upon commencing execution, a transaction may not observe the most up-to-date values for keys. 
%%%
%%%To address this, we 
%%%first model 
%%%the state of the system using \emph{multi-version key-value stores (MKVSs)} (\cref{sec:mkvs-view}). 
%%%An MKVS keeps track of all versions (values) written for keys, as well as the information about the transactions that read and wrote such versions. 
%%%To model the potential out-of-date observation, we introduce \emph{views}.
%%%A view decides the observable versions of keys for a client.
%%%Therefore, in order to execute a transaction, the client first takes \emph{a snapshot} of the system with the view, executes the transaction locally with respect to its snapshot (\cref{sec:trans-semantics}), and afterwards commits the effect of the transaction if the change is allowed by the underlying consistency model (\cref{sec:prog-semantics}).
%%
%%
%%%We first introduce MKVSs and views (\secref{sec:mkvs-view}) and.
%%%We starts with the syntax of programs followed by the semantics of transaction.
%%%Finally, we will give the semantics for the entire programs.
%\begin{figure}[t]
%
%\hrulefill
%
%\begin{subfigure}{0.38\textwidth}
%\begin{verbatim}
%interface Transaction {
%    Start(); 
%    Read(Key k);
%    Write(Key k, Value v); 
%    Commit();    
%}
%\end{verbatim}
%\caption{Example of Transaction API.}
%\label{fig:api}
%\end{subfigure}
%
%\hrulefill
%
%\end{figure}
%%
%%We focus on an abstract computational model where multiple client programs can access and update keys in a key-value store using atomic transactions. 
%%In general, clients are provided with a simple \textit{API} such as the one depicted in \cref{fig:api} \cite{gdur,physicsnmsi,clockSI}\footnote{It is 
%%often the case that key-value stores provide a mechanism to wrap more transactions inside a session, and give 
%%provide appropriate APIs to handle sessions. For the sake of simplicity, in this paper we assume that each client executes transactions 
%%within a single session.}, while both the implementation details and the system architecture are hidden from clients. 
%%Because (distributed) key-value stores only give weak consistency guarantees of the data to their clients, the latter are 
%%not ensured to read the most up-to-date version of a key.
%%%In an ideal world, when executing a transaction clients would read the most up-to-date version of a key. In a distributed setting 
%%%this approach, known as (strict) serialisability, would require a continuous synchronisation between the different components of 
%%%the system, which impacts performance and limits scalability. To this end, the database only provides weak consistency model
%%%\ac{This sentence should probably be in the introduction.}
%%
%%Following these intuitions, we model a key-value stores, or \emph{kv-store}, as a centralised unit where multiple versions 
%%are stored for each key (\cref{sec:mkvs-view}). Versions consist of a value and the meta-data of the transactions that wrote and 
%%read such a version. In practical, distributed systems, the meta-data is usually encoded using either timestamps 
%%\cite{physicsnmsi,clockSI} or vector clocks \cite{gdur}. We focus on key-value stores whose transactions 
%%enjoy \emph{atomic visibility}, meaning that \textbf{(i)} transactions read their data from an atomic 
%%snapshot of the key-value store, and \textbf{(ii)} a transaction can observe either none or all 
%%of the updates performed by another transaction. In other words, a transaction only reads (writes) at most 
%%one version for each key.
%%Because clients may observe potentially out-of-date versions of the system, we introduce the notion of \emph{views}. 
%%Intuitively, a view records the version of each key that a client observes at a given time. We use views 
%%to determine the snapshot taken by transactions executed by clients.
%%
%%A consistency model is a contract between the key-value store and its clients. We distinguish 
%%between \emph{client-centric} consistency models \cite{terry1994session}, 
%%which impose constraints on the observations and updates made by a single client, 
%%and \emph{data-centric} consistency models \cite{framework-concur}, which impose constraints 
%%on the structure of the key value store.
%%To specify weak consistency models, 
%%we introduce the notion of \emph{execution tests} (\cref{sec:execution.tests}). An execution test
%% specifies when a client is allowed to execute a transaction carrying a given 
%%set of read and write operations, or \emph{fingerprint}. Therefore, an execution 
%%test constrains how the state of the key-value store may evolve;
%%by considering all the possible evolutions of the key-value store under said execution test, 
%%we determine a consistency model. For example, an execution test for (strict) serialisability 
%%requires that a transaction can be executed by a client only if it observes the most up-to-date 
%%version for each key. 
%%We give several examples of execution tests that capture both client-centric and 
%%data-centric consistency models. 
%%
%%The idea of specifying consistency models using execution tests has been 
%%already proposed in \cite{seebelieve}; however, their notion of execution 
%%test is intrinsically more complex than ours: to determine 
%%whether a transaction can commit, the total order in which all past transactions 
%%have committed must be known. This knowledge is not needed in our setting.
%%
%%
%%\begin{figure}[t]
%%\begin{center}
%%
%%\hrulefill
%%
%%\begin{onethirdsubfig}
%%\begin{tikzpicture}
%%\begin{pgfonlayer}{foreground}
%%%\draw[help lines] grid(5,4);
%%
%%%Location x
%%\node(locx) {$\vx \mapsto$};
%%
%%\matrix(versionx) [version list, column 2/.style={text width=8mm}]
%%    at ([xshift=\tikzkvspace]locx.east) {
%%    {a} & $\txid_0$ & {a} & $\txid_{\cl}^{1}$\\
%%    {a} & $\emptyset$ & {a} & $\emptyset$ \\
%%};
%%\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$v_0$};
%%\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$v_1$};
%%
%%%Location y
%%\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\vy \mapsto$};
%%\matrix(versiony) [version list, column 2/.style={text width=8mm}]
%%   at ([xshift=\tikzkvspace]locy.east) {
%% {a} & $\txid_0$ & {a} & $\txid_{\cl'}^{1}$ \\
%% {a} & $\Set{\txid_{\cl}^{2}}$ & {a} & $\emptyset$\\
%%};
%%
%%\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$v'_0$};
%%\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{$v'_1$};
%%
%%% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%%%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);
%%
%%%%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
%%%\draw[-, blue, very thick, rounded corners=10pt]
%% %([xshift=-3pt, yshift=20pt]locx-v1.north east) node (tid1start) {} -- 
%% %([xshift=-3pt, yshift=-5pt]locx-v1.south east) --
%% %([xshift=-3pt, yshift=5pt]locy-v0.north east) -- 
%% %([xshift=-3pt, yshift=-5pt]locy-v0.south east);
%% 
%% %\path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\client$};
%%
%%%%red view
%%%\draw[-, red, very thick, rounded corners = 10pt]
%% %([xshift=-16pt, yshift=5pt]locx-v1.north east) node (tid2start) {}-- 
%% %([xshift=-16pt, yshift=-5pt]locy-v1.south east) node {};
%% 
%%%\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\client'$};
%%
%%\end{pgfonlayer}
%%\end{tikzpicture}
%%\caption{A key-value store $\hh$}
%%\label{fig:hheap-a}
%%\label{fig:key-value-store}
%%\label{fig:ser-disallowed}
%%\end{onethirdsubfig}
%%%
%%\begin{onethirdsubfig}
%%\begin{tikzpicture}
%%\begin{pgfonlayer}{foreground}
%%%\draw[help lines] grid(5,4);
%%
%%%Location x
%%\node(locx) {$\vx \mapsto$};
%%
%%\matrix(versionx) [version list, column 2/.style={text width=8mm}]
%%    at ([xshift=\tikzkvspace]locx.east) {
%%    {a} & $\txid_0$ & {a} & $\txid_{\cl}^{1}$\\
%%    {a} & $\emptyset$ & {a} & $\emptyset$ \\
%%};
%%\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$v_0$};
%%\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$v_1$};
%%
%%%Location y
%%\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\vy \mapsto$};
%%\matrix(versiony) [version list, column 2/.style={text width=8mm}, column 3/.style={dotted}, column 4/.style={dotted}]
%%   at ([xshift=\tikzkvspace]locy.east) {
%%       {a} & $\txid_0$ & {a} & \color{gray}$\txid_{\cl'}^{1}$ \\
%%   {a} & $\Set{\txid_{\cl}^{2}}$ & {a} & \color{gray}$\emptyset$\\
%%};
%%
%%\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$v'_0$};
%%\node[version node,draw=none,fit=(versiony-1-3) (versiony-2-3),fill=white, inner sep=0pt] (locy-v1) {\color{gray}$v'_1$};
%%
%%\end{pgfonlayer}
%%\end{tikzpicture}
%%\caption{A view for client \( \cl \)}
%%\label{fig:view-of-cl}
%%\end{onethirdsubfig}
%%%
%%\begin{onethirdsubfig}
%%\begin{tikzpicture}
%%\begin{pgfonlayer}{foreground}
%%%\draw[help lines] grid(5,4);
%%
%%%Location x
%%\node(locx) {$\vx \mapsto$};
%%
%%\matrix(versionx) [version list, column 2/.style={text width=8mm}, column 3/.style={dotted}, column 4/.style={dotted}]
%%    at ([xshift=\tikzkvspace]locx.east) {
%%    {a} & $\txid_0$ & {a} & \color{gray}$\txid_{\cl}^{1}$\\
%%    {a} & $\emptyset$ & {a} & \color{gray}$\emptyset$ \\
%%};
%%\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$v_0$};
%%\node[version node,draw=none,fit=(versionx-1-3) (versionx-2-3),fill=white, inner sep=0pt] (locx-v1) {\color{gray}$v_1$};
%%
%%%Location y
%%\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\vy \mapsto$};
%%\matrix(versiony) [version list, column 2/.style={text width=8mm}]
%%   at ([xshift=\tikzkvspace]locy.east) {
%%  {a} & $\txid_0$ & {a} & $\txid_{\cl'}^{1}$ \\
%%  {a} & $\left\{\txid_{\cl}^2\right\}$ & {a} & $\emptyset$\\
%%};
%%
%%\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$v'_0$};
%%\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{$v'_1$};
%%
%%\end{pgfonlayer}
%%\end{tikzpicture}
%%\caption{A view for client \( \cl' \)}
%%\label{fig:view-of-cl-prime}
%%\end{onethirdsubfig}
%%
%%\sx{The key-value store corresponds to the last step of long fork.}
%%\end{center}
%%
%%\hrulefill
%%
%%\caption{Multi-version key-value stores and views}
%%\label{fig:hheap}
%%\label{fig:key-value-store-and-view}
%%\label{fig:key-value-and-view}
%%\end{figure}
%%\ac{
%%It will be often convenient to depict key-value stores graphically: an 
%%example is given by the kv-store $\hh$ depicted in \cref{fig:hheap-a}
%%(ignore for the moment the vertical lines labelled $\client$ and $\client'$).
%%It comprises two keys \( \ke_1\) and \( \ke_2 \), 
%%each of which is associated with two versions carrying values $\val_0$ and $\val_1$, and $\val'_0$ and $\val'_1$, respectively.
%%The versions of a key are listed in order from left to right. 
%%We represent each version as a three-cell box, with the left cell storing the value, the top right cell recording the writer, and the bottom right cell recording the readers. 
%%For example, the version carrying value $\val_0$ in $\ke_1$ has been written by $\txid_0$, and has been read by $\txid_{\cl'}^1$.
%%}
%%
%%%the author require 
%%%the knowledge of the total order in which all past transactions have been 
%%%executed, to determine whether a new transaction can commit.
%%
%%%%\ac{Can't cite documentations of real databases, as they usually have a much more complicated API.}
%%%
%%%%Transactions in our model execute atomically, though they have different effects on the key-value stores depending on their associated \emph{consistency model}.
%%%%A consistency model controls how the key-value store evolves.
%%%%A common model is \emph{serialisability}, where transactions appear to execute one after another in a sequential order.
%%%%This notion of sequential execution is however not necessary for many weaker models. As such, upon commencing execution, a transaction may not observe the most up-to-date values for keys. 
%%%
%%%To address this, we 
%%%first model 
%%%the state of the system using \emph{multi-version key-value stores (MKVSs)} (\cref{sec:mkvs-view}). 
%%%An MKVS keeps track of all versions (values) written for keys, as well as the information about the transactions that read and wrote such versions. 
%%%To model the potential out-of-date observation, we introduce \emph{views}.
%%%A view decides the observable versions of keys for a client.
%%%Therefore, in order to execute a transaction, the client first takes \emph{a snapshot} of the system with the view, executes the transaction locally with respect to its snapshot (\cref{sec:trans-semantics}), and afterwards commits the effect of the transaction if the change is allowed by the underlying consistency model (\cref{sec:prog-semantics}).
%%
%%
%%%We first introduce MKVSs and views (\secref{sec:mkvs-view}) and.
%%%We starts with the syntax of programs followed by the semantics of transaction.
%%%Finally, we will give the semantics for the entire programs.f
