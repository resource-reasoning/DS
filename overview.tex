\section{Overview}
\label{sec:overview}

Suppose that we have an integer valued key-value store. Four different 
clients from the set $\{\cl_i\}_{i=1}^{4}$ interact with the key-value store by requesting 
to execute transactions from the set $\{\trans_{i}\}_{i=1}^{4}$, 
whose code is defined below, respectively:
\[
\begin{array}{lrlr}
\trans_{1} = &
\begin{session}
\begin{transaction}
\pmutate{\ke_{1}}{1}
\end{transaction}
\end{session}
&
\trans_{2} = &
\begin{session}
\begin{transaction}
\pmutate{\ke_2}{1}
\end{transaction}
\end{session}
\\[5pt]
\trans_{3} = &
\begin{session}
\begin{transaction}
\pderef{\pv{a}}{\ke_1};\\
\pderef{\pv{b}}{\ke_2};\\
\pifs{\pv{a} = 0 \wedge \pv{b} = 1} 
 \pmutate{\ke_{3}}{1}
\pife
\end{transaction}
\end{session}
&
\trans_{4} = &
\begin{session}
\begin{transaction}
\pderef{\pv{a}}{\ke_1};\\
\pderef{\pv{b}}{\ke_2};\\
\pifs{\pv{a} = 1 \wedge \pv{b} = 0} 
 \pmutate{\ke_{4}}{1}
\pife
\end{transaction}
\end{session}
\end{array}
\]
Here and in the rest of the paper, we use 
brackets to wrap fragments of code into transactions, 
which should appear as being executed atomically by the clients of the key-value store. 
Assume that initially $\ke_{i} = 0$ for $i=1,\cdots,4$.
The semantics of the set of transactions above 
depends from the data consistency model guaranteed by the key-value store. 
For example, if the key-value store is serialisable \cite{papadimitriou}, i.e. 
transactions are executed according to some serial order $\rightarrow$, 
then it is impossible to schedule the execution of the transactions $\{\trans_{i}\}_{i=1}^{4}$ 
as to obtain $\ke_3 = \ke_4 = 1$. 
If $\ke_3$ is updated to value $1$, then it must be the case that 
$\trans_3$ has been executed after  $\trans_2$, but before $\trans_1$: 
$\trans_2 \rightarrow \trans_{3} \rightarrow \trans_1$.
Similarly, the value of $\ke_4$ is updated 
to $1$ only if $\trans_4$ 
is executed after $\trans_1$, 
but before $\trans_2$: $\trans_{1} \rightarrow \trans{4} \rightarrow \trans_{2}$. 
Then, when both $\ke_3, \ke_4$ are updated to value $1$, we must have that 
$\trans_1 \rightarrow \trans_4 \rightarrow \trans_2 \rightarrow \trans_3 
\rightarrow \trans_1$, thus violating the serialisability requirement imposed by 
the key-value store. 
%A similar argument applies even it the key-value stores 
%is assumed to guarantee \emph{Snapshot Isolation} \cite{ansisql}, a weaker consistency model 
%provided by several centralised, geo-replicated and distributed databases \cite{ansisql,dias-tm,gsi,clocksi,distrsi}.

However, executing the set of transactions $\{\trans_{i}\}_{i=1}^{4}$ depicted above 
may lead to both $\ke_3 = 1$ and $\ke_4 = 1$ if a weaker consistency model than 
serialisability is employed by the key-value store. This is true especially in the case 
that the key-value store is replicated at several sites, and little to no coordination 
between replicas is present when clients commit transactions: examples of such geo-replicated 
datastores are those that provide the \emph{Causal Consistency} model \cite{cops}. 
For example, transactions $\trans_1$ and $\trans_4$ may be executed sequentially 
on a replica of the key value store, leading to $\ke_4 = 1$, while transactions 
$\trans_2$ and $\trans_3$ may be executed sequentially on a different replica, leading to $\ke_3 = 1$. 
When each replica communicates the state updates to the other, both of them will 
end up in a state where $\ke_3 = \ke_4 = 1$. 

It has been observed before that reasoning about the behaviour of a replicated data-store at a low level 
may be excessively complicated, as it requires the knowledge of the state of each 
replica, as well as understanding the synchronisation protocol among replicas \cite{framework-concur,adya,seebelieve}. 
\ac{After trying to write this paragraph several time, comparing with the three proposals in the references: 
do not apologise here about why another framework when there are already other three around. This should 
be done in introduction and conclusions. Just give the details about how we do stuff.} 
We propose an approach where we study the semantics to programs in a setting where 
clients interact with a centralised (i.e. non-replicated, non-distributed), multi-versioned key value store, 
using a mechanism that we refer to as \emph{views}: in \cref{} we show that this approach 
is sufficient to capture the behaviour of programs under several consistency models 
employed by distributed transactional storage systems.


%\sx{
%    \begin{itemize}
%        \item long-fork example
%        \item Multi-version Key-value, View.
%        \item how does the semantics work on long fork example
%        \item a sketch proof for long fork 
%    \end{itemize}
%}
%
%
%\begin{wrapfigure}[7]{r}{0.33\textwidth}
%\vspace{-10pt}
%\begin{verbatim}
%interface Transaction {
%    Start(); 
%    Read(Key k);
%    Write(Key k, Value v); 
%    Commit();    }
%\end{verbatim}
%\vspace{-10pt}
%\caption{Example of Transaction API.}
%\label{fig:api}
%\end{wrapfigure}
%We focus on an abstract computational model where multiple client programs can access and update keys in a key-value store using atomic transactions. 
%In general, clients are provided with a simple \textit{API} such as the one depicted in \cref{fig:api} \cite{gdur,physicsnmsi,clockSI}\footnote{It is 
%often the case that key-value stores provide a mechanism to wrap more transactions inside a session, and give 
%provide appropriate APIs to handle sessions. For the sake of simplicity, in this paper we assume that each client executes transactions 
%within a single session.}, while both the implementation details and the system architecture are hidden from clients. 
%Because (distributed) key-value stores only give weak consistency guarantees of the data to their clients, the latter are 
%not ensured to read the most up-to-date version of a key.
%%In an ideal world, when executing a transaction clients would read the most up-to-date version of a key. In a distributed setting 
%%this approach, known as (strict) serialisability, would require a continuous synchronisation between the different components of 
%%the system, which impacts performance and limits scalability. To this end, the database only provides weak consistency model
%%\ac{This sentence should probably be in the introduction.}
%
%Following these intuitions, we model a key-value stores, or \emph{kv-store}, as a centralised unit where multiple versions 
%are stored for each key (\cref{sec:mkvs-view}). Versions consist of a value and the meta-data of the transactions that wrote and 
%read such a version. In practical, distributed systems, the meta-data is usually encoded using either timestamps 
%\cite{physicsnmsi,clockSI} or vector clocks \cite{gdur}. We focus on key-value stores whose transactions 
%enjoy \emph{atomic visibility}, meaning that \textbf{(i)} transactions read their data from an atomic 
%snapshot of the key-value store, and \textbf{(ii)} a transaction can observe either none or all 
%of the updates performed by another transaction. In other words, a transaction only reads (writes) at most 
%one version for each key.
%Because clients may observe potentially out-of-date versions of the system, we introduce the notion of \emph{views}. 
%Intuitively, a view records the version of each key that a client observes at a given time. We use views 
%to determine the snapshot taken by transactions executed by clients.
%
%A consistency model is a contract between the key-value store and its clients. We distinguish 
%between \emph{client-centric} consistency models \cite{terry1994session}, 
%which impose constraints on the observations and updates made by a single client, 
%and \emph{data-centric} consistency models \cite{framework-concur}, which impose constraints 
%on the structure of the key value store.
%To specify weak consistency models, 
%we introduce the notion of \emph{execution tests} (\cref{sec:execution.tests}). An execution test
% specifies when a client is allowed to execute a transaction carrying a given 
%set of read and write operations, or \emph{fingerprint}. Therefore, an execution 
%test constrains how the state of the key-value store may evolve;
%by considering all the possible evolutions of the key-value store under said execution test, 
%we determine a consistency model. For example, an execution test for (strict) serialisability 
%requires that a transaction can be executed by a client only if it observes the most up-to-date 
%version for each key. 
%We give several examples of execution tests that capture both client-centric and 
%data-centric consistency models. 
%
%The idea of specifying consistency models using execution tests has been 
%already proposed in \cite{seebelieve}; however, their notion of execution 
%test is intrinsically more complex than ours: to determine 
%whether a transaction can commit, the total order in which all past transactions 
%have committed must be known. This knowledge is not needed in our setting.
%
%
%\begin{figure}[t]
%\begin{center}
%
%\hrulefill
%
%\begin{onethirdsubfig}
%\begin{tikzpicture}
%\begin{pgfonlayer}{foreground}
%%\draw[help lines] grid(5,4);
%
%%Location x
%\node(locx) {$\ke_1 \mapsto$};
%
%\matrix(versionx) [version list, column 2/.style={text width=8mm}]
%    at ([xshift=\tikzkvspace]locx.east) {
%    {a} & $\txid_0$ & {a} & $\txid_{\cl}^{1}$\\
%    {a} & $\left\{\txid_{\cl'}^{1}\right\}$ & {a} & $\emptyset$ \\
%};
%\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$v_0$};
%\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$v_1$};
%
%%Location y
%\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_2 \mapsto$};
%\matrix(versiony) [version list, column 2/.style={text width=8mm}]
%   at ([xshift=\tikzkvspace]locy.east) {
% {a} & $\txid_0$ & {a} & $\txid_{\cl'}^{1}$ \\
%  {a} & $\left\{\txid_{\cl}^1\right\}$ & {a} & $\emptyset$\\
%};
%
%\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$v'_0$};
%\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{$v'_1$};
%
%% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);
%
%%%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
%%\draw[-, blue, very thick, rounded corners=10pt]
% %([xshift=-3pt, yshift=20pt]locx-v1.north east) node (tid1start) {} -- 
% %([xshift=-3pt, yshift=-5pt]locx-v1.south east) --
% %([xshift=-3pt, yshift=5pt]locy-v0.north east) -- 
% %([xshift=-3pt, yshift=-5pt]locy-v0.south east);
% 
% %\path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\client$};
%
%%%red view
%%\draw[-, red, very thick, rounded corners = 10pt]
% %([xshift=-16pt, yshift=5pt]locx-v1.north east) node (tid2start) {}-- 
% %([xshift=-16pt, yshift=-5pt]locy-v1.south east) node {};
% 
%%\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\client'$};
%
%\end{pgfonlayer}
%\end{tikzpicture}
%\caption{A key-value store $\hh$}
%\label{fig:hheap-a}
%\label{fig:key-value-store}
%\label{fig:ser-disallowed}
%\end{onethirdsubfig}
%%
%\begin{onethirdsubfig}
%\begin{tikzpicture}
%\begin{pgfonlayer}{foreground}
%%\draw[help lines] grid(5,4);
%
%%Location x
%\node(locx) {$\ke_1 \mapsto$};
%
%\matrix(versionx) [version list, column 2/.style={text width=8mm}]
%    at ([xshift=\tikzkvspace]locx.east) {
%    {a} & $\txid_0$ & {a} & $\txid_{\cl}^{1}$\\
%    {a} & $\left\{\txid_{\cl'}^{1}\right\}$ & {a} & $\emptyset$ \\
%};
%\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$v_0$};
%\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$v_1$};
%
%%Location y
%\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_2 \mapsto$};
%\matrix(versiony) [version list, column 2/.style={text width=8mm}, column 3/.style={dotted}, column 4/.style={dotted}]
%   at ([xshift=\tikzkvspace]locy.east) {
%       {a} & $\txid_0$ & {a} & \color{gray}$\txid_{\cl'}^{1}$ \\
%  {a} & $\left\{\txid_{\cl}^1\right\}$ & {a} & \color{gray}$\emptyset$\\
%};
%
%\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$v'_0$};
%\node[version node,draw=none,fit=(versiony-1-3) (versiony-2-3),fill=white, inner sep=0pt] (locy-v1) {\color{gray}$v'_1$};
%
%\end{pgfonlayer}
%\end{tikzpicture}
%\caption{A view for client \( \cl \)}
%\label{fig:view-of-cl}
%\end{onethirdsubfig}
%%
%\begin{onethirdsubfig}
%\begin{tikzpicture}
%\begin{pgfonlayer}{foreground}
%%\draw[help lines] grid(5,4);
%
%%Location x
%\node(locx) {$\ke_1 \mapsto$};
%
%\matrix(versionx) [version list, column 2/.style={text width=8mm}, column 3/.style={dotted}, column 4/.style={dotted}]
%    at ([xshift=\tikzkvspace]locx.east) {
%    {a} & $\txid_0$ & {a} & \color{gray}$\txid_{\cl}^{1}$\\
%    {a} & $\left\{\txid_{\cl'}^{1}\right\}$ & {a} & \color{gray}$\emptyset$ \\
%};
%\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$v_0$};
%\node[version node,draw=none,fit=(versionx-1-3) (versionx-2-3),fill=white, inner sep=0pt] (locx-v1) {\color{gray}$v_1$};
%
%%Location y
%\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_2 \mapsto$};
%\matrix(versiony) [version list, column 2/.style={text width=8mm}]
%   at ([xshift=\tikzkvspace]locy.east) {
% {a} & $\txid_0$ & {a} & $\txid_{\cl'}^{1}$ \\
%  {a} & $\left\{\txid_{\cl}^1\right\}$ & {a} & $\emptyset$\\
%};
%
%\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$v'_0$};
%\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{$v'_1$};
%
%\end{pgfonlayer}
%\end{tikzpicture}
%\caption{A view for client \( \cl' \)}
%\label{fig:view-of-cl-prime}
%\end{onethirdsubfig}
%
%\end{center}
%
%\hrulefill
%
%\caption{Multi-version key-value stores and views}
%\label{fig:hheap}
%\label{fig:key-value-and-view}
%\end{figure}
%\ac{
%It will be often convenient to depict key-value stores graphically: an 
%example is given by the kv-store $\hh$ depicted in \cref{fig:hheap-a}
%(ignore for the moment the vertical lines labelled $\client$ and $\client'$).
%It comprises two keys \( \ke_1\) and \( \ke_2 \), 
%each of which is associated with two versions carrying values $\val_0$ and $\val_1$, and $\val'_0$ and $\val'_1$, respectively.
%The versions of a key are listed in order from left to right. 
%We represent each version as a three-cell box, with the left cell storing the value, the top right cell recording the writer, and the bottom right cell recording the readers. 
%For example, the version carrying value $\val_0$ in $\ke_1$ has been written by $\txid_0$, and has been read by $\txid_{\cl'}^1$.
%}
%
%%the author require 
%%the knowledge of the total order in which all past transactions have been 
%%executed, to determine whether a new transaction can commit.
%
%%%\ac{Can't cite documentations of real databases, as they usually have a much more complicated API.}
%%
%%%Transactions in our model execute atomically, though they have different effects on the key-value stores depending on their associated \emph{consistency model}.
%%%A consistency model controls how the key-value store evolves.
%%%A common model is \emph{serialisability}, where transactions appear to execute one after another in a sequential order.
%%%This notion of sequential execution is however not necessary for many weaker models. As such, upon commencing execution, a transaction may not observe the most up-to-date values for keys. 
%%
%%To address this, we 
%%first model 
%%the state of the system using \emph{multi-version key-value stores (MKVSs)} (\cref{sec:mkvs-view}). 
%%An MKVS keeps track of all versions (values) written for keys, as well as the information about the transactions that read and wrote such versions. 
%%To model the potential out-of-date observation, we introduce \emph{views}.
%%A view decides the observable versions of keys for a client.
%%Therefore, in order to execute a transaction, the client first takes \emph{a snapshot} of the system with the view, executes the transaction locally with respect to its snapshot (\cref{sec:trans-semantics}), and afterwards commits the effect of the transaction if the change is allowed by the underlying consistency model (\cref{sec:prog-semantics}).
%
%
%%We first introduce MKVSs and views (\secref{sec:mkvs-view}) and.
%%We starts with the syntax of programs followed by the semantics of transaction.
%%Finally, we will give the semantics for the entire programs.
\begin{figure}[t]

\hrulefill

\begin{subfigure}{0.38\textwidth}
\begin{verbatim}
interface Transaction {
    Start(); 
    Read(Key k);
    Write(Key k, Value v); 
    Commit();    
}
\end{verbatim}
\caption{Example of Transaction API.}
\label{fig:api}
\end{subfigure}
\begin{subfigure}{0.60\textwidth}
\[
\begin{parl}
\begin{session}
    \begin{transaction}
        \pmutate{\vx}{1} ; \\
    \end{transaction} \\
    \\
    \begin{transaction}
        \pderef{\pv{a}}{\vy}; \\
        \pifs{ \pv{a} = 0 } 
        \passign{\pv{f1}}{1} ; 
        \pife
    \end{transaction} \\
\end{session}
&
\begin{session}
    \begin{transaction}
        \pmutate{\vy}{1} ; \\
    \end{transaction} \\
    \\
    \begin{transaction}
        \pderef{\pv{b}}{\vx}; \\
        \pifs{ \pv{b} = 0 } 
        \passign{\pv{f2}}{1} ; 
        \pife
    \end{transaction} \\
\end{session}
\end{parl}
\]
\caption{Long fork.}
\label{fig:long-fork-code}
\end{subfigure}

\hrulefill

\end{figure}

We focus on an abstract computational model where multiple client programs can access and update keys in a key-value store using atomic transactions. 
In general, clients are provided with a simple \textit{API} such as the one depicted in \cref{fig:api} \cite{gdur,physicsnmsi,clockSI}\footnote{It is 
often the case that key-value stores provide a mechanism to wrap more transactions inside a session, and give 
provide appropriate APIs to handle sessions. For the sake of simplicity, in this paper we assume that each client executes transactions 
within a single session.}, while both the implementation details and the system architecture are hidden from clients. 
Because (distributed) key-value stores only give weak consistency guarantees of the data to their clients, the latter are 
not ensured to read the most up-to-date version of a key.
%In an ideal world, when executing a transaction clients would read the most up-to-date version of a key. In a distributed setting 
%this approach, known as (strict) serialisability, would require a continuous synchronisation between the different components of 
%the system, which impacts performance and limits scalability. To this end, the database only provides weak consistency model
%\ac{This sentence should probably be in the introduction.}

Following these intuitions, we model a key-value stores, or \emph{kv-store}, as a centralised unit where multiple versions 
are stored for each key (\cref{sec:mkvs-view}). Versions consist of a value and the meta-data of the transactions that wrote and 
read such a version. In practical, distributed systems, the meta-data is usually encoded using either timestamps 
\cite{physicsnmsi,clockSI} or vector clocks \cite{gdur}. We focus on key-value stores whose transactions 
enjoy \emph{atomic visibility}, meaning that \textbf{(i)} transactions read their data from an atomic 
snapshot of the key-value store, and \textbf{(ii)} a transaction can observe either none or all 
of the updates performed by another transaction. In other words, a transaction only reads (writes) at most 
one version for each key.
Because clients may observe potentially out-of-date versions of the system, we introduce the notion of \emph{views}. 
Intuitively, a view records the version of each key that a client observes at a given time. We use views 
to determine the snapshot taken by transactions executed by clients.

A consistency model is a contract between the key-value store and its clients. We distinguish 
between \emph{client-centric} consistency models \cite{terry1994session}, 
which impose constraints on the observations and updates made by a single client, 
and \emph{data-centric} consistency models \cite{framework-concur}, which impose constraints 
on the structure of the key value store.
To specify weak consistency models, 
we introduce the notion of \emph{execution tests} (\cref{sec:execution.tests}). An execution test
 specifies when a client is allowed to execute a transaction carrying a given 
set of read and write operations, or \emph{fingerprint}. Therefore, an execution 
test constrains how the state of the key-value store may evolve;
by considering all the possible evolutions of the key-value store under said execution test, 
we determine a consistency model. For example, an execution test for (strict) serialisability 
requires that a transaction can be executed by a client only if it observes the most up-to-date 
version for each key. 
We give several examples of execution tests that capture both client-centric and 
data-centric consistency models. 

The idea of specifying consistency models using execution tests has been 
already proposed in \cite{seebelieve}; however, their notion of execution 
test is intrinsically more complex than ours: to determine 
whether a transaction can commit, the total order in which all past transactions 
have committed must be known. This knowledge is not needed in our setting.


\begin{figure}[t]
\begin{center}

\hrulefill

\begin{onethirdsubfig}
\begin{tikzpicture}
\begin{pgfonlayer}{foreground}
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\vx \mapsto$};

\matrix(versionx) [version list, column 2/.style={text width=8mm}]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\txid_{\cl}^{1}$\\
    {a} & $\emptyset$ & {a} & $\emptyset$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$v_0$};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$v_1$};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\vy \mapsto$};
\matrix(versiony) [version list, column 2/.style={text width=8mm}]
   at ([xshift=\tikzkvspace]locy.east) {
 {a} & $\txid_0$ & {a} & $\txid_{\cl'}^{1}$ \\
 {a} & $\Set{\txid_{\cl}^{2}}$ & {a} & $\emptyset$\\
};

\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$v'_0$};
\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{$v'_1$};

% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
%\draw[-, blue, very thick, rounded corners=10pt]
 %([xshift=-3pt, yshift=20pt]locx-v1.north east) node (tid1start) {} -- 
 %([xshift=-3pt, yshift=-5pt]locx-v1.south east) --
 %([xshift=-3pt, yshift=5pt]locy-v0.north east) -- 
 %([xshift=-3pt, yshift=-5pt]locy-v0.south east);
 
 %\path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\client$};

%%red view
%\draw[-, red, very thick, rounded corners = 10pt]
 %([xshift=-16pt, yshift=5pt]locx-v1.north east) node (tid2start) {}-- 
 %([xshift=-16pt, yshift=-5pt]locy-v1.south east) node {};
 
%\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\client'$};

\end{pgfonlayer}
\end{tikzpicture}
\caption{A key-value store $\hh$}
\label{fig:hheap-a}
\label{fig:key-value-store}
\label{fig:ser-disallowed}
\end{onethirdsubfig}
%
\begin{onethirdsubfig}
\begin{tikzpicture}
\begin{pgfonlayer}{foreground}
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\vx \mapsto$};

\matrix(versionx) [version list, column 2/.style={text width=8mm}]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\txid_{\cl}^{1}$\\
    {a} & $\emptyset$ & {a} & $\emptyset$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$v_0$};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$v_1$};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\vy \mapsto$};
\matrix(versiony) [version list, column 2/.style={text width=8mm}, column 3/.style={dotted}, column 4/.style={dotted}]
   at ([xshift=\tikzkvspace]locy.east) {
       {a} & $\txid_0$ & {a} & \color{gray}$\txid_{\cl'}^{1}$ \\
   {a} & $\Set{\txid_{\cl}^{2}}$ & {a} & \color{gray}$\emptyset$\\
};

\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$v'_0$};
\node[version node,draw=none,fit=(versiony-1-3) (versiony-2-3),fill=white, inner sep=0pt] (locy-v1) {\color{gray}$v'_1$};

\end{pgfonlayer}
\end{tikzpicture}
\caption{A view for client \( \cl \)}
\label{fig:view-of-cl}
\end{onethirdsubfig}
%
\begin{onethirdsubfig}
\begin{tikzpicture}
\begin{pgfonlayer}{foreground}
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\vx \mapsto$};

\matrix(versionx) [version list, column 2/.style={text width=8mm}, column 3/.style={dotted}, column 4/.style={dotted}]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & \color{gray}$\txid_{\cl}^{1}$\\
    {a} & $\emptyset$ & {a} & \color{gray}$\emptyset$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$v_0$};
\node[version node,draw=none,fit=(versionx-1-3) (versionx-2-3),fill=white, inner sep=0pt] (locx-v1) {\color{gray}$v_1$};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\vy \mapsto$};
\matrix(versiony) [version list, column 2/.style={text width=8mm}]
   at ([xshift=\tikzkvspace]locy.east) {
  {a} & $\txid_0$ & {a} & $\txid_{\cl'}^{1}$ \\
  {a} & $\left\{\txid_{\cl}^2\right\}$ & {a} & $\emptyset$\\
};

\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$v'_0$};
\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{$v'_1$};

\end{pgfonlayer}
\end{tikzpicture}
\caption{A view for client \( \cl' \)}
\label{fig:view-of-cl-prime}
\end{onethirdsubfig}

\sx{The key-value store corresponds to the last step of long fork.}
\end{center}

\hrulefill

\caption{Multi-version key-value stores and views}
\label{fig:hheap}
\label{fig:key-value-store-and-view}
\label{fig:key-value-and-view}
\end{figure}
\ac{
It will be often convenient to depict key-value stores graphically: an 
example is given by the kv-store $\hh$ depicted in \cref{fig:hheap-a}
(ignore for the moment the vertical lines labelled $\client$ and $\client'$).
It comprises two keys \( \ke_1\) and \( \ke_2 \), 
each of which is associated with two versions carrying values $\val_0$ and $\val_1$, and $\val'_0$ and $\val'_1$, respectively.
The versions of a key are listed in order from left to right. 
We represent each version as a three-cell box, with the left cell storing the value, the top right cell recording the writer, and the bottom right cell recording the readers. 
For example, the version carrying value $\val_0$ in $\ke_1$ has been written by $\txid_0$, and has been read by $\txid_{\cl'}^1$.
}

%the author require 
%the knowledge of the total order in which all past transactions have been 
%executed, to determine whether a new transaction can commit.

%%\ac{Can't cite documentations of real databases, as they usually have a much more complicated API.}
%
%%Transactions in our model execute atomically, though they have different effects on the key-value stores depending on their associated \emph{consistency model}.
%%A consistency model controls how the key-value store evolves.
%%A common model is \emph{serialisability}, where transactions appear to execute one after another in a sequential order.
%%This notion of sequential execution is however not necessary for many weaker models. As such, upon commencing execution, a transaction may not observe the most up-to-date values for keys. 
%
%To address this, we 
%first model 
%the state of the system using \emph{multi-version key-value stores (MKVSs)} (\cref{sec:mkvs-view}). 
%An MKVS keeps track of all versions (values) written for keys, as well as the information about the transactions that read and wrote such versions. 
%To model the potential out-of-date observation, we introduce \emph{views}.
%A view decides the observable versions of keys for a client.
%Therefore, in order to execute a transaction, the client first takes \emph{a snapshot} of the system with the view, executes the transaction locally with respect to its snapshot (\cref{sec:trans-semantics}), and afterwards commits the effect of the transaction if the change is allowed by the underlying consistency model (\cref{sec:prog-semantics}).


%We first introduce MKVSs and views (\secref{sec:mkvs-view}) and.
%We starts with the syntax of programs followed by the semantics of transaction.
%Finally, we will give the semantics for the entire programs.f
