\section{Overview}
\label{sec:overview}
\sx{
    \begin{itemize}
        \item Multi-version Key-value, View.
    \end{itemize}
}


\begin{wrapfigure}[7]{r}{0.33\textwidth}
\vspace{-10pt}
\begin{verbatim}
interface Transaction {
    Start(); 
    Read(Key k);
    Write(Key k, Value v); 
    Commit();    }
\end{verbatim}
\vspace{-10pt}
\caption{Example of Transaction API.}
\label{fig:api}
\end{wrapfigure}
We focus on an abstract computational model where multiple client programs can access and update keys in a key-value store using atomic transactions. 
In general, clients are provided with a simple \textit{API} such as the one depicted in \cref{fig:api} \cite{gdur,physicsnmsi,clockSI}\footnote{It is 
often the case that key-value stores provide a mechanism to wrap more transactions inside a session, and give 
provide appropriate APIs to handle sessions. For the sake of simplicity, in this paper we assume that each client executes transactions 
within a single session.}, while both the implementation details and the system architecture are hidden from clients. 
Because (distributed) key-value stores only give weak consistency guarantees of the data to their clients, the latter are 
not ensured to read the most up-to-date version of a key.
%In an ideal world, when executing a transaction clients would read the most up-to-date version of a key. In a distributed setting 
%this approach, known as (strict) serialisability, would require a continuous synchronisation between the different components of 
%the system, which impacts performance and limits scalability. To this end, the database only provides weak consistency model
%\ac{This sentence should probably be in the introduction.}

Following these intuitions, we model a key-value stores, or \emph{kv-store}, as a centralised unit where multiple versions 
are stored for each key (\cref{sec:mkvs-view}). Versions consist of a value and the meta-data of the transactions that wrote and 
read such a version. In practical, distributed systems, the meta-data is usually encoded using either timestamps 
\cite{physicsnmsi,clockSI} or vector clocks \cite{gdur}. We focus on key-value stores whose transactions 
enjoy \emph{atomic visibility}, meaning that \textbf{(i)} transactions read their data from an atomic 
snapshot of the key-value store, and \textbf{(ii)} a transaction can observe either none or all 
of the updates performed by another transaction. In other words, a transaction only reads (writes) at most 
one version for each key.
Because clients may observe potentially out-of-date versions of the system, we introduce the notion of \emph{views}. 
Intuitively, a view records the version of each key that a client observes at a given time. We use views 
to determine the snapshot taken by transactions executed by clients.

A consistency model is a contract between the key-value store and its clients. We distinguish 
between \emph{client-centric} consistency models \cite{terry1994session}, 
which impose constraints on the observations and updates made by a single client, 
and \emph{data-centric} consistency models \cite{framework-concur}, which impose constraints 
on the structure of the key value store.
To specify weak consistency models, 
we introduce the notion of \emph{execution tests} (\cref{sec:execution.tests}). An execution test
 specifies when a client is allowed to execute a transaction carrying a given 
set of read and write operations, or \emph{fingerprint}. Therefore, an execution 
test constrains how the state of the key-value store may evolve;
by considering all the possible evolutions of the key-value store under said execution test, 
we determine a consistency model. For example, an execution test for (strict) serialisability 
requires that a transaction can be executed by a client only if it observes the most up-to-date 
version for each key. 
We give several examples of execution tests that capture both client-centric and 
data-centric consistency models. 

The idea of specifying consistency models using execution tests has been 
already proposed in \cite{seebelieve}; however, their notion of execution 
test is intrinsically more complex than ours: to determine 
whether a transaction can commit, the total order in which all past transactions 
have committed must be known. This knowledge is not needed in our setting.


\begin{figure}[t]
\begin{center}

\hrulefill

\begin{onethirdsubfig}
\begin{tikzpicture}
\begin{pgfonlayer}{foreground}
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\ke_1 \mapsto$};

\matrix(versionx) [version list, column 2/.style={text width=8mm}]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\txid_{\cl}^{1}$\\
    {a} & $\left\{\txid_{\cl'}^{1}\right\}$ & {a} & $\emptyset$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$v_0$};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$v_1$};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_2 \mapsto$};
\matrix(versiony) [version list, column 2/.style={text width=8mm}]
   at ([xshift=\tikzkvspace]locy.east) {
 {a} & $\txid_0$ & {a} & $\txid_{\cl'}^{1}$ \\
  {a} & $\left\{\txid_{\cl}^1\right\}$ & {a} & $\emptyset$\\
};

\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$v'_0$};
\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{$v'_1$};

% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
%\draw[-, blue, very thick, rounded corners=10pt]
 %([xshift=-3pt, yshift=20pt]locx-v1.north east) node (tid1start) {} -- 
 %([xshift=-3pt, yshift=-5pt]locx-v1.south east) --
 %([xshift=-3pt, yshift=5pt]locy-v0.north east) -- 
 %([xshift=-3pt, yshift=-5pt]locy-v0.south east);
 
 %\path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\client$};

%%red view
%\draw[-, red, very thick, rounded corners = 10pt]
 %([xshift=-16pt, yshift=5pt]locx-v1.north east) node (tid2start) {}-- 
 %([xshift=-16pt, yshift=-5pt]locy-v1.south east) node {};
 
%\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\client'$};

\end{pgfonlayer}
\end{tikzpicture}
\caption{A key-value store $\hh$}
\label{fig:hheap-a}
\label{fig:key-value-store}
\label{fig:ser-disallowed}
\end{onethirdsubfig}
%
\begin{onethirdsubfig}
\begin{tikzpicture}
\begin{pgfonlayer}{foreground}
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\ke_1 \mapsto$};

\matrix(versionx) [version list, column 2/.style={text width=8mm}]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\txid_{\cl}^{1}$\\
    {a} & $\left\{\txid_{\cl'}^{1}\right\}$ & {a} & $\emptyset$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$v_0$};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$v_1$};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_2 \mapsto$};
\matrix(versiony) [version list, column 2/.style={text width=8mm}, column 3/.style={dotted}, column 4/.style={dotted}]
   at ([xshift=\tikzkvspace]locy.east) {
       {a} & $\txid_0$ & {a} & \color{gray}$\txid_{\cl'}^{1}$ \\
  {a} & $\left\{\txid_{\cl}^1\right\}$ & {a} & \color{gray}$\emptyset$\\
};

\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$v'_0$};
\node[version node,draw=none,fit=(versiony-1-3) (versiony-2-3),fill=white, inner sep=0pt] (locy-v1) {\color{gray}$v'_1$};

\end{pgfonlayer}
\end{tikzpicture}
\caption{A view for client \( \cl \)}
\label{fig:view-of-cl}
\end{onethirdsubfig}
%
\begin{onethirdsubfig}
\begin{tikzpicture}
\begin{pgfonlayer}{foreground}
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\ke_1 \mapsto$};

\matrix(versionx) [version list, column 2/.style={text width=8mm}, column 3/.style={dotted}, column 4/.style={dotted}]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & \color{gray}$\txid_{\cl}^{1}$\\
    {a} & $\left\{\txid_{\cl'}^{1}\right\}$ & {a} & \color{gray}$\emptyset$ \\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$v_0$};
\node[version node,draw=none,fit=(versionx-1-3) (versionx-2-3),fill=white, inner sep=0pt] (locx-v1) {\color{gray}$v_1$};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_2 \mapsto$};
\matrix(versiony) [version list, column 2/.style={text width=8mm}]
   at ([xshift=\tikzkvspace]locy.east) {
 {a} & $\txid_0$ & {a} & $\txid_{\cl'}^{1}$ \\
  {a} & $\left\{\txid_{\cl}^1\right\}$ & {a} & $\emptyset$\\
};

\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$v'_0$};
\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{$v'_1$};

\end{pgfonlayer}
\end{tikzpicture}
\caption{A view for client \( \cl' \)}
\label{fig:view-of-cl-prime}
\end{onethirdsubfig}

\end{center}

\hrulefill

\caption{Multi-version key-value stores and views}
\label{fig:hheap}
\label{fig:key-value-and-view}
\end{figure}
\ac{
It will be often convenient to depict key-value stores graphically: an 
example is given by the kv-store $\hh$ depicted in \cref{fig:hheap-a}
(ignore for the moment the vertical lines labelled $\client$ and $\client'$).
It comprises two keys \( \ke_1\) and \( \ke_2 \), 
each of which is associated with two versions carrying values $\val_0$ and $\val_1$, and $\val'_0$ and $\val'_1$, respectively.
The versions of a key are listed in order from left to right. 
We represent each version as a three-cell box, with the left cell storing the value, the top right cell recording the writer, and the bottom right cell recording the readers. 
For example, the version carrying value $\val_0$ in $\ke_1$ has been written by $\txid_0$, and has been read by $\txid_{\cl'}^1$.
}

%the author require 
%the knowledge of the total order in which all past transactions have been 
%executed, to determine whether a new transaction can commit.

%%\ac{Can't cite documentations of real databases, as they usually have a much more complicated API.}
%
%%Transactions in our model execute atomically, though they have different effects on the key-value stores depending on their associated \emph{consistency model}.
%%A consistency model controls how the key-value store evolves.
%%A common model is \emph{serialisability}, where transactions appear to execute one after another in a sequential order.
%%This notion of sequential execution is however not necessary for many weaker models. As such, upon commencing execution, a transaction may not observe the most up-to-date values for keys. 
%
%To address this, we 
%first model 
%the state of the system using \emph{multi-version key-value stores (MKVSs)} (\cref{sec:mkvs-view}). 
%An MKVS keeps track of all versions (values) written for keys, as well as the information about the transactions that read and wrote such versions. 
%To model the potential out-of-date observation, we introduce \emph{views}.
%A view decides the observable versions of keys for a client.
%Therefore, in order to execute a transaction, the client first takes \emph{a snapshot} of the system with the view, executes the transaction locally with respect to its snapshot (\cref{sec:trans-semantics}), and afterwards commits the effect of the transaction if the change is allowed by the underlying consistency model (\cref{sec:prog-semantics}).


%We first introduce MKVSs and views (\secref{sec:mkvs-view}) and.
%We starts with the syntax of programs followed by the semantics of transaction.
%Finally, we will give the semantics for the entire programs.
