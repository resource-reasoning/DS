\subsection{Key-value Store Traces to Abstract Execution Traces}
\label{sec:kvtrace2aexec}

To prove our specification using execution test on key-value stores 
is sound and complete with respect with the axiomatic specification on abstract execution (\cref{sec:kv-sound-complete-proof}),
we need to prove trace equivalent between these two models.

In this section, we only consider the trace that does not involve \( \prog \) but only committing fingerprint and view shift.
In \cref{sec:kv-sound-complete-proof}, we will go further and discuss the trace installed with \( \prog \).

Similar to \(\anarchic\), let $\ET_\top$ be the most permissive execution test.
That is $\ET_\top \vdash (\hh, \vi) \triangleright \opset: \vi'$ 
such that whenever $\vi(\ke) \neq \vi'(\ke)$ then either $(\otW, \ke, \_) \in \opset$ or $(\otR, \ke, \_) \in \opset$.
%{\color{red} I forgot this last constraint in the latest version of the document, definitions 
%and proofs of theorems that follow must be re-factored to take the constraint into account.}
We will relate $\ET_{\top}$-traces to abstract executions that satisfy the last write wins resolution policy, \ie \( (\RP_\LWW, \emptyset) \).

To bridge $\ET_{\top}$-traces to abstract executions, 
The \aeset(\tr) function converse the trace of \( \ET_\top \) to set of possible abstract executions (\cref{def:kvtrace2aexec}).
In fact, for any trace \( \tr \) and abstract execution $\aexec \in \aeset(\tr)$, 
the last configuration of $\tr$ is $(\hh_{\aexec}, \_)$ (\cref{prop:kvtrace2aexec}).
We often use \( \aexec_\tr \) for \( \aexec \in \aeset(\tr) \).

\begin{definition}
\label{def:kvtrace2aexec}
Given a key-value store $\hh$, a view $\vi$, 
an initial abstract execution $\aexec_0 = ( [ ], \emptyset, \emptyset)$, 
an abstract execution $\aexec$, a set of transactions  
$\T \subseteq \T_{\aexec}$, a transaction identifier $\txid$ and a set of operations $\opset$,
the \( \extend \)  function defined as the follows:
\[
\begin{rclarray}
\extend(\aexec, \txid, \T, \opset) & \defeq &
\begin{cases}
\text{undefined} & \text{if }  \txid = \txid_{0}\\
\left(\TtoOp{T}_{\aexec} \uplus \Set{\txid \mapsto \opset}, \VIS', \AR' \right) & \text{if } \dagger \\
\end{cases} \\
\dagger & \equiv &  
\begin{array}[t]{@{}l}
\txid = \txid_{\cl}^{n}
\wedge \VIS' = \VIS_{\aexec} \uplus \Setcon{(\txid', \txid) }{ \txid \in \T}  \\
{} \wedge \AR' = \AR_{\aexec} \uplus \Setcon{(\txid', \txid) }{ \txid' \in \T_{\aexec}}
\end{array}
\end{rclarray}
\]
Given a $\ET_{\top}$ trace $\tr$, let $\lastConf(\tr)$ be the last configuration appearing in $\tr$.
The set of abstract executions $\aeset(\tr)$ is defined as the smallest set such that:
\begin{itemize}
\item $\aexec_{0} \in \aeset((\hh_{0}, \viewFun_{0}))$, 
\item if $\aexec \in \aeset(\tr)$, then $\aexec \in \aeset\left(\tr \xrightarrowtriangle{(\cl, \varepsilon)}_{\ET_{\top}} (\hh, \viewFun) \right)$, 
\item if $\aexec \in \aeset(\tr)$, then $\aexec \in \aeset\left(\tr \xrightarrowtriangle{(\cl, \emptyset)}_{\ET_{\top}} (\hh, \viewFun) \right)$, 
\item 
    let $(\hh', \viewFun') = \lastConf(\tr)$; 
    if $\aexec \in \aeset(\tr)$, $\opset \neq \emptyset$,
    and $\T = \Tx(\hh, \viewFun'(\cl)) \cup \T_\rd$ where \( \T_\rd \) is a set of \emph{read-only transactions}
    such that $(\otW, \ke, \val) \notin_{\aexec} \txid'$ for all keys \( \ke \) and values \( \val \) and transactions \( \txid' \in \T_\rd\),
    and if the transaction $\txid$ is the transaction appearing in $\lastConf(\tr)$ but not in $\hh$, 
    then $\extend(\aexec, \txid, \T, \opset) \in \aeset\left(\tr \xrightarrowtriangle{(\cl, \opset)}_{\ET_{\top}} (\hh, \viewFun) \right)$.
\end{itemize}
\end{definition}

\begin{proposition}[Trace of \( \ET \) to abstract executions]
\label{prop:kvtrace2aexec}
For any $\ET_{\top}$-trace $\tr$, 
the abstract execution $\aexec \in \aeset(\tr)$ satisfies the last write wins policy,
and $(\hh_{\aexec}, \stub) = \lastConf(\tr)$.
\end{proposition}
\begin{proof}
Fix a $\ET_{\top}$-trace $\tau$. 
We prove by induction on the number of transitions $n$ in $\tau$. 
\begin{itemize}
\item \caseB{$n = 0$}
It means $\tr = (\hh_{0}, \_)$.
It follows from \cref{def:kvtrace2aexec} that $\aexec_{\tau} = ([], \emptyset, \emptyset)$. 
This triple satisfies the constraints of \cref{def:aexec}, as well as the resolution policy $\RP_{\LWW}$. 
It is also immediate to see that $\graphof(\aexec) = ([], \emptyset, \emptyset, \emptyset)$.
In particular, $\T_{\graphof(\aexec)} = \emptyset$, 
and the only kv-store $\hh$ such that $\T_{\Gr_{\hh}} = \emptyset$ 
is given by $\hh = \hh_{0}$. 
By definition, $\hh_{\aexec_{\tr}} = \hh_{0}$, as we wanted to prove.

\item \caseI{$n > 0$} In this case, we have that $\tr = \tr' \xrightarrowtriangle{(\cl, \mu)} (\hh, \viewFun)$ 
for some $\cl, \mu, \hh, \viewFun$. The $\ET_{\top}$-trace $\tau'$ contains exactly $n-1$ transitions, 
so that by induction we can assume that $\aexec_{\tau'}$ is a valid abstract execution that satisfies 
$\RP_{\LWW}$. and $\lastConf(\tau') = (\hh_{\aexec_{\tau'}}, \viewFun')$ for some $\viewFun'$. 

We perform a case analysis on $\mu$. 
If $\mu = \varepsilon$, then it follows that $\hh = \hh_{\aexec_{\tau'}}$, 
and $\aexec_{\tau} = \aexec_{\tau'}$ by \cref{def:kvtrace2aexec}. 
Then by the inductive hypothesis $\aexec_{\tau}$ is an abstract execution that satisfies $\RP_{\LWW}$,
$\lastConf(\tau) = (\hh, \_)$, and $\hh_{\aexec_{\tau}} = \hh_{\aexec_{\tau'}} = \hh$, 
and there is nothing left to prove. 

Suppose now that $\mu = \opset$, for some $\opset$. In this case we have that  
$\hh \in \updateKV(\hh_{\aexec_{\tau'}}, \viewFun'(\cl), \cl, \opset)$. Note that if 
$\opset = \emptyset$, then $\hh = \hh_{\aexec_{\tau'}}$ and $\aexec_{\tau} = \aexec_{\tau'}$. 
By the inductive hypothesis, $\aexec_{\tau}$ is an abstract execution that satisfies 
$\RP_{\LWW}$, and $\hh = \hh_{\aexec_{\tau'}} = \hh_{\aexec_{\tau}}$. 
Assume then that $\opset \neq \emptyset$. By definition, $\hh = \updateKV(\hh_{\aexec_{\tau'}}, 
\viewFun'(\cl), \txid, \opset)$ for some $\txid \in \nextTxId(\cl, \hh_{\aexec_{\tau}})$. It follows that $\txid$ 
is the unique transaction such that $\txid \notin \hh_{\aexec_{\tau'}}$, and $\txid \in \hh$ 
(the fact that $\txid \in \hh$ follows from the assumption that $\opset \neq \emptyset$). Let 
$\T = \Tx(\hh_{\aexec_{\tau'}}, \viewFun'(\cl))$; then $\aexec_{\tau} = \extend(\hh_{\aexec_{\tau'}}, \txid, \T, \opset)$. 
Note that $\aexec_{\tau}$ satisfies the constraints of abstract execution required by \cref{def:aexec}:
\begin{itemize}
\item  Because $\txid \in \nextTxId(\cl, \hh_{\aexec_{\tau}})$, it must be the case that $\txid = \txid_{\cl}^{m}$ for some 
$m \geq 1$; we have that $\TtoOp{T}_{\aexec_{\tau}} = \TtoOp{T}_{\aexec_{\tau'}}\rmto{\txid_{\cl}^{m}}{\opset}$, 
from which it follows that 
\[
\T_{\aexec_{\tau}} = \dom(\TtoOp{T}_{\aexec_{\tau}}) = \dom(\TtoOp{T}_{\aexec_{\tau'}}) \cup 
\{\txid_{\cl}^{m} \} = \T_{\aexec_{\tau'}} \cup \{\txid_{\cl}^{m} \}
\]
By inductive hypothesis, $\txid_0 \notin \T_{\aexec_{\tau'}}$, and therefore $\txid_{0} \notin 
\T_{\aexec_{\tau'}} \cup \{\txid_{\cl}^{m} \} = \T_{\aexec}$.

\item \( \VIS_{\aexec_{\tau}} \subseteq \AR_{\aexec_{\tau}} \).
    Let $(\txid' ,\txid'') \in \VIS_{\aexec_{\tau}}$. Then either $\txid'' = \txid_{\cl}^{m}$ and $\txid' \in \T$, or $(\txid', \txid'') \in 
\VIS_{\aexec_{\tau'}}$. In the former case, we have that $(\txid', \txid_{\cl}^{m}) \in \AR_{\aexec_{\tau}}$ by definition; 
in the latter case, we have that $(\txid', \txid'') \in \AR_{\aexec_{\tau'}}$ because $\aexec_{\tau'}$ is a valid 
abstract execution by inductive hypothesis, and therefore $(\txid', \txid'') \in \AR_{\aexec_{\tau}}$ by definition. 
This concludes the proof that $\VIS_{\aexec_{\tau}} \subseteq \AR_{\aexec_{\tau}}$. 
\item \( \VIS_{\aexec_\tr} \) is irreflexive.
Assume $(\txid', \txid'') \in \VIS_{\aexec_{\tau}}$, then either 
$(\txid' \txid'') \in \VIS_{\aexec_{\tau'}}$, and because $\VIS_{\aexec_{\tau'}}$ is irreflexive by the inductive hypothesis, 
then $\txid' \neq \txid''$; 
or $\txid'' = \txid_{\cl}^{m}$, $\txid' \in \T \subseteq \T_{\aexec_{\tau'}}$, 
and because $\txid_{\cl}^{m} \notin \hh_{\aexec_{\tau'}}$, then $\txid' \neq \txid_{\cl}^{m}$. 

\item $\AR_{\aexec_{\tau}}$ is total. Let $(\txid', \txid'') \in \T_{\aexec_{\tau}}$. 
Suppose that $\txid' \neq \txid''$.
\begin{enumerate}
\item If $\txid' \neq 
\txid_{\cl}^{m}$, $\txid'' \neq \txid_{\cl}^{m}$, then it must be the case that $\txid', \txid'' \in \T_{\aexec_{\tau'}}$; 
this is because we have already argued that $\T_{\aexec_{\tau}} = \T_{\aexec_{\tau'}} \cup \{\txid_{\cl}^{m}\}$. 
By the inductive hypothesis, we have that either $(\txid', \txid'') \in \AR_{\aexec_{\tau'}}$, or 
$(\txid'', \txid') \in \AR_{\aexec_{\tau'}}$. Because $\AR_{\aexec_{\tau'}} \subseteq \AR_{\aexec_{\tau}}$, 
then either $(\txid', \txid'') \in \AR_{\aexec_{\tau'}}$ or $(\txid'', \txid') \in \AR_{\aexec_{\tau}}$. 
\item if $\txid'' = \txid_{\cl}^{m}$, then it must be $\txid' \in \T_{\aexec_{\tau'}}$. By definition, 
$(\txid', \txid_{\cl}^{m}) \in \AR_{\aexec_{\tau}}$. Similarly, if $\txid' = \txid_{\cl}^{m}$, we 
can prove that $(\txid'', \txid_{\cl}^{m}) \in \AR_{\aexec_{\tau}}$.
\end{enumerate}
\item  $\AR_{\aexec_{\tau}}$ is irreflexive. It follows is the same as the one of $\VIS_{\aexec_{\tau}}$.
\item \( \AR_{\aexec_{\tau}} \) is transitive.
Assume $(\txid', \txid'') \in \AR_{\aexec_{\tau}}$ and $(\txid'', \txid''') \in \AR_{\aexec_{\tau}}$. 
Note that it must be the case that $\txid', \txid'' \in \T_{\aexec_{\tau'}}$ by the definition of 
$\AR_{\aexec}$, and in particular $(\txid', \txid'') \in \AR_{\aexec_{\tau'}}$. 
For $\txid'''$, we have two possible cases. 
\begin{enumerate}
\item Either $\txid''' \in \T_{\aexec_{\tau}}$, from 
which it follows that $(\txid'', \txid''') \in \AR_{\aexec_{\tau'}}$; because
of $\AR_{\aexec_{\tau'}}$ is transitive by the inductive hypothesis, then 
$(\txid', \txid''') \in \AR_{\aexec_{\tau'}}$, and therefore $(\txid' ,\txid''') \in 
\AR_{\aexec_{\tau}}$.
\item Or $\txid''' = \txid_{\cl}^{m}$, and because $\txid' \in \T_{\aexec_{\tau'}}$, then 
$(\txid', \txid_{\cl}^{m}) \in \AR_{\aexec_{\tau}}$ by definition. 
\end{enumerate}
\item \( \SO_{\aexec_{\tau}} \subseteq \AR_{\aexec_{\tau}} \).
Let $\cl'$ be a client such that $(\txid_{\cl'}^{i}, \txid_{\cl'}^{j}) \in \AR_{\aexec_{\tau}}$. 
If $\cl' \neq \cl$, then it must be the case that $\txid_{\cl'}^{i}, \txid_{\cl'}^{j} \in \T_{\aexec_{\tau'}}$, 
and therefore $(\txid_{\cl'}^{i}, \txid_{\cl'}^{j}) \in \AR_{\aexec_{\tau'}}$. By the inductive hypothesis, 
it follows that $i < j$. If $\cl' = \cl$, then by definition of $\AR_{\aexec_{\tau}}$ it must be  $i \neq m$. 
If $j \neq m$ we can proceed as in the previous case to prove that $i < j$. If $j = m$, then 
note that $\txid_{\cl}^{i} \in \T_{\aexec_{\tau}}$ only if $\txid_{\cl}^{i} \in \hh_{\aexec_{tau'}}$. 
Because $\txid_{\cl}^{m} \in \nextTxId(\hh_{\aexec_{\tau'}}, \cl)$, then we have that $i < m$, 
as we wanted to prove.
\end{itemize}

Next, we prove that $\aexec_{\tau}$ satisfies the last write wins policy. 
Let $\txid' \in \T_{\aexec_{\tau}}$, and suppose that $(\otR, \ke, \val) \in_{\aexec_{\tau}} \txid'$. 
\begin{itemize} 
\item If $\txid' \neq \txid$, then we have that $\txid \in \T_{\aexec_{\tau'}}$. We also have that 
$\VIS^{-1}_{\aexec_{\tau}}(\txid') = \VIS^{-1}_{\aexec_{\tau'}}(\txid')$, $\AR^{-1}_{\aexec_{\tau}}(\txid') 
= \AR^{-1}_{\aexec_{\tau'}}(\txid')$; finally, for any $\txid'' \in \T_{\aexec_{\tau'}}$, 
$(\otW, \ke, \val') \in_{\aexec_{\tau}} \txid''$ if and only if $(\otW, \ke, \val') \in_{\aexec_{\tau'}} 
\txid''$. Therefore, let $\txid_{r} = \max_{\AR_{\aexec_{\tau}}}(\VIS^{-1}_{\aexec_{\tau}}(\txid') \cap 
\{\txid'' \mid (\otW, \ke, \_) \in_{\aexec_{\tau}} \txid''\})$. We have that $\txid_{r} = \max_{\AR_{\aexec_{\tau'}}}(\VIS^{-1}_{\aexec_{\tau'}}(\txid) 
\cap \{ \txid'' \mid (\otW, \ke, \_ \in_{\aexec_{\tau'}} \txid''\})$, and because $\aexec_{\tau'}$ satisfies the last write 
wins resolution policy,then $(\otW, \ke, \val) \in_{\aexec_{\tau'}} \txid_{r}$. This also implies that 
$(\otW, \ke, \va) \in_{\aexec_{\tau}} \txid_{r}$. 

\item Now, suppose that $\txid' = \txid$. Suppose that $(\otR, \ke, \val) \in_{\aexec_{\tau}} \txid'$. 
By definition, we have that $(\otR, \ke, \val) \in \opset$. Recall that $\tau = \tau' \xrightarrow{(\cl, \opset)}_{\ET_{\top}} (\hh, \viewFun)$, 
and $\lastConf(\tau') = (\hh_{\aexec_{\tau'}}, \viewFun')$ for some $\viewFun'$. 
That is, 
\[
    (\hh_{\aexec_{\tau'}}, \viewFun') \xrightarrowtriangle{(\cl, \opset)}_{\ET_{\top}} (\hh, \viewFun)
\]
which in turn implies that $\ET_{\top} \vdash (\hh_{\aexec_{\tau'}}, \viewFun'(\cl)) \triangleright \opset : \viewFun(\cl)$. 
Let then $r = \max\{i \mid  i \in \viewFun'(\cl)(\ke)\}$. 
By definition of execution test, and because $(\otR, \ke, \val) \in \opset$, then it must be the case that 
$\hh_{\aexec_{\tau'}}(\ke, r) = (\val, \txid'', \_)$ for some $\txid''$. 

We now prove that 
$\txid'' = \max_{\AR_{\aexec_{\tau}}}(\VIS^{-1}_{\aexec_{\tau}}(\txid) \cap \{ \txid'' \mid (\otW, \ke, \_) \in_{\aexec_{\tau}} \txid''\})$. 
First we have
\[ 
\begin{array}{l}
\VIS^{-1}_{\aexec_{\tau}}(\txid) = 
\quad \Tx(\hh_{\aexec_{\tau'}}, \viewFun'(\cl)) = \\
\qquad \{\WTx(\hh_{\aexec_{\tau'}}(\ke',  i)) \mid \ke' \in \Keys \wedge  i \in \viewFun'(\cl)(\ke')\}
\end{array}
\]
Note that $r \in \viewFun'(\cl)(\ke)$, and $\txid'' = \WTx(\hh_{\aexec_{\tau'}}(\ke, r))$. 
Therefore, $\txid'' \in \VIS^{-1}_{\aexec_{\tau}}(\txid)$. 
Because $\hh = \updateKV(\hh_{\aexec_{\tau'}}, \viewFun'(\cl), \txid, \opset)$, it 
must be the case that $\WTx(\hh(\ke, r)) = \txid''$. Also, because $\WTx(\hh_{\aexec_{\tau'}}(\ke, r)) = \txid''$, 
then $(\otW, \ke, \_) \in_{\aexec_{\tau''}} \txid''$, or equivalently $(\otW, \ke, \_) \in \TtoOp{T}_{\aexec_{\tau'}}(\txid'')$. 
We have already proved that $\VIS_{\aexec_{\tau}}$ is irreflexive, hence it must be the case that $\txid'' \neq \txid$. 
In particular, because $\aexec_{\tau} = \extend(\aexec_{\tau'}, \txid, \_, \_)$, then we have that 
$\TtoOp{T}_{\aexec_{\tau}}(\txid'') = \TtoOp{T}_{\aexec_{\tau'}}\rmto{\txid}{\opset}(\txid'') = 
\TtoOp{T}_{\aexec_{\tau'}}(\txid'')$, hence $(\otW, \ke, \_) \in \TtoOp{T}_{\aexec_{\tau}}(\txid'')$. Equivalently, 
$(\otW, \ke, \_) \in_{\aexec_{\tau}} \txid''$. We have proved that $\txid'' \in \VIS^{-1}_{\aexec_{\tau}}(\txid)$, 
and $(\otW, \ke, \_) \in_{\aexec_{\tau}} \txid''$. 

Now let $\txid'''$ be such that $\txid''' \in \VIS^{-1}_{\aexec_{\tau}}(\txid)$, and $(\otW, \ke \_) \in_{\aexec_{\tau}} \txid'''$. 
Note that $\txid''' \neq \txid$ because $\VIS_{\aexec_{\tau}}$ is irreflexive.
We show that either $\txid''' = \txid''$, or $\txid''' \xrightarrow{\AR_{\aexec_{\tau}}} \txid''$. 
Because $\txid''' \in \VIS^{-1}_{\aexec_{\tau}}(\txid)$, then there exists a key $\ke'$ and an index $i \in \viewFun'(\cl)$ 
such that $\WTx(\hh_{\aexec_{\tau'}}(\ke', i)) = \txid'''$. Because $(\otW, \ke, \_) \in_{\aexec_{\tau}} \txid'''$, 
and because $\txid''' \neq \txid$, then $(\otW, \ke, \_) \in_{\aexec_{\tau'}} \txid'''$, and therefore there exists 
an index $j$ such that $\WTx(\hh_{\aexec_{\tau'}}(\ke, j)) = \txid'''$. We have that $\WTx(\hh_{\aexec_{\tau'}}(\ke, j) = 
\WTx(\hh_{\aexec_{\tau'}}(\ke', i))$, and $i \in \viewFun'(\cl)$. By \cref{eq:view.atomic}, it must be $j \in \viewFun'(\cl)$. 
Note that $r = \max\{i \mid i \in \viewFun'(\cl)\}$, hence we have that $j \leq r$. If $j = r$, then $\txid''' = \txid''$ and 
there is nothing left to prove. If $j < r$, then we have that $(\txid''', \txid'') \in \AR_{\aexec_{\tau'}}$, and 
therefore $(\txid''', \txid'') \in \AR_{\aexec_{\tau}}$.
\end{itemize}
Finally, we need to prove that $\hh = \hh_{\aexec_{\tau}}$.
Recall $\hh = \updateKV(\hh_{\aexec_{\tau'}}, \viewFun'(\cl), \txid, \opset)$, 
and $\aexec_{\tau} = \extend(\aexec_{\tau'}, \txid, \Tx(\hh_{\aexec_{\tau'}}, \viewFun'(\cl), \opset)$. 
The result follows then from \cref{prop:extend.update.sameop}. 
\end{itemize}
\end{proof}

\sx{NEVER USED LEMMA}
\begin{lemma}
\label{lem:updatekv.preserveviews}
Let $\hh$ be a kv-store, and let $\txid \notin \hh$. For any $\vi, \vi' \in \Views(\hh)$, 
view $\vi'$ and set of operations $\opset$, then $\vi \in \updateKV(\hh, \txid, \vi', \opset)$.
\end{lemma}

\begin{proof}
Immediate from the definition of $\updateKV$. The fact that $\txid \notin \hh$ ensures that 
$\vi$ satisfies \eqref{eq:view.atomic} with respect to $\updateKV(\hh, \txid, \vi', \opset)$.
\end{proof}


\sx{NEVER USED LEMMA}
\begin{lemma}
\label{lem:cut.views}
Let $\aexec$ be an abstract execution, with 
$\T_{\aexec} = \{\txid_{i}\}_{i = 1}^{n}$ for 
$n = \lvert \T_{\aexec} \rvert$, with $\txid_{i} \xrightarrow{\AR_{\aexec}} \txid_{i+1}$ 
for all $i=0,\cdots, n-1$.  Let $\T_{0} = \emptyset$, and for $i=1,\cdots, n$, Let $\T_{i} \subseteq \AR^{-1}?(\txid_{i})$. 
Then $\getView(\aexec, \T_{i}) \in \Views(\hh_{\cut(\aexec, i)})$.
\end{lemma}

\begin{proof}
By induction on $i$. 
\begin{itemize}
\item If $i = 0$, then $\T_{0} = \emptyset$, and $\getView(\aexec, \T_{0}) = \lambda \ke. \{0 \}$. 
We also have that $\hh_{\cut(\aexec, 0)} = \lambda \ke. \List{(\val_0, \txid_{0}, \emptyset)}$, hence 
it is immediate to see that $\getView(\aexec, \T_{0}) \in \Views(\hh_{\cut(\aexec, 0)})$.

\item Let $i = i'+1$, and suppose that for any $\T \subseteq (\AR_{\aexec}^{-1}?)(\txid_{i'})$, 
$\getView(\aexec, \T) \in \Views(\hh_{\cut(\aexec, i)})$. Consider the set $\T_{i}$.
Note that, because of \cref{prop:extend.update.sameop}, we have that
\[
\begin{array}{ll}
\hh_{\cut(\aexec, i)} &=\\ 
\hh_{\extend(\cut(\aexec, i'), \txid_{i}, \VIS^{-1}_{\aexec}(\txid_{i}), \TtoOp{T}_{\aexec}(\txid_{i})} &= \\
\updateKV(\hh_{\cut(\aexec, i')}, \txid_{i}, \getView(\VIS^{-1}_{\aexec}(\txid_{i}), \TtoOp{T}_{\aexec}(\txid_{i})
\end{array}
\]
We consider two possibilities.
\begin{enumerate}
\item $\txid_{i} \notin \T_{i}$, in which case $\T_{i} \subseteq (\AR_{\aexec}^{-1})?(\txid_{i'})$, 
and from the inductive hypothesis we get $\getView(\aexec, \T_{i}) \in \Views(\hh_{\cut(\aexec, i')})$. 
Note that, from \ref{lem:cut.explicit} it must be the case that $\hh_{\cut, \aexec, i')}$ only contains 
the transactions identifiers from $\txid_{1}$ to $\txid_{i'}$; in particular, it does not contain 
$\txid_{i}$. Because $\hh_{\cut(\aexec, i)} = \updateKV(\hh_{\cut(\aexec, i')}, \txid_{i}, \_, \_)$, 
then by \ref{lem:updatekv.preserveviews} we have that  
$\getView(\aexec, \txid_{i}) \in \Views(\hh_{\cut(\aexec, i)})$.

\item $\txid \in \T_{i}$. Note that for any key $\ke$ such that 
$(\otW, \ke, \_) \notin \TtoOp{T}_{\aexec}(\txid_{i})$, then 
$\getView(\aexec, \T_{i})(\ke) = \getView(\aexec, \T_{i} \setminus \{(\txid_{i})\})(\ke)$; 
and for any key $\ke$ such that $(\otW, \ke, \_) \in \TtoOp{T}_{\aexec}(\txid_{i})$, 
then $\getView(\aexec, \T_{i}(\ke) = \getView(\aexec, \T_{i} \setminus \{\txid_{i}\})(\ke) 
\cup \{j \mid \WTx(\hh_{\aexec}(\ke, i)) = \txid_{j}\}$. Note that in this last case the index 
$j$ must be such that $j < \lvert \hh_{cut(\aexec, i)} \rvert - 1$, because we know that 
$\txid_{i} \in \hh_{\cut(\aexec, i)}$. It follows from this fact and the inductive hypothesis, 
that $\getView(\aexec, \T_{i}) \in \Views(\cut(\aexec, i))$.
\ac{This is a really loose proof sketch. The reason for an incomplete proof is 
that i got bored while typing it.} 
\end{enumerate}
\end{itemize}
\end{proof}

\begin{proposition}[\( \extend \) matching \( \updateKV\)]
\label{prop:extend.update.sameop}
Given an abstract execution $\aexec$, a set of transactions $\T \subseteq \T_{\aexec}$,
a transaction $\txid \notin \T_{\aexec}$, and a fingerprint $\opset \subseteq \powerset{\Ops}$,
if the new abstract execution $\aexec' = \extend(\aexec, \T, \txid, \opset)$,
and the view $\vi = \getView(\hh_{\aexec}, \T)$,
then $\updateKV(\hh_{\aexec}, \vi, \txid, \opset) = \hh_{\aexec'}$.
\end{proposition}

\begin{proof}
Let $\Gr = \Gr_{\updateKV(\hh_{\aexec}, \vi, \txid, \opset)}$, $\Gr' = \graphof(\aexec')$. 
Note that $\hh_{\aexec'}$ is the unique kv-store such that $\Gr_{\hh_{\aexec'}} = \graphof(\aexec') = \Gr'$. 
It suffices to prove that $\Gr = \Gr'$. Because the function $\Gr_{\cdot}$ is injective, it follows that 
$\updateKV(\hh_{\aexec}, \vi, \txid, \opset) = \hh_{\aexec'}$, as we wanted to prove.  

The proof is a consequence of \cref{lem:graph.extend} and \cref{lem:graph.update}. 
Consider the dependency graph $\Gr_{\hh_{\aexec}}$.
Recall that $\hh_{\aexec}$ is the unique key-value store such that $\Gr_{\hh_{\aexec}} = \graphof(\aexec)$. 
We prove that $\TtoOp{T}_{\Gr} = \TtoOp{T}_{\Gr'}$, $\RF_{\Gr} = \RF_{\Gr'}$ and 
$\VO_{\Gr} = \VO_{\Gr'}$ (from the last two it follows that $\AD_{\Gr} = \AD_{\Gr'}$). 
\begin{itemize}
\item It is easy to see $\TtoOp{T}_{\Gr} = \TtoOp{T}_{\Gr'}$.

\item $\RF_{\Gr} = \RF_{\Gr'}$.
Let \( \mkvs  = \mkvs_\aexec \).
Suppose that $\txid' \xrightarrow{\RF_{\Gr}(\ke)} \txid''$ for some $\txid', \txid''$. 
By \cref{lem:graph.update} we have that either $\txid' \xrightarrow{\RF_{\Gr_\hh}(\ke)} \txid''$, 
or $\txid'' = \txid$, $(\otR, \ke, \_) \in \opset$, $\txid' = \max_{\VO_{\Gr_\hh}(\ke)}\{\WTx(\ke, i) \mid i \in \vi(\ke)\}$. 

\begin{itemize}
\item If $\txid' \xrightarrow{\RF_{\Gr_\hh}(\ke)} \txid''$, then because 
$\Gr_\mkvs = \graphof(\aexec)$, we have that $\txid' \xrightarrow{\RF_{\graphof(\aexec)}(\ke)} \txid''$. 
Recall that $\Gr' = \graphof(\extend(\aexec, \T, \txid, \opset))$, hence by \cref{lem:graph.extend} 
we obtain that $\txid' \xrightarrow{\RF_{\Gr'}(\ke)} \txid''$. 

\item If $\txid'' = \txid$, $(\otR, \ke, \_) \in \opset$, and $\txid' = \max_{\VO_{\Gr_\mkvs}(\ke)} \{ \WTx(\hh_{\aexec}(\ke, i)) \mid i \in \vi(\ke)\}$, 
then we also have that $\txid' = \max_{\VO_{\graphof(\aexec)}(\ke)} (\T \cap \{ \txid''' \mid (\otW, \ke, \_) \in_{\aexec} \txid'''\}) $. 
This is because of the assumption that 
\[
\begin{array}{l}
\{\WTx(\hh_{\aexec}(\ke, i)) \mid i \in \vi(\ke)\}  \\
\quad = \{\WTx(\hh_{\aexec}(\ke', i)) \mid \ke' \in \Keys \wedge i \in \vi(\ke')\} \cap \{\WTx(\hh_{\aexec}(\ke, \_)\} \\
\quad = \Tx(\hh_{\aexec}, \vi) \cap \{\WTx(\hh_{\aexec}(\ke, \_)\}  \\
\quad = \T \cap \{(\txid''' \mid (\otW, \ke, \_) \in_{\aexec} \txid''')\}
\end{array}
\]
Again, it follows from \cref{lem:graph.extend} that $\txid' \xrightarrow{\RF_{\Gr'}(\ke)} \txid''$. 
\end{itemize}
\item \( \VO_{\Gr} = \VO_{\Gr'}\). The \( \VO_{\Gr} = \VO_{\Gr'} \) follows the similar reasons as $\RF_{\Gr} = \RF_{\Gr'}$.
\end{itemize}
\end{proof}

\begin{lemma}[Graph extension]
\label{lem:graph.extend}
Let $\aexec$ be an abstract execution, 
%$\cl$,  be a client such that $\txid \in \nextTxid(\cl, \T_{\aexec})$, 
$\txid \notin \T_{\aexec} \cup \{\txid_0\}$ be a transaction identifier $\T_{\aexec}$, and $\opset \in \Tx$. 
Let $\T \subseteq \T_{\aexec}$ be a set of transaction identifiers.
%\ac{$\nextTxId$ has been defined only for kv-stores, it must be defined for sets of transactions.}
Define $\Gr := \graphof(\aexec), \Gr' := \graphof(\extend(\aexec, \txid, \T, \opset))$. 
We have the following: 
\begin{enumerate}
\item for any $\txid' \in \T_{\Gr'}$, either $\txid' \in \T_{\Gr}$ and $\TtoOp{T}_{\Gr}(\txid') = \TtoOp{T}_{\Gr'}(\txid')$, 
or $\txid' = \txid$ and $\TtoOp{T}_{\Gr'}(\txid) = \opset$.
\item $\txid' \xrightarrow{\RF_{\Gr'}(\ke)} \txid''$ if and only if either 
$\txid' \xrightarrow{\RF_{\Gr}(\ke)_{\Gr}} \txid''$, or $(\otR, \ke, \_) \in \opset$, $\txid'' = \txid$ and 
$\txid' = \max_{\VO_{\Gr}(\ke)}(\T)$, 
\item $\txid' \xrightarrow{\VO_{\Gr'}(\ke)} \txid''$ if and only if 
either $\txid' \xrightarrow{\VO_{\Gr}(\ke)} \txid''$, or $(\otW, \ke, \_) \in \opset$, $\txid'' = \txid$, 
and $(\otW, \ke, \_) \in_{\Gr} \txid'$.
\end{enumerate}
\end{lemma}

\begin{proof}
Fix a key $\ke$. Let $\aexec' = \extend(\aexec, \txid, \T, \opset)$. Recall that $\Gr' = \graphof(\aexec')$.

\begin{enumerate}
\item By definition of $\extend$, and 
because $\txid \notin \T_{\aexec}$, we have that 
$\T_{\aexec'} = \T_{\aexec} \uplus \{\txid\}$. Furthermore, $\TtoOp{T}_{\aexec'}(\txid) = \opset$, 
from which it follows that $\TtoOp{T}_{\Gr'}(\txid) = \opset$.
For all $\txid' \in \T_{\aexec}$, we have that $\TtoOp{T}_{\aexec'}(\txid') = 
\TtoOp{T}_{\aexec}(\txid') = \TtoOp{T}_{\Gr}(\txid')$.
\item
Suppose that $\txid' \xrightarrow{\RF(\ke)_{\Gr}} \txid''$ for some $\txid', \txid'' \in \T_{\Gr}$. 
By definition, $(\otR, \ke, \_) \in_{\aexec} \txid''$,  
and $\txid' = \max_{\AR_{\aexec}}(\VIS_{\aexec}^{-1}(\txid'') \cap \{\txid''' \mid (\otW, \ke, \_) \in_{\aexec} \txid'''\})$. 
Because $\txid'' \in \T_{\Gr} = \T_{\aexec}$, it follows that $\txid'' \neq \txid$. By definition, 
$\VIS^{-1}_{\aexec'}(\txid'') = \VIS^{-1}_{\aexec}(\txid)$: also, whenever 
$\txid_{a}, \txid_{b} \in \VIS^{-1}_{\aexec'}(\txid)$ we have that $\txid_{a}, \txid_{b} \in \T_{\aexec}$, 
and therefore if $\txid_{a} \xrightarrow{\AR_{\aexec'}} \txid_{b}$, then it must be the case 
that $\txid_{a} \xrightarrow{\AR_{\aexec}} \txid_b$; also, $\TtoOp{T}_{\aexec}(\txid_{a}) = \TtoOp{T}_{\aexec'}(\txid_{a})$. 
As a consequence, we have that 
\[\max_{\AR_{\aexec'}}(\VIS^{-1}_{\aexec'}(\txid) \cap \{ \txid''' \mid (\otW, \ke, \_) \in_{\aexec'} \txid'''\}) = 
\max_{\AR_{\aexec}}(\VIS^{-1}_{\aexec}(\txid) \cap \{ \txid''' \mid (\otW, \ke, \_) \in_{\aexec} \txid'''\}) = \txid', \] 
and therefore $\txid' \xrightarrow{\RF_{\Gr'}} \txid$. 

Suppose now that $(\otR,\ke, \_) \in \opset$, and $\txid' = \max_{\VO(\ke)_{\Gr}}(\T)$. 
By Definition, $\txid' = \max_{\AR_{\aexec}}(\T) \cap \{ \txid''' \mid (\otW, \ke, \_) \in_{\aexec} \txid'''\}$, 
Also, $\T = \VIS^{-1}_{\aexec'}(\txid)$, and because $\T \subseteq \T_{\aexec}$, we have 
that for any $\txid_{a}, \txid_{b}$, if $\txid_{a} \xrightarrow{\AR_{\aexec}} \txid_{b}$, 
then $\txid_{a} \xrightarrow{\AR_{\aexec'}} \txid_{b}$; and $\TtoOp{T}_{\aexec'}(\txid_{a}) = 
TtoOp{T}_{\aexec}(\txid_a)$. Therefore, 
\[
\txid' = \max_{\AR_{\aexec'}}(\VIS^{-1}_{\aexec'}(\txid) \cap \{ \txid''' \mid (\otW, \ke, \_) \in_{\aexec'} \txid'''\}, 
\] 
from which it follows that $\txid' \xrightarrow{\RF_{\Gr'}(\ke)}\txid$.

Now, suppose that $\txid' \xrightarrow{\RF_{\Gr'}(\ke)} \txid''$ for some $\txid', \txid'' \in \T_{\Gr'} = 
\T_{\aexec'}$. We have that $ (\otR, \ke, \_) \in_{\aexec'} \txid''$, 
$(\otW, \ke, \_) \in_{\aexec'} \txid'$, and $\txid'' = \max_{\AR_{\aexec'}}(\VIS_{\aexec'}^{-1}(\txid'') 
\cap \{ \txid''' \mid (\otW, \ke, \_) \in_{\aexec'} \txid'''\}$. 
We also have that $\T_{\aexec'} = \T_{\aexec} \uplus \{\txid\}$. We perform a case 
analysis on $\txid''$. 

If $\txid'' = \txid$, then by definition of $\extend$ we have that 
$\VIS^{-1}_{\aexec'}(\txid) = \T$. Note that $\T \subseteq \T_{\aexec}$, so that 
for any $\txid_{a}, \txid_{b} \in \T_{\aexec}$, we have that $\txid_{a} \xrightarrow{\AR_{\aexec'}} \txid_{b}$ 
if and only if $\txid_{a} \xrightarrow{\AR_{\aexec}} \txid_{b}$, 
and $(\otW, \ke, \val) \in_{\aexec'} \txid_{a}$ if and only if $(\otW, \ke, \val) \in_{\aexec} \txid_{a}$. 
Thus, $\txid' = \max_{\AR_{\aexec}}(\T 
\cap \{\txid''' \mid (\otW, \ke, \_) \in_{\aexec} \txid'''\}) = \max_{\VO_{\Gr}(\ke)}(\T)$. 

If $\txid'' \in \T_{\aexec}$, then it is the case that 
$\txid' = \max_{\AR_{\aexec'}}(\VIS^{-1}_{\aexec'}(\txid'') \cap \{ \txid''' \mid (\otW, \ke, \_) \in_{\aexec'} \txid'''\}$. 
Similarly to the case above, we can prove that $\VIS^{-1}_{\aexec'}(\txid'') = \VIS^{-1}_{\aexec}(\txid)$, 
for any $\txid_{a}, \txid_{b} \in \VIS^{-1}_{\aexec}(\txid)$, $(\otW, \ke, \val) \in_{\aexec'} \txid_{a}$ 
implies $(\otW, \ke, \val) \in_{\aexec} \txid_{a}$, and $\txid_{a} \xrightarrow{\AR_{\aexec'}} \txid_{b}$ 
implies $\txid_{a} \xrightarrow{\AR_{\aexec}} \txid_{b}$, from which it follows that 
$\txid' = \max_{\AR_{\aexec}}(\VIS^{-1}_{\aexec}(\txid'') \cap \{ \txid''' \mid (\otW, \ke \_) \in_{\aexec} \txid'''\})$, 
and therefore $\txid' \xrightarrow{\RF_{\Gr}(\ke)} \txid''$.

\item Suppose that $\txid' \xrightarrow{\VO_{\Gr}(\ke)} \txid''$ for some $\txid', \txid'' \in \T_{\aexec}$. 
Then $(\otW,\ke,\_) \in_{\aexec} \txid', (\otW, \ke, \_) \in_{\aexec} \txid''$, and $\txid' \xrightarrow{\AR_{\aexec}} \txid''$. 
By definition of $\extend$, it follows that $\txid' \xrightarrow{\AR_{\aexec'}} \txid''$, and because 
$\txid', \txid'' \in \T_{\aexec}$, hence $\txid', \txid'' \neq \txid$, then 
$(\otW,\ke, \_) \in_{\aexec'} \txid'$, $(\otW, \ke, \_) \in_{\aexec'} \txid''$. By definition, 
we have that $\txid' \xrightarrow{\VO_{\aexec'}(\ke)} \txid''$.

Suppose that $(otW, \ke, \_) \in_{\aexec} \txid'$, $(\otW, \ke, \_) \in \opset$. Because $\txid' \in \T_{\aexec}$, 
we have that $\txid' \neq \txid$, hence $(\otW, \ke, \_) \in_{\aexec' }\txid'$. By definition, 
$\TtoOp{T}_{\aexec'}(\txid) = \opset$, hence $(\otW, \ke, \_) \in_{\aexec'} \txid$. Finally, 
the definition of $\extend$ ensures that $\txid' \xrightarrow{\AR_{\aexec'}} \txid$. Combining 
these three facts together, we obtain that  
$\txid' \xrightarrow{\VO_{\Gr'}(\ke)} \txid$. 

Now, suppose that $\txid' \xrightarrow{\VO_{\Gr'}(\ke)} \txid''$ for some $\txid', \txid'' \in \T_{\aexec}$. 
Then $\txid' \xrightarrow{\AR_{\aexec'}} \txid''$, $(\otW, \ke, \_) \in_{\aexec'} \txid'$, $(\otW, \ke, \_) 
\in_{\aexec'} \txid''$. 
Recall that $\T_{\Gr'} = \T_{\aexec'} = \T_{\aexec} \uplus \{ \txid \}$. We perform a case analysis on $\txid''$. 

If $\txid'' = \txid$, then the definition of $\extend$ ensures that $\txid' \xrightarrow{\AR_{\aexec'}} \txid$ 
implies that $\txid \in \T_{\aexec}$, hence $\txid' \neq \txid$. 
Together with $(\otW, \ke, \_) \in_{\aexec'} 
\txid'$, this leads to $(\otW, \ke, \_) \in_{\aexec} \txid'$. 

If $\txid'' \in \T_{\aexec}$, then $\txid'' \neq \txid$. The definition of $\extend$ ensures that $\txid' \xrightarrow{\AR_{\aexec}} \txid''$. 
This implies that $\txid', \txid'' \in \T_{\aexec}$, hence $\txid', \txid'' \neq \txid$, and $\TtoOp{T}_{\aexec'}(\txid') = \TtoOp{T}_{\aexec}(\txid')$, 
$\TtoOp{T}_{\aexec'}(\txid'') = \TtoOp{T}_{\aexec}(\txid'')$. It follows that $(\otW, \ke, \_) \in_{\aexec} \txid'$, 
$(\otW, \ke, \_) \in_{\aexec} \txid''$, and therefore $\txid' \xrightarrow{\VO_{\Gr}}(\ke) \txid''$.

\end{enumerate}
\end{proof}


\begin{lemma}[Graph update]
\label{lem:graph.update}
Let $\hh$ be a kv-store, and $\vi \in \Views(\hh)$. Let $\txid \notin \hh$, and 
$\opset \subseteq \powerset{\Ops}$, and let $\hh' = \updateKV(\hh, \vi, \txid, \opset)$. 
Let $\Gr = \Gr_{\hh}$, $\Gr' = \Gr_{\hh'}$; then for all $\txid', \txid'' \in \T_{\Gr'}$ and keys $\ke$, 
\begin{itemize}
\item $\TtoOp{T}_{\Gr'} = \TtoOp{T}_{\Gr}\rmto{\txid}{\opset}$, 
\item $\txid' \xrightarrow{\RF_{\Gr'}(\ke)} \txid''$ if and only if either 
$\txid' \xrightarrow{\RF_{\Gr}(\ke)} \txid''$, or $(\otR, \ke, \_) \in \opset$ and 
$\txid' = \max_{\VO_{\Gr}(\ke)}(\{\WTx(\hh(\ke, i)) \mid i \in \vi(\ke)\})$, 
\item $\txid' \xrightarrow{\VO_{\Gr'}(\ke)} \txid''$ if and only if either 
$\txid' \xrightarrow{\VO_{\Gr}(\ke)} \txid''$, or $(\otW, \ke, \_) \in \opset$ 
and $\txid' = \WTx(\hh(\ke, \_))$. 
\end{itemize}

\end{lemma}

\begin{proof}
Fix $\ke \in \Keys$. Because $\txid \notin \hh$, then $\txid \notin \T_{\Gr}$, 
and by definition of $update$ we obtain that $\{\txid' \mid \txid' \in \hh'\} = 
\{\txid' \mid \txid' \in \hh\} \cup \{\txid\}$. It follows that $\T_{\Gr'} = \T_{\Gr} \uplus \{\txid \}$.

\begin{enumerate}
\item Suppose that $(\otR, \ke, \val) \in_{\Gr} \txid'$. By definition, 
there exists an index $i = 0,\cdots, \lvert \hh(\ke) \rvert - 1$ such 
that $\hh(\ke, i) = (\val, \_, \{\txid'\} \cup \_)$. Because $\hh' = \updateKV(\hh, \vi, \txid, \opset)$, 
it is immediate to observe that $\hh'(\ke, i) = (\val, \_, \{\txid'\} \cup \_)$, and therefore 
$(\otR,\ke, \val) \in_{\Gr'} \txid'$. Conversely, note that if $(\otR, \ke, \val) \in_{\Gr'} \txid$, 
then there exists an index $i = 0,\cdots, \lvert \hh'(\ke) \rvert - 1$ such that 
$\hh'(\ke, i) = (\val, \_, \{\txid'\} \cup \_)$. As a simple consequence of \cref{cor:updatekv.singlecell} 
it follows that it must be the case that $i \leq \lvert \hh(\ke) \rvert - 1$, and because 
$\txid' \neq \txid$, we have that $\hh(\ke, i) = (\val, \_, \{\txid'\} \cup \_)$. Therefore 
$(\otR, \ke, \val) \in_{\Gr} \txid'$. 

Similarly, if $(\otW, \ke, \val) \in_{\Gr} \txid'$, 
then there exists an index $i=0,\cdots, \lvert \hh(\ke) \rvert - 1$ such that 
$\hh(\ke, i) = (\val, \txid', \val)$. It follows that $\hh'(\ke, i) = (\val, \txid', \_)$, hence 
$(\otW, \ke, \val) \in_{\Gr'} \txid'$. If $(\otW, \ke, \val) \in \opset$, then we 
have from \cref{cor:updatekv.singlecell} that $\hh'(\ke, \lvert \hh'(\ke) \rvert - 1) = (\val, \txid', \_)$, 
hence $(\otW, \ke, \val) \in_{\Gr'} \txid'$. 
Conversely, if $(\otW, \ke, \val) \in_{\Gr'} \txid'$, then there exists an index 
$i = 0, \cdots, \lvert \hh'(\ke) \rvert - 1$ such that $\hh(\ke, i) = (\val, \txid', \_)$. 
We have two possible cases: either $i < \lvert \hh'(\ke, i) \rvert - 1$, leading to  
$\txid' \neq \txid$ and $\hh(\ke, i) = (\val, \txid', \_)$, or equivalently 
$(\otR,\ke, \val) \in_{\Gr} \txid'$; or $i = \lvert \hh'(\ke, i) \rvert - 1$, 
leading to $\txid' = \txid$, and $\hh(\ke, i) = (\val, \txid, \emptyset)$ 
for some $\val$ such that $(\otW, \ke, \val) \in \opset$. 

Putting together the facts above, we obtain that $\TtoOp{T}_{\Gr'} = 
\TtoOp{T}_{\Gr}\rmto{\txid}{\opset}$, as we wanted to prove.

\item Suppose that $\txid' \xrightarrow{\RF_{\Gr}(\ke)} \txid''$. 
By definition, there exists an index $i = 0,\cdots, \lvert \hh(\ke) \rvert - 1$ 
such that $\hh(\ke, i) = (\_, \txid', \{\txid''\} \cup \_)$. It is immediate 
to observer, from the definition of $\updateKV$, that $\hh'(\ke, i) = (\_, \txid', \{\txid''\} \cup \_)$, 
and therefore $\txid' \xrightarrow{\RF_{\Gr'}(\ke)} \txid''$. 

Next, suppose that $(\otR, \ke, \_) \in \opset$, and $\txid' = \max_{\VO_{\Gr}(\ke)}(\{\WTx(\hh(\ke, i)) \mid i \in \vi(\ke)\}$. 
By Definition, $\hh(\ke, i) = (\_, \txid', \_)$, where $i = \max(\vi(\ke))$. This is because 
$\txid' \rightarrow{\VO_{\Gr}(\ke)} \txid''$ if and only if $\txid' = \WTx(\hh(\ke, j_1)), \txid'' = 
\WTx(\hh(\ke, j_2))$ for some $j_1, j_2$ such that $j_1 < j_2$. 
The definition of $\updateKV$ now ensures that $\hh'(\ke, i) = (\_, \txid', \{\txid \} \cup \_)$, 
from which it follows that $\txid' \xrightarrow{\RF_{\Gr'}(\ke)} \txid$.

Conversely, suppose that $\txid' \xrightarrow{\RF_{\Gr'}(\ke)} \txid''$. 
Recall that $\T_{\Gr'} = \T_{\Gr} \cup \{ \txid \}$, hence either 
$\txid'' \in \T_{\Gr}$ or $\txid'' = \txid$. 

If $\txid'' = \txid$, then it must be the case that there exists an index $i = 0,\cdots, \lvert \hh'(\ke) \rvert - 1$ 
such that $\hh'(\ke, i) = (\_, \txid', \{\txid \} \cup \_)$. Note that if $\hh'(\ke, \lvert \hh'(\ke) \rvert -1)$ is 
defined, then it must be the case that $\hh'(\ke, \lvert \hh'(\ke) \rvert -1) = (\_, \txid, \emptyset)$, 
hence it must be the case that $i < \lvert \hh'(\ke) \rvert - 1$. Because $\txid \notin \hh$, 
then by the definition of $\updateKV$ it must be the case that $(\otR, \ke, \_) \in \opset$, 
$\hh(\ke, i) = (\_, \txid', \_)$ and $i = \max(\vi(\ke))$; this also implies that $\txid' = 
\max_{\VO(\ke)}\{\WTx(\hh(\ke, i)) \mid i \in \vi(\ke)\}$. 

If $\txid'' \in \T_{\Gr}$, then  it must be the case that $\txid'' \neq \txid$. 
In this case, it also must exist an index $i = 0,\cdots, \lvert \hh'(\ke) \rvert - 1$ 
such that $\hh'(\ke, i) = (\_, \txid', \{\txid''\} \cup \_)$. As in the previous 
case, we note that $i < \lvert \hh'(\ke) \rvert - 1$, which together 
with the fact that $\txid'' \neq \txid$ leads to $\hh(\ke, i) = (\_, \txid', \{\txid''\} \cup \_)$. 
It follows that $\txid' \xrightarrow{\RF_{\Gr}(\ke)} \txid''$.

\item Suppose that $\txid' \xrightarrow{\VO_{\Gr}(\ke)} \txid''$. 
By definition, there exist two indexes $i, j$ such that 
$\hh(\ke, i) = (\_, \txid', \_)$, $\hh(\ke, j) = (\_, \txid'', \_)$ 
and $i < j$. The definition of $\updateKV$ ensures that 
$\hh'(\ke, i) = (\_, \txid', \_)$, $\hh'(\ke, j) = (\_, \txid'', \_)$, 
and because $i < j$ we obtain that $\txid' \xrightarrow{\VO_{\Gr'}(\ke)} \txid''$. 

Suppose that $(\otW, \ke, \_) \in \opset$. Then $\hh'(\ke, \lvert \hh(\ke) \rvert) = (\_, \txid, \_)$.
Let $\txid' \in \T_{\Gr}$; by definition there exists an index $i = 0,\cdots, \lvert \hh(\ke) \rvert$ 
such that $\hh(\ke, i) = (\_, \txid', \_)$. It follows that $\hh'(\ke, i) = (\_, \txid', \_)$, and 
because $i < \lvert \hh(\ke) \rvert$, then we have that $\txid' \xrightarrow{\VO_{\Gr'}(\ke)} \txid$. 

Conversely, suppose that $\txid' \xrightarrow{\VO_{\Gr'}(\ke)} \txid''$. Because 
$\T_{\Gr'} = \T_{\Gr} \cup \{ \txid \}$, we have two possibilities. Either $\txid'' = \txid$, 
or $\txid'' \in \T_{\Gr}$. 

If $\txid'' = \txid$, then it must be the case that $(\otW, \ke, \_) \in_{\Gr'} \txid$, 
or equivalently there exists an index $i=0,\cdots, \lvert \hh'(\ke) \rvert -1 $ such that 
$\hh'(\ke, i) = (\_, \txid, \_)$. Because $\txid \notin \hh$, and because for any 
$i = 0, \cdots, \lvert \hh(\ke) \rvert - 1$, $\hh'(\ke, i) = (\_, \txid, \_) \implies 
\hh(\ke, i) = (\_, \txid, \_)$, then it necessarily has to be $i = \hh'(\ke) \rvert - 1$. 
According to the definition of $\updateKV$, this is possible only if $(\otW,\ke, \_) \in \opset$. 
Finally, note that because $\txid' \xrightarrow{\VO_{\Gr'}(\ke)} \txid$, then 
there exists an index $j < \lvert \hh'(\ke, i) \rvert - 1$ such that 
$\hh'(\ke, j) = (\_, \txid' ,\_)$. The fact that $j < \lvert \hh'(\ke, i) \rvert - 1$ 
From \cref{cor:updatekv.singlecell} we obtain that $\hh(\ke, j) = (\_, \txid', \_)$, 
or equivalently $\txid' = \WTx(\hh(\ke, \_))$. 

If $\txid'' \in \T_{\Gr}$, then there exist two indexes $i,j$ such that 
$j < \lvert \hh'(\ke, j) \rvert - 1$, $\hh'(\ke, j) = (\_, \txid'', \_)$, 
$i < j$, and $\hh'(\ke, i) = (\_, \txid', \_)$. It is immediate to observe 
that $\hh(\ke, i) = (\_, \txid', \_)$, $\hh(\ke, j) = (\_, \txid'', \_)$, 
from which $\txid' \xrightarrow{\VO_{\Gr}(\ke)} \txid''$ follows. 

\end{enumerate}
\end{proof}





Next, we show to construct, given an abstract execution $\aexec$, 
a set of $\ET_{\top}$-traces $\KVtrace(\ET_{\top}, \aexec)$ in normal form such that for any 
$\tr \in \KVtrace(\ET_{\top}, \aexec)$, $\lastConf(\tr) = (\hh_{\aexec}, \_)$. 
To define the function $\KVtrace(\ET_{\top}, \_)$ formally, 
we first provide a principle to reason about abstract executions inductively in \cref{def:aexec.inductive}. 

\begin{definition}
\label{def:aexec.inductive}
Let $\aexec$ be an abstract execution, let $n = \lvert \T_{\aexec} \rvert$, and let 
$\{\txid_{i}\}_{i=1}^{n} \subseteq \T_{\aexec}$ be such that for any $i=1,\cdots,n-1$, 
$\txid_{i} \xrightarrow{\AR_{\aexec}} \txid_{i+1}$. 
For $i = 0,\cdots, n-1$, define 
\[
\begin{array}{lll}
\cut(\aexec, 0) & \defeq & ([], \emptyset, \emptyset)\\
\cut(\aexec , i+1) & \defeq & \extend(\cut(\aexec, i), \txid_{i+1}, \VIS^{-1}_{\aexec}(\txid_{i+1}), \TtoOp{T}_{\aexec}(\txid_{i+1}))
\end{array}
\]
\end{definition}

\begin{proposition}
\label{prop:aexec.inductive}
For any abstract execution $\aexec$, $\aexec = \cut(\aexec, \lvert \T_{\aexec} \rvert)$.
\end{proposition}
\begin{proof}
    This is now an instantiation of \cref{lem:cut.explicit}, choosing $i = \lvert \T_{\aexec} \rvert$. \qed
\end{proof}

\begin{lemma}
\label{lem:cut.explicit}
For any abstract execution $\aexec$, and index $i: i \leq j \leq \lvert \T_{\aexec} \rvert$, 
let $\T_{\aexec} = \{\txid_{i}\}_{i=1}^{n}$ be such that $\txid_{1} \xrightarrow{\AR_{\aexec}}
\txid_{n}$. Then $\cut(\aexec, i) = \aexec_{i}$, where 
\[
\begin{array}{lcr}
\TtoOp{T}_{\aexec_{i}}(\txid) &=& 
\begin{cases}
\TtoOp{T}_{\aexec}(\txid) &\impliedby \exists j \leq i.\; \txid = \txid_{j}\\
\text{undefined} &\impliedby \text{otherwise}\\
\end{cases}
\\
\VIS_{\aexec_{i}} &=& \{ (\txid, \txid') \in \T_{\aexec_{i}} \mid \txid \xrightarrow{\VIS_{\aexec}} \txid'\}\\
\AR_{\aexec_{i}} &=& \{ (\txid, \txid') \in \T_{\aexec_{i}} \mid \txid \xrightarrow{\AR_{\aexec}} \txid'\}
\end{array}
\]
\end{lemma}

\begin{proof}
Fix an abstract execution $\aexec$. We prove the claim by induction on $i = \lvert \T_{\aexec} \rvert$.
\begin{itemize}
\item Base case: $i = 0$. Then note that $\TtoOp{T}_{\aexec'} = [], \VIS_{\aexec'} = \emptyset$, 
$\AR_{\aexec'} = \emptyset$, which leads to $\aexec' = \cut(\aexec, 0)$. 
\item Let $i = i' + 1$, and assume that $\cut(\aexec, i') = \aexec_{i'}$. 
We prove the following: 
\begin{enumerate}
\item $\TtoOp{T}_{\cut(\aexec, i)} = \TtoOp{T}_{\aexec_i}$. 
By definition, 
\[
\begin{array}{lr}
\TtoOp{T}_{\cut(\aexec,i)} = \TtoOp{T}_{\cut(\aexec, i')}\rmto{\txid_{i}}{\TtoOp{T}_{\aexec}(\txid_{i})} &= \\
\TtoOp{T}_{\aexec_{i'}}\rmto{\txid_{i}}{\TtoOp{T}_{\aexec}}(\txid_{i}) = \TtoOp{T}_{\aexec_{i}}
\end{array}
\]
\item $\VIS_{\cut(\aexec, i)} = \VIS_{\aexec_{i}}$. 
Note that, by inductive hypothesis, $\T_{\cut(\aexec, i')} = \T_{\aexec_{i'}} = \{\txid_{j}\}_{j=1}^{i'}$. 
We have that  
\[
\begin{array}{lr}
\VIS_{\cut(\aexec, i)} = \VIS_{\cut(\aexec, i')} \cup \{(\txid_j, \txid_{i}) \in \VIS_{\aexec} \mid j = 1,\cdots, i'\} &= \\
\VIS_{\aexec_{i'}} \cup \{(\txid_{j}, \txid_{i}) \in \VIS_{\aexec} \mid j=1,\cdots, i'\} = 
\{(\txid_{j'}, \txid_{j}) \in \VIS_{\aexec} \mid j', j = 0,\cdots, i'\} \cup \{(\txid_{j}, \txid_{i} \in \VIS_{\aexec} \mid j=1,\cdots, i'\} &=\\
\{(\txid_{j'}, \txid_{j} \in \VIS_{\aexec} \mid j',j = 0,\cdots, i\} = \VIS_{\aexec_{i}}.
\end{array}
\]
\item $\AR_{\cut(\aexec, i)} = \AR_{\aexec_{i}}$. This can be proved in the same way 
as the item above. 
\end{enumerate}
\end{itemize}
\end{proof}

Given above, the conversion from abstract execution tests to \( \ET \) traces is in \cref{def:aexec2kvtrace}.

\begin{definition}
\label{def:aexec2kvtrace}
Given an abstract execution $\aexec$, a client $\cl$ and an integer $i=0,\cdots, \lvert \aexec \rvert$, 
define $\nextTx(\aexec, \cl, i) \defeq \min_{\AR_{\aexec}}\{\txid_{\cl}^{j} \mid \txid_{\cl}^{n} \notin \T_{\cut(\aexec, i)}\}$. 
Note that $\nextTx(\aexec, \cl, i)$ could be undefined. 
Let $\Clients(\aexec) \defeq \{\cl \mid \exists n.\;\txid_{\cl}^{n} \in \T_{\aexec}\}$.

Given an abstract execution $\aexec$ and an integer $i = 0,\cdots, \lvert \T_{\aexec} \rvert$, let 
$\KVtrace(\ET_{\top}, \aexec, i)$ be the smallest set such that 
\begin{itemize}
\item 
$(\hh_{0}, \lambda \cl \in \Clients(\aexec). \lambda \ke.\{0\}) \in \KVtrace(\ET_{\top}, \aexec, 0)$, 
\item suppose that $\tr \in \KVtrace(\ET_{\top}, \aexec, i)$ for some $i = 0,\cdots, \lvert \T_{\aexec} \rvert - 1$.  
Let
\begin{itemize} 
\item $\txid = \min_{\AR_{\aexec}}(\T_{\aexec} \setminus T_{\cut(\aexec, i)})$, 
\item  $\cl, n$ be such that $\txid = \txid_{\cl}^{n}$, 
\item  $\vi = \getView(\aexec, \VIS^{-1}_{\aexec}(\txid_{\cl}^{n}))$, 
\item $\vi' = \getView(\aexec, \T)$, where $\T$ is an arbitrary subset of $\T_{\aexec}$ if 
$\nextTx(\aexec, \cl, i+1)$ is undefined, or is such that 
$\T \subseteq (\AR_{\aexec}^{-1})?(\txid) \cap \VIS^{-1}_{\aexec}(\nextTx(\cl, i+1))$, 
\item $\opset = \TtoOp{T}_{\aexec}(\txid)$, 
\item $(\hh_{\tr}, \viewFun_{\tr}) = \lastConf(\tr)$, 
\item $\hh = \updateKV(\hh_{\tr}, \vi, \txid, \opset)$.
\end{itemize}
Then
\[
\big( \tr \xrightarrowtriangle{(\cl, \varepsilon)}_{\ET_{\top}} (\hh_{\tr}, \viewFun_{\tr}\rmto{\cl}{\vi}) 
\xrightarrowtriangle{(\cl, \opset)}_{\ET_{\top}} (\hh, \viewFun_{\tr}\rmto{\cl}{\vi'}) \big) \in \KVtrace(\ET_{\top}, \aexec, i+1)
\]
\end{itemize}

Finally, we let $\KVtrace(\ET_{\top}, \aexec) \defeq \KVtrace(\ET_{\top}, \aexec, \lvert \T_\aexec \rvert)$.
\end{definition}

\begin{proposition}
\label{prop:aexec2kvtrace}
Let $\aexec$ be an abstract execution that satisfies $\RP_{\LWW}$, 
and let $\tr \in \KVtrace(\ET_{\top}, \aexec)$. Then $\lastConf(\tr) = (\hh_{\aexec}, \_)$ and $\hh_{\aexec} \in \CMs(\ET_{\top})$. 
\end{proposition}
\begin{proof}
Let $\aexec$ be an abstract execution that satisfies the last write wins policy. 
Let $n = \lvert \T_{\aexec} \rvert$. Fix $i =0,\cdots, n$, 
and let $\tr \in \KVtrace(\ET_{\top}, \aexec, i)$. We prove, by 
induction on $i$, that $\tr \in \CMs(\ET_{\top})$, and 
$\lastConf(\tr) = (\hh_{(\cut(\aexec, i)}, \_)$. 
Then the result follows from  \cref{prop:aexec.inductive}.

\begin{itemize}
\item Case $i = 0$. By definition, $\tr = (\kappa_{0}, \viewFun_{0})$, 
where $\viewFun_{0} = \lambda \cl \in \Clients(\aexec). \lambda \ke.\{0\}$. 
Clearly, we have that $\tr \in CMs(\ET_{\top})$. 
\item Case $i = i'+1$. Let $\txid_{i} = \min_{\AR_{\aexec}}(\T_{\aexec} \setminus \T_{\cut(\aexec, i')})$, 
and suppose that $\txid_{i} = \txid_{\cl}^{m}$ for some client $\cl$ and index $m$. 
Fix $\vi = \getView(\aexec, \VIS_{\aexec}^{-1}(\txid_{i}))$, and  $\opset = \TtoOp{T}_{\aexec}(\txid_{i})$, . 
Then there exists a trace $\tr' \in \KVtrace(\ET_{\top}, \aexec, i')$ and a set 
$\T$ such that: 
\begin{enumerate}
\item if $\nextTx(\cl, \aexec, i)$ is undefined then $\T \subseteq \T_{\aexec}$, otherwise 
$\T \subseteq \VIS^{-1}_{\aexec}(\nextTx(\cl, \aexec, i)) \cap (\AR_{\aexec}^{-1})?(\txid_{i})$, 
\item
\[
\tr = \tr' \xrightarrowtriangle{(\cl, \varepsilon)} (\hh_{\tr'}, \viewFun_{\tr'}\rmto{\cl}{\vi}) \xrightarrowtriangle{(\cl, \opset)} 
(\hh,  \viewFun_{\tr'}\rmto{\cl}{\vi'}),
\]
where $(\hh_{\tr'}, \viewFun_{\tr'}) = \lastConf(\tr')$, and $\hh = \updateKV(\hh_{\tr'}, \vi, \txid_{i}, \opset)$, 
and $\vi' = \getView(\aexec, \T)$.
\end{enumerate}
By inductive hypothesis, we may assume that $\tr' \in \CMs(\ET_{\top})$, and $\hh_{\tr'} = \hh_{\cut(\aexec, i')}$. 
We prove the following facts: 
\begin{enumerate}
\item $\hh = \hh_{\extend(\cut(\aexec, i)}$: because of 
\ref{prop:extend.update.sameop} and \cref{prop:aexec.inductive} 
we obtain 
\[
\begin{array}{lr}
\hh = \updateKV(\hh_{\tr'}, \vi, \txid_{i}, \opset) &=\\ 
\updateKV(\hh_{\cut(\aexec, i')}, \getView(\aexec, \VIS^{-1}_{\aexec}(\txid_{i}), \txid_{i}, \TtoOp{T}_{\aexec}(\txid_{i})) &=\\
\hh_{\extend(\cut(\aexec, i'), \VIS^{-1}_{\aexec}(\txid_{i}), \txid_{i}, \TtoOp{T}_{\aexec}(\txid_{i})) }&=\\
\hh_{\extend(\cut(\aexec, i))}.
\end{array}
\]

\item $(\hh_{\tr'}, \viewFun_{\tr'}) \xrightarrowtriangle{(\cl, \varepsilon)}_{\ET_{\top}} (\hh_{\tr'}, \viewFun_{\tr'}\rmto{\cl}{\vi})$. 
To this end, it suffices to prove that for any key $\ke$, $\viewFun_{\tr'}(\cl) \viewleq \vi$. 
By \cref{lem:cut.explicit} we have that $\T_{\cut(\aexec, i')} = \{\txid_{j}\}_{j=1}^{i'}$, for 
some $\txid_{1},\cdots, \txid_{i'}$ such that whenever $1 \leq j < j' \leq i'$, then 
$\txid_{j} \xrightarrow{\AR_{\aexec}} \txid_{j'}$. We consider two possible cases: 

\begin{itemize}
\item For all $j =1,\cdots, i'$, for all $h \in \nat$, $\txid_{j} \neq \txid_{\cl}^{h}$. In 
this case we have that no transition contained in $\tr'$ has the form 
$(_, \_) \xrightarrowtriangle{(\cl, \_)} (\_, \_)$, from which it is possible to infer 
that  $\viewFun_{\tr'}(\cl) = \lambda \ke. \{0\}$. Because $\vi = \getView(\aexec, \VIS^{-1}_{\aexec}(\txid_{i}))$, 
then by definition we have that $0 \in \vi(\ke)$ for all keys $\ke \in \Keys$. It follows that 
$\viewFun_{\tr'}(\cl) \viewleq \vi$. 
\item There exists an index $j = 1,\cdots, n$ and an integer $h \in \nat$ such that $\txid_{j} = \txid_{\cl}^{h}$. 
Without loss of generality, let $j$ be the largest such index. It follows that the last transition in $\tr'$ of the form 
$(\_, \_) \xrightarrow{(\cl, \opset_{j})} (\_, \viewFun_{\mathsf{pre}})$ is such that $\viewFun_{\mathsf{pre}}(\cl) = 
\getView(\aexec, \T_{\mathsf{pre}})$, for some $\T_{\mathsf{pre}} \subseteq \VIS^{-1}_{\aexec}(\txid_{i}) \cap 
(\AR^{-1}_{\aexec})?(\txid_{j})$. This is because $\nextTx(\cl, \aexec, j)$  is defined and equal to $\txid_{i}$. 
Furthermore, because the trace $\tr'$ is in normal form by construction, in $\tr'$ a transition of the form 
$(\_, \_) \xrightarrowtriangle{(\cl, \varepsilon)}_{\ET_{\top}} (\_, \_)$ is always followed by a transition of the form
$(\_, \_) \xrightarrowtriangle{(\cl, \opset')}_{\ET_{\top}} (\_, \_)$. Because we are assuming that the last transition where client 
$\cl$ executes a transaction in $\tr'$ has the form $(\_, \_) \xrightarrowtriangle{(\cl, \opset_{j})}_{\ET_{\top}} (\_, \viewFun_{\mathsf{pre}})$, 
then the latter is also the last transition for client $\cl$ in $\tr'$ (i.e. including both execution of transactions and view updates). 
It follows that $\viewFun_{\tr'}(\cl) = \viewFun_{\mathsf{pre}}(\cl)$, and in particular 
$\viewFun_{\tr'}(\cl) = \getView(\aexec, \T_{\mathsf{pre}})$. By definition, 
$\T_{\mathsf{pre}} \subseteq  \VIS^{-1}_{\aexec}(\txid_{i}) \cap (\AR^{-1}_{\aexec})?(\txid_{j}) 
\subseteq \VIS^{-1}_{\aexec}(\txid_{i})$. By  \cref{lem:getView.monotone}, 
we have that $\viewFun_{\tr'}(\cl) = \getView(\aexec, \T_{\mathsf{pre}}) \viewleq 
\getView(\aexec, \VIS^{-1}_{\aexec}(\txid_{i})) = \vi$, as we wanted to prove.
\ac{Note: this is more a sketch, rather than a real proof. A Proposition giving an explicit form to the 
structure of any $\tr \in \KVtrace(\ET_{\top}, \aexec)$ would be helpful for a more rigorous proof here.}
\end{itemize}


\item $(\hh_{\tr'}, \viewFun_{\tr'}\rmto{\cl}{\vi}) \xrightarrowtriangle{(\cl, \opset)}_{\ET_{\top}} 
(\hh,  \viewFun_{\tr'}\rmto{\cl}{\vi'})$. It suffices to show that $\ET_{\top} \vdash (\hh_{\tr'}, \vi) 
\triangleright \opset: \vi'$. That is, it suffices to show that $\vi \in \Views(\hh_{\tr'})$, 
$\vi' \in \Views(\hh)$, and whenever $(\otR, \ke, \val) \in \opset$, then 
$\max_{<}(\vi(\ke)) = (\val, \_, \_)$. The first two facts are a consequence of 
\ref{lem:cut.views}, the fact that $\hh_{\tr'} = \hh_{\cut(\aexec, i')}$, and the fact that 
$\hh_{\cut(\aexec, i)}$. The fact that if $(\otR, \ke, \val) \in \opset$ then 
$\max_{<}(\vi(\ke) = (\val, \_, \_)$ follows from the fact that $\aexec$ satisfies 
the last write wins policy, and the fact that $\vi = \getView(\VIS^{-1}_{\aexec}(\txid_{i})$.
\ac{Again, the proof is really loose here, mostly because I got bored.}
\end{enumerate} 

\end{itemize}
\end{proof}


\begin{lemma}
\label{lem:getView.monotone}
Let $\aexec$ be an abstract execution, and let $\T_1 \subseteq \T_2 \subseteq \T_{\aexec}$. 
Then $\getView(\aexec, \T_1) \viewleq \getView(\aexec, \T_2)$.
\end{lemma}
\begin{proof}
Fix $\ke \in \Keys$. By definition  
\[
\begin{array}{lr}
\getView(\aexec, \T_1)(\ke) = \{0\} \cup \{ i \mid i = 1,\cdots, \lvert \hh_{\aexec}(\ke) \rvert - 1 \wedge \WTx(\hh_{\aexec}(\ke, i)) \in \T_1\} &\subseteq\\
\{0\} \cup \{i \mid i=1,\cdots, \lvert \hh_{\aexec}(\ke) \rvert - 1 \wedge \WTx(\hh_{\aexec}(\ke, i)) \in \T_2\} & = \\
\getView(\aexec, \T_2)(\ke).
\end{array}
\]
It follows that  $\getView(\aexec, \T_1) \viewleq \getView(\aexec, \T_2)$.
\end{proof}

Now we can prove \cref{thm:kvtrace2aexec}.
The last statement in \cref{thm:kvtrace2aexec} implies that there is a \emph{Galois connection}
between the set of $\ET_{\top}$-traces, and the set of abstract executions that satisfy the 
last write wins policy. The lower and upper adjoints of this connection are the 
lifting of the functions $\aeset(\cdot)$ and $\KVtrace(\cdot)$ to sets of $\ET_{\top}$-traces 
and abstract executions, respectively. Note however that these two sets are not isomorphic: 
when converting a set of abstract executions into kv-traces, we abstract away the 
pairs $\txid \xrightarrow{\VIS} \txid'$ in the visibility relation where $\txid$ is a read-only 
transaction. When converting a $\ET_{\top}$-trace into a set of abstract executions, 
we (partially) lose the information about the view that a clients has, immediately after it executed a transaction.

\begin{theorem}
\label{thm:kvtrace2aexec}
Let $\tr$ be a $\ET_{\top}$-trace; there exists a set of abstract executions $\aeset({\tr})$ 
such that, for any $\hh \in \aeset(\tr)$, $\lastConf(\tr) = (\hh, \_)$.
Let $\aexec$ be an abstract execution that satisfies the last write wins resolution policy. 
There exists a set of $\ET_{\top}$-traces $\KVtrace({\aexec})$ in normal form, 
such that for any $\tr \in \KVtrace({\aexec})$, $\lastConf(\tr) = (\hh_{\aexec}, \_)$. 
\end{theorem}
\begin{proof}
    For readability the proof is in \cref{sec:kvtrace2aexec}.
\end{proof}

\begin{corollary} 
\label{cor:kvtrace2aexec}
$\CMs(\ET_{\top}) = \{\hh_{\aexec} \mid \aexec \text{ satisfies } \RP_{\LWW}\}$.
\end{corollary}




