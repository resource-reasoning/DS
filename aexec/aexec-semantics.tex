\subsection{Operational Semantics of Abstract Executions}

Abstract executions are a framework originally introduced in \cite{ev_transactions} 
to capture the run-time behaviour of clients interacting with a database. 
In abstract execution, two relations between transactions are introduced: 
the \emph{visibility} relation establishes when a transaction observes the effects of another transaction; 
and the \emph{arbitration} relation helps to determine the value of a key $\ke$ read by a transaction, 
in the case that the transaction observes multiple updates to $\ke$ performed by different transactions. 

\begin{definition}
\label{def:absexec}
\label{def:aexec}
An abstract execution is a triple $\aexec = (\TtoOp{T}, \VIS, \AR)$, where 
\begin{itemize}
    \item $\TtoOp{T}: \TxID_{0} \parfinfun \powerset{\Ops}$ is a partial, 
finite function mapping transaction identifiers to the set of operations that they perform,
\item $\VIS \subseteq \dom(\TtoOp{T}) \times \dom(\TtoOp{T})$ is an irreflexive relation, 
called \emph{visibility}, 
\item $\AR \subseteq \dom(\TtoOp{T}) \times \dom(\TtoOp{T})$ is a strict, total order 
such that $\VIS \subseteq \AR$, and whenever $\txid_{\cl}^{n} \xrightarrow{\AR} 
\txid_{\cl}^{m}$, then $n < m$.
\end{itemize} 
The set of abstract executions is denoted by $\aeset$.
\end{definition}

Given an abstract execution $\aexec = (\TtoOp{T}, \VIS, \AR)$, 
the notation $\TtoOp{T}_{\aexec} = \TtoOp{T}$,
$\T_{\aexec} = \dom(\TtoOp{T})$, $\VIS_{\aexec} = \VIS$ 
and $\AR_{\aexec} = \AR$. 
The session order for a client \( \PO_{\aexec}(\cl) \)  and 
then the overall session order \( \SO_\aexec\) are defined as the following:
\[
    \PO_{\aexec}(\cl) = \Setcon{(\txid_{\cl}^{n}, \txid_{\cl}^{m})}{ \cl \in \Clients 
\wedge \txid_{\cl}^{n} \in \T_{\aexec} \wedge \txid_{\cl}^{m} \in \T_{\aexec} \wedge n < m}
\]
and 
\[
    \PO_{\aexec} = \bigcup\limits_{\cl \in \Clients} \PO_{\aexec}(\cl)
\]
The notation $(\otR, \ke, \val) \in_{\aexec} \txid$ denotes $(\otR, \ke, \val) \in \TtoOp{T}_{\aexec}(\txid)$, 
and similarly for write operations \( (\otW, \ke, \val) \in_{\aexec} \txid \).
Given an abstract execution $\aexec$, a transaction $\txid \in \T_{\aexec}$, and a key $\ke$, 
the visible writers set $\visibleWrites_{\aexec}(\ke, \txid) \defeq \{ \txid' \mid \txid' \xrightarrow{\VIS_{\aexec}} \txid \wedge 
(\otW, \ke, \_) \in_{\aexec} \txid'\}$.

The operational semantics on abstract executions (\cref{fig:aexec.semantics}) is parametrised in the axiomatic specification $(\RP, \Ax)$ of a consistency model:
transitions take the form $(\aexec, \Env, \prog) \toA{\_}_{(\RP, \Ax)} (\aexec', \Env', \prog')$. 
An axiomatic specification of a consistency model is given by a pair $(\RP, \Ax)$, 
where $\RP$ is a resolution policy (\cref{def:rp}) 
and $\Ax$ is a set of axioms for visibility relation (\cref{def:aexec-axioms}).
An abstract execution $\aexec$ satisfies the consistency model, 
written $\aexec \models (\RP, \Ax)$ if it satisfies its individual components. 
The set of abstract executions induced by an axiomatic specification is given 
by $\CMa(\RP, \Ax) = \Setcon{ \aexec }{ \aexec \models (\RP, \Ax)}$.

We first introduce a notation of two abstract executions \emph{agree}.
Given two abstract executions $\aexec_1, \aexec_2 \in \aeset$ and set of transactions $\T \subseteq \T_{\aexec_1} \cap \T_{\aexec_2}$,
 $\aexec_1$ and $\aexec_2$ \emph{agree} on $\T$ if and only if for any transactions \( \txid \) \( \txid' \) in \( \T \):
\[
\begin{array}{l}
    \TtoOp{T}_{\aexec_1}(\txid) = \TtoOp{T}_{\aexec_2}(\txid) \wedge 
((\txid \xrightarrow{\VIS_{\aexec_1}} \txid') \iff (\txid \xrightarrow{\VIS_{\aexec_2}} \txid'))
\wedge ((\txid \xrightarrow{\AR_{\aexec_1}} \txid') \iff (\txid \xrightarrow{\AR_{\aexec_2}} \txid'))
\end{array}
\]
\begin{definition}
\label{def:rp}
A resolution policy $\RP$ is a function $\RP: \aeset \times \powerset{\TxID} \rightarrow \powerset{\Snapshots}$ 
such that, for any $\aexec_1, \aexec_2$ that agree on a subset of transactions $\T$, then 
$\RP(\aexec_1, \T) = \RP(\aexec_2, \T)$.
An abstract execution $\aexec$ satisfies the execution policy $\RP$ if, 
\[
    \fora{\txid \in \T_{\aexec} } 
    \exsts{ \h \in \RP(\aexec, \VIS_{\aexec}^{-1}(\txid)) }
    \fora{ \ke,\val } (\otR, \ke, \val) \in_{\aexec} \txid 
    \implies \h(\ke) = \val
\]
\end{definition}


\begin{definition}
\label{def:aexec-axioms}
An axiom $\A$ is a function from abstract executions to relations between 
transactions, $\A: \aeset \rightarrow \powerset{\TxID \times \TxID}$, 
such that whenever $\aexec_1, \aexec_2$ agree on a subset of 
transactions $\T$, then $\A(\aexec_1) \cap (\T \times \T) \subseteq \A(\aexec_2)$.
\end{definition}

Axioms of a consistency model are constraints of the form $\A(\aexec) \subseteq \VIS_{\aexec}$. 
For example, if we require $A(\aexec) = \AR_{\aexec}$, 
then the corresponding axiom is given by $\AR_{\aexec} \subseteq \VIS_{\aexec}$,
thus capturing the serialisability of transactions,
\ie this axiom is equivalent to require that $\VIS_{\aexec}$ is a total order.
The requirement on subsets of transactions on which 
abstract executions agree will be needed later, 
when we define an operational semantics of transactions where 
clients can append a new transaction $\txid$ at the tail of an abstract execution $\aexec$,
which satisfies an axiom $\A$. This requirement ensures that 
we only need to check that the axiom is $\A$ is satisfied by the pre-visibility 
and pre-arbitration relation of the transaction $\txid$ in $\aexec'$. 
In fact, the resulting abstract execution $\aexec'$ agrees with $\aexec$ on the set $\T_{\aexec}$: 
in this case we'll note that we can rewrite 
$\A(\aexec') = \A(\aexec') \cap ((\T_{\aexec} \times \T_{\aexec}) ) \cup (\T_{\aexec} \times \{\txid\}))$.
Then
$\A(\aexec') \cap ((\T_{\aexec} \times \T_{\aexec})) \subseteq \A(\aexec) \cap (\T_{\aexec} \times \T_{\aexec}) \subseteq \VIS_{\aexec} \cap (\T_{\aexec} \times \T_{\aexec}) \subseteq \VIS_{\aexec'}$, 
hence we only need to check that $\A(\aexec') \cap (\T_{\aexec} \times \{\txid\}) \subseteq \VIS_{\aexec'}$.

We say that an abstract execution $\aexec$ satisfies an axiom $\A$, 
if $\A(\aexec) \subseteq \VIS_{\aexec}$. 
An abstract execution $\aexec$ satisfies $(\RP,\Ax)$, written $\aexec \models (\RP,\Ax)$,  
if the abstract execution \( \aexec \) satisfies \( \RP \) and \( \Ax \).

\begin{definition}[Abstract executions induced by axiomatic specifications]
\label{def:axiom-to-aexec}
The set of all abstract executions induced by a axiomatic specification, \( \CMa(\RP,\Ax)\) is defined as \( \CMa(\RP,\Ax) \defeq \Setcon{\aexec}{\aexec \models (\RP,\Ax)}\).
\end{definition}

\begin{figure}[t]

\hrulefill

\[
\begin{rclarray}
	\toA{}  & : &
    \begin{array}[t]{@{}c@{}}
    \ClientID \; \times \;
	\left( ( \Aexecs \times \Stacks ) \times \Commands \right)
    \; \times\; \Como \; \times \; \sort{Label} \;\times 
	\left( ( \Aexecs \times \Stacks ) \times \Commands \right) 
    \end{array}
\end{rclarray}
\]
\begin{mathpar}
    \inferrule[\rl{AAtomicTrans}]{
        \T \subseteq \T_{\aexec} \qquad \h \in \RP(\aexec, \T) \qquad
		(\stk, \h, \emptyset), \trans \ \toL^{*} \  (\stk', \stub,  \opset) , \pskip \\\\
		\txid \in \nextTxId(\T_{\aexec}, \cl) \qquad \aexec' = \extend(\aexec, \txid, \T, \opset) \qquad 
		\forall A \in \Ax.\;\{\txid' \mid (\txid', \txid) \in \A(\aexec') \} \subseteq \T
    }{
    \cl \vdash ( \aexec, \stk ), \ptrans{\trans} \ \toA{(\cl, \T,\f)}_{(\RP, \Ax)} \ ( \aexec', \stk' ) , \pskip
    }
    \and
    \inferrule[\rl{APrimitive}]{
        \stk \toLTS{\cmdpri} \stk'
    }{%
    \cl \vdash ( \aexec, \stk ) , \cmdpri \ \toA{(\cl,\iota)}_{\como} \  ( \aexec, \stk' ) , \pskip
    }
    \and
    \inferrule[\rl{AChoice}]{
        i \in \Set{1,2}
    }{%
        \cl \vdash ( \aexec, \stk ) , \cmd_{1} \pchoice \cmd_{2} \ \toA{(\cl,\iota)}_{\como} \  ( \aexec, \stk ) , \cmd_{i}
    }
    \quad
    \inferrule[\rl{AIter}]{ }{%
        \cl \vdash ( \aexec, \stk ) , \cmd\prepeat \ \toA{(\cl,\iota)}_{\como} \  ( \aexec, \stk ) , \pskip \pchoice (\cmd \pseq \cmd\prepeat)
    }
    \and
    \inferrule[\rl{ASeqSkip}]{ }{%
        \cl \vdash ( \aexec, \stk ) , \pskip \pseq \cmd \ \toA{(\cl,\iota)}_{\como} \  ( \aexec, \stk ) , \cmd
    }
    \quad
    \inferrule[\rl{ASeq}]{% 
        \cl \vdash ( \aexec, \stk ) , \cmd_{1} \ \toA{(\cl,\iota)}_{\como} \  ( \aexec, \stk' ) , {\cmd_{1}}' 
    }{%
        \cl \vdash ( \aexec,\stk ) , \cmd_{1} \pseq \cmd_{2} \ \toA{(\cl,\iota)}_{\como} \ ( \aexec, \stk' ) , {\cmd_{1}}' \pseq \cmd_{2}
    }
\end{mathpar}

\hrulefill

\[
	\toA{} : 
    ( \Aexecs \times \ThdEnv \times \Programs) 
    \;\times\; \Como \; \times \sort{Label} \times \;
    ( \Aexecs \times \ThdEnv \times \Programs) 
\]
\[
    \inferrule[\rl{AProg}]{%
         \cl \vdash ( \aexec, \thdenv(\thid) ) , \prog(\thid), \ \toA{\lambda}_{(\RP, \Ax)} \  ( \aexec', \stk' ) , \cmd'  
    }{%
         (\aexec, \thdenv ), \prog  \ \toA{\lambda}_{(\RP, \Ax)} \  ( \aexec', \thdenv\rmto{\thid}{\stk'} ) , \prog\rmto{\thid}{\cmd'} ) 
    }
\]
\hrulefill
\caption{Operational Semantics on Abstract Executions}
\label{fig:aexec.semantics}
\end{figure}

The \cref{fig:aexec.semantics} presents all rules of the operational semantics of programs based on abstract executions. 
The\rl{ACommit} rule is the abstract execution counterpart of rule \rl{PCommit} for kv-stores.
The\rl{ACommit} models how an abstract execution $\aexec$ evolves 
when a client wants to execute a transaction whose code is $\ptrans{\trans}$. 
In the rule, $\T$ is the set of transactions of $\aexec$ that are visible to the client $\cl$ that wishes to execute $\ptrans{\trans}$.
Such a set of transactions is used to determine a snapshot $\h \in \RP(\aexec, \T)$ that 
the client $\cl$ uses to execute the code $\ptrans{\trans}$, and obtain a fingerprint $\opset$. 
This fingerprint is then used to extend abstract execution $\aexec$ 
with a transaction from the set $\nextTxId(\T_{\aexec}, \cl)$.
Similar \rl{PProg} rule, the \rl{AProg} rule in \cref{fig:aexec.semantics}
models multi-clients concurrency in an interleaving fashion. 
All the rest rules of the abstract operational semantics in \cref{fig:aexec.semantics}
have a similar counterpart in the kv-store semantics.

Note that \rl{AAtomicTrans} is more general than Rule \rl{PAtomicTrans} in the kv-store semantics.
In the latter, the snapshot of a transaction is uniquely determined from a view of the client,
in a way that roughly corresponds to the last write wins policy in the abstract execution framework. 
In contrast, the snapshot of a transaction used in \rl{AAtomicTrans}
is chosen non-deterministically from those made available to the client by 
the resolution policy $\RP$, which may not necessarily be last-write-win. 

Throughout this report we will work mainly with the \emph{Last Write Wins} resolution policy (\cref{def:lww}).
When discussing the operational semantics of transactional programs, 
we will also introduce the \emph{Anarchic} resolution policy.

\begin{definition}
\label{def:lww}
The Last Write Wins resolution policy $\RP_{\LWW}$ is defined as 
$\RP_{\LWW}(\aexec, \T) \defeq \{\h\}$ where
\[
\h = \lambda \ke. \text{let} \ \T_{\ke} = ( \T \cap \{\txid \mid (\otW,\ke, \_) \in_{\aexec} \txid\})  \text{ in }
\begin{cases}
    \val_{0} & \text{ if } \T_{\ke} =  \emptyset\\
\val & \text{ if } (\otW, \ke, \val) \in_{\aexec} \max_{\AR_{\aexec}}(\T_{\ke})
\end{cases}
\]
\end{definition}
