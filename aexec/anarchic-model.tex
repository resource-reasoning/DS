\subsection{Anarchic Model}

To justify this semantics capture all the possible abstract executions under certain consistency model,
we introduce anarchic model, and by \cref{thm:consistency-intersect-anarchic},
we are confident that the operational semantics capture all possible behaviours.


\begin{definition}
The anarchic resolution policy $\RP_{\anarchic}$ is defined by letting, 
$\RP_{\anarchic}(\_, \_) = \Snapshots$. The \emph{anarchic consistency model} is 
specified axiomatically by the pair $\anarchicCM = (\RP_{\anarchic}, \emptyset)$.
\end{definition}

\begin{example}
Suppose that we want to execute the single-threaded program $\prog$ that maps client 
$\cl$ to the transactional code below:
\[
\begin{session}
%\ptrans{\pmutate{\ke}{\val_2}}; \\
\ptrans{\pderef{\pvar{a}}{\ke}; \\
\pifs{\pvar{a} = \val_{1}} \pmutate{\ke'}{\val_1} \pife}
\end{session}
\]
Suppose that the program is executed under a consistency model that adopts the last write 
wins resolution policy $\RP_{\LWW}$, and with no additional axioms. Then the behaviour of $\prog$ is 
completely deterministic (up-to the choice of transaction identifiers), and the execution of $\prog$ terminates in a 
state corresponding to the abstract execution below: 

\begin{center}
\begin{tikzpicture}[scale=0.85, every node/.style={transform shape}]

\node(t0rx) at (-1,2) {$(\otR, \ke, \val_0)$}; 
%\path (t0wx.south) + (0,-0.2) node[anchor=north] (t0wy) {$(\otW, \ke_2, \val'_0)$};

\begin{pgfonlayer}{background}
\node[background, fit=(t0rx)]  {};

\path(t0.west) node[anchor=east] (t0lbl) {$\txid_{\cl}^{\_}$};
%\path(t1.north) node[anchor=south] (t1lbl) {$\txid_1$};
%\path(t2.south) node[anchor=north] (t2lbl) {$\txid_2$};

%\path[->]
%(t0.north) edge[bend left=70] node[above, yshift=7pt, xshift=-1pt, pos=0.3] {$\RF(\ke_2), \VO(\ke_1)$} (t1.west)
%(t0.south) edge[bend right=70] node[below, yshift=-8pt, xshift=-1pt, pos=0.3] {$\RF(\ke_1), \VO(\ke_2)$} (t2.west)
%([xshift=-8pt]t2.north) edge[bend left=40] node[left] {$\AD(\ke_1)$} ([xshift=-8pt]t1.south) 
%([xshift=8pt]t1.south) edge[bend left=40] node[right] {$\AD(\ke_2)$} ([xshift=8pt]t2.north);
\end{pgfonlayer}
\end{tikzpicture}
\end{center}

However, if we replace the consistency model specification $(\RP_{\LWW}, \emptyset)$ with the 
anarchic one $\anarchicCM$. Because the snapshot in which client $\cl$ executes the 
transactional code above is chosen non-deterministically, 
the program $\prog$ exhibits infinitely many additional behaviours. 
In particular, the program may now terminate in a state corresponding 
to the abstract execution below: 

\begin{center}
\begin{tikzpicture}[scale=0.85, every node/.style={transform shape}]

\node(t0rx) at (-1,2) {$(\otR, \ke, \val_1)$}; 
\path (t0wx.east) + (0,0.2) node[anchor=west] (t0wy) {$(\otW, \ke', \val_1)$};

\begin{pgfonlayer}{background}
\node[background, fit=(t0rx) (t0wy)]  {};

\path(t0.west) node[anchor=east] (t0lbl) {$\txid_{\cl}^{\_}$};
%\path(t1.north) node[anchor=south] (t1lbl) {$\txid_1$};
%\path(t2.south) node[anchor=north] (t2lbl) {$\txid_2$};

%\path[->]
%(t0.north) edge[bend left=70] node[above, yshift=7pt, xshift=-1pt, pos=0.3] {$\RF(\ke_2), \VO(\ke_1)$} (t1.west)
%(t0.south) edge[bend right=70] node[below, yshift=-8pt, xshift=-1pt, pos=0.3] {$\RF(\ke_1), \VO(\ke_2)$} (t2.west)
%([xshift=-8pt]t2.north) edge[bend left=40] node[left] {$\AD(\ke_1)$} ([xshift=-8pt]t1.south) 
%([xshift=8pt]t1.south) edge[bend left=40] node[right] {$\AD(\ke_2)$} ([xshift=8pt]t2.north);
\end{pgfonlayer}
\end{tikzpicture}
\end{center}

It is important to note, however, that the set of abstract executions generated by $\prog$ is still bound 
to the structure of the program itself. For example, executing $\prog$ under the anarchic execution model 
will never lead to an abstract execution with multiple transactions, or to an abstract execution where a transaction 
writes a key other than $\ke'$ is written.
\end{example}

\begin{definition}
The semantics of a program $\prog$ under a consistency model with axiomatic specification 
$(\RP, \Ax)$ is given by 
\[
\interpr{\prog}_{(\RP, \Ax)} = \{ \aexec \mid (\aexec_{0}, \Env_{0}, \prog) \toA{\_}_{(\RP, \Ax)}^{\ast} (\aexec, \_, \prog_{f}) \}, 
\]
where $\Env_{0} = \lambda \cl \in \dom(\prog).\lambda \pvar{x}.0$ and $\prog_{f} = \lambda \cl \in \dom(\prog).\pskip$.
\end{definition}

We define the set of all the possible behaviours of a program $\prog$ to be $\interpr{\prog}_{\anarchic}$. 
The following result supports our claim that this definition is indeed accurate: 


\begin{example}
One may argue that the axiomatic specification $\anarchicCM$ does not 
truly represent an anarchic consistency model. Consider for example the single-threaded 
program $\prog'$ that associates to a client $\cl$ the following code:
\[
\begin{session}
\ptrans{
\pderef{\pvar{a}}{\ke}; \\
\pderef{\pvar{b}}{\ke};\\
\pifs{\pvar{a} != \pvar{b}} \pmutate{\ke'}{\val_1} \pife}
\end{session}
\]
One would expect that, under a truly anarchic consistency model, it would be possible 
for program $\prog'$ to write the value $\val_1$ for key $\ke'$. However, 
this never happens if $\prog'$ is executed under $\anarchicCM$. This is because 
we embedded into abstract execution the assumption that transactions only read 
at most one value for each key. 

In theory, we could lift this limitation and still retain 
the validity of all the results contained in this report; however, doing so would 
require to work with mathematical structures that are far more complex than 
abstract executions, and we preferred to avoid this issue. 
Furthermore, the constraint that an object is never read twice in transactions is enforced 
at client side in virtually all the implementations  
of libraries for accessing kv-stores. When a client first requests to fetch 
the value of some key $\ke$ within a transaction, a local copy of the value fetched is 
saved on the client (typically in an object containing the meta-data of the transaction); 
if a request to read the same key is performed again within the same client, the local 
copy of the value previously fetched for that key is returned, instead of issuing a second 
read request to the kv-store.
\end{example}

As explained above, the set of all possible behaviours exhibited by a program $\prog$ under a 
consistency model $(\RP, \Ax)$ can be defined by intersecting the set of executions 
that $\prog$ exhibits under the anarchic consistency model, with the set of all executions 
allowed by the axiomatic specification $(\RP, \Ax)$. As the next theorem shows, 
this is exactly the set of abstract executions in which $\prog$ terminates, 
when executed under the axiomatic specification $(\RP, \Ax)$.

\begin{theorem}
\label{thm:consistency-intersect-anarchic}
For any program $\prog$ and axiomatic specification $(\RP, \Ax)$:
\[
\interpr{\prog}_{(\RP, \Ax)} = \interpr{\prog}_{\anarchic} \cap \CMa(\RP, \Ax)
\]
\end{theorem}
\begin{proof}
    It is easy to see \( \interpr{\prog}_{(\RP, \Ax)} \subseteq \CMa(\RP, \Ax) \) so that 
    \( \interpr{\prog}_{(\RP, \Ax)} \subseteq \interpr{\prog}_{\anarchic} \cap \CMa(\RP, \Ax) \).
    Given \cref{prop:aexec-semantics-mono}, we know \( \interpr{\prog}_{\anarchic} \subseteq \interpr{\prog}_{(\RP, \Ax)} \).
    Then, by the definition of \( \interpr{\prog}_{\stub} \), it follows
    \( \interpr{\prog}_{\anarchic} \cap \CMa(\RP, \Ax) \subseteq \interpr{\prog}_{(\RP, \Ax)} \).
\end{proof}


\begin{proposition}
\label{prop:aexec-semantics-mono}
Let define \( (\RP_1, \Ax_1) \sqsubseteq (\RP_2, \Ax_2) \) as the following:
\[
    \fora{\aexec,\T} \RP_2{\aexec,\T} \subseteq  \RP_1{\aexec,\T}
\]
and,
\[
    \fora{\aexec} \bigcup\limits{\A_1 \in \Ax_1}\A_1(\aexec) \subseteq \bigcup\limits{\A_2 \in \Ax_2}\A_2(\aexec)
\]
then
\[ \interpr{\prog}_{(\RP, \Ax)} \subseteq \interpr{\prog}_{\anarchic} \]
\end{proposition}
\begin{proof}
    Since \( \anarchic \sqsubseteq (\RP, \Ax) \),
    We prove stronger result that for \( (\RP_1, \Ax_1) \sqsubseteq  (\RP_2, \Ax_2)\),
    the following  hold:
    \[
        \begin{array}{@{}l@{}}
            \fora{\cl, \aexec, \aexec', \prog, \prog', \stk, \stk'}  \\
            \quad \cl \vdash ( \aexec, \stk ), \prog \toA{\stub}_{(\RP_1, \Ax_1)} ( \aexec', \stk' ), \prog' \\
            \quad \implies \cl \vdash ( \aexec, \stk ), \prog \toA{\stub}_{(\RP_2, \Ax_2)} ( \aexec', \stk' ), \prog' \\
        \end{array}
    \]
    We prove it by induction on the derivations.
    The only interesting case is the \rl{PCommit} rule.
    Given an initial runtime abstract execution \( \aexec \),
    a set of observable transactions \( \T \),
    a new transaction identifier \( \txid \),
    by the \rl{ACommit} rule, it is sufficient to prove, 
    first, all the snapshot under the stronger consistency model is also a valid snapshot under the weaker one:
    \begin{equation}
        \label{equ:obs-state-included}
        \fora{\aexec,\T} \RP_2{\aexec,\T} \subseteq  \RP_1{\aexec,\T}
    \end{equation}
    and second if it is valid  to commit a new transition with the observable set \( \T \) under stronger consistency model,
    it is able to do so under weaker consistency model:
    \begin{equation}
        \label{equ:consis-both-exist}
        \bigcup\limits{\A_1 \in \Ax_1}\A_1(\aexec')^{-1}(\txid) \subseteq \bigcup\limits{\A_2 \in \Ax_2}\A_2(\aexec')^{-1}(\txid)
    \end{equation}
    The \cref{equ:obs-state-included,equ:consis-both-exist} can be proven by \( (\RP_1, \Ax_1) \sqsubseteq  (\RP_2, \Ax_2) \).

    \caseB{\rl{PAssign}, \rl{PAssume}, \rl{PChoice}, \rl{PLoop}, \rl{PSeqSkipS}, \rl{PPar}, \rl{PWait}}
    These base cases do not depend on the consistency model, so they trivial hold because of the hypothesis.
    \caseI{\rl{PSeq}}
    It is proved directly by applying the \ih
\end{proof}
