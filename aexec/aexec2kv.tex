\subsection{Key-value Store to Abstract Executions}

Throughout this section we focus on abstract executions that satisfy the resolution policy $\RP_{\LWW}$.
Such abstract executions can be converted into dependency graphs \cite{SIanaysis,laws}, 
which in turn are isomorphic to kv-stores (\cref{thm:kv2graph}). For the sake of completeness, 
we include the definition of the dependency graph and kv-store induced by an abstract execution below: 

\begin{definition}
\label{def:aexec2graph}
Given an abstract execution $\aexec$ that satisfies the last write wins policy,
the dependency graph $\graphof(\aexec) \defeq (\TtoOp{T}_{\aexec}, \RF_{\aexec}, 
\VO_{\aexec}, \AD_{\aexec})$ is defined by letting
\begin{itemize}
\item $\txid \xrightarrow{\RF_{\aexec}(\ke)} \txid'$ if and only if 
$\txid = \max_{\AR_{\aexec}}(\visibleWrites_{\aexec}(\ke, \txid'))$, 
\item $\txid \xrightarrow{\VO_{\aexec}(\ke)} \txid'$ if and only 
$\txid, \txid' \in_{\aexec} (\otW, \;\ke: \_)$ 
and $\txid \xrightarrow{\AR_{\aexec}} \txid'$,
\item $\txid \xrightarrow{\AD_{\aexec}(\ke)} \txid'$ if and only if either 
$(\otR, \ke, \_) \in_{\aexec} \txid, (\otW, \ke, \_) \in_{\aexec} \txid'$ and 
whenever $\txid'' \xrightarrow{\RF_{\aexec}(\ke)} \txid$, 
then $\txid'' \xrightarrow{\VO_{\aexec}(\ke)} \txid'$.
\end{itemize}
\end{definition}
Note that each abstract execution $\aexec$ determines a kv-store 
$\hh_{\aexec}$, as per \cref{def:aexec2graph} and \cref{thm:kv2graph}. 
Let $\hh$ be the unique kv-store such that $\Gr_{\hh} = \graphof(\aexec)$: then 
$\hh_{\aexec} = \hh$. As we discuss later in this Section, this mapping 
$\hh_{(\stub)}$ is not a bijection, in that several abstract executions may be 
encoded in the same kv-store. This is because kv-stores abstract the total 
arbitration order of transactions away.

Next, we define a notion of \emph{compatibility} between abstract executions and kv-stores. 
This notion is based on the intuition that clients can make observations over kv-stores and abstract 
executions, in terms of snapshots.
In kv-stores, observations are snapshots induced by views of clients over the kv-store. 
In abstract executions, observations correspond to the snapshots induced by the subsets of of transactions of the abstract executions,
according to some resolution policy (in this case, $\RP_{\LWW}$):
this approach is analogous to the one used by opetation contexts in \cite{repldatatypes}.
Thus a kv-store $\hh$ is compatible with an abstract execution $\aexec$ 
if any observation made on $\hh$ can be replicated by an observation made on $\aexec$, and vice-versa. 

\begin{definition}
\label{def:compatible}
Given a key-value store $\hh$,
an abstract execution $\aexec$ is compatible with $\hh$, written 
$\aexec \compatible \hh$, if and only if there exists a  mapping 
$f: \powerset{\T_{\aexec}} \rightarrow \Views(\hh)$
such that  
\begin{itemize}
\item for any subset $\T \subseteq \T_{\aexec}$, then $\RP_{\LWW}(\aexec, \T) = \{\snapshot(\hh, f(\T))\}$; 
\item for any view $\vi \in \Views(\hh)$, there exists a subset $\T \subseteq \T_{\aexec}$ 
such that $f(\T) = \vi$, and $\RP_{\LWW}(\aexec, \T) = \{\snapshot(\hh_{\aexec}, \vi)\}$.
\end{itemize}
\end{definition}

The compatibility relation $\simeq$ includes the encoding from abstract executions to kv-stores in \cref{thm:aexec2kv.compatible}.

\begin{theorem}
\label{thm:aexec2kv.compatible}
For any abstract execution $\aexec$ that satisfies the last write wins policy, $\aexec \compatible \hh_{\aexec}$.
\end{theorem}
\begin{proof}
The proof of Theorem \ref{thm:aexec2kv.compatible} requires defining a mapping 
$\getView(\aexec, \stub)$ from $\powerset{\T_{\aexec}}$ to $\Views(\hh_{\aexec})$ 
that satisfies the constraint of \cref{def:compatible}.
The function $\getView(\aexec, \stub)$ is defined by letting 
$\getView(\aexec, \T) = \lambda \ke. \{0\} \cup \{ i \mid i \in [\lvert \hh_{\aexec} \rvert - 1] \wedge 
\WTx(\hh_{\aexec}(\ke, i)) \in \T\}$.
For readability, we give details of the proof of in later section \cref{sec:thm:aexec2kv-compatible-proof}.
\end{proof}

\subsection{$\ET$-traces to Abstract Executions}

Let $\ET_\top$ be the most permissive execution test, 
that is $\ET_\top \vdash (\hh, \vi) \triangleright \opset: \vi'$ for any $\hh, \vi, \opset, \vi'$ 
such that whenever $\vi(\ke) \neq \vi'(\ke)$ then either $(\otW, \ke, \_) \in \opset$ or $(\otR, \ke, \_) \in \opset$.
%{\color{red} I forgot this last constraint in the latest version of the document, definitions 
%and proofs of theorems that follow must be re-factored to take the constraint into account.}
We will relate $\ET_{\top}$-traces to abstract executions that satisfy the last write wins resolution policy. 

To bridge $\ET_{\top}$-traces to abstract executions, we first introduce the conversion from \( \ET \) trace to abstract execution (\cref{def:kvtrace2aexec} and \cref{prop:kvtrace2aexec}).
In \cref{def:kvtrace2aexec}, given a $\ET_{\top}$-trace $\tr$, a set of abstract execution $\aeset(\tr)$ such that, 
for any $\aexec \in \aeset(\tr)$, the last configuration of $\tr$ is $(\hh_{\aexec}, \_)$. 

The \cref{def:kvtrace2aexec} 
\begin{definition}
\label{def:kvtrace2aexec}
Let $\hh$ be a kv-store, and $\vi$ be a view. 
Define $\Tx(\hh, \vi) \defeq \Setcon{ \WTx(\hh(\ke, i)) }{ \ke \in \Keys \wedge i \in \vi(\ke) }$. 
Let $\aexec_0 = ( [ ], \emptyset, \emptyset)$. Given an abstract execution $\aexec$, a set of transactions  
$\T \subseteq \T_{\aexec}$, a transaction identifier $\txid$ and a set of operations $\opset$, we let 
\[
\extend(\aexec, \txid, \T, \opset) \defeq
\begin{cases}
\textit{undefined} &\impliedby \txid = \txid_{0}\\
(\TtoOp{T}_{\aexec} \uplus \Set{\txid_{\cl}^{n} \mapsto \opset}, \VIS', \AR') & \impliedby \txid = \txid_{\cl}^{n} \wedge {}\\
& \VIS' = \VIS_{\aexec} \uplus \{(\txid', \txid) \mid \txid \in \T)\} \wedge {}\\
& \AR' = \AR_{\aexec} \uplus \{(\txid', \txid) \mid \txid' \in \T_{\aexec})\}\\
\end{cases}
\]
Given a $\ET_{\top}$ trace $\tr$, we let $\lastConf(\tr)$ to be the last configuration appearing in 
$\tr$. The set of abstract executions $\aeset(\tr)$ is defined as the smallest set such that:
\begin{itemize}
\item $\aexec_{0} \in \aeset((\hh_{0}, \viewFun_{0}))$, 
\item if $\aexec \in \aeset(\tr)$, then $\aexec \in \aeset\left(\tr \xrightarrowtriangle{(\cl, \varepsilon)}_{\ET_{\top}} (\hh, \viewFun) \right)$, 
\item if $\aexec \in \aeset(\tr)$, then $\aexec \in \aeset\left(\tr \xrightarrowtriangle{(\cl, \emptyset)}_{\ET_{\top}} (\hh, \viewFun) \right)$, 
\item let $(\hh', \viewFun') = \lastConf(\tr)$; 
    if $\aexec \in \aeset(\tr)$, $\opset \neq \emptyset$, and $\T = \Tx(\hh, \viewFun'(\cl)) \cup \T_{rd}$ where \( \T_{rd} \) 
    is a set of \emph{read-only transactions} such that $\forall \txid' \in \T_{rd}, \ke, \val.\; (\otW, \ke, \val) \notin_{\aexec} \txid'$.
    Then for the transaction $\txid$ that is a transaction appearing in $\lastConf(\tr)$ but not in $\hh$, then  
$\extend(\aexec, \txid, \T, \opset) \in \aeset\left(\tr \xrightarrowtriangle{(\cl, \opset)}_{\ET_{\top}} (\hh, \viewFun) \right)$.
\end{itemize}
\end{definition}

\begin{proposition}
\label{prop:kvtrace2aexec}
For any $\ET_{\top}$-trace $\tau$, and $\aexec \in \aeset(\tau)$ is an abstract execution that 
satisfies the last write wins policy.
Furthermore, $\hh_{\aexec} = \hh$ where $(\hh, \stub) = \lastConf(\tau)$.
\end{proposition}
\begin{proof}
Fix a $\ET_{\top}$-trace $\tau$. We prove \cref{prop:kvtrace2aexec} by induction 
on the number of transitions $n$ in $\tau$. 
\begin{itemize}
\item $n = 0$. Then $tau = (\hh_{0}, \_)$; it follows from \cref{def:kvtrace2aexec} that 
$\aexec_{\tau} = ([], \emptyset, emptyset)$. This triple satisfies the constraints 
of \cref{def:aexec}, as well as the resolution policy $\RP_{\LWW}$. 
It is also immediate to see that $\graphof(\aexec) = ([], \emptyset, \emptyset, \emptyset)$; in particular, 
$\T_{\graphof(\aexec)} = \emptyset$, and the only kv-store $\hh$ such that $\T_{\Gr_{\hh}} = \emptyset$ 
is given by $\hh = \hh_{0}$. By definition, $\hh_{\aexec_{\tau}} = \hh_{0}$, as we wanted to prove.

\item $n > 0$. In this case, we have that $\tau = \tau' \xrightarrowtriangle{(\cl, \mu)} (\hh, \viewFun)$ 
for some $\cl, \mu, \hh, \viewFun$. The $\ET_{\top}$-trace $\tau'$ contains exactly $n-1$ transititions, 
so that by induction we can assume that $\aexec_{\tau'}$ is a valid abstract execution that satisfies 
$\RP_{\LWW}$. Furthermore, $\lastConf(\tau') = (\hh_{\aexec_{\tau'}}, \viewFun')$ for some $\viewFun'$. 

We perform a case analysis on $\mu$. If $\mu = \varepsilon$, then it follows that $\hh = \hh_{\aexec_{\tau'}}$, 
and $\aexec_{\tau} = \aexec_{\tau'}$ by \cref{def:kvtrace2aexec}. By the inductive hypothesis 
$\aexec_{\tau}$ is an abstract execution that satisfies $\RP_{\LWW}$. Furthermore, 
$\lastConf(\tau) = (\hh, \_)$, and $\hh_{\aexec_{\tau}} = \hh_{\aexec_{\tau'}} = \hh$, 
and there is nothing left to prove. 

Suppose now that $\mu = \opset$, for some $\opset$. In this case we have that  
$\hh \in \updateKV(\hh_{\aexec_{\tau'}}, \viewFun'(\cl), \cl, \opset)$. Note that if 
$\opset = \emptyset$, then $\hh = \hh_{\aexec_{\tau'}}$ and $\aexec_{\tau} = \aexec_{\tau'}$. 
By the inductive hypothesis, $\aexec_{\tau}$ is an abstract execution that satisfies 
$\RP_{\LWW}$, and $\hh = \hh_{\aexec_{\tau'}} = \hh_{\aexec_{\tau}}$. 
Assume then that $\opset \neq \emptyset$. By definition, $\hh = \updateKV(\hh_{\aexec_{\tau'}}, 
\viewFun'(\cl), \txid, \opset)$ for some $\txid \in \nextTxId(\cl, \hh_{\aexec_{\tau}})$. It follows that $\txid$ 
is the unique transaction such that $\txid \notin \hh_{\aexec_{\tau'}}$, and $\txid \in \hh$ 
(the fact that $\txid \in \hh$ follows from the assumption that $\opset \neq \emptyset$). Let 
$\T = \Tx(\hh_{\aexec_{\tau'}}, \viewFun'(\cl))$; then $\aexec_{\tau} = \extend(\hh_{\aexec_{\tau'}}, \txid, \T, \opset)$. 
We first note that $\aexec_{\tau}$ satisfies the constraints of abstract execution required by \cref{def:kvtrace2aexec}.
\begin{itemize}
\item  Because $\txid \in \nextTxId(\cl, \hh_{\aexec_{\tau}})$, it must be the case that $\txid = \txid_{\cl}^{m}$ for some 
$m \geq 1$; we have that $\TtoOp{T}_{\aexec_{\tau}} = \TtoOp{T}_{\aexec_{\tau'}}\rmto{\txid_{\cl}^{m}}{\opset}$, 
from which it follows that 
\[
\T_{\aexec_{\tau}} = \dom(\TtoOp{T}_{\aexec_{\tau}}) = \dom(\TtoOp{T}_{\aexec_{\tau'}}) \cup 
\{\txid_{\cl}^{m} \} = \T_{\aexec_{\tau'}} \cup \{\txid_{\cl}^{m} \}.
\]
By inductive hypothesis, $\txid_0 \notin \T_{\aexec_{\tau'}}$, and therefore $\txid_{0} \notin 
\T_{\aexec_{\tau'}} \cup \{\txid_{\cl}^{m} \} = \T_{\aexec}$.
\item Let $(\txid' ,\txid'') \in \VIS_{\aexec_{\tau}}$. Then either $\txid'' = \txid_{\cl}^{m}$ and $\txid' \in \T$, or $(\txid', \txid'') \in 
\VIS_{\aexec_{\tau'}}$. In the former case, we have that $(\txid', \txid_{\cl}^{m}) \in \AR_{\aexec_{\tau}}$ by definition; 
in the latter case, we have that $(\txid', \txid'') \in \AR_{\aexec_{\tau'}}$ because $\aexec_{\tau'}$ is a valid 
abstract execution by inductive hypothesis, and therefore $(\txid', \txid'') \in \AR_{\aexec_{\tau}}$ by definition. 
This concludes the proof that $\VIS_{\aexec_{\tau}} \subseteq \AR_{\aexec_{\tau}}$. 
Also, observe that $\VIS_{\aexec_{\tau}}$ is irreflexive: if $(\txid', \txid'') \in \VIS_{\aexec_{\tau}}$, then either 
$(\txid' \txid'') \in \VIS_{\aexec_{\tau'}}$, and because $\VIS_{\aexec_{\tau'}}$ is irreflexive by the inductive hypothesis, 
then $\txid' \neq \txid''$; or $\txid'' = \txid_{\cl}^{m}$, $\txid' \in \T \subseteq \T_{\aexec_{\tau'}}$, 
and because $\txid_{\cl}^{m} \notin \hh_{\aexec_{\tau'}}$, then $\txid' \neq \txid_{\cl}^{m}$. 
\item Let $(\txid', \txid'') \in \T_{\aexec_{\tau}}$. We prove that $\AR_{\aexec_{\tau}}$ is total. 
Suppose that $\txid' \neq \txid''$.
\begin{enumerate}
\item If $\txid' \neq 
\txid_{\cl}^{m}$, $\txid'' \neq \txid_{\cl}^{m}$, then it must be the case that $\txid', \txid'' \in \T_{\aexec_{\tau'}}$; 
this is because we have already argued that $\T_{\aexec_{\tau}} = \T_{\aexec_{\tau'}} \cup \{\txid_{\cl}^{m}\}$. 
By the inductive hypothesis, we have that either $(\txid', \txid'') \in \AR_{\aexec_{\tau'}}$, or 
$(\txid'', \txid') \in \AR_{\aexec_{\tau'}}$. Because $\AR_{\aexec_{\tau'}} \subseteq \AR_{\aexec_{\tau}}$, 
then either $(\txid', \txid'') \in \AR_{\aexec_{\tau'}}$ or $(\txid'', \txid') \in \AR_{\aexec_{\tau}}$. 
\item if $\txid'' = \txid_{\cl}^{m}$, then it must be $\txid' \in \T_{\aexec_{\tau'}}$. By definition, 
$(\txid', \txid_{\cl}^{m}) \in \AR_{\aexec_{\tau}}$. Similarly, if $\txid' = \txid_{\cl}^{m}$, we 
can prove that $(\txid'', \txid_{\cl}^{m}) \in \AR_{\aexec_{\tau}}$.
\end{enumerate}
Next, we can employ the same proof used to show that $\VIS_{\aexec_{\tau}}$ is irreflexive 
to prove that $\AR_{\aexec_{\tau}}$ is irreflexive. Finally, let 
$(\txid', \txid'') \in \AR_{\aexec_{\tau}}$ and $(\txid'', \txid''') \in \AR_{\aexec_{\tau}}$. 
Note that it must be the case that $\txid', \txid'' \in \T_{\aexec_{\tau'}}$ by the definition of 
$\AR_{\aexec}$, and in particular $(\txid', \txid'') \in \AR_{\aexec_{\tau'}}$. 
For $\txid'''$, we have two possible cases. 
\begin{enumerate}
\item Either $\txid''' \in \T_{\aexec_{\tau}}$, from 
which it follows that $(\txid'', \txid''') \in \AR_{\aexec_{\tau'}}$; because
of $\AR_{\aexec_{\tau'}}$ is transitive by the inductive hypothesis, then 
$(\txid', \txid''') \in \AR_{\aexec_{\tau'}}$, and therefore $(\txid' ,\txid''') \in 
\AR_{\aexec_{\tau}}$.
\item Or $\txid''' = \txid_{\cl}^{m}$, and because $\txid' \in \T_{\aexec_{\tau'}}$, then 
$(\txid', \txid_{\cl}^{m}) \in \AR_{\aexec_{\tau}}$ by definition. 
\end{enumerate}
\item Let $\cl'$ be a client such that $(\txid_{\cl'}^{i}, \txid_{\cl'}^{j}) \in \AR_{\aexec_{\tau}}$. 
If $\cl' \neq \cl$, then it must be the case that $\txid_{\cl'}^{i}, \txid_{\cl'}^{j} \in \T_{\aexec_{\tau'}}$, 
and therefore $(\txid_{\cl'}^{i}, \txid_{\cl'}^{j}) \in \AR_{\aexec_{\tau'}}$. By the inductive hypothesis, 
it follows that $i < j$. If $\cl' = \cl$, then by definition of $\AR_{\aexec_{\tau}}$ it must be  $i \neq m$. 
If $j \neq m$ we can proceed as in the previous case to prove that $i < j$. If $j = m$, then 
note that $\txid_{\cl}^{i} \in \T_{\aexec_{\tau}}$ only if $\txid_{\cl}^{i} \in \hh_{\aexec_{tau'}}$. 
Because $\txid_{\cl}^{m} \in \nextTxId(\hh_{\aexec_{\tau'}}, \cl)$, then we have that $i < m$, 
as we wanted to prove.
\end{itemize}

Next, we prove that $\aexec_{\tau}$ satisfies the last write wins policy. 
Let $\txid' \in \T_{\aexec_{\tau}}$, and suppose that $(\otR, \ke, \val) \in_{\aexec_{\tau}} \txid'$. 
\begin{itemize} 
\item If $\txid' \neq \txid$, then we have that $\txid \in \T_{\aexec_{\tau'}}$. We also have that 
$\VIS^{-1}_{\aexec_{\tau}}(\txid') = \VIS^{-1}_{\aexec_{\tau'}}(\txid')$, $\AR^{-1}_{\aexec_{\tau}}(\txid') 
= \AR^{-1}_{\aexec_{\tau'}}(\txid')$; finally, for any $\txid'' \in \T_{\aexec_{\tau'}}$, 
$(\otW, \ke, \val') \in_{\aexec_{\tau}} \txid''$ if and only if $(\otW, \ke, \val') \in_{\aexec_{\tau'}} 
\txid''$. Therefore, let $\txid_{r} := \max_{\AR_{\aexec_{\tau}}}(\VIS^{-1}_{\aexec_{\tau}}(\txid') \cap 
\{\txid'' \mid (\otW, \ke, \_) \in_{\aexec_{\tau}} \txid''\})$. We have that $\txid_{r} = \max_{\AR_{\aexec_{\tau'}}}(\VIS^{-1}_{\aexec_{\tau'}}(\txid) 
\cap \{ \txid'' \mid (\otW, \ke, \_ \in_{\aexec_{\tau'}} \txid''\})$, and because $\aexec_{\tau'}$ satisfies the last write 
wins resolution policy,then $(\otW, \ke, \val) \in_{\aexec_{\tau'}} \txid_{r}$. This also implies that 
$(\otW, \ke, \va) \in_{\aexec_{\tau}} \txid_{r}$. 

\item Now, suppose that $\txid' = \txid$. Suppose that $(\otR, \ke \val) \in_{\aexec_{\tau}} \txid'$. 
By definition, we have that $(\otR, \ke, \val) \in \opset$. Recall that $\tau = \tau' \xrightarrow{(\cl, \opset)}_{\ET_{\top}} (\hh, \viewFun)$, 
and $\lastConf(\tau') = (\hh_{\aexec_{\tau'}}, \viewFun')$ for some $\viewFun'$. That is, we have that 
$(\hh_{\aexec_{\tau'}}, \viewFun') \xrightarrowtriangle{(\cl, \opset)}_{\ET_{\top}} (\hh, \viewFun)$, 
which in turn implies that $\ET_{\top} \vdash (\hh_{\aexec_{\tau'}}, \viewFun'(\cl)) \triangleright \opset : \viewFun(\cl)$. 
Let then $r : = \max\{i \mid  i \in \viewFun'(\cl)(\ke)\}$. 
By definition of execution test, and because $(\otR, \ke, \val) \in \opset$, then it must be the case that 
$\hh_{\aexec_{\tau'}}(\ke, r) = (\val, \txid'', \_)$ for some $\txid''$. 

We prove that 
$\txid'' = \max_{\AR_{\aexec_{\tau}}}(\VIS^{-1}_{\aexec_{\tau}}(\txid) \cap \{ \txid'' \mid (\otW, \ke, \_) \in_{\aexec_{\tau}} \txid''\})$. 
To this end, note that 
\[ 
\VIS^{-1}_{\aexec_{\tau}}(\txid) = \Tx(\hh_{\aexec_{\tau'}}, \viewFun'(\cl)) = \{\WTx(\hh_{\aexec_{\tau'}}(\ke',  i)) \mid \ke' \in \Keys \wedge  i \in \viewFun'(\cl)(\ke')\}.
\]
Note that $r \in \viewFun'(\cl)(\ke)$, and $\txid'' = \WTx(\hh_{\aexec_{\tau'}}(\ke, r))$. 
Therefore, $\txid'' \in \VIS^{-1}_{\aexec_{\tau}}(\txid)$. 
Because $\hh = \updateKV(\hh_{\aexec_{\tau'}}, \viewFun'(\cl), \txid, \opset)$, it 
must be the case that $\WTx(\hh(\ke, r)) = \txid''$. Also, because $\WTx(\hh_{\aexec_{\tau'}}(\ke, r) = \txid'') = \txid''$, 
then $(\otW, \ke, \_) \in_{\aexec_{\tau''}} \txid''$, or equivalently $(\otW, \ke, \_) \in \TtoOp{T}_{\aexec_{\tau'}}(\txid'')$. 
We have already proved that $\VIS_{\aexec_{\tau}}$ is irreflexive, hence it must be the case that $\txid'' \neq \txid$. 
In particular, because $\aexec_{\tau} = \extend(\aexec_{\tau'}, \txid, \_, \_)$, then we have that 
$\TtoOp{T}_{\aexec_{\tau}}(\txid'') = \TtoOp{T}_{\aexec_{\tau'}}\rmto{\txid}{\opset}(\txid'') = 
\TtoOp{T}_{\aexec_{\tau'}}(\txid'')$, hence $(\otW, \ke, \_) \in \TtoOp{T}_{\aexec_{\tau}}(\txid'')$. Equivalently, 
$(\otW, \ke, \_) \in_{\aexec_{\tau}} \txid''$. We have proved that $\txid'' \in \VIS^{-1}_{\aexec_{\tau}}(\txid)$, 
and $(\otW, \ke, \_) \in_{\aexec_{\tau}} \txid''$. 

Now let $\txid'''$ be such that $\txid''' \in \VIS^{-1}_{\aexec_{\tau}}(\txid)$, and $(\otW, \ke \_) \in_{\aexec_{\tau}} \txid'''$. 
Note that $\txid''' \neq \txid$ because $\VIS_{\aexec_{\tau}}$ is irreflexive.
We show that either $\txid''' = \txid''$, or $\txid''' \xrightarrow{\AR_{\aexec_{\tau}}} \txid''$. 
Because $\txid''' \in \VIS^{-1}_{\aexec_{\tau}}(\txid)$, then there exists a key $\ke'$ and an index $i \in \viewFun'(\cl)$ 
such that $\WTx(\hh_{\aexec_{\tau'}}(\ke', i)) = \txid'''$. Because $(\otW, \ke, \_) \in_{\aexec_{\tau}} \txid'''$, 
and because $\txid''' \neq \txid$, then $(\otW, \ke, \_) \in_{\aexec_{\tau'}} \txid'''$, and therefore there exists 
an index $j$ such that $\WTx(\hh_{\aexec_{\tau'}}(\ke, j)) = \txid'''$. We have that $\WTx(\hh_{\aexec_{\tau'}}(\ke, j) = 
\WTx(\hh_{\aexec_{\tau'}}(\ke', i))$, and $i \in \viewFun'(\cl)$. By \cref{eq:view.atomic}, it must be $j \in \viewFun'(\cl)$. 
Note that $r = \max\{i \mid i \in \viewFun'(\cl)\}$, hence we have that $j \leq r$. If $j = r$, then $\txid''' = \txid''$ and 
there is nothing left to prove. If $j < r$, then we have that $(\txid''', \txid'') \in \AR_{\aexec_{\tau'}}$, and 
therefore $(\txid''', \txid'') \in \AR_{\aexec_{\tau}}$.
\end{itemize}
Finally, we need to prove that $\hh = \hh_{\aexec_{\tau}}$.
Recall that $\hh = \updateKV(\hh_{\aexec_{\tau'}}, \viewFun'(\cl), \txid, \opset)$, 
and $\aexec_{\tau} = \extend(\aexec_{\tau'}, \txid, \Tx(\hh_{\aexec_{\tau'}}, \viewFun'(\cl), \opset)$. 
The result follows then from \cref{prop:extend.update.sameop}. 
\end{itemize}
\end{proof}

\begin{lemma}
\label{lem:updatekv.preserveviews}
Let $\hh$ be a kv-store, and let $\txid \notin \hh$. For any $\vi, \vi' \in \Views(\hh)$, 
view $\vi'$ and set of operations $\opset$, then $\vi \in \updateKV(\hh, \txid, \vi', \opset)$.
\end{lemma}

\begin{proof}
Immediate from the definition of $\updateKV$. The fact that $\txid \notin \hh$ ensures that 
$\vi$ satisfies \eqref{eq:view.atomic} with respect to $\updateKV(\hh, \txid, \vi', \opset)$.
\end{proof}


\begin{lemma}
\label{lem:cut.views}
Let $\aexec$ be an abstract execution, with 
$\T_{\aexec} = \{\txid_{i}\}_{i = 1}^{n}$ for 
$n = \lvert \T_{\aexec} \rvert$, with $\txid_{i} \xrightarrow{\AR_{\aexec}} \txid_{i+1}$ 
for all $i=0,\cdots, n-1$.  Let $\T_{0} = \emptyset$, and for $i=1,\cdots, n$, Let $\T_{i} \subseteq \AR^{-1}?(\txid_{i})$. 
Then $\getView(\aexec, \T_{i}) \in \Views(\hh_{\cut(\aexec, i)})$.
\end{lemma}

\begin{proof}
By induction on $i$. 
\begin{itemize}
\item If $i = 0$, then $\T_{0} = \emptyset$, and $\getView(\aexec, \T_{0}) = \lambda \ke. \{0 \}$. 
We also have that $\hh_{\cut(\aexec, 0)} = \lambda \ke. \List{(\val_0, \txid_{0}, \emptyset)}$, hence 
it is immediate to see that $\getView(\aexec, \T_{0}) \in \Views(\hh_{\cut(\aexec, 0)})$.

\item Let $i = i'+1$, and suppose that for any $\T \subseteq (\AR_{\aexec}^{-1}?)(\txid_{i'})$, 
$\getView(\aexec, \T) \in \Views(\hh_{\cut(\aexec, i)})$. Consider the set $\T_{i}$.
Note that, because of \cref{prop:extend.update.sameop}, we have that
\[
\begin{array}{ll}
\hh_{\cut(\aexec, i)} &=\\ 
\hh_{\extend(\cut(\aexec, i'), \txid_{i}, \VIS^{-1}_{\aexec}(\txid_{i}), \TtoOp{T}_{\aexec}(\txid_{i})} &= \\
\updateKV(\hh_{\cut(\aexec, i')}, \txid_{i}, \getView(\VIS^{-1}_{\aexec}(\txid_{i}), \TtoOp{T}_{\aexec}(\txid_{i})
\end{array}
\]
We consider two possibilities.
\begin{enumerate}
\item $\txid_{i} \notin \T_{i}$, in which case $\T_{i} \subseteq (\AR_{\aexec}^{-1})?(\txid_{i'})$, 
and from the inductive hypothesis we get $\getView(\aexec, \T_{i}) \in \Views(\hh_{\cut(\aexec, i')})$. 
Note that, from \ref{lem:cut.explicit} it must be the case that $\hh_{\cut, \aexec, i')}$ only contains 
the transactions identifiers from $\txid_{1}$ to $\txid_{i'}$; in particular, it does not contain 
$\txid_{i}$. Because $\hh_{\cut(\aexec, i)} = \updateKV(\hh_{\cut(\aexec, i')}, \txid_{i}, \_, \_)$, 
then by \ref{lem:updatekv.preserveviews} we have that  
$\getView(\aexec, \txid_{i}) \in \Views(\hh_{\cut(\aexec, i)})$.

\item $\txid \in \T_{i}$. Note that for any key $\ke$ such that 
$(\otW, \ke, \_) \notin \TtoOp{T}_{\aexec}(\txid_{i})$, then 
$\getView(\aexec, \T_{i})(\ke) = \getView(\aexec, \T_{i} \setminus \{(\txid_{i})\})(\ke)$; 
and for any key $\ke$ such that $(\otW, \ke, \_) \in \TtoOp{T}_{\aexec}(\txid_{i})$, 
then $\getView(\aexec, \T_{i}(\ke) = \getView(\aexec, \T_{i} \setminus \{\txid_{i}\})(\ke) 
\cup \{j \mid \WTx(\hh_{\aexec}(\ke, i)) = \txid_{j}\}$. Note that in this last case the index 
$j$ must be such that $j < \lvert \hh_{cut(\aexec, i)} \rvert - 1$, because we know that 
$\txid_{i} \in \hh_{\cut(\aexec, i)}$. It follows from this fact and the inductive hypothesis, 
that $\getView(\aexec, \T_{i}) \in \Views(\cut(\aexec, i))$.
\ac{This is a really loose proof sketch. The reason for an incomplete proof is 
that i got bored while typing it.} 
\end{enumerate}
\end{itemize}
\end{proof}

\begin{proposition}
\label{prop:extend.update.sameop}
Let $\aexec$ be an abstract execution, $\T \subseteq \T_{\aexec}$ be a set of transactions, 
$\txid \notin \T_{\aexec}$ be a transaction identifier, and $\opset \subseteq \powerset{\Ops}$. 
Let $\aexec' = \extend(\aexec, \T, \txid, \opset)$. 
Let $\vi = \getView(\hh_{\aexec}, \T)$. 
Then $\updateKV(\hh_{\aexec}, \vi, \txid, \opset) = \hh_{\aexec'}$.
\end{proposition}

\begin{proof}
Let $\Gr = \Gr_{(\updateKV(\hh_{\aexec}, \vi, \txid, \opset)}$, $\Gr' = \graphof(\aexec')$. 
Note that $\hh_{\aexec'}$ is the unique kv-store such that $\Gr_{\hh_{\aexec'}} = \graphof(\aexec') = \Gr'$. 
It suffices to prove that $\Gr = \Gr'$. Because the function $\Gr_{\cdot}$ is injective, it follows that 
$\updateKV(\hh_{\aexec}, \vi, \txid, \opset) = \hh_{\aexec'}$, as we wanted to prove.  

The proof is a simple consequence of \cref{lem:graph.extend} and \cref{lem:graph.update}. 
Consider the dependency graph $\Gr_{\hh_{\aexec}}$, and recall that $\hh_{\aexec}$. 
is the unique kv-store such that $\Gr_{\hh_{\aexec}} = \graphof(\aexec)$. 
We prove that $\TtoOp{T}_{\Gr} = \TtoOp{T}_{\Gr'}$, $\RF_{\Gr} = \RF_{\Gr'}$ and 
$\VO_{\Gr} = \VO_{\Gr'}$ (from the last two it follows that $\AD_{\Gr} = \AD_{\Gr'}$). 
We only supply th most interesting details of the proof.

Suppose that $\txid' \xrightarrow{\RF_{\Gr}(\ke)} \txid''$ for some $\txid', \txid''$. 
By \ref{lem:graph.update} we have that either $\txid' \xrightarrow{\RF_{\Gr_{\hh_{\aexec}}}(\ke)} \txid''$, 
or $\txid'' = \txid$, $(\otR, \ke, \_) \in \opset$, $\txid' = \max_{\VO_{\Gr_{\hh_{\aexec}}}(\ke)}\{\WTx(\ke, i) \mid i \in \vi(\ke)\}$. 

If $\txid' \xrightarrow{\RF_{\Gr_{\hh_{\aexec}}}}(\ke) \txid''$, then because 
$\Gr_{\hh_{\aexec}} = \graphof(\aexec)$, we have that $\txid' \xrightarrow{\RF_{\graphof(\aexec)}(\ke)} \txid''$. 
Recall that $\Gr' = \graphof(\extend(\aexec, \T, \txid, \opset))$, hence by \cref{lem:graph.extend} 
we obtain that $\txid' \xrightarrow{\RF_{\Gr'}(\ke)} \txid''$. 

If $\txid'' = \txid$, $(\otR, \ke, \_) \in \opset$, and $\txid' = \max_{\VO_{\Gr_{\hh_{\aexec}}}(\ke)} \{ \WTx(\hh_{\aexec}(\ke, i)) \mid i \in \vi(\ke)\}$, 
then we also have that $\txid' = \max_{\VO_{\graphof(\aexec)}(\ke)} (\T \cap \{ \txid''' \mid (\otW, \ke, \_) \in_{\aexec} \txid'''\}) $. 
This is because of the assumption that 
\[
\begin{array}{lr}
\{\WTx(\hh_{\aexec}(\ke, i)) \mid i \in \vi(\ke)\} &= \\
 \{\WTx(\hh_{\aexec}(\ke', i)) \mid \ke' \in \Keys \wedge i \in \vi(\ke')\} \cap \{\WTx(\hh_{\aexec}(\ke, \_)\} &=\\ 
 \Tx(\hh_{\aexec}, \vi) \cap \{\WTx(\hh_{\aexec}(\ke, \_)\} &=\\
 \T \cap \{(\txid''' \mid (\otW, \ke, \_) \in_{\aexec} \txid''')\}
 \end{array}
\]
Again, it follows from \cref{lem:graph.extend} that $\txid' \xrightarrow{\RF_{\Gr'}(\ke)} \txid''$. 
\end{proof}

Next, we show to construct, given an abstract execution $\aexec$, 
a set of $\ET_{\top}$-traces $\KVtrace(\ET_{\top}, \aexec)$ in normal form such that for any 
$\tr \in \KVtrace(\ET_{\top}, \aexec)$, $\lastConf(\tr) = (\hh_{\aexec}, \_)$. 
To define the function $\KVtrace(\ET_{\top}, \_)$ formally, 
we first provide a principle to reason about abstract executions inductively in \cref{def:aexec.inductive}. 

\begin{definition}
\label{def:aexec.inductive}
Let $\aexec$ be an abstract execution, let $n = \lvert \T_{\aexec} \rvert$, and let 
$\{\txid_{i}\}_{i=1}^{n} \subseteq \T_{\aexec}$ be such that for any $i=1,\cdots,n-1$, 
$\txid_{i} \xrightarrow{\AR_{\aexec}} \txid_{i+1}$. 
For $i = 0,\cdots, n-1$, define 
\[
\begin{array}{lll}
\cut(\aexec, 0) & \defeq & ([], \emptyset, \emptyset)\\
\cut(\aexec , i+1) & \defeq & \extend(\cut(\aexec, i), \txid_{i+1}, \VIS^{-1}_{\aexec}(\txid_{i+1}), \TtoOp{T}_{\aexec}(\txid_{i+1}))
\end{array}
\]
\end{definition}

\begin{proposition}
\label{prop:aexec.inductive}
For any abstract execution $\aexec$, $\aexec = \cut(\aexec, \lvert \T_{\aexec} \rvert)$.
\end{proposition}
\begin{proof}
    This is now an instantiation of \cref{lem:cut.explicit}, choosing $i = \lvert \T_{\aexec} \rvert$. \qed
\end{proof}

\begin{lemma}
\label{lem:cut.explicit}
For any abstract execution $\aexec$, and index $i: i \leq j \leq \lvert \T_{\aexec} \rvert$, 
let $\T_{\aexec} = \{\txid_{i}\}_{i=1}^{n}$ be such that $\txid_{1} \xrightarrow{\AR_{\aexec}}
\txid_{n}$. Then $\cut(\aexec, i) = \aexec_{i}$, where 
\[
\begin{array}{lcr}
\TtoOp{T}_{\aexec_{i}}(\txid) &=& 
\begin{cases}
\TtoOp{T}_{\aexec}(\txid) &\impliedby \exists j \leq i.\; \txid = \txid_{j}\\
\text{undefined} &\impliedby \text{otherwise}\\
\end{cases}
\\
\VIS_{\aexec_{i}} &=& \{ (\txid, \txid') \in \T_{\aexec_{i}} \mid \txid \xrightarrow{\VIS_{\aexec}} \txid'\}\\
\AR_{\aexec_{i}} &=& \{ (\txid, \txid') \in \T_{\aexec_{i}} \mid \txid \xrightarrow{\AR_{\aexec}} \txid'\}
\end{array}
\]
\end{lemma}

\begin{proof}
Fix an abstract execution $\aexec$. We prove the claim by induction on $i = \lvert \T_{\aexec} \rvert$.
\begin{itemize}
\item Base case: $i = 0$. Then note that $\TtoOp{T}_{\aexec'} = [], \VIS_{\aexec'} = \emptyset$, 
$\AR_{\aexec'} = \emptyset$, which leads to $\aexec' = \cut(\aexec, 0)$. 
\item Let $i = i' + 1$, and assume that $\cut(\aexec, i') = \aexec_{i'}$. 
We prove the following: 
\begin{enumerate}
\item $\TtoOp{T}_{\cut(\aexec, i)} = \TtoOp{T}_{\aexec_i}$. 
By definition, 
\[
\begin{array}{lr}
\TtoOp{T}_{\cut(\aexec,i)} = \TtoOp{T}_{\cut(\aexec, i')}\rmto{\txid_{i}}{\TtoOp{T}_{\aexec}(\txid_{i})} &= \\
\TtoOp{T}_{\aexec_{i'}}\rmto{\txid_{i}}{\TtoOp{T}_{\aexec}}(\txid_{i}) = \TtoOp{T}_{\aexec_{i}}
\end{array}
\]
\item $\VIS_{\cut(\aexec, i)} = \VIS_{\aexec_{i}}$. 
Note that, by inductive hypothesis, $\T_{\cut(\aexec, i')} = \T_{\aexec_{i'}} = \{\txid_{j}\}_{j=1}^{i'}$. 
We have that  
\[
\begin{array}{lr}
\VIS_{\cut(\aexec, i)} = \VIS_{\cut(\aexec, i')} \cup \{(\txid_j, \txid_{i}) \in \VIS_{\aexec} \mid j = 1,\cdots, i'\} &= \\
\VIS_{\aexec_{i'}} \cup \{(\txid_{j}, \txid_{i}) \in \VIS_{\aexec} \mid j=1,\cdots, i'\} = 
\{(\txid_{j'}, \txid_{j}) \in \VIS_{\aexec} \mid j', j = 0,\cdots, i'\} \cup \{(\txid_{j}, \txid_{i} \in \VIS_{\aexec} \mid j=1,\cdots, i'\} &=\\
\{(\txid_{j'}, \txid_{j} \in \VIS_{\aexec} \mid j',j = 0,\cdots, i\} = \VIS_{\aexec_{i}}.
\end{array}
\]
\item $\AR_{\cut(\aexec, i)} = \AR_{\aexec_{i}}$. This can be proved in the same way 
as the item above. 
\end{enumerate}
\end{itemize}
\end{proof}

Given above, the conversion from abstract execution tests to \( \ET \) traces is in \cref{def:aexec2kvtrace}.

\begin{definition}
\label{def:aexec2kvtrace}
Given an abstract execution $\aexec$, a client $\cl$ and an integer $i=0,\cdots, \lvert \aexec \rvert$, 
define $\nextTx(\aexec, \cl, i) \defeq \min_{\AR_{\aexec}}\{\txid_{\cl}^{j} \mid \txid_{\cl}^{n} \notin \T_{\cut(\aexec, i)}\}$. 
Note that $\nextTx(\aexec, \cl, i)$ could be undefined. 
Let $\Clients(\aexec) \defeq \{\cl \mid \exists n.\;\txid_{\cl}^{n} \in \T_{\aexec}\}$.

Given an abstract execution $\aexec$ and an integer $i = 0,\cdots, \lvert \T_{\aexec} \rvert$, let 
$\KVtrace(\ET_{\top}, \aexec, i)$ be the smallest set such that 
\begin{itemize}
\item 
$(\hh_{0}, \lambda \cl \in \Clients(\aexec). \lambda \ke.\{0\}) \in \KVtrace(\ET_{\top}, \aexec, 0)$, 
\item suppose that $\tr \in \KVtrace(\ET_{\top}, \aexec, i)$ for some $i = 0,\cdots, \lvert \T_{\aexec} \rvert - 1$.  
Let
\begin{itemize} 
\item $\txid = \min_{\AR_{\aexec}}(\T_{\aexec} \setminus T_{\cut(\aexec, i)})$, 
\item  $\cl, n$ be such that $\txid = \txid_{\cl}^{n}$, 
\item  $\vi = \getView(\aexec, \VIS^{-1}_{\aexec}(\txid_{\cl}^{n}))$, 
\item $\vi' = \getView(\aexec, \T)$, where $\T$ is an arbitrary subset of $\T_{\aexec}$ if 
$\nextTx(\aexec, \cl, i+1)$ is undefined, or is such that 
$\T \subseteq (\AR_{\aexec}^{-1})?(\txid) \cap \VIS^{-1}_{\aexec}(\nextTx(\cl, i+1))$, 
\item $\opset = \TtoOp{T}_{\aexec}(\txid)$, 
\item $(\hh_{\tr}, \viewFun_{\tr}) = \lastConf(\tr)$, 
\item $\hh = \updateKV(\hh_{\tr}, \vi, \txid, \opset)$.
\end{itemize}
Then
\[
\big( \tr \xrightarrowtriangle{(\cl, \varepsilon)}_{\ET_{\top}} (\hh_{\tr}, \viewFun_{\tr}\rmto{\cl}{\vi}) 
\xrightarrowtriangle{(\cl, \opset)}_{\ET_{\top}} (\hh, \viewFun_{\tr}\rmto{\cl}{\vi'}) \big) \in \KVtrace(\ET_{\top}, \aexec, i+1)
\]
\end{itemize}

Finally, we let $\KVtrace(\ET_{\top}, \aexec) \defeq \KVtrace(\ET_{\top}, \aexec, \lvert \T_\aexec \rvert)$.
\end{definition}

\begin{proposition}
\label{prop:aexec2kvtrace}
Let $\aexec$ be an abstract execution that satisfies $\RP_{\LWW}$, 
and let $\tr \in \KVtrace(\ET_{\top}, \aexec)$. Then $\lastConf(\tr) = (\hh_{\aexec}, \_)$ and $\hh_{\aexec} \in \CMs(\ET_{\top})$. 
\end{proposition}
\begin{proof}
Let $\aexec$ be an abstract execution that satisfies the last write wins policy. 
Let $n = \lvert \T_{\aexec} \rvert$. Fix $i =0,\cdots, n$, 
and let $\tr \in \KVtrace(\ET_{\top}, \aexec, i)$. We prove, by 
induction on $i$, that $\tr \in \CMs(\ET_{\top})$, and 
$\lastConf(\tr) = (\hh_{(\cut(\aexec, i)}, \_)$. 
Then the result follows from  \cref{prop:aexec.inductive}.

\begin{itemize}
\item Case $i = 0$. By definition, $\tr = (\kappa_{0}, \viewFun_{0})$, 
where $\viewFun_{0} = \lambda \cl \in \Clients(\aexec). \lambda \ke.\{0\}$. 
Clearly, we have that $\tr \in CMs(\ET_{\top})$. 
\item Case $i = i'+1$. Let $\txid_{i} = \min_{\AR_{\aexec}}(\T_{\aexec} \setminus \T_{\cut(\aexec, i')})$, 
and suppose that $\txid_{i} = \txid_{\cl}^{m}$ for some client $\cl$ and index $m$. 
Fix $\vi = \getView(\aexec, \VIS_{\aexec}^{-1}(\txid_{i}))$, and  $\opset = \TtoOp{T}_{\aexec}(\txid_{i})$, . 
Then there exists a trace $\tr' \in \KVtrace(\ET_{\top}, \aexec, i')$ and a set 
$\T$ such that: 
\begin{enumerate}
\item if $\nextTx(\cl, \aexec, i)$ is undefined then $\T \subseteq \T_{\aexec}$, otherwise 
$\T \subseteq \VIS^{-1}_{\aexec}(\nextTx(\cl, \aexec, i)) \cap (\AR_{\aexec}^{-1})?(\txid_{i})$, 
\item
\[
\tr = \tr' \xrightarrowtriangle{(\cl, \varepsilon)} (\hh_{\tr'}, \viewFun_{\tr'}\rmto{\cl}{\vi}) \xrightarrowtriangle{(\cl, \opset)} 
(\hh,  \viewFun_{\tr'}\rmto{\cl}{\vi'}),
\]
where $(\hh_{\tr'}, \viewFun_{\tr'}) = \lastConf(\tr')$, and $\hh = \updateKV(\hh_{\tr'}, \vi, \txid_{i}, \opset)$, 
and $\vi' = \getView(\aexec, \T)$.
\end{enumerate}
By inductive hypothesis, we may assume that $\tr' \in \CMs(\ET_{\top})$, and $\hh_{\tr'} = \hh_{\cut(\aexec, i')}$. 
We prove the following facts: 
\begin{enumerate}
\item $\hh = \hh_{\extend(\cut(\aexec, i)}$: because of 
\ref{prop:extend.update.sameop} and \cref{prop:aexec.inductive} 
we obtain 
\[
\begin{array}{lr}
\hh = \updateKV(\hh_{\tr'}, \vi, \txid_{i}, \opset) &=\\ 
\updateKV(\hh_{\cut(\aexec, i')}, \getView(\aexec, \VIS^{-1}_{\aexec}(\txid_{i}), \txid_{i}, \TtoOp{T}_{\aexec}(\txid_{i})) &=\\
\hh_{\extend(\cut(\aexec, i'), \VIS^{-1}_{\aexec}(\txid_{i}), \txid_{i}, \TtoOp{T}_{\aexec}(\txid_{i})) }&=\\
\hh_{\extend(\cut(\aexec, i))}.
\end{array}
\]

\item $(\hh_{\tr'}, \viewFun_{\tr'}) \xrightarrowtriangle{(\cl, \varepsilon)}_{\ET_{\top}} (\hh_{\tr'}, \viewFun_{\tr'}\rmto{\cl}{\vi})$. 
To this end, it suffices to prove that for any key $\ke$, $\viewFun_{\tr'}(\cl) \viewleq \vi$. 
By \cref{lem:cut.explicit} we have that $\T_{\cut(\aexec, i')} = \{\txid_{j}\}_{j=1}^{i'}$, for 
some $\txid_{1},\cdots, \txid_{i'}$ such that whenever $1 \leq j < j' \leq i'$, then 
$\txid_{j} \xrightarrow{\AR_{\aexec}} \txid_{j'}$. We consider two possible cases: 

\begin{itemize}
\item For all $j =1,\cdots, i'$, for all $h \in \nat$, $\txid_{j} \neq \txid_{\cl}^{h}$. In 
this case we have that no transition contained in $\tr'$ has the form 
$(_, \_) \xrightarrowtriangle{(\cl, \_)} (\_, \_)$, from which it is possible to infer 
that  $\viewFun_{\tr'}(\cl) = \lambda \ke. \{0\}$. Because $\vi = \getView(\aexec, \VIS^{-1}_{\aexec}(\txid_{i}))$, 
then by definition we have that $0 \in \vi(\ke)$ for all keys $\ke \in \Keys$. It follows that 
$\viewFun_{\tr'}(\cl) \viewleq \vi$. 
\item There exists an index $j = 1,\cdots, n$ and an integer $h \in \nat$ such that $\txid_{j} = \txid_{\cl}^{h}$. 
Without loss of generality, let $j$ be the largest such index. It follows that the last transition in $\tr'$ of the form 
$(\_, \_) \xrightarrow{(\cl, \opset_{j})} (\_, \viewFun_{\mathsf{pre}})$ is such that $\viewFun_{\mathsf{pre}}(\cl) = 
\getView(\aexec, \T_{\mathsf{pre}})$, for some $\T_{\mathsf{pre}} \subseteq \VIS^{-1}_{\aexec}(\txid_{i}) \cap 
(\AR^{-1}_{\aexec})?(\txid_{j})$. This is because $\nextTx(\cl, \aexec, j)$  is defined and equal to $\txid_{i}$. 
Furthermore, because the trace $\tr'$ is in normal form by construction, in $\tr'$ a transition of the form 
$(\_, \_) \xrightarrowtriangle{(\cl, \varepsilon)}_{\ET_{\top}} (\_, \_)$ is always followed by a transition of the form
$(\_, \_) \xrightarrowtriangle{(\cl, \opset')}_{\ET_{\top}} (\_, \_)$. Because we are assuming that the last transition where client 
$\cl$ executes a transaction in $\tr'$ has the form $(\_, \_) \xrightarrowtriangle{(\cl, \opset_{j})}_{\ET_{\top}} (\_, \viewFun_{\mathsf{pre}})$, 
then the latter is also the last transition for client $\cl$ in $\tr'$ (i.e. including both execution of transactions and view updates). 
It follows that $\viewFun_{\tr'}(\cl) = \viewFun_{\mathsf{pre}}(\cl)$, and in particular 
$\viewFun_{\tr'}(\cl) = \getView(\aexec, \T_{\mathsf{pre}})$. By definition, 
$\T_{\mathsf{pre}} \subseteq  \VIS^{-1}_{\aexec}(\txid_{i}) \cap (\AR^{-1}_{\aexec})?(\txid_{j}) 
\subseteq \VIS^{-1}_{\aexec}(\txid_{i})$. By  \cref{lem:getView.monotone}, 
we have that $\viewFun_{\tr'}(\cl) = \getView(\aexec, \T_{\mathsf{pre}}) \viewleq 
\getView(\aexec, \VIS^{-1}_{\aexec}(\txid_{i})) = \vi$, as we wanted to prove.
\ac{Note: this is more a sketch, rather than a real proof. A Proposition giving an explicit form to the 
structure of any $\tr \in \KVtrace(\ET_{\top}, \aexec)$ would be helpful for a more rigorous proof here.}
\end{itemize}


\item $(\hh_{\tr'}, \viewFun_{\tr'}\rmto{\cl}{\vi}) \xrightarrowtriangle{(\cl, \opset)}_{\ET_{\top}} 
(\hh,  \viewFun_{\tr'}\rmto{\cl}{\vi'})$. It suffices to show that $\ET_{\top} \vdash (\hh_{\tr'}, \vi) 
\triangleright \opset: \vi'$. That is, it suffices to show that $\vi \in \Views(\hh_{\tr'})$, 
$\vi' \in \Views(\hh)$, and whenever $(\otR, \ke, \val) \in \opset$, then 
$\max_{<}(\vi(\ke)) = (\val, \_, \_)$. The first two facts are a consequence of 
\ref{lem:cut.views}, the fact that $\hh_{\tr'} = \hh_{\cut(\aexec, i')}$, and the fact that 
$\hh_{\cut(\aexec, i)}$. The fact that if $(\otR, \ke, \val) \in \opset$ then 
$\max_{<}(\vi(\ke) = (\val, \_, \_)$ follows from the fact that $\aexec$ satisfies 
the last write wins policy, and the fact that $\vi = \getView(\VIS^{-1}_{\aexec}(\txid_{i})$.
\ac{Again, the proof is really loose here, mostly because I got bored.}
\end{enumerate} 

\end{itemize}
\end{proof}


\begin{lemma}
\label{lem:getView.monotone}
Let $\aexec$ be an abstract execution, and let $\T_1 \subseteq \T_2 \subseteq \T_{\aexec}$. 
Then $\getView(\aexec, \T_1) \viewleq \getView(\aexec, \T_2)$.
\end{lemma}
\begin{proof}
Fix $\ke \in \Keys$. By definition  
\[
\begin{array}{lr}
\getView(\aexec, \T_1)(\ke) = \{0\} \cup \{ i \mid i = 1,\cdots, \lvert \hh_{\aexec}(\ke) \rvert - 1 \wedge \WTx(\hh_{\aexec}(\ke, i)) \in \T_1\} &\subseteq\\
\{0\} \cup \{i \mid i=1,\cdots, \lvert \hh_{\aexec}(\ke) \rvert - 1 \wedge \WTx(\hh_{\aexec}(\ke, i)) \in \T_2\} & = \\
\getView(\aexec, \T_2)(\ke).
\end{array}
\]
It follows that  $\getView(\aexec, \T_1) \viewleq \getView(\aexec, \T_2)$.
\end{proof}

Now we can prove \cref{thm:kvtrace2aexec}.
The last statement in \cref{thm:kvtrace2aexec} implies that there is a \emph{Galois connection}
between the set of $\ET_{\top}$-traces, and the set of abstract executions that satisfy the 
last write wins policy. The lower and upper adjoints of this connection are the 
lifting of the functions $\aeset(\cdot)$ and $\KVtrace(\cdot)$ to sets of $\ET_{\top}$-traces 
and abstract executions, respectively. Note however that these two sets are not isomorphic: 
when converting a set of abstract executions into kv-traces, we abstract away the 
pairs $\txid \xrightarrow{\VIS} \txid'$ in the visibility relation where $\txid$ is a read-only 
transaction. When converting a $\ET_{\top}$-trace into a set of abstract executions, 
we (partially) lose the information about the view that a clients has, immediately after it executed a transaction.

\begin{theorem}
\label{thm:kvtrace2aexec}
Let $\tr$ be a $\ET_{\top}$-trace; there exists a set of abstract executions $\aeset({\tr})$ 
such that, for any $\hh \in \aeset(\tr)$, $\lastConf(\tr) = (\hh, \_)$.
Let $\aexec$ be an abstract execution that satisfies the last write wins resolution policy. 
There exists a set of $\ET_{\top}$-traces $\KVtrace({\aexec})$ in normal form, 
such that for any $\tr \in \KVtrace({\aexec})$, $\lastConf(\tr) = (\hh_{\aexec}, \_)$. 
\end{theorem}
\begin{proof}
    For readability the proof is in \cref{sec:kvtrace2aexec}.
\end{proof}

\begin{corollary} 
\label{cor:kvtrace2aexec}
$\CMs(\ET_{\top}) = \{\hh_{\aexec} \mid \aexec \text{ satisfies } \RP_{\LWW}\}$.
\end{corollary}




