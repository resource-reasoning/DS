\subsection{Proof of Theorem \ref{thm:aexec2kv.compatible}}
\label{app:aexec2kv}
\label{sec:thm:aexec2kv-compatible-proof}

To recall, the function $\getView(\aexec, \stub)$ is defined by letting 
$\getView(\aexec, \T) = \lambda \ke. \{0\} \cup \{ i \mid i \in [\lvert \hh_{\aexec} \rvert - 1] \wedge 
\WTx(\hh_{\aexec}(\ke, i)) \in \T\}$.

\begin{proposition}
\label{prop:getview.valid}
For any abstract execution $\aexec$, and $\T \subseteq \T_{\aexec}$, 
$\getView(\aexec, \T) \in \Views(\hh_{\aexec})$.
\end{proposition}
\begin{proof}
Let $\aexec$ be an abstract execution, and let 
$\T \subseteq \T_{\aexec}$. 
It is immediate from the definition of $\getView(\aexec, \T)$ that 
$0 \in \getView(\aexec, \T)$, and $\forall \ke.\forall i \in \getView(\aexec, \T). i < \lvert \hh_{\aexec}(\ke) \rvert$, 
therefore we only need to prove that $\getView(\aexec, \T)$ satisfies \eqref{eq:view.atomic}.
Let $j \in \getView(\aexec, \T)(\ke)$ for some key $\ke$, and let $\txid = 
\WTx(\hh_{\aexec}(\ke, j))$. Let also $\ke', i$ be such that 
$\WTx(\hh_{\aexec}(\ke', i)) = \txid$. We need to show that 
$i \in \getView(\aexec, \T)(\ke')$. Note that it $\txid = \txid_{0}$ 
then $\WTx(\hh_{\aexec}(\ke', i)) = \txid$ only if $i = 0$, and 
$0 \in \getView(\aexec, \T)(\ke')$ by definition. 
Let then $\txid \neq \txid_{0}$. Because $\WTx(\hh_{\aexec}(\ke, j)) = \txid$ 
and $j \in \getView(\aexec, \T)$, then it must be the case that $\txid \in \T$. 
Also, because $\WTx(\hh_{\aexec}(\ke', i)) = \txid$, then $(\otW, \ke, \_) \in 
\TtoOp{T}_{\aexec}(\txid)$. It follows that there exists an index $i' \in \getView(\aexec, \txid)(\ke')$ 
such that $\WTx(\hh_{\aexec}(\ke', i') = \txid$. By definition of 
$\hh_{\aexec}$, if $\WTx(\hh_{\aexec}(\ke', i') = \txid$, then it must 
be $i' = i$, and therefore $i \in \getView(\aexec, \txid)(\ke')$.

Let $\aexec$ be an abstract execution that satisfies the last write wins 
policy.
\end{proof}


\begin{proposition}
\label{prop:compatible.aexec2kv}
For any subset $\T \subseteq \T_{\aexec}$, $\RP_{\LWW}(\aexec, \T) = \{\snapshot(\hh_{\aexec}, \getView(\aexec, \T))\}$.
\end{proposition}

\begin{proof}
Fix $\T \subseteq \aexec$, and let $\{\hh\} = \RP_{\LWW}(\aexec, \T)$. We prove that, for any $\ke \in \Keys$, 
$\hh(\ke) = \snapshot(\getView(\aexec, \T))(\ke)$. We distinguish between two different cases: 
\begin{enumerate}
\item $\T \cap \{ \txid \mid (\otW, \ke, \_) \in_{\aexec} \txid \} = \emptyset$. 
In this case $\hh(\ke) = \val_0$. 
We know that $\graphof(\aexec)$ satisfies all the constraints required by the definition of dependency graph 
(\cite{laws}). Together with \ref{thm:kv2graph} it follows that $\hh_{\aexec}(\ke, 0) = (\val_0, \txid_0, \_)$.
We prove that $\getView(\aexec, \T)(\ke) = \{0\}$, 
hence 
\[ 
\snapshot(\hh_{\aexec}, \getView(\aexec, \T))(\ke) = \valueOf(\hh_{\aexec}(\ke, 0)) = \val_{0}.
\]
Note that whenever $(\otW, \ke, \_) \in_{\aexec} \txid$ for some $\txid$, then 
$\txid \notin \T$. Therefore, whenever $(\val, \txid, \_) = \hh_{\aexec}(\ke, i)$ for some $i \geq 0$, then 
$\txid \notin \T$.
\[
\getView(\aexec, \T)(\ke) = \{0\} \cup \{i \mid \WTx(\hh_{\aexec}(\ke, i)) \in \T)\} = \{0\} \cup \emptyset = \{0\}.
\]
\item Suppose now that $\T \cap \{ \txid \mid (\otW, \ke, \_) \in_{\aexec} \txid \} \neq \emptyset$. 
Let then $\txid = \max_{\AR_{\aexec}}(\T \cap \{\txid \mid (\otW, \ke, \_) \in_{\aexec} \txid\})$. 
Then $(\otW, \ke, \val) \in_{\aexec} \txid$ for some $\val \in \Val$. Furthermore, $\RP_{\LWW}(\aexec, \T)(\ke) = \val$.
By definition, $\txid' \in \T \cap \{ \txid \mid (\otW, \ke, \_) \in_{\aexec} \txid\}$, 
then either $\txid' = \txid$ or $\txid' \xrightarrow{\AR_{\aexec}} \txid$. The definition of 
$\graphof(\aexec)$ gives that $\txid' \xrightarrow{\VO_{\aexec}(\ke)} \txid$. 
Because $(\otW, \ke, \val) \in_{\aexec} \txid$, then there exists an index 
$i \geq 0$ such that $\hh_{\aexec}(\ke, i) = (\val, \txid, \_)$. Furthermore, 
whenever $\WTx(\ke, j) = \txid'$ for some $\txid'$ and $j > i$, then it must 
be the case that $\txid \xrightarrow{\VO_{\aexec}(\ke)} \txid'$, and because 
$\VO_{\aexec}(\ke)$ is transitive and irreflexive, it must be that  
$\neg( \txid' \xrightarrow{\VO_{\aexec}(\ke)} \txid)$ and $\txid \neq \txid'$: this implies that 
$\txid' \notin \T$. It follows that $\max(\getView(\aexec, \T)(\ke)) = i$, hence 
$\snapshot(\hh_{\aexec}, \getView(\aexec, \T)) = \valueOf(\hh_{\aexec}(\ke, i)) = \val$.
\end{enumerate}
\end{proof}

\begin{proposition}
\label{prop:getview.tx}
Let $\vi \in \Views_{\hh_{\aexec}}$, and let $\T \subseteq \T_{\aexec}$ be a 
set of read-only transactions in $\aexec$. Then 
$\getView(\aexec, \T \cup \Tx(\hh_{\aexec}, \vi)) = \vi$. 
\end{proposition}

\begin{proof}
Fix a key $\ke$. Suppose that $i \in \getView(\aexec, \T \cup \Tx(\hh_{\aexec}, \vi))(\ke)$. 
By definition, $\hh_{\aexec}(\ke, j) = (\_, \txid, \_)$ for some $\txid \in \T \cup \Tx(\hh_{\aexec}, \vi)$. 
Because $\T$ only contains read-only transactions, by definition of $\hh_{\aexec}$ there exists 
no index $j$ such that $\hh_{\aexec}(\ke, j) = (\_, \txid', \_)$ for some $\txid' \in \T$, 
hence it must be the case that $\txid \in \Tx(\hh_{\aexec}, \vi)$. By definition of $\Tx$, 
this is possible only if there exist a key $\ke'$ and an index $j$ such that $\hh_{\aexec}(\ke', \vi) = (\_, \txid, \_)$. 
Because $\vi$ is atomic by definition, and because $\hh_{\aexec}(\ke, i) = (\_, \txid, \_)$, then we have that $i \in vi$. 

Now suppose that $i \in \vi(\ke)$, and let $\hh_{\aexec}(\ke, i) = (\_, \txid, \_)$ for some $\txid$. 
This implies that $(\otW, \ke, \_) \in_{\aexec} \txid$.
By definition $\txid \in \Tx(\hh_{\aexec}, \vi)$, hence $\txid \in \T \cup \Tx(\hh_{\aexec}, \vi))$. 
Because $\txid \in \T \cup \Tx(\hh_{\aexec, \vi)}$, then for any key $\ke'$ such that 
$(\otW, \ke', \_) \in_{\aexec} \txid$, there exists an index $j \in \getView(\aexec, \T \cup \Tx(\hh_{\aexec}, \vi))$ 
$\hh(\ke', j) = (\_, \txid, \_)$; because kv-stores only allow a transaction to write at most one version 
per key, then the index $j$ is uniquely determined. In particular, we know that $(\otW, \ke, \_) \in_{\aexec} \txid$, 
and $\hh_{\aexec}(\ke, \i) = (\_, \txid, \_)$, from which it follows that $i \in \getView(\aexec, \T \cup \Tx(\hh_{\aexec}, \vi))(\ke)$.
\end{proof}

\begin{proposition}
\label{prop:compatible.kv2aexec}
Let $\vi \in \Views(\hh_{\aexec})$. Then there exists $\T \subseteq \T_{\aexec}$ 
such that $\getView(\aexec, \T) = \vi$, and $\RP_{\LWW}(\aexec, \T) = \snapshot(\hh_{\aexec}, \vi)$.
\end{proposition}

\begin{proof}
We only need to prove that, for any $\vi \in \Views(\hh_{\aexec})$, there exists $\T \subseteq \T_{\aexec}$ such 
that $\getView(\aexec, \T) = \vi$. Then it follows from \cref{prop:compatible.aexec2kv} that 
$\RP_{\LWW}(\aexec, \T) = \snapshot(\hh_{\aexec}, \vi)$. It suffices to choose $\T = \bigcup_{ke \in \Keys}(\{ \WTx(\hh_{\aexec}(\ke, i)) \mid i > 0 
\wedge i \in \vi(\ke)\})$.
Fix a key $\ke$, and let $i \in \vi(\ke)$. We prove that $i \in \getView(\aexec, \T)$. 
If $i = 0$, then $i \in \getView(\aexec, \T)$ by definition. 
Therefore, assume that $i > 0$. Let $\txid = \WTx(\hh_{\aexec}(\ke, i))$. It must be the case that $\txid \in \T$: by 
definition, $i \in \getView(\aexec, \T)(\ke)$.

Next, suppose that $i \in \getView(\aexec, \T)(\ke)$. We prove that $i \in \vi(\ke)$.
Note that if $i = 0$, then $i \in \vi(\ke)$ because of the 
definition of views. Let then $i > 0$. Because $i \in \getView(\aexec, \T)(\ke)$, we have that 
$\WTx(\hh_{\aexec}(\ke, i)) \in \T$.  Let $\txid := \WTx(\hh_{\aexec}(\ke, i))$. Because $i > 0$, 
it must be the case that $\txid \neq \txid_0$.
By definition, $\txid \in \T$ only if there 
exists an index $j$ and key $\ke'$, possibly different from $\ke$, such that $\WTx(\hh_{\aexec}(\ke', j)) = \txid$ and $j \in \vi(\ke')$. 
Because $\txid \neq \txid_0$ we have that $j > 0$. Finally, because $\vi$ is atomic by definition, $j \in \vi(\ke')$
$\WTx(\hh_{\aexec}(\ke', j)) = \txid = \WTx(\hh_{\aexec}(\ke, i))$, then it must be the case 
that $i \in \vi(\ke)$, which concludes the proof.
\end{proof}

