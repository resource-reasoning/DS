\subsection{Relationship between key-value stores and abstract execution}
\sx{SECTION NOT SURE}
\sx{%
    why this section? build connection; many literature specify consistency model use abstract execution,
    so we need to proof sound and complete with respect to wildly accepted spec.%
}
\label{sec:encoding-kv-to-aexec}
It remains to prove that our specifications given using execution tests 
capture the intended consistency models. 
In this section we relate the consistency models induced by execution tests with 
the axiomatic specifications of consistency models given in terms of abstract executions 
\cite{framework-concur,laws}. 

Abstract executions are a framework originally introduced in \cite{ev-transactions} 
to capture the run-time behaviour of clients interacting with a database. 
In abstract execution, two relations between transactions are introduced: 
the \emph{visibility} relation establishes when a transaction observes the effects of another transaction; 
and the \emph{arbitration} relation helps to determine the value of a key $\ke$ read by a transaction, 
in the case that the transaction observes multiple updates to $\ke$ performed by different transactions. 

\begin{definition}
\label{def:absexec}
\label{def:aexec}
An abstract execution is a triple $\aexec = (\TtoOp{T}, \VIS, \AR)$, where 
\begin{itemize}
    \item $\TtoOp{T}: \TxID_{0} \parfinfun \powerset{\Ops}$ is a partial, 
finite function mapping transaction identifiers to the set of operations that they perform,
\item $\VIS \subseteq \dom(\TtoOp{T}) \times \dom(\TtoOp{T})$ is an irreflexive relation, 
called \emph{visibility}, 
\item $\AR \subseteq \dom(\TtoOp{T}) \times \dom(\TtoOp{T})$ is a strict, total order 
such that $\VIS \subseteq \AR$, and whenever $\txid_{\cl}^{n} \xrightarrow{\AR} 
\txid_{\cl}^{m}$, then $n < m$.
\end{itemize} 
\end{definition}

The set of abstract executions is denoted by $\aeset$.
Given an abstract execution $\aexec = (\TtoOp{T}, \VIS, \AR)$, we let 
$\TtoOp{T}_{\aexec} = \TtoOp{T}$, $\T_{\aexec} = \dom(\TtoOp{T})$, $\VIS_{\aexec} = \VIS$ 
and $\AR_{\aexec} = \AR$. We also let $\PO_{\aexec}(\cl) = \Setcon{(\txid_{\cl}^{n}, \txid_{\cl}^{m})}{ \cl \in \Clients 
\wedge \txid_{\cl}^{n} \in \T_{\aexec} \wedge \txid_{\cl}^{m} \in \T_{\aexec} \wedge n < m}$, and 
$\PO_{\aexec} = \bigcup\limits_{\cl \in \Clients} \PO_{\aexec}(\cl)$.
We also use the notation $(\otR, \ke, \val) \in_{\aexec} \txid$ for $(\otR, \ke, \val) \in \TtoOp{T}_{\aexec}(\txid)$, 
and similarly for write operations. 
Given an abstract execution $\aexec$, a transaction $\txid \in \T_{\aexec}$, and a key $\ke$, 
we let $\visibleWrites_{\aexec}(\ke, \txid) = \{ \txid' \mid \txid' \xrightarrow{\VIS_{\aexec}} \txid \wedge 
(\otW, \ke, \_) \in_{\aexec} \txid'\}$.


%
%An abstract execution satisfies the \emph{last write win} policy if, whenever $(\otR, \ke, \val) \in_{\aexec} \txid$, 
%then either $\val = \val_0$ or $(\otW, \ke, \val) \in_{\aexec} \txid'$, where $\txid' = 
%\max_{\AR_{\aexec}}(\VIS_{\aexec}^{-1}(\txid))$.

%\begin{definition}
%\label{def:anarchic}
%The Anarchic resolution policy $\RP_{\anarchic}$ is defined by letting $\RP_{\anarchic}(\aexec, \T) = \Snapshots$.
%\end{definition}
%\ac{I know that the symbol $\anarchic$ will change in the future. This is just a comment to let you know that, when it 
%will happen, I will be very sad.}

\subsubsection{Specification of Consistency Models via Abstract Executions.}
%A consistency model can be thought as a set of abstract executions. 
Many works actually specify consistency models axiomatically on the abstract execution: 
an axiomatic specification comprises a resolution policy (for example last-write-win), 
and a set of axioms that constrain the visibility. 

\sx{what is resolution policy }

\begin{definition}
An axiom $\A$ is a function from abstract executions to relations between 
transactions, $\A: \aeset \rightarrow \powerset{\TxID \times \TxID}$, 
such that whenever $\aexec_1, \aexec_2$ agree on a subset of 
transactions $\T$, then $\A(\aexec_1) \cap (\T \times \T) \subseteq \A(\aexec_2)$.
\end{definition}

Let $\aexec_1, \aexec_2 \in \aeset$, let $\T \subseteq \T_{\aexec_1} \cap \T_{\aexec_2}$: 
$\aexec_1$ and $\aexec_2$ \emph{agree} on $\T$ if, and only if for any transactions \( \txid \) \( \txid' \) in \( \T \):
\[
\TtoOp{T}_{\aexec_1}(\txid) = \TtoOp{T}_{\aexec_2}(\txid) \wedge 
((\txid \xrightarrow{\VIS_{\aexec_1}} \txid') \iff (\txid \xrightarrow{\VIS_{\aexec_2}} \txid'))
\wedge ((\txid \xrightarrow{\AR_{\aexec_1}} \txid') \iff (\txid \xrightarrow{\AR_{\aexec_2}} \txid'))
\]
\begin{definition}
\label{def:rp}
A resolution policy $\RP$ is a function $\RP: \aeset \times \powerset{\TxID} \rightarrow \powerset{\Snapshots}$ 
such that, for any $\aexec_1, \aexec_2$ that agree on a subset of transactions $\T$, then 
$\RP(\aexec_1, \T) = \RP(\aexec_2, \T)$.
An abstract execution $\aexec$ satisfies the execution policy $\RP$ if, 
\[
    \fora{\txid \in \T_{\aexec} } 
    \exsts{ \h \in \RP(\aexec, \VIS_{\aexec}^{-1}(\txid)) }
    \fora{ \ke,\val } (\otR, \ke, \val) \in_{\aexec} \txid 
    \implies \h(\ke) = \val
\]
\end{definition}

\begin{definition}
\label{def:lww}
The Last Write Wins resolution policy $\RP_{\LWW}$ is defined as 
$\RP_{\LWW}(\aexec, \T) \defeq \{\h\}$ where
\[
\h = \lambda \ke. \text{let } \T_{\ke} = ( \T \cap \{\txid \mid (\otW,\ke, \_) \in_{\aexec} \txid\})  \text{ in }
\begin{cases}
\val_{0} &\impliedby \T_{\ke} =  \emptyset\\
\val &\impliedby (\otW, \ke, \val) \in_{\aexec} \max_{\AR_{\aexec}}(\T_{\ke})
\end{cases}
\]
\end{definition}

Throughout this report we will work mainly with the \emph{Last Write Wins} resolution policy, defined below. 
When discussing the operational semantics of transactional programs, 
we will also introduce the \emph{Anarchic} resolution policy.

\begin{definition}
An axiom $\A$ is a function from abstract executions to relations between 
transactions, $\A: \aeset \rightarrow \powerset{\TxID \times \TxID}$, 
such that whenever $\aexec_1, \aexec_2$ agree on a subset of 
transactions $\T$, then $\A(\aexec_1) \cap (\T \times \T) \subseteq \A(\aexec_2)$.
\end{definition}

\sx{Maybe we verbally say, we define a semantics that gives us a trace of abstract execution and we present the soundness and completeness theorm and says the challenge is kv does not have  a total order and read-only transaction related to  getView.
and the abstract execution does not have the information of view.}

\ac{Axioms of a consistency model are constraints of the form $\A(\aexec) \subseteq \VIS_{\aexec}$. 
For example, if we require $A(\aexec) = \AR_{\aexec}$, then the corresponding axiom is given 
by $\AR_{\aexec} \subseteq \VIS_{\aexec}$, thus capturing the serialisability of transactions 
(this axiom is equivalent to require that $\VIS_{\aexec}$ is a total order). The requirement on 
subsets of transactions on which abstract executions agree will be needed later, when 
we define an operational semantics of transactions where clients can append a new transaction $\txid$ 
at the tail of an abstract execution $\aexec$, which satisfies an axiom $\A$. This requirement ensures that 
we only need to check that the axiom is $\A$ is satisfied by the pre-visibility and pre-arbitration relation 
of the transaction $\txid$ in $\aexec'$. In fact, 
the resulting abstract execution $\aexec'$ agrees with $\aexec$ 
on the set $\T_{\aexec}$: in this case we'll note that we can rewrite 
$\A(\aexec') = \A(\aexec') \cap ((\T_{\aexec} \times \T_{\aexec}) ) \cup (\T_{\aexec} \times \{\txid\}))$. Then
 $\A(\aexec') \cap ((\T_{\aexec} \times \T_{\aexec})) \subseteq \A(\aexec) \cap (\T_{\aexec} \times \T_{\aexec}) 
 \subseteq \VIS_{\aexec} \cap (\T_{\aexec} \times \T_{\aexec}) \subseteq \VIS_{\aexec'}$, 
hence we only need to check that $\A(\aexec') \cap (\T_{\aexec} \times \{\txid\}) \subseteq \VIS_{\aexec'}$.}
We say that an abstract execution $\aexec$ satisfies an axiom $\A$, written 
$\aexec \models \A$, if 
$\A(\aexec) \subseteq \VIS_{\aexec}$. An abstract execution $\aexec$ 
satisfies a set of axioms $\Ax$, written $\aexec \models \Ax$,  if $\aexec \models 
\A$ for all $\A \in \Ax$. 

An axiomatic specification of a consistency model is given by a pair $(\RP, \Ax)$, 
where $\RP$ is a resolution policy and $\Ax$ is a set of axioms. An 
abstract execution $\aexec$ satisfies the consistency model, 
written $\aexec \models (\RP, \Ax)$ if it satisfies its individual components. 
The set of abstract executions induced by an axiomatic specification is given 
by $\CMa(\RP, \Ax) = \{ \aexec \mid \aexec \models (\RP, \Ax)\}$.

\mypar{Compatibility of kv-Stores and Abstract Executions.}
Throughout this section we focus on abstract executions that satisfy the 
resolution policy $\RP_{\LWW}$.
Such abstract executions can be converted into dependency graphs \cite{SIanaysis,laws}, 
which in turn are isomorphic to kv-stores (\cref{thm:kv2graph}). For the sake of completeness, 
we include the definition of the dependency graph and kv-store induced by an abstract execution below: 

\begin{definition}
\label{def:aexec2graph}
Given an abstract execution $\aexec$ that satisfies the last write wins policy,
the dependency graph $\graphof(\aexec) \defeq (\TtoOp{T}_{\aexec}, \RF_{\aexec}, 
\VO_{\aexec}, \AD_{\aexec})$ is defined by letting
\begin{itemize}
\item $\txid \xrightarrow{\RF_{\aexec}(\ke)} \txid'$ if and only if 
$\txid = \max_{\AR_{\aexec}}(\visibleWrites_{\aexec}(\ke, \txid'))$, 
\item $\txid \xrightarrow{\VO_{\aexec}(\ke)} \txid'$ if and only 
$\txid, \txid' \in_{\aexec} (\otW, \;\ke: \_)$ 
and $\txid \xrightarrow{\AR_{\aexec}} \txid'$,
\item $\txid \xrightarrow{\AD_{\aexec}(\ke)} \txid'$ if and only if either 
$(\otR, \ke, \_) \in_{\aexec} \txid, (\otW, \ke, \_) \in_{\aexec} \txid'$ and 
whenever $\txid'' \xrightarrow{\RF_{\aexec}(\ke)} \txid$, 
then $\txid'' \xrightarrow{\VO_{\aexec}(\ke)} \txid'$.
\end{itemize}
\end{definition}
Note that each abstract execution $\aexec$ determines a kv-store 
$\hh_{\aexec}$, as per \cref{def:aexec2graph} and \cref{thm:kv2graph}. 
Let $\hh$ be the unique kv-store such that $\Gr_{\hh} = \graphof(\aexec)$: then 
$\hh_{\aexec} = \hh$. As we discuss later in this Section, this mapping 
$\hh_{(\stub)}$ is not a bijection, in that several abstract executions may be 
encoded in the same kv-store. This is because kv-stores abstract the total 
arbitration order of transactions away.

%On the other hand, 
%abstract executions are endowed with more information than kv-stores, namely the total 
%arbitration order of transactions: for our purposes, this may be considered to be the order in which transactions 
%are executed by all clients.

%Although abstract executions contain more information than kv-stores, 
%we can 
Next, we define a notion of \emph{compatibility} between abstract executions and 
kv-stores. Roughly speaking, 
this notion is based on the intuition that clients can make observations over kv-stores and abstract 
executions, in terms of snapshots. In kv-stores, 
observations are snapshots induced by views of clients over the kv-store. 
In abstract executions, observations correspond to the snapshots induced by the subsets of
of transactions of the abstract executions, according to some resolution policy (in this 
case, $\RP_{\LWW}$): this approach is analogous to the one used by 
opetation contexts in \cite{repldatatypes}. Thus a kv-store $\hh$ is 
compatible with an abstract execution $\aexec$ if any observation 
made on $\hh$ can be replicated by an observation made on 
$\aexec$, and vice-versa. 

\begin{definition}
\label{def:compatible}
Given a key-value store $\hh$,
an abstract execution $\aexec$ is compatible with $\hh$, written 
$\aexec \compatible \hh$, if and only if there exists a  mapping 
$f: \powerset{\T_{\aexec}} \rightarrow \Views(\hh)$
such that  
\begin{itemize}
\item for any subset $\T \subseteq \T_{\aexec}$, then $\RP_{\LWW}(\aexec, \T) = \{\snapshot(\hh, f(\T))\}$; 
\item for any view $\vi \in \Views(\hh)$, there exists a subset $\T \subseteq \T_{\aexec}$ 
such that $f(\T) = \vi$, and $\RP_{\LWW}(\aexec, \T) = \{\snapshot(\hh_{\aexec}, \vi)\}$.
\end{itemize}
\end{definition}

The compatibility relation $\simeq$ includes the encoding from abstract executions to kv-stores, 
as formalised by the next result.
\begin{theorem}
\label{thm:aexec2kv.compatible}
For any abstract execution $\aexec$ that satisfies the last write wins policy, $\aexec \compatible \hh_{\aexec}$.
\end{theorem}

The proof of Theorem \ref{thm:aexec2kv.compatible} requires defining a mapping 
$\getView(\aexec, \stub)$ from $\powerset{\T_{\aexec}}$ to $\Views(\hh_{\aexec})$ 
that satisfies the constraint of \cref{def:compatible}.
The function $\getView(\aexec, \stub)$ is defined by letting 
$\getView(\aexec, \T) = \lambda \ke. \{0\} \cup \{ i \mid i \in [\lvert \hh_{\aexec} \rvert - 1] \wedge 
\WTx(\hh_{\aexec}(\ke, i)) \in \T\}$.
We give details of the proof of the Theorem in \cref{app:aexec2kv}.
\begin{proposition}
\label{prop:getview.valid}
For any abstract execution $\aexec$, and $\T \subseteq \T_{\aexec}$, 
$\getView(\aexec, \T) \in \Views(\hh_{\aexec})$.
\end{proposition}

\mypar{Relating $\ET$-traces to Abstract Executions.}
Let $,\ET_\top$ be the most permissive execution test, that is 
$\ET_\top \vdash (\hh, \vi) \triangleright \opset: \vi'$ for any $\hh, \vi, \opset, \vi'$ 
such that whenever $\vi(\ke) \neq \vi'(\ke)$ then either $(\otW, \ke, \_) \in \opset$ 
or $(\otR, \ke, \_) \in \opset$.
{\color{red} I forgot this last constraint in the latest version of the document, definitions 
and proofs of theorems that follow must be re-factored to take the constraint into account.}
In this Section, we relate $\ET_{\top}$-traces to abstract executions that satisfy the last write wins 
resolution policy. Specifically, we prove the following: 
\begin{theorem}
\label{thm:kvtrace2aexec}
Let $\tr$ be a $\ET_{\top}$-trace; there exists a set of abstract executions $\aeset({\tr})$ 
such that, for any $\hh \in \aeset(\tr)$, $\lastConf(\tr) = (\hh, \_)$.

Let $\aexec$ be an abstract execution that satisfies the last write wins resolution policy. 
There exists a set of $\ET_{\top}$-traces $\KVtrace({\aexec})$ in normal form, 
such that for any $\tr \in \KVtrace({\aexec})$, $\lastConf(\tr) = (\hh_{\aexec}, \_)$. 
%Furthermore, for any $\aexec_{\tr_{\aexec}} = \aexec$.

{\color{red} Given a $\ET_{\top}$-trace $\tr$ and a kv-store $\aexec \in \aeset(\tr)$, then 
$\tr \in \KVtrace(\aexec)$. Given an abstract execution $\aexec$ that satisfies 
the last write wins policy and a $\ET_{\top}$-trace $\tr \in \KVtrace(\hh)$, 
then $\aexec \in \aeset(\tr)$. }
\end{theorem}
\begin{proof}
    See \cref{sec:kvtrace2aexec}.
\end{proof}

\begin{corollary} 
\label{cor:kvtrace2aexec}
$\CMs(\ET_{\top}) = \{\hh_{\aexec} \mid \aexec \text{ satisfies } \RP_{\LWW}\}$.
\end{corollary}

The last statement in \cref{thm:kvtrace2aexec} implies that there is a \emph{Galois connection}
between the set of $\ET_{\top}$-traces, and the set of abstract executions that satisfy the 
last write wins policy. The lower and upper adjoints of this connection are the 
lifting of the functions $\aeset(\cdot)$ and $\KVtrace(\cdot)$ to sets of $\ET_{\top}$-traces 
and abstract executions, respectively. Note however that these two sets are not isomorphic: 
when converting a set of abstract executions into kv-traces, we abstract away the 
pairs $\txid \xrightarrow{\VIS} \txid'$ in the visibility relation where $\txid$ is a read-only 
transaction. When converting a $\ET_{\top}$-trace into a set of abstract executions, 
we (partially) lose the information about the view that a clients has, immediately after it executed a transaction.

%\ac{Actually it is the case that each abstract execution defines several kv-traces in normal form. 
%In particular, the view of a client after executing a transaction should be irrelevant, as long as it's 
%included in the view associated with the set of transactions that are seen by the next transaction 
%executed by the same client, as per the definition of $\getView$.}
%\ac{Random though of 10:30pm - so maybe not so random... the comment above is because in the construction of 
%$\aexec_{\tr}$ I define, for a given transaction $\txid$, $\VIS_{\aexec_{\tr}}^{-1}(\txid)$ to contain 
%exactly the transactions that wrote a version included in the view of the client executing $\txid$, at the 
%moment it executed $\txid$. However, here I could be loose and allow also read-only transactions 
%to be included in $\VIS_{\aexec_{\tr}}^{-1}(\txid)$ - thus a trace would induce a set of 
%abstract executions, rather than a single abstract execution. I need to think about it more carefully. }


%A consequence of Theorem \ref{thm:kvtrace2aexec} is that $\ET_{\top}$-traces in normal form are isomorphic 
%to abstract executions that satisfy the last write wins policy.
%\ac{Not true. I thought that $\aexec_{\tr_{\aexec}} = \aexec$ for any $\aexec$, but this is not 
%the case. If in $\aexec$ there is a read-only transaction $\txid$ and $\txid \xrightarrow{\VIS_{\aexec}} \txid'$, 
%then it won't be the case that $\txid \xrightarrow{\VIS_{\aexec_{\tr_{\aexec}}}} \txid'$. This will have some 
%consequences when proving the correctness of axiomatic specifications of consistency models.}
%\ac{Random though of 10:45pm - following the previous random thought: given an abstract execution $\aexec$, 
%I define a set of traces $\KVtrace(\aexec)$. Given a trace $\tr$, I define a set of abstract executions $\aeset(\tr)$. 
%For any given $\aexec$ and $\tr \in \KVtrace(\aexec)$, $\aexec \in \aeset(\tr)$. More specifically, I can lift 
%$\aeset$ and $\traces$ to operate on sets of traces and abstract executions $\mathbb{X}, \mathbb{T}$, respectively. 
%For any $\mathbb{X}$ and $\mathbb{T}$ such that $\aeset(\mathbb{T}) \subseteq \mathbb{X}$, then 
%$\mathbb{T} \subseteq \traces(\mathbb{X}).$ It follows that $(\aeset, \traces)$ form a Galois Connection.}

Note that our definition of views (\cref{def:views}) is critical to the validity of Theorem \ref{thm:kvtrace2aexec}, 
as the following example shows. 

\begin{figure}
\begin{center}
\hrule
\begin{tabular}{@{}c @{\qquad}|@{\qquad} c@{}}
\begin{tikzpicture}[scale=0.85, every node/.style={transform shape}]
%\draw[help lines] grid(6,4);

\node (t1wx) {$(\otW, \ke_1, \val_1)$}; 
\path (t1wx.east) + (0.2,0) node[anchor = west] (t1wy) {$(\otW, \ke_2, \val_1)$};
\path (t1wx.south east) + (0.1, -1) node[anchor = north] (t2wx) {$(\otW, \ke_1, \val_2)$};
\path (t1wy.south east) + (1,-1) node[anchor = north west] (t3rx) {$(\otR, \ke_1, \val_2$)};
\path (t3rx.east) + (0,0) node[anchor=west] (t3ry) {$(\otR, \ke_2, \val_0)$};

\begin{pgfonlayer}{background}
\node[background, fit=(t1wx) (t1wy)] (t1) {};
\node[background, fit= (t2wx)] (t2) {};
\node[background, fit= (t3rx) (t3ry)] (t3) {};

\path(t1.north) node[anchor=south] (t1lbl) {$\txid_{\cl_1}^{1}$};
\path(t2.south) node[anchor=north] (t2lbl) {$\txid_{\cl_2}^{1}$};
\path(t3.east) node[anchor=west] (t3lbl) {$\txid_{\cl_3}^{1}$};

\path[->]
(t1.south) edge node[right] {$\AR$} (t2.north)
(t2.east) edge node[above] {$\AR, \VIS$} (t3.west);
\end{pgfonlayer}
\end{tikzpicture}
&
\begin{tikzpicture}
\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) {$\ke_1 \mapsto$};

\matrix(versionx) [version list]
    at ([xshift=\tikzkvspace]locx.east) {
    {a} & $\txid_0$ & {a} & $\txid_{\cl_1}^{1}$ & {a} & $\txid_{\cl_2}^{1}$\\
    {a} & $\emptyset$ & {a} & $\emptyset$ & {a} & $\left\{\txid_{\cl_3}^{1}\right\}$\\
};
\tikzvalue{versionx-1-1}{versionx-2-1}{locx-v0}{$\val_0$};
\tikzvalue{versionx-1-3}{versionx-2-3}{locx-v1}{$\val_1$};
\tikzvalue{versionx-1-5}{versionx-2-5}{locx-v2}{$\val_2$};

%Location y
\path (locx.south) + (0,\tikzkeyspace) node (locy) {$\ke_2 \mapsto$};
\matrix(versiony) [version list]
   at ([xshift=\tikzkvspace]locy.east) {
 {a} & $\txid_0$ & {a} & $\txid_{\cl_1}^{1}$ \\
  {a} & $\left\{\txid_{\cl_3}^1\right\}$ & {a} & $\emptyset$\\
};

\tikzvalue{versiony-1-1}{versiony-2-1}{locy-v0}{$\val_0$};
\tikzvalue{versiony-1-3}{versiony-2-3}{locy-v1}{$\val_1$};

\end{pgfonlayer}
\end{tikzpicture}
\end{tabular}
\end{center}
\hrule
\caption{An example of abstract execution and associated kv-store.}
\label{fig:aexec.noncontiguous}
\end{figure}

\begin{example}
\label{ex:badviews}
At an earlier stage of this research, views of kv-stores were defined to include only contiguous sets of versions 
for any key $\ke$: that is, for given a kv-store $\hh$, we required from a view $\vi \in \Views(\hh)$ that 
$\vi(\ke) = [i]$ for some $i: 0 < \lvert \hh(\ke) \rvert$, in addition to the constraints posed by \cref{def:views}. 
In this setting, the most permissive execution test $\ET$ is the following: 
\[
\left(\ET \vdash (\hh, \vi) \triangleright \opset : \vi' \right) \iff \forall \ke.\;\exists i_{\ke}, j_{\ke}.\; \vi(\ke) = [ i ] \wedge \vi'(\ke) = [ j ].
\]

Consider the abstract execution $\aexec$ depicted in Figure \ref{fig:aexec.noncontiguous}, 
and the associated kv-store $\hh_{\aexec}$, depicted to the right in the same Figure.
We argue that $\hh_{\aexec} \notin \CMs(\ET)$. According to \cref{thm:et.normalform} it suffices to prove 
that there exists no $\ET$-trace that is in normal form, and whose last configuration is $(\hh_{\aexec} ,\_)$. 
Suppose that such an $\ET$-trace $\tr$ existed: because we require that the last configuration in $\tr$ is 
$(\hh_{\aexec}, \_)$, then it must be the case that in $\tr$ transaction $\txid_{\cl_1}^{1}$ is executed 
before $\txid_{\cl_2}^{1}$, and the latter is executed before $\txid_{\cl_3}^1$. This is because 
$\txid_{\cl_2}^{1}$ installs a newer version of $\ke_1$ than the one read by $\txid_{\cl_2}^1$, 
and $\txid_{\cl_3}^{1}$ reads the version of $\ke_1$ installed by $\txid_{\cl_2}^{1}$. Because, 
$\tr$ is in normal form, we have the following: 
\[
\begin{array}{ll}
\tr = & (\hh_{0}, \viewFun_{0}) \xrightarrowtriangle{(\cl_1, \varepsilon)}_{\ET} (\hh_0, \viewFun_0') 
\xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} (\hh_1, \viewFun_1) \xrightarrowtriangle{(\cl_2, \varepsilon)}_{\ET} \\
& (\hh_1, \viewFun_1') \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} (\hh_2, \viewFun_2) \xrightarrowtriangle{(\cl_3, \varepsilon)}_{\ET} 
(\hh_2, \viewFun_2')\xrightarrowtriangle{(\cl_3, \opset_3)}_{\ET} (\hh_3, \viewFun_3),
\end{array}
\]
where $\opset_1 = \{(\otW, \ke_1, \val_1), (\otW, \ke_2, \val_1)\}$, $\opset_2 = \{(\otW, \ke_1, \val_2)\}$, 
$\opset_3 = \{(\otR, \ke_1, \val_2), (\otR, \ke_2, \val_0)\}$,\\ $\hh_1 = \updateKV(\hh_0, \cl_1, \_, \opset_1)$, 
$\hh_2 = \updateKV(\hh_1, \cl_2, \_, \opset_2)$, and $\hh_3 = \updateKV(\hh_2, \cl_3, \viewFun_2'(\cl_3), \opset_3)$ 
for a suitable $\viewFun_2'$.
Furthermore, we require that $\hh_3 = \hh_{\aexec}$, which is possible only if $\viewFun_2'(\cl_3) = [\ke_1 \mapsto [2], \ke_2 \mapsto [0] ]$ 
(recall that by definition of $\ET$, it must be that for any key $\ke$, $\viewFun_2'(\cl)(\ke) = [i_{\ke}]$ for some $i_{\ke} \geq 0$); 
this is because, in $\hh_3 = \hh_{\aexec}$, transaction $\txid_{\cl}^3$ reads the $2$-nd version of $\ke_1$ and the $0$-th version of 
$\ke_2$. It remains to note that the view $\viewFun_{2}'(\cl_3)$ is not atomic w.r.t. $\hh_2$, causing a contradiction: 
in fact, we have that $\WTx(\hh_{2}(\ke_1, 1) = \txid_{\cl_1}^{1} = \WTx(\hh_2(\ke_2, 1))$. However, 
$1 \in \viewFun_{2}'(\cl_3)(\ke_1)$, but $1 \notin \viewFun_{2}'(\cl_3)(\ke_2)$: the view $\viewFun_{2}'(\cl_3)$ 
contains the update of $\ke_1$ performed by $\txid_{\cl_1}^{1}$, but not the update of $\ke_2$ performed by the 
same transaction.
\end{example}

We now turn our attention to the proof of \cref{thm:kvtrace2aexec}. 
The first step is that of constructing, given a $\ET_{\top}$-trace $\tr$, 
a set of abstract execution $\aeset(\tr)$ such that, for any $\aexec \in \aeset(\tr)$, 
the last configuration of $\tr$ is $(\hh_{\aexec}, \_)$. 
%In practice, we map each $\ET_{\top}$-trace 
%$\tr$ into an abstract execution $\aexec_{\tr}$, and a function $\visibleTx: \Clients \parfun \T_{\aexec}$. 
%The latter are to abstract execution what view functions are to kv-stores in configurations: they keep 
%track of what transactions would be observed by a client, if it were to execute a transaction. 
The definition of $\aeset(\aexec)$ is natural, and is given inductively below: 

\begin{definition}
\label{def:kvtrace2aexec}
Let $\hh$ be a kv-store, and $\vi$ be a view. 
Define $\Tx(\hh, \vi) \defeq \Setcon{ \WTx(\hh(\ke, i)) }{ \ke \in \Keys \wedge i \in \vi(\ke) }$. 
Let $\aexec_0 = ( [ ], \emptyset, \emptyset)$. Given an abstract execution $\aexec$, a set of transactions  
$\T \subseteq \T_{\aexec}$, a transaction identifier $\txid$ and a set of operations $\opset$, we let 
\[
\extend(\aexec, \txid, \T, \opset) \defeq
\begin{cases}
\textit{undefined} &\impliedby \txid = \txid_{0}\\
(\TtoOp{T}_{\aexec} \uplus \Set{\txid_{\cl}^{n} \mapsto \opset}, \VIS', \AR') & \impliedby \txid = \txid_{\cl}^{n} \wedge {}\\
& \VIS' = \VIS_{\aexec} \uplus \{(\txid', \txid) \mid \txid \in \T)\} \wedge {}\\
& \AR' = \AR_{\aexec} \uplus \{(\txid', \txid) \mid \txid' \in \T_{\aexec})\}\\
\end{cases}
\]

Given a $\ET_{\top}$ trace $\tr$, we let $\lastConf(\tr)$ to be the last configuration appearing in 
$\tr$. The set of abstract executions $\aeset(\tr)$ is defined as the smallest set such that:
\begin{itemize}
\item $\aexec_{0} \in \aeset((\hh_{0}, \viewFun_{0}))$, 
\item if $\aexec \in \aeset(\tr)$, then $\aexec \in \aeset\left(\tr \xrightarrowtriangle{(\cl, \varepsilon)}_{\ET_{\top}} (\hh, \viewFun) \right)$, 
\item if $\aexec \in \aeset(\tr)$, then $\aexec \in \aeset\left(\tr \xrightarrowtriangle{(\cl, \emptyset)}_{\ET_{\top}} (\hh, \viewFun) \right)$, 
\item let $(\hh', \viewFun') = \lastConf(\tr)$; 
    if $\aexec \in \aeset(\tr)$, $\opset \neq \emptyset$, and $\T = \Tx(\hh, \viewFun'(\cl)) \cup \T_{rd}$ where \( \T_{rd} \) 
    is a set of \emph{read-only transactions} such that $\forall \txid' \in \T_{rd}, \ke, \val.\; (\otW, \ke, \val) \notin_{\aexec} \txid'$.
    Then for the transaction $\txid$ that is a transaction appearing in $\lastConf(\tr)$ but not in $\hh$, then  
$\extend(\aexec, \txid, \T, \opset) \in \aeset\left(\tr \xrightarrowtriangle{(\cl, \opset)}_{\ET_{\top}} (\hh, \viewFun) \right)$.
\end{itemize}
\end{definition}

\begin{proposition}
\label{prop:kvtrace2aexec}
For any $\ET_{\top}$-trace $\tau$, and $\aexec \in \aeset(\tau)$ is an abstract execution that 
satisfies the last write wins policy.
Furthermore, $\hh_{\aexec} = \hh$ where $(\hh, \stub) = \lastConf(\tau)$.
\end{proposition}
\begin{proof}
    See \cref{sec:kvtrace2aexec-under-lww}.
\end{proof}

Next, we show to construct, given an abstract execution $\aexec$, 
a set of $\ET_{\top}$-traces $\KVtrace(\ET_{\top}, \aexec)$ in normal form such that for any 
$\tr \in \KVtrace(\ET_{\top}, \aexec)$, $\lastConf(\tr) = (\hh_{\aexec}, \_)$. 
To define the function $\KVtrace(\ET_{\top}, \_)$ formally, we first provide a principle 
to reason about abstract executions inductively. 
%\begin{proposition}
%Let $\aexec$ be an abstract execution. Then either $\T_{\aexec} = \emptyset$, 
%or $\aexec = \extend(\aexec', \VIS^{-1}_{\aexec}(\txid), \txid, \TtoOp{T}_{\aexec}(\txid))$ 
%for some $\aexec'$ such that $\T_{\aexec'} = \T_{\aexec} \setminus \txid$, and $\txid = \max_{\AR}(\T_{\aexec})$.
%\end{proposition}
\begin{definition}
\label{def:aexec.inductive}
Let $\aexec$ be an abstract execution, let $n = \lvert \T_{\aexec} \rvert$, and let 
$\{\txid_{i}\}_{i=1}^{n} \subseteq \T_{\aexec}$ be such that for any $i=1,\cdots,n-1$, 
$\txid_{i} \xrightarrow{\AR_{\aexec}} \txid_{i+1}$. 
For $i = 0,\cdots, n-1$, define 
\[
\begin{array}{lll}
\cut(\aexec, 0) & \defeq & ([], \emptyset, \emptyset)\\
\cut(\aexec , i+1) & \defeq & \extend(\cut(\aexec, i), \txid_{i+1}, \VIS^{-1}_{\aexec}(\txid_{i+1}), \TtoOp{T}_{\aexec}(\txid_{i+1}))
\end{array}
\]
\end{definition}

\begin{proposition}
\label{prop:aexec.inductive}
For any abstract execution $\aexec$, $\aexec = \cut(\aexec, \lvert \T_{\aexec} \rvert)$.
\end{proposition}
\begin{proof}
    See \cref{sec:aexec-inductive}.
\end{proof}

\begin{definition}
\label{def:aexec2kvtrace}
Given an abstract execution $\aexec$, a client $\cl$ and an integer $i=0,\cdots, \lvert \aexec \rvert$, 
define $\nextTx(\aexec, \cl, i) \defeq \min_{\AR_{\aexec}}\{\txid_{\cl}^{j} \mid \txid_{\cl}^{n} \notin \T_{\cut(\aexec, i)}\}$. 
Note that $\nextTx(\aexec, \cl, i)$ could be undefined. 
Let $\Clients(\aexec) \defeq \{\cl \mid \exists n.\;\txid_{\cl}^{n} \in \T_{\aexec}\}$.

Given an abstract execution $\aexec$ and an integer $i = 0,\cdots, \lvert \T_{\aexec} \rvert$, let 
$\KVtrace(\ET_{\top}, \aexec, i)$ be the smallest set such that 
\begin{itemize}
\item 
$(\hh_{0}, \lambda \cl \in \Clients(\aexec). \lambda \ke.\{0\}) \in \KVtrace(\ET_{\top}, \aexec, 0)$, 
\item suppose that $\tr \in \KVtrace(\ET_{\top}, \aexec, i)$ for some $i = 0,\cdots, \lvert \T_{\aexec} \rvert - 1$.  
Let
\begin{itemize} 
\item $\txid = \min_{\AR_{\aexec}}(\T_{\aexec} \setminus T_{\cut(\aexec, i)})$, 
\item  $\cl, n$ be such that $\txid = \txid_{\cl}^{n}$, 
\item  $\vi = \getView(\aexec, \VIS^{-1}_{\aexec}(\txid_{\cl}^{n}))$, 
\item $\vi' = \getView(\aexec, \T)$, where $\T$ is an arbitrary subset of $\T_{\aexec}$ if 
$\nextTx(\aexec, \cl, i+1)$ is undefined, or is such that 
$\T \subseteq (\AR_{\aexec}^{-1})?(\txid) \cap \VIS^{-1}_{\aexec}(\nextTx(\cl, i+1))$, 
\item $\opset = \TtoOp{T}_{\aexec}(\txid)$, 
\item $(\hh_{\tr}, \viewFun_{\tr}) = \lastConf(\tr)$, 
\item $\hh = \updateKV(\hh_{\tr}, \vi, \txid, \opset)$.
\end{itemize}
Then
\[
\big( \tr \xrightarrowtriangle{(\cl, \varepsilon)}_{\ET_{\top}} (\hh_{\tr}, \viewFun_{\tr}\rmto{\cl}{\vi}) 
\xrightarrowtriangle{(\cl, \opset)}_{\ET_{\top}} (\hh, \viewFun_{\tr}\rmto{\cl}{\vi'}) \big) \in \KVtrace(\ET_{\top}, \aexec, i+1)
\]
\end{itemize}

Finally, we let $\KVtrace(\ET_{\top}, \aexec) \defeq \KVtrace(\ET_{\top}, \aexec, \lvert \T_\aexec \rvert)$.
\end{definition}

\begin{proposition}
\label{prop:aexec2kvtrace}
Let $\aexec$ be an abstract execution that satisfies $\RP_{\LWW}$, 
and let $\tr \in \KVtrace(\ET_{\top}, \aexec)$. Then $\lastConf(\tr) = (\hh_{\aexec}, \_)$ and $\hh_{\aexec} \in \CMs(\ET_{\top})$. 
\end{proposition}
\begin{proof}
    See \cref{sec:aexec2kvtrace}.
\end{proof}

%\mypar{Specification of Consistency Models via Abstract Executions.}
%In the abstract execution framework, specifications of consistency models are given by placing \emph{axioms} that the 
%arbitration and visibility relations of abstract executions must satisfy. Such axioms usually 
%have the form $\mathscr{F}(\aexec) \subseteq \VIS_{\aexec}$, 
%where $\mathscr{F}$ maps abstract executions into relations between transactions \cite{laws}. 
%For example, let $[(\otW, \ke, \_)]_{\aexec} = \{(\txid, \txid) \mid (\otW, \ke, \_) \in \TtoOp{T}(\T_{\aexec}(\txid) \}$. 
%Then (strong session) snapshot isolation can be described as the set of abstract executions $\aexec$ that 
%satisfy the axioms $\PO_{\aexec} \subseteq \VIS_{\aexec}$, $\AR_{\aexec} ; \VIS_{\aexec} \subseteq \VIS_{\aexec}$, 
%and for each $\ke$, $[(\otW, \ke, \_)]_{\aexec} ; \AR_{\aexec} ; [(\otW, \ke, \_)]_{\aexec} \subseteq \VIS_{\aexec}$. 
%Actual specifications of consistency models using this formalism are outside the scope of this article, and we 
%refer the reader to \cite{laws} for a comprehensive list of axioms for specifying different consistency models.
%
%We show that there is a Galois connection between the set of  abstract executions that satisfy 
%the last write win resolution policy, and the set of \emph{kv-traces}. 
%These are sequences of the form 
%\[ 
%\conf_0 \xrightarrowtriangle{\_}_{\ET_{\bot}} \cdots \xrightarrowtriangle{\_}_{\ET_{\bot}} \conf_n.
%\]
%Let then $\aexec$ be an abstract execution that satisfies the last write win policy. We now show 
%how to construct the kv-trace $\KVtrace(\aexec)$.
%\begin{definition}
%Let $\aexec$ be an abstract execution, and let $\txid^{0} \xrightarrowtriangle{\AR_{\aexec}} \txid^{n-1} \xrightarrow{\AR_{\aexec}} \txid^{n}$. 
%We recursively define $\KVtrace(\aexec, m)$ for all $m \leq n$, and we let $\KVtrace(\aexec) = \KVtrace(\aexec, n)$. 
%For $m = 0$, we let $\KVtrace(\aexec, m) = \hh_0$, where $\hh_0 = \lambda \ke. (\val_0, \txid_0, \emptyset)$. 
%Assuming that $\KVtrace(\aexec, m) = \conf_0 \xrightarrowtriangle{(\cl^{0}, \vi^{0},\opset^{0})}_{\ET_{\bot}} \cdots \xrightarrowtriangle{
%(\cl^{m-1}, \vi^{m-1}, \opset^{m-1})}_{\ET_{\bot}} \conf_{m}$ 
%has been defined for some $m < n$, consider the set of transactions $\VIS^{-1}(\txid_{m})$. Let 
%$\vi^{m} = \lambda \ke. \lvert \VIS^{-1}(\ke) \cap \{ \txid \mid (\otW, \ke, \_) \in_{\aexec} \txid \} \rvert$ 
%{\color{red} basically I am counting the number of versions of that $\txid_{m}$ sees, for each $\ke$.}, 
%and define $\hh_{m+1} = \updateKV(\hh_{m}, \vi, \txid, \opset)$. Finally, suppose that 
%$\txid^{m} = \txid_{\cl}^{\_}$ for some $\cl$, and let $m: m < m' \leq n$ be the smallest 
%index (if any) such that $\txid_{m'} = \txid_{\cl}^{\_}$. Define $\vi'_{m} = \lambda \ke. \lvert 
%\VIS^{-1}(\txid_{m'}) \cap (\AR^{-1}(\txid_{m}) \cup \{\txid_m\}) \cap \{ \txid \mid (\otW, \ke, \_) \in_{\aexec} \txid \} \rvert$. 
%If such an $m'$ does not exist, then let $\vi'_{m} = \lambda \ke. \lvert \hh_{m+1}(\ke) \rvert -1$. 
%{\color{red} basically I select the final view after committing $\txid_{m}$ by looking at 
%the versions of each $\ke$ that are already present in the kv-store at the moment 
%$\txid_{m}$ committed, and which are going to be observed by the next transaction in the same session. If there 
%are no future tranactions for the current session, just shift the view to the end, it's never going to be used again.} 
%Then we let $\conf_{m+1} = \hh_{m+1}, \viewFun_{m}\rmto{\cl}{\vi'_{m}}$, and define 
%\[
%\KVtrace(\aexec, m) = \conf_0 \xrightarrowtriangle{(\cl^{0}, \vi^{0},\opset^{0})}_{\ET_{\bot}} \cdots \xrightarrowtriangle{
%(\cl^{m-1}, \vi^{m-1}, \opset^{m-1})}_{\ET_{\bot}} \conf_{m} \xrightarrowtriangle{(\cl, \vi^{m}, \TtoOp(\txid_{m})} 
%\conf^{m+1}.
%\]
%\end{definition}
