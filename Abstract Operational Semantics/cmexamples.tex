%\[
%    \begin{session}
%        \begin{array}{@{}c || c ||  c || c@{}}
%            \begin{transaction}      		
%                \pderef{\vx}{\loc_x}; \\
%                \pifs{\vx=0} \\
%                \quad \pmutate{\loc_y}{1}
%            \end{transaction} & 
%            \begin{transaction}
%                \pderef{\vy}{\loc_y}; \\
%                \pifs{\vx=0} \\
%                \quad \pmutate{\loc_x}{1}
%            \end{transaction} & 
%            \begin{transaction}
%                \pmutate{\loc_x}{2}
%            \end{transaction} & 
%            \begin{transaction}
%                \pmutate{\loc_y}{2}
%            \end{transaction} \\
%        \end{array}
%    \end{session}
%\]
\ac{This Section is going to become heavy in pictures, which should be 
organised into figures.}
In this Section we present different consistency models specifications. 
For each of them, we give: 
\begin{itemize}
\item an informal definition, describing the consistency guarantees that 
schedules of the database should have in plain English, 
\item examples of litmus tests that, when executed,  give rise to the anomalies that should be forbidden 
from the consistency model, 
\item a formal consistency model specification, in the style described in \S \ref{sec:semantics.programs},
\item an explanation of why the consistency model forbids the litmus tests to exhibit the anomaly that 
should be forbidden. 
\end{itemize}
Later on in the paper, we will show how to compare our consistency 
models specifications with those already existing in the 
literature.
\ac{There is still a long-way to go before proving correspondence with dependency graph specifications, 
but this should be mentioned here.}

\subsection{Read Atomic} 
Read atomic \cite{ramp} is the weakest consistency model among 
those that enjoy \emph{atomic visibility} \cite{framework-concur}. 
It requires transactions to read an atomic snapshot of the database. 
It also requires transactions to never observe the partial effects of other transactions. 
This is also known as the \emph{all-or-nothing} property: A transaction 
observes either none or all the updates performed by another transaction. 

One litmus test that should \textbf{not} be failed in RAMP consists of the program 
$\prog_1$ from \S \ref{sec:semantics.example}, which we already observed 
to produce a violation of atomic visibility in no constraints on the consistency 
model are placed. Intuitively, in such a program, the violation of atomic 
visibility happened because we allowed to execute the transaction 
\[
\trans = \begin{array}{c} 
            \begin{transaction}
            		\pderef{\pvar{a}}{\loc_x};\\
            		\pderef{\pvar{b}}{\loc_y};\\
            		\pifs{\pvar{a}=1 \wedge \pvar{b}=0}\\
            			\;\;\;\;\passign{\retvar}{\Large \frownie{}}
             \end{transaction}
     \end{array}
\]
in the thread-local configuration of $\mathcal{C}'$ relative to $\tid_2$, which is obtained 
by removing all the information about $\tid_1$ (view and stack) in Figure \ref{fig:opsem.example}(c):

\begin{center}
\begin{tikzpicture}[font=\large]

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) at (1,3) {$[\loc_x] \mapsto$};

\matrix(locxcells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locx.east) {
 {a} & $T_0$ & {a} &  $T_1$ \\
  {a} & $\emptyset$ & {a} & $\emptyset$ \\
};
\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};

%Location y
\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
\matrix(locycells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locy.east) {
 {a} & $T_0$ & {a} &  $T_1$ \\
  {a} & $\emptyset$ & {a} & $\emptyset$ \\
};
\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
\node[version node, fit=(locycells-1-3) (locycells-2-3), fill=white, inner sep=0cm, font=\Large] (locy-v1) {$1$};

% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, , blue, very thick, rounded corners=10pt]
 ([xshift=-5pt, yshift=5pt]locx-v1.north east) -- 
 ([xshift=-5pt, yshift=-5pt]locx-v1.south east) --
 ([xshift=-5pt, yshift=5pt]locy-v0.north east) -- 
 ([xshift=-5pt, yshift=-5pt]locy-v0.south east);

\end{pgfonlayer}
\end{tikzpicture}
\end{center}

To avoid transactions to only observe the partial effects of other transactions, we 
must ensure that transactional code cannot be executed by a thread whose 
views is up-to-date with respect to some transaction $\tsid$ for some location $[\loc_x]$, 
but not for some other location $[\loc_y]$. This leads to the following definition.
we let $\hh_2, V_2$ be the history heap and view corresponding to the figure above, respectively. 
In this case, the view $V_2$ (indicated by the blue line in the figure) 
is up-to-date with respect to the update of location $[\loc_x]$ performed by $\tsid_1$: 
formally, there exists an index $i \leq V_2([n])$ such that $\hh([\loc_{x}])(i) = (\_, \tsid_1, \_)$. 
On the other hand, the view $V_2$ is not up-to-date with respect to the updated of 
location $[\loc_y]$ performed by $\tsid_1$:  $\hh([\loc_y])(1) = (\_, \tsid_1, \_)$, 
but $V_2([\loc_y]) = 0$. 
\begin{definition}
Let $\hh$ be a history heap,$V$ be a view, $\tsid$ be a transaction identifier, and $[\loc_x]$ be a location.
We say that $V$ is up-to-date in $\hh$, with respect to $\tsid$, relatively to $\tsid$, 
written $\mathsf{up-to-date}(\hh, V, \tsid, [\loc_x])$, if either 

\begin{itemize}
\item for all indexes $i = 0,\cdots, \lvert \hh([\loc_x]) - 1 \rvert$, 
$\WS(\hh([\loc_x])(i)) \neq \tsid)$, or 
\item if $\WS(\hh([\loc_x])(i)) = \tsid$ for some $i = 0,\cdots, \lvert \hh([\loc_n]) -1 \rvert$, 
then $i \leq V([\loc_n])$.
\end{itemize}

We say that the view $V$ is $RA$-consistent with respect to $\hh$, written $\mathsf{RA-cons}(V, \hh)$, if
\[
\forall \tsid, [\loc_x], [\loc_y].\; \mathsf{up-to-date}(\hh, V, \tsid, [\loc_x]) \implies \mathsf{up-to-date}(\hh, V, \tsid, [\loc_y]).
\]

The consistency model specification $\mathsf{RA}$ is defined as the smallest set such that  
\[
\mathsf{RA-cons}(\hh, V) \implies (\hh, V, \_) \triangleright_{\mathsf{RA}} \_
\]
\end{definition}

As we have already discussed, the thread-local configuration $(\hh_2, V_2)$ is not $\mathsf{RA}$-consistent, 
and therefore it is not possible to infer a transition of the form $(\hh_2, [\tid_2 \mapsto \_, V_2], \trans.\nil ) \xrightarrow{\_}_{\mathsf{RA}} 
\_$ using Rule $(P-thd-exec)$. In contranst, we have shown in \S \ref{sec:semantics.example} that, if no 
constraints are placed in the consistency model, then it is possible to derive a transition of the form 
$(\hh_2, [\tid_2 \mapsto \_, V_2], \trans.\nil) \xrightarrow{\_}_{\mathsf{CM}_{\top}}$ 
$(\hh_2', [\tid_2 \mapsto \left( [\retvar \mapsto {\Large \frownie{}}], V_2' \right) ], \nil)$.

%The first condition is built-in in the rules of the operational semantics: transactions 
%are always executed by taking a snapshot of the database as the initial state; such a 
%snapshot is determined by the history heap, and the view of the thread that executes 
%the transaction. However, the all-or-nothing property is not enforced by the operational 
%semantics, as the following example shows: 
%\begin{example}
%Consider the following program $\prog_1$:
%\[
%    \begin{session}
%        \begin{array}{@{}c || c@{}}
%            \begin{transaction}
%            		\pmutate{\loc_x}{1};
%            		\pmutate{\loc_y}{1};
%              \end{transaction} &
%              \begin{transaction}
%            		\pderef{\vx}{\loc_x};
%            		\pderef{\vy}{\loc_y};
%            		\pifs{\vx=1 \wedge \vy=0}\\
%            			\passign{\retvar}{\Large \frownie{}}
%             \end{transaction}
%        \end{array}
%    \end{session}
% \]
% \ac{Note that in this example I don't differentiate between thread stack and transaction stack}
%In the program above we committed an abuse of notation and did not insert thread identifiers. In general, 
%we assume that thread identifiers are fixed by the order in which commands appear in a parallel 
%composition. For exampe, we write $\cmd_1 \Par \cdots \Par \cmd_n$ as a shorthand for 
%$\tid_1: \cmd_1 \Par \cdots \Par \tid_{n}: \cmd_n$. 
%Also, note that the transaction for thread $\tid_2$ may return a special value ${\Large \frownie{}}$, which 
%we did not introduce before. Although in practice we could have chosen any natural number 
%to assign to $\retvar$, we use the special symbol ${\Large \frownie{}}$ to emphasise 
%the fact that the transaction gives rise to an anomaly that should not be allowed by the 
%consistency model that we are considering. In this case, this happens if the transaction 
%executed by thread $\tid_2$ observes the update of $\loc_x$ performed by 
%the transaction executed by $\tid_1$, but not the update of $\loc_y$ performed by 
%the same transaction: in this scenario, atomic visibility is violated.
%
%We illustrate the semantics of this program under the 
%most general consistency model $CM_{\mathsf{all}}$ such that 
%$(\hh, V, \mathcal{V}) \triangleright_{CM_{\mathsf{all}}} \mathcal{O}$ for all 
%$\hh, V, \mathcal{V}, \mathcal{O}$. 
%For this example, we assume that the database consists of only two keys $\loc_x, \loc_y$.
%The program is executed starting from the initial configuration 
%$(\hh_{0}, [\tsid_1 \mapsto (\thdstack_0, V_{0}), \tsid_2 \mapsto (\thdstack_0, V_0)]$, 
%where: 
%\begin{enumerate}
%\item $\hh_{0}([\loc_x]) = \hh_{0}([\loc_y]) = (0, \tsid_0, \emptyset)$, and $\tsid_0$ is a random transaction identifier, 
%\item $\thdstack_0 = \lambda \vx.0$ is the initial thread stack.
%\item $V_{0}([n]) = [ [\loc_x] \mapsto 0, \loc_y \mapsto 0] ]$ is the view that maps every 
%key to its initial version.
%\end{enumerate}
%Here and in the rest of the report we will give a graphical representation of views. For example, 
%below we depict the inital configuration in which $\prog_1$ is executed:
%\begin{center}
%\begin{tikzpicture}[font=\large]
%\begin{pgfonlayer}{foreground}
%\node (locx) {$[\loc_x] \mapsto$};
%\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
%\path (locx.east) + (0.5,0)  node (locx0) {$0$};
%\path (locx0.north east) + (0.3,0) node[font=\small] (locx0ws) {$\tsid_0$};
%\path (locx0.south east) + (0.3,0) node[font=\small] (locx0rs) {$\emptyset$};
%\path (locy.east) + (0.5,0)  node (locy0) {$0$};
%\path (locy0.north east) + (0.3,0) node[font=\small] (locy0ws) {$\tsid_0$};
%\path (locy0.south east) + (0.3,0) node[font=\small] (locy0rs) {$\emptyset$};
%
%\path(locy0.south) + (0,-1) node[font = \small, text=red] (tid1ret) {$\tid_1: \retvar = 0$};
%\path(tid1ret.south) + (0,-0.3) node[font= \small, text=blue] (tid2ret) {$\tid_2: \retvar = 0$};
%\end{pgfonlayer}
%
%\begin{pgfonlayer}{main}
%\node[hheapcell, fit=(locx0) (locx0ws) (locx0rs)] (locx0cell) {};
%\node[hheapcell, fit=(locy0) (locy0ws) (locy0rs)] (locy0cell) {};
%
%\path[-]
%(locx0cell.north) edge (locx0cell.south)
%(locx0cell.center) edge (locx0cell.east)
%(locy0cell.north) edge (locy0cell.south) 
%(locy0cell.center) edge (locy0cell.east);
%
%\path(locx0cell.north) + (-0.5, 0.2) node(v1beforex) {};
%\path(locx0cell.south) + (-0.5, -0.1) node(v1afterx) {};
%\path(locy0cell.north) + (-0.5, 0.1) node(v1beforey) {};
%\path(locy0cell.south) + (-0.5, -0.2) node(v1aftery) {};
%\path(v1beforex.center) + (-0.25,0.15) node[font=\normalsize, text=red] (t1) {$\tid_1$};
%
%\path[-, draw=red!80, very thick]
% (v1beforex.center) edge (v1afterx.center)
% (v1afterx.center) edge (v1beforey.center)
% (v1beforey.center) edge (v1aftery.center);
% 
% \path(locx0cell.north) + (-0.1, 0.2) node(v2beforex) {};
%\path(locx0cell.south) + (-0.1, -0.1) node(v2afterx) {};
%\path(locy0cell.north) + (-0.1, 0.1) node(v2beforey) {};
%\path(locy0cell.south) + (-0.1, -0.2) node(v2aftery) {};
%\path(v1beforex.center) + (0.6,0.15) node[font=\normalsize, text=blue] (t2) {$\tid_2$};
%
%\path[-, draw=blue!80, very thick]
% (v2beforex.center) edge (v2afterx.center)
% (v2afterx.center) edge (v2beforey.center)
% (v2beforey.center) edge (v2aftery.center);
% 
%\end{pgfonlayer}
%
%\end{tikzpicture}
%\end{center}
%In the figure above, each location is mapped to a list of version (one in this case), depicted as a cell 
%consisting of three components: the component at  the left (which is $0$ for both cells in the figure 
%above) consists of the value stored in the version of the location. The component at the top 
%left identifies the transaction that wrote such a version, while the component at the bottom left 
%includes the set of transactions that read such a version. Views of threads are represented each by a vertical  
%line that crosses a location exactly at the cell corresponding to the version to which the view points. 
%At the bottom of the picture, we also included information about the thread stack of individual threads.
%\ac{The discussion about graphical representation of configurations should be before.
%In fact, $\prog_1$ should be introduced before the section on consistency models, as 
%an example of the semantics.} In practice, we should 
%We are now ready to start analysing the behaviour 
%
%\end{example}
%which a transaction executes is fixed at the moment it starts. However, the 
%The weakest consistency model specification that we consider is given by \emph{Read Atomic}. 
%\ac{Following a discussion with Azalea and Shale, it looks like history heaps alone do not enforce 
%atomic visibility. I find this to be actually good, because that means that there may be some way to 
%reduce transactions in one step, while modelling non-atomic behaviours}.
%This consistency models require that transactions observe either none, or all the updates performed by 
%another transaction (i.e. they enjoy atomic visibility). 
%In terms of history heaps and views, we must ensure that views do not observe only the partial 
%effects of transactions. Given a transaction $\tsid$, if a view of a history heap points to a version of location $[n]$ that 
%is more up-to-date than the one written by some transaction $\tsid$, then we require that the 
%same property holds also for any location $[m]$ that has been written by $\tsid$.
%
%
%\begin{definition}
%We say that a view $V$ \emph{respects atomic visibility} w.r.t a history heap $\hh$ if, 
%whenever $\hh([n])(i) = (\_, \tsid, \_)$, $\hh([m])(j) = (\_, \tsid, \_)$ for some addresses 
%$[n], [m]$ and indexes $i, j$,  then $i \leq V([n])$ implies $j \leq V([n])$.
%The consistency model specification $\mathsf{RA}_{\mathcal{H}}$ is defined to be the smallest set 
%such that 
%\begin{itemize}
%\item for any history-heaps $\hh$, $\hh'$ and  $V$, $V'$, if $V$ respects atomic visibility w.r.t. 
%$\hh$, then $(\hh, \{V\}) \leadsto_{\mathsf{RA}_{\mathcal{H}}} (\hh', \{V'\})$.
%\item for any history-heaps $\hh,\hh'$ and  multi-set of views $\mathcal{V}, \mathcal{V}', 
%\mathcal{V}''$, $\mathcal{V}'' \Vdash (\hh, \mathcal{V}') \leadsto_{\mathsf{RA}_{\mathcal{H}}} 
%(\hh', \mathcal{V}')$.  
%\end{itemize}
%\ac{Hold on! I'm rethinking consistency models specifications completely. It seems that 
%the best way to specify a consistency model is given by triples of the form 
%$(\hh, V, \mathcal{V}, \mathcal{O})$, which may be interpreted as: 
%given a history heap $\hh$, a thread with view $V$ can safely execute a transaction 
%with fingerprint $\mathcal{O}$, when running in an environment where the views 
%of other threads are given by $\mathcal{V}$.) This seems to be closer in spirit 
%to what Crooks and Alvisi do as well in their PODC'17 paper.}
%
%\end{definition}

\subsection{Causal Consistency}
\begin{figure}
\begin{tabular}{|c|c|}
\hline
\begin{tikzpicture}[font=\large]

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) at (1,3) {$[\loc_x] \mapsto$};

\matrix(locxcells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locx.east) {
 {a} & $T_0$ \\
  {a} & $\emptyset$ \\
};
\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};

%Location y
\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
\matrix(locycells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locy.east) {
 {a} & $T_0$ \\
  {a} & $\emptyset$ \\
};
\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};

% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
 ([xshift=-2pt, yshift=20pt]locx-v0.north east) node (tid1start) {} -- 
% ([xshift=-2pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-2pt, yshift=5pt]locy-v0.north east) -- 
 ([xshift=-2pt, yshift=-5pt]locy-v0.south east);
 
 \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_3$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
 ([xshift=-5pt, yshift=5pt]locx-v0.north east) -- 
% ([xshift=-8pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-8pt, yshift=5pt]locy-v0.north east) -- 
 ([xshift=-5pt, yshift=-10pt]locy-v0.south east) node (tid2start) {};
 
\path (tid2start) node[anchor=north, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\tid_2$};
 
 %green view
\draw[-, DarkGreen, very thick, rounded corners = 10pt]
 ([xshift=-16pt, yshift=8pt]locx-v0.north east) node (tid3start) {}-- 
% ([xshift=-15pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-15pt, yshift=5pt]locy-v0.north east) -- 
 ([xshift=-16pt, yshift=-5pt]locy-v0.south east);
 
 \path (tid3start) node[anchor=south, rectangle, fill=DarkGreen!20, draw=DarkGreen, font=\small, inner sep=1pt] {$\tid_1$};

\end{pgfonlayer}
\end{tikzpicture}
&
\begin{tikzpicture}[font=\large]

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) at (1,3) {$[\loc_x] \mapsto$};

\matrix(locxcells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locx.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_1$\\
  {a} & $\emptyset$ & {a} & $\emptyset$ \\
};
\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v-1) {$1$};
%Location y
\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
\matrix(locycells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locy.east) {
 {a} & $\tsid_0$ \\
   {a} & $\emptyset$ \\
};
\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
 ([xshift=-2pt, yshift=20pt]locx-v0.north east) node (tid1start) {} -- 
% ([xshift=-2pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-2pt, yshift=5pt]locy-v0.north east) -- 
 ([xshift=-2pt, yshift=-5pt]locy-v0.south east);
 
 \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_3$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
 ([xshift=-5pt, yshift=5pt]locx-v0.north east) -- 
% ([xshift=-8pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-8pt, yshift=5pt]locy-v0.north east) -- 
 ([xshift=-5pt, yshift=-10pt]locy-v0.south east) node (tid2start) {};
 
\path (tid2start) node[anchor=north, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\tid_2$};
 
 %green view
\draw[-, DarkGreen, very thick, rounded corners = 10pt]
 ([xshift=-16pt, yshift=8pt]locx-v1.north east) node (tid3start) {}-- 
 ([xshift=-16pt, yshift=-5pt]locx-v1.south east) --
 ([xshift=-16pt, yshift=5pt]locy-v0.north east) -- 
 ([xshift=-16pt, yshift=-5pt]locy-v0.south east);
 
 \path (tid3start) node[anchor=south, rectangle, fill=DarkGreen!20, draw=DarkGreen, font=\small, inner sep=1pt] {$\tid_1$};

\end{pgfonlayer}
\end{tikzpicture}
\\
{\small (a)} & {\small (b)}\\
\hline
\begin{tikzpicture}[font=\large]

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) at (1,3) {$[\loc_x] \mapsto$};

\matrix(locxcells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locx.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_1$\\
  {a} & $\emptyset$ & {a} & $\emptyset$ \\
};
\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v-1) {$1$};
%Location y
\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
\matrix(locycells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locy.east) {
 {a} & $\tsid_0$ \\
   {a} & $\emptyset$ \\
};
\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
 ([xshift=-2pt, yshift=20pt]locx-v0.north east) node (tid1start) {} -- 
% ([xshift=-2pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-2pt, yshift=5pt]locy-v0.north east) -- 
 ([xshift=-2pt, yshift=-5pt]locy-v0.south east);
 
 \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_3$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
 ([xshift=-5pt, yshift=5pt]locx-v1.north east) -- 
 ([xshift=-5pt, yshift=-5pt]locx-v1.south east) --
 ([xshift=-5pt, yshift=3pt]locy-v0.north east) -- 
 ([xshift=-5pt, yshift=-10pt]locy-v0.south east) node (tid2start) {};
 
\path (tid2start) node[anchor=north, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\tid_2$};
 
 %green view
\draw[-, DarkGreen, very thick, rounded corners = 10pt]
 ([xshift=-16pt, yshift=8pt]locx-v1.north east) node (tid3start) {}-- 
 ([xshift=-16pt, yshift=-5pt]locx-v1.south east) --
 ([xshift=-16pt, yshift=5pt]locy-v0.north east) -- 
 ([xshift=-16pt, yshift=-5pt]locy-v0.south east);
 
 \path (tid3start) node[anchor=south, rectangle, fill=DarkGreen!20, draw=DarkGreen, font=\small, inner sep=1pt] {$\tid_1$};

\end{pgfonlayer}
\end{tikzpicture}
&
\begin{tikzpicture}[font=\large]

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) at (1,3) {$[\loc_x] \mapsto$};

\matrix(locxcells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locx.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_1$\\
  {a} & $\emptyset$ & {a} & $\{\tsid_2\}$ \\
};
\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v-1) {$1$};
%Location y
\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
\matrix(locycells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locy.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_2$ \\
   {a} & $\emptyset$ & {a} & $\emptyset$\\
};
\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
\node[version node, fit=(locycells-1-3) (locycells-2-3), fill=white, inner sep=0cm, font=\Large] (locy-v-1) {$1$};
% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
 ([xshift=-2pt, yshift=20pt]locx-v0.north east) node (tid1start) {} -- 
% ([xshift=-2pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-2pt, yshift=5pt]locy-v0.north east) -- 
 ([xshift=-2pt, yshift=-5pt]locy-v0.south east);
 
 \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_3$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
 ([xshift=-5pt, yshift=5pt]locx-v1.north east) -- 
% ([xshift=-5pt, yshift=-5pt]locx-v1.south east) --
% ([xshift=-5pt, yshift=3pt]locy-v0.north east) -- 
 ([xshift=-5pt, yshift=-10pt]locy-v1.south east) node (tid2start) {};
 
\path (tid2start) node[anchor=north, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\tid_2$};
 
 %green view
\draw[-, DarkGreen, very thick, rounded corners = 10pt]
 ([xshift=-16pt, yshift=8pt]locx-v1.north east) node (tid3start) {}-- 
 ([xshift=-16pt, yshift=-5pt]locx-v1.south east) --
 ([xshift=-16pt, yshift=5pt]locy-v0.north east) -- 
 ([xshift=-16pt, yshift=-5pt]locy-v0.south east);
 
 \path (tid3start) node[anchor=south, rectangle, fill=DarkGreen!20, draw=DarkGreen, font=\small, inner sep=1pt] {$\tid_1$};

\end{pgfonlayer}
\end{tikzpicture}\\
{\small (c)} & {\small (d)} \\
\hline
\begin{tikzpicture}[font=\large]

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) at (1,3) {$[\loc_x] \mapsto$};

\matrix(locxcells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locx.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_1$\\
  {a} & $\emptyset$ & {a} & $\{\tsid_2\}$ \\
};
\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v-1) {$1$};
%Location y
\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
\matrix(locycells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locy.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_2$ \\
   {a} & $\emptyset$ & {a} & $\emptyset$\\
};
\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
\node[version node, fit=(locycells-1-3) (locycells-2-3), fill=white, inner sep=0cm, font=\Large] (locy-v-1) {$1$};
% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
 ([xshift=-2pt, yshift=20pt]locx-v0.north east) node (tid1start) {} -- 
 ([xshift=-2pt, yshift=-5pt]locx-v0.south east) --
 ([xshift=-2pt, yshift=5pt]locy-v1.north east) -- 
 ([xshift=-2pt, yshift=-5pt]locy-v1.south east);
 
 \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_3$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
 ([xshift=-5pt, yshift=5pt]locx-v1.north east) -- 
% ([xshift=-5pt, yshift=-5pt]locx-v1.south east) --
% ([xshift=-5pt, yshift=3pt]locy-v0.north east) -- 
 ([xshift=-5pt, yshift=-10pt]locy-v1.south east) node (tid2start) {};
 
\path (tid2start) node[anchor=north, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\tid_2$};
 
 %green view
\draw[-, DarkGreen, very thick, rounded corners = 10pt]
 ([xshift=-16pt, yshift=8pt]locx-v1.north east) node (tid3start) {}-- 
 ([xshift=-16pt, yshift=-5pt]locx-v1.south east) --
 ([xshift=-16pt, yshift=5pt]locy-v0.north east) -- 
 ([xshift=-16pt, yshift=-5pt]locy-v0.south east);
 
 \path (tid3start) node[anchor=south, rectangle, fill=DarkGreen!20, draw=DarkGreen, font=\small, inner sep=1pt] {$\tid_1$};

\end{pgfonlayer}
\end{tikzpicture}
&
\begin{tikzpicture}[font=\large]

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) at (1,3) {$[\loc_x] \mapsto$};

\matrix(locxcells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locx.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_1$\\
  {a} & $\{\tsid_3\}$ & {a} & $\{\tsid_2\}$ \\
};
\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};
%Location y
\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
\matrix(locycells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locy.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_2$ \\
   {a} & $\emptyset$ & {a} & $\{\tsid_3\}$\\
};
\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
\node[version node, fit=(locycells-1-3) (locycells-2-3), fill=white, inner sep=0cm, font=\Large] (locy-v1) {$1$};
% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
 ([xshift=-2pt, yshift=20pt]locx-v0.north east) node (tid1start) {} -- 
 ([xshift=-2pt, yshift=-5pt]locx-v0.south east) --
 ([xshift=-2pt, yshift=5pt]locy-v1.north east) -- 
 ([xshift=-2pt, yshift=-5pt]locy-v1.south east);
 
 \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_3$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
 ([xshift=-5pt, yshift=5pt]locx-v1.north east) -- 
% ([xshift=-5pt, yshift=-5pt]locx-v1.south east) --
% ([xshift=-5pt, yshift=3pt]locy-v0.north east) -- 
 ([xshift=-5pt, yshift=-10pt]locy-v1.south east) node (tid2start) {};
 
\path (tid2start) node[anchor=north, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\tid_2$};
 
 %green view
\draw[-, DarkGreen, very thick, rounded corners = 10pt]
 ([xshift=-16pt, yshift=8pt]locx-v1.north east) node (tid3start) {}-- 
 ([xshift=-16pt, yshift=-5pt]locx-v1.south east) --
 ([xshift=-16pt, yshift=5pt]locy-v0.north east) -- 
 ([xshift=-16pt, yshift=-5pt]locy-v0.south east);
 
 \path (tid3start) node[anchor=south, rectangle, fill=DarkGreen!20, draw=DarkGreen, font=\small, inner sep=1pt] {$\tid_1$};

\end{pgfonlayer}
\end{tikzpicture}
\\
{\small (e)} & {\small (f)} \\
\hline
\end{tabular}
\caption{History heaps obtained in a execution of $\prog_2$.}
\label{fig:cc.exec}
\end{figure}
The next consistency model that we consider is \emph{transactional causal consistency} 
\cite{?}. Intuitively, in this consistency model transactions must be ensured 
that versions read by transactions are closed with respect to causal dependencies. 
Consider for example the following program: 
\[
    \prog_2 := \begin{session}
        \begin{array}{@{}c || c || c@{}}
            \begin{transaction}
            		 \pmutate{\loc_x}{1};\\
              \end{transaction} &
              \begin{transaction}
            		  \pderef{\pvar{a}}{\loc_x};\\
            		  \pmutate{\loc_x}{a};\\
            	  \end{transaction} &
              \begin{transaction}
            		   \pderef{\pvar{a}}{\loc_x};\\
            		   \pderef{\pvar{b}}{\loc_y};\\
            		   \pifs{\pvar{a}=0 \wedge \pvar{b}=1}\\
            				\;\;\;\;\passign{\retvar}{\Large \frownie{}}
            			\}
             \end{transaction}
        \end{array}
    \end{session}
 \]
For the sake of simplicity, we label the code of the three transactions above 
ast $\trans_1, \trans_2, \trans_3$, from left to right.
It is easy to see that, if no constraints are placed on the  consistency model, 
then we can have $\ptrans{\trans_3}$ return ${\Large \frownie{}}$. 
The same is true even if the consistency model specification $\mathsf{RA}$ is assumed. 
Informally, the return of value ${\Large \frownie{}}$ by $\ptrans{\trans_3}$ can be 
obtained from the schedule below. 
%In the initial history heap of the execution, 
%$\hh_0$,  both locations $\loc_x, \loc_y$ contain a single version with value $0$, written by transaction $\tsid_0$. 
The initial configuration of this execution is depicted in Figure \ref{fig:cc.exec}(a).
%\begin{center}
%\begin{tikzpicture}[font=\large]
%
%\begin{pgfonlayer}{foreground}
%%Uncomment line below for help lines
%%\draw[help lines] grid(5,4);
%
%%Location x
%\node(locx) at (1,3) {$[\loc_x] \mapsto$};
%
%\matrix(locxcells) [version list, text width=7mm, anchor=west]
%   at ([xshift=10pt]locx.east) {
% {a} & $T_0$ \\
%  {a} & $\emptyset$ \\
%};
%\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
%
%%Location y
%\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
%\matrix(locycells) [version list, text width=7mm, anchor=west]
%   at ([xshift=10pt]locy.east) {
% {a} & $T_0$ \\
%  {a} & $\emptyset$ \\
%};
%\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
%
%% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);
%
%%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
%\draw[-, blue, very thick, rounded corners=10pt]
% ([xshift=-2pt, yshift=20pt]locx-v0.north east) node (tid1start) {} -- 
%% ([xshift=-2pt, yshift=-5pt]locx-v0.south east) --
%% ([xshift=-2pt, yshift=5pt]locy-v0.north east) -- 
% ([xshift=-2pt, yshift=-5pt]locy-v0.south east);
% 
% \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_3$};
%
%%red view
%\draw[-, red, very thick, rounded corners = 10pt]
% ([xshift=-5pt, yshift=5pt]locx-v0.north east) -- 
%% ([xshift=-8pt, yshift=-5pt]locx-v0.south east) --
%% ([xshift=-8pt, yshift=5pt]locy-v0.north east) -- 
% ([xshift=-5pt, yshift=-10pt]locy-v0.south east) node (tid2start) {};
% 
%\path (tid2start) node[anchor=north, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\tid_2$};
% 
% %green view
%\draw[-, DarkGreen, very thick, rounded corners = 10pt]
% ([xshift=-16pt, yshift=8pt]locx-v0.north east) node (tid3start) {}-- 
%% ([xshift=-15pt, yshift=-5pt]locx-v0.south east) --
%% ([xshift=-15pt, yshift=5pt]locy-v0.north east) -- 
% ([xshift=-16pt, yshift=-5pt]locy-v0.south east);
% 
% \path (tid3start) node[anchor=south, rectangle, fill=DarkGreen!20, draw=DarkGreen, font=\small, inner sep=1pt] {$\tid_1$};
%
%\end{pgfonlayer}
%\end{tikzpicture}
%\end{center}

\begin{itemize}
\item $\ptrans{\trans_1}$ executes with the initial view, which points to the 
initial (and only) version for each location; after this transaction is 
executed, a new version $\langle 1, T_1, \emptyset \rangle$ is appended 
at the end of $\hh{\loc_{x}}$. The resulting history heap is depicted in Figure \ref{fig:cc.exec}(b).
%\begin{center}
%\begin{tikzpicture}[font=\large]
%
%\begin{pgfonlayer}{foreground}
%%Uncomment line below for help lines
%%\draw[help lines] grid(5,4);
%
%%Location x
%\node(locx) at (1,3) {$[\loc_x] \mapsto$};
%
%\matrix(locxcells) [version list, text width=7mm, anchor=west]
%   at ([xshift=10pt]locx.east) {
% {a} & $\tsid_0$ & {a} & $\tsid_1$\\
%  {a} & $\emptyset$ & {a} & $\emptyset$ \\
%};
%\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
%\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v-1) {$1$};
%%Location y
%\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
%\matrix(locycells) [version list, text width=7mm, anchor=west]
%   at ([xshift=10pt]locy.east) {
% {a} & $\tsid_0$ \\
%   {a} & $\emptyset$ \\
%};
%\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
%% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);
%
%%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
%\draw[-, blue, very thick, rounded corners=10pt]
% ([xshift=-2pt, yshift=20pt]locx-v0.north east) node (tid1start) {} -- 
%% ([xshift=-2pt, yshift=-5pt]locx-v0.south east) --
%% ([xshift=-2pt, yshift=5pt]locy-v0.north east) -- 
% ([xshift=-2pt, yshift=-5pt]locy-v0.south east);
% 
% \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_3$};
%
%%red view
%\draw[-, red, very thick, rounded corners = 10pt]
% ([xshift=-5pt, yshift=5pt]locx-v0.north east) -- 
%% ([xshift=-8pt, yshift=-5pt]locx-v0.south east) --
%% ([xshift=-8pt, yshift=5pt]locy-v0.north east) -- 
% ([xshift=-5pt, yshift=-10pt]locy-v0.south east) node (tid2start) {};
% 
%\path (tid2start) node[anchor=north, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\tid_2$};
% 
% %green view
%\draw[-, DarkGreen, very thick, rounded corners = 10pt]
% ([xshift=-16pt, yshift=8pt]locx-v1.north east) node (tid3start) {}-- 
% ([xshift=-16pt, yshift=-5pt]locx-v1.south east) --
% ([xshift=-16pt, yshift=5pt]locy-v0.north east) -- 
% ([xshift=-16pt, yshift=-5pt]locy-v0.south east);
% 
% \path (tid3start) node[anchor=south, rectangle, fill=DarkGreen!20, draw=DarkGreen, font=\small, inner sep=1pt] {$\tid_1$};
%
%\end{pgfonlayer}
%\end{tikzpicture}
%\end{center}
\item next, $\tid_2$ updates its view as to see the version of $\loc_x$ installed by $\tid_1$, after 
which it proceeds to execute $\ptrans{\trans_2}$. This results in a new version with value $1$ 
to be installed for $\loc_y$. The history heaps before, and after the execution of $\ptrans{\trans_2}$, 
are depicted in figures \ref{fig:cc.exec}(c) and \ref{fig:cc.exec}(d), respectively.
%\begin{center}
%\begin{tikzpicture}[font=\large]
%
%\begin{pgfonlayer}{foreground}
%%Uncomment line below for help lines
%%\draw[help lines] grid(5,4);
%
%%Location x
%\node(locx) at (1,3) {$[\loc_x] \mapsto$};
%
%\matrix(locxcells) [version list, text width=7mm, anchor=west]
%   at ([xshift=10pt]locx.east) {
% {a} & $\tsid_0$ & {a} & $\tsid_1$\\
%  {a} & $\emptyset$ & {a} & $\emptyset$ \\
%};
%\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
%\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v-1) {$1$};
%%Location y
%\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
%\matrix(locycells) [version list, text width=7mm, anchor=west]
%   at ([xshift=10pt]locy.east) {
% {a} & $\tsid_0$ \\
%   {a} & $\emptyset$ \\
%};
%\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
%% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);
%
%%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
%\draw[-, blue, very thick, rounded corners=10pt]
% ([xshift=-2pt, yshift=20pt]locx-v0.north east) node (tid1start) {} -- 
%% ([xshift=-2pt, yshift=-5pt]locx-v0.south east) --
%% ([xshift=-2pt, yshift=5pt]locy-v0.north east) -- 
% ([xshift=-2pt, yshift=-5pt]locy-v0.south east);
% 
% \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_3$};
%
%%red view
%\draw[-, red, very thick, rounded corners = 10pt]
% ([xshift=-5pt, yshift=5pt]locx-v1.north east) -- 
% ([xshift=-5pt, yshift=-5pt]locx-v1.south east) --
% ([xshift=-5pt, yshift=3pt]locy-v0.north east) -- 
% ([xshift=-5pt, yshift=-10pt]locy-v0.south east) node (tid2start) {};
% 
%\path (tid2start) node[anchor=north, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\tid_2$};
% 
% %green view
%\draw[-, DarkGreen, very thick, rounded corners = 10pt]
% ([xshift=-16pt, yshift=8pt]locx-v1.north east) node (tid3start) {}-- 
% ([xshift=-16pt, yshift=-5pt]locx-v1.south east) --
% ([xshift=-16pt, yshift=5pt]locy-v0.north east) -- 
% ([xshift=-16pt, yshift=-5pt]locy-v0.south east);
% 
% \path (tid3start) node[anchor=south, rectangle, fill=DarkGreen!20, draw=DarkGreen, font=\small, inner sep=1pt] {$\tid_1$};
%
%\end{pgfonlayer}
%\end{tikzpicture}
%\hfill
%\begin{tikzpicture}[font=\large]
%
%\begin{pgfonlayer}{foreground}
%%Uncomment line below for help lines
%%\draw[help lines] grid(5,4);
%
%%Location x
%\node(locx) at (1,3) {$[\loc_x] \mapsto$};
%
%\matrix(locxcells) [version list, text width=7mm, anchor=west]
%   at ([xshift=10pt]locx.east) {
% {a} & $\tsid_0$ & {a} & $\tsid_1$\\
%  {a} & $\emptyset$ & {a} & $\{\tsid_2\}$ \\
%};
%\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
%\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v-1) {$1$};
%%Location y
%\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
%\matrix(locycells) [version list, text width=7mm, anchor=west]
%   at ([xshift=10pt]locy.east) {
% {a} & $\tsid_0$ & {a} & $\tsid_2$ \\
%   {a} & $\emptyset$ & {a} & $\emptyset$\\
%};
%\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
%\node[version node, fit=(locycells-1-3) (locycells-2-3), fill=white, inner sep=0cm, font=\Large] (locy-v-1) {$1$};
%% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);
%
%%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
%\draw[-, blue, very thick, rounded corners=10pt]
% ([xshift=-2pt, yshift=20pt]locx-v0.north east) node (tid1start) {} -- 
%% ([xshift=-2pt, yshift=-5pt]locx-v0.south east) --
%% ([xshift=-2pt, yshift=5pt]locy-v0.north east) -- 
% ([xshift=-2pt, yshift=-5pt]locy-v0.south east);
% 
% \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_3$};
%
%%red view
%\draw[-, red, very thick, rounded corners = 10pt]
% ([xshift=-5pt, yshift=5pt]locx-v1.north east) -- 
%% ([xshift=-5pt, yshift=-5pt]locx-v1.south east) --
%% ([xshift=-5pt, yshift=3pt]locy-v0.north east) -- 
% ([xshift=-5pt, yshift=-10pt]locy-v1.south east) node (tid2start) {};
% 
%\path (tid2start) node[anchor=north, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\tid_2$};
% 
% %green view
%\draw[-, DarkGreen, very thick, rounded corners = 10pt]
% ([xshift=-16pt, yshift=8pt]locx-v1.north east) node (tid3start) {}-- 
% ([xshift=-16pt, yshift=-5pt]locx-v1.south east) --
% ([xshift=-16pt, yshift=5pt]locy-v0.north east) -- 
% ([xshift=-16pt, yshift=-5pt]locy-v0.south east);
% 
% \path (tid3start) node[anchor=south, rectangle, fill=DarkGreen!20, draw=DarkGreen, font=\small, inner sep=1pt] {$\tid_1$};
%
%\end{pgfonlayer}
%\end{tikzpicture}
%\end{center}
\item Finally, thread $\tid_3$ updates its view to observe the update of location $[\loc_y]$, but not the update of 
location $[\loc_y]$, before executing transaction $\ptrans{\trans_3}$. The execution of $\ptrans{\trans_3}$ will 
return the value ${\Large \frownie{}}$. The history heaps immediately before and after 
the execution of $\tid_3$, are depicted in figures \ref{fig:cc.exec}(e) and \ref{fig:cc.exec}(f), respectively. 
%\begin{center}
%\begin{tikzpicture}[font=\large]
%
%\begin{pgfonlayer}{foreground}
%%Uncomment line below for help lines
%%\draw[help lines] grid(5,4);
%
%%Location x
%\node(locx) at (1,3) {$[\loc_x] \mapsto$};
%
%\matrix(locxcells) [version list, text width=7mm, anchor=west]
%   at ([xshift=10pt]locx.east) {
% {a} & $\tsid_0$ & {a} & $\tsid_1$\\
%  {a} & $\emptyset$ & {a} & $\{\tsid_2\}$ \\
%};
%\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
%\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v-1) {$1$};
%%Location y
%\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
%\matrix(locycells) [version list, text width=7mm, anchor=west]
%   at ([xshift=10pt]locy.east) {
% {a} & $\tsid_0$ & {a} & $\tsid_2$ \\
%   {a} & $\emptyset$ & {a} & $\emptyset$\\
%};
%\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
%\node[version node, fit=(locycells-1-3) (locycells-2-3), fill=white, inner sep=0cm, font=\Large] (locy-v-1) {$1$};
%% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);
%
%%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
%\draw[-, blue, very thick, rounded corners=10pt]
% ([xshift=-2pt, yshift=20pt]locx-v0.north east) node (tid1start) {} -- 
% ([xshift=-2pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-2pt, yshift=5pt]locy-v1.north east) -- 
% ([xshift=-2pt, yshift=-5pt]locy-v1.south east);
% 
% \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_3$};
%
%%red view
%\draw[-, red, very thick, rounded corners = 10pt]
% ([xshift=-5pt, yshift=5pt]locx-v1.north east) -- 
%% ([xshift=-5pt, yshift=-5pt]locx-v1.south east) --
%% ([xshift=-5pt, yshift=3pt]locy-v0.north east) -- 
% ([xshift=-5pt, yshift=-10pt]locy-v1.south east) node (tid2start) {};
% 
%\path (tid2start) node[anchor=north, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\tid_2$};
% 
% %green view
%\draw[-, DarkGreen, very thick, rounded corners = 10pt]
% ([xshift=-16pt, yshift=8pt]locx-v1.north east) node (tid3start) {}-- 
% ([xshift=-16pt, yshift=-5pt]locx-v1.south east) --
% ([xshift=-16pt, yshift=5pt]locy-v0.north east) -- 
% ([xshift=-16pt, yshift=-5pt]locy-v0.south east);
% 
% \path (tid3start) node[anchor=south, rectangle, fill=DarkGreen!20, draw=DarkGreen, font=\small, inner sep=1pt] {$\tid_1$};
%
%\end{pgfonlayer}
%\end{tikzpicture}
%\hfill
%\begin{tikzpicture}[font=\large]
%
%\begin{pgfonlayer}{foreground}
%%Uncomment line below for help lines
%%\draw[help lines] grid(5,4);
%
%%Location x
%\node(locx) at (1,3) {$[\loc_x] \mapsto$};
%
%\matrix(locxcells) [version list, text width=7mm, anchor=west]
%   at ([xshift=10pt]locx.east) {
% {a} & $\tsid_0$ & {a} & $\tsid_1$\\
%  {a} & $\{\tsid_3\}$ & {a} & $\{\tsid_2\}$ \\
%};
%\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
%\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};
%%Location y
%\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
%\matrix(locycells) [version list, text width=7mm, anchor=west]
%   at ([xshift=10pt]locy.east) {
% {a} & $\tsid_0$ & {a} & $\tsid_2$ \\
%   {a} & $\emptyset$ & {a} & $\{\tsid_3\}$\\
%};
%\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
%\node[version node, fit=(locycells-1-3) (locycells-2-3), fill=white, inner sep=0cm, font=\Large] (locy-v1) {$1$};
%% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);
%
%%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
%\draw[-, blue, very thick, rounded corners=10pt]
% ([xshift=-2pt, yshift=20pt]locx-v0.north east) node (tid1start) {} -- 
% ([xshift=-2pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-2pt, yshift=5pt]locy-v1.north east) -- 
% ([xshift=-2pt, yshift=-5pt]locy-v1.south east);
% 
% \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_3$};
%
%%red view
%\draw[-, red, very thick, rounded corners = 10pt]
% ([xshift=-5pt, yshift=5pt]locx-v1.north east) -- 
%% ([xshift=-5pt, yshift=-5pt]locx-v1.south east) --
%% ([xshift=-5pt, yshift=3pt]locy-v0.north east) -- 
% ([xshift=-5pt, yshift=-10pt]locy-v1.south east) node (tid2start) {};
% 
%\path (tid2start) node[anchor=north, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\tid_2$};
% 
% %green view
%\draw[-, DarkGreen, very thick, rounded corners = 10pt]
% ([xshift=-16pt, yshift=8pt]locx-v1.north east) node (tid3start) {}-- 
% ([xshift=-16pt, yshift=-5pt]locx-v1.south east) --
% ([xshift=-16pt, yshift=5pt]locy-v0.north east) -- 
% ([xshift=-16pt, yshift=-5pt]locy-v0.south east);
% 
% \path (tid3start) node[anchor=south, rectangle, fill=DarkGreen!20, draw=DarkGreen, font=\small, inner sep=1pt] {$\tid_1$};
%
%\end{pgfonlayer}
%\end{tikzpicture}
%\end{center}
\end{itemize}

%\ac{The only way I can think to define causal consistency right now, is by using 
%write-read dependencies. Hopefully there is a more operational specification. 
%
%I take it back, I can give an inductive definition of causally consistent views, 
%without using dependencies explicitly - though in practice I am still tracking down 
%write-read dependencies.}
The reason why the execution outlined above is because, in the last step, 
thread $\tid_3$ executed transaction $\ptrans{\trans_3}$ in a 
state where its view observes the update to location $[\loc_y]$, but 
not the update to location $\loc_2$. However, the update of $[\loc_y]$ 
performed in  $\ptrans{\trans_2}$, consisted in copying the value of the update 
of $[\loc_y]$: that is, the update of $[\loc_y]$ \textbf{depends} from the update of $[\loc_x]$. 
Summarising, the execution of transaction $\ptrans{\trans_3}$ resulted in a violation of 
causality: the update of $[\loc_y]$ is observed, but not the update of $[\loc_x]$ on which 
it depends.

To specify formally transactional causal consistency, we define inductively the 
set of views that are consistent with respect to a history heap $\hh$. 
Intuitively, the definition below models the fact that, if we start from a 
causally consistent view, and we wish to update the view for some location $\tid_2$, 


\begin{definition}
Let $\nu_1 = (v_1, \tsid_1, \mathcal{T}_1)$, $\nu_2 = (v_2, \tsid_2, \mathcal{T_2})$. 
We say that $\nu_2$ directly depends on $\nu_1$ if $\tsid_1 \in \mathcal{T_2}$. 
\ac{Note to self: the notion of directly depends here has little to do with dependencies 
between transactions. Note to note to self: directly depends is the name that 
makes most sense here, though it's going to drive Philippa mad because of the 
clash of terminology with dependency graphs.}

Let $\hh$ be a history heap. The set of views that are \emph{causally consistent} 
with respect to $\hh$, $\mathsf{CCViews}(\hh)$, is defined as the smallest set such that: 
\begin{enumerate} 
\item $V_0 := \lambda [\loc_x].0 \in \mathsf{CCViews}(\hh)$, 
\item let $V \in \mathsf{CCViews}(\hh)$, $V' = V[[\loc_x] \mapsto (V(x) + 1)]$, 
%for some $i: V([\loc_x]) < i \leq \lvert \hh \rvert -1$
for some $[\loc_x]$ such that $V([\loc_x]) < \lvert \hh([\loc_x]) \rvert - 1$.
Suppose that for any location $[\loc_y]$ and 
index $j = 0, \cdots, \lvert \hh([\loc_y]) \rvert -1$ such that $\hh([\loc_{x})(V'([\loc_x]))$ 
directly depends on $\hh([\loc_y])(j)$, then $j \leq V([\loc_y])$. Then 
$V' \in \mathsf{CCViews}(\hh)$.
% and suppose that $\hh([\loc_{x}])(V'([\loc_x])) = 
%(\_, \tsid, \_ )$ for some $\tsid$. If for all locations $\loc_{y}$ and 
%indexes $j$ such that $\hh([\loc_y])(j) = (\_, \_, \_ \cup \{\tsid\})$, 
%then $j \leq V'([\loc_y])$, then $V' \in \mathsf{CCViews}(\hh)$.
\end{enumerate}
\end{definition}

\begin{figure}
\begin{tabular}{|c|c|} 
\hline
\begin{tikzpicture}[font=\large]

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) at (1,3) {$[\loc_x] \mapsto$};

\matrix(locxcells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locx.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_1$\\
  {a} & $\emptyset$ & {a} & $\{\tsid_2\}$ \\
};
\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v-1) {$1$};
%Location y
\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
\matrix(locycells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locy.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_2$ \\
   {a} & $\emptyset$ & {a} & $\{\tsid_3\}$\\
};
\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
\node[version node, fit=(locycells-1-3) (locycells-2-3), fill=white, inner sep=0cm, font=\Large] (locy-v1) {$1$};
% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

\path (locy.south) + (0,-1.5) node (locy) {$[\loc_z] \mapsto$};
\matrix(loczcells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locy.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_3$ \\
   {a} & $\emptyset$ & {a} & $\emptyset$\\
};
\node[version node, fit=(loczcells-1-1) (loczcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locz-v0) {$0$};
\node[version node, fit=(loczcells-1-3) (loczcells-2-3), fill=white, inner sep=0cm, font=\Large] (locz-v1) {$1$};

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
 ([xshift=-5pt, yshift=5pt]locx-v0.north east) node (tid1start) {} -- 
% ([xshift=-5pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-5pt, yshift=5pt]locy-v1.north east) -- 
 ([xshift=-5pt, yshift=-5pt]locy-v0.south east);
 
% \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_3$};
\end{pgfonlayer}
\end{tikzpicture}
&
\begin{tikzpicture}[font=\large]

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) at (1,3) {$[\loc_x] \mapsto$};

\matrix(locxcells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locx.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_1$\\
  {a} & $\emptyset$ & {a} & $\{\tsid_2\}$ \\
};
\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};

%Location y
\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
\matrix(locycells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locy.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_2$ \\
   {a} & $\emptyset$ & {a} & $\{\tsid_3\}$\\
};
\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
\node[version node, fit=(locycells-1-3) (locycells-2-3), fill=white, inner sep=0cm, font=\Large] (locy-v1) {$1$};



\path (locy.south) + (0,-1.5) node (locz) {$[\loc_z] \mapsto$};
\matrix(loczcells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locz.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_3$ \\
   {a} & $\emptyset$ & {a} & $\emptyset$\\
};

\node[version node, fit=(loczcells-1-1) (loczcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locz-v0) {$0$};
\node[version node, fit=(loczcells-1-3) (loczcells-2-3), fill=white, inner sep=0cm, font=\Large] (locz-v1) {$1$};

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
 ([xshift=-5pt, yshift=5pt]locx-v1.north east) node (tid1start) {} -- 
 ([xshift=-5pt, yshift=-5pt]locx-v1.south east) --
 ([xshift=-5pt, yshift=5pt]locy-v0.north east) -- 
% ([xshift=-5pt, yshift=-5pt]locy-v0.south east) --
% ([xshift=-5pt, yshift=5pt]locz-v0.north east) -- 
 ([xshift=-5pt, yshift=-5pt]locz-v0.south east);
 
% \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_3$};
\end{pgfonlayer}
\end{tikzpicture}
\\
{\small(a)} & {\small(b)}\\
\hline
\begin{tikzpicture}[font=\large]

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) at (1,3) {$[\loc_x] \mapsto$};

\matrix(locxcells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locx.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_1$\\
  {a} & $\emptyset$ & {a} & $\{\tsid_2\}$ \\
};
\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};

%Location y
\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
\matrix(locycells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locy.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_2$ \\
   {a} & $\emptyset$ & {a} & $\{\tsid_3\}$\\
};
\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
\node[version node, fit=(locycells-1-3) (locycells-2-3), fill=white, inner sep=0cm, font=\Large] (locy-v1) {$1$};



\path (locy.south) + (0,-1.5) node (locz) {$[\loc_z] \mapsto$};
\matrix(loczcells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locz.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_3$ \\
   {a} & $\emptyset$ & {a} & $\emptyset$\\
};

\node[version node, fit=(loczcells-1-1) (loczcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locz-v0) {$0$};
\node[version node, fit=(loczcells-1-3) (loczcells-2-3), fill=white, inner sep=0cm, font=\Large] (locz-v1) {$1$};

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
 ([xshift=-5pt, yshift=5pt]locx-v1.north east) node (tid1start) {} -- 
% ([xshift=-5pt, yshift=-5pt]locx-v1.south east) --
% ([xshift=-5pt, yshift=5pt]locy-v0.north east) -- 
 ([xshift=-5pt, yshift=-5pt]locy-v1.south east) --
 ([xshift=-5pt, yshift=5pt]locz-v0.north east) -- 
 ([xshift=-5pt, yshift=-5pt]locz-v0.south east);
 
% \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_3$};
\end{pgfonlayer}
\end{tikzpicture}
&
\begin{tikzpicture}[font=\large]

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) at (1,3) {$[\loc_x] \mapsto$};

\matrix(locxcells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locx.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_1$\\
  {a} & $\emptyset$ & {a} & $\{\tsid_2\}$ \\
};
\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};

%Location y
\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
\matrix(locycells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locy.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_2$ \\
   {a} & $\emptyset$ & {a} & $\{\tsid_3\}$\\
};
\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
\node[version node, fit=(locycells-1-3) (locycells-2-3), fill=white, inner sep=0cm, font=\Large] (locy-v1) {$1$};



\path (locy.south) + (0,-1.5) node (locz) {$[\loc_z] \mapsto$};
\matrix(loczcells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locz.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_3$ \\
   {a} & $\emptyset$ & {a} & $\emptyset$\\
};

\node[version node, fit=(loczcells-1-1) (loczcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locz-v0) {$0$};
\node[version node, fit=(loczcells-1-3) (loczcells-2-3), fill=white, inner sep=0cm, font=\Large] (locz-v1) {$1$};

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
 ([xshift=-5pt, yshift=5pt]locx-v1.north east) node (tid1start) {} -- 
% ([xshift=-5pt, yshift=-5pt]locx-v1.south east) --
% ([xshift=-5pt, yshift=5pt]locy-v0.north east) -- 
% ([xshift=-5pt, yshift=-5pt]locy-v1.south east) --
% ([xshift=-5pt, yshift=5pt]locz-v0.north east) -- 
 ([xshift=-5pt, yshift=-5pt]locz-v1.south east);
 
% \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_3$};
\end{pgfonlayer}
\end{tikzpicture}\\
{\small(c)} & {\small(d)}\\
\hline
\end{tabular}
\caption{Building a causally consistent view.}
\label{fig:cc.view}
\end{figure}

\begin{example}
\ac{Note to self: I got this example and the definition wrong several times before getting them
right. Which means that inductive definition of causally dependent views is not really that 
intuitive after all...}
Consider the history heap $\hh$, depicted in Figure \ref{fig:cc.view}(a) 
- ignore for the moment the view in the Figure.
%\begin{center}
%\begin{tikzpicture}[font=\large]
%
%\begin{pgfonlayer}{foreground}
%%Uncomment line below for help lines
%%\draw[help lines] grid(5,4);
%
%%Location x
%\node(locx) at (1,3) {$[\loc_x] \mapsto$};
%
%\matrix(locxcells) [version list, text width=7mm, anchor=west]
%   at ([xshift=10pt]locx.east) {
% {a} & $\tsid_0$ & {a} & $\tsid_1$\\
%  {a} & $\emptyset$ & {a} & $\{\tsid_2\}$ \\
%};
%\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
%\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v-1) {$1$};
%%Location y
%\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
%\matrix(locycells) [version list, text width=7mm, anchor=west]
%   at ([xshift=10pt]locy.east) {
% {a} & $\tsid_0$ & {a} & $\tsid_2$ \\
%   {a} & $\emptyset$ & {a} & $\{\tsid_3\}$\\
%};
%\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
%\node[version node, fit=(locycells-1-3) (locycells-2-3), fill=white, inner sep=0cm, font=\Large] (locy-v1) {$1$};
%% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);
%
%\path (locy.south) + (0,-1.5) node (locy) {$[\loc_z] \mapsto$};
%\matrix(loczcells) [version list, text width=7mm, anchor=west]
%   at ([xshift=10pt]locy.east) {
% {a} & $\tsid_0$ & {a} & $\tsid_3$ \\
%   {a} & $\emptyset$ & {a} & $\emptyset$\\
%};
%\node[version node, fit=(loczcells-1-1) (loczcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locz-v0) {$0$};
%\node[version node, fit=(loczcells-1-3) (loczcells-2-3), fill=white, inner sep=0cm, font=\Large] (locz-v1) {$1$};
%
%%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
%%\draw[-, blue, very thick, rounded corners=10pt]
%% ([xshift=-5pt, yshift=5pt]locx-v0.north east) node (tid1start) {} -- 
%% ([xshift=-5pt, yshift=-5pt]locx-v0.south east) --
%% ([xshift=-5pt, yshift=5pt]locy-v1.north east) -- 
%% ([xshift=-5pt, yshift=-5pt]locy-v1.south east);
% 
%% \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_3$};
%\end{pgfonlayer}
%\end{tikzpicture}
%\end{center}
We want to find a view $V$ that is up-to-date with the update of location $[\loc_z]$; 
that is, $V[\loc_z] = 1$, and $\hh([\loc_z])(V[\loc_z]) = (1, \tsid_3, \{\tsid_4\})$.
Furthermore, we want the view $V$ to be causally consistent. 
We construct such a view by induction. 

We start from the initial view $V_0$, $V_0([\loc_{\_}]) = 0$. This view is 
depicted in Figure \ref{fig:cc.view}(a), and it is 
causally consistent by definition. However, it does not include the update to location $[\loc_z]$: 
$V_0([\loc_z]) = 0$. As a first try, one could immediately consider a view $V'$ 
where the value for location $[\loc_z]$ is updated to $1$, 
that is $V' = V_0[ [\loc_z] \mapsto 1]$. However, in this case 
the view $V'$ is not causally consistent. In fact, the version observed 
by $V'$ for location $[\loc_z]$ is $\hh([\loc_z])(V'([\loc_z]) = 
\{1, \tsid_3, \emptyset\}$, meaning that the version has been written 
by transaction $\tsid_3$. On the other hand, we also have 
that $V'([\loc_y]) = 0$, while $\hh([\loc_{y}])(1) = (1, \tsid_2, 
\{\tsid_3\}$. That is, the version observed by $V'$ for $[\loc_z]$ 
directly depends from the version $\hh([\loc_y])(1)$, but the latter 
is not observed by $V'$; in fact, $V'([\loc_y]) = 1$. 

As a second attempt, one could then try to update the the view of location 
$[\loc_y]$ to value $1$, resulting in the value $V'' = V_0[ [\loc_y] \mapsto 1]$, 
but similarly we would find that the version 
$\hh([\loc_y])(1) = (\_, \tsid_2, \_)$ directly depends from the version 
$\hh([\loc_x])(1) = (\_, \_, \{\tsid_2\})$, and $V''([\loc_x]) = 0 < 1$. 

Finally, we can update the view $V_0$ to include the update of $[\loc_x]$: 
this results in the view $V_1 = V_0[ [\loc_x] \mapsto 1$. Because $\hh([\loc_x])(1) 
= (\_, \tsid_1, \_)$, and there is no version $\nu$ in $\hh$ on which 
$\hh([\loc_x])(1)$ depends - i.e. such that  
$\nu = (\_, \_, \_ \cup \{\tsid_1\})$ - we can conclude that $V_1$ is causally 
consistent. The view $V_1$ is depicted in Figure \ref{fig:cc.view}(b).
%We can now proceed to update the view of location $[\loc_y]$ in $T_1$. 
%Because 

%\begin{center}
%\begin{tikzpicture}[font=\large]
%
%\begin{pgfonlayer}{foreground}
%%Uncomment line below for help lines
%%\draw[help lines] grid(5,4);
%
%%Location x
%\node(locx) at (1,3) {$[\loc_x] \mapsto$};
%
%\matrix(locxcells) [version list, text width=7mm, anchor=west]
%   at ([xshift=10pt]locx.east) {
% {a} & $\tsid_0$ & {a} & $\tsid_1$\\
%  {a} & $\emptyset$ & {a} & $\{\tsid_2\}$ \\
%};
%\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
%\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};
%
%%Location y
%\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
%\matrix(locycells) [version list, text width=7mm, anchor=west]
%   at ([xshift=10pt]locy.east) {
% {a} & $\tsid_0$ & {a} & $\tsid_2$ \\
%   {a} & $\emptyset$ & {a} & $\{\tsid_3\}$\\
%};
%\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
%\node[version node, fit=(locycells-1-3) (locycells-2-3), fill=white, inner sep=0cm, font=\Large] (locy-v1) {$1$};
%
%
%
%\path (locy.south) + (0,-1.5) node (locz) {$[\loc_z] \mapsto$};
%\matrix(loczcells) [version list, text width=7mm, anchor=west]
%   at ([xshift=10pt]locz.east) {
% {a} & $\tsid_0$ & {a} & $\tsid_3$ \\
%   {a} & $\emptyset$ & {a} & $\emptyset$\\
%};
%
%\node[version node, fit=(loczcells-1-1) (loczcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locz-v0) {$0$};
%\node[version node, fit=(loczcells-1-3) (loczcells-2-3), fill=white, inner sep=0cm, font=\Large] (locz-v1) {$1$};
%
%%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
%\draw[-, blue, very thick, rounded corners=10pt]
% ([xshift=-5pt, yshift=5pt]locx-v1.north east) node (tid1start) {} -- 
% ([xshift=-5pt, yshift=-5pt]locx-v1.south east) --
% ([xshift=-5pt, yshift=5pt]locy-v0.north east) -- 
%% ([xshift=-5pt, yshift=-5pt]locy-v0.south east) --
%% ([xshift=-5pt, yshift=5pt]locz-v0.north east) -- 
% ([xshift=-5pt, yshift=-5pt]locz-v0.south east);
% 
%% \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_3$};
%\end{pgfonlayer}
%\end{tikzpicture}
%\end{center}
We can now update the view $V_1$ to include the version $\hh([\loc_y])(1)$, 
resulting in the view $V_2 := V_1[ [\loc_y] \mapsto 1]$, depicted in Figure \ref{fig:cc.view}(c). 
Because the view $V_1$ is 
causally consistent, and because all the versions on which $\hh([\loc_y])(V_2([\loc_y]))$ directly depends
are included in $V_1$, then $V_2$ is also causally consistent. Similarly, we can define 
the view $V_3 := V_2[[\loc_z] \mapsto 1]$, depicted in Figure \ref{fig:cc.view}(d), 
and prove that it casually consistent. 

%\begin{center}
%\begin{tikzpicture}[font=\large]
%
%\begin{pgfonlayer}{foreground}
%%Uncomment line below for help lines
%%\draw[help lines] grid(5,4);
%
%%Location x
%\node(locx) at (1,3) {$[\loc_x] \mapsto$};
%
%\matrix(locxcells) [version list, text width=7mm, anchor=west]
%   at ([xshift=10pt]locx.east) {
% {a} & $\tsid_0$ & {a} & $\tsid_1$\\
%  {a} & $\emptyset$ & {a} & $\{\tsid_2\}$ \\
%};
%\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
%\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};
%
%%Location y
%\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
%\matrix(locycells) [version list, text width=7mm, anchor=west]
%   at ([xshift=10pt]locy.east) {
% {a} & $\tsid_0$ & {a} & $\tsid_2$ \\
%   {a} & $\emptyset$ & {a} & $\{\tsid_3\}$\\
%};
%\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
%\node[version node, fit=(locycells-1-3) (locycells-2-3), fill=white, inner sep=0cm, font=\Large] (locy-v1) {$1$};
%
%
%
%\path (locy.south) + (0,-1.5) node (locz) {$[\loc_z] \mapsto$};
%\matrix(loczcells) [version list, text width=7mm, anchor=west]
%   at ([xshift=10pt]locz.east) {
% {a} & $\tsid_0$ & {a} & $\tsid_3$ \\
%   {a} & $\emptyset$ & {a} & $\emptyset$\\
%};
%
%\node[version node, fit=(loczcells-1-1) (loczcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locz-v0) {$0$};
%\node[version node, fit=(loczcells-1-3) (loczcells-2-3), fill=white, inner sep=0cm, font=\Large] (locz-v1) {$1$};
%
%%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
%\draw[-, blue, very thick, rounded corners=10pt]
% ([xshift=-5pt, yshift=5pt]locx-v1.north east) node (tid1start) {} -- 
%% ([xshift=-5pt, yshift=-5pt]locx-v1.south east) --
%% ([xshift=-5pt, yshift=5pt]locy-v0.north east) -- 
% ([xshift=-5pt, yshift=-5pt]locy-v1.south east) --
% ([xshift=-5pt, yshift=5pt]locz-v0.north east) -- 
% ([xshift=-5pt, yshift=-5pt]locz-v0.south east);
% 
%% \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_3$};
%\end{pgfonlayer}
%\end{tikzpicture}
%\hfill
%\begin{tikzpicture}[font=\large]
%
%\begin{pgfonlayer}{foreground}
%%Uncomment line below for help lines
%%\draw[help lines] grid(5,4);
%
%%Location x
%\node(locx) at (1,3) {$[\loc_x] \mapsto$};
%
%\matrix(locxcells) [version list, text width=7mm, anchor=west]
%   at ([xshift=10pt]locx.east) {
% {a} & $\tsid_0$ & {a} & $\tsid_1$\\
%  {a} & $\emptyset$ & {a} & $\{\tsid_2\}$ \\
%};
%\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
%\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};
%
%%Location y
%\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
%\matrix(locycells) [version list, text width=7mm, anchor=west]
%   at ([xshift=10pt]locy.east) {
% {a} & $\tsid_0$ & {a} & $\tsid_2$ \\
%   {a} & $\emptyset$ & {a} & $\{\tsid_3\}$\\
%};
%\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
%\node[version node, fit=(locycells-1-3) (locycells-2-3), fill=white, inner sep=0cm, font=\Large] (locy-v1) {$1$};
%
%
%
%\path (locy.south) + (0,-1.5) node (locz) {$[\loc_z] \mapsto$};
%\matrix(loczcells) [version list, text width=7mm, anchor=west]
%   at ([xshift=10pt]locz.east) {
% {a} & $\tsid_0$ & {a} & $\tsid_3$ \\
%   {a} & $\emptyset$ & {a} & $\emptyset$\\
%};
%
%\node[version node, fit=(loczcells-1-1) (loczcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locz-v0) {$0$};
%\node[version node, fit=(loczcells-1-3) (loczcells-2-3), fill=white, inner sep=0cm, font=\Large] (locz-v1) {$1$};
%
%%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
%\draw[-, blue, very thick, rounded corners=10pt]
% ([xshift=-5pt, yshift=5pt]locx-v1.north east) node (tid1start) {} -- 
%% ([xshift=-5pt, yshift=-5pt]locx-v1.south east) --
%% ([xshift=-5pt, yshift=5pt]locy-v0.north east) -- 
%% ([xshift=-5pt, yshift=-5pt]locy-v1.south east) --
%% ([xshift=-5pt, yshift=5pt]locz-v0.north east) -- 
% ([xshift=-5pt, yshift=-5pt]locz-v1.south east);
% 
%% \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_3$};
%\end{pgfonlayer}
%\end{tikzpicture}
%\end{center}
\end{example}

Causal consistency ensures that transactions can only observe 
a causally consistent state of the database, i.e. they can only run 
only by threads with a causally consistent view of the history heap.

\begin{definition}
$(\hh, V, \mathcal{V}) \triangleright_{\mathsf{CC}} \mathcal{O}$ if and only if 
$(\hh, V, \mathcal{O}) \triangleright_{\mathsf{RA}} \mathcal{O}$, 
and $V \in \mathsf{CCViews}(\hh)$.
\end{definition}
\ac{Note to self: here there is something subtle going on. We also need to ensure that dependencies 
caused by the information flow of the program are tracked down. For example, we could have a 
transaction returning the value of a location $[\loc_x]$, and then another transaction copy such a value 
into another location $[\loc_y]$. There is a notion of dependency between $[\loc_x], [\loc_y]$ that 
is not captured by the notion of \emph{directly depends}. On the other hand, the fact that 
stacks are thread local, and we have per-thread view monotonicity, should ensure that also program 
dependencies are preserved. A definitive proof that $\mathsf{CC}$ is equivalent to the dependency 
graph specification of causal consistency would settle the argument.}

Note that, the view $V$ of $\tid_3$ in Figure \ref{fig:cc.view}(e) is not caually consistent. This is 
because $V([\loc_y]) = 1$, and $V([\loc_x]) = 0$. However, $\hh([\loc_y])(1)$ directly depends 
in $\hh([\loc_x])(1)$, which is not included in the view. 
In general, the only case in which an execution of $\prog_2$ causes transaction $\ptrans{\trans_3}$ 
to return value ${\Large \frownie{}}$ is when such a transaction is executed using a snapshot determined 
by a non-causally consistent view. There exists no execution of $\prog_2$ under $\mathsf{CC}$ that 
causes $\ptrans{\trans_3}$ to return value ${\Large \frownie{}}$.
%if we execute the program $\prog_2$, illustrated previously in this section, under $\mathsf{CCViews}$,
%it is not possible any more to have the transaction $\ptrans{\trans_3}$ return value ${\Large \frownie}$. 
%This is because, in order for $\ptrans{\trans_3}$ to return such a value, it must be executed in a 
%configuration such as the one of Figure \ref{fig:cc.view}(e) (only the view of $\tid_3$ is relevant here), 
%%state where the view thread of $\tid_3$ observes the update to location $[\loc_y]$, but not the 
%%update of $[\loc_x]$ from which the latter causally depends. 

\ac{In theory, I can do better, and require that I see only the causal dependencies 
of what I read. But at the end of the day, who cares?}

%\begin{definition}
%Let $\hh, V$ and $[\loc_x]$ be a history heap, a view, and a location, respectively. 
Given two transactions $\tsid_1, \tsid_2$, we say that $\tsid_2$ write-read depends 
%on $\tsid_1$ via $[\loc_x]$, written $\tsid_1 \xrightarrow{\RF([\loc_x])_{\hh}} \tsid_2$, 
%if there exists an index $i = 0,\cdots, \llvert \hh, \rvert -1$ such that $\hh([\loc_n])(x) = 
%(\_, \tsid_1, \mathcal{T})$, and $\tsid_2 \in \mathcal{T}$.
%\end{definition}
%
%\begin{definition}
%Let $\hh$ be a history heap, and $V$ be a view.
%Let $[\loc_x]$ be a location, and let 
%$(\_, \tsid, \_) := \hh([\loc_{n}])(V([\loc_{x}]))$. 
%We say that $V$ respects causality for $[\loc_{x}]$ if, 
%whenever $\tsid' \xrightarrow{\RF([\loc_{x}])}_{\tsid}'$, 
%$\hh([\loc_x])(i)$ as follows: 
%\begin{enumerate}
%\end{definition}

\subsection{Consistent Update}
\begin{figure}
\begin{tabular}{|c|c|}
\hline
\begin{tikzpicture}[font=\large]

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) at (1,3) {$[\loc_x] \mapsto$};

\matrix(locxcells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locx.east) {
 {a} & $T_0$ \\
  {a} & $\emptyset$ \\
};
\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};

%Location y
\path (locx.south) + (0,-1.5) node (locf1) {$[\loc_{f_1}] \mapsto$};
\matrix(locf1cells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locf1.east) {
 {a} & $T_0$ \\
  {a} & $\emptyset$ \\
};
\node[version node, fit=(locf1cells-1-1) (locf1cells-2-1), fill=white, inner sep= 0cm, font=\Large] (locf1-v0) {$0$};

%Location y
\path (locf1.south) + (0,-1.5) node (locf2) {$[\loc_{f_2}] \mapsto$};
\matrix(locf2cells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locf2.east) {
 {a} & $T_0$ \\
  {a} & $\emptyset$ \\
};
\node[version node, fit=(locf2cells-1-1) (locf2cells-2-1), fill=white, inner sep= 0cm, font=\Large] (locf2-v0) {$0$};

% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
 ([xshift=-2pt, yshift=20pt]locx-v0.north east) node (tid1start) {} -- 
% ([xshift=-2pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-2pt, yshift=5pt]locf1-v0.north east) -- 
% ([xshift=-2pt, yshift=-5pt]locf1-v0.south east) --
% ([xshift=-2pt, yshift=5pt]locf2-v0.north east) -- 
 ([xshift=-2pt, yshift=-5pt]locf2-v0.south east);
 
 \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_3$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
 ([xshift=-5pt, yshift=5pt]locx-v0.north east) -- 
% ([xshift=-5pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-5pt, yshift=5pt]locf1-v0.north east) -- 
% ([xshift=-5pt, yshift=-5pt]locf1-v0.south east) --
% ([xshift=-5pt, yshift=5pt]locf2-v0.north east) -- 
 ([xshift=-5pt, yshift=-10pt]locf2-v0.south east) node (tid2start) {};
 
\path (tid2start) node[anchor=north, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\tid_2$};
 
 %green view
\draw[-, DarkGreen, very thick, rounded corners = 10pt]
 ([xshift=-16pt, yshift=8pt]locx-v0.north east) node (tid3start) {}-- 
% ([xshift=-16pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-16pt, yshift=5pt]locf1-v0.north east) -- 
% ([xshift=-16pt, yshift=-5pt]locf1-v0.south east) --
% ([xshift=-16pt, yshift=5pt]locf2-v0.north east) -- 
 ([xshift=-16pt, yshift=-5pt]locf2-v0.south east);
 
 \path (tid3start) node[anchor=south, rectangle, fill=DarkGreen!20, draw=DarkGreen, font=\small, inner sep=1pt] {$\tid_1$};

\end{pgfonlayer}
\end{tikzpicture}
%
&
%
\begin{tikzpicture}[font=\large]

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) at (1,3) {$[\loc_x] \mapsto$};

\matrix(locxcells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locx.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_1$\\
  {a} & $\{\tsid_1\}$ & {a} & $\emptyset$\\
};
\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep= 0cm, font=\Large] (locx-v1) {$1$};

%Location y
\path (locx.south) + (0,-1.5) node (locf1) {$[\loc_{f_1}] \mapsto$};
\matrix(locf1cells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locf1.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_1$\\
  {a} & $\{\tsid_1\}$ & {a} & $\emptyset$\\
};
\node[version node, fit=(locf1cells-1-1) (locf1cells-2-1), fill=white, inner sep= 0cm, font=\Large] (locf1-v0) {$0$};
\node[version node, fit=(locf1cells-1-3) (locf1cells-2-3), fill=white, inner sep= 0cm, font=\Large] (locf1-v1) {$1$};

%Location y
\path (locf1.south) + (0,-1.5) node (locf2) {$[\loc_{f_2}] \mapsto$};
\matrix(locf2cells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locf2.east) {
 {a} & $T_0$ \\
  {a} & $\emptyset$ \\
};
\node[version node, fit=(locf2cells-1-1) (locf2cells-2-1), fill=white, inner sep= 0cm, font=\Large] (locf2-v0) {$0$};

% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
 ([xshift=-2pt, yshift=20pt]locx-v0.north east) node (tid1start) {} -- 
% ([xshift=-2pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-2pt, yshift=5pt]locf1-v0.north east) -- 
% ([xshift=-2pt, yshift=-5pt]locf1-v0.south east) --
% ([xshift=-2pt, yshift=5pt]locf2-v0.north east) -- 
 ([xshift=-2pt, yshift=-5pt]locf2-v0.south east);
 
 \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_3$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
 ([xshift=-5pt, yshift=5pt]locx-v0.north east) -- 
% ([xshift=-5pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-5pt, yshift=5pt]locf1-v0.north east) -- 
% ([xshift=-5pt, yshift=-5pt]locf1-v0.south east) --
% ([xshift=-5pt, yshift=5pt]locf2-v0.north east) -- 
 ([xshift=-5pt, yshift=-10pt]locf2-v0.south east) node (tid2start) {};
 
\path (tid2start) node[anchor=north, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\tid_2$};
 
 %green view
\draw[-, DarkGreen, very thick, rounded corners = 10pt]
 ([xshift=-16pt, yshift=8pt]locx-v1.north east) node (tid3start) {}-- 
% ([xshift=-16pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-16pt, yshift=5pt]locf1-v0.north east) -- 
 ([xshift=-16pt, yshift=-5pt]locf1-v1.south east) --
 ([xshift=-16pt, yshift=5pt]locf2-v0.north east) -- 
 ([xshift=-16pt, yshift=-5pt]locf2-v0.south east);
 
 \path (tid3start) node[anchor=south, rectangle, fill=DarkGreen!20, draw=DarkGreen, font=\small, inner sep=1pt] {$\tid_1$};

\end{pgfonlayer}
\end{tikzpicture}
\\
{\small (a)} & {\small (b)}\\
\hline
\begin{tikzpicture}[font=\large]

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) at (1,3) {$[\loc_x] \mapsto$};

\matrix(locxcells) [version list, column 2/.style = {text width=14mm}, text width=7mm, anchor=west]
   at ([xshift=10pt]locx.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_1$ & {a} & $\tsid_2$\\
  {a} & $\{\tsid_1, \tsid_2\}$ & {a} & $\emptyset$ & {a} & $\emptyset$\\
};
\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep= 0cm, font=\Large] (locx-v1) {$1$};
\node[version node, fit=(locxcells-1-5) (locxcells-2-5), fill=white, inner sep= 0cm, font=\Large] (locx-v2) {$1$};

%Location y
\path (locx.south) + (0,-1.5) node (locf1) {$[\loc_{f_1}] \mapsto$};
\matrix(locf1cells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locf1.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_1$\\
  {a} & $\{\tsid_1\}$ & {a} & $\emptyset$\\
};
\node[version node, fit=(locf1cells-1-1) (locf1cells-2-1), fill=white, inner sep= 0cm, font=\Large] (locf1-v0) {$0$};
\node[version node, fit=(locf1cells-1-3) (locf1cells-2-3), fill=white, inner sep= 0cm, font=\Large] (locf1-v1) {$1$};

%Location y
\path (locf1.south) + (0,-1.5) node (locf2) {$[\loc_{f_2}] \mapsto$};
\matrix(locf2cells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locf2.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_2$\\
  {a} & $\{\tsid_2\}$ & {a} & $\emptyset$ \\
};
\node[version node, fit=(locf2cells-1-1) (locf2cells-2-1), fill=white, inner sep= 0cm, font=\Large] (locf2-v0) {$0$};
\node[version node, fit=(locf2cells-1-3) (locf2cells-2-3), fill=white, inner sep= 0cm, font=\Large] (locf2-v1) {$1$};

% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
 ([xshift=-2pt, yshift=20pt]locx-v0.north east) node (tid1start) {} -- 
% ([xshift=-2pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-2pt, yshift=5pt]locf1-v0.north east) -- 
% ([xshift=-2pt, yshift=-5pt]locf1-v0.south east) --
% ([xshift=-2pt, yshift=5pt]locf2-v0.north east) -- 
 ([xshift=-2pt, yshift=-5pt]locf2-v0.south east);
 
 \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_3$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
 ([xshift=-5pt, yshift=5pt]locx-v2.north east) -- 
 ([xshift=-5pt, yshift=-5pt]locx-v2.south east) --
 ([xshift=-5pt, yshift=5pt]locf1-v0.north east) -- 
 ([xshift=-5pt, yshift=-5pt]locf1-v0.south east) --
 ([xshift=-5pt, yshift=5pt]locf2-v1.north east) -- 
 ([xshift=-5pt, yshift=-10pt]locf2-v1.south east) node (tid2start) {};
 
\path (tid2start) node[anchor=north, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\tid_2$};
 
 %green view
\draw[-, DarkGreen, very thick, rounded corners = 10pt]
 ([xshift=-16pt, yshift=8pt]locx-v1.north east) node (tid3start) {}-- 
 ([xshift=-16pt, yshift=-5pt]locx-v1.south east) --
 ([xshift=-16pt, yshift=5pt]locf1-v1.north east) -- 
 ([xshift=-16pt, yshift=-5pt]locf1-v1.south east) --
 ([xshift=-16pt, yshift=5pt]locf2-v0.north east) -- 
 ([xshift=-16pt, yshift=-5pt]locf2-v0.south east);
 
 \path (tid3start) node[anchor=south, rectangle, fill=DarkGreen!20, draw=DarkGreen, font=\small, inner sep=1pt] {$\tid_1$};

\end{pgfonlayer}
\end{tikzpicture}
%
&
%
\begin{tikzpicture}[font=\large]

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) at (1,3) {$[\loc_x] \mapsto$};

\matrix(locxcells) [version list, column 2/.style = {text width=14mm}, text width=7mm, anchor=west]
   at ([xshift=10pt]locx.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_1$ & {a} & $\tsid_2$\\
  {a} & $\{\tsid_1, \tsid_2\}$ & {a} & $\emptyset$ & {a} & $\emptyset$\\
};
\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep= 0cm, font=\Large] (locx-v1) {$1$};
\node[version node, fit=(locxcells-1-5) (locxcells-2-5), fill=white, inner sep= 0cm, font=\Large] (locx-v2) {$1$};

%Location y
\path (locx.south) + (0,-1.5) node (locf1) {$[\loc_{f_1}] \mapsto$};
\matrix(locf1cells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locf1.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_1$\\
  {a} & $\{\tsid_1\}$ & {a} & $\emptyset$\\
};
\node[version node, fit=(locf1cells-1-1) (locf1cells-2-1), fill=white, inner sep= 0cm, font=\Large] (locf1-v0) {$0$};
\node[version node, fit=(locf1cells-1-3) (locf1cells-2-3), fill=white, inner sep= 0cm, font=\Large] (locf1-v1) {$1$};

%Location y
\path (locf1.south) + (0,-1.5) node (locf2) {$[\loc_{f_2}] \mapsto$};
\matrix(locf2cells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locf2.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_2$\\
  {a} & $\{\tsid_2\}$ & {a} & $\emptyset$ \\
};
\node[version node, fit=(locf2cells-1-1) (locf2cells-2-1), fill=white, inner sep= 0cm, font=\Large] (locf2-v0) {$0$};
\node[version node, fit=(locf2cells-1-3) (locf2cells-2-3), fill=white, inner sep= 0cm, font=\Large] (locf2-v1) {$1$};

% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
 ([xshift=-2pt, yshift=20pt]locx-v2.north east) node (tid1start) {} -- 
 ([xshift=-2pt, yshift=-7pt]locx-v2.south east) --
 ([xshift=-2pt, yshift=3pt]locf1-v1.north east) -- 
 ([xshift=-2pt, yshift=-5pt]locf1-v1.south east) --
 ([xshift=-2pt, yshift=5pt]locf2-v1.north east) -- 
 ([xshift=-2pt, yshift=-5pt]locf2-v1.south east);
 
 \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_3$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
 ([xshift=-5pt, yshift=5pt]locx-v2.north east) -- 
 ([xshift=-5pt, yshift=-5pt]locx-v2.south east) --
 ([xshift=-5pt, yshift=5pt]locf1-v0.north east) -- 
 ([xshift=-5pt, yshift=-5pt]locf1-v0.south east) --
 ([xshift=-5pt, yshift=5pt]locf2-v1.north east) -- 
 ([xshift=-5pt, yshift=-10pt]locf2-v1.south east) node (tid2start) {};
 
\path (tid2start) node[anchor=north, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\tid_2$};
 
 %green view
\draw[-, DarkGreen, very thick, rounded corners = 10pt]
 ([xshift=-16pt, yshift=8pt]locx-v1.north east) node (tid3start) {}-- 
 ([xshift=-16pt, yshift=-5pt]locx-v1.south east) --
 ([xshift=-16pt, yshift=5pt]locf1-v1.north east) -- 
 ([xshift=-16pt, yshift=-5pt]locf1-v1.south east) --
 ([xshift=-16pt, yshift=5pt]locf2-v0.north east) -- 
 ([xshift=-16pt, yshift=-5pt]locf2-v0.south east);
 
 \path (tid3start) node[anchor=south, rectangle, fill=DarkGreen!20, draw=DarkGreen, font=\small, inner sep=1pt] {$\tid_1$};

\end{pgfonlayer}
\end{tikzpicture}\\
{\small (c)} & {\small (d)} \\
\hline
\begin{tikzpicture}[font=\large]

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) at (1,3) {$[\loc_x] \mapsto$};

\matrix(locxcells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locx.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_1$\\
  {a} & $\{\tsid_1\}$ & {a} & $\emptyset$\\
};
\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep= 0cm, font=\Large] (locx-v1) {$1$};

%Location y
\path (locx.south) + (0,-1.5) node (locf1) {$[\loc_{f_1}] \mapsto$};
\matrix(locf1cells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locf1.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_1$\\
  {a} & $\{\tsid_1\}$ & {a} & $\emptyset$\\
};
\node[version node, fit=(locf1cells-1-1) (locf1cells-2-1), fill=white, inner sep= 0cm, font=\Large] (locf1-v0) {$0$};
\node[version node, fit=(locf1cells-1-3) (locf1cells-2-3), fill=white, inner sep= 0cm, font=\Large] (locf1-v1) {$1$};

%Location y
\path (locf1.south) + (0,-1.5) node (locf2) {$[\loc_{f_2}] \mapsto$};
\matrix(locf2cells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locf2.east) {
 {a} & $T_0$ \\
  {a} & $\emptyset$ \\
};
\node[version node, fit=(locf2cells-1-1) (locf2cells-2-1), fill=white, inner sep= 0cm, font=\Large] (locf2-v0) {$0$};

% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
 ([xshift=-2pt, yshift=20pt]locx-v0.north east) node (tid1start) {} -- 
% ([xshift=-2pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-2pt, yshift=5pt]locf1-v0.north east) -- 
% ([xshift=-2pt, yshift=-5pt]locf1-v0.south east) --
% ([xshift=-2pt, yshift=5pt]locf2-v0.north east) -- 
 ([xshift=-2pt, yshift=-5pt]locf2-v0.south east);
 
 \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_3$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
 ([xshift=-5pt, yshift=5pt]locx-v1.north east) -- 
% ([xshift=-5pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-5pt, yshift=5pt]locf1-v0.north east) -- 
 ([xshift=-5pt, yshift=-5pt]locf1-v1.south east) --
 ([xshift=-5pt, yshift=5pt]locf2-v0.north east) -- 
 ([xshift=-5pt, yshift=-10pt]locf2-v0.south east) node (tid2start) {};
 
\path (tid2start) node[anchor=north, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\tid_2$};
 
 %green view
\draw[-, DarkGreen, very thick, rounded corners = 10pt]
 ([xshift=-16pt, yshift=8pt]locx-v1.north east) node (tid3start) {}-- 
% ([xshift=-16pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-16pt, yshift=5pt]locf1-v0.north east) -- 
 ([xshift=-16pt, yshift=-5pt]locf1-v1.south east) --
 ([xshift=-16pt, yshift=5pt]locf2-v0.north east) -- 
 ([xshift=-16pt, yshift=-5pt]locf2-v0.south east);
 
 \path (tid3start) node[anchor=south, rectangle, fill=DarkGreen!20, draw=DarkGreen, font=\small, inner sep=1pt] {$\tid_1$};

\end{pgfonlayer}
\end{tikzpicture}
&
\begin{tikzpicture}[font=\large]

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) at (1,3) {$[\loc_x] \mapsto$};

\matrix(locxcells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locx.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_1$ & {a} & $\tsid_2$\\
  {a} & $\{\tsid_1\}$ & {a} & $\{\tsid_2\}$ & {a} & $\emptyset$\\
};
\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep= 0cm, font=\Large] (locx-v1) {$1$};
\node[version node, fit=(locxcells-1-5) (locxcells-2-5), fill=white, inner sep= 0cm, font=\Large] (locx-v2) {$2$};

%Location y
\path (locx.south) + (0,-1.5) node (locf1) {$[\loc_{f_1}] \mapsto$};
\matrix(locf1cells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locf1.east) {
 {a} & $\tsid_0$ & {a} & $\tsid_1$\\
  {a} & $\{\tsid_1\}$ & {a} & $\emptyset$\\
};
\node[version node, fit=(locf1cells-1-1) (locf1cells-2-1), fill=white, inner sep= 0cm, font=\Large] (locf1-v0) {$0$};
\node[version node, fit=(locf1cells-1-3) (locf1cells-2-3), fill=white, inner sep= 0cm, font=\Large] (locf1-v1) {$1$};

%Location y
\path (locf1.south) + (0,-1.5) node (locf2) {$[\loc_{f_2}] \mapsto$};
\matrix(locf2cells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locf2.east) {
 {a} & $T_0$ & {a} & $\tsid_2$\\
  {a} & $\emptyset$ & {a} & $\emptyset$ \\
};
\node[version node, fit=(locf2cells-1-1) (locf2cells-2-1), fill=white, inner sep= 0cm, font=\Large] (locf2-v0) {$0$};
\node[version node, fit=(locf2cells-1-3) (locf2cells-2-3), fill=white, inner sep= 0cm, font=\Large] (locf2-v1) {$1$};

% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
 ([xshift=-2pt, yshift=20pt]locx-v0.north east) node (tid1start) {} -- 
% ([xshift=-2pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-2pt, yshift=5pt]locf1-v0.north east) -- 
% ([xshift=-2pt, yshift=-5pt]locf1-v0.south east) --
% ([xshift=-2pt, yshift=5pt]locf2-v0.north east) -- 
 ([xshift=-2pt, yshift=-5pt]locf2-v0.south east);
 
 \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_3$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
 ([xshift=-5pt, yshift=5pt]locx-v2.north east) -- 
 ([xshift=-5pt, yshift=-5pt]locx-v2.south east) --
 ([xshift=-5pt, yshift=5pt]locf1-v1.north east) -- 
% ([xshift=-5pt, yshift=-5pt]locf1-v0.south east) --
% ([xshift=-5pt, yshift=5pt]locf2-v0.north east) -- 
 ([xshift=-5pt, yshift=-10pt]locf2-v1.south east) node (tid2start) {};
 
\path (tid2start) node[anchor=north, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\tid_2$};
 
 %green view
\draw[-, DarkGreen, very thick, rounded corners = 10pt]
 ([xshift=-16pt, yshift=8pt]locx-v1.north east) node (tid3start) {}-- 
% ([xshift=-16pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-16pt, yshift=5pt]locf1-v0.north east) -- 
 ([xshift=-16pt, yshift=-5pt]locf1-v1.south east) --
 ([xshift=-16pt, yshift=5pt]locf2-v0.north east) -- 
 ([xshift=-16pt, yshift=-5pt]locf2-v0.south east);
 
 \path (tid3start) node[anchor=south, rectangle, fill=DarkGreen!20, draw=DarkGreen, font=\small, inner sep=1pt] {$\tid_1$};

\end{pgfonlayer}
\end{tikzpicture}\\
{\small(e)} & {\small(f)}\\
\hline
\end{tabular}
\caption{History heaps obtained in a execution of $\prog_3$.}
\label{fig:cu.exec}
\end{figure}
\ac{This Consistency Model shows why the notion of consistent views must 
depend on the set of operations that need to be executed.}

The next consistency model that we consider is \emph{Consistent Update}. 
Although this model has not been implemented, it has been proposed in 
\cite{framework-concur} as a strengthening to Read Atomic to avoid 
conflicts. The informal specification of Consistent Update states that 
\textbf{(i)} transactions enjoy atomic visibility, and \textbf{(ii)} 
transactions writing to one same location cannot execute concurrently.
\ac{Check: Nobi said he was interested in implementing Consistent Update 
at some point, maybe he ended up doing something.}

Programs executing under Consistent Update do not exhibit the \emph{lost update} 
anomaly: two or more transactions update one location (for example, by incrementing it by $1$), 
but only the effects of one of them (for example, only one of the increments) will 
be observed by future transactions.

To illustrate how the lost update anomaly can arise in practice, 
consider the following program:
\[
    \prog_3 := \begin{session}
        \begin{array}{@{}c || c || c@{}}
            \begin{transaction}
               \pmutate{\loc_{f_1}}{1};\\
                  \pderef{\pvar{a}}{\loc_x};\\
            		  \pmutate{\loc_x}{a + 1};\\
              \end{transaction} & 
              \begin{transaction}
                  \pmutate{\loc_{f_2}}{1};\\
            		  \pderef{\pvar{a}}{\loc_x};\\
            		  \pmutate{\loc_x}{a + 1};\\
            	  \end{transaction} &
              \begin{transaction}
            		   \pderef{\pvar{a}}{\loc_{f_1}};\\
            		   \pderef{\pvar{b}}{\loc_{f_2}};\\
            		   \pderef{\pvar{c}}{\loc_{x}};\\
            		   \pifs{\pvar{a}=1 \wedge \pvar{b}=1 \wedge \pvar{b} = 1}\\
            				\;\;\;\;\passign{\retvar}{\Large \frownie{}}
            			\}
             \end{transaction}
        \end{array}
    \end{session}
 \]
\ac{Intuitive behaviour of the litmus test: two transactions concurrently increment $x$. 
 A third transaction observes that the first two transactions have been executed. 
 However, it only observes one of the two increments taking place.
 }
We consider an execution in which the transactions contained in the code of threads 
$\tid_1, \tid_2$ both execute w.r.t. the snapshot determined by the initial view. 
Initially, the configuration of the program coincides with the one given in 
Figure \ref{fig:cu.exec}(a). After executing the transaction of $\tid_1$, the resulting 
configuration is the one depicted in Figure \ref{fig:cu.exec}(b). Next, after $\tid_2$ executed 
its own transaction, we obtain the configuration in \ref{fig:cu.exec}(c). Note that 
in this configuration, both transactions $\tsid_1, \tsid_2$ read the initial version 
for location $[\loc_x]$. Finally, thread $\tid_3$ updates its view to include the most recent 
version for all the locations $[\loc_x], [\loc_{f_1}], [\loc_{f_2}]$. When executing the 
transaction in its code, all the locations will be found to have value $1$, and 
the return variable will be set to ${\Large \frownie{}}$.

The reason why the program $\prog_3$ exhibited the lost-update anomaly is 
that the transaction of $\tid_2$ executed using a snapshot obtained from 
a view which did not include the most up-to-date version for location $[\loc_x]$. 
However, the same transaction installed a new version for $[\loc_x]$. That is, 
it \emph{lost the update} of the version installed by the transaction executed 
by $\tid_1$. To forbid this anomaly, we require that if a transaction 
writes to some location $[\loc_x]$, then it must have been executed 
in a snapshot obtained from a view including the most recent version of 
$[\loc_x]$.

\begin{definition}
$(\hh, V, \mathcal{V}) \triangleright_{\mathsf{CU}} \mathcal{O}$ iff 
$(\hh, V, \mathcal{V}) \triangleright_{\mathsf{RA}} \mathcal{O}$, and 
for all locations $[\loc_x]$ such that $(\WR\; [\loc_x] : \_ \in \mathcal{O})$ 
then $V([\loc_{x}]) = \lvert \hh([\loc_x]) \rvert - 1$. 
\end{definition}

Note that in $prog_3$, under $\mathsf{CU}$, 
we cannot execute the transaction of $\tid_2$ starting from 
the configuration depicted in Figure \ref{fig:cu.exec}(b). This 
is because the view of $\tid_2$, in such a configuration, does 
not include the most recent version for location $[\loc_x]$. 
Instead, before executing its transaction $\tid_2$ must update 
its view to include the most recent version of $[\loc_x]$. The 
resulting configuration is depicted in Figure \ref{fig:cu.exec}(e). 
After executing its transaction using the snapshot obtained 
from the view of $\tid_2$ in this configuration, the resulting 
configuration is the one obtained in Figure \ref{fig:cu.exec}(f). 
There are now three different possible configurations in which 
$\tid_3$ can execute its transaction: 
\begin{itemize}
\item the initial one, in which case the value $0$ will be observed 
for the three locations $[\loc_x], [\loc_{f1}]$ and $[\loc_{f_2}]$. 
In this case the transaction will not return value ${\Large \frownie{}}$, 
\item one in which the view of $\tid_3$ for $[\loc_x]$ points to the 
version $(1, \tsid_1, \{\tsid_2\})$. Because of atomic visibility, 
it must also be the case that the same view for location $[\loc_{f_2}]$ 
does not include the update performed by $\tsid_2$ (otherwise, 
the view for $[\loc_x]$ should point to its most recent version, which 
was also installed by $\tsid_2$. Thus in this case the transaction executes 
w.r.t a snapshot where $\loc_{f_2} = 0$, and the value ${\Large \frownie{}}$ 
will not be returned, 
\item one in which the view of $\tid_3$ for $[\loc_x]$ points to 
its most recent version $(2, \tsid_2, \emptyset)$; also in this case, 
the value ${\Large \frownie{}}$ will not be returned from the transaction.
\end{itemize}


\subsection{Consistent Prefix} 
The next consistency model that we illustrate is given 
by consistent prefix. In this model, transactions cannot 
observe updates to differ locations in different order. 

In theory, one such situation could arise in the following program:
 \[
    \prog_4 := \begin{session}
        \begin{array}{@{}c || c @{}}
            \begin{transaction}
                \pmutate{\loc_{x}}{1};\\
            \end{transaction} \\
            
            \begin{transaction}
              	\pderef{\pvar{a}}{\loc_{y}};\\
              	\pifs{\pvar{a}=0}\\
              		\;\;\;\;\passign{\retvar}{\Large \frownie{}} \};
            \end{transaction}
              &
           \begin{transaction}
                \pmutate{\loc_{y}}{1};\\
            \end{transaction} \\
            
            \begin{transaction}
              	\pderef{\pvar{a}}{\loc_{x}};\\
              	\pifs{\pvar{a}=0}\\
              		\;\;\;\;\passign{\retvar}{\Large \frownie{}} \};
            \end{transaction}
        \end{array}
    \end{session}
 \]


\begin{definition}
$(\hh, V, \mathcal{V}) \triangleright_{\mathsf{CP}} \mathcal{O}$ iff 
$(\hh, V, \mathcal{V}) \triangleright_{\mathsf{RA}} \mathcal{O}$, 
and for any $V' \in \mathcal{V}$, either $V' \sqsubseteq V$ or 
$V \sqsubseteq V'$.
\end{definition}
\ac{I found that this is a very easy way to encode consistent 
prefix. In English, a thread can execute a transaction if its view does 
not cross with the views of any other thread.}

\ac{Very Important - note to self: It seems that the condition of 
requiring that views do not cross before executing a transaction 
does not suffice to model snapshot isolation. In fact, it seems that 
consistent prefix (when transaction are limited to either one read 
or one write) coincides with TSO.
Update, it seems that the condition that I need for Snapshot Isolation 
(besides write confict detection) is that, after you execute a transaction, 
you bring your view up-to-date. (So here I have to concede that I was wrong, 
and the state of the view after you execute a transaction is actually important).\\

}


\subsection{Parallel Snapshot Isolation and Snapshot Isolation}
\begin{definition}
$\mathsf{PSI} = \mathsf{CC} \cap \mathsf{CU}$. \\
$\mathsf{SI} = \mathsf{CP} \cap \mathsf{CU}$.
\end{definition}

\subsection{Serialisability}

\begin{definition}
$(\hh, V,  \_) \triangleright \_$ iff for any location $[\loc_x]$, 
$V([\loc_x]) = \lvert \hh([\loc_x]) \rvert -1$. 
\end{definition}

\ac{Contents: Read Atomic, Causal Consistency, Update Atomic, Consistent Prefix, Parallel Snapshot Isolation, Snapshot Isolation, 
Serializability. Well-formedness constraint to be placed on consistency models: progress must always be possible - i.e. it is 
always possible to execute a transaction if the view of all threads are up-to-date.}  