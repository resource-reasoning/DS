\documentclass[a4paper,UKenglish]{article}%This is a template for producing LIPIcs articles. 

\input{env.tex}
\usepackage{hhmacros}
\usepackage{wasysym}
%\usepackage{hheapdraw}




 
\usepackage{microtype}%if unwanted, comment out or use option "draft"
%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

%\bibliographystyle{plainurl}% the recommended bibstyle

%\usepackage[a4paper]{geometry}
%\usepackage[letterpaper,left=2.4cm,right=2.4cm,top=2.4cm,bottom=2.4cm]{geometry}

\usepackage{opsem}

\usepackage{etex}

%\usepackage{stackengine}

\usepackage{authblk}



%%%%%%%%%%%%%%%%%%%%%% edit mode
\newif\iflong
\longfalse  % uncomment for short version
%\longtrue  % uncomment for long version

\newif\ifdraft
%\draftfalse %uncomment for deleting notes
\drafttrue %uncomment for showing notes

%\newif\ifEditing
%\Editingtrue
%\ifEditing
%    \linenumbers
%\fi

\newif\ifComments
\Commentstrue
\input{comment-box.tex}
%%%%%%%%%%%%%%%%%%%%%% end edit mode

\newcommand{\tr}[2]{\iflong{}\S#1\else{}\cite[\S{}#2]{ext}\fi}
\newcommand{\tra}[2]{\iflong{}(\S#1)\else{}\cite[\S{}#2]{ext}\fi}

\newcommand{\nanomalies}{A}
\newcommand{\ngeneral}{B}
\newcommand{\nproofs}{C}
\newcommand{\ncompleteness}{D}

%\renewcommand{\ttdefault}{cmtt}
%\renewcommand{\sfdefault}{cmss}

\newcommand{\cross}{\ding{56}}


%\renewcommand{\rmdefault}{ptm}

\renewcommand{\O}{\mathcal{O}}

\newcommand{\theproof}{{\noindent\hskip\labelsep
        \color{darkgray}\sffamily\bfseries \proofname.}}
        
\newcommand{\myparagraph}[1]{\textbf{\color{darkgray}\sffamily#1.}}
\newcommand{\newtext}[1]{{\color{red}{\bf #1}}}
\newcommand{\dfont}[1]{{\bf\em #1}}
% comments


\usepackage{pifont}
\usepackage[frame,all]{xy}
\usepackage{nicefrac}
\usepackage{executions}
\usepackage{execgraphs}

\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{proof}

\DeclareMathAlphabet{\mathpzc}{OT1}{pzc}{m}{it}

%\usepackage{mathtools}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Packages above %%%%%%%%%%%%%%%%%%%%%%%


\theoremstyle{plain}

%\newcommand{\qed}{$\Box$}
%\newenvironment{proof}{\begin{trivlist}
%\item[\hskip\labelsep{\sc Proof.}]}
%{$\hfill\Box$\end{trivlist}}
\newenvironment{sketch}{\begin{trivlist}
\item[\hskip\labelsep{\sc Proof sketch.}]}
{$\hfill\Box$\end{trivlist}}
\newenvironment{scheme}{\begin{trivlist}
\item[\hskip\labelsep{\sc Proof scheme.}]}
{$\hfill\Box$\end{trivlist}}


%\newcommand{\account}{\ensuremath{\mathsf{acct}}}
%\newcommand{\emptytxt}{{\ensuremath{\mathsf{empty}}}}
%\newcommand{\post}{\ensuremath{\mathsf{post}}}
%\newcommand{\comment}{\ensuremath{\mathsf{comment}}}

%\def\qed{\ifmmode\squareforqed\else{\unskip\nobreak\hfil
%\penalty50\hskip1em\null\nobreak\hfil\squareforqed
%\parfillskip=0pt\finalhyphendemerits=0\endgraf}\fi}


\newcommand{\leaveout}[1]{}

\newcommand\Tstrut{\rule{0pt}{3.5ex}}         % = `top' strut
\newcommand\Bstrut{\\[3pt]}   % = `bottom' strut

%usepackage{paralist}
%\setdefaultleftmargin{10pt}{}{}{}{}{}
%\setlength{\topsep}{3pt}
%\setlength{\itemsep}{2pt}
% \setlength{\partopsep}{0pt}
% \setlength{\parsep}{0pt}
%\setlength{\parskip}{0pt}

\newenvironment{subitemize}{
\begin{itemize}
 \setlength{\topsep}{0pt}
  \setlength{\itemsep}{0pt}
  \setlength{\parskip}{0pt}
}{\end{itemize}}

\multlinegap=3pt
\setlength{\jot}{2pt}
\newcommand{\ms}{\\[2pt]}

%
\setlength{\floatsep}{10pt plus 6pt minus 2pt}
\setlength{\textfloatsep}{10pt plus 6pt minus 3pt}
\setlength{\intextsep}{10pt plus 6pt minus 3pt}
\setlength{\dblfloatsep}{18pt plus 4pt minus 2pt}
\setlength{\dbltextfloatsep}{20pt plus 4pt minus 3pt}

\newenvironment{mywrapfigure}[3][]{
  \floatstyle{boxed}
  \restylefloat{figure}
  \wrapfigure[#1]{#2}{#3}}
  {\endwrapfigure
    \floatstyle{ruled}
    \restylefloat{figure}
    }
    

% \setlength{\floatsep}{18pt plus 4pt minus 2pt}
% \setlength{\textfloatsep}{18pt plus 4pt minus 3pt}
% \setlength{\intextsep}{10pt plus 4pt minus 3pt}
% \setlength{\dblfloatsep}{18pt plus 4pt minus 2pt}
% \setlength{\dbltextfloatsep}{20pt plus 4pt minus 3pt}
%
%\makeatletter
%\renewcommand{\section}{\@startsection{section}{1}{0pt}%
%{-3ex plus -1ex minus -.2ex}{1.5ex plus.2ex}%
%{\normalfont\large\bfseries}}
%\renewcommand{\subsection}{\@startsection{subsection}{1}{0pt}%
%{-2ex plus -1ex minus -.2ex}{1ex plus.2ex}%
%{\bfseries}}
%\def \@begintheorem #1#2{%                      {name}{number}
%  \trivlist
%  \item[\hskip \labelsep \textbf{#1 #2.}]%
%  \itshape\selectfont
%  \ignorespaces}
%\newcommand{\nut}{\hspace{.35em}}
%\def \@opargbegintheorem #1#2#3{%               {name}{number}{title}
%  \trivlist
%  \item[%
%    \hskip\labelsep \textsc{#1\ #2}\nut (#3).]%
%  \itshape\selectfont
%  \ignorespaces}
%
%\def\@listI{\leftmargin\leftmargini
%            \parsep 0\p@ \@plus1\p@ \@minus\p@
%            \topsep 6\p@ \@plus2\p@ \@minus0\p@
%            \itemsep 0\p@}
%\let\@listi\@listI
%\@listi
%
%\makeatother
%
%\sloppy

%Labels for groups of inequations
\newcommand{\txlaws}{{\textbf{(a)}}}
\newcommand{\deplaws}{{\textbf{(b)}}}
\newcommand{\allexeclaws}{{\textbf{(c)}}}
\newcommand{\cmexeclaws}{{\textbf{(d)}}}

%Labels for individual inequations
\newcommand{\txId}{{\textbf{(a.1)}}}
\newcommand{\txComp}{{\textbf{(a.2)}}}
\newcommand{\txCap}{{\textbf{(a.5)}}}
\newcommand{\txCup}{{\textbf{(a.6)}}}
\newcommand{\txDistrR}{{\textbf{(a.3)}}}
\newcommand{\txDistrL}{{\textbf{(a.4)}}}
%
\newcommand{\depWRTx}{{\textbf{(b.1)}}}
\newcommand{\depWWTx}{{\textbf{(b.2)}}}
\newcommand{\depRWTx}{{\textbf{(b.3)}}}
\newcommand{\depWRIrrefl}{{\textbf{(b.4)}}}
\newcommand{\depWWIrrefl}{{\textbf{(b.5)}}}
\newcommand{\depRWIrrefl}{{\textbf{(b.6)}}}
%
\newcommand{\ARtrans}{{\textbf{(c.5)}}}
\newcommand{\VIStrans}{{\textbf{(c.4)}}}
\newcommand{\VISinAR}{{\textbf{(c.6)}}}
\newcommand{\ARirrefl}{{\textbf{(c.12)}}}
\newcommand{\VISnotAVIS}{{\textbf{(c.11)}}}
\newcommand{\POinVIS}{{\textbf{(c.0)}}}
\newcommand{\WRinVIS}{{\textbf{(c.1)}}}
\newcommand{\WWinAR}{{\textbf{(c.2)}}}
\newcommand{\LWW}{{\textbf{(c.7)}}}
\newcommand{\RWinAVIS}{{\textbf{(c.3)}}}
\newcommand{\AVISright}{{\textbf{(c.8)}}}
\newcommand{\AVISleft}{{\textbf{(c.9)}}}
\newcommand{\AVISnotVIS}{{\textbf{(c.10)}}}
\newcommand{\CompIrrefl}{{\textbf{(c.13)}}}
%
\newcommand{\Axiom}{{\textbf{(d.1)}}}
\newcommand{\CoAxiomAR}{{\textbf{(d.2)}}}
\newcommand{\CoAxiomL}{{\textbf{(d.3)}}}
\newcommand{\CoAxiomR}{{\textbf{(d.4)}}}

\newcommand{\Spo}{\text{(V0)}}
\newcommand{\Srf}{\text{(V1)}}
\newcommand{\Sconflict}{\text{(V3)}}
\newcommand{\SvisTrans}{\text{(V2)}}
\newcommand{\Saxiom}{\text{(V4)}}
\newcommand{\Svo}{\text{(A1)}}
\newcommand{\Svis}{\text{(A2)}}
\newcommand{\SarTrans}{\text{(A4)}}
\newcommand{\Scoaxiom}{\text{(A5)}}
\newcommand{\Sext}{\text{(A3)}}
\newcommand{\Sad}{\text{(N1)}}
\newcommand{\SavisL}{\text{(N2)}}
\newcommand{\SavisR}{\text{(N3)}}

\newcommand{\palette}{\ensuremath{\mathop{\raisebox{-4pt}{\includegraphics[scale=0.02]{palette.png}}}}}
\newcommand{\gspec}{\ensuremath{\mathsf{gSpec}}}

% Author macros:begin %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\iflong
\title{Specification, Verification and Program Correctness of Transactional Consistency Models using History Heaps}
%\titlerunning{History Heaps} %optional, in case that the title is too long; the running title should fit into the top page column
\else
\title{Specification, Verification and Program Correctness of Transactional Consistency Models using History Heaps}
\fi

%% Please provide for each author the \author and \affil macro, even when authors have the same affiliation, i.e. for each author there needs to be the  \author and \affil macros
\iflong

\author[1]{Shale Xiong, Andrea Cerone, Philippa Gardner}
\author[2]{Azalea Raad}
\affil[1]{Imperial College London, UK}
\affil[2]{MPI KaiserSlautern}
%\authorrunning{A. Cerone} %mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et. al.'
\else

\author[1]{Shale Xiong}
\author[1]{Andrea Cerone}
\author[2]{Azalea Raad}
\author[1]{Philippa Gardner}
\affil[1]{Imperial College London, UK}
\affil[2]{MPI Kaiserslautern}
\fi

\begin{document}
\maketitle
\begin{abstract}
Contents of this set of notes: 
History heaps. Semantics of Programs 
running under weak consistency models using history heaps as states. 
Simulation technique for comparing weak consistency models defined using 
history heaps. Verification of implementations.
\textbf{Points following Dagstuhl: Viktor seemed positive about the 
history heap work. His question was whether the framework is generic 
enough to capture the protocols that they are developing with Azalea. 
Alexey's opinion is that the framework may have some use if we 
manage to prove implementations of protocols correct. 
I would also like to have Azalea's opinion on a semantics based 
on history heaps.}

%{\color{red} \textbf{I AM CURRENTLY EDITING THIS DOCUMENT. 
%DO NOT TOUCH THIS FILE UNTIL I SAY SO!!!}}
\end{abstract}

\section{Computational Model}
We focus on a computational model where multi-threaded programs can access and update 
locations in a centralised heap using atomic transactions. Transactions in our model execute atomically, 
though the consistency guarantees that they provide do not necessarily correspond to \emph{serialisability}. 
This means that, at the moment of executing, a transaction may not observe the most up-to-date value 
of a location. 

To overcome this issue, we model the state of the system using \emph{history heaps}. A 
history heap keeps track of all the versions written for any location, as well as the information 
about the transactions that read and wrote such versions. History heaps are defined formally later in 
the paper.

When executing, a transaction extracts a heap by selecting a version for each 
object in the database. The heap extracted in this way takes the name of the 
\emph{snapshot} of the transaction. In general ,the process of determining 
a snapshot for a transaction is non-deterministic.
A heap $\h \in \Heaps$ consists of a partial function 
from a set of addresses $\Addr \defeq \Setcon{ [\nat] }{\nat \in \Nat }$ to values in $ \val \in \Val \defeq \Nat \cup \Addr$. 
The set of all heaps is denoted by $\Heaps$.
Each thread has its own stack, 
where data for performing local computations is stored. Transactions also 
have a transaction-local stack. 
The set of thread-local stack variables is denoted by $\ThreadVars \defeq \{\pvar{x}, \pvar{y}, \cdots\}$, 
while the set of transaction local variables is denoted by $\TxVars \defeq \{\pvar{a}, \pvar{b}, \cdots\}$. 
We use $\ThdStacks$ to range over thread-local stacks in the set $\ThdStacks \defeq \ThreadVars \to \Val$, 
and $\TxStacks$ to range over transaction-local stacks in the set $\TxStacks \defeq \TxVars \to \Val$.
%\ac{We had some discussion on whether separating the thread-local and transaction-local stack made sense. 
%If you see tranaction code the same as method invocations, this assumption reflects what happens 
%in standard imperative programming languages (i.e. C): transaction-local variables are the local variables 
%of a method, thread-local variables are global variables. A method can read from the global variables. 
%The local variables of a method cannot be accessed outside of the method execution.
%From the technical point of view, having a single thread-local stack won't make too much of a difference, 
%as concurrent access to stack locations can never happen. So we can change it, if needed.}
%\ac{I am wondering whether it makes sense to allow threads to communicate using shared 
%variables outside of the database. In The context of concurrent data structures, this affects 
%the characterisation of contextual refinement (from sequential consistency to linearisability). 
%But in this case transactions are meant to execute atomically, whereas in concurrent 
%library semantics interleavings of method executions are possible.}

The transaction-local stack is created at the moment a transaction starts, 
and is destroyed at the moment it commits. 
Transactions can read from, but cannot 
write to, the thread-local stack. This assumption makes it possible to abstract from 
aborting transactions, as these would have no side-effects in the computational model described. 
We assume that each transaction-local 
stack has a special variable that is used to store the value returned by the transaction 
upon commit. Each thread-local stack also comes equipped with a special return variable, 
where the contents of the value returned by transactions are stored. We use the symbol 
$\retvar$ to denote the special return variable, both in transaction-local and thread-local 
stacks.
%\sx{
%    Not sure about the ret var, 
%    how to transfer the ret var from tx stack to thread stack as 
%    we cannot modify the thread stack.
%}
%\ac{That can be done as part of the program semantics, executing 
%a transaction modifies the ret value of the semantics. This is 
%also what happens in real program executions, by pushing/popping the return value into 
%the execution stack.}
We leave the consistency model of the transactional memory unspecified. The rules 
of our operational semantics will be parametric in the specification of a consistency 
model, using a novel style of specification that we will present later in the paper. 

\paragraph{\textbf{Syntax of Programs}}
We assume a set of (primitive) transactional commands $\primt,\primt',\cdots$, which 
we leave unspecified. Each transactional command $t$ is associated to a \emph{state transformer} 
$\mathcal{S}_t \subseteq (\ThdStacks \times \TxStacks \times \Heaps) \times (\TxStacks \times \Heaps)$. 
\ac{This is slightly confusing: from the point of view of programs, the heap does not change 
while a transaction is executing.}
We use the notation $(\thdstack, \txstack, \heap) \toT{t} (\txstack' , \heap')$ 
in lieu of $((\thdstack, \txstack, \h), (\txstack', \h' )) \in \mathcal{S}_t$. Note that this definition ensures 
that primitive transactional commands cannot update the thread-local stack.
We also assume a set of primitive (non-transactional) commands $\primc, \primc',\cdots$ 
that can be executed by a command outside transactions. Each primitive non-transactional 
command $\primc$ is associated with a state transformer $\mathcal{S}_c \subseteq 
(\ThdStacks \times \ThdStacks)$, and again we adopt the notation $\thdstack \toT{c} 
\thdstack'$ in lieu of $(\thdstack, \thdstack') \in \mathcal{S}_c$. This definition ensures that 
thread-local primitive commands do not access neither the transaction-local stack, nor the heap.

Often, we will assume a language of expressions at the base of primitive (transactional and non-transactional) 
commands. This language is defined by the grammar below: 
\[
\begin{rclarray}
\expr & ::= & \val \bor \pvar{x} \bor \pvar{a} \bor \expr + \expr \bor \expr \cdot \expr \bor \cdots
\end{rclarray}
\]
The set of all expressions is denoted by $\Expr$.
Because non-transactional commands cannot access the transaction-local stack, we will 
need the following, inductively defined, predicate: 
\[
\begin{rclarray}
\isthdexp(\val) &=& \ttrue\\
\isthdexp(\pvar{x}) &=& \ttrue\\
\isthdexp(\pvar{a}) &=& \ffalse\\
\isthdexp(\expr_1 + \expr_2) &=& \isthdexp(\expr_1) \wedge \isthdexp(\expr_2)\\
\vdots & \vdots & \vdots
\end{rclarray}
\]
In general, if the language of expressions contains an operator $\func{f}{\expr_1, \cdots, \expr_n}$, 
where $n \geq 1$, we define $\isthdexp(\func{f}{\expr_1, \cdots, \expr_n}) = \bigwedge_{i=1,\cdots,n} \isthdexp(\expr_i)$.
%\ac{Subtle error here: for $f$ with arity $0$, then $\isthdexp(f) = \ttrue$. But now I can interpret 
%$\interpr{\mathtt{f}} = \lambda \thdstack. \lambda \txstack. \txstack(\pvar{a})$, for some $\pvar{a} \in 
%\TxVars$, thus allowing the access of transaction-local variables within thread-local commands. Boolean predicate must 
%be  fixed.}

The set of primitive commands we will use is given by 
\[
\begin{rclarray}
\primc &::=& \passign{\pvar{x}}{\expr} \mid \assume(\expr) \\
\primt &::=& \passign{\pvar{a}}{\expr} \mid \pmutate{\expr}{\expr} \mid  \pderef{\pvar{a}}{\expr} \mid \assume(\expr)
\end{rclarray}
\]
where in the right-hand sides of the $\primc$ clause we always require that $\isthdexp(\expr) = \ttrue$.

Below we define the syntax of programs allowed by our language. 

\[
\begin{rclarray}
\prog & ::= & \tid: \cmd \Par \prog \Par \prog \\
\cmd & ::= & \nil \mid X \mid \pi.\cmd \mid \cmd + \cmd \mid \mu X.\cmd \\
\pi  & ::= & \primc \mid \ptrans{\trans} \\
\trans  & ::= & \nil \mid X \mid \primt.\trans \mid \trans + \trans \mid  \mu X. \trans \\
\end{rclarray}
\]
%\sx{what is the different between . and \(\pseq\) , \ie \( t \mid \trans \pseq \trans \mid \dots \).  }
%\ac{The mathematical structure that defines syntactically correct programs is different. In particular, if you 
%want to prove a property of a program, by induction on the syntax of that program, you have two 
%different inductive principles, whether your syntax allows $\primc. \cmd$ or $\cmd_1 \pseq \cmd_2$.}

A program corresponds therefore to a set of commands executing in parallel. 
Each command in a command is annotated with a thread identifier $\tid$. 
\ac{Following a discussion on the semantics, nobody likes thread identifiers. It 
may simply be the case that we model a program as a set of commands, each of 
which is augmented with a history heap and the view on such history heaps.}
%Note that each command is annotated with a component $V$, called a \emph{view} which we 
%have purposely left unexplained. At an intuitive level, in a program of the form 
%$V : \cmd \Par \prog$, the view $V$ specifies the version that the command $C$ observes, 
%for each location. Views are described formally when introducing the operational semantics of 
%commands.
%
%Note that each thread has a unique thread identifier $\tid$ associated. The set 
%of all thread identifiers is $\tidset$.

\section{Interpretation of Expressions and Primitive Commands}
Expressions are going to be evaluated in values from $\mathbb{N}$ in the usual way. 
Note that we need to account for the fact that we have two different notions of 
stacks, one transaction-local, and the other thread-local. 
\ac{We agreed to ditch the transaction-local stack. This will change in future versions.}
\[
\begin{rclarray}
\interpr{\cdot}(.)(.) &:& \Expr \times \ThdStacks \times \TxStacks \to \mathbb{N}\\
\interpr{\val}(\thdstack)(\txstack) & \defeq & \val \\
\interpr{\mathtt{x}}(\thdstack)(\txstack) & \defeq & \thdstack(\mathtt{x})\\
\interpr{\mathtt{a}}(\thdstack)(\txstack) & \defeq & \txstack(\mathtt{a})\\
\interpr{E_1 + E_2}(\thdstack)(\txstack) & \defeq & \interpr{E_1}(\thdstack)(\txstack) + \interpr{E_2}(\thdstack)(\txstack)\\
\vdots & \defeq  & \vdots
\end{rclarray}
\]

Note that, for any expression $\expr$ such that $\isthdexp(\expr) = \ttrue$, we have 
that $\interpr{\expr}(\thdstack)(\txstack) = \interpr{\expr}(\thdstack)(\txstack')$ for 
any $\txstack, \txstack' \in \TxStacks$ and $\thdstack \in \ThdStacks$. 
In this case, we commit an abuse of notation and write $\interpr{\expr}(\thdstack)$ 
as a shorthand for $\interpr{\expr}(\thdstack)(\txstack_0)$, where $\txstack_0 = 
\lambda \mathtt{a} .0$.

%\sx{ why \( \txstack_0 = \lambda \mathtt{a} .0\) instead of any? I guess any is also ok. }
%\ac{ Standard initialisation value. Many programming languages use $0$ as a default value 
%for variables upon initialisation.}

We now proceed to define the state transformers associated to transactional and non-transactional primitive commands. 
For transactional primitive commands we have  
\[
\begin{rclarray}
(\thdstack, \txstack, \h) &\toT{\passign{\pvar{a}}{\expr}}& (\txstack\rmto{\pvar{a}}{\interpr{\expr}(\thdstack)(\txstack)}, \h)\\
(\thdstack, \txstack, \h) &\toT{\pderef{\pvar{a}}{\expr}}& (\txstack\rmto{\pvar{a}}{\h(\interpr{\expr}(\thdstack)(\txstack))}, \h)\\
(\thdstack, \txstack, \h) &\toT{\pmutate{\expr_{1}}{\expr_{2}}}& (\txstack, \h\rmto{\interpr{\expr_{1}}(\thdstack)(\txstack)}{\interpr{\expr}(\thdstack)(\txstack)})\\
(\thdstack, \txstack, \heap) &\toT{\assume(\expr)} & (\thdstack,\heap) \  \text{where} \  \interpr{E}(\thdstack)(\txstack) \neq 0 \\
\end{rclarray}
\]
For non-transactional primitive commands we have 
\[
\begin{rclarray}
\thdstack & \toC{\passign{\pvar{x}}{\expr}} & \thdstack\rmto{\pvar{x}}{\interpr{\expr}(\thdstack)} \  \text{where} \  \isthdexp(\expr) = \ttrue\\
\thdstack & \toC{\assume(E)} & \thdstack \ \text{where} \ \isthdexp(\expr) = \ttrue \land \interpr{\expr}(\thdstack) \neq 0
\end{rclarray}
\]

For some transactional primitive command $t$, we also defined its fingerprint, 
which denotes the contribution of the primitive command $t$ in terms of operations that may be 
potentially observed by the external environment (i.e. other transactions). 
Formally, we assume a set of operations $\Op$ that we leave unspecified, aside the fact that 
we require that $\Op \supseteq \Setcon{ \varepsilon, \RD\;[\nat] :\val, \WR\;\addr :\val }{[\nat] \in \Addr \land \val \in \Val }$. 
Here $\varepsilon$ denotes the \emph{empty operation}, that is one that does not read, nor write from the shared state.
We assume a function  $\fingerprint : \cmd \times \ThdStacks \times \TxStacks \times \Heaps \to \Op$. 
This denotes the kind of operation that is performed by  $t$. 
\[
\begin{array}{lclr}
\fingerprint(\passign{\pvar{a}}{\expr}, \stub, \stub, \stub) & \defeq & \varepsilon & \\
\fingerprint(\pderef{\pvar{a}}{\expr},\thdstack,\txstack,\h) & \defeq  & \RD\; [n] : h([n]) & \text{where } n := \interpr{\expr}(\thdstack)(\txstack)\\
\fingerprint(\pmutate{\expr_{1}}{\expr_{2}},\thdstack,\txstack,\heap) & \defeq & \WR\; [n_1] : n_2 & \text{where } n_i := \interpr{\expr_i}(\thdstack)(\txstack), i=1,2
\end{array}
\]
%\sx{
%Previously we are setting up the \(t\) as in a very generous form, now we are saying some of then can be extracted to a read/write form. 
%Here it is a bit inconsistent.
%Minor point but might change later.
%
%Possibly finger print heap with  \( \ws{\h} \) and \( \rs{\h} \) functions is a good way to go.
%}
\section{Semantics of Transactions}
The semantics of transactions is given in an operational way, 
judgements take the form $\thdstack \vdash \langle \txstack, \heap, \mathcal{O}, \trans \rangle 
\to \langle \txstack', \heap', \mathcal{O}', \trans' \rangle$. Here $\mathcal{O}, \mathcal{O}' \subseteq \Op$ 
keep track of the fingerprint of the transaction being executed. Note that in this semantics 
the $\thdstack$ component cannot be manipulated by performing a transition, as to reflect 
the fact that transactions can only read from, and never write to, the thread local heap.
%The components $\RS, \WS \in \Addr \parfun \Val$ record the read-set and write-set associated to the transaction code, 
%respectively.

We also assume a partial operator $\oplus$ that specifies the effects of adding a new operation inside 
a set of previously defined operations. Again, the behaviour of $\oplus$ is left widely unspecified, 
exception made for the rules that govern read and write operations.
%In order to give the semantics of transactions, it will be useful to define the following operator over sets of 
%operations. 
%\[
%\begin{rclarray}
%\RS \RScup (\addr, \val) & \defeq  & \RS \uplus \Set{\addr \mapsto \val} \\
%\WS \WScup (\addr, \val) & \defeq & \WS\rmto{\addr}{\val} 
%\end{rclarray}
%\]
\[
\begin{array}{lcl}
\mathcal{O} \oplus \varepsilon &=& \mathcal{O}\\
\mathcal{O} \oplus (\RD\;[n]: m) &=&
\begin{cases}
\mathcal{O} \cup \{\RD\; [n]: m)\} & \impliedby \mathcal{O} \cap \{ \RD\;[n]: m, \WR [n]: m \mid m \in \Val\} = \emptyset\\
\mathcal{O} & \impliedby \text{otherwise}
\end{cases}\\
\mathcal{O} \oplus (\WR\;[n]: m) &=& 
(\mathcal{O} \setminus \{ \WR;[n] : m \mid m \in \Val \}) \cup \{\WR\;[n]: m \}
\end{array}
\]

The rules of the operational semantics for transactions are the following: 
%\[
%\infer[{\scriptstyle{(prim-t-local-nofp)}}]
%{\thdstack \vdash \langle \txstack, \heap, \mathcal{O}, t.\trans  \rangle \rightarrow \langle \txstack', \heap', \mathcal{O}, \trans \rangle}
%{(\thdstack, \txstack, \heap) \toT{t} (\txstack', \heap') \qquad \fingerprint(t,\thdstack,\txstack,\heap) = \text{undefined}}
%\]

\[
\infer[{\scriptstyle{(Tx-prim)}}]
{\thdstack \vdash \langle \txstack, \heap, \mathcal{O}, t.\trans  \rangle \rightarrow \langle \txstack', \heap', \mathcal{O} \oplus op, \trans \rangle}
{(\thdstack, \txstack, \heap) \toT{t} (\txstack', \heap') \qquad \fingerprint(t,\thdstack,\txstack,\h) = op}
\]

%\[
%\infer[{\scriptstyle{(prim-t-write)}}]
%{\thdstack \vdash \langle \txstack, \heap, \RS, \WS, t.\trans \rangle \rightarrow \langle \txstack', \heap', \RS, \WS \WScup (\addr,\val), \trans \rangle}
%{(\thdstack, \txstack, \heap) \toT{t} (\txstack', \heap') \qquad \fingerprint(t,\thdstack,\txstack,\h) = (\WR, \addr, \val)}
%\]

\[
\infer[{\scriptstyle{(\Tx-choice-L)}}]{\thdstack \vdash \langle \txstack, \heap, \mathcal{O}, \trans_1 + \trans_2 \rangle 
\rightarrow \langle  \txstack, \heap, \mathcal{O}, \trans_1 \rangle}{}
\]

\[
\infer[{\scriptstyle{(\trans-choice-R)}}]{\thdstack \vdash \langle \txstack, \heap, \mathcal{O}, \trans_1 + \trans_2 \rangle 
\rightarrow \langle  \txstack, \heap, \mathcal{O}, \trans_2 \rangle}{}
\]

\[
\infer[{\scriptstyle{(\Tx-fix)}}]{\thdstack \vdash \langle \txstack, \heap, \mathcal{O}, \mu X.\trans \rangle 
\rightarrow \langle  \txstack, \heap, \mathcal{O}, \{\nicefrac{\mu X.\trans}{X}\}\trans \rangle}{}
\]

%\ac{Design Choice: maybe the heap should go away in the right hand side of judgments for 
%transactional commands. Judgements may take the form $\thdstack, \heap \vdash \langle \txstack, \mathcal{O}, \trans \rangle 
%\rightarrow \langle \txstack', \mathcal{O'}, \trans' \rangle$; then one can define the operator 
%$\mathsf{lift}: (\heap, \mathcal{O}) \mapsto \heap'$ by letting $\mathsf{lift}(h, \mathcal{O})([\nat]) = m$ if $\WR\;[n]: m \in \mathcal{O}$, 
%$h([n])$ otherwise - note that this operator is well-defined only in the case that whenever $\WR\; [n]:m, \WR\;[n]:m' \in \mathcal{O}$, 
%then $m = m'$. Then one can define sequences of computations by means of these two rules: 
%\[
%\infer[{\scriptstyle(SeqTx-Id)}]{\thdstack, \heap \vdash \langle \txstack, \mathcal{O}, \trans \rangle \twoheadrightarrow
%\langle \txstack, \mathcal{O}, \trans \rangle}{}
%\]
%\[
%\infer[{\scriptstyle(SeqTx-trans)}]{\thdstack, \heap \vdash \langle \txstack, \mathcal{O}, \trans \rangle \twoheadrightarrow 
%\langle \txstack'', \mathcal{O}'', \trans'' \rangle}
%{\begin{array}{c}\thdstack, \heap \vdash \langle \txstack, \mathcal{O}, \trans \rangle \twoheadrightarrow \langle \txstack', \mathcal{O}', \trans' \rangle
%\qquad \heap' = \mathsf{lift}(\heap, \mathcal{O}')\\
%\thdstack, \heap' \vdash \langle \txstack', \mathcal{O}', \trans' \rangle \rightarrow \langle \txstack'', \mathcal{O}'', \trans'' \rangle  \end{array}}
%\]
%}
%\section{Abstract Executions}
%Here we present abstract executions, which we will use to record the 
%run-time behaviour of programs. 
%
%We start by defining the behaviour of transactions at run-time. 
%We assume a set of (run-time) transactions identifiers $\TransID = \{\tsid, S , \cdots \}$ 
%and a set of operations which we leave unspecified, though 
%we require that $\Op \supseteq \Setcon{ \RD\;\addr :\val, \WR\;\addr :\val }{\addr \in \Addr \land \val \in \Val }$.
%We also assume a function $\behav : \TransID \to \powerset{\Op}$, which maps 
%transactions into the operations that they perform on locations. With an abuse of 
%notation, for any transaction $\tsid$ and operation $o$, we write $o \in \tsid$ (or $\tsid \ni o$) as 
%a shorthand for $o \in \behav(\tsid)$. 
%We only model transaction that enjoy \emph{atomic visibility}. This 
%means that \textbf{(i)} transactions never observe two different values when reading from 
%the same location: $\for{ \tsid \in \TransID,  \addr \in \Addr,\val, \val' \in \Val }
%\tsid\ni \RD\;\addr :\val \land \tsid \ni \RD\;\addr:\val' \implies \val = \val'$; and \textbf{(ii)} 
%the effects of a transactions become visible at once, which means that we never observe
%two different values written for the same location by a transaction: $\for{ \tsid \in \TransID, \addr \in \Addr, \val,\val' \in \Val } 
%\tsid \ni \WR\;\addr: \val \land \tsid \ni \WR\;\addr:\val' \implies \val = \val'$.
%
%\begin{definition}[abstraction executions]
%An abstract execution is a tuple $\aexec = (\settrans, \PO, \VIS, \AR)$, where 
%
%\begin{enumerate}
%\item 
%$\T$ is a finite, empty set of transactions, 
%
%\item 
%$\PO \subseteq \T \times \T$, the \emph{program order}, is the union 
%of disjoint, strict total orders over $\T$. That is, there exists a partition $\{\T_i\}_{i \in I}$ 
%of $\T$ such that $\PO = \bigcup_{i \in I} \PO_i$, where for any $i \in I$, $\PO_i$ is a strict, 
%total order over $\T_i$\footnote{Recall that a relation $R \subseteq \T \times \T$ is a strict partial order 
%if it is irreflexive and transitive. It is a strict total order if it enjoys the additional property that 
%for any $T_1, T_2 \in \T$, either $T_1 = T_2$, $(T_1, T_2) \in R$ or $(T_2, T_1) \in R$.},
%
%%\item 
%$\VIS \subseteq \T \times \T$ is a strict, partial order such that $\PO \subseteq \VIS$, and $\VIS \rcomp \VIS \subseteq 
%\VIS$,
%
%%\item 
%$\AR \subseteq \T \times \T$ is a strict, total order such that $\VIS \subseteq \AR$,
%
%%\item 
%for any location $\addr \in \Addr$ let $\WTr(\addr) = \Setcon{S \in \T }{S \ni \WR\;\addr:\anyval }$. 
%Given $T \in \T$, let also $\pw_{\aexec}(\addr, \tsid) = \Setcon{\tsid' }{ \tsid' \in \VIS^{-1}(\tsid)} \cap \WTr(\addr)$. 
%Whenever $T \ni \RD\;\addr: \val$ for some transaction $\tsid \in \T$, location $\addr \in \Addr$ and 
%value $\val \in \Val$, then either $\pw_{\aexec}(\addr, \tsid) = \emptyset$ and $\val = 0$, 
%or $\max_{\AR}(\pw_{\aexec}(\addr, \tsid)) \ni \WR\;\addr: \val$.
%
%\end{enumerate}
%
%\end{definition}
%The set of all abstract executions is denoted as $\aeset$.
%In the following, for an abstract execution $\aexec = (\T, \PO, \VIS, \AR)$, we let 
%$\T_{\aexec} = \T$, $\PO_{\aexec} = \PO$, $\VIS_{\aexec} = \VIS$, $\AR_{\aexec} = \AR$. 
%We often use the notation $T \xrightarrow{R} S$ instead of $(T,S) \in R$.
%
%\paragraph{\textbf{Specification of Weak Consistency Models.}}
%We use the style of specification for weak consistency models 
%proposed in \cite{laws}. 
%
%\begin{definition}
%A specification function $\rho$ is an endo-function of relations over 
%transactions, $\rho: (\TrSet \times \TrSet) \rightarrow (\TrSet \times \TrSet)$,
%such that for any abstract execution $\aexec$ and relation $R \subseteq \T_{\aexec} \times \T_{\aexec}$, 
%$\rho(R) = \rho(\T_{\aexec} \times \T_{\aexec}) \cap R?$. 
%
%A consistency guarantee is a pair $(\rho, \pi)$ of specification functios.
%An abstract execution based specification of weak consistency models, or simply \emph{x-specification}, 
%is a (possibly empty, possibly infinite) set of consistency guarantees: $\xspec = \{(\rho_i, \pi_i)\}_{i \in I}$ 
%for some index set $I$.
%\end{definition}
%
%\begin{definition}
%An abstract execution $\aexec$ is allowed by the consistency model specification $\xspec$, 
%written $\xspec \models \aexec$, if and only if, for any $(\rho, \pi) \in \xspec$, we have that $\rho(\VIS_{\aexec}) \rcomp \AR_{\aexec} 
%\rcomp \VIS_{\aexec} \subseteq \AR_{\aexec}$.
%\end{definition}
%
%\begin{example}
%Let $\rho_{\Id} = \lambda \_. \Id$, $\rho_{\SI} = \lambda R. (R \setminus \Id)$, and $\rho_[n] = 
%\lambda \_. [\WTr_{[n]}]$ for any location $[n] \in \locs$. Here, given a set $X \subseteq \TrSet$, 
%$[X]$ is defined as $\Id \cap (X \times X)$. We specify \emph{Snapshot Isolation} via the set 
%of consistency guarantees $\xspec_{\SI} = \{(\rho_{\Id}, \rho_{\SI})\} \cup \bigcup_{[n] \in \locs} \{(\rho_{[n]}, \rho_{[n]}\}$. 
%
%An abstract execution $\aexec$ is allowed by $\xspec_{\SI}$ if and only if 
%$\AR_{\aexec} \rcomp \VIS_{\aexec} \subseteq \VIS_{\aexec}$, 
%and for any $[n] \in \locs$, $[\WTr_{[n]}] \rcomp \AR_{\aexec} \rcomp [\WTr_{[n]}] \subseteq \VIS$.
%\end{example}
%\sx{NEED TO REVISIT ABOVE LATER}
%
%In the following, we will use an incremental approach to build abstract executions from transactions. 
%Suppose that an abstract execution $\aexec$ has been obtained as the (partial) result of a program $P$ running 
%in a system that implements the x-specification $\xspec$. 
%Suppose also that $T \in \T_{\aexec}$ is the transaction-instance associated with the last transactional 
%code that has been executed by some thread, and that the same thread executes another piece of transactional 
%code next, which results in the transaction instance $S$. This may result in an abstract execution $\aexec'$, 
%where the new transaction instance $S$ follows $T$ in the program order $\PO_{\aexec'}$, and $\VIS_{\aexec'}, 
%\AR_{\aexec'}$ are computed according to the axioms of $\xspec$.
%$T \in \T_{\aexec}$. Note that the result of this procedure may result in an abstract execution that 
%is not allowed by $\xspec$, hence it is not always defined.
%Formally, we define an operator $\aeplus_{\xspec} : (\aeset \times \TrSet) \rightharpoonup 
%\aeset$ as follows:
%
%\begin{defn}[Runtime abstract executions]
%Assuming set of thread identifiers \( \ThreadID \defeq \Set{\thid, \dots}\), the set of \emph{runtime abstract executions} is defined as the follows,
%\[
%    \begin{rclarray}
%    \aexecrun \in \Setcon{(\settrans, \PO, \VIS, \AR) 
%    }{ 
%        \settrans \in  (\TransID \uplus \ThreadID ) \parfun \powerset{\Events}  \\
%        {} \land  \PO, \VIS \subseteq ( \dom(\settrans) \cap \TransID ) \times \dom(\settrans) \\
%        {} \land  \AR \subseteq ( \dom(\settrans) \cap \TransID  ) \times ( \dom(\settrans) \cap \TransID )
%    }
%    \end{rclarray}
%\]
%\end{defn}
%
%\begin{definition}
%Let $\xspec$ be a x-specification. 
%Let $\aexec \in \aeset$, and let $T \in \T_{\aexec}$. 
%Also, let $S \in \TrSet \setminus \T_{\aexec}$.
%Define the abstract execution $\aexec'$ as follows: 
%in which case we have
%\begin{gather*}
%\PO_{\aexec}' = (\PO_{\aexec} \cup \{(T,S)\})^{+}\\
%\AR_{\aexec}' = \{(T', S), (S, T'') \mid T' \in \AR_{\aexec}^{-1}(T) \wedge T'' \in \AR_{\aexec}(T)\}^{+}\\
%\VIS_{\aexec}' = \mu V.(\PO_{\aexec}' \cup \VIS_{\aexec} \cup \bigcup_{(\rho, \pi \in \xspec)} \rho(V) \rcomp \AR_{\aexec}' \rcomp \pi(V) )^{+}
%\end{gather*}
%The abstract execution $(\aexec, T) \aeplus_{\xspec} S$ is defined to be exactly $\aexec'$ 
%if whenever $S \ni \WR\;[n]:\_$ and $S \xrightarrow{\VIS_{\aexec}'} T$, then $T \not\ni \RD\;[n]:\_$ 
%and $T \not\ni \WR\;[n]:\_$, 
%it is undefined otherwise.
%\end{definition}
%
%\begin{proposition}
%Let $\xspec$ be a x-specification, and suppose that $\xspec \models \aexec$ for some abstract
%execution $\aexec$. Let $T, S$ be two transactions such that $(\aexec, T) \aeplus_{\xspec} S$ is
%defined. Then $\xspec \models (\aexec, T) \aeplus_{\xspec} S$.
%\end{proposition}
%\ac{Not sure whether it's true. Needs to be checked.}
%
%Note that, for a transaction $T_0$ such that $T_0 \ni o$ for no operation $o \in \Op$, 
%$(\aexec, T) \aeplus_{\xspec} T_0$ is always defined (provided $T_0 \notin \T_{\aexec}, T \in \T_{\aexec})$.
%
%Given an abstract execution and a x-specification $\aexec$, we can map any transaction $T \in \T_{\aexec}$ 
%to a heap $\heap_{\aexec}^{\xspec}(T)$. Intuitively, the latter corresponds to the heap that would be observed 
%by a client that interact with a system implementing the x-specification $\xspec$, assuming that 
%the set of transactions processed by the system so far resulted has given rise to the abstract execution 
%$\aexec$, and that the last transaction instance of $\aexec$ observed by the client is $T$.
%
%\begin{definition}
%Let$\xspec$ be a consistency model specification, and $\aexec$ be an abstract execution. For any $T \in \T_{\aexec}$, 
%let $\aexec' = (\aexec, T) \aeplus_{\xspec} T_0$, where $T_0 \notin \T_{\aexec}$ and $T_0 \ni o$ for no 
%$o \in \Op$. We can always assume that such a transaction exists. 
%
%We define $\heap_{\aexec}^{\xspec}(T)$ as follows:
%\[
%\heap_{\aexec}(T) = \lambda [n] \in \locs.
%\begin{cases}
%0 &\impliedby \pw_{\aexec'}([n], T) = \emptyset\\
%m & \impliedby \max_{\AR_{\aexec'}}(\pw_{\aexec'}([n], T_0)) \ni \WR\;[n]: m 
%\end{cases}
%\]
%\end{definition}
%\ac{I don't really like this definition, but for the moment it will do...}
%
%\begin{example}
%Consider the abstract execution $\aexec$ depicted below, denoting the write-skew anomaly 
%allowed by snapshot isolation. 
%
%\begin{center}
%\begin{tikzpicture}
%\node(Rx0) {$\RD\;[1]: 0$};
%\path(Rx0.center) + (0,-0.5) node (Wy1) {$\WR\;[2]: 1$};
%\path(Rx0.center) + (4,0) node (Ry0) {$\RD\;[2]: 0$};
%\path(Ry0.center) + (0,-0.5) node (Wx1) {$\WR\;[1]: 1$};
%%
%\begin{pgfonlayer}{background}
%\node(t1)[background, fit=(Rx0)(Wy1), inner sep=0.15cm] {};
%\node(t2)[background, fit=(Ry0)(Wx1), inner sep=0.15cm] {};
%\path(t1.west) + (-0.25,0) node (T) {$T$};
%\path(t2.east) + (0.25,0) node(S) {$S$};
%\path[->, thick]
%(t2.west) edge node[above] {$\AR$} (t1.east);
%\end{pgfonlayer}
%\end{tikzpicture}
%\end{center}
%Let us calculate $\heap_{\aexec}^{\xspec_{\SI}}(T)$. 
%Let then $T_0$ be a transaction with no operation associated, 
%and let us compute $\aexec' = (\aexec, T) \aeplus_{\xspec_{\SI}} T_0$. 
%By definition, we have that $T \xrightarrow{\PO_{\aexec'}} T_0$, hence 
%$T \xrightarrow{\VIS_{\aexec'}} T_0$. Because $S \xrightarrow{\AR_{\aexec}}T$, 
%we also have that $S \xrightarrow{\AR_{\aexec}} T$, and now from 
%$S \xrightarrow{\AR_{\aexec'}} T \xrightarrow{\VIS_{\aexec'}} T_0$, 
%we obtain that $S \xrightarrow{\VIS_{\aexec'}} T_0$. By definition, 
%we also know that $S \xrightarrow{\AR_{\aexec}} T$ implies that 
%$S \xrightarrow{\AR_{\aexec'}} T_0$. The final result is the abstract 
%execution $\aexec'$ depicted below: 
%\begin{center}
%\begin{tikzpicture}
%\node(Rx0) {$\RD\;[1]: 0$};
%\path(Rx0.center) + (0,-0.5) node (Wy1) {$\WR\;[2]: 1$};
%\path(Rx0.center) + (4,0) node (Ry0) {$\RD\;[2]: 0$};
%\path(Ry0.center) + (0,-0.5) node (Wx1) {$\WR\;[1]: 1$};
%\path(Wy1.center) + (0,-2.5) node (phantom) {\phantom{$\WR\;[2]: 1$}};
%%
%\begin{pgfonlayer}{background}
%\node(t1)[background, fit=(Rx0)(Wy1), inner sep=0.15cm] {};
%\node(t2)[background, fit=(Ry0)(Wx1), inner sep=0.15cm] {};
%\node(t3)[background, fit=(phantom), inner sep=0.15cm] {};
%\path(t1.west) + (-0.25,0) node (T) {$T$};
%\path(t2.east) + (0.25,0) node(S) {$S$};
%\path(t3.west) + (-0.3,0) node(T0) {$T_0$};
%\path[->, thick]
%(t2.west) edge node[above] {$\AR$} (t1.east)
%(t1.south) edge node[left] {$\PO, \VIS,\AR$} (t3.north)
%(t2.south west) edge node[right] {\;\;\;$\VIS, \AR$} (t3.north east);
%\end{pgfonlayer}
%\end{tikzpicture}
%\end{center}
%It is easy to see that $\pw_{\aexec'}([1], T_0) = \{S\}$, and $\pw_{\aexec'}([2], T_0) = \{T\}$. 
%Because $S \ni \WR\;[1]:1$, we have that $\heap_{\aexec}^{\xspec_{\SI}}(T)([1]) = 1$, 
%and because $T \ni \WR\;[2]:1$, we have that $\heap_{\aexec}^{\xspec_{\SI}}(T)([2]) = 1$.
%
%Next, we want to calculate $\heap_{\aexec}^{\xspec_{\SI}}(S)$. To this end, we need first 
%to retrieve the abstract execution $\aexec'' = (\aexec, S) \aeplus_{\xspec_{\SI}} T_0$, 
%which is depicted below:
%\begin{center}
%\begin{tikzpicture}
%\node(Rx0) {$\RD\;[1]: 0$};
%\path(Rx0.center) + (0,-0.5) node (Wy1) {$\WR\;[2]: 1$};
%\path(Rx0.center) + (4,0) node (Ry0) {$\RD\;[2]: 0$};
%\path(Ry0.center) + (0,-0.5) node (Wx1) {$\WR\;[1]: 1$};
%\path(Wx1.center) + (0,-2.5) node (phantom) {\phantom{$\WR\;[1]: 1$}};
%%
%\begin{pgfonlayer}{background}
%\node(t1)[background, fit=(Rx0)(Wy1), inner sep=0.15cm] {};
%\node(t2)[background, fit=(Ry0)(Wx1), inner sep=0.15cm] {};
%\node(t3)[background, fit=(phantom), inner sep=0.15cm] {};
%\path(t1.west) + (-0.25,0) node (T) {$T$};
%\path(t2.east) + (0.25,0) node(S) {$S$};
%\path(t3.east) + (0.25,0) node(T0) {$T_0$};
%\path[->, thick]
%(t2.west) edge node[above] {$\AR$} (t1.east)
%(t2.south) edge node[right] {$\PO, \VIS,\AR$} (t3.north)
%(t3.north west) edge node[right] {\;\;\;$\AR$} (t1.south east);
%\end{pgfonlayer}
%\end{tikzpicture}
%\end{center}
%In this case we have that $\pw_{\aexec''}([1],T_0) = \{S\}$, 
%and $\pw_{\aexec''}([2], T_0) = \emptyset$. By definition, 
%we have that $\heap_{\aexec}^{\xspec_{\SI}}(S)([1]) = 1$, 
%and $\heap_{\aexec}^{\xspec_{\SI}}(S)([2]) = 0$.
%\end{example}
%
%\paragraph{\textbf{Semantics of Commands.}}
%Judgements for programs take the form 
%$\langle \aexec, T, \thdstack \Cmd \rangle \rightarrow \langle \aexec', T',  \thdstack', \Cmd' \rangle
%$.Here $\aexec$ is an abstract execution that represent 
%the global run of the database, 
%$T$ represents the last transaction executed by the command, in the abstract execution, 
%and $\thdstack$ is the thread local stack associated with the transaction.
%
%The rule for evaluating a non-transactional primitive command is straightforward, as it 
%does only require to manipulate the thread-local stack associated  with the command. 
%\[
%\infer[{\scriptstyle{(prim-c)}}]
%{\langle \aexec, T, \thdstack, \primc.\Cmd \rangle \rightarrow \langle \aexec, T, \thdstack', \Cmd \rangle}
%{\thdstack \rightsquigarrow_c \thdstack'} 
%\]
%
%Next, we give the rule for evaluating a transaction in a command of the form $\TxOp{\trans}.\Cmd$. 
%First, given a read-set $\RS$ and a write-set $\WS$, we define the set of transaction $\makeTx(\RS,\WS)$ 
%to be the largest set of transactions such that, whenever $T \in \makeTx(\RS, \WS)$, then $T \ni \RD\;[n]:m$, if and only if $([n], m) \in \RS$, and $T \ni 
%\WR\;[n]:m$ if and only if $([n], m) \in \WS$. 
%\[
%\infer[{\scriptstyle{(Tx-exec)}}]{\langle \aexec, T, \thdstack, \TxOp{\trans}.\Cmd \rangle \rightarrow 
%\langle \aexec', T', \thdstack[\retvar \mapsto \txstack'(\retvar)], \Cmd \rangle}
%{
%\begin{array}{lll}T \xrightarrow{\AR_{\aexec}} S &  T' \in (\makeTx(\RS,\WS) \setminus \T_{\aexec}) & \aexec' = (\aexec, S) \aeplus_{\xspec} T'\\[4pt]
%\multicolumn{3}{c}{\thdstack \vdash \langle \txstack_0, \heap_{\aexec}^{\xspec}(S), \emptyset, \emptyset, \trans \rangle \rightarrow^\ast \langle \txstack', \heap', \RS, \WS, \nil \rangle}
%\end{array}}
%\]
%The three remaining rules are standard.
%\[
%\infer[{\scriptstyle{(C-choice-L)}}]
%{\langle \aexec, T, \thdstack, \Cmd_1 + \Cmd_2 \rangle \rightarrow \langle \aexec, \Cmd_1, \thdstack, \Cmd \rangle}
%{} 
%\]
%
%\[
%\infer[{\scriptstyle{(C-choice-R)}}]
%{\langle \aexec, T, \thdstack, \Cmd_1 + \Cmd_2 \rangle \rightarrow \langle \aexec, \Cmd_2, \thdstack, \Cmd \rangle}
%{} 
%\]
%
%\[
%\infer[{\scriptstyle{(C-fix)}}]
%{\langle \aexec, T, \thdstack, \mu X.\Cmd \rangle \rightarrow \langle \aexec, \{\nicefrac{\mu X.\Cmd}{X}\}\Cmd, \thdstack, \Cmd \rangle}
%{} 
%\]

\paragraph{\textbf{Semantics of Commands.}}
Before giving the semantics of commands, it will be necessary to formalise 
the notions of \emph{history heap} and \emph{view}. 
We assume countably infinite set of transaction identifiers $\TransID$, whose elements 
are ranged over $\tsid$. Subsets of $\TransID$ are ranged over by $\T$. 
A \emph{Version} is a triple 
$(v, \tsid, \{\tsid_1, \tsid_2,\cdots\}) \in \Val \times \TransID \times 2^{\TransID}$. 
The set of all versions is denoted by $\Versions$, and its elements are ranged over $\nu, \nu', \cdots$. 
Intuitively, associating a location $[n]$ with the version $\nu = (v, \tsid, \{\tsid_1,\tsid_,\cdots\})$ means that the 
value $v$ has been written for location $[n]$. The transaction that wrote version $\nu$ is $\tsid$, 
and the version has been read by transactions $\{\tsid_1,\tsid_2,\cdots\}$. 
Given a version $\nu := (v, \tsid, \T)$, we define $\valueof(\nu) = v$, $\WTx(\nu) := \tsid$, 
and $\RTx(\nu) := \T$.
A history heap is a function $\hh: \Addr \rightarrow \Versions^{\ast}$ that 
maps each location to its list of versions. As usual, if 
$\hh([n]) = \nu_0,\cdots, \nu_m$ for some location $[n]$, then for any 
$i= 0,\cdots, m$ we let $\hh([n])(i) = \nu_i$, and we let $\lvert \hh([n]) \rvert = m -1$. 
For a list of versions $vlist$, an index $i = 0,\ cdots, \lvert vlist \rvert - 1$, and a version $\nu$, 
we let  $vlist[i \mapsto \nu]$ to be the same of $vlist$, exception made for the version at 
location $i$ which is replaced with $\nu$.

Given a history heap $\hh$, we can extract several heaps 
from it, by simply choosing for each location $[n]$ a version 
contained in the list of versions available for $[n]$ in $\hh$, 
namely $\hh([n])$. 
In order to determine uniquely the heap in which a command 
is executing, we introduce \emph{views}. A view $V : \Addr \rightarrow \mathbb{N}$ is 
a function that maps a location $[n]$ to the index of the version 
that must be read for such a location. Given a history heap $\hh$ and a 
view $V$, we can construct a heap as follows:  
\[
\snapshot(\hh, V) = \lambda [n] \in \Addr. \big( \hh([n])(V([n]) \big)
%\begin{cases}
%v_{V([n])} &\impliedby \hh([n]) = \langle v_0, \_ , \_ \rangle \cdots \langle v_{m}, \_, \_ \rangle \wedge m \geq V([n])\\
%\text{undefined} & \text{otherwise}
%\end{cases}
\]

%Formally, we define a \emph{snapshot} 
%to be a function $\snapshot: \Addr \rightarrow \mathbb{N}$; 
%given a history heap $\hh$ and a snapshot $\snapshot$, 
%we can construct the heap 
%\[
%\heap(\hh, \snapshot) = \lambda [n] \in \Addr. 
%\begin{cases}
%v_{\snapshot([n])} &\impliedby \hh([n]) = \langle v_0, \_ , \_ \rangle \cdots \langle v_{m}, \_, \_ \rangle \wedge m \geq \snapshot([n])\\
%\text{undefined} & \text{otherwise}
%\end{cases}
%\]
%The syntax of commands has the form $V : \cmd$. Here $V$ is the view of the thread executing 
%the command $\cmd$. 
Judgements in the semantics of commands take the form 
\[ 
\langle \hh, \sigma, V: C \rangle \xrightarrow{CM} \langle \hh', \thdstack', V': \cmd' \rangle
\]

%where $\alpha \in \{ \lambda, \delta \}$ identifies whether a transition performed within 
%a command corresponds to a local computation ($\lambda$), such as executing a 
%non-transactional primitive command or some housekeeping activity, or to an interaction with 
%the database ($\delta$), that is executing a transaction. 
Where 
%$\mathcal{O}$ is a possibly empty set of operations, and 
$CM$ is an arbitrary consistency model specification; consistency model specifications 
are introduced formally later in this Section.
%\ac{Introducing labelled transitions was necessary to remove complications later on when dealing 
%with the parallel composition of threads. More details when discussing the rule.}

The main rule in the operational semantics of commands is the one corresponding 
to the execution of a transaction, i.e. $\cmd = [\trans].\cmd'$. For this rule, we must specify the following: 
\begin{itemize}
\item How the execution of the transaction $[\trans]$ affects the history heap, and 
\item How the view of the thread executing the command is changed, after the transaction 
has been executed. 
\end{itemize}

Let us first discuss how the history heap is changed when executing a transaction. 
Recall that the history heap $\hh$ and the view $V$ determine a heap 
via the function $\snapshot$. By executing the transaction $[\trans]$ using 
such a snapshot is an initial state, we obtain the fingerprint of the transaction 
as a set of operations $\mathcal{O}$. We then choose a fresh transaction identifier 
$\tsid$ that is associated with the execution of $[\trans]$> 
Each read operation $\RD\;[n]:m$, 
refers to the version $\nu$ to which the view $V$ pointed before the transaction $[\trans]$ 
was executed: when we update the history heap, we must update the readset of 
such a version $\RS(\nu)$ to include the transaction $\tsid$. For write 
operations of the form $\WR\;[n]:m$, we create a new version 
$\nu = (m, \tsid, \emptyset)$ and we append it at the tail of $\hh([n])$.
Formally: 
\[
\begin{array}{lll}
\mathsf{HHupdate}_{\tsid}(\hh, V, \{\RD\;[n]: m\}) &=& 
\mathsf{let}\; (v, \tsid', RS) = \snapshot(\hh,V, [n]) \; \mathsf{in} \; \\
&&
\hh\Big[ [n] \mapsto  \Big( \hh([n])  [ V([n]) \mapsto (v, \tsid', RS \cup \{ \tsid \} ) ] \Big) \Big]
%\lambda [k].\begin{cases}
%\langle v_0, T_{0}, \T_{0} \rangle \cdots \langle v_i, T_{i}, \T_{i} \cup \{\tsid\} \rangle \cdots \langle v_{n_{k}}, T_{n_{k}}, \T_{n_{k}} \rangle\\
%\hspace{5pt} \text{if } [k] = [n] \wedge V([k]) = i &\\
%\hh([k]) \hspace{5pt} \text{otherwise}
%\end{cases}
\\
\mathsf{HHupdate}_{\tsid}(\hh, \_, \{\WR\; [n]: m\}) &=& 
\hh\Big[ [n] \mapsto ( \hh([n]) \cdot \langle m, \tsid, \emptyset \rangle) \Big]\\
\mathsf{HHupdate}_{T}(\hh, V, \mathcal{O}_1 \cup \mathcal{O}_2) &=& 
\mathsf{HHupdate}_{T}(\mathsf{HHupdate}_{\tsid}(\hh, V, \mathcal{O}_1), V, \mathcal{O}_2)
\end{array}
\]
\ac{The definition above should be well-formed, but we must prove this.}
Next, we discuss how the view of a command is changed after executing 
a transaction. In this case, we only update the view of the locations that 
have been written by a transaction to be up-to-date with the version 
installed by the transaction that has been executed. 
Formally, we define the function 
\[
\begin{array}{lll}
\mathsf{ViewUpdate}(\hh, V, \mathsf{RD}\;[n]: m) &=& V\\
\mathsf{ViewUpdate}(\hh, V, \mathsf{WR}\;[n]: m) &=& V[ [n] \mapsto ( \lvert \hh([n]) \rvert -1)]\\
\mathsf{ViewUpdate}(\hh, V, \mathcal{O}_1 \cup \mathcal{O}_2) &=& \mathsf{update}(\hh, \mathsf{update}(\hh, V, \mathcal{O}_1), \mathcal{O}_2)
\end{array}
\]
\ac{Note that according to this definition the $\mathsf{ViewUpdate}$ function may push the view of a 
location out of the boundaries of the history heap by $1$. This happens when a new version is written 
for some location $[n]$. This is totally fine, as the new view will be paired with a history heap which 
carries a new version for location $[n]$, and the view is within the boundaries of such a history heap.}


%\ac{It seems that introducing history heaps and sessions here may be avoided. 
%In fact, the semantics of commands should be just a bridge between transaction 
%code and multi-threaded programs.}
%For commands, judgements take the form 
%\[
%\heap \vdash \langle \thdstack, \cmd \rangle \rightarrow \langle \thdstack', \mathcal{O}', \cmd' \rangle.
%\] 
The last notion that we need to introduce, before giving the semantics of commands, 
is the one of \textbf{Consistency Model Specification.} 
A consistency model specification $CM$ consists of a set of quadruples 
$(\hh, V, \mathcal{V}, \mathcal{O})$, where 
\begin{itemize}
\item $\hh$ is a history heap, corresponding to a state of the database
\item $V$ is the view of the history heap of the thread that wants to execute a 
transaction, 
\item $\mathcal{V}$ is the multi-set of views of the external environment (i.e. other 
threads that may be interacting with the database), 
\item $\mathcal{O}$ is the fingerprint of the transaction to be executed.
\end{itemize}
Therefore, tuples of the form $(\hh, V, \mathcal{V}, \mathcal{O}) \in CM$ describe 
which operations a thread is allowed to execute in a single transaction, without conflicting 
with other threads. We often write $(\hh, V, \mathcal{V}) \triangleright_{CM} \mathcal{O}$ 
in lieu of $(\hh, V, \mathcal{V}, \mathcal{O}) \in CM$.

We are now ready to give the operational semantics for commands.
The main rule for executing commands is the one that models the execution of one transaction. 
In the rule below we compare views according to a partial order $\sqsubseteq$, which 
is defined to be the point-wise comparison of values of views at single locations: 
$V_1 \sqsubseteq V_2 \triangleq \forall [n] \in \Addr. V_1([n]) \leq V_2([n])$.
%In the rule below, ignore for the moment the side condition $\langle \hh, \{V\} \leadsto \langle \hh', \{V'\} \rangle$, 
%which we will explain when we introduce consistency models in the next section.
\ac{The side-condition concerning weak consistency models 
has been moved to the semantics of programs, in the rule where we 
lift the semantics of commands. In any case, this is going to change in the future 
because we agreed to remove thread identifiers.}
%\[
%\infer[{\scriptstyle(Tx-exec)}]{\heap \vdash \langle \thdstack, [\trans].\cmd \rangle \rightarrow \langle \thdstack[\retvar \mapsto v], \mathcal{O}, \cmd \rangle}
%{\thdstack \vdash \langle \txstack_{0}, \heap, \emptyset, \trans \rangle \rightarrow^{\ast} \langle \txstack, \_, \mathcal{O}, \nil \rangle 
%\qquad \txstack(\retvar) = v}
%\]
\[
\infer[{\scriptstyle(C-Tx)}]{\langle \hh, \thdstack, V, [\trans].\cmd \rangle \xrightarrow{CM} \langle \hh', \thdstack', V', \cmd \rangle}
{\begin{array}{c}
V \sqsubseteq V' \qquad 
h = \snapshot(\hh, V') \\
\thdstack \vdash \langle \txstack_{0}, \heap, \emptyset, \trans \rangle \rightarrow^{\ast} \langle \txstack, \_, \mathcal{O}, \nil \rangle 
\qquad \mathsf{ViewUpdate}(\hh, V', \mathcal{O}) \sqsubseteq V'' \qquad (\hh, V) \triangleright_{CM} \mathcal{O} : V'' \\
\tsid \text{ fresh in } \hh \qquad 
%(\hh, V) \leadsto_{CM} (\hh', V') \qquad \hh\\
\mathsf{HHupdate}_{\tsid}(\hh, V', \mathcal{O}) = \hh' \qquad 
\thdstack[\retvar \mapsto \txstack(\retvar)] = \thdstack'
\end{array}
}
\]
\ac{Condition on thread stack should go away once the transaction stack is ditched.}
\ac{Check that $V'$ is well-formed with respect to $\hh'$ is missing from the rule above. 
Also, for the moment I am going with the possibility of having conflicts in views as long as 
transactions cannot be executed. My catch here is that there are cases where whether 
a view is conflicting depends on the code of the transaction to be executed (i.e. write-conflict 
detection), so conflicting views cannot be avoided without losing completeness of the semantics). 
The rule below allows for views to be pushed to the right, so as to resolve conflicts.}

%We also introduce a rule that allows to update the view of the thread executing a command. 
%We say that the view $V$ is dominated by $V'$, written $V \sqsubseteq V'$, if for any 
%location $[n]$ we have that $V([n]) \leq V'([n])$. Because updating a view of a thread 
%does not result in an interaction with the database (i.e. no locations are read or written), 
%the transition is labelled with the empty fingerprint $\emptyset$.
%\[
%\infer[{\scriptstyle{(C-View-Update)}}]
%{\langle \hh, \thdstack, V, \cmd \rangle \xrightarrow{\emptyset} \langle \hh, \thdstack, V', \cmd \rangle }
%{ V \sqsubseteq V'}
%\]
\ac{The rule for shifting views to the right is now gone, and embedded into the rule for executing transactions}

The other rules of the operational semantics are standard: 

\[
\infer[{\scriptstyle{(prim-c)}}]
{\langle \hh, \thdstack, V, \primc.\cmd \rangle \xrightarrow{CM} \langle \hh, \thdstack', V, \cmd \rangle}
{\thdstack \rightsquigarrow_c \thdstack'} 
\]

\[
\infer[{\scriptstyle{(C-Choice-L)}}]
{\langle \hh, \thdstack, V, \cmd_1 + \cmd_2 \rangle \xrightarrow{CM} \langle \hh, \thdstack, V, \cmd_1 \rangle}
{} 
\]

\[
\infer[{\scriptstyle{(C-Choice-R)}}]
{\langle \hh, \thdstack, V, \cmd_1 + \cmd_2 \rangle \xrightarrow{CM} \langle \hh, \thdstack, V, \cmd_2 \rangle}
{} 
\]

\[
\infer[{\scriptstyle{(C-Fix)}}]
{\langle \hh, \thdstack, V, \mu X.\cmd \rangle \xrightarrow{CM} \langle \hh, \thdstack, V, \{\mu X.\cmd/X\}\cmd \rangle}
{} 
\]

%\[
%\infer[{\scriptstyle{(prim-c)}}]
%{\heap \vdash \langle \thdstack, \primc.\cmd \rangle \rightarrow \langle \thdstack', \emptyset, \Cmd \rangle}
%{\thdstack \rightsquigarrow_c \thdstack'} 
%\]
%
%\[
%\infer[{\scriptstyle{(C-Choice-L)}}]
%{\heap \vdash \langle \thdstack, \cmd_1 + \cmd_2 \rangle \rightarrow \langle \thdstack, \emptyset, \cmd_1 \rangle}
%{} 
%\]
%
%\[
%\infer[{\scriptstyle{(C-Choice-R)}}]
%{\heap \vdash \langle \thdstack, \cmd_1 + \cmd_2 \rangle \rightarrow \langle \thdstack, \emptyset, \cmd_2 \rangle}
%{} 
%\]
%
%\[\infer[{\scriptstyle{(C-Fix)}}]
%{\heap \vdash \langle \thdstack, \mu X.\cmd \rangle \rightarrow \langle \thdstack, \emptyset, \{\mu X.\cmd/X\}\cmd \rangle}
%{} 
%\]

%\ac{I really don't like this style for expressing the rules of the operational semantics. 
%Intuitively we may want the LHS and RHS of judgements to be the same, 
%as it is standard. However, this means that we need to carry around a lot of redundant 
%information, for example heap states.}

\subsection{Semantics of Programs}
\label{sec:semantics.programs}
%We want a semantics of programs where transactions are 
%executed atomically, in an interleaving fashion, while still capturing non-serialisable 
%behaviours. We also want our operational semantics to be parametric in the definition of 
%a consistency model. 

%In this sense, a consistency model specification is the set of all the possible transitions that 
%are allowed by the semantics. Formally, a consistency model specification $CM$ is 
%a set of quadruples of the form $(\hh, \mathcal{V}, \hh', \mathcal{V}')$, 
%where $\mathcal{V}, \mathcal{V}'$ are non-empty, finite multi-sets of views,
%and we often write $(\hh, \mathcal{V}) \leadsto_{CM} (\hh, \mathcal{V}')$ 
%in lieu of $(\hh, \mathcal{V}, \hh', \mathcal{V}') \in CM$. 
\ac{
I changed (again) the definition of consistency models. I'm leaving the old 
version in the comment-box for future reference, though it is not clear 
whether the definition below is expressive enough to capture some consistency models (among 
others, snapshot isolation.)

In this sense, a consistency model specification $CM$ consists of a set of quadruples 
$(\hh, V, \mathcal{V}, \mathcal{O})$, where 
\begin{itemize}
\item $\hh$ is a history heap, corresponding to a state of the database
\item $V$ is the view of the history heap of the thread that wants to execute a 
transaction, 
\item $\mathcal{V}$ is the multi-set of views of the external environment (i.e. other 
threads that may be interacting with the database), 
\item $\mathcal{O}$ is the fingerprint of the transaction to be executed.
\end{itemize}

%\ac{I start to believe that calling this \emph{consistency model specification} is 
%misleading. In fact, a consistency model should only concern the 
%history-heap, and it should be just a set of history heaps (as much as for dependency graphs, 
%consistency models are just sets of dependency graphs. Crooks and Alvisi call similar 
%structures in their paper \emph{commit tests}, and maybe I should follow the same terminology.)}
Therefore, tuples of the form $(\hh, V, \mathcal{V}, \mathcal{O}) \in CM$ describe 
which operations a thread is allowed to execute in a single transaction, without conflicting 
with other threads. We often write $(\hh, V, \mathcal{V}) \triangleright_{CM} \mathcal{O}$ 
in lieu of $(\hh, V, \mathcal{V}, \mathcal{O}) \in CM$. }
%\ac{One thing that was not clear from the discussion I had with Philippa and Azalea - 
%mainly because it was stuck in my head as an intuition, but I could not think of it during 
%the chat we had - is that whether a set of views is consistent, with respect to some history 
%heap $\hh$, may depend on the set of operations that may 
%be performed in a single transaction. Therefore, we cannot ensure at compile time 
%that a configuration is always going to be consistent. One example is write-conflict detection (see the formal definition 
%later on), where we require that a transaction may write to location $[n]$ only if the view for such a 
%location is up-to-date (i.e. it points to the last available version for $[n]$). This point should now be 
%more clear in the new style I adopted for specifying consistency models, where the fingerprint of a 
%transaction is explicit.}
%\ac{Following a second discussion with Azalea, I'm okay for removing Rule (C-view-update), 
%and to change rule (Tx-exec) to update the view of a thread before and after a transaction execution.
%Though even in this scenario, there may be cases in which a thread ends-up having an inconsistent 
%view, with respect to the set of operations to be executed next.}
%\ac{Had to switch to multi-sets, though I'm looking for alternatives.}

%In this sense, a consistency model specification $CM$ consists of a set of quadruples 
%$(\hh, V, \mathcal{O}, V')$, where 
%\begin{enumerate}
%\item $\hh$ is a history heap, corresponding to a state of the database
%\item $V$ is the view over the history heap of the thread that wants to 
%execute a transaction, 
%\item $\mathcal{O}$ is the fingerprint of the transaction to be executed,
%\item $V'$ is the view over the history heap of the thread, \textbf{immediately after} 
%executing a transaction.
%\end{enumerate}
%\ac{This notion will require to change the rule for executing transactions in 
%the operational semantics.}
%Given a consistency model specification $CM$, we often write 
%$(\hh, V) \triangleright_{CM} \mathcal{O} : V'$ in lieu of
%$(\hh, V, \mathcal{O}, V') \in CM$.

%We place the following well-formedness constraints on specifications 
%of consistency models. We say that $CM$ is well-formed if: 
%\begin{enumerate}
%\item[Views can be pushed] for any $\hh, \mathcal{V}, V, V'$ such that 
%$V \sqsubseteq V'$, then $(\hh, \mathcal{V} \cup \{V\} \leadsto_{CM} \hh, \mathcal{V} \cup \{V'\})$. 
%This condition also implies that $CM$ must be reflexive, 
%\item[Transactions can be renamed] for any $\hh, \mathcal{V}, \hh', \mathcal{V}'$ and transaction $\tsid$ that does not appear 
%$\hh, \hh'$, $(\hh[\tsid \mapsto \tsid'], \mathcal{V}) \leadsto_{CM} (\hh'[\tsid \mapsto \tsid'], \mathcal{V}')$, 
%\item[Atomic Visibility], let us say that a configuration $(\hh, \{V\})$ enjoys atomic visibility 
%if, whenever $\hh([n])(i) = (\_, \tsid, \_)$ for some $i \leq V([n])$, then for any $[m]$ and 
%$j'$ such that $\hh([m])(j') = (\_, \tsid, \_)$, $j' \leq V([m])$. We say that $(\hh, \mathcal{V})$ 
%enjoys atomic visibility if $(\hh, \{V\})$ enjoys atomic visibility for all $V$ such that 
%$\mathcal{V} = \mathcal{V}' \cup \{V\}$. A consistency model specification enjoys atomic 
%visibility if and only if, whenever $(\hh, \mathcal{V}) \leadsto_{CM} (\hh', \mathcal{V}')$, 
%then $(\hh, \mathcal{V}$ and $(\hh, \mathcal{V}')$ enjoy atomic visibility.
%\end{enumerate}
%The well-formedness condition reflects the fact that internal computations of threads that do not 
%result in an interaction with the database (i.e. resolution of non-deterministic choices, unfolding 
%of fixed point operators, pushing views) must always be allowed by the consistency model. 
%Obviously, any consistency model $CM$ can be strengthened to a well-formed one $\overline{CM}$.
%
%\ac{Ok, this is completely screwed. Atomic visibility clashes with the closure constraint that 
%views can be always pushed. The reason why we have the closure constraint is because, when 
%we define the rule for the parallel composition, we check that an action performed by a single 
%thread does not conflict with the views of other threads, and we always want local computation 
%of threads to be allowed. 
%One possible solution to this problem would be to first constrain all configurations to 
%those that enjoy atomic visibility. A second solution would be 
%to just assume atomic visibility for those transitions $(\hh, \mathcal{V}) \leadsto_{CM} 
%(\hh', \mathcal{V}')$ where $\hh \neq \hh'$. Both solutions are patches to a flawed 
%definition, and we don't do patches. I think the best strategy here would be that 
%of distinguishing between local computations $(\lambda)$ and database interactions 
%$(\delta)$ in the semantics, and define a parallel rule that checks for transitions allowed 
%by the consistency model, only when a thread performs a $\delta$ action. I am first 
%typing up the semantics as it is now, and then I will make the appropriate changes. 
% Actually screw it, I'm going to change the semantics immediately.}
%
%Given two multi-sets of views $\mathcal{V}_1, \mathcal{V}_2$, 
%we write $\mathcal{V}_1 \Subset \mathcal{V}_2$, if there is 
%a one-to-one mapping from $\mathsf{push}: \mathcal{V}_1 \rightarrow \mathcal{V}_2$ 
%such that for any $V \in \mathcal{V}_1$, $V_1 \sqsubseteq \mathsf{push}(V_1)$.
%\ac{Again, notation should be re-adapted to multisets}.
%
%In general we require a consistency model specification to be reflexive, 
%and to be closed with respect to pushing the views in the 
%state of the system: if $(\hh, \{V_1, \cdots, V_n\}) \leadsto 
%(\hh, \{V'_1, \cdots, V'_{n})\}$, and 
%
%For a given consistency model $CM$, quadruple $(\hh, \mathcal{V}) 
%\leadsto_{CM} (\hh', \mathcal{V}')$,  and set of views $\mathcal{V}''$, 
%we write $(\hh, \mathcal{V}) \bowtie_{\mathcal{V}''} (\hh', \mathcal{V}')$ 
%if $(\hh, \mathcal{V} \cup \mathcal{V}'') \leadsto_{CM} (\hh', \mathcal{V}' \cup \mathcal{V}'')$.
The last step we take is that of defining the operational semantics of 
programs.
To this end, we associate a thread stack and view to each parallel component (or thread) of the program. 
In practice, we define an environment $\mathsf{Env}$ to be 
a partial mapping $\mathsf{Env} : \tidset \rightharpoonup (\thdstackset \times \mathsf{Views})$ 
\ac{Set of Views and thread identifiers never introduced before.} 
Given two environments, $\mathsf{Env}_1, \mathsf{Env}_2$, we let 
$\mathsf{Env_1} \uplus \mathsf{Env}_2$ to be defined if 
$\dom(\mathsf{Env}_1) \cap \dom(\mathsf{Env}_2) = \emptyset$, 
in which case we have 
\[
(\mathsf{Env}_1 \uplus \mathsf{Env}_2)(\tid) = \begin{cases}
\mathsf{Env}_1(\tid) & \impliedby \tid \in \dom(\mathsf{Env}_1)\\
\mathsf{Env}_2(\tid) & \impliedby \tid \in \dom(\mathsf{Env}_2)\\
\text{undefined} & \impliedby \text{otherwise}
\end{cases}
\]

%For a program $\prog$ we define its set of views inductively as follows: 
%\[
%\begin{array}{lcl}
%\mathsf{Views}(\nil) &=& \emptyset \\
%\mathsf{Views}(V: \cmd \Par \prog) &=& V \cup \mathsf{Views}(\prog)
%\end{array}
%\]

Judgements in the operational semantics take the form 
%\[
%\infer{\langle \hh, \mathsf{Env}, \prog \rangle \xrightarrow{(V, \mathcal{V}, \mathcal{O})}_{CM} \langle \hh', \mathsf{Env}', \prog' \rangle}{}
%\]

\[
\infer{\langle \hh, \mathsf{Env}, \prog \rangle \xrightarrow{CM} \langle \hh', \mathsf{Env}', \prog' \rangle}{}
\]
\ac{The changes made to consistency model specifications simplify the semantics \textbf{a lot}. The rule of parallel 
composition becomes standard, and the only rule that now needs to take the consistency model into account 
should be the execution of a transaction in the semantics of commands.}

The rules for the operational semantics of programs are standard. We have three rules. One rule lifts transitions
 of commands to single-threaded programs.  The remaining two rules model the parallel composition of programs in 
 a standard, interleaving fashion.
\[
\infer[{\scriptstyle(P-thd-exec)}]{\langle \hh, \mathsf{Env}, \tid: \cmd \rangle \xrightarrow{CM} \langle \hh', \mathsf{Env}', \tid: \cmd' \rangle}
{
\begin{array}{c}
\mathsf{Env} = [\tid \mapsto (\sigma, V)] \qquad \langle \hh, \thdstack, V, \cmd \rangle \xrightarrow{CM} \langle \hh', \thdstack', V', \cmd' \rangle 
\qquad \mathsf{Env}' = [\tid \mapsto (\sigma', V')]\\
%\mathcal{O} \neq \emptyset \implies (\hh, V, \emptyset) \triangleright_{CM} \mathcal{O}
\end{array}
}
\]


%We first define how to lift the semantics of commands to programs. This results 
%in the following rule: 
%\[
%\infer[{\scriptstyle(P-thd-exec)}]{\langle \hh, \mathsf{Env}, \tid: \cmd \rangle \xrightarrow{(V, \emptyset, \mathcal{O})}_{CM} \langle \hh', \mathsf{Env}', \tid: \cmd' \rangle}
%{
%\begin{array}{c}
%\mathsf{Env} = [\tid \mapsto (\sigma, V)] \qquad \langle \hh, \thdstack, V, \cmd \rangle \xrightarrow{\mathcal{O}} \langle \hh', \thdstack', V', \cmd' \rangle 
%\qquad \mathsf{Env}' = [\tid \mapsto (\sigma', V')]\\
%\mathcal{O} \neq \emptyset \implies (\hh, V, \emptyset) \triangleright_{CM} \mathcal{O}
%\end{array}
%}
%\]
%Note the side condition $\mathcal{O} \neq \emptyset \implies (\hh, V, \emptyset) \triangleright_{CM} \mathcal{O}$ in the rule above. 
%This is were consistency models come into play. This side condition states that if performing a computation 
%in a command resulted in an interaction with the database $(\mathcal{O} \neq \emptyset)$, then such a computation 
%should be performed only if it is consistent with the consistency model specification ($(\hh, V, \emptyset) \triangleright_{CM} \mathcal{O}$).
%\ac{An alternative would be that of placing a well-formedness condition on consistency models, 
%and require that $(\hh, V, \mathcal{V}) \triangleright_{CM} \emptyset$ for any $\hh, V, \mathcal{V}$. 
%I don't really have a preference.}
%
%
%Finally, we need to define how to compose programs together. 
%Here the main idea is that computations that are valid for a 
%program $\prog_1$ are not necessarily valid anymore in 
%a composite program of the form $\prog_1 \Par \prog_2$. 
%This is because the views of the threads that constitute $\prog_2$ 
%may be conflicting with the thread performing a computation step in 
%$\prog_1$. We will give some examples of consistency models 
%that exhibit this behaviour in the next section. 

%Formally, given a transition of the form $(\hh, \mathcal{V}_1) 
%\leadsto (\hh, \mathcal{V}_1')$, and a set of views $\mathcal{V}_2$, 
%we write
%$\mathcal{V}_2 \Vdash (\hh, \mathcal{V}_1) \leadsto_{CM} 
%(\hh', \mathcal{V}_1')$ if whenever $(\hh, \mathcal{V}_1) 
%\leadsto_{CM} (\hh', \mathcal{V}_1)'$, then  
%$(\hh, \mathcal{V}_1 \uplus \mathcal{V}_2) \leadsto_{CM} (\hh', \mathcal{V}_1' \uplus \mathcal{V}_2')$. 
%\ac{I am pretty sure that for how the semantics is defined the premise of the implication 
%is always going to be valid, so we may choose to ditch it.}
%The rule for the parallel composition of programs is defined below: 
%\[
%\infer[{\scriptstyle (P-par-L)}]
%{\langle \hh, \mathsf{Env}_1 \uplus \mathsf{Env}_2, \prog_1 \Par \prog_2 \rangle 
%\xrightarrow{(V, \mathcal{V}_1 \uplus \mathcal{V}_2, \mathcal{O})}_{CM} \langle \hh', \mathsf{Env}_1' \uplus \mathsf{Env}_2, 
%\prog_1' \Par \prog_2 \rangle }
%{ \begin{array}{c}
%\langle \hh, \mathsf{Env}_1, \prog_1 \rangle \xrightarrow{(V, \mathcal{V}_1, \mathcal{O})}_{CM} \langle \hh', \mathsf{Env}_1', \prog_1' \rangle
%\qquad (\mathsf{Env_1} \uplus \mathsf{Env}_2)\downarrow \\ 
%\mathcal{V}_2 = \mathsf{Views}(\mathsf{Env}_2) \qquad 
%\mathcal{O} \neq \emptyset \implies (\hh, V, \mathcal{V}_1 \uplus \mathcal{V}_2 \triangleright_{CM} \mathcal{O}) 
%%\leadsto_{CM} (\hh', \mathsf{Views}(\mathsf{Env}_1')
%\end{array}
%}
%\]
\[
\infer[{\scriptstyle (P-par-L)}]
{\langle \hh, \mathsf{Env}_1 \uplus \mathsf{Env}_2, \prog_1 \Par \prog_2 \rangle 
\xrightarrow{CM} \langle \hh', \mathsf{Env}_1' \uplus \mathsf{Env}_2, 
\prog_1' \Par \prog_2 \rangle }
{ \begin{array}{c}
\langle \hh, \mathsf{Env}_1, \prog_1 \rangle \xrightarrow{CM} \langle \hh', \mathsf{Env}_1', \prog_1' \rangle
\qquad (\mathsf{Env_1} \uplus \mathsf{Env}_2)\downarrow
%\mathcal{V}_2 = \mathsf{Views}(\mathsf{Env}_2) \qquad 
%\mathcal{O} \neq \emptyset \implies (\hh, V, \mathcal{V}_1 \uplus \mathcal{V}_2 \triangleright_{CM} \mathcal{O}) 
%\leadsto_{CM} (\hh', \mathsf{Views}(\mathsf{Env}_1')
\end{array}
}
\]
\[
\infer[{\scriptstyle (P-par-R)}]
{\langle \hh, \mathsf{Env}_1 \uplus \mathsf{Env}_2, \prog_1 \Par \prog_2 \rangle 
\xrightarrow{CM} \langle \hh', \mathsf{Env}_1' \uplus \mathsf{Env}_2, 
\prog_1' \Par \prog_2 \rangle }
{ \begin{array}{c}
\langle \hh, \mathsf{Env}_2, \prog_2 \rangle \xrightarrow{CM} \langle \hh', \mathsf{Env}_2', \prog_2' \rangle
\qquad (\mathsf{Env_1} \uplus \mathsf{Env}_2)\downarrow
%\mathcal{V}_2 = \mathsf{Views}(\mathsf{Env}_2) \qquad 
%\mathcal{O} \neq \emptyset \implies (\hh, V, \mathcal{V}_1 \uplus \mathcal{V}_2 \triangleright_{CM} \mathcal{O}) 
%\leadsto_{CM} (\hh', \mathsf{Views}(\mathsf{Env}_1')
\end{array}
}
\]
\ac{Probably I need a check to require that $\dom(\mathsf{Env}_2) = \mathsf{threads}(\prog_2)$, 
where $\mathsf{threads}(\cdot)$ is the function that maps a program into its set of thread identifiers?}
%For programs, the main rule of the operational semantics is as follows: 
%\[
%\infer[{\scriptstyle{(C-Par)}}]
%{\langle \hh, \prog_1 \Par \prog_2 \rangle \xrightarrow{CM} \langle \hh', \prog_1' \Par \prog_2 \rangle }
%{\langle \hh, \prog_1 \rangle \xrightarrow{CM} \langle \hh', \prog_1' \rangle \qquad 
%(\hh, \mathsf{Views}(\prog_1)) \bowtie_{\mathsf{Views}(\prog_2)} (\hh', \mathsf{views}(\prog_1'))} 
%\]
%To do so, we introduce \emph{history heaps}.
%
%We assume countably infinite set of transaction identifiers $\TransID$, whose elements 
%are ranged over $\tsid$. Subsets of $\TransID$ are ranged over by $\T$. 
%A \emph{Version} is a triple 
%$(v, \tsid, \{\tsid_1, \tsid_2,\cdots\}) \in \Val \times \TransID \times 2^{\TransID}$. 
%The set of all versions is denoted by $\Versions$, and its elements are ranged over $\nu, \nu', \cdots$. 
%Intuitively, associating a location $[n]$ with the version $\nu = (v, \tsid, \{\tsid_1,\tsid_,\cdots\})$ means that the 
%value $v$ has been written for location $[n]$. The transaction that wrote version $\nu$ is $\tsid$, 
%and the version has been read by transactions $\{\tsid_1,\tsid_2,\cdots\}$. 
%Given a version $\nu := (v, \tsid, \T)$, we define $\valueof(\nu) = v$, $\WTx(\nu) := \tsid$, 
%and $\RTx(\nu) := \T$.
%A history heap is a function $\hh: \Addr \rightarrow \Versions^{\ast}$ that 
%maps each location to its list of versions. As usual, if 
%$\hh([n]) = \nu_1,\cdots, \nu_m$ for some location $[n]$, then for any 
%$i= 1,\cdots, m$ we let $\hh([n])(i) = \nu_i$. 
%
%Given a history heap $\hh$, we can extract several heaps 
%from it, by simply choosing for each location $[n]$ a version 
%contained in the list of versions available for $[n]$ in $\hh$, 
%namely $\hh([n])$. Formally, we define a \emph{snapshot} 
%to be a function $\snapshot: \Addr \rightarrow \mathbb{N}$; 
%given a history heap $\hh$ and a snapshot $\snapshot$, 
%we can construct the heap 
%\[
%\heap(\hh, \snapshot) = \lambda [n] \in \Addr. 
%\begin{cases}
%v_{\snapshot([n])} &\impliedby \hh([n]) = \langle v_0, \_ , \_ \rangle \cdots \langle v_{m}, \_, \_ \rangle \wedge m \geq \snapshot([n])\\
%\text{undefined} & \text{otherwise}
%\end{cases}
%\]
%
%We use history heaps to model the global, shared state of all threads in multi-threaded programs. 
%However, each thread will have a local view of the history heap, which is induced by the 
%snapshot of the history heap that it observes. 
%Formally, judgements in the operational semantics of programs take the form 
%\[
%\langle \hh, (\snapshot_1, \cdots, \snapshot_n), (\thdstack_1,\cdots,\thdstack_n) \cmd_1 \Par \cdots \Par \cmd_n), \rangle
%\rightarrow \langle \hh', (\snapshot'_1, \cdots, \snapshot'_{n}), (\thdstack_1' , \cdots, \thdstack_n'), (\cmd'_1 \Par \cdots \Par \cmd'_n) \rangle
%\]
%\ac{Note that here we are exploiting the fact that programs have a rigid structure, with 
%no creation of dynamic threads. Honestly, I never understood what all the fuzz about 
%having dynamic thread creation was, since it seems that whether we have static or dynamic 
%thread creation, is irrelevant to the discussions we had thus far.}
%
%The rules for the operational semantics of programs will be parametric in the specification 
%of a consistency model. The specification of a consistency model describes which change 
%of states are allowed by programs. I.e. the specification of a consistency model is a 
%set of quadruples $(\hh, \snapshot, \hh', \snapshot')$. Given a consistency model 
%specification $\mathsf{CM}$, we write $(\hh, \snapshot) \leadsto_{\mathsf{CM}} 
%(\hh', \snapshot')$ in lieu of $(\hh, \snapshot, \hh', \snapshot') \in \mathsf{CM}$.
%
%Making a command progress in a program may result in the former producing a set of operations, 
%or fingerprint, which contributes to the evolution of the history heap. 
%\[
%\begin{array}{lll}
%\mathsf{append}_{T}(\hh, \snapshot, \{\RD\;[n]: m\}) &=& 
%\lambda [k].\begin{cases}
%\langle v_0, T_{0}, \T_{0} \rangle \cdots \langle v_i, T_{i}, \T_{i} \cup \{T\} \rangle \cdots \langle v_{n_{k}}, T_{n_{k}}, \T_{n_{k}} \rangle\\
%\hspace{5pt} \text{if } [k] = [n] \wedge \snapshot([k]) = i &\\
%\hh([k]) \hspace{5pt} \text{otherwise}
%\end{cases}\\
%\mathsf{append}_{T}(\hh, \_, \{\WR\; [n]: m\}) &=& 
%\hh[ [n] \mapsto ( \hh([n]) \cdot \langle m, T, \emptyset \rangle) ]\\
%\mathsf{append}_{T}(\hh, \snapshot, \mathcal{O}_1 \cup \mathcal{O}_2) &=& 
%\mathsf{append}_{T}(\mathsf{append}_{T}(\hh, \snapshot, \mathcal{O}_1), \snapshot, \mathcal{O}_2)
%\end{array}
%\]
%Furthermore, if executing a command under snapshot $\snapshot$ results in producing the fingerprint $\mathcal{O}$, 
%then we must also update the snapshot of the thread executing the command by including the versions 
%written by $\mathcal{O}$; formally, we define the function 
%\[
%\begin{array}{lll}
%\mathsf{update}(\hh, \snapshot, \mathsf{RD}\;[n]: m) &=& \snapshot\\
%\mathsf{update}(\hh, \snapshot, \mathsf{WR}\;[n]: m) &=& \snapshot[ [n] \mapsto \lvert \hh([n]) \rvert -1 ]\\
%\mathsf{update}(\hh, \snapshot, \mathcal{O}_1 \cup \mathcal{O}_2) &=& \mathsf{update}(\hh, \mathsf{update}(\hh, \snapshot, \mathcal{O}_1), \mathcal{O}_2)
%\end{array}
%\]
%
%The operational semantics of programs includes two rules: one for advancing the snapshot in 
%a session, as long as the snapshot policy is satisfied, and another for progressing commands 
%that constitute the program. Below we use $\mathcal{S}$ to denote a tuple of snapshots, 
%and $\mathcal{S}(i)$ to denote the $i$-th component of such a tuple. Similarly, $\Sigma$ 
%denotes a tuple of thread stacks. In the rules below, we assume that the arity of such tuples matches 
%the one of program components.
%
%\[
%\infer[P-Exec]{
%\langle \hh, \mathcal{S}, \Sigma, \cmd_1 \Par \cdots \Par \cmd_i \Par \cdots \Par \cmd_{n} \rangle
%\xrightarrow{\mathsf{CM}} \langle \hh', 
%\mathcal{S}[i \mapsto \snapshot'], \Sigma[i \mapsto \thdstack'], \cmd_1 \Par \cdots \Par \cmd_i' \Par \cdots \Par \cmd'_n \rangle
%}
%{
%\begin{array}{l}
%h = \heap(\hh, \mathcal{S}(i)) \qquad
%h \vdash \langle \Sigma(i), \cmd_i \rangle  \rightarrow \langle \thdstack', \mathcal{O}, \cmd_i' \rangle \qquad 
%(\hh, \mathcal{S}) \leadsto_{\mathsf{CM}} (\hh', \mathcal{S}[i \mapsto \snapshot']) \\
%\hh' = \mathsf{append}_{T}(\hh, \mathcal{S}(i), \mathcal{O}) \qquad T \text{ does not appear in } \hh 
%\qquad \snapshot' = \mathsf{update}(\mathcal{S}(i), \mathcal{O})\\
%\end{array}
%}
%\]
%
%\[
%\infer[S-update]{
%\langle \hh, \mathcal{S}, \Sigma, \prog \rangle \xrightarrow{\mathsf{CM}} \langle \hh, \mathcal{S}[i \mapsto \snapshot], \Sigma, \prog \rangle
%}
%{
%\mathcal{S}(i) \sqsubseteq \snapshot
%}
%\]
%
%\section{Examples of Specifications of Consistency Models}
%
%
%\section{Comparing Different Specifications of Consistency Models}
%To compare different specifications of consistency models, we adopt 
%a black-box testing approach, similar in style to the one proposed by Hennessy 
%and de Nicola \cite{hdn84} for concurrent processes. 
%
%We assume that primitive commands contain a special element $\thick$, with empty state transformer. 
%We say that a program is successful, denoted $\mathsf{successful}(P)$, if it contains an unguarded occurrence of the $\thick$ command. 
%Formally, we define $\mathsf{successful}(P)$ inductively on the syntax of programs as follows: 
%\[
%\begin{array}{lll}
%\mathsf{successful}(\nil) &=& \ffalse\\
%\mathsf{successful}(\thick) &=& \ttrue\\
%\mathsf{successful}(c) &=& \ffalse \hspace{5pt} \text{ if } c \neq \thick\\
%\mathsf{successful}([\trans]) &=& \ffalse\\
%\mathsf{successful}(X) &=& \ffalse\\
%\mathsf{successful}(\cmd_1 + \cmd_2) &=& \mathsf{successful}(\cmd_1) \vee \mathsf{successful}(\cmd_2)\\
%\mathsf{successful}(\mu X.\cmd) &=& \ffalse\\
%\mathsf{successful}(\cmd \Par \prog) &=& \mathsf{successful}(\cmd) \vee \mathsf{successful}(\prog)
%\end{array}
%\]
%
%We say that a program $\prog$ may-pass under the consistency model specification $\CM$, 
%written $\prog \maypass\; \CM$, if there exists a computation fragment 
%\[ 
%\langle \hh_{0}, \mathcal{S}_0, \Sigma_0, \prog_0 \rangle \xrightarrow{\CM} \cdots \xrightarrow{\CM} \langle \hh_{n}, \mathcal{S}_n, \Sigma_n, \prog_n \rangle,
%\]
%such that $\hh_{0} = \lambda [m]. \langle 0, T_0, \emptyset \rangle$, $\mathcal{S}_0 = \lambda [m].0$, $\Sigma_0 = \langle \thdstack_0, \cdots, \thdstack_0$ 
%and $\thdstack_0 = \lambda x. 0$, $\prog_0 = \prog$, and $\mathsf{successful}(\prog_{n})$. 
%
%\begin{definition}
%Given two consistency model specifications $\CM_1, \CM_2$, we say that 
%$\CM_1$ is \emph{(weakly) stronger than} $\CM_2$, written $\CM_1 \sqsubseteq \CM_2$, if for all program $\prog$, 
%\[
%\CM_1 \maypass\; \prog \implies \CM_2 \maypass\;\prog
%\]
%\end{definition}
%\bibliographystyle{abbrv}
%\ac{This notion of equivalence is based on the observations made by clients, in contrast to other 
%notion of history equivalences found in the literature - conflict equivalence, history equivalence, view equivaence, $\cdots$, 
%which are way too fine-grained for our purposes.}
%\bibliography{bibliography2}

\subsection{Operational Semantics: Example} 
\label{sec:semantics.example}
To conclude our discussion on the operational semantics, 
we show in detail one possible computation of a program consisting 
of two transactions executing in parallel.  
The program $\prog_1$ that we consider is illustrated below: 
\[
    \begin{session}
        \begin{array}{@{}c || c@{}}
            \begin{transaction}
            		 \pmutate{\loc_x}{1};\\
            		 \pmutate{\loc_y}{1};
              \end{transaction} &
              \begin{transaction}
            		\pderef{\pvar{a}}{\loc_x};\\
            		\pderef{\pvar{b}}{\loc_y};\\
            		\pifs{\pvar{a}=1 \wedge \pvar{b}=0}\\
            			\;\;\;\;\passign{\retvar}{\Large \frownie{}}
            	    \}
             \end{transaction}
        \end{array}
    \end{session}
 \]
Note also that we omitted thread identifiers for commands in $\prog_1$. In general,  
we often write $\cmd_1 \Par \cdots \Par \cmd_n$ as a shorthand for $\tid_1: \cmd_1 \Par \cdots \Par
\tid_n: \cmd_n$. 

The program $\prog_1$ contains a special symbol ${\Large \frownie{}}$ which can be 
returned by the transaction of $\tid_2$. 
In practice, this can be an arbitrary fixed value that can be returned by a transaction. 
However, by using the symbol ${\Large \frownie{}}$ as the return value for the transaction, 
we want to emphasize the fact that the transaction exhibited some undesirable behaviour. In 
this case, the undesirable behaviour corresponds to the transaction on the right hand side 
observing only one of the updates that can be executed by the transaction on the left hand side. 

Although this behaviour clearly violates the constraints that transactions should be executed atomically, 
we show that if no restrictions are placed on the consistency model specification, 
it is possible to execute $\prog_1$ and reach a configuration where the transaction executed by 
$\tid_2$ returns ${\Large \frownie{}}$. To this end, let $CM$ be the most permissive 
consistency model, i.e. the one such that
% $(\hh, V, \mathcal{V}) \triangleright_{CM} \mathcal{O}$ for any 
%$\hh, V, \mathcal{V}, \mathcal{O}$. 
$(\hh, V) \triangleright_{CM} \mathcal{O} : V'$ for any $\hh, V, \mathcal{O}, V'$ 
such that $\mathsf{UpdateVies}(\hh, V, \mathcal{O}) \sqsubseteq V'$.
\ac{The condition on $V'$ is not really needed.}

\begin{figure}
\begin{center}
\begin{tabular}{|@{}c|c@{}|}
\hline
\begin{tikzpicture}[font=\large]

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) at (1,3) {$[\loc_x] \mapsto$};

\matrix(locxcells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locx.east) {
 {a} & $T_0$ \\
  {a} & $\emptyset$ \\
};
\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
%\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};

%Location y
\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
\matrix(locycells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locy.east) {
 {a} & $T_0$ \\
  {a} & $\emptyset$ \\
};
\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
%\node[version node, fit=(locycells-1-3) (locycells-2-3), fill=white, inner sep=0cm, font=\Large] (locy-v1) {$1$};

% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
 ([xshift=-3pt, yshift=20pt]locx-v0.north east) node (tid1start) {} -- 
% ([xshift=-2pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-2pt, yshift=5pt]locy-v0.north east) -- 
 ([xshift=-3pt, yshift=-5pt]locy-v0.south east);
 
 \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_1$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
 ([xshift=-16pt, yshift=5pt]locx-v0.north east) node (tid2start) {}-- 
% ([xshift=-8pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-8pt, yshift=5pt]locy-v0.north east) -- 
 ([xshift=-16pt, yshift=-5pt]locy-v0.south east) node {};
 
\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\tid_2$};

%Stack for threads tid_1 and tid_2

\draw[-, dashed] let 
   \p1 = ([xshift=0pt]locy.west),
   \p2 = ([yshift=-5pt]locycells.south),
   \p3 = ([xshift=10pt]locycells.east) in
   (\x1, \y2) -- (\x3, \y2);
   
\matrix(stacks) [
   matrix of nodes,
   anchor=north, 
   text=blue, 
   font=\normalsize, 
   row 1/.style = {text = blue}, 
   row 2/.style = {text = red}, 
   text width= 13mm ] 
   at ([xshift=-10pt,yshift=-8pt]locycells.south) {
   $\tid_1:$ & $\retvar = 0$\\
   $\tid_2:$ & $\retvar = 0$\\
   };
\end{pgfonlayer}
\end{tikzpicture} 
&
\begin{tikzpicture}[font=\large]

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) at (1,3) {$[\loc_x] \mapsto$};

\matrix(locxcells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locx.east) {
 {a} & $T_0$ &{a} & $T_1$\\
  {a} & $\emptyset$ & {a} & $\emptyset$ \\
};
\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};

%Location y
\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
\matrix(locycells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locy.east) {
 {a} & $T_0$ & {a} & $T_1$\\
  {a} & $\emptyset$ & {a} & $\emptyset$ \\
};
\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
\node[version node, fit=(locycells-1-3) (locycells-2-3), fill=white, inner sep=0cm, font=\Large] (locy-v1) {$1$};

% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
 ([xshift=-3pt, yshift=20pt]locx-v1.north east) node (tid1start) {} -- 
% ([xshift=-2pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-2pt, yshift=5pt]locy-v0.north east) -- 
 ([xshift=-3pt, yshift=-5pt]locy-v1.south east);
 
 \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_1$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
 ([xshift=-16pt, yshift=5pt]locx-v0.north east) node (tid2start) {}-- 
% ([xshift=-8pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-8pt, yshift=5pt]locy-v0.north east) -- 
 ([xshift=-16pt, yshift=-5pt]locy-v0.south east) node {};
 
\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\tid_2$};

%Stack for threads tid_1 and tid_2

\draw[-, dashed] let 
   \p1 = ([xshift=0pt]locy.west),
   \p2 = ([yshift=-5pt]locycells.south),
   \p3 = ([xshift=10pt]locycells.east) in
   (\x1, \y2) -- (\x3, \y2);
   
\matrix(stacks) [
   matrix of nodes,
   anchor=north, 
   text=blue, 
   font=\normalsize, 
   row 1/.style = {text = blue}, 
   row 2/.style = {text = red}, 
   text width= 13mm ] 
   at ([xshift=-10pt,yshift=-8pt]locycells.south) {
   $\tid_1:$ & $\retvar = 0$\\
   $\tid_2:$ & $\retvar = 0$\\
   };
\end{pgfonlayer}
\end{tikzpicture}

\\
{\small (a) } & {\small (b)}\\
\hline
\end{tabular}
\end{center}
\label{fig:opsem.example}
\caption{Graphical Representation of configurations 
obtained through the execution of $\prog_1$.}
\end{figure}

Before showing the computation of $\prog_1$ that leads to the transaction of 
$\tid_2$ to return ${\Large \frownie{}}$, we need to introduce some 
definitions and  notation.
The initial configuration in which $\prog_1$ is executed is the one in which 
each location has an initial version written by some initialisation transaction $\tsid_0$, 
the view of each thread points to the initial version of each location, and all the  
thread stacks are initialised to $0$. Assuming that the only key in the database 
are $[\loc_x], [\loc_y]$, and the only variable in the thread stack is $\retvar$, 
the initial configuration is then given by $\mathcal{C}_0 = (\hh_{0}, \mathsf{Env}_0)$, 
where $\hh_{0}([\loc_{x}) = \hh_{0}([\loc_y]) =  (0, \tsid_0, \emptyset)$,  
$\mathsf{Env}_0(\tid_1) = \mathsf{Env}_0(\tid_2) = ([\retvar \mapsto 0], V_0)$, 
and $V_0([\loc_{x}]) = V_0([\loc_{y}]) = 0$. Here and in the following, we prefer 
to adopt a more graphical notation for configurations. For example, the initial configuration 
defined is represented graphically in Figure \ref{fig:opsem.example}(a). 
%
%\begin{center}
%\begin{tikzpicture}[font=\large]
%\node (locx) {$[\loc_x] \mapsto$};
%\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
%\path (locx.east) + (0.5,0)  node (locx0) {$0$};
%\path (locx0.north east) + (0.4,0) node[font=\small] (locx0ws) {$\tsid_0$};
%\path (locx0.south east) + (0.4,0) node[font=\small] (locx0rs) {$\emptyset$};
%\path (locy.east) + (0.5,0)  node (locy0) {$0$};
%\path (locy0.north east) + (0.4,0) node[font=\small] (locy0ws) {$\tsid_0$};
%\path (locy0.south east) + (0.4,0) node[font=\small] (locy0rs) {$\emptyset$};
%
%\path (locy.south west) + (-0.7, -0.6) node (dashlinestart) {};
%\path (dashlinestart.center) + (5, 0) node (dashlineend) {};
%
%\path(locy0.south) + (0,-1) node[font = \small, text=red] (tid1ret) {$\tid_1: \retvar = 0$};
%\path(tid1ret.south) + (0,-0.3) node[font= \small, text=blue] (tid2ret) {$\tid_2: \retvar = 0$};
%
%\begin{pgfonlayer}{background}
%
%\path[-, dashed, thick] (dashlinestart.center) edge (dashlineend.center);
%
%\node[hheapcell, fit=(locx0) (locx0ws) (locx0rs)] (locx0cell) {};
%\node[hheapcell, fit=(locy0) (locy0ws) (locy0rs)] (locy0cell) {};
%
%\path[-]
%(locx0cell.north) edge (locx0cell.south)
%(locx0cell.center) edge (locx0cell.east)
%(locy0cell.north) edge (locy0cell.south) 
%(locy0cell.center) edge (locy0cell.east);
%
%\path(locx0cell.north) + (-0.5, 0.2) node(v1beforex) {};
%\path(locx0cell.south) + (-0.5, -0.1) node(v1afterx) {};
%\path(locy0cell.north) + (-0.5, 0.1) node(v1beforey) {};
%\path(locy0cell.south) + (-0.5, -0.2) node(v1aftery) {};
%\path(v1beforex.center) + (-0.25,0.15) node[font=\normalsize, text=red] (t1) {$\tid_1$};
%
%\path[-, draw=red!80, very thick]
% (v1beforex.center) edge (v1afterx.center)
% (v1afterx.center) edge (v1beforey.center)
% (v1beforey.center) edge (v1aftery.center);
% 
% \path(locx0cell.north) + (-0.1, 0.2) node(v2beforex) {};
%\path(locx0cell.south) + (-0.1, -0.1) node(v2afterx) {};
%\path(locy0cell.north) + (-0.1, 0.1) node(v2beforey) {};
%\path(locy0cell.south) + (-0.1, -0.2) node(v2aftery) {};
%\path(v1beforex.center) + (0.6,0.15) node[font=\normalsize, text=blue] (t2) {$\tid_2$};
%
%\path[-, draw=blue!80, very thick]
% (v2beforex.center) edge (v2afterx.center)
% (v2afterx.center) edge (v2beforey.center)
% (v2beforey.center) edge (v2aftery.center);
% 
%\end{pgfonlayer}
%\end{tikzpicture}
%\end{center}
In the picture above, the part above the dashed line represents the history heap and 
view of each thread, while the part below the dashed line contains the thread-stack 
of each thread. History heaps are represented as mappings to locations to lists of cells, 
each of which represents a version and has three component: the value of the version 
to the left, the identifier of the transaction that wrote it to the top right, and the 
set of transactions that read the version to the bottom right. Vertical lines labelled 
with thread identifiers are used to represent the views. The position of the view of 
thread $\tid_1$ relatively to the location $[\loc_x]$ is determined by the version 
at which the vertical line labelled $\tid_1$ crosses the list of versions for $[\loc_x]$,
 and similarly for $[\loc_y]$.

We are now ready to show how to derive the computation of $\prog_1$ that 
violates atomic visibility. First, we reduce the transaction of the thread 
to the left hand side, $\tid_1$. According to rule $(Tx-exec)$, we need to 
perform the following steps: 
\begin{itemize}
\item shift the view $V_0$ for thread $\tid_1$, in $\hh_0$, to the right of an arbitrary amount 
of positions for each location, and obtain a view $V' : V_0 \sqsubseteq V$. Because $\hh_0$ contains 
only  one version for each location, here the only possibility is that $V' = V_0$.
\item Determine the heap $h = \snapshot(\hh_0, V')$ in which thread $\tid_1$ executes the transaction. 
In this case, we have that $h = [ [\loc_x \mapsto 0, \loc_y \mapsto 1]]$. 
\item Determining the fingerprint $\mathcal{O}$ of the transaction executed by $\tid_1$, whose code is
 \[
            \begin{transaction}
            		 \pmutate{\loc_x}{1};\\
            		 \pmutate{\loc_y}{1};
              \end{transaction}
 \]
 This amounts to execute the transaction in isolation from the external environment, using the rules in the operational semantics for 
 transactions. Because this execution must match the premiss of Rule $(C-Tx)$,  The code is run using $h$ as the initial heap, $\sigma_0$ as the initial 
 thread stack, $\tau_0 = \lambda_a.0$ as the initial transaction stack, and $\emptyset$ as the 
 initial fingerprint. We only need to apply 
 Rule $(Tx-prim)$ twice, in which case we obtain
 \begin{equation}
\label{eq:tx1}
\begin{array}{llcll}
&\left\langle h_0, \_, \emptyset, \begin{array}{l}
\pmutate{\loc_x}{1};\\ \pmutate{\loc_y}{1} \end{array} \right\rangle 
&\rightarrow& \left \langle h_0[ [\loc_x] \mapsto 1], \_, \emptyset \oplus \WR\; [\loc_x]: 1, 
\pmutate{\loc_y}{1} \right\rangle &= \\
=&\left \langle h_0[[\loc_x] \mapsto 1], \_, \{\WR\; [\loc_x]: 1\}, 
\pmutate{\loc_y}{1} \right\rangle 
&\rightarrow& 
\left\langle h_0[[\loc_x \mapsto_1, \loc_y \mapsto 1], \_, \begin{array}{c} \{\WR\;[\loc_x]:1\} \oplus\\  (\WR\;[\loc_y]: 1) \end{array}, 
\nil \right\rangle & = \\
=&\left \langle \_, \_, \{\WR\;[\loc_x]: 1, \WR\;[\loc_y]:1 \}, \nil \right\rangle
\end{array}
\end{equation}
Therefore, we conclude $\mathcal{O} = \{\WR\; [\loc_x] : 1, \WR\;[\loc_y]:1\}$.
\item Determine the history heap and view $\hh_1, V''$ obtained by applying the 
functions $\mathsf{HHeapUpdate}(\hh_0, V', \mathcal{O})$ and  $\mathsf{ViewUpdate}(\hh_0, V', 
mathcal{O})$, respectively. This result in the history heap $\hh_1$ and view $V_1$, depicted in 
Figure \ref{fig:opsem.example}(b) - the view $V'$ is the one labelled with $\tid_1$.
\item Shift  $V'''$ such that $V'' \sqsubseteq V'''$, and $(\hh_0, V') \triangleright_{CM} \mathcal{O} : V'''$. 
The only possibility here is by choosing $V'' = V'''$,
\item Combine all the steps above, and infer the transition $\mathcal{C}_0, \prog_0 \xrightarrow{CM} 
\mathcal{C}_1, \prog_0' \rangle$, where $\mathcal{C}_1$ is depicted in Figure \ref{fig:cc.exec} 
and 
\[
\prog_1' = 
    \begin{session}
        \begin{array}{@{}c || c@{}}
            \nil &
              \begin{transaction}
            		\pderef{\pvar{a}}{\loc_x};\\
            		\pderef{\pvar{b}}{\loc_y};\\
            		\pifs{\pvar{a}=1 \wedge \pvar{b}=0}\\
            			\;\;\;\;\passign{\retvar}{\Large \frownie{}}
             \end{transaction}
        \end{array}
    \end{session}
\]
\end{itemize}
%
%is only one version for both 
%first need 
%to determine the snapshot obtained from the history heap $\hh_{0}$ and the 
%view $V_0$ of $\tid_1$: this snapshot corresponds to the heap $h_0 = [ [\loc_x] \mapsto 0, 
%[\loc_y] \mapsto 0]$. Note that $h_0$ can be determined easily from the graphical 
%representation of $\mathcal{C}_0$, by simply looking at the value of the versions at 
%which the view of $\tid_1$ intersects the list of versions of the respective location.
%Once the heap $h_0$ has been determined, we determine the fingerprint of the 
%transaction of $\tid_1$ by running it under the heap $h_0$. By applying twice Rule 
%$(prim-t-fp)$ we obtain the following derivation: 
%\begin{equation}
%\label{eq:tx1}
%\begin{array}{llcll}
%&\left\langle h_0, \_, \emptyset, \begin{array}{l}
%\pmutate{\loc_x}{1};\\ \pmutate{\loc_y}{1} \end{array} \right\rangle 
%&\rightarrow& \left \langle h_0[ [\loc_x] \mapsto 1], \_, \emptyset \oplus \WR\; [\loc_x]: 1, 
%\pmutate{\loc_y}{1} \right\rangle &= \\
%=&\left \langle h_0[[\loc_x] \mapsto 1], \_, \{\WR\; [\loc_x]: 1\}, 
%\pmutate{\loc_y}{1} \right\rangle 
%&\rightarrow& 
%\left\langle h_0[[\loc_x \mapsto_1, \loc_y \mapsto 1], \_, \begin{array}{c} \{\WR\;[\loc_x]:1\} \oplus\\  (\WR\;[\loc_y]: 1) \end{array}, 
%\nil \right\rangle & = \\
%=&\left \langle \_, \_, \{\WR\;[\loc_x]: 1, \WR\;[\loc_y]:1 \}, \nil \right\rangle
%\end{array}
%\end{equation}
%We can now apply rules $(tx-exec), (p-thd-exec)$ and $(p-par-L)$, in this order, 
%to infer how the computation given in \eqref{eq:tx1} affects the whole program $\prog_1$. Here the most important 
%derivation is the one obtained by applying rule $(tx-exec)$. This rule, in fact, states that the history 
%heap $\hh_0$ and the view $V_0$ of $\tid_1$ must be updated to reflect the effects of the 
%transaction $\hh_1$. This leads to a history heap $\hh_1$ where a new version is appended for 
%both locations $\loc_x, \loc_y$. The view of $\tid_1$ is also updated as to point to the versions 
%that the thread $\tid_1$ just installed for the locations $\loc_1, \loc_2$. According to rule 
%$(p-par-L)$, the view of the thread $\tid_2$ is left unchanged by executing a transaction in $\tid_1$. 
%This leads to the transition $\langle \mathcal{C}_0, \prog_1 \rangle \xrightarrow{\_}_{CM} \langle 
%\mathcal{C}_1, \prog_1' \rangle$, which is depicted below: 
%\begin{center}
%\begin{tikzpicture}[font=\large]
%\begin{pgfonlayer}{foreground}
%\node (locx) {$[\loc_x] \mapsto$};
%\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
%\path (locx.east) + (0.5,0)  node (locx0) {$0$};
%\path (locx0.north east) + (0.4,0) node[font=\small] (locx0ws) {$\tsid_0$};
%\path (locx0.south east) + (0.4,0) node[font=\small] (locx0rs) {$\emptyset$};
%\path (locy.east) + (0.5,0)  node (locy0) {$0$};
%\path (locy0.north east) + (0.4,0) node[font=\small] (locy0ws) {$\tsid_0$};
%\path (locy0.south east) + (0.4,0) node[font=\small] (locy0rs) {$\emptyset$};
%
%\path (locy.south west) + (0, -0.6) node (dashlinestart) {};
%\path (dashlinestart.center) + (3.5, 0) node (dashlineend) {};
%
%\path(locy0.south) + (0,-1) node[font = \small, text=red] (tid1ret) {$\tid_1: \retvar = 0$};
%\path(tid1ret.south) + (0,-0.3) node[font= \small, text=blue] (tid2ret) {$\tid_2: \retvar = 0$};
%\end{pgfonlayer}
%
%\begin{pgfonlayer}{main}
%
%\path[-, dashed, thick] (dashlinestart.center) edge (dashlineend.center);
%
%\node[hheapcell, fill=white, fit=(locx0) (locx0ws) (locx0rs)] (locx0cell) {};
%\node[hheapcell, fill=white, fit=(locy0) (locy0ws) (locy0rs)] (locy0cell) {};
%
%\path[-]
%(locx0cell.north) edge (locx0cell.south)
%(locx0cell.center) edge (locx0cell.east)
%(locy0cell.north) edge (locy0cell.south) 
%(locy0cell.center) edge (locy0cell.east);
%
%\path(locx0cell.north) + (-0.5, 0.2) node(v1beforex) {};
%\path(locx0cell.south) + (-0.5, -0.1) node(v1afterx) {};
%\path(locy0cell.north) + (-0.5, 0.1) node(v1beforey) {};
%\path(locy0cell.south) + (-0.5, -0.2) node(v1aftery) {};
%\path(v1beforex.center) + (-0.25,0.15) node[font=\normalsize, text=red] (t1) {$\tid_1$};
%
%\path[-, draw=red!80, very thick]
% (v1beforex.center) edge (v1afterx.center)
% (v1afterx.center) edge (v1beforey.center)
% (v1beforey.center) edge (v1aftery.center);
% 
% \path(locx0cell.north) + (-0.1, 0.2) node(v2beforex) {};
%\path(locx0cell.south) + (-0.1, -0.1) node(v2afterx) {};
%\path(locy0cell.north) + (-0.1, 0.1) node(v2beforey) {};
%\path(locy0cell.south) + (-0.1, -0.2) node(v2aftery) {};
%\path(v2beforex.center) + (0.2,0.15) node[font=\normalsize, text=blue] (t2) {$\tid_2$};
%
%\path[-, draw=blue!80, very thick]
% (v2beforex.center) edge (v2afterx.center)
% (v2afterx.center) edge (v2beforey.center)
% (v2beforey.center) edge (v2aftery.center);
%\end{pgfonlayer}
%
%\begin{pgfonlayer}{background}
%\node[background, fill=yellow!20, fit= (t1) (t2) (dashlinestart) (dashlineend) (tid1ret) (tid2ret), inner sep=0.05cm] (c1) {};
%\end{pgfonlayer}
%
%\path(c1.east) + (0.8,0)  node [font=\Huge] (p1) {{}, $\prog_1$};
%\path(p1.east) + (0.5,0) node[font=\Huge] (arrow) {${}\xrightarrow{\_}$};
%
%\begin{pgfonlayer}{foreground}
%\path (locx.east) + (6, 0) node (locxf) {$[\loc_x] \mapsto$};
%\path (locxf.south) + (0,-1.5) node (locyf) {$[\loc_y] \mapsto$};
%\path (locxf.east) + (0.5,0)  node (locxf0) {$0$};
%\path (locxf0.north east) + (0.4,0) node[font=\small] (locxf0ws) {$\tsid_0$};
%\path (locxf0.south east) + (0.4,0) node[font=\small] (locxf0rs) {$\emptyset$};
%\path(locxf0.east) + (1.135,0) node (locxf1) {$1$};
%\path (locxf1.north east) + (0.4,0) node[font=\small] (locxf1ws) {$\tsid_1$};
%\path (locxf1.south east) + (0.4,0) node[font=\small] (locxf1rs) {$\emptyset$};
%\path (locyf.east) + (0.5,0)  node (locyf0) {$0$};
%\path (locyf0.north east) + (0.4,0) node[font=\small] (locyf0ws) {$\tsid_0$};
%\path (locyf0.south east) + (0.4,0) node[font=\small] (locyf0rs) {$\emptyset$};
%\path(locyf0.east) + (1.13,0) node (locyf1) {$1$};
%\path (locyf1.north east) + (0.4,0) node[font=\small] (locyf1ws) {$\tsid_1$};
%\path (locyf1.south east) + (0.4,0) node[font=\small] (locyf1rs) {$\emptyset$};
%
%\path (locyf.south west) + (0, -0.6) node (dashlinestartf) {};
%\path (dashlinestartf.center) + (4.5, 0) node (dashlineendf) {};
%
%\path(locyf0.south) + (0,-1) node[font = \small, text=red] (tidf1ret) {$\tid_1: \retvar = 0$};
%\path(tidf1ret.south) + (0,-0.3) node[font= \small, text=blue] (tidf2ret) {$\tid_2: \retvar = 0$};
%\end{pgfonlayer}
%
%\begin{pgfonlayer}{main}
%
%\path[-, dashed, thick] (dashlinestartf.center) edge (dashlineendf.center);
%
%\node[hheapcell, fill=white, fit=(locxf0) (locxf0ws) (locxf0rs)] (locxf0cell) {};
%\node[hheapcell, fill=white, fit=(locyf0) (locyf0ws) (locyf0rs)] (locyf0cell) {};
%\node[hheapcell, fill=white, fit=(locxf1) (locxf1ws) (locxf1rs)] (locxf1cell) {};
%\node[hheapcell, fill=white, fit=(locyf1) (locyf1ws) (locyf1rs)] (locyf1cell) {};
%
%\path[-]
%(locxf0cell.north) edge (locxf0cell.south)
%(locxf0cell.center) edge (locxf0cell.east)
%(locyf0cell.north) edge (locyf0cell.south) 
%(locyf0cell.center) edge (locyf0cell.east)
%(locxf1cell.north) edge (locxf1cell.south)
%(locxf1cell.center) edge (locxf1cell.east)
%(locyf1cell.north) edge (locyf1cell.south) 
%(locyf1cell.center) edge (locyf1cell.east);
%
%\path(locxf1cell.north) + (-0.5, 0.2) node(vf1beforex) {};
%\path(locxf1cell.south) + (-0.5, -0.1) node(vf1afterx) {};
%\path(locyf1cell.north) + (-0.5, 0.1) node(vf1beforey) {};
%\path(locyf1cell.south) + (-0.5, -0.2) node(vf1aftery) {};
%\path(vf1beforex.center) + (0.25,0.15) node[font=\normalsize, text=red] (tf1) {$\tid_1$};
%
%\path[-, draw=red!80, very thick]
% (vf1beforex.center) edge (vf1afterx.center)
% (vf1afterx.center) edge (vf1beforey.center)
% (vf1beforey.center) edge (vf1aftery.center);
% 
% \path(locxf0cell.north) + (-0.1, 0.2) node(vf2beforex) {};
%\path(locxf0cell.south) + (-0.1, -0.1) node(vf2afterx) {};
%\path(locyf0cell.north) + (-0.1, 0.1) node(vf2beforey) {};
%\path(locyf0cell.south) + (-0.1, -0.2) node(vf2aftery) {};
%\path(vf2beforex.center) + (-0.1,0.15) node[font=\normalsize, text=blue] (tf2) {$\tid_2$};
%
%\path[-, draw=blue!80, very thick]
% (vf2beforex.center) edge (vf2afterx.center)
% (vf2afterx.center) edge (vf2beforey.center)
% (vf2beforey.center) edge (vf2aftery.center);
%\end{pgfonlayer}
%
%\begin{pgfonlayer}{background}
%\node[background, fill=yellow!20, fit= (tf1) (tf2) (dashlinestartf) (dashlineendf) (tidf1ret) (tidf2ret), inner sep=0.05cm] (c2) {};
%\end{pgfonlayer}
%\path(c2.east) + (0.8,0)  node [font=\Huge] (p2) {{}, $\prog_1'$};
%
%\end{tikzpicture}
%\end{center}
%where 
%\[
%\prog_1' = 
%    \begin{session}
%        \begin{array}{@{}c || c@{}}
%            \nil &
%              \begin{transaction}
%            		\pderef{\pvar{a}}{\loc_x};\\
%            		\pderef{\pvar{b}}{\loc_y};\\
%            		\pifs{\pvar{a}=1 \wedge \pvar{b}=0}\\
%            			\;\;\;\;\passign{\retvar}{\Large \frownie{}}
%             \end{transaction}
%        \end{array}
%    \end{session}
%\]

Next, we update the view of thread $\tid_2$, using rules $(C-View-update)$, 
$(P-thd-exec)$ and $(P-par-R)$. 
\ac{I never wrote down $(P-par-R)$: as you may expect, it is the symmetric counterpart of $(P-par-L)$}. 
Rule $(C-View-update)$ allows to update the view of $\tid_2$ of any location to a more up-to-date version 
for such a location. We can therefore update this view to the most recent version for key $\loc_x$, while 
maintaining the view for location $\loc_y$ unchanged. This leads to the transition 
$\langle \mathcal{C}_1, \prog_1' \rangle \xrightarrow{\_}_{CM} \langle \mathcal{C}_2, \prog_1' \rangle$, 
which is depicted below:
\begin{center}
\begin{tikzpicture}[font=\large]
\begin{pgfonlayer}{foreground}
\node(locx) {$[\loc_x] \mapsto$};
\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
\path (locx.east) + (0.5,0)  node (locx0) {$0$};
\path (locx0.north east) + (0.4,0) node[font=\small] (locx0ws) {$\tsid_0$};
\path (locx0.south east) + (0.4,0) node[font=\small] (locx0rs) {$\emptyset$};
\path(locx0.east) + (1.135,0) node (locx1) {$1$};
\path (locx1.north east) + (0.4,0) node[font=\small] (locx1ws) {$\tsid_1$};
\path (locx1.south east) + (0.4,0) node[font=\small] (locx1rs) {$\emptyset$};
\path (locy.east) + (0.5,0)  node (locy0) {$0$};
\path (locy0.north east) + (0.4,0) node[font=\small] (locy0ws) {$\tsid_0$};
\path (locy0.south east) + (0.4,0) node[font=\small] (locy0rs) {$\emptyset$};
\path(locy0.east) + (1.13,0) node (locy1) {$1$};
\path (locy1.north east) + (0.4,0) node[font=\small] (locy1ws) {$\tsid_1$};
\path (locy1.south east) + (0.4,0) node[font=\small] (locy1rs) {$\emptyset$};

\path (locy.south west) + (0, -0.6) node (dashlinestart) {};
\path (dashlinestart.center) + (4.5, 0) node (dashlineend) {};

\path(locy0.south) + (0,-1) node[font = \small, text=red] (tid1ret) {$\tid_1: \retvar = 0$};
\path(tid1ret.south) + (0,-0.3) node[font= \small, text=blue] (tid2ret) {$\tid_2: \retvar = 0$};
\end{pgfonlayer}

\begin{pgfonlayer}{main}

\path[-, dashed, thick] (dashlinestart.center) edge (dashlineend.center);

\node[hheapcell, fill=white, fit=(locx0) (locx0ws) (locx0rs)] (locx0cell) {};
\node[hheapcell, fill=white, fit=(locy0) (locy0ws) (locy0rs)] (locy0cell) {};
\node[hheapcell, fill=white, fit=(locx1) (locx1ws) (locx1rs)] (locx1cell) {};
\node[hheapcell, fill=white, fit=(locy1) (locy1ws) (locy1rs)] (locy1cell) {};

\path[-]
(locx0cell.north) edge (locx0cell.south)
(locx0cell.center) edge (locx0cell.east)
(locy0cell.north) edge (locy0cell.south) 
(locy0cell.center) edge (locy0cell.east)
(locx1cell.north) edge (locx1cell.south)
(locx1cell.center) edge (locx1cell.east)
(locy1cell.north) edge (locy1cell.south) 
(locy1cell.center) edge (locy1cell.east);

\path(locx1cell.north) + (-0.5, 0.2) node(v1beforex) {};
\path(locx1cell.south) + (-0.5, -0.1) node(v1afterx) {};
\path(locy1cell.north) + (-0.5, 0.1) node(v1beforey) {};
\path(locy1cell.south) + (-0.5, -0.2) node(v1aftery) {};
\path(v1beforex.center) + (0.25,0.15) node[font=\normalsize, text=red] (t1) {$\tid_1$};

\path[-, draw=red!80, very thick]
 (v1beforex.center) edge (v1afterx.center)
 (v1afterx.center) edge (v1beforey.center)
 (v1beforey.center) edge (v1aftery.center);
 
 \path(locx0cell.north) + (-0.1, 0.2) node(v2beforex) {};
\path(locx0cell.south) + (-0.1, -0.1) node(v2afterx) {};
\path(locy0cell.north) + (-0.1, 0.1) node(v2beforey) {};
\path(locy0cell.south) + (-0.1, -0.2) node(v2aftery) {};
\path(v2beforex.center) + (-0.1,0.15) node[font=\normalsize, text=blue] (t2) {$\tid_2$};

\path[-, draw=blue!80, very thick]
 (v2beforex.center) edge (v2afterx.center)
 (v2afterx.center) edge (v2beforey.center)
 (v2beforey.center) edge (v2aftery.center);
\end{pgfonlayer}

\begin{pgfonlayer}{background}
\node[background, fill=yellow!20, fit= (t1) (t2) (dashlinestart) (dashlineend) (tid1ret) (tid2ret), inner sep=0.05cm] (c1) {};
\end{pgfonlayer}
\path(c1.east) + (0.8,0)  node [font=\Huge] (p1) {{}, $\prog_1'$};

%%End of first configuration

\path(p1.east) + (0.5,0) node[font=\Huge] (arrow) {${}\xrightarrow{\_}$};

%%Beginning of second configuration

\begin{pgfonlayer}{foreground}
\path (locx.east) + (7, 0) node (locxf) {$[\loc_x] \mapsto$};
\path (locxf.south) + (0,-1.5) node (locyf) {$[\loc_y] \mapsto$};
\path (locxf.east) + (0.5,0)  node (locxf0) {$0$};
\path (locxf0.north east) + (0.4,0) node[font=\small] (locxf0ws) {$\tsid_0$};
\path (locxf0.south east) + (0.4,0) node[font=\small] (locxf0rs) {$\emptyset$};
\path(locxf0.east) + (1.135,0) node (locxf1) {$1$};
\path (locxf1.north east) + (0.4,0) node[font=\small] (locxf1ws) {$\tsid_1$};
\path (locxf1.south east) + (0.4,0) node[font=\small] (locxf1rs) {$\emptyset$};
\path (locyf.east) + (0.5,0)  node (locyf0) {$0$};
\path (locyf0.north east) + (0.4,0) node[font=\small] (locyf0ws) {$\tsid_0$};
\path (locyf0.south east) + (0.4,0) node[font=\small] (locyf0rs) {$\emptyset$};
\path(locyf0.east) + (1.13,0) node (locyf1) {$1$};
\path (locyf1.north east) + (0.4,0) node[font=\small] (locyf1ws) {$\tsid_1$};
\path (locyf1.south east) + (0.4,0) node[font=\small] (locyf1rs) {$\emptyset$};

\path (locyf.south west) + (0, -0.6) node (dashlinestartf) {};
\path (dashlinestartf.center) + (4.5, 0) node (dashlineendf) {};

\path(locyf0.south) + (0,-1) node[font = \small, text=red] (tidf1ret) {$\tid_1: \retvar = 0$};
\path(tidf1ret.south) + (0,-0.3) node[font= \small, text=blue] (tidf2ret) {$\tid_2: \retvar = 0$};
\end{pgfonlayer}

\begin{pgfonlayer}{main}

\path[-, dashed, thick] (dashlinestartf.center) edge (dashlineendf.center);

\node[hheapcell, fill=white, fit=(locxf0) (locxf0ws) (locxf0rs)] (locxf0cell) {};
\node[hheapcell, fill=white, fit=(locyf0) (locyf0ws) (locyf0rs)] (locyf0cell) {};
\node[hheapcell, fill=white, fit=(locxf1) (locxf1ws) (locxf1rs)] (locxf1cell) {};
\node[hheapcell, fill=white, fit=(locyf1) (locyf1ws) (locyf1rs)] (locyf1cell) {};

\path[-]
(locxf0cell.north) edge (locxf0cell.south)
(locxf0cell.center) edge (locxf0cell.east)
(locyf0cell.north) edge (locyf0cell.south) 
(locyf0cell.center) edge (locyf0cell.east)
(locxf1cell.north) edge (locxf1cell.south)
(locxf1cell.center) edge (locxf1cell.east)
(locyf1cell.north) edge (locyf1cell.south) 
(locyf1cell.center) edge (locyf1cell.east);

\path(locxf1cell.north) + (-0.5, 0.2) node(vf1beforex) {};
\path(locxf1cell.south) + (-0.5, -0.1) node(vf1afterx) {};
\path(locyf1cell.north) + (-0.5, 0.1) node(vf1beforey) {};
\path(locyf1cell.south) + (-0.5, -0.2) node(vf1aftery) {};
\path(vf1beforex.center) + (-0.3,0.15) node[font=\normalsize, text=red] (tf1) {$\tid_1$};

\path[-, draw=red!80, very thick, smooth]
 (vf1beforex.center) edge (vf1afterx.center)
 (vf1afterx.center) edge (vf1beforey.center)
 (vf1beforey.center) edge (vf1aftery.center);
 
 \path(locxf1cell.north) + (-0.2, 0.2) node(vf2beforex) {};
\path(locxf1cell.south) + (-0.2, -0.1) node(vf2afterx) {};
\path(locyf0cell.north) + (-0.1, 0.1) node(vf2beforey) {};
\path(locyf0cell.south) + (-0.1, -0.2) node(vf2aftery) {};
\path(vf2beforex.center) + (0.2,0.15) node[font=\normalsize, text=blue] (tf2) {$\tid_2$};

%\path[-, draw=blue!80, very thick, smooth, tension=0.4]
% (vf2beforex.center) edge (vf2afterx.center)
% (vf2afterx.center) edge (vf2beforey.center)
% (vf2beforey.center) edge (vf2aftery.center);
\draw[blue!80, very thick] plot [smooth, tension=0.4] coordinates { (vf2beforex.center) (vf2afterx.center) (vf2beforey.center) (vf2aftery.center)};
\end{pgfonlayer}

\begin{pgfonlayer}{background}
\node[background, fill=yellow!20, fit= (tf1) (tf2) (dashlinestartf) (dashlineendf) (tidf1ret) (tidf2ret), inner sep=0.05cm] (c2) {};
\end{pgfonlayer}
\path(c2.east) + (0.8,0)  node [font=\Huge] (p2) {{}, $\prog_1'$};

\end{tikzpicture}
\end{center}

Finally, we can execute the transaction of thread $\tid_2$, again using rules 
$(Tx-exec), (P-thd-exec)$ and $(P-par-R)$. Note that the view of the thread $\tid_2$ in the 
configuration depicted above, mandates that the transaction will be executed with 
respect to the snapshot $[ [\loc_x] \mapsto 1, [\loc_y] \mapsto 0]$, and therefore it will 
return the special symbol ${\Large \frownie{}}$. Formally, let $\prog_1'' = \nil \Par \nil$. 
Then we have the transition $\langle \mathcal{C}_2, \prog_1' \rangle \xrightarrow{\_}_{CM} 
\langle \mathcal{C}_3, \prog_1'' \rangle$, which is depicted below: 

\begin{center}
\begin{tikzpicture}[font=\large]
\begin{pgfonlayer}{foreground}
\node(locx) {$[\loc_x] \mapsto$};
\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
\path (locx.east) + (0.5,0)  node (locx0) {$0$};
\path (locx0.north east) + (0.4,0) node[font=\small] (locx0ws) {$\tsid_0$};
\path (locx0.south east) + (0.4,0) node[font=\small] (locx0rs) {$\emptyset$};
\path(locx0.east) + (1.135,0) node (locx1) {$1$};
\path (locx1.north east) + (0.4,0) node[font=\small] (locx1ws) {$\tsid_1$};
\path (locx1.south east) + (0.4,0) node[font=\small] (locx1rs) {$\emptyset$};
\path (locy.east) + (0.5,0)  node (locy0) {$0$};
\path (locy0.north east) + (0.4,0) node[font=\small] (locy0ws) {$\tsid_0$};
\path (locy0.south east) + (0.4,0) node[font=\small] (locy0rs) {$\emptyset$};
\path(locy0.east) + (1.13,0) node (locy1) {$1$};
\path (locy1.north east) + (0.4,0) node[font=\small] (locy1ws) {$\tsid_1$};
\path (locy1.south east) + (0.4,0) node[font=\small] (locy1rs) {$\emptyset$};

\path (locy.south west) + (0, -0.6) node (dashlinestart) {};
\path (dashlinestart.center) + (4.5, 0) node (dashlineend) {};

\path(locy0.south) + (0,-1) node[font = \small, text=red] (tid1ret) {$\tid_1: \retvar = 0$};
\path(tid1ret.south) + (0,-0.3) node[font= \small, text=blue] (tid2ret) {$\tid_2: \retvar = 0$};
\end{pgfonlayer}

\begin{pgfonlayer}{main}

\path[-, dashed, thick] (dashlinestart.center) edge (dashlineend.center);

\node[hheapcell, fill=white, fit=(locx0) (locx0ws) (locx0rs)] (locx0cell) {};
\node[hheapcell, fill=white, fit=(locy0) (locy0ws) (locy0rs)] (locy0cell) {};
\node[hheapcell, fill=white, fit=(locx1) (locx1ws) (locx1rs)] (locx1cell) {};
\node[hheapcell, fill=white, fit=(locy1) (locy1ws) (locy1rs)] (locy1cell) {};

\path[-]
(locx0cell.north) edge (locx0cell.south)
(locx0cell.center) edge (locx0cell.east)
(locy0cell.north) edge (locy0cell.south) 
(locy0cell.center) edge (locy0cell.east)
(locx1cell.north) edge (locx1cell.south)
(locx1cell.center) edge (locx1cell.east)
(locy1cell.north) edge (locy1cell.south) 
(locy1cell.center) edge (locy1cell.east);

\path(locx1cell.north) + (-0.5, 0.2) node(v1beforex) {};
\path(locx1cell.south) + (-0.5, -0.1) node(v1afterx) {};
\path(locy1cell.north) + (-0.5, 0.1) node(v1beforey) {};
\path(locy1cell.south) + (-0.5, -0.2) node(v1aftery) {};
\path(v1beforex.center) + (-0.3,0.15) node[font=\normalsize, text=red] (t1) {$\tid_1$};

\path[-, draw=red!80, very thick]
 (v1beforex.center) edge (v1afterx.center)
 (v1afterx.center) edge (v1beforey.center)
 (v1beforey.center) edge (v1aftery.center);
 
 \path(locx1cell.north) + (-0.2, 0.2) node(v2beforex) {};
\path(locx1cell.south) + (-0.2, -0.1) node(v2afterx) {};
\path(locy0cell.north) + (-0.1, 0.1) node(v2beforey) {};
\path(locy0cell.south) + (-0.1, -0.2) node(v2aftery) {};
\path(v2beforex.center) + (0.2,0.15) node[font=\normalsize, text=blue] (t2) {$\tid_2$};

\draw[blue!80, very thick] plot [smooth, tension=0.4] coordinates { (v2beforex.center) (v2afterx.center) (v2beforey.center) (v2aftery.center)};
\end{pgfonlayer}

\begin{pgfonlayer}{background}
\node[background, fill=yellow!20, fit= (t1) (t2) (dashlinestart) (dashlineend) (tid1ret) (tid2ret), inner sep=0.05cm] (c1) {};
\end{pgfonlayer}
\path(c1.east) + (0.8,0)  node [font=\Huge] (p1) {{}, $\prog_1'$};

%%End of first configuration

\path(p1.east) + (0.5,0) node[font=\Huge] (arrow) {${}\xrightarrow{\_}$};

%%Beginning of second configuration

\begin{pgfonlayer}{foreground}
\path (locx.east) + (7, 0) node (locxf) {$[\loc_x] \mapsto$};
\path (locxf.south) + (0,-1.5) node (locyf) {$[\loc_y] \mapsto$};
\path (locxf.east) + (0.5,0)  node (locxf0) {$0$};
\path (locxf0.north east) + (0.4,0) node[font=\small] (locxf0ws) {$\tsid_0$};
\path (locxf0.south east) + (0.4,0) node[font=\small] (locxf0rs) {$\emptyset$};
\path(locxf0.east) + (1.12,0.01) node (locxf1) {$1$};
\path (locxf1.north east) + (0.4,0) node[font=\small] (locxf1ws) {$\;\;\;\;\;\;\tsid_1$};
\path (locxf1.south east) + (0.4,0) node[font=\small] (locxf1rs) {$\;\;\;\;\;\;\{\tsid_2\}$};
\path (locyf.east) + (0.5,0)  node (locyf0) {$0$};
\path (locyf0.north east) + (0.4,0) node[font=\small] (locyf0ws) {$\;\;\;\;\;\;\tsid_0$};
\path (locyf0.south east) + (0.4,0) node[font=\small] (locyf0rs) {$\;\;\;\;\;\;\{\tsid_2\}$};
\path(locyf0.east) + (1.55,0) node (locyf1) {$1$};
\path (locyf1.north east) + (0.4,0) node[font=\small] (locyf1ws) {$\tsid_1$};
\path (locyf1.south east) + (0.4,0) node[font=\small] (locyf1rs) {$\emptyset$};

\path (locyf.south west) + (0, -0.6) node (dashlinestartf) {};
\path (dashlinestartf.center) + (5, 0) node (dashlineendf) {};

\path(locyf0.south) + (0,-1) node[font = \small, text=red] (tidf1ret) {$\tid_1: \retvar = 0$};
\path(tidf1ret.south) + (0,-0.3) node[font= \small, text=blue] (tidf2ret) {$\tid_2: \retvar = {\large \frownie{}}$};
\end{pgfonlayer}

\begin{pgfonlayer}{main}

\path[-, dashed, thick] (dashlinestartf.center) edge (dashlineendf.center);

\node[hheapcell, fill=white, fit=(locxf0) (locxf0ws) (locxf0rs)] (locxf0cell) {};
\node[hheapcell, fill=white, fit=(locyf0) (locyf0ws) (locyf0rs), inner sep=0.083cm] (locyf0cell) {};
\node[hheapcell, fill=white, fit=(locxf1) (locxf1ws) (locxf1rs), inner sep= 0.083cm] (locxf1cell) {};
\node[hheapcell, fill=white, fit=(locyf1) (locyf1ws) (locyf1rs)] (locyf1cell) {};

\path[-]
(locxf0cell.north) edge (locxf0cell.south)
(locxf0cell.center) edge (locxf0cell.east)
(locyf0cell.north) edge (locyf0cell.south) 
(locyf0cell.center) edge (locyf0cell.east)
(locxf1cell.north) edge (locxf1cell.south)
(locxf1cell.center) edge (locxf1cell.east)
(locyf1cell.north) edge (locyf1cell.south) 
(locyf1cell.center) edge (locyf1cell.east);

\path(locxf1cell.north) + (-0.7, 0.2) node(vf1beforex) {};
\path(locxf1cell.south) + (-0.7, -0.1) node(vf1afterx) {};
\path(locyf1cell.north) + (-0.5, 0.1) node(vf1beforey) {};
\path(locyf1cell.south) + (-0.5, -0.2) node(vf1aftery) {};
\path(vf1beforex.center) + (-0.3,0.15) node[font=\normalsize, text=red] (tf1) {$\tid_1$};

%\path[-, draw=red!80, very thick, smooth]
% (vf1beforex.center) edge (vf1afterx.center)
% (vf1afterx.center) edge (vf1beforey.center)
% (vf1beforey.center) edge (vf1aftery.center);
\draw[red!80, very thick] plot [smooth, tension=0.2] coordinates { (vf1beforex.center) (vf1afterx.center) (vf1beforey.center) (vf1aftery.center)};

 \path(locxf1cell.north) + (-0.2, 0.2) node(vf2beforex) {};
\path(locxf1cell.south) + (-0.2, -0.1) node(vf2afterx) {};
\path(locyf0cell.north) + (-0.1, 0.1) node(vf2beforey) {};
\path(locyf0cell.south) + (-0.1, -0.2) node(vf2aftery) {};
\path(vf2beforex.center) + (0.2,0.15) node[font=\normalsize, text=blue] (tf2) {$\tid_2$};

%\path[-, draw=blue!80, very thick, smooth, tension=0.4]
% (vf2beforex.center) edge (vf2afterx.center)
% (vf2afterx.center) edge (vf2beforey.center)
% (vf2beforey.center) edge (vf2aftery.center);
\draw[blue!80, very thick] plot [smooth, tension=0.4] coordinates { (vf2beforex.center) (vf2afterx.center) (vf2beforey.center) (vf2aftery.center)};
\end{pgfonlayer}

\begin{pgfonlayer}{background}
\node[background, fill=yellow!20, fit= (tf1) (tf2) (dashlinestartf) (dashlineendf) (tidf1ret) (tidf2ret), inner sep=0.05cm] (c2) {};
\end{pgfonlayer}
\path(c2.east) + (0.8,0)  node [font=\Huge] (p2) {{}, $\prog_1''$};

\end{tikzpicture}
\end{center}

\ac{Fix style for pictures. Having a different block for each cell may cause disalignment.
The return value of $\tid_2$ should be emphasised more in the picture.\\
Update: Done. Need to synch pictures in this section with new style.}
Note that, in the final configuration configuration $\mathcal{C}_2$, the variable $\retvar$ in the thread 
stack of $\tid_2$ contains the special symbol $\Large \frownie{}$, as to mean that we obtained a violation of 
atomic visibility.

\section{Examples of Consistency Models}
\input{cmexamples}


\subsection{Encoding Dependency Graphs' Specifications}
\ac{Contents: Isomorphism between history heaps and dependency graphs, 
converting dependency graphs specifications, well-formedness of dependency graphs' specifications.}

\subsection{Completeness of the Semantics} 
\ac{Contents: Abstract execution Semantics and the anarchic model. 
Encoding of abstract executions into history heaps. Also, 
traces in the history heaps semantics can be used to recover 
an abstract execution $\chi$. Hence it is possible to convert history heaps 
specifications into sets of abstract executions.
I think this should be the Theorem: for every possible trace of a program $\prog$ that is allowed by the anarchic 
model, and that results into an abstract execution $\chi$ that is allowed by $CM$, there 
exists a trace of the same program under the history heaps $CM$-semantics, 
and whose encoding into an abstract execution is exactly $\chi$.}
\subsection{Remarks on the operational semantics}
\ac{There was a discussion on whether views of threads should always be consistent w.r.t a 
consistency model specification, or whether they should be consistent only w.r.t. to 
a consistency model specification only prior to executing a transaction.\\ 
In this section I should argue that the first option leads to losing the completeness of the 
semantics.}


\section{Testing Consistency Models Specifications}
\ac{Definition of may-testing preorder, which is standard and at some point 
was also in the notes - where did it go? Most General Client Semantics of consistency 
models under history heaps. Conjecture: two consistency models are equivalent if they 
produce the same set of histories (transactions labelled with the session order) under 
the most general client semantics. This is consistent with Hongseok's result that contextual 
refinement for concurrent libraries coincide with 
the sequential consistency preorder, when threads can only communicate via the memory regions 
shared withing the library.}

\subsection{Applications}
\ac{Proof of equivalence of consistency models specifications given in terms of history heaps, 
with respect to the same specifications given in terms of dependnecy graphs. In this section 
I must be careful to address the work by Crook and Alvisi, as they also have an operational model 
of transactions (without a programming language) and a proof of equivalence with respect to 
dependency graphs' specifications.}

\subsection{Verification of Algorithms} 
Candidates: 
\begin{itemize}
\item Walter (\textbf{https://dl.acm.org/citation.cfm?id=2043592}) - PSI, should be easy, 
people may find it boring, the Concur'15 model was inspired by Walter and people may argue we 
already proved its correctness in there.
\item Wren (\textbf{https://infoscience.epfl.ch/record/254970}) - Causal Consistency - very recent and seems to have 
a nice pseudo-code.\\
\item COPS-gt (\textbf{https://www.cs.cmu.edu/~dga/papers/cops-sosp2011.pdf}) - Causal Consistency -  mentioned a lot at 
talks, may be a viable option.
\item Distributed SI (\textbf{https://dl.acm.org/citation.cfm?id=2691546}) - Snapshot Isolation - 5 different protocols given in the paper, 
not sure if any of those is easily verifiable.\\ 
\item Clock-SI (\textbf{https://dl.acm.org/citation.cfm?id=2553434}) - Using physical clocks as time-stamps, may have a direct encoding 
into history heaps - has some chances of being verifiable.
\end{itemize}

\bibliographystyle{abbrv}
\bibliography{bibliography2}

\end{document}

