\documentclass[a4paper,UKenglish]{article}%This is a template for producing LIPIcs articles. 

\input{env.tex}
\usepackage{hhmacros}




 
\usepackage{microtype}%if unwanted, comment out or use option "draft"
%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

%\bibliographystyle{plainurl}% the recommended bibstyle

%\usepackage[a4paper]{geometry}
%\usepackage[letterpaper,left=2.4cm,right=2.4cm,top=2.4cm,bottom=2.4cm]{geometry}

\usepackage{opsem}

\usepackage{etex}

%\usepackage{stackengine}

\usepackage{authblk}



%%%%%%%%%%%%%%%%%%%%%% edit mode
\newif\iflong
\longfalse  % uncomment for short version
%\longtrue  % uncomment for long version

\newif\ifdraft
%\draftfalse %uncomment for deleting notes
\drafttrue %uncomment for showing notes

%\newif\ifEditing
%\Editingtrue
%\ifEditing
%    \linenumbers
%\fi

\newif\ifComments
\Commentstrue
\input{comment-box.tex}
%%%%%%%%%%%%%%%%%%%%%% end edit mode

\newcommand{\tr}[2]{\iflong{}\S#1\else{}\cite[\S{}#2]{ext}\fi}
\newcommand{\tra}[2]{\iflong{}(\S#1)\else{}\cite[\S{}#2]{ext}\fi}

\newcommand{\nanomalies}{A}
\newcommand{\ngeneral}{B}
\newcommand{\nproofs}{C}
\newcommand{\ncompleteness}{D}

%\renewcommand{\ttdefault}{cmtt}
%\renewcommand{\sfdefault}{cmss}

\newcommand{\cross}{\ding{56}}


%\renewcommand{\rmdefault}{ptm}

\renewcommand{\O}{\mathcal{O}}

\newcommand{\theproof}{{\noindent\hskip\labelsep
        \color{darkgray}\sffamily\bfseries \proofname.}}
        
\newcommand{\myparagraph}[1]{\textbf{\color{darkgray}\sffamily#1.}}
\newcommand{\newtext}[1]{{\color{red}{\bf #1}}}
\newcommand{\dfont}[1]{{\bf\em #1}}

% comments


\usepackage{pifont}
\usepackage[frame,all]{xy}
\usepackage{nicefrac}
\usepackage{executions}
\usepackage{execgraphs}

\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{proof}

\DeclareMathAlphabet{\mathpzc}{OT1}{pzc}{m}{it}

%\usepackage{mathtools}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Packages above %%%%%%%%%%%%%%%%%%%%%%%


\theoremstyle{plain}

%\newcommand{\qed}{$\Box$}
%\newenvironment{proof}{\begin{trivlist}
%\item[\hskip\labelsep{\sc Proof.}]}
%{$\hfill\Box$\end{trivlist}}
\newenvironment{sketch}{\begin{trivlist}
\item[\hskip\labelsep{\sc Proof sketch.}]}
{$\hfill\Box$\end{trivlist}}
\newenvironment{scheme}{\begin{trivlist}
\item[\hskip\labelsep{\sc Proof scheme.}]}
{$\hfill\Box$\end{trivlist}}


%\newcommand{\account}{\ensuremath{\mathsf{acct}}}
%\newcommand{\emptytxt}{{\ensuremath{\mathsf{empty}}}}
%\newcommand{\post}{\ensuremath{\mathsf{post}}}
%\newcommand{\comment}{\ensuremath{\mathsf{comment}}}

%\def\qed{\ifmmode\squareforqed\else{\unskip\nobreak\hfil
%\penalty50\hskip1em\null\nobreak\hfil\squareforqed
%\parfillskip=0pt\finalhyphendemerits=0\endgraf}\fi}


\newcommand{\leaveout}[1]{}

\newcommand\Tstrut{\rule{0pt}{3.5ex}}         % = `top' strut
\newcommand\Bstrut{\\[3pt]}   % = `bottom' strut

%usepackage{paralist}
%\setdefaultleftmargin{10pt}{}{}{}{}{}
%\setlength{\topsep}{3pt}
%\setlength{\itemsep}{2pt}
% \setlength{\partopsep}{0pt}
% \setlength{\parsep}{0pt}
%\setlength{\parskip}{0pt}

\newenvironment{subitemize}{
\begin{itemize}
 \setlength{\topsep}{0pt}
  \setlength{\itemsep}{0pt}
  \setlength{\parskip}{0pt}
}{\end{itemize}}

\multlinegap=3pt
\setlength{\jot}{2pt}
\newcommand{\ms}{\\[2pt]}

%
\setlength{\floatsep}{10pt plus 6pt minus 2pt}
\setlength{\textfloatsep}{10pt plus 6pt minus 3pt}
\setlength{\intextsep}{10pt plus 6pt minus 3pt}
\setlength{\dblfloatsep}{18pt plus 4pt minus 2pt}
\setlength{\dbltextfloatsep}{20pt plus 4pt minus 3pt}

\newenvironment{mywrapfigure}[3][]{
  \floatstyle{boxed}
  \restylefloat{figure}
  \wrapfigure[#1]{#2}{#3}}
  {\endwrapfigure
    \floatstyle{ruled}
    \restylefloat{figure}
    }
    

% \setlength{\floatsep}{18pt plus 4pt minus 2pt}
% \setlength{\textfloatsep}{18pt plus 4pt minus 3pt}
% \setlength{\intextsep}{10pt plus 4pt minus 3pt}
% \setlength{\dblfloatsep}{18pt plus 4pt minus 2pt}
% \setlength{\dbltextfloatsep}{20pt plus 4pt minus 3pt}
%
%\makeatletter
%\renewcommand{\section}{\@startsection{section}{1}{0pt}%
%{-3ex plus -1ex minus -.2ex}{1.5ex plus.2ex}%
%{\normalfont\large\bfseries}}
%\renewcommand{\subsection}{\@startsection{subsection}{1}{0pt}%
%{-2ex plus -1ex minus -.2ex}{1ex plus.2ex}%
%{\bfseries}}
%\def \@begintheorem #1#2{%                      {name}{number}
%  \trivlist
%  \item[\hskip \labelsep \textbf{#1 #2.}]%
%  \itshape\selectfont
%  \ignorespaces}
%\newcommand{\nut}{\hspace{.35em}}
%\def \@opargbegintheorem #1#2#3{%               {name}{number}{title}
%  \trivlist
%  \item[%
%    \hskip\labelsep \textsc{#1\ #2}\nut (#3).]%
%  \itshape\selectfont
%  \ignorespaces}
%
%\def\@listI{\leftmargin\leftmargini
%            \parsep 0\p@ \@plus1\p@ \@minus\p@
%            \topsep 6\p@ \@plus2\p@ \@minus0\p@
%            \itemsep 0\p@}
%\let\@listi\@listI
%\@listi
%
%\makeatother
%
%\sloppy

%Labels for groups of inequations
\newcommand{\txlaws}{{\textbf{(a)}}}
\newcommand{\deplaws}{{\textbf{(b)}}}
\newcommand{\allexeclaws}{{\textbf{(c)}}}
\newcommand{\cmexeclaws}{{\textbf{(d)}}}

%Labels for individual inequations
\newcommand{\txId}{{\textbf{(a.1)}}}
\newcommand{\txComp}{{\textbf{(a.2)}}}
\newcommand{\txCap}{{\textbf{(a.5)}}}
\newcommand{\txCup}{{\textbf{(a.6)}}}
\newcommand{\txDistrR}{{\textbf{(a.3)}}}
\newcommand{\txDistrL}{{\textbf{(a.4)}}}
%
\newcommand{\depWRTx}{{\textbf{(b.1)}}}
\newcommand{\depWWTx}{{\textbf{(b.2)}}}
\newcommand{\depRWTx}{{\textbf{(b.3)}}}
\newcommand{\depWRIrrefl}{{\textbf{(b.4)}}}
\newcommand{\depWWIrrefl}{{\textbf{(b.5)}}}
\newcommand{\depRWIrrefl}{{\textbf{(b.6)}}}
%
\newcommand{\ARtrans}{{\textbf{(c.5)}}}
\newcommand{\VIStrans}{{\textbf{(c.4)}}}
\newcommand{\VISinAR}{{\textbf{(c.6)}}}
\newcommand{\ARirrefl}{{\textbf{(c.12)}}}
\newcommand{\VISnotAVIS}{{\textbf{(c.11)}}}
\newcommand{\POinVIS}{{\textbf{(c.0)}}}
\newcommand{\WRinVIS}{{\textbf{(c.1)}}}
\newcommand{\WWinAR}{{\textbf{(c.2)}}}
\newcommand{\LWW}{{\textbf{(c.7)}}}
\newcommand{\RWinAVIS}{{\textbf{(c.3)}}}
\newcommand{\AVISright}{{\textbf{(c.8)}}}
\newcommand{\AVISleft}{{\textbf{(c.9)}}}
\newcommand{\AVISnotVIS}{{\textbf{(c.10)}}}
\newcommand{\CompIrrefl}{{\textbf{(c.13)}}}
%
\newcommand{\Axiom}{{\textbf{(d.1)}}}
\newcommand{\CoAxiomAR}{{\textbf{(d.2)}}}
\newcommand{\CoAxiomL}{{\textbf{(d.3)}}}
\newcommand{\CoAxiomR}{{\textbf{(d.4)}}}

\newcommand{\Spo}{\text{(V0)}}
\newcommand{\Srf}{\text{(V1)}}
\newcommand{\Sconflict}{\text{(V3)}}
\newcommand{\SvisTrans}{\text{(V2)}}
\newcommand{\Saxiom}{\text{(V4)}}
\newcommand{\Svo}{\text{(A1)}}
\newcommand{\Svis}{\text{(A2)}}
\newcommand{\SarTrans}{\text{(A4)}}
\newcommand{\Scoaxiom}{\text{(A5)}}
\newcommand{\Sext}{\text{(A3)}}
\newcommand{\Sad}{\text{(N1)}}
\newcommand{\SavisL}{\text{(N2)}}
\newcommand{\SavisR}{\text{(N3)}}

\newcommand{\palette}{\ensuremath{\mathop{\raisebox{-4pt}{\includegraphics[scale=0.02]{palette.png}}}}}
\newcommand{\gspec}{\ensuremath{\mathsf{gSpec}}}

% Author macros:begin %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\iflong
\title{On the Operational Behaviour of Weak Consistency Models with Atomic Visibility}
%\titlerunning{Algebraic Laws for Weak Consistency (Extended Version)} %optional, in case that the title is too long; the running title should fit into the top page column
\else
\title{On the Operational Behaviour of Weak Consistency Models with Atomic Visibility}
%\titlerunning{Algebraic Laws for Weak Consistency}
\fi

%% Please provide for each author the \author and \affil macro, even when authors have the same affiliation, i.e. for each author there needs to be the  \author and \affil macros
\iflong

\author[1]{Andrea Cerone}
\affil[1]{Imperial College London, UK}
%\authorrunning{A. Cerone} %mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et. al.'
\else

\author[1]{Andrea Cerone}
\affil[1]{Imperial College London, UK, \texttt{a.cerone@imperial.ac.uk}}
\fi

\begin{document}
\maketitle
\begin{abstract}
Contents of this set of notes: 
History heaps. Semantics of Programs 
running under weak consistency models using history heaps as states. 
Simulation technique for comparing weak consistency models defined using 
history heaps. Verification of implementations.
\textbf{Points following Dagstuhl: Viktor seemed positive about the 
history heap work. His question was whether the framework is generic 
enough to capture the protocols that they are developing with Azalea. 
Alexey's opinion is that the framework may have some use if we 
manage to prove implementations of protocols correct. 
I would also like to have Azalea's opinion on a semantics based 
on history heaps.}

%{\color{red} \textbf{I AM CURRENTLY EDITING THIS DOCUMENT. 
%DO NOT TOUCH THIS FILE UNTIL I SAY SO!!!}}
\end{abstract}

\section{Computational Model}
We focus on a computational model where multi-threaded programs can access and update 
locations in a centralised heap using atomic transactions. Transactions in our model execute atomically, 
though the consistency guarantees that they provide do not necessarily correspond to \emph{serialisability}. 
This means that, at the moment of executing, a transaction may not observe the most up-to-date value 
of a location. 

To overcome this issue, we model the state of the system using \emph{history heaps}. A 
history heap keeps track of all the versions written for any location, as well as the information 
about the transactions that read and wrote such versions. History heaps are defined formally later in 
the paper.

When executing, a transaction extracts a heap by selecting a version for each 
object in the database. The heap extracted in this way takes the name of the 
\emph{snapshot} of the transaction. In general ,the process of determining 
a snapshot for a transaction is non-deterministic.
A heap $\h \in \Heaps$ consists of a partial function 
from a set of addresses $\Addr \defeq \Setcon{ [\nat] }{\nat \in \Nat }$ to values in $ \val \in \Val \defeq \Nat \cup \Addr$. 
The set of all heaps is denoted by $\Heaps$.
Each thread has its own stack, 
where data for performing local computations is stored. Transactions also 
have a transaction-local stack. 
The set of thread-local stack variables is denoted by $\ThreadVars \defeq \{\pvar{x}, \pvar{y}, \cdots\}$, 
while the set of transaction local variables is denoted by $\TxVars \defeq \{\pvar{a}, \pvar{b}, \cdots\}$. 
We use $\ThdStacks$ to range over thread-local stacks in the set $\ThdStacks \defeq \ThreadVars \to \Val$, 
and $\TxStacks$ to range over transaction-local stacks in the set $\TxStacks \defeq \TxVars \to \Val$.
%\ac{We had some discussion on whether separating the thread-local and transaction-local stack made sense. 
%If you see tranaction code the same as method invocations, this assumption reflects what happens 
%in standard imperative programming languages (i.e. C): transaction-local variables are the local variables 
%of a method, thread-local variables are global variables. A method can read from the global variables. 
%The local variables of a method cannot be accessed outside of the method execution.
%From the technical point of view, having a single thread-local stack won't make too much of a difference, 
%as concurrent access to stack locations can never happen. So we can change it, if needed.}
%\ac{I am wondering whether it makes sense to allow threads to communicate using shared 
%variables outside of the database. In The context of concurrent data structures, this affects 
%the characterisation of contextual refinement (from sequential consistency to linearisability). 
%But in this case transactions are meant to execute atomically, whereas in concurrent 
%library semantics interleavings of method executions are possible.}

The transaction-local stack is created at the moment a transaction starts, 
and is destroyed at the moment it commits. 
Transactions can read from, but cannot 
write to, the thread-local stack. This assumption makes it possible to abstract from 
aborting transactions, as these would have no side-effects in the computational model described. 
We assume that each transaction-local 
stack has a special variable that is used to store the value returned by the transaction 
upon commit. Each thread-local stack also comes equipped with a special return variable, 
where the contents of the value returned by transactions are stored. We use the symbol 
$\retvar$ to denote the special return variable, both in transaction-local and thread-local 
stacks.
%\sx{
%    Not sure about the ret var, 
%    how to transfer the ret var from tx stack to thread stack as 
%    we cannot modify the thread stack.
%}
%\ac{That can be done as part of the program semantics, executing 
%a transaction modifies the ret value of the semantics. This is 
%also what happens in real program executions, by pushing/popping the return value into 
%the execution stack.}
We leave the consistency model of the transactional memory unspecified. The rules 
of our operational semantics will be parametric in the specification of a consistency 
model, using a novel style of specification that we will present later in the paper. 

\paragraph{\textbf{Syntax of Programs}}
We assume a set of (primitive) transactional commands $\primt,\primt',\cdots$, which 
we leave unspecified. Each transactional command $t$ is associated to a \emph{state transformer} 
$\mathcal{S}_t \subseteq (\ThdStacks \times \TxStacks \times \Heaps) \times (\TxStacks \times \Heaps)$. 
\ac{This is slightly confusing: from the point of view of programs, the heap does not change 
while a transaction is executing.}
We use the notation $(\thdstack, \txstack, \heap) \toT{t} (\txstack' , \heap')$ 
in lieu of $((\thdstack, \txstack, \h), (\txstack', \h' )) \in \mathcal{S}_t$. Note that this definition ensures 
that primitive transactional commands cannot update the thread-local stack.
We also assume a set of primitive (non-transactional) commands $\primc, \primc',\cdots$ 
that can be executed by a command outside transactions. Each primitive non-transactional 
command $\primc$ is associated with a state transformer $\mathcal{S}_c \subseteq 
(\ThdStacks \times \ThdStacks)$, and again we adopt the notation $\thdstack \toT{c} 
\thdstack'$ in lieu of $(\thdstack, \thdstack') \in \mathcal{S}_c$. This definition ensures that 
thread-local primitive commands do not access neither the transaction-local stack, nor the heap.

Often, we will assume a language of expressions at the base of primitive (transactional and non-transactional) 
commands. This language is defined by the grammar below: 
\[
\begin{rclarray}
\expr & ::= & \val \bor \pvar{x} \bor \pvar{a} \bor \expr + \expr \bor \expr \cdot \expr \bor \cdots
\end{rclarray}
\]
The set of all expressions is denoted by $\Expr$.
Because non-transactional commands cannot access the transaction-local stack, we will 
need the following, inductively defined, predicate: 
\[
\begin{rclarray}
\isthdexp(\val) &=& \ttrue\\
\isthdexp(\pvar{x}) &=& \ttrue\\
\isthdexp(\pvar{a}) &=& \ffalse\\
\isthdexp(\expr_1 + \expr_2) &=& \isthdexp(\expr_1) \wedge \isthdexp(\expr_2)\\
\vdots & \vdots & \vdots
\end{rclarray}
\]
In general, if the language of expressions contains an operator $\func{f}{\expr_1, \cdots, \expr_n}$, 
where $n \geq 1$, we define $\isthdexp(\func{f}{\expr_1, \cdots, \expr_n}) = \bigwedge_{i=1,\cdots,n} \isthdexp(\expr_i)$.
%\ac{Subtle error here: for $f$ with arity $0$, then $\isthdexp(f) = \ttrue$. But now I can interpret 
%$\interpr{\mathtt{f}} = \lambda \thdstack. \lambda \txstack. \txstack(\pvar{a})$, for some $\pvar{a} \in 
%\TxVars$, thus allowing the access of transaction-local variables within thread-local commands. Boolean predicate must 
%be  fixed.}

The set of primitive commands we will use is given by 
\[
\begin{rclarray}
\primc &::=& \passign{\pvar{x}}{\expr} \mid \assume(\expr) \\
\primt &::=& \passign{\pvar{a}}{\expr} \mid \pmutate{\expr}{\expr} \mid  \pderef{\pvar{a}}{\expr} \mid \assume(\expr)
\end{rclarray}
\]
where in the right-hand sides of the $\primc$ clause we always require that $\isthdexp(\expr) = \ttrue$.

Below we define the syntax of programs allowed by our language. 

\[
\begin{rclarray}
\prog & ::= & \tid: \cmd \Par \prog \Par \prog \\
\cmd & ::= & \nil \mid X \mid \pi.\cmd \mid \cmd + \cmd \mid \mu X.\cmd \\
\pi  & ::= & \primc \mid \ptrans{\trans} \\
\trans  & ::= & \nil \mid X \mid \primt.\trans \mid \trans + \trans \mid  \mu X. \trans \\
\end{rclarray}
\]
%\sx{what is the different between . and \(\pseq\) , \ie \( t \mid \trans \pseq \trans \mid \dots \).  }
%\ac{The mathematical structure that defines syntactically correct programs is different. In particular, if you 
%want to prove a property of a program, by induction on the syntax of that program, you have two 
%different inductive principles, whether your syntax allows $\primc. \cmd$ or $\cmd_1 \pseq \cmd_2$.}

A program corresponds therefore to a set of commands executing in parallel. 
Each command in a command is annotated with a thread identifier $\tid$. 
\ac{Following a discussion on the semantics, nobody likes thread identifiers. It 
may simply be the case that we model a program as a set of commands, each of 
which is augmented with a history heap and the view on such history heaps.}
%Note that each command is annotated with a component $V$, called a \emph{view} which we 
%have purposely left unexplained. At an intuitive level, in a program of the form 
%$V : \cmd \Par \prog$, the view $V$ specifies the version that the command $C$ observes, 
%for each location. Views are described formally when introducing the operational semantics of 
%commands.
%
%Note that each thread has a unique thread identifier $\tid$ associated. The set 
%of all thread identifiers is $\tidset$.

\section{Interpretation of Expressions and Primitive Commands}
Expressions are going to be evaluated in values from $\mathbb{N}$ in the usual way. 
Note that we need to account for the fact that we have two different notions of 
stacks, one transaction-local, and the other thread-local. 
\ac{We agreed to ditch the transaction-local stack. This will change in future versions.}
\[
\begin{rclarray}
\interpr{\cdot}(.)(.) &:& \Expr \times \ThdStacks \times \TxStacks \to \mathbb{N}\\
\interpr{\val}(\thdstack)(\txstack) & \defeq & \val \\
\interpr{\mathtt{x}}(\thdstack)(\txstack) & \defeq & \thdstack(\mathtt{x})\\
\interpr{\mathtt{a}}(\thdstack)(\txstack) & \defeq & \txstack(\mathtt{a})\\
\interpr{E_1 + E_2}(\thdstack)(\txstack) & \defeq & \interpr{E_1}(\thdstack)(\txstack) + \interpr{E_2}(\thdstack)(\txstack)\\
\vdots & \defeq  & \vdots
\end{rclarray}
\]

Note that, for any expression $\expr$ such that $\isthdexp(\expr) = \ttrue$, we have 
that $\interpr{\expr}(\thdstack)(\txstack) = \interpr{\expr}(\thdstack)(\txstack')$ for 
any $\txstack, \txstack' \in \TxStacks$ and $\thdstack \in \ThdStacks$. 
In this case, we commit an abuse of notation and write $\interpr{\expr}(\thdstack)$ 
as a shorthand for $\interpr{\expr}(\thdstack)(\txstack_0)$, where $\txstack_0 = 
\lambda \mathtt{a} .0$.

%\sx{ why \( \txstack_0 = \lambda \mathtt{a} .0\) instead of any? I guess any is also ok. }
%\ac{ Standard initialisation value. Many programming languages use $0$ as a default value 
%for variables upon initialisation.}

We now proceed to define the state transformers associated to transactional and non-transactional primitive commands. 
For transactional primitive commands we have  
\[
\begin{rclarray}
(\thdstack, \txstack, \h) &\toT{\passign{\pvar{a}}{\expr}}& (\txstack\rmto{\pvar{a}}{\interpr{\expr}(\thdstack)(\txstack)}, \h)\\
(\thdstack, \txstack, \h) &\toT{\pderef{\pvar{a}}{\expr}}& (\txstack\rmto{\pvar{a}}{\h(\interpr{\expr}(\thdstack)(\txstack))}, \h)\\
(\thdstack, \txstack, \h) &\toT{\pmutate{\expr_{1}}{\expr_{2}}}& (\txstack, \h\rmto{\interpr{\expr_{1}}(\thdstack)(\txstack)}{\interpr{\expr}(\thdstack)(\txstack)})\\
(\thdstack, \txstack, \heap) &\toT{\assume(\expr)} & (\thdstack,\heap) \  \text{where} \  \interpr{E}(\thdstack)(\txstack) \neq 0 \\
\end{rclarray}
\]
For non-transactional primitive commands we have 
\[
\begin{rclarray}
\thdstack & \toC{\passign{\pvar{x}}{\expr}} & \thdstack\rmto{\pvar{x}}{\interpr{\expr}(\thdstack)} \  \text{where} \  \isthdexp(\expr) = \ttrue\\
\thdstack & \toC{\assume(E)} & \thdstack \ \text{where} \ \isthdexp(\expr) = \ttrue \land \interpr{\expr}(\thdstack) \neq 0
\end{rclarray}
\]

For some transactional primitive command $t$, we also defined its fingerprint, 
which denotes the contribution of the primitive command $t$ in terms of operations that may be 
potentially observed by the external environment (i.e. other transactions). 
Formally, we assume a set of operations $\Op$ that we leave unspecified, aside the fact that 
we require that $\Op \supseteq \Setcon{ \varepsilon, \RD\;[\nat] :\val, \WR\;\addr :\val }{[\nat] \in \Addr \land \val \in \Val }$. 
Here $\varepsilon$ denotes the \emph{empty operation}, that is one that does not read, nor write from the shared state.
We assume a function  $\fingerprint : \cmd \times \ThdStacks \times \TxStacks \times \Heaps \to \Op$. 
This denotes the kind of operation that is performed by  $t$. 
\[
\begin{array}{lclr}
\fingerprint(\passign{\pvar{a}}{\expr}, \stub, \stub, \stub) & \defeq & \varepsilon & \\
\fingerprint(\pderef{\pvar{a}}{\expr},\thdstack,\txstack,\h) & \defeq  & \RD\; [n] : h([n]) & \text{where } n := \interpr{\expr}(\thdstack)(\txstack)\\
\fingerprint(\pmutate{\expr_{1}}{\expr_{2}},\thdstack,\txstack,\heap) & \defeq & \WR\; [n_1] : n_2 & \text{where } n_i := \interpr{\expr_i}(\thdstack)(\txstack), i=1,2
\end{array}
\]
%\sx{
%Previously we are setting up the \(t\) as in a very generous form, now we are saying some of then can be extracted to a read/write form. 
%Here it is a bit inconsistent.
%Minor point but might change later.
%
%Possibly finger print heap with  \( \ws{\h} \) and \( \rs{\h} \) functions is a good way to go.
%}
\section{Semantics of Transactions}
The semantics of transactions is given in an operational way, 
judgements take the form $\thdstack \vdash \langle \txstack, \heap, \mathcal{O}, \trans \rangle 
\to \langle \txstack', \heap', \mathcal{O}', \trans' \rangle$. Here $\mathcal{O}, \mathcal{O}' \subseteq \Op$ 
keep track of the fingerprint of the transaction being executed. Note that in this semantics 
the $\thdstack$ component cannot be manipulated by performing a transition, as to reflect 
the fact that transactions can only read from, and never write to, the thread local heap.
%The components $\RS, \WS \in \Addr \parfun \Val$ record the read-set and write-set associated to the transaction code, 
%respectively.

We also assume a partial operator $\oplus$ that specifies the effects of adding a new operation inside 
a set of previously defined operations. Again, the behaviour of $\oplus$ is left widely unspecified, 
exception made for the rules that govern read and write operations.
%In order to give the semantics of transactions, it will be useful to define the following operator over sets of 
%operations. 
%\[
%\begin{rclarray}
%\RS \RScup (\addr, \val) & \defeq  & \RS \uplus \Set{\addr \mapsto \val} \\
%\WS \WScup (\addr, \val) & \defeq & \WS\rmto{\addr}{\val} 
%\end{rclarray}
%\]
\[
\begin{array}{lcl}
\mathcal{O} \oplus \varepsilon &=& \mathcal{O}\\
\mathcal{O} \oplus (\RD\;[n]: m) &=&
\begin{cases}
\mathcal{O} \cup \{\RD\; [n]: m)\} & \impliedby \mathcal{O} \cap \{ \RD\;[n]: m, \WR [n]: m \mid m \in \Val\} = \emptyset\\
\mathcal{O} & \impliedby \text{otherwise}
\end{cases}\\
\mathcal{O} \oplus (\WR\;[n]: m) &=& 
(\mathcal{O} \setminus \{ \WR;[n] : m \mid m \in \Val \}) \cup \{\WR\;[n]: m \}
\end{array}
\]

The rules of the operational semantics for transactions are the following: 
%\[
%\infer[{\scriptstyle{(prim-t-local-nofp)}}]
%{\thdstack \vdash \langle \txstack, \heap, \mathcal{O}, t.\trans  \rangle \rightarrow \langle \txstack', \heap', \mathcal{O}, \trans \rangle}
%{(\thdstack, \txstack, \heap) \toT{t} (\txstack', \heap') \qquad \fingerprint(t,\thdstack,\txstack,\heap) = \text{undefined}}
%\]

\[
\infer[{\scriptstyle{(prim-t-fp)}}]
{\thdstack \vdash \langle \txstack, \heap, \mathcal{O}, t.\trans  \rangle \rightarrow \langle \txstack', \heap', \mathcal{O} \oplus op, \trans \rangle}
{(\thdstack, \txstack, \heap) \toT{t} (\txstack', \heap') \qquad \fingerprint(t,\thdstack,\txstack,\h) = op}
\]

%\[
%\infer[{\scriptstyle{(prim-t-write)}}]
%{\thdstack \vdash \langle \txstack, \heap, \RS, \WS, t.\trans \rangle \rightarrow \langle \txstack', \heap', \RS, \WS \WScup (\addr,\val), \trans \rangle}
%{(\thdstack, \txstack, \heap) \toT{t} (\txstack', \heap') \qquad \fingerprint(t,\thdstack,\txstack,\h) = (\WR, \addr, \val)}
%\]

\[
\infer[{\scriptstyle{(\Tx-choice-L)}}]{\thdstack \vdash \langle \txstack, \heap, \mathcal{O}, \trans_1 + \trans_2 \rangle 
\rightarrow \langle  \txstack, \heap, \mathcal{O}, \trans_1 \rangle}{}
\]

\[
\infer[{\scriptstyle{(\trans-choice-R)}}]{\thdstack \vdash \langle \txstack, \heap, \mathcal{O}, \trans_1 + \trans_2 \rangle 
\rightarrow \langle  \txstack, \heap, \mathcal{O}, \trans_2 \rangle}{}
\]

\[
\infer[{\scriptstyle{(\Tx-fix)}}]{\thdstack \vdash \langle \txstack, \heap, \mathcal{O}, \mu X.\trans \rangle 
\rightarrow \langle  \txstack, \heap, \mathcal{O}, \{\nicefrac{\mu X.\trans}{X}\}\trans \rangle}{}
\]

%\ac{Design Choice: maybe the heap should go away in the right hand side of judgments for 
%transactional commands. Judgements may take the form $\thdstack, \heap \vdash \langle \txstack, \mathcal{O}, \trans \rangle 
%\rightarrow \langle \txstack', \mathcal{O'}, \trans' \rangle$; then one can define the operator 
%$\mathsf{lift}: (\heap, \mathcal{O}) \mapsto \heap'$ by letting $\mathsf{lift}(h, \mathcal{O})([\nat]) = m$ if $\WR\;[n]: m \in \mathcal{O}$, 
%$h([n])$ otherwise - note that this operator is well-defined only in the case that whenever $\WR\; [n]:m, \WR\;[n]:m' \in \mathcal{O}$, 
%then $m = m'$. Then one can define sequences of computations by means of these two rules: 
%\[
%\infer[{\scriptstyle(SeqTx-Id)}]{\thdstack, \heap \vdash \langle \txstack, \mathcal{O}, \trans \rangle \twoheadrightarrow
%\langle \txstack, \mathcal{O}, \trans \rangle}{}
%\]
%\[
%\infer[{\scriptstyle(SeqTx-trans)}]{\thdstack, \heap \vdash \langle \txstack, \mathcal{O}, \trans \rangle \twoheadrightarrow 
%\langle \txstack'', \mathcal{O}'', \trans'' \rangle}
%{\begin{array}{c}\thdstack, \heap \vdash \langle \txstack, \mathcal{O}, \trans \rangle \twoheadrightarrow \langle \txstack', \mathcal{O}', \trans' \rangle
%\qquad \heap' = \mathsf{lift}(\heap, \mathcal{O}')\\
%\thdstack, \heap' \vdash \langle \txstack', \mathcal{O}', \trans' \rangle \rightarrow \langle \txstack'', \mathcal{O}'', \trans'' \rangle  \end{array}}
%\]
%}
%\section{Abstract Executions}
%Here we present abstract executions, which we will use to record the 
%run-time behaviour of programs. 
%
%We start by defining the behaviour of transactions at run-time. 
%We assume a set of (run-time) transactions identifiers $\TransID = \{\tsid, S , \cdots \}$ 
%and a set of operations which we leave unspecified, though 
%we require that $\Op \supseteq \Setcon{ \RD\;\addr :\val, \WR\;\addr :\val }{\addr \in \Addr \land \val \in \Val }$.
%We also assume a function $\behav : \TransID \to \powerset{\Op}$, which maps 
%transactions into the operations that they perform on locations. With an abuse of 
%notation, for any transaction $\tsid$ and operation $o$, we write $o \in \tsid$ (or $\tsid \ni o$) as 
%a shorthand for $o \in \behav(\tsid)$. 
%We only model transaction that enjoy \emph{atomic visibility}. This 
%means that \textbf{(i)} transactions never observe two different values when reading from 
%the same location: $\for{ \tsid \in \TransID,  \addr \in \Addr,\val, \val' \in \Val }
%\tsid\ni \RD\;\addr :\val \land \tsid \ni \RD\;\addr:\val' \implies \val = \val'$; and \textbf{(ii)} 
%the effects of a transactions become visible at once, which means that we never observe
%two different values written for the same location by a transaction: $\for{ \tsid \in \TransID, \addr \in \Addr, \val,\val' \in \Val } 
%\tsid \ni \WR\;\addr: \val \land \tsid \ni \WR\;\addr:\val' \implies \val = \val'$.
%
%\begin{definition}[abstraction executions]
%An abstract execution is a tuple $\aexec = (\settrans, \PO, \VIS, \AR)$, where 
%
%\begin{enumerate}
%\item 
%$\T$ is a finite, empty set of transactions, 
%
%\item 
%$\PO \subseteq \T \times \T$, the \emph{program order}, is the union 
%of disjoint, strict total orders over $\T$. That is, there exists a partition $\{\T_i\}_{i \in I}$ 
%of $\T$ such that $\PO = \bigcup_{i \in I} \PO_i$, where for any $i \in I$, $\PO_i$ is a strict, 
%total order over $\T_i$\footnote{Recall that a relation $R \subseteq \T \times \T$ is a strict partial order 
%if it is irreflexive and transitive. It is a strict total order if it enjoys the additional property that 
%for any $T_1, T_2 \in \T$, either $T_1 = T_2$, $(T_1, T_2) \in R$ or $(T_2, T_1) \in R$.},
%
%%\item 
%$\VIS \subseteq \T \times \T$ is a strict, partial order such that $\PO \subseteq \VIS$, and $\VIS \rcomp \VIS \subseteq 
%\VIS$,
%
%%\item 
%$\AR \subseteq \T \times \T$ is a strict, total order such that $\VIS \subseteq \AR$,
%
%%\item 
%for any location $\addr \in \Addr$ let $\WTr(\addr) = \Setcon{S \in \T }{S \ni \WR\;\addr:\anyval }$. 
%Given $T \in \T$, let also $\pw_{\aexec}(\addr, \tsid) = \Setcon{\tsid' }{ \tsid' \in \VIS^{-1}(\tsid)} \cap \WTr(\addr)$. 
%Whenever $T \ni \RD\;\addr: \val$ for some transaction $\tsid \in \T$, location $\addr \in \Addr$ and 
%value $\val \in \Val$, then either $\pw_{\aexec}(\addr, \tsid) = \emptyset$ and $\val = 0$, 
%or $\max_{\AR}(\pw_{\aexec}(\addr, \tsid)) \ni \WR\;\addr: \val$.
%
%\end{enumerate}
%
%\end{definition}
%The set of all abstract executions is denoted as $\aeset$.
%In the following, for an abstract execution $\aexec = (\T, \PO, \VIS, \AR)$, we let 
%$\T_{\aexec} = \T$, $\PO_{\aexec} = \PO$, $\VIS_{\aexec} = \VIS$, $\AR_{\aexec} = \AR$. 
%We often use the notation $T \xrightarrow{R} S$ instead of $(T,S) \in R$.
%
%\paragraph{\textbf{Specification of Weak Consistency Models.}}
%We use the style of specification for weak consistency models 
%proposed in \cite{laws}. 
%
%\begin{definition}
%A specification function $\rho$ is an endo-function of relations over 
%transactions, $\rho: (\TrSet \times \TrSet) \rightarrow (\TrSet \times \TrSet)$,
%such that for any abstract execution $\aexec$ and relation $R \subseteq \T_{\aexec} \times \T_{\aexec}$, 
%$\rho(R) = \rho(\T_{\aexec} \times \T_{\aexec}) \cap R?$. 
%
%A consistency guarantee is a pair $(\rho, \pi)$ of specification functios.
%An abstract execution based specification of weak consistency models, or simply \emph{x-specification}, 
%is a (possibly empty, possibly infinite) set of consistency guarantees: $\xspec = \{(\rho_i, \pi_i)\}_{i \in I}$ 
%for some index set $I$.
%\end{definition}
%
%\begin{definition}
%An abstract execution $\aexec$ is allowed by the consistency model specification $\xspec$, 
%written $\xspec \models \aexec$, if and only if, for any $(\rho, \pi) \in \xspec$, we have that $\rho(\VIS_{\aexec}) \rcomp \AR_{\aexec} 
%\rcomp \VIS_{\aexec} \subseteq \AR_{\aexec}$.
%\end{definition}
%
%\begin{example}
%Let $\rho_{\Id} = \lambda \_. \Id$, $\rho_{\SI} = \lambda R. (R \setminus \Id)$, and $\rho_[n] = 
%\lambda \_. [\WTr_{[n]}]$ for any location $[n] \in \locs$. Here, given a set $X \subseteq \TrSet$, 
%$[X]$ is defined as $\Id \cap (X \times X)$. We specify \emph{Snapshot Isolation} via the set 
%of consistency guarantees $\xspec_{\SI} = \{(\rho_{\Id}, \rho_{\SI})\} \cup \bigcup_{[n] \in \locs} \{(\rho_{[n]}, \rho_{[n]}\}$. 
%
%An abstract execution $\aexec$ is allowed by $\xspec_{\SI}$ if and only if 
%$\AR_{\aexec} \rcomp \VIS_{\aexec} \subseteq \VIS_{\aexec}$, 
%and for any $[n] \in \locs$, $[\WTr_{[n]}] \rcomp \AR_{\aexec} \rcomp [\WTr_{[n]}] \subseteq \VIS$.
%\end{example}
%\sx{NEED TO REVISIT ABOVE LATER}
%
%In the following, we will use an incremental approach to build abstract executions from transactions. 
%Suppose that an abstract execution $\aexec$ has been obtained as the (partial) result of a program $P$ running 
%in a system that implements the x-specification $\xspec$. 
%Suppose also that $T \in \T_{\aexec}$ is the transaction-instance associated with the last transactional 
%code that has been executed by some thread, and that the same thread executes another piece of transactional 
%code next, which results in the transaction instance $S$. This may result in an abstract execution $\aexec'$, 
%where the new transaction instance $S$ follows $T$ in the program order $\PO_{\aexec'}$, and $\VIS_{\aexec'}, 
%\AR_{\aexec'}$ are computed according to the axioms of $\xspec$.
%$T \in \T_{\aexec}$. Note that the result of this procedure may result in an abstract execution that 
%is not allowed by $\xspec$, hence it is not always defined.
%Formally, we define an operator $\aeplus_{\xspec} : (\aeset \times \TrSet) \rightharpoonup 
%\aeset$ as follows:
%
%\begin{defn}[Runtime abstract executions]
%Assuming set of thread identifiers \( \ThreadID \defeq \Set{\thid, \dots}\), the set of \emph{runtime abstract executions} is defined as the follows,
%\[
%    \begin{rclarray}
%    \aexecrun \in \Setcon{(\settrans, \PO, \VIS, \AR) 
%    }{ 
%        \settrans \in  (\TransID \uplus \ThreadID ) \parfun \powerset{\Events}  \\
%        {} \land  \PO, \VIS \subseteq ( \dom(\settrans) \cap \TransID ) \times \dom(\settrans) \\
%        {} \land  \AR \subseteq ( \dom(\settrans) \cap \TransID  ) \times ( \dom(\settrans) \cap \TransID )
%    }
%    \end{rclarray}
%\]
%\end{defn}
%
%\begin{definition}
%Let $\xspec$ be a x-specification. 
%Let $\aexec \in \aeset$, and let $T \in \T_{\aexec}$. 
%Also, let $S \in \TrSet \setminus \T_{\aexec}$.
%Define the abstract execution $\aexec'$ as follows: 
%in which case we have
%\begin{gather*}
%\PO_{\aexec}' = (\PO_{\aexec} \cup \{(T,S)\})^{+}\\
%\AR_{\aexec}' = \{(T', S), (S, T'') \mid T' \in \AR_{\aexec}^{-1}(T) \wedge T'' \in \AR_{\aexec}(T)\}^{+}\\
%\VIS_{\aexec}' = \mu V.(\PO_{\aexec}' \cup \VIS_{\aexec} \cup \bigcup_{(\rho, \pi \in \xspec)} \rho(V) \rcomp \AR_{\aexec}' \rcomp \pi(V) )^{+}
%\end{gather*}
%The abstract execution $(\aexec, T) \aeplus_{\xspec} S$ is defined to be exactly $\aexec'$ 
%if whenever $S \ni \WR\;[n]:\_$ and $S \xrightarrow{\VIS_{\aexec}'} T$, then $T \not\ni \RD\;[n]:\_$ 
%and $T \not\ni \WR\;[n]:\_$, 
%it is undefined otherwise.
%\end{definition}
%
%\begin{proposition}
%Let $\xspec$ be a x-specification, and suppose that $\xspec \models \aexec$ for some abstract
%execution $\aexec$. Let $T, S$ be two transactions such that $(\aexec, T) \aeplus_{\xspec} S$ is
%defined. Then $\xspec \models (\aexec, T) \aeplus_{\xspec} S$.
%\end{proposition}
%\ac{Not sure whether it's true. Needs to be checked.}
%
%Note that, for a transaction $T_0$ such that $T_0 \ni o$ for no operation $o \in \Op$, 
%$(\aexec, T) \aeplus_{\xspec} T_0$ is always defined (provided $T_0 \notin \T_{\aexec}, T \in \T_{\aexec})$.
%
%Given an abstract execution and a x-specification $\aexec$, we can map any transaction $T \in \T_{\aexec}$ 
%to a heap $\heap_{\aexec}^{\xspec}(T)$. Intuitively, the latter corresponds to the heap that would be observed 
%by a client that interact with a system implementing the x-specification $\xspec$, assuming that 
%the set of transactions processed by the system so far resulted has given rise to the abstract execution 
%$\aexec$, and that the last transaction instance of $\aexec$ observed by the client is $T$.
%
%\begin{definition}
%Let$\xspec$ be a consistency model specification, and $\aexec$ be an abstract execution. For any $T \in \T_{\aexec}$, 
%let $\aexec' = (\aexec, T) \aeplus_{\xspec} T_0$, where $T_0 \notin \T_{\aexec}$ and $T_0 \ni o$ for no 
%$o \in \Op$. We can always assume that such a transaction exists. 
%
%We define $\heap_{\aexec}^{\xspec}(T)$ as follows:
%\[
%\heap_{\aexec}(T) = \lambda [n] \in \locs.
%\begin{cases}
%0 &\impliedby \pw_{\aexec'}([n], T) = \emptyset\\
%m & \impliedby \max_{\AR_{\aexec'}}(\pw_{\aexec'}([n], T_0)) \ni \WR\;[n]: m 
%\end{cases}
%\]
%\end{definition}
%\ac{I don't really like this definition, but for the moment it will do...}
%
%\begin{example}
%Consider the abstract execution $\aexec$ depicted below, denoting the write-skew anomaly 
%allowed by snapshot isolation. 
%
%\begin{center}
%\begin{tikzpicture}
%\node(Rx0) {$\RD\;[1]: 0$};
%\path(Rx0.center) + (0,-0.5) node (Wy1) {$\WR\;[2]: 1$};
%\path(Rx0.center) + (4,0) node (Ry0) {$\RD\;[2]: 0$};
%\path(Ry0.center) + (0,-0.5) node (Wx1) {$\WR\;[1]: 1$};
%%
%\begin{pgfonlayer}{background}
%\node(t1)[background, fit=(Rx0)(Wy1), inner sep=0.15cm] {};
%\node(t2)[background, fit=(Ry0)(Wx1), inner sep=0.15cm] {};
%\path(t1.west) + (-0.25,0) node (T) {$T$};
%\path(t2.east) + (0.25,0) node(S) {$S$};
%\path[->, thick]
%(t2.west) edge node[above] {$\AR$} (t1.east);
%\end{pgfonlayer}
%\end{tikzpicture}
%\end{center}
%Let us calculate $\heap_{\aexec}^{\xspec_{\SI}}(T)$. 
%Let then $T_0$ be a transaction with no operation associated, 
%and let us compute $\aexec' = (\aexec, T) \aeplus_{\xspec_{\SI}} T_0$. 
%By definition, we have that $T \xrightarrow{\PO_{\aexec'}} T_0$, hence 
%$T \xrightarrow{\VIS_{\aexec'}} T_0$. Because $S \xrightarrow{\AR_{\aexec}}T$, 
%we also have that $S \xrightarrow{\AR_{\aexec}} T$, and now from 
%$S \xrightarrow{\AR_{\aexec'}} T \xrightarrow{\VIS_{\aexec'}} T_0$, 
%we obtain that $S \xrightarrow{\VIS_{\aexec'}} T_0$. By definition, 
%we also know that $S \xrightarrow{\AR_{\aexec}} T$ implies that 
%$S \xrightarrow{\AR_{\aexec'}} T_0$. The final result is the abstract 
%execution $\aexec'$ depicted below: 
%\begin{center}
%\begin{tikzpicture}
%\node(Rx0) {$\RD\;[1]: 0$};
%\path(Rx0.center) + (0,-0.5) node (Wy1) {$\WR\;[2]: 1$};
%\path(Rx0.center) + (4,0) node (Ry0) {$\RD\;[2]: 0$};
%\path(Ry0.center) + (0,-0.5) node (Wx1) {$\WR\;[1]: 1$};
%\path(Wy1.center) + (0,-2.5) node (phantom) {\phantom{$\WR\;[2]: 1$}};
%%
%\begin{pgfonlayer}{background}
%\node(t1)[background, fit=(Rx0)(Wy1), inner sep=0.15cm] {};
%\node(t2)[background, fit=(Ry0)(Wx1), inner sep=0.15cm] {};
%\node(t3)[background, fit=(phantom), inner sep=0.15cm] {};
%\path(t1.west) + (-0.25,0) node (T) {$T$};
%\path(t2.east) + (0.25,0) node(S) {$S$};
%\path(t3.west) + (-0.3,0) node(T0) {$T_0$};
%\path[->, thick]
%(t2.west) edge node[above] {$\AR$} (t1.east)
%(t1.south) edge node[left] {$\PO, \VIS,\AR$} (t3.north)
%(t2.south west) edge node[right] {\;\;\;$\VIS, \AR$} (t3.north east);
%\end{pgfonlayer}
%\end{tikzpicture}
%\end{center}
%It is easy to see that $\pw_{\aexec'}([1], T_0) = \{S\}$, and $\pw_{\aexec'}([2], T_0) = \{T\}$. 
%Because $S \ni \WR\;[1]:1$, we have that $\heap_{\aexec}^{\xspec_{\SI}}(T)([1]) = 1$, 
%and because $T \ni \WR\;[2]:1$, we have that $\heap_{\aexec}^{\xspec_{\SI}}(T)([2]) = 1$.
%
%Next, we want to calculate $\heap_{\aexec}^{\xspec_{\SI}}(S)$. To this end, we need first 
%to retrieve the abstract execution $\aexec'' = (\aexec, S) \aeplus_{\xspec_{\SI}} T_0$, 
%which is depicted below:
%\begin{center}
%\begin{tikzpicture}
%\node(Rx0) {$\RD\;[1]: 0$};
%\path(Rx0.center) + (0,-0.5) node (Wy1) {$\WR\;[2]: 1$};
%\path(Rx0.center) + (4,0) node (Ry0) {$\RD\;[2]: 0$};
%\path(Ry0.center) + (0,-0.5) node (Wx1) {$\WR\;[1]: 1$};
%\path(Wx1.center) + (0,-2.5) node (phantom) {\phantom{$\WR\;[1]: 1$}};
%%
%\begin{pgfonlayer}{background}
%\node(t1)[background, fit=(Rx0)(Wy1), inner sep=0.15cm] {};
%\node(t2)[background, fit=(Ry0)(Wx1), inner sep=0.15cm] {};
%\node(t3)[background, fit=(phantom), inner sep=0.15cm] {};
%\path(t1.west) + (-0.25,0) node (T) {$T$};
%\path(t2.east) + (0.25,0) node(S) {$S$};
%\path(t3.east) + (0.25,0) node(T0) {$T_0$};
%\path[->, thick]
%(t2.west) edge node[above] {$\AR$} (t1.east)
%(t2.south) edge node[right] {$\PO, \VIS,\AR$} (t3.north)
%(t3.north west) edge node[right] {\;\;\;$\AR$} (t1.south east);
%\end{pgfonlayer}
%\end{tikzpicture}
%\end{center}
%In this case we have that $\pw_{\aexec''}([1],T_0) = \{S\}$, 
%and $\pw_{\aexec''}([2], T_0) = \emptyset$. By definition, 
%we have that $\heap_{\aexec}^{\xspec_{\SI}}(S)([1]) = 1$, 
%and $\heap_{\aexec}^{\xspec_{\SI}}(S)([2]) = 0$.
%\end{example}
%
%\paragraph{\textbf{Semantics of Commands.}}
%Judgements for programs take the form 
%$\langle \aexec, T, \thdstack \Cmd \rangle \rightarrow \langle \aexec', T',  \thdstack', \Cmd' \rangle
%$.Here $\aexec$ is an abstract execution that represent 
%the global run of the database, 
%$T$ represents the last transaction executed by the command, in the abstract execution, 
%and $\thdstack$ is the thread local stack associated with the transaction.
%
%The rule for evaluating a non-transactional primitive command is straightforward, as it 
%does only require to manipulate the thread-local stack associated  with the command. 
%\[
%\infer[{\scriptstyle{(prim-c)}}]
%{\langle \aexec, T, \thdstack, \primc.\Cmd \rangle \rightarrow \langle \aexec, T, \thdstack', \Cmd \rangle}
%{\thdstack \rightsquigarrow_c \thdstack'} 
%\]
%
%Next, we give the rule for evaluating a transaction in a command of the form $\TxOp{\trans}.\Cmd$. 
%First, given a read-set $\RS$ and a write-set $\WS$, we define the set of transaction $\makeTx(\RS,\WS)$ 
%to be the largest set of transactions such that, whenever $T \in \makeTx(\RS, \WS)$, then $T \ni \RD\;[n]:m$, if and only if $([n], m) \in \RS$, and $T \ni 
%\WR\;[n]:m$ if and only if $([n], m) \in \WS$. 
%\[
%\infer[{\scriptstyle{(Tx-exec)}}]{\langle \aexec, T, \thdstack, \TxOp{\trans}.\Cmd \rangle \rightarrow 
%\langle \aexec', T', \thdstack[\retvar \mapsto \txstack'(\retvar)], \Cmd \rangle}
%{
%\begin{array}{lll}T \xrightarrow{\AR_{\aexec}} S &  T' \in (\makeTx(\RS,\WS) \setminus \T_{\aexec}) & \aexec' = (\aexec, S) \aeplus_{\xspec} T'\\[4pt]
%\multicolumn{3}{c}{\thdstack \vdash \langle \txstack_0, \heap_{\aexec}^{\xspec}(S), \emptyset, \emptyset, \trans \rangle \rightarrow^\ast \langle \txstack', \heap', \RS, \WS, \nil \rangle}
%\end{array}}
%\]
%The three remaining rules are standard.
%\[
%\infer[{\scriptstyle{(C-choice-L)}}]
%{\langle \aexec, T, \thdstack, \Cmd_1 + \Cmd_2 \rangle \rightarrow \langle \aexec, \Cmd_1, \thdstack, \Cmd \rangle}
%{} 
%\]
%
%\[
%\infer[{\scriptstyle{(C-choice-R)}}]
%{\langle \aexec, T, \thdstack, \Cmd_1 + \Cmd_2 \rangle \rightarrow \langle \aexec, \Cmd_2, \thdstack, \Cmd \rangle}
%{} 
%\]
%
%\[
%\infer[{\scriptstyle{(C-fix)}}]
%{\langle \aexec, T, \thdstack, \mu X.\Cmd \rangle \rightarrow \langle \aexec, \{\nicefrac{\mu X.\Cmd}{X}\}\Cmd, \thdstack, \Cmd \rangle}
%{} 
%\]

\paragraph{\textbf{Semantics of Commands.}}
Before giving the semantics of commands, it will be necessary to formalise 
the notions of \emph{history heap} and \emph{view}. 
We assume countably infinite set of transaction identifiers $\TransID$, whose elements 
are ranged over $\tsid$. Subsets of $\TransID$ are ranged over by $\T$. 
A \emph{Version} is a triple 
$(v, \tsid, \{\tsid_1, \tsid_2,\cdots\}) \in \Val \times \TransID \times 2^{\TransID}$. 
The set of all versions is denoted by $\Versions$, and its elements are ranged over $\nu, \nu', \cdots$. 
Intuitively, associating a location $[n]$ with the version $\nu = (v, \tsid, \{\tsid_1,\tsid_,\cdots\})$ means that the 
value $v$ has been written for location $[n]$. The transaction that wrote version $\nu$ is $\tsid$, 
and the version has been read by transactions $\{\tsid_1,\tsid_2,\cdots\}$. 
Given a version $\nu := (v, \tsid, \T)$, we define $\valueof(\nu) = v$, $\WTx(\nu) := \tsid$, 
and $\RTx(\nu) := \T$.
A history heap is a function $\hh: \Addr \rightarrow \Versions^{\ast}$ that 
maps each location to its list of versions. As usual, if 
$\hh([n]) = \nu_0,\cdots, \nu_m$ for some location $[n]$, then for any 
$i= 0,\cdots, m$ we let $\hh([n])(i) = \nu_i$, and we let $\lvert \hh([n]) \rvert = m -1$. 
For a list of versions $vlist$, an index $i = 0,\ cdots, \lvert vlist \rvert - 1$, and a version $\nu$, 
we let  $vlist[i \mapsto \nu]$ to be the same of $vlist$, exception made for the version at 
location $i$ which is replaced with $\nu$.

Given a history heap $\hh$, we can extract several heaps 
from it, by simply choosing for each location $[n]$ a version 
contained in the list of versions available for $[n]$ in $\hh$, 
namely $\hh([n])$. 
In order to determine uniquely the heap in which a command 
is executing, we introduce \emph{views}. A view $V : \Addr \rightarrow \mathbb{N}$ is 
a function that maps a location $[n]$ to the index of the version 
that must be read for such a location. Given a history heap $\hh$ and a 
view $V$, we can construct a heap as follows:  
\[
\snapshot(\hh, V) = \lambda [n] \in \Addr. \big( \hh([n])(V([n]) \big)
%\begin{cases}
%v_{V([n])} &\impliedby \hh([n]) = \langle v_0, \_ , \_ \rangle \cdots \langle v_{m}, \_, \_ \rangle \wedge m \geq V([n])\\
%\text{undefined} & \text{otherwise}
%\end{cases}
\]

%Formally, we define a \emph{snapshot} 
%to be a function $\snapshot: \Addr \rightarrow \mathbb{N}$; 
%given a history heap $\hh$ and a snapshot $\snapshot$, 
%we can construct the heap 
%\[
%\heap(\hh, \snapshot) = \lambda [n] \in \Addr. 
%\begin{cases}
%v_{\snapshot([n])} &\impliedby \hh([n]) = \langle v_0, \_ , \_ \rangle \cdots \langle v_{m}, \_, \_ \rangle \wedge m \geq \snapshot([n])\\
%\text{undefined} & \text{otherwise}
%\end{cases}
%\]
%The syntax of commands has the form $V : \cmd$. Here $V$ is the view of the thread executing 
%the command $\cmd$. 
Judgements in the semantics of commands take the form 
\[ 
\langle \hh, \sigma, V: C \rangle \xrightarrow{\alpha} \langle \hh', \thdstack', V': \cmd' \rangle
\]

where $\alpha \in \{ \lambda, \delta \}$ identifies whether a transition performed within 
a command corresponds to a local computation ($\lambda$), such as executing a 
non-transactional primitive command or some housekeeping activity, or to an interaction with 
the database ($\delta$), that is executing a transaction.
\ac{Introducing labelled transitions was necessary to remove complications later on when dealing 
with the parallel composition of threads. More details when discussing the rule.}

The main rule in the operational semantics of commands is the one corresponding 
to the execution of a transaction, i.e. $\cmd = [\trans].\cmd'$. For this rule, we must specify the following: 
\begin{itemize}
\item How the execution of the transaction $[\trans]$ affects the history heap, and 
\item How the view of the thread executing the command is changed, after the transaction 
has been executed. 
\end{itemize}

Let us first discuss how the history heap is changed when executing a transaction. 
Recall that the history heap $\hh$ and the view $V$ determine a heap 
via the function $\snapshot$. By executing the transaction $[\trans]$ using 
such a snapshot is an initial state, we obtain the fingerprint of the transaction 
as a set of operations $\mathcal{O}$. We then choose a fresh transaction identifier 
$\tsid$ that is associated with the execution of $[\trans]$> 
Each read operation $\RD\;[n]:m$, 
refers to the version $\nu$ to which the view $V$ pointed before the transaction $[\trans]$ 
was executed: when we update the history heap, we must update the readset of 
such a version $\RS(\nu)$ to include the transaction $\tsid$. For write 
operations of the form $\WR\;[n]:m$, we create a new version 
$\nu = (m, \tsid, \emptyset)$ and we append it at the tail of $\hh([n])$.
Formally: 
\[
\begin{array}{lll}
\mathsf{HHupdate}_{\tsid}(\hh, V, \{\RD\;[n]: m\}) &=& 
\mathsf{let}\; (v, \tsid, RS) = \snapshot(\hh,V, [n]) \; \mathsf{in} \; \\
&&
\hh\Big[ [n] \mapsto  \Big( \hh([n])  [ V([n]) \mapsto (v, \tsid, RS \cup \{ \RD\;n: m\} ) ] \Big) \Big]
%\lambda [k].\begin{cases}
%\langle v_0, T_{0}, \T_{0} \rangle \cdots \langle v_i, T_{i}, \T_{i} \cup \{\tsid\} \rangle \cdots \langle v_{n_{k}}, T_{n_{k}}, \T_{n_{k}} \rangle\\
%\hspace{5pt} \text{if } [k] = [n] \wedge V([k]) = i &\\
%\hh([k]) \hspace{5pt} \text{otherwise}
%\end{cases}
\\
\mathsf{HHupdate}_{T}(\hh, \_, \{\WR\; [n]: m\}) &=& 
\hh\Big[ [n] \mapsto ( \hh([n]) \cdot \langle m, T, \emptyset \rangle) \Big]\\
\mathsf{HHupdate}_{T}(\hh, V, \mathcal{O}_1 \cup \mathcal{O}_2) &=& 
\mathsf{HHupdate}_{T}(\mathsf{HHupdate}_{T}(\hh, V, \mathcal{O}_1), V, \mathcal{O}_2)
\end{array}
\]

Next, we discuss how the view of a command is changed after executing 
a transaction. In this case, we only update the view of the locations that 
have been written by a transaction to be up-to-date with the version 
installed by the transaction that has been executed. 
Formally, we define the function 
\[
\begin{array}{lll}
\mathsf{ViewUpdate}(\hh, V, \mathsf{RD}\;[n]: m) &=& V\\
\mathsf{ViewUpdate}(\hh, V, \mathsf{WR}\;[n]: m) &=& V[ [n] \mapsto \lvert \hh([n])]\\
\mathsf{ViewUpdate}(\hh, V, \mathcal{O}_1 \cup \mathcal{O}_2) &=& \mathsf{update}(\hh, \mathsf{update}(\hh, V, \mathcal{O}_1), \mathcal{O}_2)
\end{array}
\]
\ac{Note that according to this definition the $\mathsf{ViewUpdate}$ function may push the view of a 
location out of the boundaries of the history heap by $1$. This happens when a new version is written 
for some location $[n]$. This is totally fine, as the new view will be paired with a history heap which 
carries a new version for location $[n]$, and the view is within the boundaries of such a history heap.}


%\ac{It seems that introducing history heaps and sessions here may be avoided. 
%In fact, the semantics of commands should be just a bridge between transaction 
%code and multi-threaded programs.}
%For commands, judgements take the form 
%\[
%\heap \vdash \langle \thdstack, \cmd \rangle \rightarrow \langle \thdstack', \mathcal{O}', \cmd' \rangle.
%\] 
We are now ready to give the operational semantics for commands.
The main rule for executing commands is the one that models the execution of one transaction. 
In the rule below we compare views according to a partial order $\sqsubseteq$, which 
is defined to be the point-wise comparison of values of views at single addresses: 
$V_1 \sqsubseteq V_2 \triangleq \forall [n] \in \Addr. V_1([n]) \leq V_2([n])$.
%In the rule below, ignore for the moment the side condition $\langle \hh, \{V\} \leadsto \langle \hh', \{V'\} \rangle$, 
%which we will explain when we introduce consistency models in the next section.
\ac{The side-condition has been moved to the semantics of programs, when we 
lift the semantics of commands. In any case, this is going to change in the future 
because we need to remove thread identifiers.}
%\[
%\infer[{\scriptstyle(Tx-exec)}]{\heap \vdash \langle \thdstack, [\trans].\cmd \rangle \rightarrow \langle \thdstack[\retvar \mapsto v], \mathcal{O}, \cmd \rangle}
%{\thdstack \vdash \langle \txstack_{0}, \heap, \emptyset, \trans \rangle \rightarrow^{\ast} \langle \txstack, \_, \mathcal{O}, \nil \rangle 
%\qquad \txstack(\retvar) = v}
%\]
\[
\infer[{\scriptstyle(Tx-exec)}]{\langle \hh, \thdstack, V, [\trans].\cmd \rangle \xrightarrow{\delta} \langle \hh', \thdstack', V', \cmd \rangle}
{\begin{array}{c}
\thdstack \vdash \langle \txstack_{0}, \heap, \emptyset, \trans \rangle \rightarrow^{\ast} \langle \txstack, \_, \mathcal{O}, \nil \rangle \\
%(\hh, V) \leadsto_{CM} (\hh', V') \\
\qquad
\hh' = \mathsf{HHupdate}(\hh, V, \mathcal{O}) \qquad V' = \mathsf{ViewUpdate}(\hh, V, \mathcal{O}) \qquad 
\thdstack' = \thdstack[\retvar \mapsto \txstack(\retvar)]
\end{array}
}
\]
\ac{Check that $V'$ is well-formed with respect to $\hh'$ is missing from the rule above. 
Also, for the moment I am going with the possibility of having conflicts in views as long as 
transactions cannot be executed. My catch here is that there are cases where whether 
a view is conflicting depends on the code of the transaction to be executed (i.e. write-conflict 
detection), so conflicting views cannot be avoided without losing completeness of the semantics). 
The rule below allows for views to be pushed to the right, so as to resolve conflicts.}

We also introduce a rule that allows to update the view of the thread executing a command. 
We say that the view $V$ is dominated by $V'$, written $V \sqsubseteq V'$, if for any 
location $[n]$ we have that $V([n]) \leq V'([n])$.
\[
\infer[{\scriptstyle{(C-View-Update)}}]
{\langle \hh, \thdstack, V, \cmd \rangle \xrightarrow{\lambda} \langle \hh, \thdstack, V', \cmd \rangle }
{ V \sqsubseteq V'}
\]

The other rules of the operational semantics are standard: 

\[
\infer[{\scriptstyle{(prim-c)}}]
{\langle \hh, \thdstack, V, \primc.\cmd \rangle \xrightarrow{\lambda} \langle \hh, \thdstack', V, \cmd \rangle}
{\thdstack \rightsquigarrow_c \thdstack'} 
\]

\[
\infer[{\scriptstyle{(C-Choice-L)}}]
{\langle \hh, \thdstack, V, \cmd_1 + \cmd_2 \rangle \xrightarrow{\lambda} \langle \hh, \thdstack, V, \cmd_1 \rangle}
{} 
\]

\[
\infer[{\scriptstyle{(C-Choice-L)}}]
{\langle \hh, \thdstack, V, \cmd_1 + \cmd_2 \rangle \xrightarrow{\lambda} \langle \hh, \thdstack, V, \cmd_2 \rangle}
{} 
\]

\[
\infer[{\scriptstyle{(C-Choice-L)}}]
{\langle \hh, \thdstack, V, \mu X.\cmd \rangle \xrightarrow{\lambda} \langle \hh, \thdstack, V, \{\mu X.\cmd/X\}\cmd \rangle}
{} 
\]

%\[
%\infer[{\scriptstyle{(prim-c)}}]
%{\heap \vdash \langle \thdstack, \primc.\cmd \rangle \rightarrow \langle \thdstack', \emptyset, \Cmd \rangle}
%{\thdstack \rightsquigarrow_c \thdstack'} 
%\]
%
%\[
%\infer[{\scriptstyle{(C-Choice-L)}}]
%{\heap \vdash \langle \thdstack, \cmd_1 + \cmd_2 \rangle \rightarrow \langle \thdstack, \emptyset, \cmd_1 \rangle}
%{} 
%\]
%
%\[
%\infer[{\scriptstyle{(C-Choice-R)}}]
%{\heap \vdash \langle \thdstack, \cmd_1 + \cmd_2 \rangle \rightarrow \langle \thdstack, \emptyset, \cmd_2 \rangle}
%{} 
%\]
%
%\[\infer[{\scriptstyle{(C-Fix)}}]
%{\heap \vdash \langle \thdstack, \mu X.\cmd \rangle \rightarrow \langle \thdstack, \emptyset, \{\mu X.\cmd/X\}\cmd \rangle}
%{} 
%\]

%\ac{I really don't like this style for expressing the rules of the operational semantics. 
%Intuitively we may want the LHS and RHS of judgements to be the same, 
%as it is standard. However, this means that we need to carry around a lot of redundant 
%information, for example heap states.}

\subsection{Semantics of Programs}
We want a semantics of programs where transactions are 
executed atomically, in an interleaving fashion, while still capturing non-serialisable 
behaviours. We also want our operational semantics to be parametric in the definition of 
a consistency model. 

In this sense, a consistency model specification is the set of all the possible transitions that 
are allowed by the semantics. Formally, a consistency model specification $CM$ is 
a set of quadruples of the form $(\hh, \mathcal{V}, \hh', \mathcal{V}')$, 
where $\mathcal{V}, \mathcal{V}'$ are non-empty, finite multi-sets of views,
and we often write $(\hh, \mathcal{V}) \leadsto_{CM} (\hh, \mathcal{V}')$ 
in lieu of $(\hh, \mathcal{V}, \hh', \mathcal{V}') \in CM$. 
\ac{Had to switch to multi-sets, though I'm looking for alternatives.}
%We place the following well-formedness constraints on specifications 
%of consistency models. We say that $CM$ is well-formed if: 
%\begin{enumerate}
%\item[Views can be pushed] for any $\hh, \mathcal{V}, V, V'$ such that 
%$V \sqsubseteq V'$, then $(\hh, \mathcal{V} \cup \{V\} \leadsto_{CM} \hh, \mathcal{V} \cup \{V'\})$. 
%This condition also implies that $CM$ must be reflexive, 
%\item[Transactions can be renamed] for any $\hh, \mathcal{V}, \hh', \mathcal{V}'$ and transaction $\tsid$ that does not appear 
%$\hh, \hh'$, $(\hh[\tsid \mapsto \tsid'], \mathcal{V}) \leadsto_{CM} (\hh'[\tsid \mapsto \tsid'], \mathcal{V}')$, 
%\item[Atomic Visibility], let us say that a configuration $(\hh, \{V\})$ enjoys atomic visibility 
%if, whenever $\hh([n])(i) = (\_, \tsid, \_)$ for some $i \leq V([n])$, then for any $[m]$ and 
%$j'$ such that $\hh([m])(j') = (\_, \tsid, \_)$, $j' \leq V([m])$. We say that $(\hh, \mathcal{V})$ 
%enjoys atomic visibility if $(\hh, \{V\})$ enjoys atomic visibility for all $V$ such that 
%$\mathcal{V} = \mathcal{V}' \cup \{V\}$. A consistency model specification enjoys atomic 
%visibility if and only if, whenever $(\hh, \mathcal{V}) \leadsto_{CM} (\hh', \mathcal{V}')$, 
%then $(\hh, \mathcal{V}$ and $(\hh, \mathcal{V}')$ enjoy atomic visibility.
%\end{enumerate}
%The well-formedness condition reflects the fact that internal computations of threads that do not 
%result in an interaction with the database (i.e. resolution of non-deterministic choices, unfolding 
%of fixed point operators, pushing views) must always be allowed by the consistency model. 
%Obviously, any consistency model $CM$ can be strengthened to a well-formed one $\overline{CM}$.
%
%\ac{Ok, this is completely screwed. Atomic visibility clashes with the closure constraint that 
%views can be always pushed. The reason why we have the closure constraint is because, when 
%we define the rule for the parallel composition, we check that an action performed by a single 
%thread does not conflict with the views of other threads, and we always want local computation 
%of threads to be allowed. 
%One possible solution to this problem would be to first constrain all configurations to 
%those that enjoy atomic visibility. A second solution would be 
%to just assume atomic visibility for those transitions $(\hh, \mathcal{V}) \leadsto_{CM} 
%(\hh', \mathcal{V}')$ where $\hh \neq \hh'$. Both solutions are patches to a flawed 
%definition, and we don't do patches. I think the best strategy here would be that 
%of distinguishing between local computations $(\lambda)$ and database interactions 
%$(\delta)$ in the semantics, and define a parallel rule that checks for transitions allowed 
%by the consistency model, only when a thread performs a $\delta$ action. I am first 
%typing up the semantics as it is now, and then I will make the appropriate changes. 
% Actually screw it, I'm going to change the semantics immediately.}
%
%Given two multi-sets of views $\mathcal{V}_1, \mathcal{V}_2$, 
%we write $\mathcal{V}_1 \Subset \mathcal{V}_2$, if there is 
%a one-to-one mapping from $\mathsf{push}: \mathcal{V}_1 \rightarrow \mathcal{V}_2$ 
%such that for any $V \in \mathcal{V}_1$, $V_1 \sqsubseteq \mathsf{push}(V_1)$.
%\ac{Again, notation should be re-adapted to multisets}.
%
%In general we require a consistency model specification to be reflexive, 
%and to be closed with respect to pushing the views in the 
%state of the system: if $(\hh, \{V_1, \cdots, V_n\}) \leadsto 
%(\hh, \{V'_1, \cdots, V'_{n})\}$, and 
%
%For a given consistency model $CM$, quadruple $(\hh, \mathcal{V}) 
%\leadsto_{CM} (\hh', \mathcal{V}')$,  and set of views $\mathcal{V}''$, 
%we write $(\hh, \mathcal{V}) \bowtie_{\mathcal{V}''} (\hh', \mathcal{V}')$ 
%if $(\hh, \mathcal{V} \cup \mathcal{V}'') \leadsto_{CM} (\hh', \mathcal{V}' \cup \mathcal{V}'')$.

In order to define the semantics of programs, we need to associate 
a thread stack and view to each parallel component (or thread) of the program. 
To this purpose, we define an environment $\mathsf{Env}$ to be 
a partial mapping $\mathsf{Env} : \tidset \rightharpoonup (\thdstackset \times \mathsf{Views})$ 
\ac{Set of Views and thread identifiers never introduced before.} 
Given two environments, $\mathsf{Env}_1, \mathsf{Env}_2$, we let 
$\mathsf{Env_1} \uplus \mathsf{Env}_2$ to be defined if 
$\dom(\mathsf{Env}_1) \cap \dom(\mathsf{Env}_2) = \emptyset$, 
in which case we have 
\[
(\mathsf{Env}_1 \uplus \mathsf{Env}_2)(\tid) = \begin{cases}
\mathsf{Env}_1(\tid) & \impliedby \tid \in \dom(\mathsf{Env}_1)\\
\mathsf{Env}_2(\tid) & \impliedby \tid \in \dom(\mathsf{Env}_2)\\
\text{undefined} & \impliedby \text{otherwise}
\end{cases}
\]

%For a program $\prog$ we define its set of views inductively as follows: 
%\[
%\begin{array}{lcl}
%\mathsf{Views}(\nil) &=& \emptyset \\
%\mathsf{Views}(V: \cmd \Par \prog) &=& V \cup \mathsf{Views}(\prog)
%\end{array}
%\]

Judgements in the operational semantics take the form 
\[
\infer{\langle \hh, \mathsf{Env}, \prog \rangle \xrightarrow{\alpha}_{CM} \langle \hh', \mathsf{Env}', \prog' \rangle}{}
\]

We first define how to lift the semantics of commands to programs. This results 
in the following rule: 
\[
\infer[{\scriptstyle(P-thd-exec)}]{\langle \hh, \mathsf{Env}, \tid: \cmd \rangle \xrightarrow{\alpha}_{CM} \langle \hh', \mathsf{Env}', \tid: \cmd' \rangle}
{
\begin{array}{c}
\mathsf{Env} = [\tid \mapsto (\sigma, V)] \qquad \langle \hh, \thdstack, V, \cmd \rangle \xrightarrow{\alpha} \langle \hh', \thdstack', V', \cmd' \rangle 
\qquad \mathsf{Env}' = [\tid \mapsto (\sigma', V')]\\
\alpha = \delta \implies (\hh, \{V\}) \leadsto_{CM} (\hh', \{V'\})
\end{array}
}
\]
Note the side condition $\alpha = \delta \implies (\hh, \{V\} \leadsto_{CM} (\hh', \{V'\})$ in the rule above. 
This is were consistency models come into play. This side condition states that if performing a computation 
in a command resulted in an interaction with the database $(\alpha = \delta)$, then such a computation 
should be performed only if it is consistent with the consistency model specification ($(\hh, \{V\}) \leadsto_{CM} 
(\hh', \{V'\})$).


Finally, we need to define how to compose programs together. 
Here the main idea is that computations that are valid for a 
program $\prog_1$ are not necessarily valid anymore in 
a composite program of the form $\prog_1 \Par \prog_2$. 
This is because the views of the threads that constitute $\prog_2$ 
may be conflicting with the thread performing a computation step in 
$\prog_1$. We will give some examples of consistency models 
that exhibit this behaviour in the next section. 

Formally, given a transition of the form $(\hh, \mathcal{V}_1) 
\leadsto (\hh, \mathcal{V}_1')$, and a set of views $\mathcal{V}_2$, 
we write
$\mathcal{V}_2 \Vdash (\hh, \mathcal{V}_1) \leadsto_{CM} 
(\hh', \mathcal{V}_1')$ if whenever $(\hh, \mathcal{V}_1) 
\leadsto_{CM} (\hh', \mathcal{V}_1)'$, then  
$(\hh, \mathcal{V}_1 \uplus \mathcal{V}_2) \leadsto_{CM} (\hh', \mathcal{V}_1' \uplus \mathcal{V}_2')$. 
\ac{I am pretty sure that for how the semantics is defined the premise of the implication 
is always going to be valid, so we may choose to ditch it.}
The rule for the parallel composition of programs is defined below: 
\[
\infer[{\scriptstyle (P-par-L)}]
{\langle \hh, \mathsf{Env}_1 \uplus \mathsf{Env}_2, \prog_1 \Par \prog_2 \rangle 
\xrightarrow{\alpha}_{CM} \langle \hh', \mathsf{Env}_1' \uplus \mathsf{Env}_2, 
\prog_1' \Par \prog_2 \rangle }
{ \begin{array}{c}
\langle \hh, \mathsf{Env}_1, \prog_1 \xrightarrow{\alpha}_{CM} \langle \hh', \mathsf{Env}_1', \prog_1' 
\qquad (\mathsf{Env_1} \uplus \mathsf{Env}_2)\downarrow \\ 
\alpha = \delta \implies \mathsf{Views}(\mathsf{Env}_2) \Vdash (\hh, \mathsf{Views}(\mathsf{Env}_1) 
\leadsto_{CM} (\hh', \mathsf{Views}(\mathsf{Env}_1')
\end{array}
}
\]



%For programs, the main rule of the operational semantics is as follows: 
%\[
%\infer[{\scriptstyle{(C-Par)}}]
%{\langle \hh, \prog_1 \Par \prog_2 \rangle \xrightarrow{CM} \langle \hh', \prog_1' \Par \prog_2 \rangle }
%{\langle \hh, \prog_1 \rangle \xrightarrow{CM} \langle \hh', \prog_1' \rangle \qquad 
%(\hh, \mathsf{Views}(\prog_1)) \bowtie_{\mathsf{Views}(\prog_2)} (\hh', \mathsf{views}(\prog_1'))} 
%\]
%To do so, we introduce \emph{history heaps}.
%
%We assume countably infinite set of transaction identifiers $\TransID$, whose elements 
%are ranged over $\tsid$. Subsets of $\TransID$ are ranged over by $\T$. 
%A \emph{Version} is a triple 
%$(v, \tsid, \{\tsid_1, \tsid_2,\cdots\}) \in \Val \times \TransID \times 2^{\TransID}$. 
%The set of all versions is denoted by $\Versions$, and its elements are ranged over $\nu, \nu', \cdots$. 
%Intuitively, associating a location $[n]$ with the version $\nu = (v, \tsid, \{\tsid_1,\tsid_,\cdots\})$ means that the 
%value $v$ has been written for location $[n]$. The transaction that wrote version $\nu$ is $\tsid$, 
%and the version has been read by transactions $\{\tsid_1,\tsid_2,\cdots\}$. 
%Given a version $\nu := (v, \tsid, \T)$, we define $\valueof(\nu) = v$, $\WTx(\nu) := \tsid$, 
%and $\RTx(\nu) := \T$.
%A history heap is a function $\hh: \Addr \rightarrow \Versions^{\ast}$ that 
%maps each location to its list of versions. As usual, if 
%$\hh([n]) = \nu_1,\cdots, \nu_m$ for some location $[n]$, then for any 
%$i= 1,\cdots, m$ we let $\hh([n])(i) = \nu_i$. 
%
%Given a history heap $\hh$, we can extract several heaps 
%from it, by simply choosing for each location $[n]$ a version 
%contained in the list of versions available for $[n]$ in $\hh$, 
%namely $\hh([n])$. Formally, we define a \emph{snapshot} 
%to be a function $\snapshot: \Addr \rightarrow \mathbb{N}$; 
%given a history heap $\hh$ and a snapshot $\snapshot$, 
%we can construct the heap 
%\[
%\heap(\hh, \snapshot) = \lambda [n] \in \Addr. 
%\begin{cases}
%v_{\snapshot([n])} &\impliedby \hh([n]) = \langle v_0, \_ , \_ \rangle \cdots \langle v_{m}, \_, \_ \rangle \wedge m \geq \snapshot([n])\\
%\text{undefined} & \text{otherwise}
%\end{cases}
%\]
%
%We use history heaps to model the global, shared state of all threads in multi-threaded programs. 
%However, each thread will have a local view of the history heap, which is induced by the 
%snapshot of the history heap that it observes. 
%Formally, judgements in the operational semantics of programs take the form 
%\[
%\langle \hh, (\snapshot_1, \cdots, \snapshot_n), (\thdstack_1,\cdots,\thdstack_n) \cmd_1 \Par \cdots \Par \cmd_n), \rangle
%\rightarrow \langle \hh', (\snapshot'_1, \cdots, \snapshot'_{n}), (\thdstack_1' , \cdots, \thdstack_n'), (\cmd'_1 \Par \cdots \Par \cmd'_n) \rangle
%\]
%\ac{Note that here we are exploiting the fact that programs have a rigid structure, with 
%no creation of dynamic threads. Honestly, I never understood what all the fuzz about 
%having dynamic thread creation was, since it seems that whether we have static or dynamic 
%thread creation, is irrelevant to the discussions we had thus far.}
%
%The rules for the operational semantics of programs will be parametric in the specification 
%of a consistency model. The specification of a consistency model describes which change 
%of states are allowed by programs. I.e. the specification of a consistency model is a 
%set of quadruples $(\hh, \snapshot, \hh', \snapshot')$. Given a consistency model 
%specification $\mathsf{CM}$, we write $(\hh, \snapshot) \leadsto_{\mathsf{CM}} 
%(\hh', \snapshot')$ in lieu of $(\hh, \snapshot, \hh', \snapshot') \in \mathsf{CM}$.
%
%Making a command progress in a program may result in the former producing a set of operations, 
%or fingerprint, which contributes to the evolution of the history heap. 
%\[
%\begin{array}{lll}
%\mathsf{append}_{T}(\hh, \snapshot, \{\RD\;[n]: m\}) &=& 
%\lambda [k].\begin{cases}
%\langle v_0, T_{0}, \T_{0} \rangle \cdots \langle v_i, T_{i}, \T_{i} \cup \{T\} \rangle \cdots \langle v_{n_{k}}, T_{n_{k}}, \T_{n_{k}} \rangle\\
%\hspace{5pt} \text{if } [k] = [n] \wedge \snapshot([k]) = i &\\
%\hh([k]) \hspace{5pt} \text{otherwise}
%\end{cases}\\
%\mathsf{append}_{T}(\hh, \_, \{\WR\; [n]: m\}) &=& 
%\hh[ [n] \mapsto ( \hh([n]) \cdot \langle m, T, \emptyset \rangle) ]\\
%\mathsf{append}_{T}(\hh, \snapshot, \mathcal{O}_1 \cup \mathcal{O}_2) &=& 
%\mathsf{append}_{T}(\mathsf{append}_{T}(\hh, \snapshot, \mathcal{O}_1), \snapshot, \mathcal{O}_2)
%\end{array}
%\]
%Furthermore, if executing a command under snapshot $\snapshot$ results in producing the fingerprint $\mathcal{O}$, 
%then we must also update the snapshot of the thread executing the command by including the versions 
%written by $\mathcal{O}$; formally, we define the function 
%\[
%\begin{array}{lll}
%\mathsf{update}(\hh, \snapshot, \mathsf{RD}\;[n]: m) &=& \snapshot\\
%\mathsf{update}(\hh, \snapshot, \mathsf{WR}\;[n]: m) &=& \snapshot[ [n] \mapsto \lvert \hh([n]) \rvert -1 ]\\
%\mathsf{update}(\hh, \snapshot, \mathcal{O}_1 \cup \mathcal{O}_2) &=& \mathsf{update}(\hh, \mathsf{update}(\hh, \snapshot, \mathcal{O}_1), \mathcal{O}_2)
%\end{array}
%\]
%
%The operational semantics of programs includes two rules: one for advancing the snapshot in 
%a session, as long as the snapshot policy is satisfied, and another for progressing commands 
%that constitute the program. Below we use $\mathcal{S}$ to denote a tuple of snapshots, 
%and $\mathcal{S}(i)$ to denote the $i$-th component of such a tuple. Similarly, $\Sigma$ 
%denotes a tuple of thread stacks. In the rules below, we assume that the arity of such tuples matches 
%the one of program components.
%
%\[
%\infer[P-Exec]{
%\langle \hh, \mathcal{S}, \Sigma, \cmd_1 \Par \cdots \Par \cmd_i \Par \cdots \Par \cmd_{n} \rangle
%\xrightarrow{\mathsf{CM}} \langle \hh', 
%\mathcal{S}[i \mapsto \snapshot'], \Sigma[i \mapsto \thdstack'], \cmd_1 \Par \cdots \Par \cmd_i' \Par \cdots \Par \cmd'_n \rangle
%}
%{
%\begin{array}{l}
%h = \heap(\hh, \mathcal{S}(i)) \qquad
%h \vdash \langle \Sigma(i), \cmd_i \rangle  \rightarrow \langle \thdstack', \mathcal{O}, \cmd_i' \rangle \qquad 
%(\hh, \mathcal{S}) \leadsto_{\mathsf{CM}} (\hh', \mathcal{S}[i \mapsto \snapshot']) \\
%\hh' = \mathsf{append}_{T}(\hh, \mathcal{S}(i), \mathcal{O}) \qquad T \text{ does not appear in } \hh 
%\qquad \snapshot' = \mathsf{update}(\mathcal{S}(i), \mathcal{O})\\
%\end{array}
%}
%\]
%
%\[
%\infer[S-update]{
%\langle \hh, \mathcal{S}, \Sigma, \prog \rangle \xrightarrow{\mathsf{CM}} \langle \hh, \mathcal{S}[i \mapsto \snapshot], \Sigma, \prog \rangle
%}
%{
%\mathcal{S}(i) \sqsubseteq \snapshot
%}
%\]
%
%\section{Examples of Specifications of Consistency Models}
%
%
%\section{Comparing Different Specifications of Consistency Models}
%To compare different specifications of consistency models, we adopt 
%a black-box testing approach, similar in style to the one proposed by Hennessy 
%and de Nicola \cite{hdn84} for concurrent processes. 
%
%We assume that primitive commands contain a special element $\thick$, with empty state transformer. 
%We say that a program is successful, denoted $\mathsf{successful}(P)$, if it contains an unguarded occurrence of the $\thick$ command. 
%Formally, we define $\mathsf{successful}(P)$ inductively on the syntax of programs as follows: 
%\[
%\begin{array}{lll}
%\mathsf{successful}(\nil) &=& \ffalse\\
%\mathsf{successful}(\thick) &=& \ttrue\\
%\mathsf{successful}(c) &=& \ffalse \hspace{5pt} \text{ if } c \neq \thick\\
%\mathsf{successful}([\trans]) &=& \ffalse\\
%\mathsf{successful}(X) &=& \ffalse\\
%\mathsf{successful}(\cmd_1 + \cmd_2) &=& \mathsf{successful}(\cmd_1) \vee \mathsf{successful}(\cmd_2)\\
%\mathsf{successful}(\mu X.\cmd) &=& \ffalse\\
%\mathsf{successful}(\cmd \Par \prog) &=& \mathsf{successful}(\cmd) \vee \mathsf{successful}(\prog)
%\end{array}
%\]
%
%We say that a program $\prog$ may-pass under the consistency model specification $\CM$, 
%written $\prog \maypass\; \CM$, if there exists a computation fragment 
%\[ 
%\langle \hh_{0}, \mathcal{S}_0, \Sigma_0, \prog_0 \rangle \xrightarrow{\CM} \cdots \xrightarrow{\CM} \langle \hh_{n}, \mathcal{S}_n, \Sigma_n, \prog_n \rangle,
%\]
%such that $\hh_{0} = \lambda [m]. \langle 0, T_0, \emptyset \rangle$, $\mathcal{S}_0 = \lambda [m].0$, $\Sigma_0 = \langle \thdstack_0, \cdots, \thdstack_0$ 
%and $\thdstack_0 = \lambda x. 0$, $\prog_0 = \prog$, and $\mathsf{successful}(\prog_{n})$. 
%
%\begin{definition}
%Given two consistency model specifications $\CM_1, \CM_2$, we say that 
%$\CM_1$ is \emph{(weakly) stronger than} $\CM_2$, written $\CM_1 \sqsubseteq \CM_2$, if for all program $\prog$, 
%\[
%\CM_1 \maypass\; \prog \implies \CM_2 \maypass\;\prog
%\]
%\end{definition}
%\bibliographystyle{abbrv}
%\ac{This notion of equivalence is based on the observations made by clients, in contrast to other 
%notion of history equivalences found in the literature - conflict equivalence, history equivalence, view equivaence, $\cdots$, 
%which are way too fine-grained for our purposes.}
%\bibliography{bibliography2}

\end{document}

