%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[acmsmall]{acmart}\settopmatter{}


%% Journal information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{CONF} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2018}
\acmMonth{1}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format must update the '\documentclass' and
%% topmatter commands above; see 'acmart-sigplanproc-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\PassOptionsToPackage{svgnames}{xcolor}
%\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}

\definecolor{DarkGreen}{rgb}{0, 0.5, 0}


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

%\documentclass[a4paper,UKenglish]{article}%This is a template for producing LIPIcs articles. 

%\input{env.tex}
\usepackage{hhmacros}
\usepackage{wasysym}
\usepackage{mathrsfs}  
%\usepackage{hheapdraw}




 
%\usepackage{microtype}%if unwanted, comment out or use option "draft"
%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

%\bibliographystyle{plainurl}% the recommended bibstyle

%\usepackage[a4paper]{geometry}
%\usepackage[letterpaper,left=2.4cm,right=2.4cm,top=2.4cm,bottom=2.4cm]{geometry}

\usepackage{opsem}

\usepackage{etex}

%\usepackage{stackengine}

\usepackage{authblk}



%%%%%%%%%%%%%%%%%%%%%% edit mode
\newif\iflong
\longfalse  % uncomment for short version
%\longtrue  % uncomment for long version

\newif\ifdraft
%\draftfalse %uncomment for deleting notes
\drafttrue %uncomment for showing notes

%\newif\ifEditing
%\Editingtrue
%\ifEditing
%    \linenumbers
%\fi

\newif\ifComments
\Commentstrue
\input{comment-box.tex}
%%%%%%%%%%%%%%%%%%%%%% end edit mode

%\newcommand{\tr}[2]{\iflong{}\S#1\else{}\cite[\S{}#2]{ext}\fi}
%\newcommand{\tra}[2]{\iflong{}(\S#1)\else{}\cite[\S{}#2]{ext}\fi}
%
%\newcommand{\nanomalies}{A}
%\newcommand{\ngeneral}{B}
%\newcommand{\nproofs}{C}
%\newcommand{\ncompleteness}{D}
%
%%\renewcommand{\ttdefault}{cmtt}
%%\renewcommand{\sfdefault}{cmss}
%
%\newcommand{\cross}{\ding{56}}


%\renewcommand{\rmdefault}{ptm}      %Space Hacks

\renewcommand{\O}{\mathcal{O}}

%\newcommand{\theproof}{{\noindent\hskip\labelsep
%        \color{darkgray}\sffamily\bfseries \proofname.}}
        
\newcommand{\myparagraph}[1]{\textbf{\color{darkgray}\sffamily#1.}}
\newcommand{\newtext}[1]{{\color{red}{\bf #1}}}
\newcommand{\dfont}[1]{{\bf\em #1}}
% comments


\usepackage{pifont}
\usepackage[frame,all]{xy}
\usepackage{nicefrac}
\usepackage{executions}
\usepackage{execgraphs}

%\usepackage{graphicx}
%\usepackage{wrapfig}
\usepackage{proof}

\DeclareMathAlphabet{\mathpzc}{OT1}{pzc}{m}{it}

%\usepackage{mathtools}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Packages above %%%%%%%%%%%%%%%%%%%%%%%


%\theoremstyle{plain}

%\newcommand{\qed}{$\Box$}
%\newenvironment{proof}{\begin{trivlist}
%\item[\hskip\labelsep{\sc Proof.}]}
%{$\hfill\Box$\end{trivlist}}
%\newenvironment{sketch}{\begin{trivlist}
%\item[\hskip\labelsep{\sc Proof sketch.}]}
%{$\hfill\Box$\end{trivlist}}
%\newenvironment{scheme}{\begin{trivlist}
%\item[\hskip\labelsep{\sc Proof scheme.}]}
%{$\hfill\Box$\end{trivlist}}


%\newcommand{\account}{\ensuremath{\mathsf{acct}}}
%\newcommand{\emptytxt}{{\ensuremath{\mathsf{empty}}}}
%\newcommand{\post}{\ensuremath{\mathsf{post}}}
%\newcommand{\comment}{\ensuremath{\mathsf{comment}}}

%\def\qed{\ifmmode\squareforqed\else{\unskip\nobreak\hfil
%\penalty50\hskip1em\null\nobreak\hfil\squareforqed
%\parfillskip=0pt\finalhyphendemerits=0\endgraf}\fi}


\newcommand{\leaveout}[1]{}

\newcommand\Tstrut{\rule{0pt}{3.5ex}}         % = `top' strut
\newcommand\Bstrut{\\[3pt]}   % = `bottom' strut

%usepackage{paralist}
%\setdefaultleftmargin{10pt}{}{}{}{}{}
%\setlength{\topsep}{3pt}
%\setlength{\itemsep}{2pt}
% \setlength{\partopsep}{0pt}
% \setlength{\parsep}{0pt}
%\setlength{\parskip}{0pt}

%\newenvironment{subitemize}{
%\begin{itemize}
% \setlength{\topsep}{0pt}
%  \setlength{\itemsep}{0pt}
%  \setlength{\parskip}{0pt}
%}{\end{itemize}}
%
%\multlinegap=3pt
%\setlength{\jot}{2pt}
%\newcommand{\ms}{\\[2pt]}

%
%\setlength{\floatsep}{10pt plus 6pt minus 2pt}
%\setlength{\textfloatsep}{10pt plus 6pt minus 3pt}
%\setlength{\intextsep}{10pt plus 6pt minus 3pt}
%\setlength{\dblfloatsep}{18pt plus 4pt minus 2pt}
%\setlength{\dbltextfloatsep}{20pt plus 4pt minus 3pt}

%\newenvironment{mywrapfigure}[3][]{
%  \floatstyle{boxed}
%  \restylefloat{figure}
%  \wrapfigure[#1]{#2}{#3}}
%  {\endwrapfigure
%    \floatstyle{ruled}
%    \restylefloat{figure}
%    }
    

% \setlength{\floatsep}{18pt plus 4pt minus 2pt}
% \setlength{\textfloatsep}{18pt plus 4pt minus 3pt}
% \setlength{\intextsep}{10pt plus 4pt minus 3pt}
% \setlength{\dblfloatsep}{18pt plus 4pt minus 2pt}
% \setlength{\dbltextfloatsep}{20pt plus 4pt minus 3pt}
%
%\makeatletter
%\renewcommand{\section}{\@startsection{section}{1}{0pt}%
%{-3ex plus -1ex minus -.2ex}{1.5ex plus.2ex}%
%{\normalfont\large\bfseries}}
%\renewcommand{\subsection}{\@startsection{subsection}{1}{0pt}%
%{-2ex plus -1ex minus -.2ex}{1ex plus.2ex}%
%{\bfseries}}
%\def \@begintheorem #1#2{%                      {name}{number}
%  \trivlist
%  \item[\hskip \labelsep \textbf{#1 #2.}]%
%  \itshape\selectfont
%  \ignorespaces}
%\newcommand{\nut}{\hspace{.35em}}
%\def \@opargbegintheorem #1#2#3{%               {name}{number}{title}
%  \trivlist
%  \item[%
%    \hskip\labelsep \textsc{#1\ #2}\nut (#3).]%
%  \itshape\selectfont
%  \ignorespaces}
%
%\def\@listI{\leftmargin\leftmargini
%            \parsep 0\p@ \@plus1\p@ \@minus\p@
%            \topsep 6\p@ \@plus2\p@ \@minus0\p@
%            \itemsep 0\p@}
%\let\@listi\@listI
%\@listi
%
%\makeatother
%
%\sloppy

% Author macros:begin %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\iflong
%\title{Specification, Verification and Program Correctness of Transactional Consistency Models using History Heaps}
%%\titlerunning{History Heaps} %optional, in case that the title is too long; the running title should fit into the top page column
%\else
%\title{Specification, Verification and Program Correctness of Transactional Consistency Models using History Heaps}
%\fi
%
%%% Please provide for each author the \author and \affil macro, even when authors have the same affiliation, i.e. for each author there needs to be the  \author and \affil macros
%\iflong
%
%\author[1]{Shale Xiong, Andrea Cerone, Philippa Gardner}
%\author[2]{Azalea Raad}
%\affil[1]{Imperial College London, UK}
%\affil[2]{MPI KaiserSlautern}
%%\authorrunning{A. Cerone} %mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et. al.'
%\else
%
%\author[1]{Shale Xiong}
%\author[1]{Andrea Cerone}
%\author[2]{Azalea Raad}
%\author[1]{Philippa Gardner}
%\affil[1]{Imperial College London, UK}
%\affil[2]{MPI Kaiserslautern}
%\fi

\begin{document}

%% Title information
\title{Weak Consistency in Transactional Systems: a Multi-version Based Operational Approach}         %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
%\titlenote{with title note}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
%\subtitle{Subtitle}                     %% \subtitle is optional
%\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{Shale Xiong}
%\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \position{Ph.D. Student}
  \department{Department of Computing}              %% \department is recommended
  \institution{Imperial College London}            %% \institution is required
  \streetaddress{Huxley Building}
  \city{London}
  \state{}
  \postcode{SW7 2AZ}
  \country{United Kingdom}                    %% \country is recommended
}
\email{shale.xiong14@imperial.ac.uk}          %% \email is recommended

%% Author with single affiliation.
\author{Andrea Cerone}
%\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \position{Research Associate}
  \department{Department of Computing}              %% \department is recommended
  \institution{Imperial College London}            %% \institution is required
  \streetaddress{Huxley Building}
  \city{London}
  \state{}
  \postcode{SW7 2AZ}
  \country{United Kingdom}                    %% \country is recommended
}
\email{a.cerone@imperial.ac.uk}          %% \email is recommended

%% Author with single affiliation.
\author{Philippa Gardner}
%\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \position{Professor}
  \department{Department of Computing}              %% \department is recommended
  \institution{Imperial College London}            %% \institution is required
  \streetaddress{Huxley Building}
  \city{London}
  \state{-}
  \postcode{SW7 2AZ}
  \country{United Kingdom}                    %% \country is recommended
}
\email{p.gardner@imperial.ac.uk}          %% \email is recommended

\author{Azalea Raad}
%\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \position{Post-doctoral Researcher}
  \department{}              %% \department is recommended
  \institution{Max Planck Institute}            %% \institution is required
  \streetaddress{no idea}
  \city{Kaiserslautern}
  \state{-}
  \postcode{-}
  \country{Germany}                    %% \country is recommended
}
\email{a.raad@mpi-sws.org}          %% \email is recommended

%%%% Author with two affiliations and emails.
%\author{First2 Last2}
%\authornote{with author2 note}          %% \authornote is optional;
%                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
%\affiliation{
%  \position{Position2a}
%  \department{Department2a}             %% \department is recommended
%  \institution{Institution2a}           %% \institution is required
%  \streetaddress{Street2a Address2a}
%  \city{City2a}
%  \state{State2a}
%  \postcode{Post-Code2a}
%  \country{Country2a}                   %% \country is recommended
%}
%\email{first2.last2@inst2a.com}         %% \email is recommended
%\affiliation{
%  \position{Position2b}
%  \department{Department2b}             %% \department is recommended
%  \institution{Institution2b}           %% \institution is required
%  \streetaddress{Street3b Address2b}
%  \city{City2b}
%  \state{State2b}
%  \postcode{Post-Code2b}
%  \country{Country2b}                   %% \country is recommended
%}
%\email{first2.last2@inst2b.org}         %% \email is recommended


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
Contents of this set of notes: 
History heaps. Semantics of Programs 
running under weak consistency models using history heaps as states. 
Simulation technique for comparing weak consistency models defined using 
history heaps. Verification of implementations.
\textbf{Points following Dagstuhl: Viktor seemed positive about the 
history heap work. His question was whether the framework is generic 
enough to capture the protocols that they are developing with Azalea. 
Alexey's opinion is that the framework may have some use if we 
manage to prove implementations of protocols correct. 
I would also like to have Azalea's opinion on a semantics based 
on history heaps.}
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{keyword1, keyword2, keyword3}  %% \keywords are mandatory in final camera-ready submission


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle

\section{Introduction}
\ac{Obviously this will be rewritten again and again, but it should give 
an idea of how the paper is going to be structured.}
Modern distributed systems s often rely on databases that achieve scalability by weakening
consistency guarantees of distributed transaction processing. These databases are said
to implement weak consistency models. Such weakly consistent databases allow for faster
transaction processing, but exhibit anomalous behaviours, which do not arise under a database
with a strong consistency guarantee, such as \emph{serialisability}. 

Recently, the research community has made an effort to give formal specifications of weak consistency 
models for transactional distributed databases \cite{ev_transactions,framework-concur,consistency3d,seebelieve,laws,alonetogether}. 
However, the problem of giving the semantics describing the operational behaviour of 
clients interacting with a weakly consistent databases, has been largely neglected. The only 
work that we are aware of in this field is given by \cite{alonetogether}. There the authors 
study the behaviour of functional programs interacting with a relational database, and develop 
a program logics for proving invariants of programs executed by clients of the database. 
\ac{Insert sentence to swiftly kill their paper without being an asshole here.}

In this paper we focus on the semantics of clients of distributed key-value 
stores which provide weak consistency guarantees. 
We propose a \emph{coarse-grained} approach to evaluating transactions, 
where transactions are executed by clients in a single, atomic step; furthermore, 
transactions of concurrent clients are executed in an interleaving fashion.
This is In contrast with the work of \cite{alonetogether}, which 
takes a fine-grained approach in which transactions are evaluated one step 
at the time on a local copy of the database, and thus it is possible 
to interleave the execution of transaction; we find this complication to be 
unnecessary, at least in a setting where transactions enjoy \emph{atomic 
visibility}: either none or all the updates of a transaction are made 
visible to another transaction. 

We take a multi-version approach to model the state of a key-value store. 
Each key is mapped to a set of versions. A Version consists of a 
value and the meta-data of the transactions that wrote and read the version. 
At any given instant of time, concurrent clients can observe different versions for the same key.
This approach is necessary to capture the non-serialisable behaviour of 
programs, while still retaining interleaving concurrency and atomic reduction 
of transactions. 

Because we want to model different consistency models, in our semantics 
transactions are executed only prior to passing a particular execution test. For example, 
to constrain a program to only exhibit serialisable behaviours, we require that 
transactions can be executed by a client only if it observes the most 
recent available version for each key. By tweaking the execution test 
of transactions, we tweak the consistency model under which programs 
are executed. In \ref{sec:cmexamples} we give examples of execution tests 
that can be used to model all the consistency models formalised in \cite{framework-concur}.
The notion of execution test is inspired by \cite{seebelieve}. There a notion of \emph{commit test} is introduced 
to determine whether a transaction can be executed safely. However, 
the notion of commit test requires the complete knowledge of 
how the system of the key-value store evolved from its 
initial state (i.e. it requires knowing the total order in which transactions executed in 
the computation); execution tests, on the other hand, only requires 
knowing the list of versions stored by each key, and the 
information about which version of each key is observed 
by the client executing the transaction.
\ac{Paragraph about the thoroughness of the semantics and 
correspondence of our specifications and the declarative 
ones from the CONCUR'15 paper. Paragraph about the logic. 
Here we should stress that clients that execute correctly 
under serialisability, are not necessarily correct under a 
weaker consistency model. There should  be a sentence explaining 
that thoroughness of the semantics is necessary to obtain soundness 
of the logic.}

Contributions of the paper: 
\begin{enumerate}
\item An operational semantics of programs interacting with a key-value store, 
\item Definition of different execution tests for capturing several consistency models, 
and a proof that the consistency models captured by the execution tests we propose 
are equivalent to the ones obtained through the respective declarative specification 
given in\cite{framework-concur},
\item A proof that the operational semantics is \emph{thorough}: For each of the 
consistency model we propose, and for any program $\prog$, our semantics captures 
all the behaviours that $\prog$ can display under said consistency model, 
\item A separation logic based on our semantics to reason about properties 
of clients interacting with a weakly consistent key-value store.
\end{enumerate}

\ac{Got bored of writing the introduction, in any case it will need to be 
changed a lot in the future.}
%Let us illustrate how our semantics works informally.
%Consider the program $\prog_1$ defined below:
%\[
%\begin{session}
%\begin{array}{@{}c || c@{}}
%\cl_1 : 
%\begin{transaction}
%\pderef{\pvar{a}}{\key{y}};\\
%\pifs{\pvar{a} = 0};\\
%\;\;\; \pmutate{\key{x}}{1};\\
%\}
%\end{transaction}
%&
%\cl_2
%\begin{transaction}
%\pderef{\pvar{a}}{\key{x}};\\
%\pifs{\pvar{a} = 0};\\
%\;\;\; \pmutate{\key{y}}{1};\\
%\}
%\end{transaction}
%\end{array}
%\end{session}
%\]
%There are two concurrent clients, $\cl_1$ and $\cl_2$. Client $\cl_1$ 
%updates the value of key $\key{x}$ to value $1$, provided that 
%it observes value $0$ for key $\key{y}$. Symmetrically, client 
%$\cl_2$ updated the value of $\key{y}$ to $1$ when it observes 
%value $0$ for $\key{x}$. Initially, the (multi-version) key-value store contains only one version 
%with value $0$, for each key. Both the clients $\cl_1$ and $\cl_2$ 
%are equipped with a \emph{view}, which identifies for each key, 
%the version that it will observe for the version 

%Because we reduce transactions in an atomic step, and because we model 
%the behaviour of concurrent clients in an interleaving fashion, we cannot 
%hope to capture non-serialisable behaviours of programs if only the 
%information about the current state of the key-value store were used 
%to evaluate the effects of a transaction. 

\section{History Heaps and Views}

We focus on a computational model where multiple client programs can access and update 
locations in a key-value store using atomic transactions. Transactions in our model execute atomically, 
though the consistency guarantees that they provide do not necessarily correspond to \emph{serialisability}. 
This means that, at the moment of executing, a transaction may not observe the most up-to-date value 
of a location. 

To overcome this issue, we model the state of the system using \emph{multi-version key-value stores} 
(MKVSs) and \emph{views}. A 
MKVS keeps track of all the versions written for any key, as well as the information 
about the transactions that read and wrote such versions.  Views keep track of the version observed 
for each key by clients. 

\begin{figure}
\begin{center}
\begin{tabular}{|@{}c|c@{}|}
\hline
\begin{tikzpicture}[font=\large]

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) at (1,3) {$\key{k}_1 \mapsto$};

\matrix(locxcells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locx.east) {
 {a} & $T_0$ & {a} & $\tsid_1$\\
  {a} & $\{\tsid_2\}$ & {a} & $\emptyset$ \\
};
\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};

%Location y
\path (locx.south) + (0,-1.5) node (locy) {$\key{k}_2 \mapsto$};
\matrix(locycells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locy.east) {
 {a} & $T_0$ & {a} & $\tsid_2$ \\
  {a} & $\{\tsid_1\}$ & {a} & $\emptyset$\\
};
\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
\node[version node, fit=(locycells-1-3) (locycells-2-3), fill=white, inner sep=0cm, font=\Large] (locy-v1) {$1$};

% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
 ([xshift=-3pt, yshift=20pt]locx-v1.north east) node (tid1start) {} -- 
 ([xshift=-3pt, yshift=-5pt]locx-v1.south east) --
 ([xshift=-3pt, yshift=5pt]locy-v0.north east) -- 
 ([xshift=-3pt, yshift=-5pt]locy-v0.south east);
 
 \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_1$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
 ([xshift=-16pt, yshift=5pt]locx-v1.north east) node (tid2start) {}-- 
% ([xshift=-16pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-16pt, yshift=5pt]locy-v1.north east) -- 
 ([xshift=-16pt, yshift=-5pt]locy-v1.south east) node {};
 
\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\tid_2$};

%%Stack for threads tid_1 and tid_2
%
%\draw[-, dashed] let 
%   \p1 = ([xshift=0pt]locy.west),
%   \p2 = ([yshift=-5pt]locycells.south),
%   \p3 = ([xshift=10pt]locycells.east) in
%   (\x1, \y2) -- (\x3, \y2);
%   
%\matrix(stacks) [
%   matrix of nodes,
%   anchor=north, 
%   text=blue, 
%   font=\normalsize, 
%   row 1/.style = {text = blue}, 
%   row 2/.style = {text = red}, 
%   text width= 13mm ] 
%   at ([xshift=-10pt,yshift=-8pt]locycells.south) {
%   $\tid_1:$ & $\retvar = 0$\\
%   $\tid_2:$ & $\retvar = 0$\\
%   };
\end{pgfonlayer}
\end{tikzpicture}
&
\begin{tikzpicture}[font=\large]

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) at (1,3) {$\key{k}_1 \mapsto$};

\matrix(locxcells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locx.east) {
 {a} & $T_0$ & {a} & $\tsid_1$\\
  {a} & $\emptyset$ & {a} & $\{\tsid_2\}$ \\
};
\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};

%Location y
\path (locx.south) + (0,-1.5) node (locy) {$\key{k}_2 \mapsto$};
\matrix(locycells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locy.east) {
 {a} & $T_0$ & {a} & $\tsid_2$ \\
  {a} & $\emptyset$ & {a} & $\{\tsid_1\}$\\
};
\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
\node[version node, fit=(locycells-1-3) (locycells-2-3), fill=white, inner sep=0cm, font=\Large] (locy-v1) {$1$};

% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
%\draw[-, blue, very thick, rounded corners=10pt]
% ([xshift=-3pt, yshift=20pt]locx-v1.north east) node (tid1start) {} -- 
% ([xshift=-3pt, yshift=-5pt]locx-v1.south east) --
% ([xshift=-3pt, yshift=5pt]locy-v0.north east) -- 
% ([xshift=-3pt, yshift=-5pt]locy-v0.south east);
% 
% \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_1$};
%
%%red view
%\draw[-, red, very thick, rounded corners = 10pt]
% ([xshift=-16pt, yshift=5pt]locx-v1.north east) node (tid2start) {}-- 
%% ([xshift=-16pt, yshift=-5pt]locx-v0.south east) --
%% ([xshift=-16pt, yshift=5pt]locy-v1.north east) -- 
% ([xshift=-16pt, yshift=-5pt]locy-v1.south east) node {};
% 
%\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\tid_2$};

%%Stack for threads tid_1 and tid_2
%
%\draw[-, dashed] let 
%   \p1 = ([xshift=0pt]locy.west),
%   \p2 = ([yshift=-5pt]locycells.south),
%   \p3 = ([xshift=10pt]locycells.east) in
%   (\x1, \y2) -- (\x3, \y2);
%   
%\matrix(stacks) [
%   matrix of nodes,
%   anchor=north, 
%   text=blue, 
%   font=\normalsize, 
%   row 1/.style = {text = blue}, 
%   row 2/.style = {text = red}, 
%   text width= 13mm ] 
%   at ([xshift=-10pt,yshift=-8pt]locycells.south) {
%   $\tid_1:$ & $\retvar = 0$\\
%   $\tid_2:$ & $\retvar = 0$\\
%   };
\end{pgfonlayer}
\end{tikzpicture}\\
{\small(a)} & {\small(b)}\\
\hline
\end{tabular}
\end{center}
\caption{(a) - A well-formed configuration \hfill (b) - An ill-formed MKVS.}
\label{fig:hheap}
\end{figure}

Formally speaking, we assume a countably infinite set of keys $\Addr = \{\key{k}_1, \cdots\}$, a set of transaction identifiers $\TxID = 
\{ \tsid_1, \cdots \}$, 
a set of clients $\tidset = \{\tid_1, \cdots \}$.
We also assume values to be natural numbers from the set $\nat$. 
\ac{from now on, the sort font is used for sets.}
\begin{definition}
\label{def:hheap}
A \emph{version} is a triple $\nu = ( n, \tsid, \T)$, where, 
$n$ is the value of the version, $\tsid$ is the identifier of the transaction 
that wrote the version, and $\T$ is a (possibly empty) set of identifiers of 
the transactions that read the version. Given a version $\nu = (n, \tsid, \T)$, 
we let $\valueOf(\nu) = n$, $\WTx(\nu) = \tsid$, $\RTx(\nu) = \T$. 
The set of versions is denoted as $\Versions$.

A \emph{Multi-version Key-value Store}, or MKVS, is a mapping  
$\hh : \Addr \rightarrow \Versions^{\ast}$ from keys to lists of versions. 
\end{definition}
Given a list of versions $\nu_1 \cdots \nu_{n}$, 
we let $\lvert \nu_1 \cdots \nu_{n} \rvert = n$ be 
its length. Also, let $\hh$ be a MKVS, $\key{k}$ be a key 
such that $\hh(\key{k}) = \nu_1 \cdots \nu_n$, and 
$i \leq n$ be a strictly positive natural number; then we let 
$\hh(\key{k}, i) = \nu_i$. 

We often depict MKVSs graphically. 
One example is given by the MKVS $\hh_0$ of Figure \ref{fig:hheap}(a) (ignore for the moment 
the straight lines labelled $\tid_1$ and $\tid_2$).
\ac{Maybe it's better to keep $\Addr$ fixed and say that we look at only a 
fragment of the key value store. Alternatively, we can go for partial mappings to 
represent MKVSs, but still avoiding allocation and deallocation of keys.}. To the left 
we have the set of keys stored y $\hh_0$, in this case $\key{k}_1$ and 
$\key{k}_2$. To the right, on the same line of a key, a matrix containing the
 list of versions stored by such a key in $\hh_0$. Starting from the first column, 
 each version is represented by two adjacent columns in the matrix: the 
 column to the left gives the value of the version, while the column to the 
 right contains the identifier of the transaction that wrote the version to the 
 top, and the identifiers of the transactions that read such a version to the bottom.
In the case of $\hh_0$, there are two versions stored for $\key{k}_1$: 
the first one with value $0$, written by $\tsid_0$ and read by $\tsid_2$; 
and the second one with value $1$, written by $\tsid_2$ and read by no 
transaction. 

Throughout this paper, we focus on MKVSs that can be obtained in 
databases whose consistency guarantees enjoy atomic visibility 
\cite{framework-concur,SIanalysis,laws}. To this end, we impose 
some well-formedness constraints on the MKVSs.

\begin{definition}
\label{def:hh.wellformed}
A MKVS $\hh$ is \emph{well-formed} if and only if 
\begin{itemize}
\item a transaction does not write two different versions for the same key: 
$\forall \key{k} \in \Addr.\;\forall i, j = 1,\cdots, \lvert \hh(\key{k}) \rvert. 
\WTx(\hh(\key{k}, i)) = \WTx(\hh(\key{k}, j)) \implies i = j$, 
\item a transaction does not read two different versions for the same key:  
$\forall \key{k} \in \Addr.\;\forall i, j = 1,\cdots, \lvert \hh(\key{k}) \rvert. 
(\RTx(\hh(\key{k},i) \cap \RTx(\hh(\key{k}, j)) \neq \emptyset) \implies i = j$.
\item There are no circular dependencies in versions. Given two versions 
$\nu_1, \nu_2$, we say that $\nu_2$ \emph{direct dependency} from 
$\nu_1$, written $\nu_1 \xrightarrow{\ddep} \nu_2$, if $\WTx(nu_2) \in \RTx(\nu_1)$; 
that is, some transaction $\tsid$ wrote the version $\nu_2$ after reading $\nu_1$ 
\ac{A point that this does not ensure a real causal dependency between the 
two versions, yet it is consistent with the notion of causality employed in databases, 
should be made}. If $\nu_1, \nu_2$ appear as versions of some object in 
$\hh$, then we write $\nu_1 \xrightarrow{\ddep(\hh)} \nu_2$. Then the relation $\left(\xrightarrow{\ddep(\hh)}\right)^{+}$ is acyclic in $\hh$, 
i.e. $\left(\xrightarrow{\ddep(\hh)} \right)^{+} \cap \Id = \emptyset$ (where $\Id$ is 
the identity relation).
\end{itemize}
\end{definition}
Let us discuss for a moment the last constraint in Definition \ref{def:hh.wellformed}, 
which states that there is no circularity in dependencies stored by a MKVS. This is 
to ensure that no versions are created \emph{out of thin-air}. An example of the 
out of thin-air anomaly is given by the MKVS $\hh_1$ of Figure \ref{fig:hheap}(b): 
there we have a transaction $\tsid_2$ that read the value of $\key{k}_1$ written 
by $\tsid_1$; conversely, $\tsid_1$ read the value of $\key{k}_2$ written by $\tsid_2$. 
Because we assume that transactions read a state of the key-value store from 
an atomic snapshot fixed at the moment they execute, this situation cannot happen. 
For $\tsid_2$ to read the value installed by $\tsid_1$, then $\tsid_2$ 
must have been executed after $\tsid_1$. Simlarly, $\tsid_1$ must have been 
executed after $\tsid_2$.
Formally, we have that $\hh_1(\key{k}_2, 2) \xrightarrow{\ddep(\hh_1)} \hh(\key{k}_1, 2)$, 
and $\hh_1(\key{k}_1, 2) \xrightarrow{\ddep(hh_1)} \hh_1(\key{k}_2, 2)$, violating the 
constraint of well-formed MKVSs that states that $\xrightarrow{\ddep(\hh_1)}$ is acyclic. 
When introducing our semantics of clients in \S \ref{sec:semantics}, we show that 
(under reasonable conditions) it generates only well-formed MKVSs.

Because MKVSs store multiple versions for each key, different clients may 
observe different versions of the same key, at a single instant of time. 
To model this fact, we introduce the notion of \emph{views} and \emph{configurations}. 
\begin{definition}
\label{def:view}
A \emph{View} is a function $V: \Addr \rightarrow \nat$. 
The set of all views is denoted as $\viewSet$. 

A \emph{configuration} is a pair $\conf = (\hh, \viewFun)$, where 
$\viewFun: \tidset \rightharpoonup \viewSet$ is a partial mapping 
from clients to views. 
\end{definition}
A view $V$ defines the particular version of each key that a client 
will observe when executing a transaction. A configuration consists 
of a MKVS, and the views that a set of clients have each on the state 
of the MKVS. An example of configuration is given in Figure \ref{fig:hheap}(a). 
There are two clients, $\tid_1$ and $\tid_2$, each with their own view 
(represented in the Figure by labelled lines crossing the MKVS at each location). 
According to the view of $\tid_1$, formally defined as $V_1 = [\key{k}_1 \mapsto 2], 
\key{k}_2 \mapsto 1]$, this client observes in $\hh$ the second version of key $\key{k}_1$, carrying 
value $1$, and 
the first version of $\key{k}_2$, carrying value $0$. Similarly, according to its view 
$V_2 = [\key{k}_1 \mapsto 2, \key{k}_2 \mapsto 2]$, the client $\tid_2$ observes 
in $\hh$the second and most up-to-date version for both $\key{k}_1$ and $\key{k}_2$.

A view $V$ is well-formed with respect to a MKVS $\hh$ iff, 
for any $\key{k} \in \Addr.\; 0 < V(\key{k}) \leq \lvert \hh(\key{k}) \rvert$. 
A configuration $\conf = (\hh, \viewFun)$ is well-formed if, for any 
$\tid \in \dom(\viewFun)$, the view $\viewFun(\tid)$ is well-formed with respect 
to $\hh$. Henceforth, we always assume that MKVSs, views and configurations are well-formed, 
unless otherwise stated.
%We say that a view $V$ is well-defined with respect to the 
%MKVS $\hh$ if, $\forall \key{k} \in \Addr. 0 < V(\key{k}) \leq 
%\lvert \hh(\key{k}) \rvert$. 
%Given a view $V$ that is well-defined 
%with respect to a 
and a MKVS $\hh$, we let $\version(\hh, \key{k}, V) = 
\hh(\key{k}, V(\key{k}))$; we commit an abuse of notation and 
often write $\valueOf(\hh, \key{k}, V)$ in lieu of $
\valueOf(\version(\hh, \key{k}, V))$, and similarly for $\WTx, \RTx$.
if $\nu = \version(\hh, \key{k}, V)$,  
we say that $V$ $\key{k}$-points to $\nu$ in $\hh$. If $\nu = \hh(\key{k}, i)$ 
for some $i \leq V(\key{k})$, we say that $V$ $\key{k}$-includes $\nu$ in $\hh$.

%\begin{definition}
%\label{def:configuration}
%A \emph{configuration} is a pair $\conf = (\hh, \viewFun)$, where 
%$\viewFun: \tidset \rightharpoonup \viewSet$ is a partial mapping 
%from clients to views such that whenever $\tid \in \dom(\viewFun), 
%\viewFun(\tidset)$ is well-defined with respect to $\hh$. 
%\end{definition}

%
%History heaps and views are defined formally in Section \ref{sec:historyheaps}. 

When a client executes a transaction, it extracts a concrete state of the key-value store by using its view 
to select a version for each key in the database. The concrete state extracted in this way takes the name of the 
\emph{snapshot} of the transaction. In general, the process of determining the view of a client, 
hence the snapshot in which such a client executes transactions, is non-deterministic.
%In general ,the process of determining 
%a snapshot for a transaction is non-deterministic.
%Formally speaking, we assume a countably infinite set of keys $\Addr = \{\key{k}_1, \cdots\}$. 
%\ac{from now on, the mathrm is used for addresses/keys.}
A snapshot 
%consists of a mapping from 
%A heap 
$\h \in \Heaps$ consists of a function 
$\h: \Addr \rightarrow \Nat$. 
Given a MKVS $\hh$ and a view $V$, we can always determine a snapshot in 
the obvious way. 

\begin{definition}
\label{def:snapshot}
Let $\hh$ be a MKVS, and $V$ be a view. The snapshot of 
$V$ in $\hh$ is defined as
\[
\snapshot(\hh, V) = \lambda \key{k}. \valueOf(\hh, \key, V).
\]
\end{definition}



\ac{General Comment on this Section: it is too abstract. We 
should give either here or in the introduction an example of computation - 
the write skew program should be okay that helps the reader understanding 
what's going on. Also, it could be also good to illustrate the notions 
of execution tests and consistency models.}
%from a set of addresses $\Addr \defeq \Setcon{ [\nat] }{\nat \in \Nat }$ to values in $ \val \in \Val \defeq \Nat \cup \Addr$. 
%The set of all heaps is denoted by $\Heaps$.
We assume that each client has its own stack, 
where data for performing local computations is stored. 
%Transactions also 
%have a transaction-local stack. 
The set of thread-local stack variables is denoted by $\ThreadVars \defeq \{\pvar{x}, \pvar{y}, \cdots\}$, 
while the set of transaction local variables is denoted by $\TxVars \defeq \{\pvar{a}, \pvar{b}, \cdots\}$. 
We use $\ThdStacks$ to range over thread-local stacks in the set $\ThdStacks \defeq \ThreadVars \to \Val$, 
and $\TxStacks$ to range over transaction-local stacks in the set $\TxStacks \defeq \TxVars \to \Val$.
%\ac{We had some discussion on whether separating the thread-local and transaction-local stack made sense. 
%If you see tranaction code the same as method invocations, this assumption reflects what happens 
%in standard imperative programming languages (i.e. C): transaction-local variables are the local variables 
%of a method, thread-local variables are global variables. A method can read from the global variables. 
%The local variables of a method cannot be accessed outside of the method execution.
%From the technical point of view, having a single thread-local stack won't make too much of a difference, 
%as concurrent access to stack locations can never happen. So we can change it, if needed.}
%\ac{I am wondering whether it makes sense to allow threads to communicate using shared 
%variables outside of the database. In The context of concurrent data structures, this affects 
%the characterisation of contextual refinement (from sequential consistency to linearisability). 
%But in this case transactions are meant to execute atomically, whereas in concurrent 
%library semantics interleavings of method executions are possible.}

%The transaction-local stack is created at the moment a transaction starts, 
%and is destroyed at the moment it commits. 
%Transactions can read from, but cannot 
%write to, the thread-local stack. This assumption makes it possible to abstract from 
%aborting transactions, as these would have no side-effects in the computational model described. 
%We assume that each transaction-local 
%stack has a special variable that is used to store the value returned by the transaction 
%upon commit. Each thread-local stack also comes equipped with a special return variable, 
%where the contents of the value returned by transactions are stored. We use the symbol 
%$\retvar$ to denote the special return variable, both in transaction-local and thread-local 
%stacks.
%%\sx{
%%    Not sure about the ret var, 
%%    how to transfer the ret var from tx stack to thread stack as 
%%    we cannot modify the thread stack.
%%}
%%\ac{That can be done as part of the program semantics, executing 
%%a transaction modifies the ret value of the semantics. This is 
%%also what happens in real program executions, by pushing/popping the return value into 
%%the execution stack.}
%We leave the consistency model of the transactional memory unspecified. The rules 
%of our operational semantics will be parametric in the specification of a consistency 
%model, using a novel style of specification that we will present later in the paper. 

\section{Operational Semantics}
\label{sec:semantics}
In this section we define a simple programming language for clients of 
programs interacting with a key-value store. In this semantics, 
clients can only interact with the key-value store by using transactions. 
We abstract from aborting transactions: rather than assuming that a transaction 
may abort due to a violation of the consistency guarantees given by the key-value store, 
we only allow the execution of a transaction when its effects are guaranteed to not violate 
the consistency model of the key-value store. This approach is equivalent to a setting where 
clients always restart a transaction after it aborts.

Programs are mapping from clients to commands. Each
client is equipped with a set of local variables $\ThreadVars \defeq \{\pvar{x}, \pvar{y}, \cdots\}$ 
that they can use for local computations. Each client is equipped with a stack 
$\thdstack: \ThreadVars \rightarrow \nat$. The set of stacks is denoted by $\ThdStacks$. 
The state of a system consists of a configuration 
$\conf = (\hh, \viewFun)$, and a partial mapping $\Env: \tidset \rightharpoonup \ThdStacks$ from client identifiers to stacks, 
such that $\dom(\viewFun) = \dom(\ThdStacks)$.

\paragraph{\textbf{Syntax of Programs}}
We assume a set of (primitive) transactional commands $\primt,\primt',\cdots$, which 
we leave unspecified. Each transactional command $\primt$ is associated with a \emph{state transformer} 
%$\mathcal{S}_t \subseteq (\ThdStacks \times \TxStacks \times \Heaps) \times (\TxStacks \times \Heaps)$. 
$\mathcal{S}_t \subseteq (\ThdStacks \times \Heaps) \times (\ThdStacks \times \Heaps)$. 
\ac{This is slightly confusing: from the point of view of programs, the snapshot does not change 
while a transaction is executing.}
We use the notation $(\thdstack, \heap) \toT{t} (\thdstack' , \heap')$ 
in lieu of $(\thdstack, \txstack, \h), (\thdstack', \h' )) \in \mathcal{S}_t$. 
%Note that this definition ensures 
%that primitive transactional commands cannot update the thread-local stack.
We also assume a set of primitive non-transactional commands $\primc, \primc',\cdots$ 
that can be executed by a command outside transactions. Each primitive non-transactional 
command $\primc$ is associated with a state transformer $\mathcal{S}_c \subseteq 
(\ThdStacks \times \ThdStacks)$, and again we adopt the notation $\thdstack \toT{c} 
\thdstack'$ in lieu of $(\thdstack, \thdstack') \in \mathcal{S}_c$.
This definition ensures that non-transactional primitive commands do not access 
versions stored in  the key-value stores.

Often, we will assume a language of expressions at the base of primitive (transactional and non-transactional) 
commands. This language is defined by the grammar below: 
\[
\begin{rclarray}
\expr & ::= & \val \bor \pvar{x} \bor \pvar{a} \bor \expr + \expr \bor \expr \cdot \expr \bor \cdots
\end{rclarray}
\]
The set of all expressions is denoted by $\Expr$.
%Because non-transactional commands cannot access the transaction-local stack, we will 
%need the following, inductively defined, predicate: 
%\[
%\begin{rclarray}
%\isthdexp(\val) &=& \ttrue\\
%\isthdexp(\pvar{x}) &=& \ttrue\\
%\isthdexp(\pvar{a}) &=& \ffalse\\
%\isthdexp(\expr_1 + \expr_2) &=& \isthdexp(\expr_1) \wedge \isthdexp(\expr_2)\\
%\vdots & \vdots & \vdots
%\end{rclarray}
%\]
%In general, if the language of expressions contains an operator $\func{f}{\expr_1, \cdots, \expr_n}$, 
%where $n \geq 1$, we define $\isthdexp(\func{f}{\expr_1, \cdots, \expr_n}) = \bigwedge_{i=1,\cdots,n} \isthdexp(\expr_i)$.
%\ac{Subtle error here: for $f$ with arity $0$, then $\isthdexp(f) = \ttrue$. But now I can interpret 
%$\interpr{\mathtt{f}} = \lambda \thdstack. \lambda \txstack. \txstack(\pvar{a})$, for some $\pvar{a} \in 
%\TxVars$, thus allowing the access of transaction-local variables within thread-local commands. Boolean predicate must 
%be  fixed.}

The set of primitive non-transactional and transactional commands we will use is given by 
%\[
%\begin{rclarray}
%\primc &::=& \passign{\pvar{x}}{\expr} \mid \assume(\expr) \\
%\primt &::=& \passign{\pvar{x}}{\expr} \mid \pmutate{\expr}{\expr} \mid  \pderef{\pvar{a}}{\expr} \mid \assume(\expr)
%\end{rclarray}
%\]
\[
\begin{rclarray}
\primc &::=& \passign{\pvar{x}}{\expr} \mid \assume(\expr) \\
\primt &::=& \primc \mid \pmutate{\expr}{\expr} \mid  \pderef{\pvar{a}}{\expr}
\end{rclarray}
\]
Below we define the syntax of programs allowed by our language. 

\[
\begin{rclarray}
\prog & ::= & \tid: \cmd \Par \prog \Par \prog \\
%\cmd & ::= & \nil \mid X \mid \pi.\cmd \mid \cmd + \cmd \mid \mu X.\cmd \\
%\pi  & ::= & \primc \mid \ptrans{\trans} \\
%\trans  & ::= & \nil \mid X \mid \primt.\trans \mid \trans + \trans \mid  \mu X. \trans \\
\cmd & ::= & \nil \mid \primc \mid \ptrans{\trans} \mid \cmd ; \cmd \mid \cmd + \cmd \mid \cmd^{\ast} \\
%\pi  & ::= & \primc \mid \ptrans{\trans} \\
\trans  & ::= & \nil \mid \primt \mid \trans ; \trans \mid \trans + \trans \mid \trans^{\ast} \\
\end{rclarray}
\]
%\sx{what is the different between . and \(\pseq\) , \ie \( t \mid \trans \pseq \trans \mid \dots \).  }
%\ac{The mathematical structure that defines syntactically correct programs is different. In particular, if you 
%want to prove a property of a program, by induction on the syntax of that program, you have two 
%different inductive principles, whether your syntax allows $\primc. \cmd$ or $\cmd_1 \pseq \cmd_2$.}

A program corresponds therefore to a set of commands executing in parallel. 
Each command in a command is annotated with a thread identifier $\tid$. 
\ac{Following a discussion on the semantics, nobody likes client identifiers. It 
may simply be the case that we model a program as a set of commands, each of 
which is augmented with a MKVS and the views of clients on such MKVS.}
%Note that each command is annotated with a component $V$, called a \emph{view} which we 
%have purposely left unexplained. At an intuitive level, in a program of the form 
%$V : \cmd \Par \prog$, the view $V$ specifies the version that the command $C$ observes, 
%for each location. Views are described formally when introducing the operational semantics of 
%commands.
%
%Note that each thread has a unique thread identifier $\tid$ associated. The set 
%of all thread identifiers is $\tidset$.

\paragraph{Interpretation of Expressions and Primitive Commands}
Expressions are going to be evaluated in values from $\nat$ in the usual way. 
%Note that we need to account for the fact that we have two different notions of 
%stacks, one transaction-local, and the other thread-local. 
%\ac{We agreed to ditch the transaction-local stack. This will change in future versions.}
\[
\begin{rclarray}
\interpr{\cdot} \cdot &:& \Expr \times \ThdStacks \to \mathbb{N}\\
\interpr{\val}\thdstack & = & \val \\
\interpr{\mathtt{x}}\thdstack & = & \thdstack(\mathtt{x})\\
%\interpr{\mathtt{a}}(\thdstack)(\txstack) & = & \txstack(\mathtt{a})\\
\interpr{E_1 + E_2}\thdstack & \defeq & \interpr{E_1}\thdstack + \interpr{E_2}\thdstack\\
\vdots & = & \vdots
\end{rclarray}
\]

%Note that, for any expression $\expr$ such that $\isthdexp(\expr) = \ttrue$, we have 
%that $\interpr{\expr}(\thdstack)(\txstack) = \interpr{\expr}(\thdstack)(\txstack')$ for 
%any $\txstack, \txstack' \in \TxStacks$ and $\thdstack \in \ThdStacks$. 
%In this case, we commit an abuse of notation and write $\interpr{\expr}(\thdstack)$ 
%as a shorthand for $\interpr{\expr}(\thdstack)(\txstack_0)$, where $\txstack_0 = 
%\lambda \mathtt{a} .0$.

%\sx{ why \( \txstack_0 = \lambda \mathtt{a} .0\) instead of any? I guess any is also ok. }
%\ac{ Standard initialisation value. Many programming languages use $0$ as a default value 
%for variables upon initialisation.}

We now proceed to define the state transformers associated to transactional and non-transactional primitive commands. 
To specify the transformer of mutations, i.e. commands of the form $\pmutate{\expr_1}{\expr_2}$, and 
dereference, i.e. commands of the form $\pderef{\pvar{x}}{\expr}$, we fix a bijection $\keyOf: \nat \rightarrow \Addr$. 
This bijection exists because we are assuming that $\Addr$ is countably infinite. For the sake of clarity, we often avoid writing 
$\keyOf(n)$ and use the symbol $\key{k}_n$ as a shorthand for $\keyOf(n)$ instead.
For transactional and non-transactional primitive commands we have  
%\[
%\begin{rclarray}
%(\thdstack, \txstack, \h) &\toT{\passign{\pvar{a}}{\expr}}& (\txstack\rmto{\pvar{a}}{\interpr{\expr}(\thdstack)(\txstack)}, \h)\\
%(\thdstack, \txstack, \h) &\toT{\pderef{\pvar{a}}{\expr}}& (\txstack\rmto{\pvar{a}}{\h(\interpr{\expr}(\thdstack)(\txstack))}, \h)\\
%(\thdstack, \txstack, \h) &\toT{\pmutate{\expr_{1}}{\expr_{2}}}& (\txstack, \h\rmto{\interpr{\expr_{1}}(\thdstack)(\txstack)}{\interpr{\expr}(\thdstack)(\txstack)})\\
%(\thdstack, \txstack, \heap) &\toT{\assume(\expr)} & (\thdstack,\heap) \  \text{where} \  \interpr{E}(\thdstack)(\txstack) \neq 0 \\
%\end{rclarray}
%\]
\[
\begin{rclarray}
(\thdstack,\h) &\toT{\passign{\pvar{x}}{\expr}}& (\txstack\rmto{\pvar{x}}{\interpr{\expr}\thdstack}, \h)\\
(\thdstack, \h) &\toT{\pderef{\pvar{x}}{\expr}}& (\txstack[ \pvar{x} \mapsto \h(\key{k}_{\interpr{\expr}\thdstack}) ], \h)\\
(\thdstack, \h) &\toT{\pmutate{\expr_{1}}{\expr_{2}}}& (\txstack, \h[\key{k}_{\interpr{\expr_{1}}\thdstack} \mapsto \interpr{\expr_2}\thdstack])\\
%(\thdstack, \h) &\toT{\pderef{\pvar{x}}{\expr}}& (\txstack\rmto{\pvar{x}}{\h(\key{k}_{\interpr{\expr}(\thdstack)})}, \h)\\
%(\thdstack, \h) &\toT{\pmutate{\expr_{1}}{\expr_{2}}}& (\txstack, \h\rmto{\key{k}_{\interpr{\expr_{1}}(\thdstack)}}{\interpr{\expr_2}(\thdstack)})\\
(\thdstack, \h) &\toT{\assume(\expr)} & (\thdstack,\heap) \  \text{if} \  \interpr{E}\thdstack \neq 0 \\
\end{rclarray}
\]
where we recall that, given an arbitrary function $f: X \rightarrow Y$, and two elements $x \in X, y \in Y$, then 
$f[x \mapsto y]$ denotes the function $f'$ such that $f'(x) = y$, and $f'(x') = f(x')$ for all $x' \neq x$.

For non-transactional primitive commands we have 
\[
\begin{rclarray}
\thdstack & \toC{\passign{\pvar{x}}{\expr}} & \thdstack\rmto{\pvar{x}}{\interpr{\expr}(\thdstack)}\\
\thdstack & \toC{\assume(E)} & \thdstack \ \text{where} \interpr{\expr}(\thdstack) \neq 0
\end{rclarray}
\]

For transactional primitive commands $t$, we also defined a \emph{fingerprint}, 
which denotes the contribution of the primitive command $t$ in terms of operations that may be 
potentially observed by the external environment (i.e. other transactions). 
Formally, we assume a set of operations 
%$\Op$ that we leave unspecified, aside the fact that 
%we require that 
$\Op = \Setcon{\RD\;\key{k} : n, \WR\;\key{k} : n }{\key{k} \in \Addr \land n \in \nat}$. 
For technical reasons, we also define a special operation $\varepsilon$, called the 
empty operation,  that is not included in $\Op$, and we let $\Op_{\varepsilon} = \Op \cup \{\varepsilon\}$. 
Intuitively, $\varepsilon$ corresponds to the fingerprint of transactional commands that do not result in an 
interaction with the key-value store.
%
%Here $\varepsilon$ denotes the \emph{empty operation}, that is one that does not read, nor write from the shared state.

\begin{definition}
\label{def:fingerprint}
For our language of primitive transactional commands, we define the function
$\fingerprint : \cmd \times \ThdStacks \times \Heaps \to \Op$ 
as follows:
%This denotes the kind of operation that is performed by  $t$. 
\[
\begin{array}{lclr}
\fingerprint(\passign{\pvar{a}}{\expr}, \stub, \stub) & \defeq & \varepsilon & \\
\fingerprint(\pderef{\pvar{a}}{\expr},\thdstack,\h) & \defeq  & \RD\; [n] : \h([n]) & \text{where } n := \interpr{\expr}(\thdstack)(\txstack)\\
\fingerprint(\pmutate{\expr_{1}}{\expr_{2}},\thdstack, \h) & \defeq & \WR\; [n_1] : n_2 & \text{where } n_i := \interpr{\expr_i}(\thdstack),  i=1,2
\end{array}
\]
\end{definition}
%\sx{
%Previously we are setting up the \(t\) as in a very generous form, now we are saying some of then can be extracted to a read/write form. 
%Here it is a bit inconsistent.
%Minor point but might change later.
%
%Possibly finger print heap with  \( \ws{\h} \) and \( \rs{\h} \) functions is a good way to go.
%}
\paragraph{Semantics of Transactions}
For the operational semantics of transactions, 
%The semantics of transactions is given in an operational way, 
judgements take the form $\langle \thdstack, \heap, \mathcal{O}, \trans \rangle 
\rightarrow \langle \thdstack', \heap', \mathcal{O}', \trans' \rangle$. Here $\mathcal{O}, \mathcal{O}' \subseteq \Op$ 
keep track of the fingerprint of the transaction being executed. Because transactions only work with a local 
snapshot of the key-value store, at this level MKVSs and views are not involved.
%Note that in this semantics 
%the $\thdstack$ component cannot be manipulated by performing a transition, as to reflect 
%the fact that transactions can only read from, and never write to, the thread local heap.
%The components $\RS, \WS \in \Addr \parfun \Val$ record the read-set and write-set associated to the transaction code, 
%respectively.

The fingerprint of a transaction corresponds to the set of all its interactions (i.e. read and write operations over keys) 
with the  key-value store. To keep track of such interactions, we introduce an operator 
$\oplus$ that specifies the effects of adding a new operation inside 
a set of previously defined operations. 
%Again, the behaviour of $\oplus$ is left widely unspecified, 
%exception made for the rules that govern read and write operations.
%In order to give the semantics of transactions, it will be useful to define the following operator over sets of 
%operations. 
%\[
%\begin{rclarray}
%\RS \RScup (\addr, \val) & \defeq  & \RS \uplus \Set{\addr \mapsto \val} \\
%\WS \WScup (\addr, \val) & \defeq & \WS\rmto{\addr}{\val} 
%\end{rclarray}
%\]
\begin{definition}
\label{def:fingerprint.operator}
The operator $\oplus : \powerset{\Op} \times \Op_{\varepsilon} \rightarrow \powerset{\Op}$ is defined as follows: 
\[
\begin{array}{lcl}
\mathcal{O} \oplus \varepsilon &=& \mathcal{O}\\
\mathcal{O} \oplus (\RD\;[n]: m) &=&
\begin{cases}
\mathcal{O} \cup \{\RD\; [n]: m)\} & \impliedby \mathcal{O} \cap \{ \RD\;[n]: m, \WR [n]: m \mid m \in \Val\} = \emptyset\\
\mathcal{O} & \impliedby \text{otherwise}
\end{cases}\\
\mathcal{O} \oplus (\WR\;[n]: m) &=& 
(\mathcal{O} \setminus \{ \WR;[n] : m \mid m \in \Val \}) \cup \{\WR\;[n]: m \}
\end{array}
\]
\end{definition}
Intuitively, when executing a transaction we start with the empty fingerprint. Initially, the transaction has 
not interacted with the key-value store. Then, every time that a primitive command is executed by the 
transaction, we update its set of interactions by applying the operator $\oplus$ to the fingerprint of the  primitive
command executed. The definition of the operator $\oplus$ ensures that, for each key, only the first read preceding a 
write, and only the last write to that key, are recorded into the fingerprint of a transaction. This choice is motivated 
by the fact that we only focus on atomically visible transactions: keys are read from a snapshot of the 
database, and new version are written only at the moment the transaction commits. 

\begin{definition}
\label{def:ops.welldefined}
A set of operations $\mathcal{O}$ is well-defined if, 
\[
\forall \key{k} \in \Addr.\forall O \in \{\RD, \WR\}. \forall n,m \in \nat.\; (O \;\key{k}: n) \in \mathcal{O} \wedge (O\; \key{k}: m) \in \mathcal{O}
\implies n = m.
\] 
\end{definition}

\begin{lemma}
\label{lem:wellformedops.closed}
The set of well-defined operations is closed under $\oplus$: 
\[ \forall \mathcal{O} \in \powerset{\Op}.\; \forall op \in \Op_{\varepsilon}.\; \mathcal{O} \text{ is well-formed } 
\implies \mathcal{O} \oplus op \text{ is well-formed.}
\]
\end{lemma}

The rules of the operational semantics for transactions are given in Figure \ref{fig:opsem.tx}.
\begin{figure}
\begin{tabular}{|@{}c c@{}|}
\hline 
\multicolumn{2}{|@{}c@{}|}{
%\[
%\infer[{\scriptstyle{(prim-t-local-nofp)}}]
%{\thdstack \vdash \langle \txstack, \heap, \mathcal{O}, t.\trans  \rangle \rightarrow \langle \txstack', \heap', \mathcal{O}, \trans \rangle}
%{(\thdstack, \txstack, \heap) \toT{t} (\txstack', \heap') \qquad \fingerprint(t,\thdstack,\txstack,\heap) = \text{undefined}}
%\]
$
\infer[{\scriptstyle{(Tx-prim)}}]
{\langle \thdstack, \h, \mathcal{O}, t \rangle \rightarrow \langle \txstack', \h', \mathcal{O} \oplus op, \trans \rangle}
{(\thdstack, \h) \toT{t} (\thdstack', \heap') \qquad \fingerprint(t,\thdstack,\h) = op}
$
}\\[8pt]
%\[
%\infer[{\scriptstyle{(prim-t-write)}}]
%{\thdstack \vdash \langle \txstack, \heap, \RS, \WS, t.\trans \rangle \rightarrow \langle \txstack', \heap', \RS, \WS \WScup (\addr,\val), \trans \rangle}
%{(\thdstack, \txstack, \heap) \toT{t} (\txstack', \heap') \qquad \fingerprint(t,\thdstack,\txstack,\h) = (\WR, \addr, \val)}
%\]
$
\infer[{\scriptstyle{(\Tx-comp-1)}}]{\langle \thdstack, \h, \mathcal{O}, \trans_1 ; \trans_2 \rangle 
\rightarrow \langle  \thdstack', \h', \mathcal{O}', \trans_1' ; \trans_2 \rangle}
{\langle \thdstack, \h, \mathcal{O}, \trans_1 \rangle \rightarrow \langle \thdstack', \h', \mathcal{O}', \trans_1' \rangle}
$
&
$
\infer[{\scriptstyle{(\Tx-comp-1)}}]{\langle \thdstack, \h, \mathcal{O}, \nil ; \trans_2 \rangle 
\rightarrow \langle  \thdstack, \h, \mathcal{O}, \trans_2 \rangle}
{}
$
\\[8pt]
$
\infer[{\scriptstyle{(\Tx-choice-L)}}]{\langle \thdstack, \h, \mathcal{O}, \trans_1 + \trans_2 \rangle 
\rightarrow \langle  \thdstack, \h, \mathcal{O}, \trans_1 \rangle}{}
$
& 
$
\infer[{\scriptstyle{(\Tx-choice-R)}}]{\langle \thdstack, \h, \mathcal{O}, \trans_1 + \trans_2 \rangle 
\rightarrow \langle  \thdstack, \h, \mathcal{O}, \trans_2 \rangle}{}
$
\\[8pt]
\multicolumn{2}{|@{}c@{}|}{
$
\infer[{\scriptstyle{(\Tx-star)}}]{\langle \thdstack, \h, \mathcal{O}, \trans^{\ast} \rangle 
\rightarrow \langle  \thdstack, \h, \mathcal{O}, \nil + (\trans ; \trans^{\ast}) \rangle}{}
$
%$
%\infer[{\scriptstyle{(\Tx-star)}}]{\thdstack \vdash \langle \txstack, \heap, \mathcal{O}, \mu X.\trans \rangle 
%\rightarrow \langle  \txstack, \heap, \mathcal{O}, \{\nicefrac{\mu X.\trans}{X}\}\trans \rangle}{}
%$
}\\
\hline
\end{tabular}
\caption{Rules for the operational semantics of transactions.}
\label{fig:opsem.tx}
\end{figure}
\ac{I changed the language so that we have classical sequential composition and Kleene star. 
However, these choices lead to a more complicated operational semantics (6 rules against 4). 
The advantage of this syntax is that we do not have program variables anymore, which in turn makes proofs 
easier (especially when proving properties of recursive programs). 
However, I'm not a fan of this approach, since we are basically getting rid of an internal 
complication - i.e. technical details that will only play a role in proofs - by introducing external 
ones - i.e. that are plainly visible for the reader.}
%\ac{Design Choice: maybe the heap should go away in the right hand side of judgments for 
%transactional commands. Judgements may take the form $\thdstack, \heap \vdash \langle \txstack, \mathcal{O}, \trans \rangle 
%\rightarrow \langle \txstack', \mathcal{O'}, \trans' \rangle$; then one can define the operator 
%$\mathsf{lift}: (\heap, \mathcal{O}) \mapsto \heap'$ by letting $\mathsf{lift}(h, \mathcal{O})([\nat]) = m$ if $\WR\;[n]: m \in \mathcal{O}$, 
%$h([n])$ otherwise - note that this operator is well-defined only in the case that whenever $\WR\; [n]:m, \WR\;[n]:m' \in \mathcal{O}$, 
%then $m = m'$. Then one can define sequences of computations by means of these two rules: 
%\[
%\infer[{\scriptstyle(SeqTx-Id)}]{\thdstack, \heap \vdash \langle \txstack, \mathcal{O}, \trans \rangle \twoheadrightarrow
%\langle \txstack, \mathcal{O}, \trans \rangle}{}
%\]
%\[
%\infer[{\scriptstyle(SeqTx-trans)}]{\thdstack, \heap \vdash \langle \txstack, \mathcal{O}, \trans \rangle \twoheadrightarrow 
%\langle \txstack'', \mathcal{O}'', \trans'' \rangle}
%{\begin{array}{c}\thdstack, \heap \vdash \langle \txstack, \mathcal{O}, \trans \rangle \twoheadrightarrow \langle \txstack', \mathcal{O}', \trans' \rangle
%\qquad \heap' = \mathsf{lift}(\heap, \mathcal{O}')\\
%\thdstack, \heap' \vdash \langle \txstack', \mathcal{O}', \trans' \rangle \rightarrow \langle \txstack'', \mathcal{O}'', \trans'' \rangle  \end{array}}
%\]
%}
%\section{Abstract Executions}
%Here we present abstract executions, which we will use to record the 
%run-time behaviour of programs. 
%
%We start by defining the behaviour of transactions at run-time. 
%We assume a set of (run-time) transactions identifiers $\TransID = \{\tsid, S , \cdots \}$ 
%and a set of operations which we leave unspecified, though 
%we require that $\Op \supseteq \Setcon{ \RD\;\addr :\val, \WR\;\addr :\val }{\addr \in \Addr \land \val \in \Val }$.
%We also assume a function $\behav : \TransID \to \powerset{\Op}$, which maps 
%transactions into the operations that they perform on locations. With an abuse of 
%notation, for any transaction $\tsid$ and operation $o$, we write $o \in \tsid$ (or $\tsid \ni o$) as 
%a shorthand for $o \in \behav(\tsid)$. 
%We only model transaction that enjoy \emph{atomic visibility}. This 
%means that \textbf{(i)} transactions never observe two different values when reading from 
%the same location: $\for{ \tsid \in \TransID,  \addr \in \Addr,\val, \val' \in \Val }
%\tsid\ni \RD\;\addr :\val \land \tsid \ni \RD\;\addr:\val' \implies \val = \val'$; and \textbf{(ii)} 
%the effects of a transactions become visible at once, which means that we never observe
%two different values written for the same location by a transaction: $\for{ \tsid \in \TransID, \addr \in \Addr, \val,\val' \in \Val } 
%\tsid \ni \WR\;\addr: \val \land \tsid \ni \WR\;\addr:\val' \implies \val = \val'$.
%
%\begin{definition}[abstraction executions]
%An abstract execution is a tuple $\aexec = (\settrans, \PO, \VIS, \AR)$, where 
%
%\begin{enumerate}
%\item 
%$\T$ is a finite, empty set of transactions, 
%
%\item 
%$\PO \subseteq \T \times \T$, the \emph{program order}, is the union 
%of disjoint, strict total orders over $\T$. That is, there exists a partition $\{\T_i\}_{i \in I}$ 
%of $\T$ such that $\PO = \bigcup_{i \in I} \PO_i$, where for any $i \in I$, $\PO_i$ is a strict, 
%total order over $\T_i$\footnote{Recall that a relation $R \subseteq \T \times \T$ is a strict partial order 
%if it is irreflexive and transitive. It is a strict total order if it enjoys the additional property that 
%for any $T_1, T_2 \in \T$, either $T_1 = T_2$, $(T_1, T_2) \in R$ or $(T_2, T_1) \in R$.},
%
%%\item 
%$\VIS \subseteq \T \times \T$ is a strict, partial order such that $\PO \subseteq \VIS$, and $\VIS \rcomp \VIS \subseteq 
%\VIS$,
%
%%\item 
%$\AR \subseteq \T \times \T$ is a strict, total order such that $\VIS \subseteq \AR$,
%
%%\item 
%for any location $\addr \in \Addr$ let $\WTr(\addr) = \Setcon{S \in \T }{S \ni \WR\;\addr:\anyval }$. 
%Given $T \in \T$, let also $\pw_{\aexec}(\addr, \tsid) = \Setcon{\tsid' }{ \tsid' \in \VIS^{-1}(\tsid)} \cap \WTr(\addr)$. 
%Whenever $T \ni \RD\;\addr: \val$ for some transaction $\tsid \in \T$, location $\addr \in \Addr$ and 
%value $\val \in \Val$, then either $\pw_{\aexec}(\addr, \tsid) = \emptyset$ and $\val = 0$, 
%or $\max_{\AR}(\pw_{\aexec}(\addr, \tsid)) \ni \WR\;\addr: \val$.
%
%\end{enumerate}
%
%\end{definition}
%The set of all abstract executions is denoted as $\aeset$.
%In the following, for an abstract execution $\aexec = (\T, \PO, \VIS, \AR)$, we let 
%$\T_{\aexec} = \T$, $\PO_{\aexec} = \PO$, $\VIS_{\aexec} = \VIS$, $\AR_{\aexec} = \AR$. 
%We often use the notation $T \xrightarrow{R} S$ instead of $(T,S) \in R$.
%
%\paragraph{\textbf{Specification of Weak Consistency Models.}}
%We use the style of specification for weak consistency models 
%proposed in \cite{laws}. 
%
%\begin{definition}
%A specification function $\rho$ is an endo-function of relations over 
%transactions, $\rho: (\TrSet \times \TrSet) \rightarrow (\TrSet \times \TrSet)$,
%such that for any abstract execution $\aexec$ and relation $R \subseteq \T_{\aexec} \times \T_{\aexec}$, 
%$\rho(R) = \rho(\T_{\aexec} \times \T_{\aexec}) \cap R?$. 
%
%A consistency guarantee is a pair $(\rho, \pi)$ of specification functios.
%An abstract execution based specification of weak consistency models, or simply \emph{x-specification}, 
%is a (possibly empty, possibly infinite) set of consistency guarantees: $\xspec = \{(\rho_i, \pi_i)\}_{i \in I}$ 
%for some index set $I$.
%\end{definition}
%
%\begin{definition}
%An abstract execution $\aexec$ is allowed by the consistency model specification $\xspec$, 
%written $\xspec \models \aexec$, if and only if, for any $(\rho, \pi) \in \xspec$, we have that $\rho(\VIS_{\aexec}) \rcomp \AR_{\aexec} 
%\rcomp \VIS_{\aexec} \subseteq \AR_{\aexec}$.
%\end{definition}
%
%\begin{example}
%Let $\rho_{\Id} = \lambda \_. \Id$, $\rho_{\SI} = \lambda R. (R \setminus \Id)$, and $\rho_[n] = 
%\lambda \_. [\WTr_{[n]}]$ for any location $[n] \in \locs$. Here, given a set $X \subseteq \TrSet$, 
%$[X]$ is defined as $\Id \cap (X \times X)$. We specify \emph{Snapshot Isolation} via the set 
%of consistency guarantees $\xspec_{\SI} = \{(\rho_{\Id}, \rho_{\SI})\} \cup \bigcup_{[n] \in \locs} \{(\rho_{[n]}, \rho_{[n]}\}$. 
%
%An abstract execution $\aexec$ is allowed by $\xspec_{\SI}$ if and only if 
%$\AR_{\aexec} \rcomp \VIS_{\aexec} \subseteq \VIS_{\aexec}$, 
%and for any $[n] \in \locs$, $[\WTr_{[n]}] \rcomp \AR_{\aexec} \rcomp [\WTr_{[n]}] \subseteq \VIS$.
%\end{example}
%\sx{NEED TO REVISIT ABOVE LATER}
%
%In the following, we will use an incremental approach to build abstract executions from transactions. 
%Suppose that an abstract execution $\aexec$ has been obtained as the (partial) result of a program $P$ running 
%in a system that implements the x-specification $\xspec$. 
%Suppose also that $T \in \T_{\aexec}$ is the transaction-instance associated with the last transactional 
%code that has been executed by some thread, and that the same thread executes another piece of transactional 
%code next, which results in the transaction instance $S$. This may result in an abstract execution $\aexec'$, 
%where the new transaction instance $S$ follows $T$ in the program order $\PO_{\aexec'}$, and $\VIS_{\aexec'}, 
%\AR_{\aexec'}$ are computed according to the axioms of $\xspec$.
%$T \in \T_{\aexec}$. Note that the result of this procedure may result in an abstract execution that 
%is not allowed by $\xspec$, hence it is not always defined.
%Formally, we define an operator $\aeplus_{\xspec} : (\aeset \times \TrSet) \rightharpoonup 
%\aeset$ as follows:
%
%\begin{defn}[Runtime abstract executions]
%Assuming set of thread identifiers \( \ThreadID \defeq \Set{\thid, \dots}\), the set of \emph{runtime abstract executions} is defined as the follows,
%\[
%    \begin{rclarray}
%    \aexecrun \in \Setcon{(\settrans, \PO, \VIS, \AR) 
%    }{ 
%        \settrans \in  (\TransID \uplus \ThreadID ) \parfun \powerset{\Events}  \\
%        {} \land  \PO, \VIS \subseteq ( \dom(\settrans) \cap \TransID ) \times \dom(\settrans) \\
%        {} \land  \AR \subseteq ( \dom(\settrans) \cap \TransID  ) \times ( \dom(\settrans) \cap \TransID )
%    }
%    \end{rclarray}
%\]
%\end{defn}
%
%\begin{definition}
%Let $\xspec$ be a x-specification. 
%Let $\aexec \in \aeset$, and let $T \in \T_{\aexec}$. 
%Also, let $S \in \TrSet \setminus \T_{\aexec}$.
%Define the abstract execution $\aexec'$ as follows: 
%in which case we have
%\begin{gather*}
%\PO_{\aexec}' = (\PO_{\aexec} \cup \{(T,S)\})^{+}\\
%\AR_{\aexec}' = \{(T', S), (S, T'') \mid T' \in \AR_{\aexec}^{-1}(T) \wedge T'' \in \AR_{\aexec}(T)\}^{+}\\
%\VIS_{\aexec}' = \mu V.(\PO_{\aexec}' \cup \VIS_{\aexec} \cup \bigcup_{(\rho, \pi \in \xspec)} \rho(V) \rcomp \AR_{\aexec}' \rcomp \pi(V) )^{+}
%\end{gather*}
%The abstract execution $(\aexec, T) \aeplus_{\xspec} S$ is defined to be exactly $\aexec'$ 
%if whenever $S \ni \WR\;[n]:\_$ and $S \xrightarrow{\VIS_{\aexec}'} T$, then $T \not\ni \RD\;[n]:\_$ 
%and $T \not\ni \WR\;[n]:\_$, 
%it is undefined otherwise.
%\end{definition}
%
%\begin{proposition}
%Let $\xspec$ be a x-specification, and suppose that $\xspec \models \aexec$ for some abstract
%execution $\aexec$. Let $T, S$ be two transactions such that $(\aexec, T) \aeplus_{\xspec} S$ is
%defined. Then $\xspec \models (\aexec, T) \aeplus_{\xspec} S$.
%\end{proposition}
%\ac{Not sure whether it's true. Needs to be checked.}
%
%Note that, for a transaction $T_0$ such that $T_0 \ni o$ for no operation $o \in \Op$, 
%$(\aexec, T) \aeplus_{\xspec} T_0$ is always defined (provided $T_0 \notin \T_{\aexec}, T \in \T_{\aexec})$.
%
%Given an abstract execution and a x-specification $\aexec$, we can map any transaction $T \in \T_{\aexec}$ 
%to a heap $\heap_{\aexec}^{\xspec}(T)$. Intuitively, the latter corresponds to the heap that would be observed 
%by a client that interact with a system implementing the x-specification $\xspec$, assuming that 
%the set of transactions processed by the system so far resulted has given rise to the abstract execution 
%$\aexec$, and that the last transaction instance of $\aexec$ observed by the client is $T$.
%
%\begin{definition}
%Let$\xspec$ be a consistency model specification, and $\aexec$ be an abstract execution. For any $T \in \T_{\aexec}$, 
%let $\aexec' = (\aexec, T) \aeplus_{\xspec} T_0$, where $T_0 \notin \T_{\aexec}$ and $T_0 \ni o$ for no 
%$o \in \Op$. We can always assume that such a transaction exists. 
%
%We define $\heap_{\aexec}^{\xspec}(T)$ as follows:
%\[
%\heap_{\aexec}(T) = \lambda [n] \in \locs.
%\begin{cases}
%0 &\impliedby \pw_{\aexec'}([n], T) = \emptyset\\
%m & \impliedby \max_{\AR_{\aexec'}}(\pw_{\aexec'}([n], T_0)) \ni \WR\;[n]: m 
%\end{cases}
%\]
%\end{definition}
%\ac{I don't really like this definition, but for the moment it will do...}
%
%\begin{example}
%Consider the abstract execution $\aexec$ depicted below, denoting the write-skew anomaly 
%allowed by snapshot isolation. 
%
%\begin{center}
%\begin{tikzpicture}
%\node(Rx0) {$\RD\;[1]: 0$};
%\path(Rx0.center) + (0,-0.5) node (Wy1) {$\WR\;[2]: 1$};
%\path(Rx0.center) + (4,0) node (Ry0) {$\RD\;[2]: 0$};
%\path(Ry0.center) + (0,-0.5) node (Wx1) {$\WR\;[1]: 1$};
%%
%\begin{pgfonlayer}{background}
%\node(t1)[background, fit=(Rx0)(Wy1), inner sep=0.15cm] {};
%\node(t2)[background, fit=(Ry0)(Wx1), inner sep=0.15cm] {};
%\path(t1.west) + (-0.25,0) node (T) {$T$};
%\path(t2.east) + (0.25,0) node(S) {$S$};
%\path[->, thick]
%(t2.west) edge node[above] {$\AR$} (t1.east);
%\end{pgfonlayer}
%\end{tikzpicture}
%\end{center}
%Let us calculate $\heap_{\aexec}^{\xspec_{\SI}}(T)$. 
%Let then $T_0$ be a transaction with no operation associated, 
%and let us compute $\aexec' = (\aexec, T) \aeplus_{\xspec_{\SI}} T_0$. 
%By definition, we have that $T \xrightarrow{\PO_{\aexec'}} T_0$, hence 
%$T \xrightarrow{\VIS_{\aexec'}} T_0$. Because $S \xrightarrow{\AR_{\aexec}}T$, 
%we also have that $S \xrightarrow{\AR_{\aexec}} T$, and now from 
%$S \xrightarrow{\AR_{\aexec'}} T \xrightarrow{\VIS_{\aexec'}} T_0$, 
%we obtain that $S \xrightarrow{\VIS_{\aexec'}} T_0$. By definition, 
%we also know that $S \xrightarrow{\AR_{\aexec}} T$ implies that 
%$S \xrightarrow{\AR_{\aexec'}} T_0$. The final result is the abstract 
%execution $\aexec'$ depicted below: 
%\begin{center}
%\begin{tikzpicture}
%\node(Rx0) {$\RD\;[1]: 0$};
%\path(Rx0.center) + (0,-0.5) node (Wy1) {$\WR\;[2]: 1$};
%\path(Rx0.center) + (4,0) node (Ry0) {$\RD\;[2]: 0$};
%\path(Ry0.center) + (0,-0.5) node (Wx1) {$\WR\;[1]: 1$};
%\path(Wy1.center) + (0,-2.5) node (phantom) {\phantom{$\WR\;[2]: 1$}};
%%
%\begin{pgfonlayer}{background}
%\node(t1)[background, fit=(Rx0)(Wy1), inner sep=0.15cm] {};
%\node(t2)[background, fit=(Ry0)(Wx1), inner sep=0.15cm] {};
%\node(t3)[background, fit=(phantom), inner sep=0.15cm] {};
%\path(t1.west) + (-0.25,0) node (T) {$T$};
%\path(t2.east) + (0.25,0) node(S) {$S$};
%\path(t3.west) + (-0.3,0) node(T0) {$T_0$};
%\path[->, thick]
%(t2.west) edge node[above] {$\AR$} (t1.east)
%(t1.south) edge node[left] {$\PO, \VIS,\AR$} (t3.north)
%(t2.south west) edge node[right] {\;\;\;$\VIS, \AR$} (t3.north east);
%\end{pgfonlayer}
%\end{tikzpicture}
%\end{center}
%It is easy to see that $\pw_{\aexec'}([1], T_0) = \{S\}$, and $\pw_{\aexec'}([2], T_0) = \{T\}$. 
%Because $S \ni \WR\;[1]:1$, we have that $\heap_{\aexec}^{\xspec_{\SI}}(T)([1]) = 1$, 
%and because $T \ni \WR\;[2]:1$, we have that $\heap_{\aexec}^{\xspec_{\SI}}(T)([2]) = 1$.
%
%Next, we want to calculate $\heap_{\aexec}^{\xspec_{\SI}}(S)$. To this end, we need first 
%to retrieve the abstract execution $\aexec'' = (\aexec, S) \aeplus_{\xspec_{\SI}} T_0$, 
%which is depicted below:
%\begin{center}
%\begin{tikzpicture}
%\node(Rx0) {$\RD\;[1]: 0$};
%\path(Rx0.center) + (0,-0.5) node (Wy1) {$\WR\;[2]: 1$};
%\path(Rx0.center) + (4,0) node (Ry0) {$\RD\;[2]: 0$};
%\path(Ry0.center) + (0,-0.5) node (Wx1) {$\WR\;[1]: 1$};
%\path(Wx1.center) + (0,-2.5) node (phantom) {\phantom{$\WR\;[1]: 1$}};
%%
%\begin{pgfonlayer}{background}
%\node(t1)[background, fit=(Rx0)(Wy1), inner sep=0.15cm] {};
%\node(t2)[background, fit=(Ry0)(Wx1), inner sep=0.15cm] {};
%\node(t3)[background, fit=(phantom), inner sep=0.15cm] {};
%\path(t1.west) + (-0.25,0) node (T) {$T$};
%\path(t2.east) + (0.25,0) node(S) {$S$};
%\path(t3.east) + (0.25,0) node(T0) {$T_0$};
%\path[->, thick]
%(t2.west) edge node[above] {$\AR$} (t1.east)
%(t2.south) edge node[right] {$\PO, \VIS,\AR$} (t3.north)
%(t3.north west) edge node[right] {\;\;\;$\AR$} (t1.south east);
%\end{pgfonlayer}
%\end{tikzpicture}
%\end{center}
%In this case we have that $\pw_{\aexec''}([1],T_0) = \{S\}$, 
%and $\pw_{\aexec''}([2], T_0) = \emptyset$. By definition, 
%we have that $\heap_{\aexec}^{\xspec_{\SI}}(S)([1]) = 1$, 
%and $\heap_{\aexec}^{\xspec_{\SI}}(S)([2]) = 0$.
%\end{example}
%
%\paragraph{\textbf{Semantics of Commands.}}
%Judgements for programs take the form 
%$\langle \aexec, T, \thdstack \Cmd \rangle \rightarrow \langle \aexec', T',  \thdstack', \Cmd' \rangle
%$.Here $\aexec$ is an abstract execution that represent 
%the global run of the database, 
%$T$ represents the last transaction executed by the command, in the abstract execution, 
%and $\thdstack$ is the thread local stack associated with the transaction.
%
%The rule for evaluating a non-transactional primitive command is straightforward, as it 
%does only require to manipulate the thread-local stack associated  with the command. 
%\[
%\infer[{\scriptstyle{(prim-c)}}]
%{\langle \aexec, T, \thdstack, \primc.\Cmd \rangle \rightarrow \langle \aexec, T, \thdstack', \Cmd \rangle}
%{\thdstack \rightsquigarrow_c \thdstack'} 
%\]
%
%Next, we give the rule for evaluating a transaction in a command of the form $\TxOp{\trans}.\Cmd$. 
%First, given a read-set $\RS$ and a write-set $\WS$, we define the set of transaction $\makeTx(\RS,\WS)$ 
%to be the largest set of transactions such that, whenever $T \in \makeTx(\RS, \WS)$, then $T \ni \RD\;[n]:m$, if and only if $([n], m) \in \RS$, and $T \ni 
%\WR\;[n]:m$ if and only if $([n], m) \in \WS$. 
%\[
%\infer[{\scriptstyle{(Tx-exec)}}]{\langle \aexec, T, \thdstack, \TxOp{\trans}.\Cmd \rangle \rightarrow 
%\langle \aexec', T', \thdstack[\retvar \mapsto \txstack'(\retvar)], \Cmd \rangle}
%{
%\begin{array}{lll}T \xrightarrow{\AR_{\aexec}} S &  T' \in (\makeTx(\RS,\WS) \setminus \T_{\aexec}) & \aexec' = (\aexec, S) \aeplus_{\xspec} T'\\[4pt]
%\multicolumn{3}{c}{\thdstack \vdash \langle \txstack_0, \heap_{\aexec}^{\xspec}(S), \emptyset, \emptyset, \trans \rangle \rightarrow^\ast \langle \txstack', \heap', \RS, \WS, \nil \rangle}
%\end{array}}
%\]
%The three remaining rules are standard.
%\[
%\infer[{\scriptstyle{(C-choice-L)}}]
%{\langle \aexec, T, \thdstack, \Cmd_1 + \Cmd_2 \rangle \rightarrow \langle \aexec, \Cmd_1, \thdstack, \Cmd \rangle}
%{} 
%\]
%
%\[
%\infer[{\scriptstyle{(C-choice-R)}}]
%{\langle \aexec, T, \thdstack, \Cmd_1 + \Cmd_2 \rangle \rightarrow \langle \aexec, \Cmd_2, \thdstack, \Cmd \rangle}
%{} 
%\]
%
%\[
%\infer[{\scriptstyle{(C-fix)}}]
%{\langle \aexec, T, \thdstack, \mu X.\Cmd \rangle \rightarrow \langle \aexec, \{\nicefrac{\mu X.\Cmd}{X}\}\Cmd, \thdstack, \Cmd \rangle}
%{} 
%\]

\paragraph{\textbf{Semantics of Commands.}}
%Before giving the semantics of commands, it will be necessary to formalise 
%the notions of \emph{history heap} and \emph{view}. 
%We assume countably infinite set of transaction identifiers $\TransID$, whose elements 
%are ranged over $\tsid$. Subsets of $\TransID$ are ranged over by $\T$. 
%A \emph{Version} is a triple 
%$(v, \tsid, \{\tsid_1, \tsid_2,\cdots\}) \in \Val \times \TransID \times 2^{\TransID}$. 
%The set of all versions is denoted by $\Versions$, and its elements are ranged over $\nu, \nu', \cdots$. 
%Intuitively, associating a location $[n]$ with the version $\nu = (v, \tsid, \{\tsid_1,\tsid_,\cdots\})$ means that the 
%value $v$ has been written for location $[n]$. The transaction that wrote version $\nu$ is $\tsid$, 
%and the version has been read by transactions $\{\tsid_1,\tsid_2,\cdots\}$. 
%Given a version $\nu := (v, \tsid, \T)$, we define $\valueOf(\nu) = v$, $\WTx(\nu) := \tsid$, 
%and $\RTx(\nu) := \T$.
%A history heap is a function $\hh: \Addr \rightarrow \Versions^{\ast}$ that 
%maps each location to its list of versions. As usual, if 
%$\hh([n]) = \nu_0,\cdots, \nu_m$ for some location $[n]$, then for any 
%$i= 0,\cdots, m$ we let $\hh([n])(i) = \nu_i$, and we let $\lvert \hh([n]) \rvert = m -1$. 
%For a list of versions $vlist$, an index $i = 0,\ cdots, \lvert vlist \rvert - 1$, and a version $\nu$, 
%we let  $vlist[i \mapsto \nu]$ to be the same of $vlist$, exception made for the version at 
%location $i$ which is replaced with $\nu$.
%
%Given a history heap $\hh$, we can extract several heaps 
%from it, by simply choosing for each location $[n]$ a version 
%contained in the list of versions available for $[n]$ in $\hh$, 
%namely $\hh([n])$. 
%In order to determine uniquely the heap in which a command 
%is executing, we introduce \emph{views}. A view $V : \Addr \rightarrow \mathbb{N}$ is 
%a function that maps a location $[n]$ to the index of the version 
%that must be read for such a location. Given a history heap $\hh$ and a 
%view $V$, we can construct a heap as follows:  
%\[
%\snapshot(\hh, V) = \lambda [n] \in \Addr. \big( \hh([n])(V([n]) \big)
%%\begin{cases}
%%v_{V([n])} &\impliedby \hh([n]) = \langle v_0, \_ , \_ \rangle \cdots \langle v_{m}, \_, \_ \rangle \wedge m \geq V([n])\\
%%\text{undefined} & \text{otherwise}
%%\end{cases}
%\]
%
%%Formally, we define a \emph{snapshot} 
%%to be a function $\snapshot: \Addr \rightarrow \mathbb{N}$; 
%%given a history heap $\hh$ and a snapshot $\snapshot$, 
%%we can construct the heap 
%%\[
%%\heap(\hh, \snapshot) = \lambda [n] \in \Addr. 
%%\begin{cases}
%%v_{\snapshot([n])} &\impliedby \hh([n]) = \langle v_0, \_ , \_ \rangle \cdots \langle v_{m}, \_, \_ \rangle \wedge m \geq \snapshot([n])\\
%%\text{undefined} & \text{otherwise}
%%\end{cases}
%%\]
%%The syntax of commands has the form $V : \cmd$. Here $V$ is the view of the thread executing 
%%the command $\cmd$. 
Judgements in the semantics of commands take the form 
\[ 
\langle \hh, \sigma, V: C \rangle \xrightarrow{\ET} \langle \hh', \thdstack', V': \cmd' \rangle
\]

%where $\alpha \in \{ \lambda, \delta \}$ identifies whether a transition performed within 
%a command corresponds to a local computation ($\lambda$), such as executing a 
%non-transactional primitive command or some housekeeping activity, or to an interaction with 
%the database ($\delta$), that is executing a transaction. 
Where 
%$\mathcal{O}$ is a possibly empty set of operations, and 
$\ET$ is an execution test, i.e. a condition that must be satisfied in 
order for a client to execute a transaction safely. 
Execution Tests are introduced formally later in this Section, while we 
give different examples of execution tests in Section \ref{sec:cmexamples}. 
There we also note that by tweaking the execution test used by the 
semantics, we capture different consistency models of 
key-value stores.
%\ac{Introducing labelled transitions was necessary to remove complications later on when dealing 
%with the parallel composition of threads. More details when discussing the rule.}

The main rule in the operational semantics of commands is the one corresponding 
to the execution of a transaction, i.e. $\cmd = [\trans]$. For this rule, we must specify the following: 
\begin{itemize}
\item How the execution of the transaction $[\trans]$ affects a MKVS, and 
\item How the view of the client executing the command is changed, after the transaction 
has been executed. 
\end{itemize}

Let us first discuss how the MKVS is changed when executing a transaction. 
Recall that a MKVS $\hh$ and the view $V$ determine a snapshot 
via the function $\snapshot$. By executing the transaction $[\trans]$ using 
such a snapshot as its initial state, we obtain the fingerprint of the transaction 
as a set of operations $\mathcal{O}$. We then choose a fresh transaction identifier 
$\tsid$ (i.e. that does not appear in $\hh$ already) 
that we associate with the execution of $[\trans]$. 
Each read operation $\RD\;\key{k}:n$, 
refers to the version $\nu$ to which the view $V$ pointed before the transaction $[\trans]$ 
was executed: when we update the history heap, we must update the set of read transactions of 
such a version $\RTx(\nu)$ to include the transaction $\tsid$. For write 
operations of the form $\WR\;\key{k}:m$, we create a new version 
$\nu = (m, \tsid, \emptyset)$ and we append it at the tail of $\hh(\key{k})$.

\begin{definition}
The function $\HHupdate_{\tsid}$ is defined as follows:
\[
\begin{array}{lll}
\HHupdate_{\tsid}(\hh, V, \{\RD\;\key{k}: n\}) &=& 
\mathsf{let}\; (m, \tsid', \T) = \snapshot(\hh, V)(\key{k}) \; \mathsf{in} \; \\
&&
\hh\Big[ \key{k} \mapsto  \Big( \hh(\key{k})  [ V(\key{k}) \mapsto (m, \tsid', \T \cup \{ \tsid \} ) ] \Big) \Big]
%\lambda [k].\begin{cases}
%\langle v_0, T_{0}, \T_{0} \rangle \cdots \langle v_i, T_{i}, \T_{i} \cup \{\tsid\} \rangle \cdots \langle v_{n_{k}}, T_{n_{k}}, \T_{n_{k}} \rangle\\
%\hspace{5pt} \text{if } [k] = [n] \wedge V([k]) = i &\\
%\hh([k]) \hspace{5pt} \text{otherwise}
%\end{cases}
\\
\mathsf{HHupdate}_{\tsid}(\hh, \_, \{\WR\; \key{k}: n\}) &=& 
\hh\Big[ [n] \mapsto ( \hh(\key{k}) \cdot \langle n, \tsid, \emptyset \rangle) \Big]\\
\HHupdate_{\tsid}(\hh, V, \mathcal{O}_1 \cup \mathcal{O}_2) &=& 
\HHupdate_{\tsid}(\mathsf{HHupdate}_{\tsid}(\hh, V, \mathcal{O}_1), V, \mathcal{O}_2)
\end{array}
\]
\end{definition}

\begin{lemma}
\label{lem:hhupdate.welldefined}
The function $\HHupdate_{\tsid}$ is well-defined over well-formed MKVS, sets of operations and 
views. If $\hh$ is a well-formed history heap, $V$ is a well-formed view with respect 
to $\hh$, $\mathcal{O}$ is a well-formed set of operations and $\tsid$ does not 
appear in $\hh$, then $\HHupdate_{\tsid}(\hh, \mathcal{O}, V)$ is uniquely determined 
and equivalent to a well-formed MKVS.
\end{lemma}

\ac{The definition above should be well-formed, but we must prove this.}
Next, we discuss how the view of a command is changed after executing 
a transaction. In this case, we only update the view of the locations that 
have been written by a transaction to be up-to-date with the version 
installed by the transaction that has been executed. 

\begin{definition}
The function $\Vupdate$ is defined below: 
\[
\begin{array}{lll}
\Vupdate(\hh, V, \{\RD\;\key{k}: n\}) &=& V\\
\Vupdate(\hh, V, \{\WR\;\key{k}: n \}) &=& V[ \key{k} \mapsto ( \lvert \hh(\key{k}) \rvert + 1)]\\
\Vupdate(\hh, V, \mathcal{O}_1 \cup \mathcal{O}_2) &=& \Vupdate(\hh, \Vupdate(\hh, V, \mathcal{O}_1), \mathcal{O}_2)
\end{array}
\]
\end{definition}

\begin{lemma}
The function $\Vupdate$ is well-defined. Furthermore, let $\hh, V, \mathcal{O}$ and $\tsid$ 
be a well-formed MKVS, view, set of operations, and a transction identifier that does not appear 
in $\hh$, respectively. Then $\Vupdate(\hh, V, \mathcal{O})$ is well-formed with respect 
to $\HHupdate_{\tsid}(\hh, V, \mathcal{O})$.
\end{lemma}

\ac{The paragraph below should probably go when discussing the rules of the semantics}
Note that the way in which MKVSs and views are updated ensure the following: 
$\bullet$ a client always reads its own preceding writes; 
$\bullet$ clients always read from an increasingly up-to-date state of the database; 
$\bullet$ the order in which clients update a key $\key{k}$ is consistent with the 
order of the versions for such keys in the MKVS; 
$\bullet$ writes take place after reads on which they depend. 
\ac{(need to check again what this exactly means, but I'm working from home and I cannot access the 
session guarantee paper)}
Assuming that commands executed by clients represent are wrapped within a single session,
these four bullets correspond to the strong session guarantees introduced by Terry et al. 
in \cite{sessionguarantees}. 


%\ac{Note that according to this definition the $\mathsf{ViewUpdate}$ function may push the view of a 
%location out of the boundaries of the history heap by $1$. This happens when a new version is written 
%for some location $[n]$. This is totally fine, as the new view will be paired with a history heap which 
%carries a new version for location $[n]$, and the view is within the boundaries of such a history heap.}


%\ac{It seems that introducing history heaps and sessions here may be avoided. 
%In fact, the semantics of commands should be just a bridge between transaction 
%code and multi-threaded programs.}
%For commands, judgements take the form 
%\[
%\heap \vdash \langle \thdstack, \cmd \rangle \rightarrow \langle \thdstack', \mathcal{O}', \cmd' \rangle.
%\] 
%The last notion that we need to introduce, before giving the semantics of commands, 
%is the one of \textbf{Consistency Model Specification.} 
%A consistency model specification $CM$ consists of a set of quadruples 
Finally, we introduce the notion of \emph{execution tests}, that will be used 
in the semantics to determine whether a client can safely execute a transaction. 
\begin{definition}
\label{def:executiontests}
An execution test is a set $\ET$ of tuples of the form
$(\hh, V, \mathcal{O}, V')$.
\end{definition}
Given an execution test $\ET$ and a tuple $(\hh, V, \mathcal{O}, V') \in \ET$, 
we often write $\ET \vdash (\hh, V) \triangleright \mathcal{O} : V'$. 
Roughly speaking $\ET \vdash (\hh, V) \triangleright \mathcal{O}: V'$ means 
that, under the execution test $\ET$, in the MKVS $\hh$ a client with view 
$V$ can safely commit a transaction with fingerprint $\mathcal{O}$, and 
push its view to $V'$.
%, where 
%\begin{itemize}
%\item $\hh$ is a history heap, corresponding to a state of the database
%\item $V$ is the view of the history heap of the thread that wants to execute a 
%transaction, 
%\item $\mathcal{O}$ is the fingerprint of the transaction to be executed.
%\item $V'$ is the view of the thread immediately after executing the transaction, 
%and it is such that $\mathsf{UpdateView}(\hh, V, \mathcal{O}) \sqsubseteq V'$.
%\end{itemize}
%We often write $(\hh, V) \triangleright_{CM} \mathcal{O} : V'$ in lieu 
%of $(\hh, V, \mathcal{O}, V') \in CM$.
%%Therefore, tuples of the form $(\hh, V, \mathcal{O}) \in CM$ describe 
%%which operations a thread is allowed to execute in a single transaction, without conflicting 
%%with other threads. We often write $(\hh, V, \mathcal{V}) \triangleright_{CM} \mathcal{O}$ 
%%in lieu of $(\hh, V, \mathcal{V}, \mathcal{O}) \in CM$.

The rules of the operational semantics of commands are given in Figure \ref{fig:opsem.cmd}.
The main rule for executing commands is the one that models the execution of one transaction. 
In the rule below we compare views according to a partial order $\sqsubseteq$, which 
is defined to be the point-wise comparison of values of views at single locations: 
$V_1 \sqsubseteq V_2 \triangleq \forall \key{k} \in \Addr. V_1(\key{k}) \leq V_2(\key{k})$.
%In the rule below, ignore for the moment the side condition $\langle \hh, \{V\} \leadsto \langle \hh', \{V'\} \rangle$, 
%which we will explain when we introduce consistency models in the next section.
%\ac{The side-condition concerning weak consistency models 
%has been moved to the semantics of programs, in the rule where we 
%lift the semantics of commands. In any case, this is going to change in the future 
%because we agreed to remove thread identifiers.}

\begin{figure}
\begin{tabular}{|@{}cc@{}|}
%\[
%\infer[{\scriptstyle(Tx-exec)}]{\heap \vdash \langle \thdstack, [\trans].\cmd \rangle \rightarrow \langle \thdstack[\retvar \mapsto v], \mathcal{O}, \cmd \rangle}
%{\thdstack \vdash \langle \txstack_{0}, \heap, \emptyset, \trans \rangle \rightarrow^{\ast} \langle \txstack, \_, \mathcal{O}, \nil \rangle 
%\qquad \txstack(\retvar) = v}
%\]
\hline
\multicolumn{2}{|@{}c@{}|}{
$
\infer[{\scriptstyle(C-Tx)}]{\langle \hh, \thdstack, V, [\trans] \rangle \rightarrow_{\ET} \langle \HHupdate_{\tsid}(\hh, V', \mathcal{O}), \thdstack', V'', \nil \rangle}
{\begin{array}{c}
V \sqsubseteq V' \qquad 
\h = \snapshot(\hh, V') \qquad
\langle \heap, \thdstack, \emptyset, \trans \rangle \rightarrow^{\ast} \langle \_, \thdstack', \mathcal{O}, \nil \rangle \\
\qquad \Vupdate(\hh, V', \mathcal{O}) \sqsubseteq V'' \qquad \ET \vdash (\hh, V') \triangleright \mathcal{O} : V'' \qquad 
\tsid \text{ fresh in } \hh \\
%(\hh, V) \leadsto_{CM} (\hh', V') \qquad \hh\\
%\HHupdate_{\tsid}(\hh, V', \mathcal{O}) = \hh' 
%\qquad 
%\thdstack[\retvar \mapsto \txstack(\retvar)] = \thdstack'
\end{array}
}
$
}\\[8pt]
%\ac{Condition on thread stack should go away once the transaction stack is ditched.}
%\ac{Check that $V'$ is well-formed with respect to $\hh'$ is missing from the rule above. 
%Also, for the moment I am going with the possibility of having conflicts in views as long as 
%transactions cannot be executed. My catch here is that there are cases where whether 
%a view is conflicting depends on the code of the transaction to be executed (i.e. write-conflict 
%detection), so conflicting views cannot be avoided without losing completeness of the semantics). 
%The rule below allows for views to be pushed to the right, so as to resolve conflicts.}
%
%%We also introduce a rule that allows to update the view of the thread executing a command. 
%%We say that the view $V$ is dominated by $V'$, written $V \sqsubseteq V'$, if for any 
%%location $[n]$ we have that $V([n]) \leq V'([n])$. Because updating a view of a thread 
%%does not result in an interaction with the database (i.e. no locations are read or written), 
%%the transition is labelled with the empty fingerprint $\emptyset$.
%%\[
%%\infer[{\scriptstyle{(C-View-Update)}}]
%%{\langle \hh, \thdstack, V, \cmd \rangle \xrightarrow{\emptyset} \langle \hh, \thdstack, V', \cmd \rangle }
%%{ V \sqsubseteq V'}
%%\]
%\ac{The rule for shifting views to the right is now gone, and embedded into the rule for executing transactions}
%
%The other rules of the operational semantics are standard: 
\multicolumn{2}{|@{}c@{}|}{
$
\infer[{\scriptstyle{(prim-c)}}]
{\langle \hh, \thdstack, V, \primc \rangle \rightarrow_{\ET} \langle \hh, \thdstack', V, \nil \rangle}
{\thdstack \rightsquigarrow_c \thdstack'} 
$
}\\[8pt]
$
\infer[{\scriptstyle{(C-Seq-T)}}]
{\langle \hh, \thdstack, V, \cmd_1 ; \cmd_2 \rangle \rightarrow_{\ET} \langle \hh', \thdstack', V', \cmd_1' ; \cmd_2 \rangle}
{\langle \hh, \thdstack, V, \cmd_1 \rangle \rightarrow_{\ET} \langle \hh', \thdstack', V', \cmd_1' \rangle} 
$
&
$
\infer[{\scriptstyle{(C-Seq-nil)}}]
{\langle \hh, \thdstack, V, \nil ; \cmd_2 \rangle \rightarrow_{\ET} \langle \hh, \thdstack, V, \cmd_2 \rangle}
{} 
$
\\[8pt]
$
\infer[{\scriptstyle{(C-Choice-L)}}]
{\langle \hh, \thdstack, V, \cmd_1 + \cmd_2 \rangle \rightarrow_{\ET} \langle \hh, \thdstack, V, \cmd_1 \rangle}
{} 
$
&
$
\infer[{\scriptstyle{(C-Choice-R)}}]
{\langle \hh, \thdstack, V, \cmd_1 + \cmd_2 \rangle \rightarrow_{\ET} \langle \hh, \thdstack, V, \cmd_2 \rangle}
{} 
$
\\[8pt]
\multicolumn{2}{|@{}c@{}|}{
$
\infer[{\scriptstyle{(C-star)}}]
{\langle \hh, \thdstack, V, \cmd^{\ast} \rangle \rightarrow \langle \hh, \thdstack, V, \nil + (\cmd ; \cmd^{\ast}) \rangle}
{} 
$
}\\
\hline
\end{tabular}
\caption{Operational Semantics of Commands.}
\label{fig:opsem.cmd}
\end{figure}
%\[
%\infer[{\scriptstyle{(prim-c)}}]
%{\heap \vdash \langle \thdstack, \primc.\cmd \rangle \rightarrow \langle \thdstack', \emptyset, \Cmd \rangle}
%{\thdstack \rightsquigarrow_c \thdstack'} 
%\]
%
%\[
%\infer[{\scriptstyle{(C-Choice-L)}}]
%{\heap \vdash \langle \thdstack, \cmd_1 + \cmd_2 \rangle \rightarrow \langle \thdstack, \emptyset, \cmd_1 \rangle}
%{} 
%\]
%
%\[
%\infer[{\scriptstyle{(C-Choice-R)}}]
%{\heap \vdash \langle \thdstack, \cmd_1 + \cmd_2 \rangle \rightarrow \langle \thdstack, \emptyset, \cmd_2 \rangle}
%{} 
%\]
%
%\[\infer[{\scriptstyle{(C-Fix)}}]
%{\heap \vdash \langle \thdstack, \mu X.\cmd \rangle \rightarrow \langle \thdstack, \emptyset, \{\mu X.\cmd/X\}\cmd \rangle}
%{} 
%\]

%\ac{I really don't like this style for expressing the rules of the operational semantics. 
%Intuitively we may want the LHS and RHS of judgements to be the same, 
%as it is standard. However, this means that we need to carry around a lot of redundant 
%information, for example heap states.}

\paragraph{Semantics of Programs}
\label{sec:semantics.programs}
%We want a semantics of programs where transactions are 
%executed atomically, in an interleaving fashion, while still capturing non-serialisable 
%behaviours. We also want our operational semantics to be parametric in the definition of 
%a consistency model. 

%In this sense, a consistency model specification is the set of all the possible transitions that 
%are allowed by the semantics. Formally, a consistency model specification $CM$ is 
%a set of quadruples of the form $(\hh, \mathcal{V}, \hh', \mathcal{V}')$, 
%where $\mathcal{V}, \mathcal{V}'$ are non-empty, finite multi-sets of views,
%and we often write $(\hh, \mathcal{V}) \leadsto_{CM} (\hh, \mathcal{V}')$ 
%in lieu of $(\hh, \mathcal{V}, \hh', \mathcal{V}') \in CM$. 
\ac{
I changed (again) the definition of consistency models. I'm leaving the old 
version in the comment-box for future reference, though it is not clear 
whether the definition below is expressive enough to capture some consistency models (among 
others, snapshot isolation.)

In this sense, a consistency model specification $CM$ consists of a set of quadruples 
$(\hh, V, \mathcal{V}, \mathcal{O})$, where 
\begin{itemize}
\item $\hh$ is a history heap, corresponding to a state of the database
\item $V$ is the view of the history heap of the thread that wants to execute a 
transaction, 
\item $\mathcal{V}$ is the multi-set of views of the external environment (i.e. other 
threads that may be interacting with the database), 
\item $\mathcal{O}$ is the fingerprint of the transaction to be executed.
\end{itemize}

%\ac{I start to believe that calling this \emph{consistency model specification} is 
%misleading. In fact, a consistency model should only concern the 
%history-heap, and it should be just a set of history heaps (as much as for dependency graphs, 
%consistency models are just sets of dependency graphs. Crooks and Alvisi call similar 
%structures in their paper \emph{commit tests}, and maybe I should follow the same terminology.)}
Therefore, tuples of the form $(\hh, V, \mathcal{V}, \mathcal{O}) \in CM$ describe 
which operations a thread is allowed to execute in a single transaction, without conflicting 
with other threads. We often write $(\hh, V, \mathcal{V}) \triangleright_{CM} \mathcal{O}$ 
in lieu of $(\hh, V, \mathcal{V}, \mathcal{O}) \in CM$. }
%\ac{One thing that was not clear from the discussion I had with Philippa and Azalea - 
%mainly because it was stuck in my head as an intuition, but I could not think of it during 
%the chat we had - is that whether a set of views is consistent, with respect to some history 
%heap $\hh$, may depend on the set of operations that may 
%be performed in a single transaction. Therefore, we cannot ensure at compile time 
%that a configuration is always going to be consistent. One example is write-conflict detection (see the formal definition 
%later on), where we require that a transaction may write to location $[n]$ only if the view for such a 
%location is up-to-date (i.e. it points to the last available version for $[n]$). This point should now be 
%more clear in the new style I adopted for specifying consistency models, where the fingerprint of a 
%transaction is explicit.}
%\ac{Following a second discussion with Azalea, I'm okay for removing Rule (C-view-update), 
%and to change rule (Tx-exec) to update the view of a thread before and after a transaction execution.
%Though even in this scenario, there may be cases in which a thread ends-up having an inconsistent 
%view, with respect to the set of operations to be executed next.}
%\ac{Had to switch to multi-sets, though I'm looking for alternatives.}

%In this sense, a consistency model specification $CM$ consists of a set of quadruples 
%$(\hh, V, \mathcal{O}, V')$, where 
%\begin{enumerate}
%\item $\hh$ is a history heap, corresponding to a state of the database
%\item $V$ is the view over the history heap of the thread that wants to 
%execute a transaction, 
%\item $\mathcal{O}$ is the fingerprint of the transaction to be executed,
%\item $V'$ is the view over the history heap of the thread, \textbf{immediately after} 
%executing a transaction.
%\end{enumerate}
%\ac{This notion will require to change the rule for executing transactions in 
%the operational semantics.}
%Given a consistency model specification $CM$, we often write 
%$(\hh, V) \triangleright_{CM} \mathcal{O} : V'$ in lieu of
%$(\hh, V, \mathcal{O}, V') \in CM$.

%We place the following well-formedness constraints on specifications 
%of consistency models. We say that $CM$ is well-formed if: 
%\begin{enumerate}
%\item[Views can be pushed] for any $\hh, \mathcal{V}, V, V'$ such that 
%$V \sqsubseteq V'$, then $(\hh, \mathcal{V} \cup \{V\} \leadsto_{CM} \hh, \mathcal{V} \cup \{V'\})$. 
%This condition also implies that $CM$ must be reflexive, 
%\item[Transactions can be renamed] for any $\hh, \mathcal{V}, \hh', \mathcal{V}'$ and transaction $\tsid$ that does not appear 
%$\hh, \hh'$, $(\hh[\tsid \mapsto \tsid'], \mathcal{V}) \leadsto_{CM} (\hh'[\tsid \mapsto \tsid'], \mathcal{V}')$, 
%\item[Atomic Visibility], let us say that a configuration $(\hh, \{V\})$ enjoys atomic visibility 
%if, whenever $\hh([n])(i) = (\_, \tsid, \_)$ for some $i \leq V([n])$, then for any $[m]$ and 
%$j'$ such that $\hh([m])(j') = (\_, \tsid, \_)$, $j' \leq V([m])$. We say that $(\hh, \mathcal{V})$ 
%enjoys atomic visibility if $(\hh, \{V\})$ enjoys atomic visibility for all $V$ such that 
%$\mathcal{V} = \mathcal{V}' \cup \{V\}$. A consistency model specification enjoys atomic 
%visibility if and only if, whenever $(\hh, \mathcal{V}) \leadsto_{CM} (\hh', \mathcal{V}')$, 
%then $(\hh, \mathcal{V}$ and $(\hh, \mathcal{V}')$ enjoy atomic visibility.
%\end{enumerate}
%The well-formedness condition reflects the fact that internal computations of threads that do not 
%result in an interaction with the database (i.e. resolution of non-deterministic choices, unfolding 
%of fixed point operators, pushing views) must always be allowed by the consistency model. 
%Obviously, any consistency model $CM$ can be strengthened to a well-formed one $\overline{CM}$.
%
%\ac{Ok, this is completely screwed. Atomic visibility clashes with the closure constraint that 
%views can be always pushed. The reason why we have the closure constraint is because, when 
%we define the rule for the parallel composition, we check that an action performed by a single 
%thread does not conflict with the views of other threads, and we always want local computation 
%of threads to be allowed. 
%One possible solution to this problem would be to first constrain all configurations to 
%those that enjoy atomic visibility. A second solution would be 
%to just assume atomic visibility for those transitions $(\hh, \mathcal{V}) \leadsto_{CM} 
%(\hh', \mathcal{V}')$ where $\hh \neq \hh'$. Both solutions are patches to a flawed 
%definition, and we don't do patches. I think the best strategy here would be that 
%of distinguishing between local computations $(\lambda)$ and database interactions 
%$(\delta)$ in the semantics, and define a parallel rule that checks for transitions allowed 
%by the consistency model, only when a thread performs a $\delta$ action. I am first 
%typing up the semantics as it is now, and then I will make the appropriate changes. 
% Actually screw it, I'm going to change the semantics immediately.}
%
%Given two multi-sets of views $\mathcal{V}_1, \mathcal{V}_2$, 
%we write $\mathcal{V}_1 \Subset \mathcal{V}_2$, if there is 
%a one-to-one mapping from $\mathsf{push}: \mathcal{V}_1 \rightarrow \mathcal{V}_2$ 
%such that for any $V \in \mathcal{V}_1$, $V_1 \sqsubseteq \mathsf{push}(V_1)$.
%\ac{Again, notation should be re-adapted to multisets}.
%
%In general we require a consistency model specification to be reflexive, 
%and to be closed with respect to pushing the views in the 
%state of the system: if $(\hh, \{V_1, \cdots, V_n\}) \leadsto 
%(\hh, \{V'_1, \cdots, V'_{n})\}$, and 
%
%For a given consistency model $CM$, quadruple $(\hh, \mathcal{V}) 
%\leadsto_{CM} (\hh', \mathcal{V}')$,  and set of views $\mathcal{V}''$, 
%we write $(\hh, \mathcal{V}) \bowtie_{\mathcal{V}''} (\hh', \mathcal{V}')$ 
%if $(\hh, \mathcal{V} \cup \mathcal{V}'') \leadsto_{CM} (\hh', \mathcal{V}' \cup \mathcal{V}'')$.
The last step we take is that of defining the operational semantics of 
programs.
To this end, we associate a thread stack and view to each parallel component (or thread) of the program. 
In practice, we define an environment $\mathsf{Env}$ to be 
a partial mapping $\mathsf{Env} : \tidset \rightharpoonup (\thdstackset \times \mathsf{Views})$ 
\ac{Set of Views and thread identifiers never introduced before.} 
Given two environments, $\mathsf{Env}_1, \mathsf{Env}_2$, we let 
$\mathsf{Env_1} \uplus \mathsf{Env}_2$ to be defined if 
$\dom(\mathsf{Env}_1) \cap \dom(\mathsf{Env}_2) = \emptyset$, 
in which case we have 
\[
(\mathsf{Env}_1 \uplus \mathsf{Env}_2)(\tid) = \begin{cases}
\mathsf{Env}_1(\tid) & \impliedby \tid \in \dom(\mathsf{Env}_1)\\
\mathsf{Env}_2(\tid) & \impliedby \tid \in \dom(\mathsf{Env}_2)\\
\text{undefined} & \impliedby \text{otherwise}
\end{cases}
\]

%For a program $\prog$ we define its set of views inductively as follows: 
%\[
%\begin{array}{lcl}
%\mathsf{Views}(\nil) &=& \emptyset \\
%\mathsf{Views}(V: \cmd \Par \prog) &=& V \cup \mathsf{Views}(\prog)
%\end{array}
%\]

Judgements in the operational semantics take the form 
%\[
%\infer{\langle \hh, \mathsf{Env}, \prog \rangle \xrightarrow{(V, \mathcal{V}, \mathcal{O})}_{CM} \langle \hh', \mathsf{Env}', \prog' \rangle}{}
%\]

\[
\infer{\langle \hh, \mathsf{Env}, \prog \rangle \xrightarrow{CM} \langle \hh', \mathsf{Env}', \prog' \rangle}{}
\]
\ac{The changes made to consistency model specifications simplify the semantics \textbf{a lot}. The rule of parallel 
composition becomes standard, and the only rule that now needs to take the consistency model into account 
should be the execution of a transaction in the semantics of commands.}

The rules for the operational semantics of programs are standard. We have three rules, depicted in 
Figure \ref{fig:opsem.prog}. One rule lifts transitions
 of commands to single-threaded programs.  The remaining two rules model the parallel composition of programs in 
 a standard, interleaving fashion.
\begin{figure}
\begin{tabular}{|@{}c@{}|}
\hline
%\multicolumn{2}{|@{}c@{}|}{
$
\infer[{\scriptstyle(P-thd-exec)}]{\langle \hh, \mathsf{Env}, \tid: \cmd \rangle \rightarrow_{\ET} \langle \hh', \mathsf{Env}', \tid: \cmd' \rangle}
{
\begin{array}{c}
\mathsf{Env} = [\tid \mapsto (\sigma, V)] \qquad \langle \hh, \thdstack, V, \cmd \rangle \rightarrow_{\ET} \langle \hh', \thdstack', V', \cmd' \rangle 
\qquad \mathsf{Env}' = [\tid \mapsto (\sigma', V')]\\
%\mathcal{O} \neq \emptyset \implies (\hh, V, \emptyset) \triangleright_{CM} \mathcal{O}
\end{array}
}
$
%}
\\[8pt]
%We first define how to lift the semantics of commands to programs. This results 
%in the following rule: 
%\[
%\infer[{\scriptstyle(P-thd-exec)}]{\langle \hh, \mathsf{Env}, \tid: \cmd \rangle \xrightarrow{(V, \emptyset, \mathcal{O})}_{CM} \langle \hh', \mathsf{Env}', \tid: \cmd' \rangle}
%{
%\begin{array}{c}
%\mathsf{Env} = [\tid \mapsto (\sigma, V)] \qquad \langle \hh, \thdstack, V, \cmd \rangle \xrightarrow{\mathcal{O}} \langle \hh', \thdstack', V', \cmd' \rangle 
%\qquad \mathsf{Env}' = [\tid \mapsto (\sigma', V')]\\
%\mathcal{O} \neq \emptyset \implies (\hh, V, \emptyset) \triangleright_{CM} \mathcal{O}
%\end{array}
%}
%\]
%Note the side condition $\mathcal{O} \neq \emptyset \implies (\hh, V, \emptyset) \triangleright_{CM} \mathcal{O}$ in the rule above. 
%This is were consistency models come into play. This side condition states that if performing a computation 
%in a command resulted in an interaction with the database $(\mathcal{O} \neq \emptyset)$, then such a computation 
%should be performed only if it is consistent with the consistency model specification ($(\hh, V, \emptyset) \triangleright_{CM} \mathcal{O}$).
%\ac{An alternative would be that of placing a well-formedness condition on consistency models, 
%and require that $(\hh, V, \mathcal{V}) \triangleright_{CM} \emptyset$ for any $\hh, V, \mathcal{V}$. 
%I don't really have a preference.}
%
%
%Finally, we need to define how to compose programs together. 
%Here the main idea is that computations that are valid for a 
%program $\prog_1$ are not necessarily valid anymore in 
%a composite program of the form $\prog_1 \Par \prog_2$. 
%This is because the views of the threads that constitute $\prog_2$ 
%may be conflicting with the thread performing a computation step in 
%$\prog_1$. We will give some examples of consistency models 
%that exhibit this behaviour in the next section. 

%Formally, given a transition of the form $(\hh, \mathcal{V}_1) 
%\leadsto (\hh, \mathcal{V}_1')$, and a set of views $\mathcal{V}_2$, 
%we write
%$\mathcal{V}_2 \Vdash (\hh, \mathcal{V}_1) \leadsto_{CM} 
%(\hh', \mathcal{V}_1')$ if whenever $(\hh, \mathcal{V}_1) 
%\leadsto_{CM} (\hh', \mathcal{V}_1)'$, then  
%$(\hh, \mathcal{V}_1 \uplus \mathcal{V}_2) \leadsto_{CM} (\hh', \mathcal{V}_1' \uplus \mathcal{V}_2')$. 
%\ac{I am pretty sure that for how the semantics is defined the premise of the implication 
%is always going to be valid, so we may choose to ditch it.}
%The rule for the parallel composition of programs is defined below: 
%\[
%\infer[{\scriptstyle (P-par-L)}]
%{\langle \hh, \mathsf{Env}_1 \uplus \mathsf{Env}_2, \prog_1 \Par \prog_2 \rangle 
%\xrightarrow{(V, \mathcal{V}_1 \uplus \mathcal{V}_2, \mathcal{O})}_{CM} \langle \hh', \mathsf{Env}_1' \uplus \mathsf{Env}_2, 
%\prog_1' \Par \prog_2 \rangle }
%{ \begin{array}{c}
%\langle \hh, \mathsf{Env}_1, \prog_1 \rangle \xrightarrow{(V, \mathcal{V}_1, \mathcal{O})}_{CM} \langle \hh', \mathsf{Env}_1', \prog_1' \rangle
%\qquad (\mathsf{Env_1} \uplus \mathsf{Env}_2)\downarrow \\ 
%\mathcal{V}_2 = \mathsf{Views}(\mathsf{Env}_2) \qquad 
%\mathcal{O} \neq \emptyset \implies (\hh, V, \mathcal{V}_1 \uplus \mathcal{V}_2 \triangleright_{CM} \mathcal{O}) 
%%\leadsto_{CM} (\hh', \mathsf{Views}(\mathsf{Env}_1')
%\end{array}
%}
%\]
$
\infer[{\scriptstyle (P-par-L)}]
{\langle \hh, \mathsf{Env}_1 \uplus \mathsf{Env}_2, \prog_1 \Par \prog_2 \rangle 
\rightarrow_{\ET} \langle \hh', \mathsf{Env}_1' \uplus \mathsf{Env}_2, 
\prog_1' \Par \prog_2 \rangle }
{ \begin{array}{c}
\langle \hh, \mathsf{Env}_1, \prog_1 \rangle \rightarrow_{\ET} \langle \hh', \mathsf{Env}_1', \prog_1' \rangle
\qquad (\mathsf{Env_1} \uplus \mathsf{Env}_2)\downarrow
%\mathcal{V}_2 = \mathsf{Views}(\mathsf{Env}_2) \qquad 
%\mathcal{O} \neq \emptyset \implies (\hh, V, \mathcal{V}_1 \uplus \mathcal{V}_2 \triangleright_{CM} \mathcal{O}) 
%\leadsto_{CM} (\hh', \mathsf{Views}(\mathsf{Env}_1')
\end{array}
}
$
\\[8pt]
$
\infer[{\scriptstyle (P-par-R)}]
{\langle \hh, \mathsf{Env}_1 \uplus \mathsf{Env}_2, \prog_1 \Par \prog_2 \rangle 
\rightarrow_{\ET} \langle \hh', \mathsf{Env}_1' \uplus \mathsf{Env}_2, 
\prog_1' \Par \prog_2 \rangle }
{ \begin{array}{c}
\langle \hh, \mathsf{Env}_2, \prog_2 \rangle \rightarrow_{\ET} \langle \hh', \mathsf{Env}_2', \prog_2' \rangle
\qquad (\mathsf{Env_1} \uplus \mathsf{Env}_2)\downarrow
%\mathcal{V}_2 = \mathsf{Views}(\mathsf{Env}_2) \qquad 
%\mathcal{O} \neq \emptyset \implies (\hh, V, \mathcal{V}_1 \uplus \mathcal{V}_2 \triangleright_{CM} \mathcal{O}) 
%\leadsto_{CM} (\hh', \mathsf{Views}(\mathsf{Env}_1')
\end{array}
}
$\\[8pt]
\hline
\end{tabular}
\caption{Semantics of Programs.}
\label{fig:semantics.prog}
\end{figure}

%\ac{Probably I need a check to require that $\dom(\mathsf{Env}_2) = \mathsf{threads}(\prog_2)$, 
%where $\mathsf{threads}(\cdot)$ is the function that maps a program into its set of thread identifiers?}
%For programs, the main rule of the operational semantics is as follows: 
%\[
%\infer[{\scriptstyle{(C-Par)}}]
%{\langle \hh, \prog_1 \Par \prog_2 \rangle \xrightarrow{CM} \langle \hh', \prog_1' \Par \prog_2 \rangle }
%{\langle \hh, \prog_1 \rangle \xrightarrow{CM} \langle \hh', \prog_1' \rangle \qquad 
%(\hh, \mathsf{Views}(\prog_1)) \bowtie_{\mathsf{Views}(\prog_2)} (\hh', \mathsf{views}(\prog_1'))} 
%\]
%To do so, we introduce \emph{history heaps}.
%
%We assume countably infinite set of transaction identifiers $\TransID$, whose elements 
%are ranged over $\tsid$. Subsets of $\TransID$ are ranged over by $\T$. 
%A \emph{Version} is a triple 
%$(v, \tsid, \{\tsid_1, \tsid_2,\cdots\}) \in \Val \times \TransID \times 2^{\TransID}$. 
%The set of all versions is denoted by $\Versions$, and its elements are ranged over $\nu, \nu', \cdots$. 
%Intuitively, associating a location $[n]$ with the version $\nu = (v, \tsid, \{\tsid_1,\tsid_,\cdots\})$ means that the 
%value $v$ has been written for location $[n]$. The transaction that wrote version $\nu$ is $\tsid$, 
%and the version has been read by transactions $\{\tsid_1,\tsid_2,\cdots\}$. 
%Given a version $\nu := (v, \tsid, \T)$, we define $\valueof(\nu) = v$, $\WTx(\nu) := \tsid$, 
%and $\RTx(\nu) := \T$.
%A history heap is a function $\hh: \Addr \rightarrow \Versions^{\ast}$ that 
%maps each location to its list of versions. As usual, if 
%$\hh([n]) = \nu_1,\cdots, \nu_m$ for some location $[n]$, then for any 
%$i= 1,\cdots, m$ we let $\hh([n])(i) = \nu_i$. 
%
%Given a history heap $\hh$, we can extract several heaps 
%from it, by simply choosing for each location $[n]$ a version 
%contained in the list of versions available for $[n]$ in $\hh$, 
%namely $\hh([n])$. Formally, we define a \emph{snapshot} 
%to be a function $\snapshot: \Addr \rightarrow \mathbb{N}$; 
%given a history heap $\hh$ and a snapshot $\snapshot$, 
%we can construct the heap 
%\[
%\heap(\hh, \snapshot) = \lambda [n] \in \Addr. 
%\begin{cases}
%v_{\snapshot([n])} &\impliedby \hh([n]) = \langle v_0, \_ , \_ \rangle \cdots \langle v_{m}, \_, \_ \rangle \wedge m \geq \snapshot([n])\\
%\text{undefined} & \text{otherwise}
%\end{cases}
%\]
%
%We use history heaps to model the global, shared state of all threads in multi-threaded programs. 
%However, each thread will have a local view of the history heap, which is induced by the 
%snapshot of the history heap that it observes. 
%Formally, judgements in the operational semantics of programs take the form 
%\[
%\langle \hh, (\snapshot_1, \cdots, \snapshot_n), (\thdstack_1,\cdots,\thdstack_n) \cmd_1 \Par \cdots \Par \cmd_n), \rangle
%\rightarrow \langle \hh', (\snapshot'_1, \cdots, \snapshot'_{n}), (\thdstack_1' , \cdots, \thdstack_n'), (\cmd'_1 \Par \cdots \Par \cmd'_n) \rangle
%\]
%\ac{Note that here we are exploiting the fact that programs have a rigid structure, with 
%no creation of dynamic threads. Honestly, I never understood what all the fuzz about 
%having dynamic thread creation was, since it seems that whether we have static or dynamic 
%thread creation, is irrelevant to the discussions we had thus far.}
%
%The rules for the operational semantics of programs will be parametric in the specification 
%of a consistency model. The specification of a consistency model describes which change 
%of states are allowed by programs. I.e. the specification of a consistency model is a 
%set of quadruples $(\hh, \snapshot, \hh', \snapshot')$. Given a consistency model 
%specification $\mathsf{CM}$, we write $(\hh, \snapshot) \leadsto_{\mathsf{CM}} 
%(\hh', \snapshot')$ in lieu of $(\hh, \snapshot, \hh', \snapshot') \in \mathsf{CM}$.
%
%Making a command progress in a program may result in the former producing a set of operations, 
%or fingerprint, which contributes to the evolution of the history heap. 
%\[
%\begin{array}{lll}
%\mathsf{append}_{T}(\hh, \snapshot, \{\RD\;[n]: m\}) &=& 
%\lambda [k].\begin{cases}
%\langle v_0, T_{0}, \T_{0} \rangle \cdots \langle v_i, T_{i}, \T_{i} \cup \{T\} \rangle \cdots \langle v_{n_{k}}, T_{n_{k}}, \T_{n_{k}} \rangle\\
%\hspace{5pt} \text{if } [k] = [n] \wedge \snapshot([k]) = i &\\
%\hh([k]) \hspace{5pt} \text{otherwise}
%\end{cases}\\
%\mathsf{append}_{T}(\hh, \_, \{\WR\; [n]: m\}) &=& 
%\hh[ [n] \mapsto ( \hh([n]) \cdot \langle m, T, \emptyset \rangle) ]\\
%\mathsf{append}_{T}(\hh, \snapshot, \mathcal{O}_1 \cup \mathcal{O}_2) &=& 
%\mathsf{append}_{T}(\mathsf{append}_{T}(\hh, \snapshot, \mathcal{O}_1), \snapshot, \mathcal{O}_2)
%\end{array}
%\]
%Furthermore, if executing a command under snapshot $\snapshot$ results in producing the fingerprint $\mathcal{O}$, 
%then we must also update the snapshot of the thread executing the command by including the versions 
%written by $\mathcal{O}$; formally, we define the function 
%\[
%\begin{array}{lll}
%\mathsf{update}(\hh, \snapshot, \mathsf{RD}\;[n]: m) &=& \snapshot\\
%\mathsf{update}(\hh, \snapshot, \mathsf{WR}\;[n]: m) &=& \snapshot[ [n] \mapsto \lvert \hh([n]) \rvert -1 ]\\
%\mathsf{update}(\hh, \snapshot, \mathcal{O}_1 \cup \mathcal{O}_2) &=& \mathsf{update}(\hh, \mathsf{update}(\hh, \snapshot, \mathcal{O}_1), \mathcal{O}_2)
%\end{array}
%\]
%
%The operational semantics of programs includes two rules: one for advancing the snapshot in 
%a session, as long as the snapshot policy is satisfied, and another for progressing commands 
%that constitute the program. Below we use $\mathcal{S}$ to denote a tuple of snapshots, 
%and $\mathcal{S}(i)$ to denote the $i$-th component of such a tuple. Similarly, $\Sigma$ 
%denotes a tuple of thread stacks. In the rules below, we assume that the arity of such tuples matches 
%the one of program components.
%
%\[
%\infer[P-Exec]{
%\langle \hh, \mathcal{S}, \Sigma, \cmd_1 \Par \cdots \Par \cmd_i \Par \cdots \Par \cmd_{n} \rangle
%\xrightarrow{\mathsf{CM}} \langle \hh', 
%\mathcal{S}[i \mapsto \snapshot'], \Sigma[i \mapsto \thdstack'], \cmd_1 \Par \cdots \Par \cmd_i' \Par \cdots \Par \cmd'_n \rangle
%}
%{
%\begin{array}{l}
%h = \heap(\hh, \mathcal{S}(i)) \qquad
%h \vdash \langle \Sigma(i), \cmd_i \rangle  \rightarrow \langle \thdstack', \mathcal{O}, \cmd_i' \rangle \qquad 
%(\hh, \mathcal{S}) \leadsto_{\mathsf{CM}} (\hh', \mathcal{S}[i \mapsto \snapshot']) \\
%\hh' = \mathsf{append}_{T}(\hh, \mathcal{S}(i), \mathcal{O}) \qquad T \text{ does not appear in } \hh 
%\qquad \snapshot' = \mathsf{update}(\mathcal{S}(i), \mathcal{O})\\
%\end{array}
%}
%\]
%
%\[
%\infer[S-update]{
%\langle \hh, \mathcal{S}, \Sigma, \prog \rangle \xrightarrow{\mathsf{CM}} \langle \hh, \mathcal{S}[i \mapsto \snapshot], \Sigma, \prog \rangle
%}
%{
%\mathcal{S}(i) \sqsubseteq \snapshot
%}
%\]
%
%\section{Examples of Specifications of Consistency Models}
%
%
%\section{Comparing Different Specifications of Consistency Models}
%To compare different specifications of consistency models, we adopt 
%a black-box testing approach, similar in style to the one proposed by Hennessy 
%and de Nicola \cite{hdn84} for concurrent processes. 
%
%We assume that primitive commands contain a special element $\thick$, with empty state transformer. 
%We say that a program is successful, denoted $\mathsf{successful}(P)$, if it contains an unguarded occurrence of the $\thick$ command. 
%Formally, we define $\mathsf{successful}(P)$ inductively on the syntax of programs as follows: 
%\[
%\begin{array}{lll}
%\mathsf{successful}(\nil) &=& \ffalse\\
%\mathsf{successful}(\thick) &=& \ttrue\\
%\mathsf{successful}(c) &=& \ffalse \hspace{5pt} \text{ if } c \neq \thick\\
%\mathsf{successful}([\trans]) &=& \ffalse\\
%\mathsf{successful}(X) &=& \ffalse\\
%\mathsf{successful}(\cmd_1 + \cmd_2) &=& \mathsf{successful}(\cmd_1) \vee \mathsf{successful}(\cmd_2)\\
%\mathsf{successful}(\mu X.\cmd) &=& \ffalse\\
%\mathsf{successful}(\cmd \Par \prog) &=& \mathsf{successful}(\cmd) \vee \mathsf{successful}(\prog)
%\end{array}
%\]
%
%We say that a program $\prog$ may-pass under the consistency model specification $\CM$, 
%written $\prog \maypass\; \CM$, if there exists a computation fragment 
%\[ 
%\langle \hh_{0}, \mathcal{S}_0, \Sigma_0, \prog_0 \rangle \xrightarrow{\CM} \cdots \xrightarrow{\CM} \langle \hh_{n}, \mathcal{S}_n, \Sigma_n, \prog_n \rangle,
%\]
%such that $\hh_{0} = \lambda [m]. \langle 0, T_0, \emptyset \rangle$, $\mathcal{S}_0 = \lambda [m].0$, $\Sigma_0 = \langle \thdstack_0, \cdots, \thdstack_0$ 
%and $\thdstack_0 = \lambda x. 0$, $\prog_0 = \prog$, and $\mathsf{successful}(\prog_{n})$. 
%
%\begin{definition}
%Given two consistency model specifications $\CM_1, \CM_2$, we say that 
%$\CM_1$ is \emph{(weakly) stronger than} $\CM_2$, written $\CM_1 \sqsubseteq \CM_2$, if for all program $\prog$, 
%\[
%\CM_1 \maypass\; \prog \implies \CM_2 \maypass\;\prog
%\]
%\end{definition}
%\bibliographystyle{abbrv}
%\ac{This notion of equivalence is based on the observations made by clients, in contrast to other 
%notion of history equivalences found in the literature - conflict equivalence, history equivalence, view equivaence, $\cdots$, 
%which are way too fine-grained for our purposes.}
%\bibliography{bibliography2}

\subsection{Operational Semantics: Example} 
\label{sec:semantics.example}
To conclude our discussion on the operational semantics, 
we show in detail one possible computation of a program consisting 
of two transactions executing in parallel.  
The program $\prog_1$ that we consider is illustrated below: 
\[
    \begin{session}
        \begin{array}{@{}c || c@{}}
            \begin{transaction}
            		 \pmutate{\loc_x}{1};\\
            		 \pmutate{\loc_y}{1};
              \end{transaction} &
              \begin{transaction}
            		\pderef{\pvar{a}}{\loc_x};\\
            		\pderef{\pvar{b}}{\loc_y};\\
            		\pifs{\pvar{a}=1 \wedge \pvar{b}=0}\\
            			\;\;\;\;\passign{\retvar}{\Large \frownie{}}
            	    \}
             \end{transaction}
        \end{array}
    \end{session}
 \]
Note also that we omitted thread identifiers for commands in $\prog_1$. In general,  
we often write $\cmd_1 \Par \cdots \Par \cmd_n$ as a shorthand for $\tid_1: \cmd_1 \Par \cdots \Par
\tid_n: \cmd_n$. 

The program $\prog_1$ contains a special symbol ${\Large \frownie{}}$ which can be 
returned by the transaction of $\tid_2$. 
In practice, this can be an arbitrary fixed value that can be returned by a transaction. 
However, by using the symbol ${\Large \frownie{}}$ as the return value for the transaction, 
we want to emphasize the fact that the transaction exhibited some undesirable behaviour. In 
this case, the undesirable behaviour corresponds to the transaction on the right hand side 
observing only one of the updates that can be executed by the transaction on the left hand side. 

Although this behaviour clearly violates the constraints that transactions should be executed atomically, 
we show that if no restrictions are placed on the consistency model specification, 
it is possible to execute $\prog_1$ and reach a configuration where the transaction executed by 
$\tid_2$ returns ${\Large \frownie{}}$. To this end, let $CM$ be the most permissive 
consistency model, i.e. the one such that
% $(\hh, V, \mathcal{V}) \triangleright_{CM} \mathcal{O}$ for any 
%$\hh, V, \mathcal{V}, \mathcal{O}$. 
$(\hh, V) \triangleright_{CM} \mathcal{O} : V'$ for any $\hh, V, \mathcal{O}, V'$ 
such that $\mathsf{UpdateVies}(\hh, V, \mathcal{O}) \sqsubseteq V'$.
\ac{The condition on $V'$ is not really needed.}

\begin{figure}
\begin{center}
\begin{tabular}{|@{}c|c@{}|}
\hline
\begin{tikzpicture}[font=\large]

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) at (1,3) {$[\loc_x] \mapsto$};

\matrix(locxcells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locx.east) {
 {a} & $T_0$ \\
  {a} & $\emptyset$ \\
};
\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
%\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};

%Location y
\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
\matrix(locycells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locy.east) {
 {a} & $T_0$ \\
  {a} & $\emptyset$ \\
};
\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
%\node[version node, fit=(locycells-1-3) (locycells-2-3), fill=white, inner sep=0cm, font=\Large] (locy-v1) {$1$};

% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
 ([xshift=-3pt, yshift=20pt]locx-v0.north east) node (tid1start) {} -- 
% ([xshift=-2pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-2pt, yshift=5pt]locy-v0.north east) -- 
 ([xshift=-3pt, yshift=-5pt]locy-v0.south east);
 
 \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_1$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
 ([xshift=-16pt, yshift=5pt]locx-v0.north east) node (tid2start) {}-- 
% ([xshift=-8pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-8pt, yshift=5pt]locy-v0.north east) -- 
 ([xshift=-16pt, yshift=-5pt]locy-v0.south east) node {};
 
\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\tid_2$};

%Stack for threads tid_1 and tid_2

\draw[-, dashed] let 
   \p1 = ([xshift=0pt]locy.west),
   \p2 = ([yshift=-5pt]locycells.south),
   \p3 = ([xshift=10pt]locycells.east) in
   (\x1, \y2) -- (\x3, \y2);
   
\matrix(stacks) [
   matrix of nodes,
   anchor=north, 
   text=blue, 
   font=\normalsize, 
   row 1/.style = {text = blue}, 
   row 2/.style = {text = red}, 
   text width= 13mm ] 
   at ([xshift=-10pt,yshift=-8pt]locycells.south) {
   $\tid_1:$ & $\retvar = 0$\\
   $\tid_2:$ & $\retvar = 0$\\
   };
\end{pgfonlayer}
\end{tikzpicture} 
&
\begin{tikzpicture}[font=\large]

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) at (1,3) {$[\loc_x] \mapsto$};

\matrix(locxcells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locx.east) {
 {a} & $T_0$ &{a} & $T_1$\\
  {a} & $\emptyset$ & {a} & $\emptyset$ \\
};
\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};

%Location y
\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
\matrix(locycells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locy.east) {
 {a} & $T_0$ & {a} & $T_1$\\
  {a} & $\emptyset$ & {a} & $\emptyset$ \\
};
\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
\node[version node, fit=(locycells-1-3) (locycells-2-3), fill=white, inner sep=0cm, font=\Large] (locy-v1) {$1$};

% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
 ([xshift=-3pt, yshift=20pt]locx-v1.north east) node (tid1start) {} -- 
% ([xshift=-2pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-2pt, yshift=5pt]locy-v0.north east) -- 
 ([xshift=-3pt, yshift=-5pt]locy-v1.south east);
 
 \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_1$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
 ([xshift=-16pt, yshift=5pt]locx-v0.north east) node (tid2start) {}-- 
% ([xshift=-8pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-8pt, yshift=5pt]locy-v0.north east) -- 
 ([xshift=-16pt, yshift=-5pt]locy-v0.south east) node {};
 
\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\tid_2$};

%Stack for threads tid_1 and tid_2

\draw[-, dashed] let 
   \p1 = ([xshift=0pt]locy.west),
   \p2 = ([yshift=-5pt]locycells.south),
   \p3 = ([xshift=10pt]locycells.east) in
   (\x1, \y2) -- (\x3, \y2);
   
\matrix(stacks) [
   matrix of nodes,
   anchor=north, 
   text=blue, 
   font=\normalsize, 
   row 1/.style = {text = blue}, 
   row 2/.style = {text = red}, 
   text width= 13mm ] 
   at ([xshift=-10pt,yshift=-8pt]locycells.south) {
   $\tid_1:$ & $\retvar = 0$\\
   $\tid_2:$ & $\retvar = 0$\\
   };
\end{pgfonlayer}
\end{tikzpicture}
\\
{\small (a) } & {\small (b)}\\
\hline
\begin{tikzpicture}[font=\large]

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) at (1,3) {$[\loc_x] \mapsto$};

\matrix(locxcells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locx.east) {
 {a} & $T_0$ &{a} & $T_1$\\
  {a} & $\emptyset$ & {a} & $\{T_2\}$ \\
};
\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};

%Location y
\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
\matrix(locycells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locy.east) {
 {a} & $T_0$ & {a} & $T_1$\\
  {a} & $\{T_2\}$ & {a} & $\emptyset$ \\
};
\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
\node[version node, fit=(locycells-1-3) (locycells-2-3), fill=white, inner sep=0cm, font=\Large] (locy-v1) {$1$};

% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
 ([xshift=-3pt, yshift=20pt]locx-v1.north east) node (tid1start) {} -- 
% ([xshift=-2pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-2pt, yshift=5pt]locy-v0.north east) -- 
 ([xshift=-3pt, yshift=-5pt]locy-v1.south east);
 
 \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_1$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
 ([xshift=-16pt, yshift=5pt]locx-v1.north east) node (tid2start) {}-- 
 ([xshift=-16pt, yshift=-5pt]locx-v1.south east) --
 ([xshift=-16pt, yshift=5pt]locy-v0.north east) -- 
 ([xshift=-16pt, yshift=-5pt]locy-v0.south east) node {};
 
\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\tid_2$};

%Stack for threads tid_1 and tid_2

\draw[-, dashed] let 
   \p1 = ([xshift=0pt]locy.west),
   \p2 = ([yshift=-5pt]locycells.south),
   \p3 = ([xshift=10pt]locycells.east) in
   (\x1, \y2) -- (\x3, \y2);
   
\matrix(stacks) [
   matrix of nodes,
   anchor=north, 
   text=blue, 
   font=\normalsize, 
   row 1/.style = {text = blue}, 
   row 2/.style = {text = red}, 
   text width= 13mm ] 
   at ([xshift=-10pt,yshift=-8pt]locycells.south) {
   $\tid_1:$ & $\retvar = 0$\\
   $\tid_2:$ & $\retvar = 0$\\
   };
\end{pgfonlayer}
\end{tikzpicture}
&
\begin{tikzpicture}[font=\large]

\begin{pgfonlayer}{foreground}
%Uncomment line below for help lines
%\draw[help lines] grid(5,4);

%Location x
\node(locx) at (1,3) {$[\loc_x] \mapsto$};

\matrix(locxcells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locx.east) {
 {a} & $T_0$ &{a} & $T_1$\\
  {a} & $\emptyset$ & {a} & $\emptyset$ \\
};
\node[version node, fit=(locxcells-1-1) (locxcells-2-1), fill=white, inner sep= 0cm, font=\Large] (locx-v0) {$0$};
\node[version node, fit=(locxcells-1-3) (locxcells-2-3), fill=white, inner sep=0cm, font=\Large] (locx-v1) {$1$};

%Location y
\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
\matrix(locycells) [version list, text width=7mm, anchor=west]
   at ([xshift=10pt]locy.east) {
 {a} & $T_0$ & {a} & $T_1$\\
  {a} & $\emptyset$ & {a} & $\emptyset$ \\
};
\node[version node, fit=(locycells-1-1) (locycells-2-1), fill=white, inner sep= 0cm, font=\Large] (locy-v0) {$0$};
\node[version node, fit=(locycells-1-3) (locycells-2-3), fill=white, inner sep=0cm, font=\Large] (locy-v1) {$1$};

% \draw[-, red, very thick, rounded corners] ([xshift=-5pt, yshift=5pt]locx-v1.north east) |- 
%  ($([xshift=-5pt,yshift=-5pt]locx-v1.south east)!.5!([xshift=-5pt, yshift=5pt]locy-v0.north east)$) -| ([xshift=-5pt, yshift=5pt]locy-v0.south east);

%blue view - I should  check whether I can use pgfkeys to just declare the list of locations, and then add the view automatically.
\draw[-, blue, very thick, rounded corners=10pt]
 ([xshift=-3pt, yshift=20pt]locx-v1.north east) node (tid1start) {} -- 
% ([xshift=-2pt, yshift=-5pt]locx-v0.south east) --
% ([xshift=-2pt, yshift=5pt]locy-v0.north east) -- 
 ([xshift=-3pt, yshift=-5pt]locy-v1.south east);
 
 \path (tid1start) node[anchor=south, rectangle, fill=blue!20, draw=blue, font=\small, inner sep=1pt] {$\tid_1$};

%red view
\draw[-, red, very thick, rounded corners = 10pt]
 ([xshift=-16pt, yshift=5pt]locx-v1.north east) node (tid2start) {}-- 
 ([xshift=-16pt, yshift=-5pt]locx-v1.south east) --
 ([xshift=-16pt, yshift=5pt]locy-v0.north east) -- 
 ([xshift=-16pt, yshift=-5pt]locy-v0.south east) node {};
 
\path (tid2start) node[anchor=south, rectangle, fill=red!20, draw=red, font=\small, inner sep=1pt] {$\tid_2$};

%Stack for threads tid_1 and tid_2

\draw[-, dashed] let 
   \p1 = ([xshift=0pt]locy.west),
   \p2 = ([yshift=-5pt]locycells.south),
   \p3 = ([xshift=10pt]locycells.east) in
   (\x1, \y2) -- (\x3, \y2);
   
\matrix(stacks) [
   matrix of nodes,
   anchor=north, 
   text=blue, 
   font=\normalsize, 
   row 1/.style = {text = blue}, 
   row 2/.style = {text = red}, 
   text width= 15mm ] 
   at ([xshift=-10pt,yshift=-8pt]locycells.south) {
   $\tid_1:$ & $\retvar = 0$\\
   $\tid_2:$ & $\retvar = {\Large \frownie}$\\
   };
   \end{pgfonlayer}
 \end{tikzpicture}
\\
{\small(c)} & {\small(d)}\\
\hline
\end{tabular}
\end{center}
\caption{Graphical Representation of configurations 
obtained through the execution of $\prog_1$.}
\label{fig:opsem.example}
\end{figure}

Before showing the computation of $\prog_1$ that leads to the transaction of 
$\tid_2$ to return ${\Large \frownie{}}$, we need to introduce some 
definitions and  notation.
The initial configuration in which $\prog_1$ is executed is the one in which 
each location has an initial version written by some initialisation transaction $\tsid_0$, 
the view of each thread points to the initial version of each location, and all the  
thread stacks are initialised to $0$. Assuming that the only key in the database 
are $[\loc_x], [\loc_y]$, and the only variable in the thread stack is $\retvar$, 
the initial configuration is then given by $\mathcal{C}_0 = (\hh_{0}, \mathsf{Env}_0)$, 
where $\hh_{0}([\loc_{x}) = \hh_{0}([\loc_y]) =  (0, \tsid_0, \emptyset)$,  
$\mathsf{Env}_0(\tid_1) = \mathsf{Env}_0(\tid_2) = ([\retvar \mapsto 0], V_0)$, 
and $V_0([\loc_{x}]) = V_0([\loc_{y}]) = 0$. Here and in the following, we prefer 
to adopt a more graphical notation for configurations. For example, the initial configuration 
defined is represented graphically in Figure \ref{fig:opsem.example}(a). 
%
%\begin{center}
%\begin{tikzpicture}[font=\large]
%\node (locx) {$[\loc_x] \mapsto$};
%\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
%\path (locx.east) + (0.5,0)  node (locx0) {$0$};
%\path (locx0.north east) + (0.4,0) node[font=\small] (locx0ws) {$\tsid_0$};
%\path (locx0.south east) + (0.4,0) node[font=\small] (locx0rs) {$\emptyset$};
%\path (locy.east) + (0.5,0)  node (locy0) {$0$};
%\path (locy0.north east) + (0.4,0) node[font=\small] (locy0ws) {$\tsid_0$};
%\path (locy0.south east) + (0.4,0) node[font=\small] (locy0rs) {$\emptyset$};
%
%\path (locy.south west) + (-0.7, -0.6) node (dashlinestart) {};
%\path (dashlinestart.center) + (5, 0) node (dashlineend) {};
%
%\path(locy0.south) + (0,-1) node[font = \small, text=red] (tid1ret) {$\tid_1: \retvar = 0$};
%\path(tid1ret.south) + (0,-0.3) node[font= \small, text=blue] (tid2ret) {$\tid_2: \retvar = 0$};
%
%\begin{pgfonlayer}{background}
%
%\path[-, dashed, thick] (dashlinestart.center) edge (dashlineend.center);
%
%\node[hheapcell, fit=(locx0) (locx0ws) (locx0rs)] (locx0cell) {};
%\node[hheapcell, fit=(locy0) (locy0ws) (locy0rs)] (locy0cell) {};
%
%\path[-]
%(locx0cell.north) edge (locx0cell.south)
%(locx0cell.center) edge (locx0cell.east)
%(locy0cell.north) edge (locy0cell.south) 
%(locy0cell.center) edge (locy0cell.east);
%
%\path(locx0cell.north) + (-0.5, 0.2) node(v1beforex) {};
%\path(locx0cell.south) + (-0.5, -0.1) node(v1afterx) {};
%\path(locy0cell.north) + (-0.5, 0.1) node(v1beforey) {};
%\path(locy0cell.south) + (-0.5, -0.2) node(v1aftery) {};
%\path(v1beforex.center) + (-0.25,0.15) node[font=\normalsize, text=red] (t1) {$\tid_1$};
%
%\path[-, draw=red!80, very thick]
% (v1beforex.center) edge (v1afterx.center)
% (v1afterx.center) edge (v1beforey.center)
% (v1beforey.center) edge (v1aftery.center);
% 
% \path(locx0cell.north) + (-0.1, 0.2) node(v2beforex) {};
%\path(locx0cell.south) + (-0.1, -0.1) node(v2afterx) {};
%\path(locy0cell.north) + (-0.1, 0.1) node(v2beforey) {};
%\path(locy0cell.south) + (-0.1, -0.2) node(v2aftery) {};
%\path(v1beforex.center) + (0.6,0.15) node[font=\normalsize, text=blue] (t2) {$\tid_2$};
%
%\path[-, draw=blue!80, very thick]
% (v2beforex.center) edge (v2afterx.center)
% (v2afterx.center) edge (v2beforey.center)
% (v2beforey.center) edge (v2aftery.center);
% 
%\end{pgfonlayer}
%\end{tikzpicture}
%\end{center}
In the picture above, the part above the dashed line represents the history heap and 
view of each thread, while the part below the dashed line contains the thread-stack 
of each thread. History heaps are represented as mappings to locations to lists of cells, 
each of which represents a version and has three component: the value of the version 
to the left, the identifier of the transaction that wrote it to the top right, and the 
set of transactions that read the version to the bottom right. Vertical lines labelled 
with thread identifiers are used to represent the views. The position of the view of 
thread $\tid_1$ relatively to the location $[\loc_x]$ is determined by the version 
at which the vertical line labelled $\tid_1$ crosses the list of versions for $[\loc_x]$,
 and similarly for $[\loc_y]$.

We are now ready to show how to derive the computation of $\prog_1$ that 
violates atomic visibility. First, we reduce the transaction of the thread 
to the left hand side, $\tid_1$. According to rule $(Tx-exec)$, we need to 
perform the following steps: 
\begin{itemize}
\item shift the view $V_0$ for thread $\tid_1$, in $\hh_0$, to the right of an arbitrary amount 
of positions for each location, and obtain a view $V' : V_0 \sqsubseteq V$. Because $\hh_0$ contains 
only  one version for each location, here the only possibility is that $V' = V_0$.
\item Determine the heap $h = \snapshot(\hh_0, V')$ in which thread $\tid_1$ executes the transaction. 
In this case, we have that $h = [ [\loc_x \mapsto 0, \loc_y \mapsto 1]]$. 
\item Determining the fingerprint $\mathcal{O}$ of the transaction executed by $\tid_1$, whose code is
 \[
            \begin{transaction}
            		 \pmutate{\loc_x}{1};\\
            		 \pmutate{\loc_y}{1};
              \end{transaction}
 \]
 This amounts to execute the transaction in isolation from the external environment, using the rules in the operational semantics for 
 transactions. Because this execution must match the premiss of Rule $(C-Tx)$,  The code is run using $h$ as the initial heap, $\sigma_0$ as the initial 
 thread stack, $\tau_0 = \lambda_a.0$ as the initial transaction stack, and $\emptyset$ as the 
 initial fingerprint. We only need to apply 
 Rule $(Tx-prim)$ twice, in which case we obtain
 \begin{equation}
\label{eq:tx1}
\begin{array}{lcr}
& \sigma_0 \vdash \left\langle h_0, \_, \emptyset, \begin{array}{l}
\pmutate{\loc_x}{1};\\ \pmutate{\loc_y}{1} \end{array} \right\rangle 
&\rightarrow \\
\rightarrow & 
\left \langle h_0[ [\loc_x] \mapsto 1], \_, \big( \emptyset \oplus \WR\; [\loc_x]: 1 \big), 
\pmutate{\loc_y}{1} \right\rangle &= \\
=&\left \langle h_0[[\loc_x] \mapsto 1], \_, \{\WR\; [\loc_x]: 1\}, 
\pmutate{\loc_y}{1} \right\rangle 
&\rightarrow\\ 
\rightarrow & 
\left\langle h_0[[\loc_x] \mapsto_1, [\loc_y] \mapsto 1], \_, \big( \{\WR\;[\loc_x]:1\} \oplus  (\WR\;[\loc_y]: 1) \big), 
\nil \right\rangle & = \\
=& \left \langle \_, \_, \{\WR\;[\loc_x]: 1, \WR\;[\loc_y]:1 \}, \nil \right\rangle
\end{array}
\end{equation}
Therefore, we conclude $\mathcal{O} = \{\WR\; [\loc_x] : 1, \WR\;[\loc_y]:1\}$.
\item Determine the history heap and view $\hh_1, V''$ obtained by applying the 
functions $\mathsf{HHeapUpdate}_{\tsid_1}(\hh_0, V', \mathcal{O})$ and  $\mathsf{ViewUpdate}(\hh_0, V', 
mathcal{O})$, respectively. Here $\tsid_1$ is a fresh transaction identifier. 
This result in the history heap $\hh_1$ and view $V_1$, depicted in 
Figure \ref{fig:opsem.example}(b) - the view $V'$ is the one labelled with $\tid_1$.
\item Shift  $V'''$ such that $V'' \sqsubseteq V'''$, and $(\hh_0, V') \triangleright_{CM} \mathcal{O} : V'''$. 
The only possibility here is by choosing $V'' = V'''$,
\item Combine all the steps above, and infer the transition $\langle \mathcal{C}_0, \prog_1 \rangle \xrightarrow{CM} 
\langle \mathcal{C}_1, \prog_1' \rangle$, where $\mathcal{C}_1$ is depicted in Figure \ref{fig:cc.exec} 
and 
\[
\prog_1' = 
    \begin{session}
        \begin{array}{@{}c || c@{}}
            \nil &
              \begin{transaction}
            		\pderef{\pvar{a}}{\loc_x};\\
            		\pderef{\pvar{b}}{\loc_y};\\
            		\pifs{\pvar{a}=1 \wedge \pvar{b}=0}\\
            			\;\;\;\;\passign{\retvar}{\Large \frownie{}}
             \end{transaction}
        \end{array}
    \end{session}
\]
\end{itemize}
%
%is only one version for both 
%first need 
%to determine the snapshot obtained from the history heap $\hh_{0}$ and the 
%view $V_0$ of $\tid_1$: this snapshot corresponds to the heap $h_0 = [ [\loc_x] \mapsto 0, 
%[\loc_y] \mapsto 0]$. Note that $h_0$ can be determined easily from the graphical 
%representation of $\mathcal{C}_0$, by simply looking at the value of the versions at 
%which the view of $\tid_1$ intersects the list of versions of the respective location.
%Once the heap $h_0$ has been determined, we determine the fingerprint of the 
%transaction of $\tid_1$ by running it under the heap $h_0$. By applying twice Rule 
%$(prim-t-fp)$ we obtain the following derivation: 
%\begin{equation}
%\label{eq:tx1}
%\begin{array}{llcll}
%&\left\langle h_0, \_, \emptyset, \begin{array}{l}
%\pmutate{\loc_x}{1};\\ \pmutate{\loc_y}{1} \end{array} \right\rangle 
%&\rightarrow& \left \langle h_0[ [\loc_x] \mapsto 1], \_, \emptyset \oplus \WR\; [\loc_x]: 1, 
%\pmutate{\loc_y}{1} \right\rangle &= \\
%=&\left \langle h_0[[\loc_x] \mapsto 1], \_, \{\WR\; [\loc_x]: 1\}, 
%\pmutate{\loc_y}{1} \right\rangle 
%&\rightarrow& 
%\left\langle h_0[[\loc_x \mapsto_1, \loc_y \mapsto 1], \_, \begin{array}{c} \{\WR\;[\loc_x]:1\} \oplus\\  (\WR\;[\loc_y]: 1) \end{array}, 
%\nil \right\rangle & = \\
%=&\left \langle \_, \_, \{\WR\;[\loc_x]: 1, \WR\;[\loc_y]:1 \}, \nil \right\rangle
%\end{array}
%\end{equation}
%We can now apply rules $(tx-exec), (p-thd-exec)$ and $(p-par-L)$, in this order, 
%to infer how the computation given in \eqref{eq:tx1} affects the whole program $\prog_1$. Here the most important 
%derivation is the one obtained by applying rule $(tx-exec)$. This rule, in fact, states that the history 
%heap $\hh_0$ and the view $V_0$ of $\tid_1$ must be updated to reflect the effects of the 
%transaction $\hh_1$. This leads to a history heap $\hh_1$ where a new version is appended for 
%both locations $\loc_x, \loc_y$. The view of $\tid_1$ is also updated as to point to the versions 
%that the thread $\tid_1$ just installed for the locations $\loc_1, \loc_2$. According to rule 
%$(p-par-L)$, the view of the thread $\tid_2$ is left unchanged by executing a transaction in $\tid_1$. 
%This leads to the transition $\langle \mathcal{C}_0, \prog_1 \rangle \xrightarrow{\_}_{CM} \langle 
%\mathcal{C}_1, \prog_1' \rangle$, which is depicted below: 
%\begin{center}
%\begin{tikzpicture}[font=\large]
%\begin{pgfonlayer}{foreground}
%\node (locx) {$[\loc_x] \mapsto$};
%\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
%\path (locx.east) + (0.5,0)  node (locx0) {$0$};
%\path (locx0.north east) + (0.4,0) node[font=\small] (locx0ws) {$\tsid_0$};
%\path (locx0.south east) + (0.4,0) node[font=\small] (locx0rs) {$\emptyset$};
%\path (locy.east) + (0.5,0)  node (locy0) {$0$};
%\path (locy0.north east) + (0.4,0) node[font=\small] (locy0ws) {$\tsid_0$};
%\path (locy0.south east) + (0.4,0) node[font=\small] (locy0rs) {$\emptyset$};
%
%\path (locy.south west) + (0, -0.6) node (dashlinestart) {};
%\path (dashlinestart.center) + (3.5, 0) node (dashlineend) {};
%
%\path(locy0.south) + (0,-1) node[font = \small, text=red] (tid1ret) {$\tid_1: \retvar = 0$};
%\path(tid1ret.south) + (0,-0.3) node[font= \small, text=blue] (tid2ret) {$\tid_2: \retvar = 0$};
%\end{pgfonlayer}
%
%\begin{pgfonlayer}{main}
%
%\path[-, dashed, thick] (dashlinestart.center) edge (dashlineend.center);
%
%\node[hheapcell, fill=white, fit=(locx0) (locx0ws) (locx0rs)] (locx0cell) {};
%\node[hheapcell, fill=white, fit=(locy0) (locy0ws) (locy0rs)] (locy0cell) {};
%
%\path[-]
%(locx0cell.north) edge (locx0cell.south)
%(locx0cell.center) edge (locx0cell.east)
%(locy0cell.north) edge (locy0cell.south) 
%(locy0cell.center) edge (locy0cell.east);
%
%\path(locx0cell.north) + (-0.5, 0.2) node(v1beforex) {};
%\path(locx0cell.south) + (-0.5, -0.1) node(v1afterx) {};
%\path(locy0cell.north) + (-0.5, 0.1) node(v1beforey) {};
%\path(locy0cell.south) + (-0.5, -0.2) node(v1aftery) {};
%\path(v1beforex.center) + (-0.25,0.15) node[font=\normalsize, text=red] (t1) {$\tid_1$};
%
%\path[-, draw=red!80, very thick]
% (v1beforex.center) edge (v1afterx.center)
% (v1afterx.center) edge (v1beforey.center)
% (v1beforey.center) edge (v1aftery.center);
% 
% \path(locx0cell.north) + (-0.1, 0.2) node(v2beforex) {};
%\path(locx0cell.south) + (-0.1, -0.1) node(v2afterx) {};
%\path(locy0cell.north) + (-0.1, 0.1) node(v2beforey) {};
%\path(locy0cell.south) + (-0.1, -0.2) node(v2aftery) {};
%\path(v2beforex.center) + (0.2,0.15) node[font=\normalsize, text=blue] (t2) {$\tid_2$};
%
%\path[-, draw=blue!80, very thick]
% (v2beforex.center) edge (v2afterx.center)
% (v2afterx.center) edge (v2beforey.center)
% (v2beforey.center) edge (v2aftery.center);
%\end{pgfonlayer}
%
%\begin{pgfonlayer}{background}
%\node[background, fill=yellow!20, fit= (t1) (t2) (dashlinestart) (dashlineend) (tid1ret) (tid2ret), inner sep=0.05cm] (c1) {};
%\end{pgfonlayer}
%
%\path(c1.east) + (0.8,0)  node [font=\Huge] (p1) {{}, $\prog_1$};
%\path(p1.east) + (0.5,0) node[font=\Huge] (arrow) {${}\xrightarrow{\_}$};
%
%\begin{pgfonlayer}{foreground}
%\path (locx.east) + (6, 0) node (locxf) {$[\loc_x] \mapsto$};
%\path (locxf.south) + (0,-1.5) node (locyf) {$[\loc_y] \mapsto$};
%\path (locxf.east) + (0.5,0)  node (locxf0) {$0$};
%\path (locxf0.north east) + (0.4,0) node[font=\small] (locxf0ws) {$\tsid_0$};
%\path (locxf0.south east) + (0.4,0) node[font=\small] (locxf0rs) {$\emptyset$};
%\path(locxf0.east) + (1.135,0) node (locxf1) {$1$};
%\path (locxf1.north east) + (0.4,0) node[font=\small] (locxf1ws) {$\tsid_1$};
%\path (locxf1.south east) + (0.4,0) node[font=\small] (locxf1rs) {$\emptyset$};
%\path (locyf.east) + (0.5,0)  node (locyf0) {$0$};
%\path (locyf0.north east) + (0.4,0) node[font=\small] (locyf0ws) {$\tsid_0$};
%\path (locyf0.south east) + (0.4,0) node[font=\small] (locyf0rs) {$\emptyset$};
%\path(locyf0.east) + (1.13,0) node (locyf1) {$1$};
%\path (locyf1.north east) + (0.4,0) node[font=\small] (locyf1ws) {$\tsid_1$};
%\path (locyf1.south east) + (0.4,0) node[font=\small] (locyf1rs) {$\emptyset$};
%
%\path (locyf.south west) + (0, -0.6) node (dashlinestartf) {};
%\path (dashlinestartf.center) + (4.5, 0) node (dashlineendf) {};
%
%\path(locyf0.south) + (0,-1) node[font = \small, text=red] (tidf1ret) {$\tid_1: \retvar = 0$};
%\path(tidf1ret.south) + (0,-0.3) node[font= \small, text=blue] (tidf2ret) {$\tid_2: \retvar = 0$};
%\end{pgfonlayer}
%
%\begin{pgfonlayer}{main}
%
%\path[-, dashed, thick] (dashlinestartf.center) edge (dashlineendf.center);
%
%\node[hheapcell, fill=white, fit=(locxf0) (locxf0ws) (locxf0rs)] (locxf0cell) {};
%\node[hheapcell, fill=white, fit=(locyf0) (locyf0ws) (locyf0rs)] (locyf0cell) {};
%\node[hheapcell, fill=white, fit=(locxf1) (locxf1ws) (locxf1rs)] (locxf1cell) {};
%\node[hheapcell, fill=white, fit=(locyf1) (locyf1ws) (locyf1rs)] (locyf1cell) {};
%
%\path[-]
%(locxf0cell.north) edge (locxf0cell.south)
%(locxf0cell.center) edge (locxf0cell.east)
%(locyf0cell.north) edge (locyf0cell.south) 
%(locyf0cell.center) edge (locyf0cell.east)
%(locxf1cell.north) edge (locxf1cell.south)
%(locxf1cell.center) edge (locxf1cell.east)
%(locyf1cell.north) edge (locyf1cell.south) 
%(locyf1cell.center) edge (locyf1cell.east);
%
%\path(locxf1cell.north) + (-0.5, 0.2) node(vf1beforex) {};
%\path(locxf1cell.south) + (-0.5, -0.1) node(vf1afterx) {};
%\path(locyf1cell.north) + (-0.5, 0.1) node(vf1beforey) {};
%\path(locyf1cell.south) + (-0.5, -0.2) node(vf1aftery) {};
%\path(vf1beforex.center) + (0.25,0.15) node[font=\normalsize, text=red] (tf1) {$\tid_1$};
%
%\path[-, draw=red!80, very thick]
% (vf1beforex.center) edge (vf1afterx.center)
% (vf1afterx.center) edge (vf1beforey.center)
% (vf1beforey.center) edge (vf1aftery.center);
% 
% \path(locxf0cell.north) + (-0.1, 0.2) node(vf2beforex) {};
%\path(locxf0cell.south) + (-0.1, -0.1) node(vf2afterx) {};
%\path(locyf0cell.north) + (-0.1, 0.1) node(vf2beforey) {};
%\path(locyf0cell.south) + (-0.1, -0.2) node(vf2aftery) {};
%\path(vf2beforex.center) + (-0.1,0.15) node[font=\normalsize, text=blue] (tf2) {$\tid_2$};
%
%\path[-, draw=blue!80, very thick]
% (vf2beforex.center) edge (vf2afterx.center)
% (vf2afterx.center) edge (vf2beforey.center)
% (vf2beforey.center) edge (vf2aftery.center);
%\end{pgfonlayer}
%
%\begin{pgfonlayer}{background}
%\node[background, fill=yellow!20, fit= (tf1) (tf2) (dashlinestartf) (dashlineendf) (tidf1ret) (tidf2ret), inner sep=0.05cm] (c2) {};
%\end{pgfonlayer}
%\path(c2.east) + (0.8,0)  node [font=\Huge] (p2) {{}, $\prog_1'$};
%
%\end{tikzpicture}
%\end{center}
%where 
%\[
%\prog_1' = 
%    \begin{session}
%        \begin{array}{@{}c || c@{}}
%            \nil &
%              \begin{transaction}
%            		\pderef{\pvar{a}}{\loc_x};\\
%            		\pderef{\pvar{b}}{\loc_y};\\
%            		\pifs{\pvar{a}=1 \wedge \pvar{b}=0}\\
%            			\;\;\;\;\passign{\retvar}{\Large \frownie{}}
%             \end{transaction}
%        \end{array}
%    \end{session}
%\]

Next, thread $\tid_2$ executes its own transaction using a similar pattern. 
Note that in $\mathcal{C}_1$, the view of thread $\tid_2$ is $V_0$. Because 
the history heap of this configuration contains two versions for each location, 
there are exactly four views $V': V_0 \sqsubseteq V'$ that can be chosen 
prior to executing the code of the transaction 
\[
              \begin{transaction}
            		\pderef{\pvar{a}}{\loc_x};\\
            		\pderef{\pvar{b}}{\loc_y};\\
            		\pifs{\pvar{a}=1 \wedge \pvar{b}=0}\\
            			\;\;\;\;\passign{\retvar}{\Large \frownie{}}
             \end{transaction}
\]

In practice, for this example we choose the view $V' = [ [\loc_x] \mapsto 1, [\loc_y] \mapsto 0]$, 
which points to the last version for location $\loc_x$, and to the initial version for $[\loc_y]$. 
This view is represented in Figure \ref{fig:opsem.example}(c). Executing the transaction 
results in the transition $\langle \mathcal{C}_1, \prog_1' \rangle \xrightarrow{CM} \langle \mathcal{C}_2, \nil \Par \nil \rangle$, 
where $\mathcal{C}_2$ is the configuration depicted in Figure \ref{fig:opsem.example}(d). 
Note that in $\mathcal{C}_2$ the transaction $\tsid_2$ executed by $\tid_2$ has 
read both the initial version for location $[\loc_y]$, and the latest version for $[\loc_x]$. 
This caused such a transaction to pass the check at its third line of code, so that the value $\retvar$ 
for thread $\tid_2$ is updated to ${\Large \frownie{}}$ (see Figure \ref{fig:opsem.example}(d)).

%Next, we update the view of thread $\tid_2$, using rules $(C-View-update)$, 
%$(P-thd-exec)$ and $(P-par-R)$. 
%\ac{I never wrote down $(P-par-R)$: as you may expect, it is the symmetric counterpart of $(P-par-L)$}. 
%Rule $(C-View-update)$ allows to update the view of $\tid_2$ of any location to a more up-to-date version 
%for such a location. We can therefore update this view to the most recent version for key $\loc_x$, while 
%maintaining the view for location $\loc_y$ unchanged. This leads to the transition 
%$\langle \mathcal{C}_1, \prog_1' \rangle \xrightarrow{\_}_{CM} \langle \mathcal{C}_2, \prog_1' \rangle$, 
%which is depicted below:
%\begin{center}
%\begin{tikzpicture}[font=\large]
%\begin{pgfonlayer}{foreground}
%\node(locx) {$[\loc_x] \mapsto$};
%\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
%\path (locx.east) + (0.5,0)  node (locx0) {$0$};
%\path (locx0.north east) + (0.4,0) node[font=\small] (locx0ws) {$\tsid_0$};
%\path (locx0.south east) + (0.4,0) node[font=\small] (locx0rs) {$\emptyset$};
%\path(locx0.east) + (1.135,0) node (locx1) {$1$};
%\path (locx1.north east) + (0.4,0) node[font=\small] (locx1ws) {$\tsid_1$};
%\path (locx1.south east) + (0.4,0) node[font=\small] (locx1rs) {$\emptyset$};
%\path (locy.east) + (0.5,0)  node (locy0) {$0$};
%\path (locy0.north east) + (0.4,0) node[font=\small] (locy0ws) {$\tsid_0$};
%\path (locy0.south east) + (0.4,0) node[font=\small] (locy0rs) {$\emptyset$};
%\path(locy0.east) + (1.13,0) node (locy1) {$1$};
%\path (locy1.north east) + (0.4,0) node[font=\small] (locy1ws) {$\tsid_1$};
%\path (locy1.south east) + (0.4,0) node[font=\small] (locy1rs) {$\emptyset$};
%
%\path (locy.south west) + (0, -0.6) node (dashlinestart) {};
%\path (dashlinestart.center) + (4.5, 0) node (dashlineend) {};
%
%\path(locy0.south) + (0,-1) node[font = \small, text=red] (tid1ret) {$\tid_1: \retvar = 0$};
%\path(tid1ret.south) + (0,-0.3) node[font= \small, text=blue] (tid2ret) {$\tid_2: \retvar = 0$};
%\end{pgfonlayer}
%
%\begin{pgfonlayer}{main}
%
%\path[-, dashed, thick] (dashlinestart.center) edge (dashlineend.center);
%
%\node[hheapcell, fill=white, fit=(locx0) (locx0ws) (locx0rs)] (locx0cell) {};
%\node[hheapcell, fill=white, fit=(locy0) (locy0ws) (locy0rs)] (locy0cell) {};
%\node[hheapcell, fill=white, fit=(locx1) (locx1ws) (locx1rs)] (locx1cell) {};
%\node[hheapcell, fill=white, fit=(locy1) (locy1ws) (locy1rs)] (locy1cell) {};
%
%\path[-]
%(locx0cell.north) edge (locx0cell.south)
%(locx0cell.center) edge (locx0cell.east)
%(locy0cell.north) edge (locy0cell.south) 
%(locy0cell.center) edge (locy0cell.east)
%(locx1cell.north) edge (locx1cell.south)
%(locx1cell.center) edge (locx1cell.east)
%(locy1cell.north) edge (locy1cell.south) 
%(locy1cell.center) edge (locy1cell.east);
%
%\path(locx1cell.north) + (-0.5, 0.2) node(v1beforex) {};
%\path(locx1cell.south) + (-0.5, -0.1) node(v1afterx) {};
%\path(locy1cell.north) + (-0.5, 0.1) node(v1beforey) {};
%\path(locy1cell.south) + (-0.5, -0.2) node(v1aftery) {};
%\path(v1beforex.center) + (0.25,0.15) node[font=\normalsize, text=red] (t1) {$\tid_1$};
%
%\path[-, draw=red!80, very thick]
% (v1beforex.center) edge (v1afterx.center)
% (v1afterx.center) edge (v1beforey.center)
% (v1beforey.center) edge (v1aftery.center);
% 
% \path(locx0cell.north) + (-0.1, 0.2) node(v2beforex) {};
%\path(locx0cell.south) + (-0.1, -0.1) node(v2afterx) {};
%\path(locy0cell.north) + (-0.1, 0.1) node(v2beforey) {};
%\path(locy0cell.south) + (-0.1, -0.2) node(v2aftery) {};
%\path(v2beforex.center) + (-0.1,0.15) node[font=\normalsize, text=blue] (t2) {$\tid_2$};
%
%\path[-, draw=blue!80, very thick]
% (v2beforex.center) edge (v2afterx.center)
% (v2afterx.center) edge (v2beforey.center)
% (v2beforey.center) edge (v2aftery.center);
%\end{pgfonlayer}
%
%\begin{pgfonlayer}{background}
%\node[background, fill=yellow!20, fit= (t1) (t2) (dashlinestart) (dashlineend) (tid1ret) (tid2ret), inner sep=0.05cm] (c1) {};
%\end{pgfonlayer}
%\path(c1.east) + (0.8,0)  node [font=\Huge] (p1) {{}, $\prog_1'$};
%
%%%End of first configuration
%
%\path(p1.east) + (0.5,0) node[font=\Huge] (arrow) {${}\xrightarrow{\_}$};
%
%%%Beginning of second configuration
%
%\begin{pgfonlayer}{foreground}
%\path (locx.east) + (7, 0) node (locxf) {$[\loc_x] \mapsto$};
%\path (locxf.south) + (0,-1.5) node (locyf) {$[\loc_y] \mapsto$};
%\path (locxf.east) + (0.5,0)  node (locxf0) {$0$};
%\path (locxf0.north east) + (0.4,0) node[font=\small] (locxf0ws) {$\tsid_0$};
%\path (locxf0.south east) + (0.4,0) node[font=\small] (locxf0rs) {$\emptyset$};
%\path(locxf0.east) + (1.135,0) node (locxf1) {$1$};
%\path (locxf1.north east) + (0.4,0) node[font=\small] (locxf1ws) {$\tsid_1$};
%\path (locxf1.south east) + (0.4,0) node[font=\small] (locxf1rs) {$\emptyset$};
%\path (locyf.east) + (0.5,0)  node (locyf0) {$0$};
%\path (locyf0.north east) + (0.4,0) node[font=\small] (locyf0ws) {$\tsid_0$};
%\path (locyf0.south east) + (0.4,0) node[font=\small] (locyf0rs) {$\emptyset$};
%\path(locyf0.east) + (1.13,0) node (locyf1) {$1$};
%\path (locyf1.north east) + (0.4,0) node[font=\small] (locyf1ws) {$\tsid_1$};
%\path (locyf1.south east) + (0.4,0) node[font=\small] (locyf1rs) {$\emptyset$};
%
%\path (locyf.south west) + (0, -0.6) node (dashlinestartf) {};
%\path (dashlinestartf.center) + (4.5, 0) node (dashlineendf) {};
%
%\path(locyf0.south) + (0,-1) node[font = \small, text=red] (tidf1ret) {$\tid_1: \retvar = 0$};
%\path(tidf1ret.south) + (0,-0.3) node[font= \small, text=blue] (tidf2ret) {$\tid_2: \retvar = 0$};
%\end{pgfonlayer}
%
%\begin{pgfonlayer}{main}
%
%\path[-, dashed, thick] (dashlinestartf.center) edge (dashlineendf.center);
%
%\node[hheapcell, fill=white, fit=(locxf0) (locxf0ws) (locxf0rs)] (locxf0cell) {};
%\node[hheapcell, fill=white, fit=(locyf0) (locyf0ws) (locyf0rs)] (locyf0cell) {};
%\node[hheapcell, fill=white, fit=(locxf1) (locxf1ws) (locxf1rs)] (locxf1cell) {};
%\node[hheapcell, fill=white, fit=(locyf1) (locyf1ws) (locyf1rs)] (locyf1cell) {};
%
%\path[-]
%(locxf0cell.north) edge (locxf0cell.south)
%(locxf0cell.center) edge (locxf0cell.east)
%(locyf0cell.north) edge (locyf0cell.south) 
%(locyf0cell.center) edge (locyf0cell.east)
%(locxf1cell.north) edge (locxf1cell.south)
%(locxf1cell.center) edge (locxf1cell.east)
%(locyf1cell.north) edge (locyf1cell.south) 
%(locyf1cell.center) edge (locyf1cell.east);
%
%\path(locxf1cell.north) + (-0.5, 0.2) node(vf1beforex) {};
%\path(locxf1cell.south) + (-0.5, -0.1) node(vf1afterx) {};
%\path(locyf1cell.north) + (-0.5, 0.1) node(vf1beforey) {};
%\path(locyf1cell.south) + (-0.5, -0.2) node(vf1aftery) {};
%\path(vf1beforex.center) + (-0.3,0.15) node[font=\normalsize, text=red] (tf1) {$\tid_1$};
%
%\path[-, draw=red!80, very thick, smooth]
% (vf1beforex.center) edge (vf1afterx.center)
% (vf1afterx.center) edge (vf1beforey.center)
% (vf1beforey.center) edge (vf1aftery.center);
% 
% \path(locxf1cell.north) + (-0.2, 0.2) node(vf2beforex) {};
%\path(locxf1cell.south) + (-0.2, -0.1) node(vf2afterx) {};
%\path(locyf0cell.north) + (-0.1, 0.1) node(vf2beforey) {};
%\path(locyf0cell.south) + (-0.1, -0.2) node(vf2aftery) {};
%\path(vf2beforex.center) + (0.2,0.15) node[font=\normalsize, text=blue] (tf2) {$\tid_2$};
%
%%\path[-, draw=blue!80, very thick, smooth, tension=0.4]
%% (vf2beforex.center) edge (vf2afterx.center)
%% (vf2afterx.center) edge (vf2beforey.center)
%% (vf2beforey.center) edge (vf2aftery.center);
%\draw[blue!80, very thick] plot [smooth, tension=0.4] coordinates { (vf2beforex.center) (vf2afterx.center) (vf2beforey.center) (vf2aftery.center)};
%\end{pgfonlayer}
%
%\begin{pgfonlayer}{background}
%\node[background, fill=yellow!20, fit= (tf1) (tf2) (dashlinestartf) (dashlineendf) (tidf1ret) (tidf2ret), inner sep=0.05cm] (c2) {};
%\end{pgfonlayer}
%\path(c2.east) + (0.8,0)  node [font=\Huge] (p2) {{}, $\prog_1'$};
%
%\end{tikzpicture}
%\end{center}
%
%Finally, we can execute the transaction of thread $\tid_2$, again using rules 
%$(Tx-exec), (P-thd-exec)$ and $(P-par-R)$. Note that the view of the thread $\tid_2$ in the 
%configuration depicted above, mandates that the transaction will be executed with 
%respect to the snapshot $[ [\loc_x] \mapsto 1, [\loc_y] \mapsto 0]$, and therefore it will 
%return the special symbol ${\Large \frownie{}}$. Formally, let $\prog_1'' = \nil \Par \nil$. 
%Then we have the transition $\langle \mathcal{C}_2, \prog_1' \rangle \xrightarrow{\_}_{CM} 
%\langle \mathcal{C}_3, \prog_1'' \rangle$, which is depicted below: 
%
%\begin{center}
%\begin{tikzpicture}[font=\large]
%\begin{pgfonlayer}{foreground}
%\node(locx) {$[\loc_x] \mapsto$};
%\path (locx.south) + (0,-1.5) node (locy) {$[\loc_y] \mapsto$};
%\path (locx.east) + (0.5,0)  node (locx0) {$0$};
%\path (locx0.north east) + (0.4,0) node[font=\small] (locx0ws) {$\tsid_0$};
%\path (locx0.south east) + (0.4,0) node[font=\small] (locx0rs) {$\emptyset$};
%\path(locx0.east) + (1.135,0) node (locx1) {$1$};
%\path (locx1.north east) + (0.4,0) node[font=\small] (locx1ws) {$\tsid_1$};
%\path (locx1.south east) + (0.4,0) node[font=\small] (locx1rs) {$\emptyset$};
%\path (locy.east) + (0.5,0)  node (locy0) {$0$};
%\path (locy0.north east) + (0.4,0) node[font=\small] (locy0ws) {$\tsid_0$};
%\path (locy0.south east) + (0.4,0) node[font=\small] (locy0rs) {$\emptyset$};
%\path(locy0.east) + (1.13,0) node (locy1) {$1$};
%\path (locy1.north east) + (0.4,0) node[font=\small] (locy1ws) {$\tsid_1$};
%\path (locy1.south east) + (0.4,0) node[font=\small] (locy1rs) {$\emptyset$};
%
%\path (locy.south west) + (0, -0.6) node (dashlinestart) {};
%\path (dashlinestart.center) + (4.5, 0) node (dashlineend) {};
%
%\path(locy0.south) + (0,-1) node[font = \small, text=red] (tid1ret) {$\tid_1: \retvar = 0$};
%\path(tid1ret.south) + (0,-0.3) node[font= \small, text=blue] (tid2ret) {$\tid_2: \retvar = 0$};
%\end{pgfonlayer}
%
%\begin{pgfonlayer}{main}
%
%\path[-, dashed, thick] (dashlinestart.center) edge (dashlineend.center);
%
%\node[hheapcell, fill=white, fit=(locx0) (locx0ws) (locx0rs)] (locx0cell) {};
%\node[hheapcell, fill=white, fit=(locy0) (locy0ws) (locy0rs)] (locy0cell) {};
%\node[hheapcell, fill=white, fit=(locx1) (locx1ws) (locx1rs)] (locx1cell) {};
%\node[hheapcell, fill=white, fit=(locy1) (locy1ws) (locy1rs)] (locy1cell) {};
%
%\path[-]
%(locx0cell.north) edge (locx0cell.south)
%(locx0cell.center) edge (locx0cell.east)
%(locy0cell.north) edge (locy0cell.south) 
%(locy0cell.center) edge (locy0cell.east)
%(locx1cell.north) edge (locx1cell.south)
%(locx1cell.center) edge (locx1cell.east)
%(locy1cell.north) edge (locy1cell.south) 
%(locy1cell.center) edge (locy1cell.east);
%
%\path(locx1cell.north) + (-0.5, 0.2) node(v1beforex) {};
%\path(locx1cell.south) + (-0.5, -0.1) node(v1afterx) {};
%\path(locy1cell.north) + (-0.5, 0.1) node(v1beforey) {};
%\path(locy1cell.south) + (-0.5, -0.2) node(v1aftery) {};
%\path(v1beforex.center) + (-0.3,0.15) node[font=\normalsize, text=red] (t1) {$\tid_1$};
%
%\path[-, draw=red!80, very thick]
% (v1beforex.center) edge (v1afterx.center)
% (v1afterx.center) edge (v1beforey.center)
% (v1beforey.center) edge (v1aftery.center);
% 
% \path(locx1cell.north) + (-0.2, 0.2) node(v2beforex) {};
%\path(locx1cell.south) + (-0.2, -0.1) node(v2afterx) {};
%\path(locy0cell.north) + (-0.1, 0.1) node(v2beforey) {};
%\path(locy0cell.south) + (-0.1, -0.2) node(v2aftery) {};
%\path(v2beforex.center) + (0.2,0.15) node[font=\normalsize, text=blue] (t2) {$\tid_2$};
%
%\draw[blue!80, very thick] plot [smooth, tension=0.4] coordinates { (v2beforex.center) (v2afterx.center) (v2beforey.center) (v2aftery.center)};
%\end{pgfonlayer}
%
%\begin{pgfonlayer}{background}
%\node[background, fill=yellow!20, fit= (t1) (t2) (dashlinestart) (dashlineend) (tid1ret) (tid2ret), inner sep=0.05cm] (c1) {};
%\end{pgfonlayer}
%\path(c1.east) + (0.8,0)  node [font=\Huge] (p1) {{}, $\prog_1'$};
%
%%%End of first configuration
%
%\path(p1.east) + (0.5,0) node[font=\Huge] (arrow) {${}\xrightarrow{\_}$};
%
%%%Beginning of second configuration
%
%\begin{pgfonlayer}{foreground}
%\path (locx.east) + (7, 0) node (locxf) {$[\loc_x] \mapsto$};
%\path (locxf.south) + (0,-1.5) node (locyf) {$[\loc_y] \mapsto$};
%\path (locxf.east) + (0.5,0)  node (locxf0) {$0$};
%\path (locxf0.north east) + (0.4,0) node[font=\small] (locxf0ws) {$\tsid_0$};
%\path (locxf0.south east) + (0.4,0) node[font=\small] (locxf0rs) {$\emptyset$};
%\path(locxf0.east) + (1.12,0.01) node (locxf1) {$1$};
%\path (locxf1.north east) + (0.4,0) node[font=\small] (locxf1ws) {$\;\;\;\;\;\;\tsid_1$};
%\path (locxf1.south east) + (0.4,0) node[font=\small] (locxf1rs) {$\;\;\;\;\;\;\{\tsid_2\}$};
%\path (locyf.east) + (0.5,0)  node (locyf0) {$0$};
%\path (locyf0.north east) + (0.4,0) node[font=\small] (locyf0ws) {$\;\;\;\;\;\;\tsid_0$};
%\path (locyf0.south east) + (0.4,0) node[font=\small] (locyf0rs) {$\;\;\;\;\;\;\{\tsid_2\}$};
%\path(locyf0.east) + (1.55,0) node (locyf1) {$1$};
%\path (locyf1.north east) + (0.4,0) node[font=\small] (locyf1ws) {$\tsid_1$};
%\path (locyf1.south east) + (0.4,0) node[font=\small] (locyf1rs) {$\emptyset$};
%
%\path (locyf.south west) + (0, -0.6) node (dashlinestartf) {};
%\path (dashlinestartf.center) + (5, 0) node (dashlineendf) {};
%
%\path(locyf0.south) + (0,-1) node[font = \small, text=red] (tidf1ret) {$\tid_1: \retvar = 0$};
%\path(tidf1ret.south) + (0,-0.3) node[font= \small, text=blue] (tidf2ret) {$\tid_2: \retvar = {\large \frownie{}}$};
%\end{pgfonlayer}
%
%\begin{pgfonlayer}{main}
%
%\path[-, dashed, thick] (dashlinestartf.center) edge (dashlineendf.center);
%
%\node[hheapcell, fill=white, fit=(locxf0) (locxf0ws) (locxf0rs)] (locxf0cell) {};
%\node[hheapcell, fill=white, fit=(locyf0) (locyf0ws) (locyf0rs), inner sep=0.083cm] (locyf0cell) {};
%\node[hheapcell, fill=white, fit=(locxf1) (locxf1ws) (locxf1rs), inner sep= 0.083cm] (locxf1cell) {};
%\node[hheapcell, fill=white, fit=(locyf1) (locyf1ws) (locyf1rs)] (locyf1cell) {};
%
%\path[-]
%(locxf0cell.north) edge (locxf0cell.south)
%(locxf0cell.center) edge (locxf0cell.east)
%(locyf0cell.north) edge (locyf0cell.south) 
%(locyf0cell.center) edge (locyf0cell.east)
%(locxf1cell.north) edge (locxf1cell.south)
%(locxf1cell.center) edge (locxf1cell.east)
%(locyf1cell.north) edge (locyf1cell.south) 
%(locyf1cell.center) edge (locyf1cell.east);
%
%\path(locxf1cell.north) + (-0.7, 0.2) node(vf1beforex) {};
%\path(locxf1cell.south) + (-0.7, -0.1) node(vf1afterx) {};
%\path(locyf1cell.north) + (-0.5, 0.1) node(vf1beforey) {};
%\path(locyf1cell.south) + (-0.5, -0.2) node(vf1aftery) {};
%\path(vf1beforex.center) + (-0.3,0.15) node[font=\normalsize, text=red] (tf1) {$\tid_1$};
%
%%\path[-, draw=red!80, very thick, smooth]
%% (vf1beforex.center) edge (vf1afterx.center)
%% (vf1afterx.center) edge (vf1beforey.center)
%% (vf1beforey.center) edge (vf1aftery.center);
%\draw[red!80, very thick] plot [smooth, tension=0.2] coordinates { (vf1beforex.center) (vf1afterx.center) (vf1beforey.center) (vf1aftery.center)};
%
% \path(locxf1cell.north) + (-0.2, 0.2) node(vf2beforex) {};
%\path(locxf1cell.south) + (-0.2, -0.1) node(vf2afterx) {};
%\path(locyf0cell.north) + (-0.1, 0.1) node(vf2beforey) {};
%\path(locyf0cell.south) + (-0.1, -0.2) node(vf2aftery) {};
%\path(vf2beforex.center) + (0.2,0.15) node[font=\normalsize, text=blue] (tf2) {$\tid_2$};
%
%%\path[-, draw=blue!80, very thick, smooth, tension=0.4]
%% (vf2beforex.center) edge (vf2afterx.center)
%% (vf2afterx.center) edge (vf2beforey.center)
%% (vf2beforey.center) edge (vf2aftery.center);
%\draw[blue!80, very thick] plot [smooth, tension=0.4] coordinates { (vf2beforex.center) (vf2afterx.center) (vf2beforey.center) (vf2aftery.center)};
%\end{pgfonlayer}
%
%\begin{pgfonlayer}{background}
%\node[background, fill=yellow!20, fit= (tf1) (tf2) (dashlinestartf) (dashlineendf) (tidf1ret) (tidf2ret), inner sep=0.05cm] (c2) {};
%\end{pgfonlayer}
%\path(c2.east) + (0.8,0)  node [font=\Huge] (p2) {{}, $\prog_1''$};
%
%\end{tikzpicture}
%\end{center}
%
%\ac{Fix style for pictures. Having a different block for each cell may cause disalignment.
%The return value of $\tid_2$ should be emphasised more in the picture.\\
%Update: Done. Need to synch pictures in this section with new style.}
%Note that, in the final configuration configuration $\mathcal{C}_2$, the variable $\retvar$ in the thread 
%stack of $\tid_2$ contains the special symbol $\Large \frownie{}$, as to mean that we obtained a violation of 
%atomic visibility.

\section{Examples of Consistency Models}
\input{cmexamples}
%
%
%\subsection{Encoding Dependency Graphs' Specifications}
%\ac{Contents: Isomorphism between history heaps and dependency graphs, 
%converting dependency graphs specifications, well-formedness of dependency graphs' specifications.}

\section{Relationship to Abstract Executions}
\input{hheap2absexec}

\subsection{Completeness of the Semantics} 
\ac{Contents: Abstract execution Semantics and the anarchic model. 
Encoding of abstract executions into history heaps. Also, 
traces in the history heaps semantics can be used to recover 
an abstract execution $\aexec$. Hence it is possible to convert history heaps 
specifications into sets of abstract executions.
I think this should be the Theorem: for every possible trace of a program $\prog$ that is allowed by the anarchic 
model, and that results into an abstract execution $\chi$ that is allowed by $CM$, there 
exists a trace of the same program under the history heaps $CM$-semantics, 
and whose encoding into an abstract execution is exactly $\aexec$.}
\subsection{Remarks on the operational semantics}
\ac{There was a discussion on whether views of threads should always be consistent w.r.t a 
consistency model specification, or whether they should be consistent only w.r.t. to 
a consistency model specification only prior to executing a transaction.\\ 
In this section I should argue that the first option leads to losing the completeness of the 
semantics.}


%\section{Testing Consistency Models Specifications}
%\ac{Definition of may-testing preorder, which is standard and at some point 
%was also in the notes - where did it go? Most General Client Semantics of consistency 
%models under history heaps. Conjecture: two consistency models are equivalent if they 
%produce the same set of histories (transactions labelled with the session order) under 
%the most general client semantics. This is consistent with Hongseok's result that contextual 
%refinement for concurrent libraries coincide with 
%the sequential consistency preorder, when threads can only communicate via the memory regions 
%shared withing the library.}

%\subsection{Applications}
%\ac{Proof of equivalence of consistency models specifications given in terms of history heaps, 
%with respect to the same specifications given in terms of dependnecy graphs. In this section 
%I must be careful to address the work by Crook and Alvisi, as they also have an operational model 
%of transactions (without a programming language) and a proof of equivalence with respect to 
%dependency graphs' specifications.}

%\subsection{Verification of Algorithms} 
%Candidates: 
%\begin{itemize}
%\item Walter (\textbf{https://dl.acm.org/citation.cfm?id=2043592}) - PSI, should be easy, 
%people may find it boring, the Concur'15 model was inspired by Walter and people may argue we 
%already proved its correctness in there.
%\item Wren (\textbf{https://infoscience.epfl.ch/record/254970}) - Causal Consistency - very recent and seems to have 
%a nice pseudo-code.\\
%\item COPS-gt (\textbf{https://www.cs.cmu.edu/~dga/papers/cops-sosp2011.pdf}) - Causal Consistency -  mentioned a lot at 
%talks, may be a viable option.
%\item Distributed SI (\textbf{https://dl.acm.org/citation.cfm?id=2691546}) - Snapshot Isolation - 5 different protocols given in the paper, 
%not sure if any of those is easily verifiable.\\ 
%\item Clock-SI (\textbf{https://dl.acm.org/citation.cfm?id=2553434}) - Using physical clocks as time-stamps, may have a direct encoding 
%into history heaps - has some chances of being verifiable.
%\end{itemize}

\bibliographystyle{abbrv}
\bibliography{bibliography2}

\end{document}

