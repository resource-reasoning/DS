\documentclass[a4paper,UKenglish]{article}%This is a template for producing LIPIcs articles. 


\input{env.tex}
\input{macros.tex}



%See lipics-manual.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
% for section-numbered lemmas etc., use "numberwithinsect"

%DOI commented out in the class file for space purposes: 
%to put back, uncomment lines 419-422 in the style file.
 
\usepackage{microtype}%if unwanted, comment out or use option "draft"
%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

%\bibliographystyle{plainurl}% the recommended bibstyle

%\usepackage[a4paper]{geometry}
%\usepackage[letterpaper,left=2.4cm,right=2.4cm,top=2.4cm,bottom=2.4cm]{geometry}

\usepackage{opsem}


\usepackage{etex}

\usepackage{stackengine}

\usepackage{authblk}



%%%%%%%%%%%%%%%%%%%%%% edit mode
\newif\iflong
\longfalse  % uncomment for short version
%\longtrue  % uncomment for long version

\newif\ifdraft
%\draftfalse %uncomment for deleting notes
\drafttrue %uncomment for showing notes

\newif\ifEditing
\Editingtrue
\ifEditing
    \linenumbers
\fi

\newif\ifComments
\Commentstrue
\input{comment-box.tex}
%%%%%%%%%%%%%%%%%%%%%% end edit mode

\newcommand{\tr}[2]{\iflong{}\S#1\else{}\cite[\S{}#2]{ext}\fi}
\newcommand{\tra}[2]{\iflong{}(\S#1)\else{}\cite[\S{}#2]{ext}\fi}

\newcommand{\nanomalies}{A}
\newcommand{\ngeneral}{B}
\newcommand{\nproofs}{C}
\newcommand{\ncompleteness}{D}

\renewcommand{\ttdefault}{cmtt}
\renewcommand{\sfdefault}{cmss}

\newcommand{\cross}{\ding{56}}


%\renewcommand{\rmdefault}{ptm}

\renewcommand{\O}{\mathcal{O}}

\newcommand{\theproof}{{\noindent\hskip\labelsep
        \color{darkgray}\sffamily\bfseries \proofname.}}
        
\newcommand{\myparagraph}[1]{\textbf{\color{darkgray}\sffamily#1.}}
\newcommand{\newtext}[1]{{\color{red}{\bf #1}}}
\newcommand{\dfont}[1]{{\bf\em #1}}

% comments


\usepackage{pifont}
\usepackage[frame,all]{xy}
\usepackage{nicefrac}
\usepackage{executions}
\usepackage{execgraphs}

\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{proof}

\DeclareMathAlphabet{\mathpzc}{OT1}{pzc}{m}{it}

%\usepackage{mathtools}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Packages above %%%%%%%%%%%%%%%%%%%%%%%


\theoremstyle{plain}

%\newcommand{\qed}{$\Box$}
%\newenvironment{proof}{\begin{trivlist}
%\item[\hskip\labelsep{\sc Proof.}]}
%{$\hfill\Box$\end{trivlist}}
\newenvironment{sketch}{\begin{trivlist}
\item[\hskip\labelsep{\sc Proof sketch.}]}
{$\hfill\Box$\end{trivlist}}
\newenvironment{scheme}{\begin{trivlist}
\item[\hskip\labelsep{\sc Proof scheme.}]}
{$\hfill\Box$\end{trivlist}}


%\newcommand{\account}{\ensuremath{\mathsf{acct}}}
%\newcommand{\emptytxt}{{\ensuremath{\mathsf{empty}}}}
%\newcommand{\post}{\ensuremath{\mathsf{post}}}
%\newcommand{\comment}{\ensuremath{\mathsf{comment}}}

%\def\qed{\ifmmode\squareforqed\else{\unskip\nobreak\hfil
%\penalty50\hskip1em\null\nobreak\hfil\squareforqed
%\parfillskip=0pt\finalhyphendemerits=0\endgraf}\fi}


\newcommand{\leaveout}[1]{}

\newcommand\Tstrut{\rule{0pt}{3.5ex}}         % = `top' strut
\newcommand\Bstrut{\\[3pt]}   % = `bottom' strut

\usepackage{paralist}
\setdefaultleftmargin{10pt}{}{}{}{}{}
\setlength{\topsep}{3pt}
\setlength{\itemsep}{2pt}
% \setlength{\partopsep}{0pt}
% \setlength{\parsep}{0pt}
%\setlength{\parskip}{0pt}

\newenvironment{subitemize}{
\begin{itemize}
 \setlength{\topsep}{0pt}
  \setlength{\itemsep}{0pt}
  \setlength{\parskip}{0pt}
}{\end{itemize}}

\multlinegap=3pt
\setlength{\jot}{2pt}
\newcommand{\ms}{\\[2pt]}

%
\setlength{\floatsep}{10pt plus 6pt minus 2pt}
\setlength{\textfloatsep}{10pt plus 6pt minus 3pt}
\setlength{\intextsep}{10pt plus 6pt minus 3pt}
\setlength{\dblfloatsep}{18pt plus 4pt minus 2pt}
\setlength{\dbltextfloatsep}{20pt plus 4pt minus 3pt}

\newenvironment{mywrapfigure}[3][]{
  \floatstyle{boxed}
  \restylefloat{figure}
  \wrapfigure[#1]{#2}{#3}}
  {\endwrapfigure
    \floatstyle{ruled}
    \restylefloat{figure}
    }
    

% \setlength{\floatsep}{18pt plus 4pt minus 2pt}
% \setlength{\textfloatsep}{18pt plus 4pt minus 3pt}
% \setlength{\intextsep}{10pt plus 4pt minus 3pt}
% \setlength{\dblfloatsep}{18pt plus 4pt minus 2pt}
% \setlength{\dbltextfloatsep}{20pt plus 4pt minus 3pt}
%
%\makeatletter
%\renewcommand{\section}{\@startsection{section}{1}{0pt}%
%{-3ex plus -1ex minus -.2ex}{1.5ex plus.2ex}%
%{\normalfont\large\bfseries}}
%\renewcommand{\subsection}{\@startsection{subsection}{1}{0pt}%
%{-2ex plus -1ex minus -.2ex}{1ex plus.2ex}%
%{\bfseries}}
%\def \@begintheorem #1#2{%                      {name}{number}
%  \trivlist
%  \item[\hskip \labelsep \textbf{#1 #2.}]%
%  \itshape\selectfont
%  \ignorespaces}
%\newcommand{\nut}{\hspace{.35em}}
%\def \@opargbegintheorem #1#2#3{%               {name}{number}{title}
%  \trivlist
%  \item[%
%    \hskip\labelsep \textsc{#1\ #2}\nut (#3).]%
%  \itshape\selectfont
%  \ignorespaces}
%
%\def\@listI{\leftmargin\leftmargini
%            \parsep 0\p@ \@plus1\p@ \@minus\p@
%            \topsep 6\p@ \@plus2\p@ \@minus0\p@
%            \itemsep 0\p@}
%\let\@listi\@listI
%\@listi
%
%\makeatother
%
%\sloppy

%Labels for groups of inequations
\newcommand{\txlaws}{{\textbf{(a)}}}
\newcommand{\deplaws}{{\textbf{(b)}}}
\newcommand{\allexeclaws}{{\textbf{(c)}}}
\newcommand{\cmexeclaws}{{\textbf{(d)}}}

%Labels for individual inequations
\newcommand{\txId}{{\textbf{(a.1)}}}
\newcommand{\txComp}{{\textbf{(a.2)}}}
\newcommand{\txCap}{{\textbf{(a.5)}}}
\newcommand{\txCup}{{\textbf{(a.6)}}}
\newcommand{\txDistrR}{{\textbf{(a.3)}}}
\newcommand{\txDistrL}{{\textbf{(a.4)}}}
%
\newcommand{\depWRTx}{{\textbf{(b.1)}}}
\newcommand{\depWWTx}{{\textbf{(b.2)}}}
\newcommand{\depRWTx}{{\textbf{(b.3)}}}
\newcommand{\depWRIrrefl}{{\textbf{(b.4)}}}
\newcommand{\depWWIrrefl}{{\textbf{(b.5)}}}
\newcommand{\depRWIrrefl}{{\textbf{(b.6)}}}
%
\newcommand{\ARtrans}{{\textbf{(c.5)}}}
\newcommand{\VIStrans}{{\textbf{(c.4)}}}
\newcommand{\VISinAR}{{\textbf{(c.6)}}}
\newcommand{\ARirrefl}{{\textbf{(c.12)}}}
\newcommand{\VISnotAVIS}{{\textbf{(c.11)}}}
\newcommand{\POinVIS}{{\textbf{(c.0)}}}
\newcommand{\WRinVIS}{{\textbf{(c.1)}}}
\newcommand{\WWinAR}{{\textbf{(c.2)}}}
\newcommand{\LWW}{{\textbf{(c.7)}}}
\newcommand{\RWinAVIS}{{\textbf{(c.3)}}}
\newcommand{\AVISright}{{\textbf{(c.8)}}}
\newcommand{\AVISleft}{{\textbf{(c.9)}}}
\newcommand{\AVISnotVIS}{{\textbf{(c.10)}}}
\newcommand{\CompIrrefl}{{\textbf{(c.13)}}}
%
\newcommand{\Axiom}{{\textbf{(d.1)}}}
\newcommand{\CoAxiomAR}{{\textbf{(d.2)}}}
\newcommand{\CoAxiomL}{{\textbf{(d.3)}}}
\newcommand{\CoAxiomR}{{\textbf{(d.4)}}}

\newcommand{\Spo}{\text{(V0)}}
\newcommand{\Srf}{\text{(V1)}}
\newcommand{\Sconflict}{\text{(V3)}}
\newcommand{\SvisTrans}{\text{(V2)}}
\newcommand{\Saxiom}{\text{(V4)}}
\newcommand{\Svo}{\text{(A1)}}
\newcommand{\Svis}{\text{(A2)}}
\newcommand{\SarTrans}{\text{(A4)}}
\newcommand{\Scoaxiom}{\text{(A5)}}
\newcommand{\Sext}{\text{(A3)}}
\newcommand{\Sad}{\text{(N1)}}
\newcommand{\SavisL}{\text{(N2)}}
\newcommand{\SavisR}{\text{(N3)}}

\newcommand{\palette}{\ensuremath{\mathop{\raisebox{-4pt}{\includegraphics[scale=0.02]{palette.png}}}}}
\newcommand{\gspec}{\ensuremath{\mathsf{gSpec}}}

% Author macros:begin %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\iflong
\title{On the Operational Behaviour of Weak Consistency Models with Atomic Visibility}
%\titlerunning{Algebraic Laws for Weak Consistency (Extended Version)} %optional, in case that the title is too long; the running title should fit into the top page column
\else
\title{On the Operational Behaviour of Weak Consistency Models with Atomic Visibility}
%\titlerunning{Algebraic Laws for Weak Consistency}
\fi

%% Please provide for each author the \author and \affil macro, even when authors have the same affiliation, i.e. for each author there needs to be the  \author and \affil macros
\iflong

\author[1]{Andrea Cerone}
%\author[2]{Alexey Gotsman}
%\author[3]{Hongseok Yang\vspace{-5pt}}
\affil[1]{Imperial College London, UK}
%\affil[2]{IMDEA Software Institute, Madrid, Spain, \texttt{alexey.gotsman@imdea.org}}
%\affil[3]{University of Oxford, UK, \texttt{hongseok.yang@cs.ox.ac.uk} \vspace{-15pt}}
%\authorrunning{A. Cerone} %mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et. al.'
\else

\author[1]{Andrea Cerone}
\affil[1]{Imperial College London, UK, \texttt{a.cerone@imperial.ac.uk}}
%\affil[2]{IMDEA Software Institute, Madrid, Spain, \texttt{alexey.gotsman@imdea.org}}
%\affil[3]{University of Oxford, UK, \texttt{hongseok.yang@cs.ox.ac.uk}}
%\authorrunning{A. Cerone,\, A. Gotsman,\, H. Yang} %mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et. al.'
\fi

%\Copyright{Andrea Cerone, Alexey Gotsman and Hongseok Yang}%mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/
%%
%\subjclass{C.2.4 Distributed Databases}% mandatory: Please choose ACM 1998 classifications from http://www.acm.org/about/class/ccs98-html . E.g., cite as "F.1.1 Models of Computation". 
%\keywords{Weak Consistency Models, Distributed Databases, Dependency Graphs.}% mandatory: Please provide 1-5 keywords
%%% Author macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%\EventEditors{Roland Meyer and Uwe Nestmann}
%\EventNoEds{2}
%\EventLongTitle{28th International Conference on Concurrency Theory (CONCUR 2017)}
%\EventShortTitle{CONCUR 2017}
%\EventAcronym{CONCUR}
%\EventYear{2017}
%\EventDate{September 5--8, 2017}
%\EventLocation{Berlin, Germany}
%\EventLogo{}
%\SeriesVolume{85}
%\ArticleNo{22} % "New number" (=<article-no>) goes here!



\begin{document}
\maketitle
The objective of these notes is that of defining a small step operational semantics for 
consistency models. Judgements will define small step reductions $\mathcal{C} \xrightarrow{\lambda} \mathcal{C'}$ 
between the configurations $\mathcal{C}, \mathcal{C'}$. These contain the information about the state of the 
transactional memory, and the concurrent program to be executed. The former will be represented using 
abstract executions \cite{framework-concur}.

\paragraph{\textbf{Computational Model.}}
We focus on a computational model where multi-threaded programs can access and update 
locations in a centralised heap using atomic transactions. A heap $\heap$ consists of a mapping 
from a set of locations $\locs = \{ [n] \mid n \in \mathbb{N}\}$ to values in $\mathbb{N}$. 
The set of all heaps is denoted by $\heapset$. 
Each thread has its own stack, 
where data for performing local computations is stored. Transactions also 
have a transaction-local stack. 
The set of thread-local stack variables is denoted by $\threadvars = \{\mathtt{x}, \mathtt{y}, \cdots\}$, 
while the set of transaction local locations is denoted by $\txvars = \{\mathtt{a}, \mathtt{b}, \cdots\}$. 
We use $\thdstack$ to range over thread-local stacks in the set $\thdstackset \triangleq \threadvars \rightarrow \mathbb{N}$, 
and $\txstack$ to range over transaction-local stacks in the set $\txstackset \triangleq \txvars \rightarrow \mathbb{N}$.

The transaction-local stack is created at the moment a transaction start, 
and is destroyed at the moment it commits. 
Transactions can read from, but cannot 
write to, the thread-local stack. This assumption makes it possible to abstract from 
aborting transactions, as these would have no side-effects in the computational described. 
We assume that each transaction-local 
stack has a special variable that is used to store the value returned by the transaction 
upon commit. Each thread-local stack also comes equipped with a special return variable, 
where the contents of the value returned by transactions are stored. We use the symbol 
$\retvar$ to denote the special return variable, both in transaction-local and thread-local 
stacks.

We leave the consistency model of the transactional memory unspecified. The rules 
of our operational semantics will be parametric in the specification of a consistency 
model, using the style of specification proposed in \cite{laws}. 

\paragraph{\textbf{Syntax of Programs}}
We assume a set of (primitive) transactional commands $\primt,\primt',\cdots$, which 
we leave unspecified. Each transactional command $t$ is associated to a \emph{state transformer} 
$\mathcal{S}_t \subseteq (\thdstackset \times \txstackset \times \heapset) \times (\txstackset \times \heapset)$. 
We use the notation $(\thdstack, \txstack, \heap) \rightsquigarrow_t (\txstack' \times \heap')$ 
in lieu of $(\thdstack, \txstack, \heap, \txstack', \heap') \in \mathcal{S}_t$. Note that this definition ensures 
that primitive transactional commands cannot update the thread-local stack.
We also assume a set of primitive (non-transactional) commands $\primc, \primc',\cdots$ 
that can be executed by a command outside transactions. Each primitive non-transactional 
command $\primc$ is associated with a state transformer $\mathcal{S}_t \subseteq 
(\thdstackset \times \thdstackset)$, and again we adopt the notation $\thdstack \rightsquigarrow_c 
\thdstack'$ in lieu of $(\thdstack, \thdstack') \in \mathcal{S}_c$. This definition ensures that 
thread-local stack do not access neither the transaction-local stack, nor the heap.

Often, we will assume a language of expressions at the base of primitive (transactional and non-transactional) 
commands. This language is defined by the grammar below: 
\[
E ::= n \bor \mathtt{x} \bor \mathtt{a} \bor E + E \bor E \cdot E \bor \cdots
\]
The set of all expressions is denoted by $\Expr$.
Because non-transactional commands cannot access the thread-local stack, we will 
need the following, inductively defined, predicate: 
\[
\begin{array}{lcl}
\isthdexp(n) &=& \ttrue\\
\isthdexp(\mathtt{x}) &=& \ttrue\\
\isthdexp(\mathtt{a}) &=& \ffalse\\
\isthdexp(E_1 + E_2) &=& \isthdexp(E_1) \wedge \isthdexp(E_2)\\
\vdots & \vdots & \vdots
\end{array}
\]
In general, if the language of expressions contains an operator $\mathsf{f}(E_1, \cdots, E_n)$, 
we define $\isthdexp(\mathsf{f}(E_1, \cdots, E_n)) = \bigwedge_{i=1,\cdots,n} \isthdexp(E_i)$.
The set of primitive commands we will use is given by 
\[
\begin{array}{lcl}
\primc &::=& \mathtt{x} := E \bor \assume(E)\\[4pt]
\primt &::=& \mathtt{a} := E \bor \mathtt{a} := [E] \bor [E] := E \bor \assume(E)
\end{array}
\]
where in the right-hand sides of the $\primc$ clause we always require that $\isthdexp(E) = \ttrue$.

Below we define the syntax of programs allowed by our language. 

\[
\begin{rclarray}
\Prg & ::= & \nil \mid \tid : \Cmd \Par \Prg \\
\Cmd & ::= & \nil \mid X \mid \pi.\Cmd \mid \Cmd + \Cmd \mid \mu X.\Cmd \\
\pi  & ::= & \primc \mid \TxOp{\Tx} \\
\Tx  & ::= & \nil \mid X \mid \primt.\Tx \mid \Tx + \Tx \mid  \mu X. \Tx \\
\end{rclarray}
\]
Note that each thread has a thread identifier $\tid$ associated. We require that 
the same thread identifier never appear twice in the same program. The set 
of all thread identifiers is $\tidset$.

\paragraph{\textbf{Interpretation of Expressions and Primitive Commands.}}
Expressions are going to be evaluated in values from $\mathbb{N}$ in the usual way. 
Note that we need to account for the fact that we have two different notions of 
stacks, one transaction-local, and the other thread-local. 
\[
\begin{array}{lcl}
\interpr{\cdot} &\rightarrow& \Expr \rightarrow \thdstackset \rightarrow \txstackset \rightarrow \mathbb{N}\\
\interpr{n}(\thdstack)(\txstack) & = & n\\
\interpr{\mathtt{x}}(\thdstack)(\txstack) &=& \thdstack(\mathtt{x})\\
\interpr{\mathtt{a}}(\thdstack)(\txstack) &=& \txstack(\mathtt{a})\\
\interpr{E_1 + E_2}(\thdstack)(\txstack) &=& \interpr{E_1}(\thdstack)(\txstack) + \interpr{E_2}(\thdstack)(\txstack)\\
\vdots &\vdots&\vdots
\end{array}
\]

Note that, for any expression $E$ such that $\isthdexp(E) = \ttrue$, we have 
that $\interpr{E}(\thdstack)(\txstack) = \interpr{E}(\thdstack)(\txstack')$ for 
any $\txstack, \txstack' \in \txstackset$ and $\thdstack \in \thdstackset$. 
In this case, we commit an abuse of notation and write $\interpr{E}(\thdstack)$ 
as a shortcut for $\interpr{E}(\thdstack)(\txstack_0)$, where $\txstack_0 = 
\lambda \mathtt{a} .0$.

We now proceed to define the state transformers associated to transactional and non-transactional primitive commands. 
For transactional primitive commands we have  
\[
\begin{array}{lll}
(\thdstack, \txstack, \heap) &\rightsquigarrow_{\mathtt{a} := E}& (\txstack[\mathtt{a} \mapsto \interpr{E}(\thdstack)(\txstack)], \heap)\\
(\thdstack, \txstack, \heap) &\rightsquigarrow_{\mathtt{a} := [E]}& (\txstack[\mathtt{a} \mapsto \heap(\interpr{E}(\thdstack)(\txstack))], \heap)\\
(\thdstack, \txstack, \heap) &\rightsquigarrow_{[E_1] := E_2}& (\txstack, \heap\big[\; [(\interpr{E_1}(\thdstack)(\txstack)] \mapsto 
\interpr{E_2}(\thdstack)(\txstack) \;\big])\\
(\thdstack, \txstack, \heap) &\rightsquigarrow_{\assume(E)} & (\thdstack,\heap) \hfill \impliedby \interpr{E}(\thdstack)(\txstack) \neq 0
\end{array}
\]
For non-transactional primitive commands we have 
\[
\begin{array}{llll}
\thdstack &\rightsquigarrow_{\mathtt{x} := E} \thdstack[\mathtt{x} \mapsto \interpr{E}(\thdstack)] &\impliedby \isthdexp(E) = \ttrue\\
\thdstack &\rightsquigarrow_{\assume(E)} \thdstack &\impliedby \isthdexp(E) = \ttrue \wedge \interpr{E}(\thdstack) \neq 0
\end{array}
\]

For some transactional primitive command $t$, we also defined its fingerprint $\fingerprint(t) \in 
\thdstackset \rightarrow \txstackset \rightarrow \heapset \rightarrow (\{\RD, \WR\} \times \locs \times \mathbb{N})$. 
This denotes the kind of operation that  performed by  $t$. 
\[
\begin{array}{lcl}
\fingerprint(\mathtt{a} := E) &=& \text{undefined for all } \thdstack,\txstack\\
\fingerprint(\mathtt{a} := [E])(\thdstack)(\txstack)(\heap) &=& (\RD, \big[ \interpr{E}(\thdstack)(\txstack) \big], \heap(\interpr{E}(\thdstack)(\txstack))\\
\fingerprint([E_1] := E_2)(\thdstack)(\txstack)(\heap) &=& (\WR, \big[ \interpr{E_1}(\thdstack)(\txstack) \big], \heap(\interpr{E_2}(\thdstack)(\txstack))
\end{array}
\]

\paragraph{\textbf{Semantics of Transactions.}}
The semantics of transactions is given in an operational way, 
Judgements take the form $\thdstack \vdash \langle \txstack, \heap \RS, \WS, \Tx \rangle 
\rightarrow \langle \txstack', \heap', \RS', \WS', \Tx' \rangle$. Note that in this semantics 
the $\thdstack$ component cannot be manipulated by performing a transition, as to reflect 
the fact that transactions can only read from, and never write to, the thread local heap.
The components $\RS, \WS \subseteq \locs \times \mathbb{N}$ record the read-set and write-set associated to the transaction code, 
respectively.

In order to give the semantics of transactions, it will be useful to define the following operators over sets of key-value pairs. 
\[
\begin{array}{lll}
\RS \RScup ([n], m) = \begin{cases}
\RS \cup \{([n], m)\} &\impliedby \RS \cap \{([n], m') \mid m' \in \mathbb{N}\} = \emptyset\\
\RS &\text{Otherwise}
\end{cases}\\[20pt]
\WS \WScup ([n], m) = (\WS \setminus \{([n], m') \mid m' \in \mathbb{N}\}) \cup \{([n], m)\}
\end{array}
\]

The rules of the operational semantics for transactions are the following: 
\[
\infer[{\scriptstyle{(prim-t-local)}}]
{\thdstack \vdash \langle \txstack, \heap, \RS, \WS, t.\Tx  \rangle \rightarrow \langle \txstack', \heap', \RS, \WS, \Tx \rangle}
{(\thdstack, \txstack, \heap) \rightsquigarrow_t (\txstack', \heap') \qquad \fingerprint(t)(\thdstack)(\txstack)(\heap) = \text{undefined}}
\]

\[
\infer[{\scriptstyle{(prim-t-read)}}]
{\thdstack \vdash \langle \txstack, \heap, \RS, \WS, t.\Tx  \rangle \rightarrow \langle \txstack', \heap', \RS \RScup ([n],m), \WS, \Tx \rangle}
{(\thdstack, \txstack, \heap) \rightsquigarrow_t (\txstack', \heap') \qquad \fingerprint(t)(\thdstack)(\txstack)(\heap) = (\RD, [n], m)}
\]

\[
\infer[{\scriptstyle{(prim-t-write)}}]
{\thdstack \vdash \langle \txstack, \heap, \RS, \WS, t.\Tx \rangle \rightarrow \langle \txstack', \heap', \RS, \WS \WScup ([n],m), \Tx \rangle}
{(\thdstack, \txstack, \heap) \rightsquigarrow_t (\txstack', \heap') \qquad \fingerprint(t)(\thdstack)(\txstack)(\heap) = (\WR, [n], m)}
\]

\[
\infer[{\scriptstyle{(\Tx-choice-L)}}]{\thdstack \vdash \langle \txstack, \heap, \RS, \WS, \Tx_1 + \Tx_2 \rangle 
\rightarrow \langle  \txstack, \heap, \RS, \WS, \Tx_1 \rangle}{}
\]

\[
\infer[{\scriptstyle{(\Tx-choice-R)}}]{\thdstack \vdash \langle \txstack, \heap, \RS, \WS, \Tx_1 + \Tx_2 \rangle 
\rightarrow \langle  \txstack, \heap, \RS, \WS, \Tx_2 \rangle}{}
\]

\[
\infer[{\scriptstyle{(\Tx-fix)}}]{\thdstack \vdash \langle \txstack, \heap, \RS, \WS, \mu X.\Tx \rangle 
\rightarrow \langle  \txstack, \heap, \RS, \WS, \{\nicefrac{\mu X.\Tx}{X}\}\Tx \rangle}{}
\]

\paragraph{\textbf{Abstract Executions.}}
Here we present abstract executions, which we will use to record the 
run-time behaviour of programs. 

We start by defining the behaviour of transactions at run-time. 
We assume a set of (run-time) transactions $\TrSet = \{T, S , \cdots \}$ 
and a set of operations which we leave unspecified, though 
we require that $\Op \supseteq \{ \RD\;[m]:n,\WR\;[m]:n \mid [m] \in \locs \wedge n \in \mathbb{N} \}$.
We also assume a mapping $\behav : \TrSet \rightarrow 2^{\Op}$, which maps 
transactions into the operations that they perform on locations. With an abuse of 
notation, for any transaction $T$ and operation $o$, we write $o \in T$ (or $T \ni o$) as 
a shortcut for $o \in \behav(T)$. 
We only model transaction that enjoy \emph{atomic visibility}. This 
means that \textbf{(i)} transactions never observe two different values when reading from 
the same location: $\forall T \in \TrSet.\, \forall [n] \in \locs, \forall m,m' \in \mathbb{N}.\, 
T \ni \RD\;[n]:m \wedge T \ni \RD\;[n]:m' \implies m = m'$; and \textbf{(ii)} 
the effects of a transactions become visible at once, which means that we never observe
two different values written for the same location by a transaction: $\forall T \in \TrSet.\, 
\forall [n] \in \locs, \forall m,m' \in \mathbb{N}.\, T \ni \WR\;[n]: m \wedge T \ni \WR\;[n]:m' 
\implies m = m'$.

\begin{definition}
A \emph{transaction instance} is a mapping
An abstract execution is a tuple $\aexec = (\T, \PO, \VIS, \AR)$, where 

\begin{enumerate}
\item $\T$ is a finite, empty set of transactions, 
\item $\PO \subseteq \T \times \T$, the \emph{program order}, is the union 
of disjoint, strict total orders over $\T$. That is, there exists a partition $\{\T_i\}_{i \in I}$ 
of $\T$ such that $\PO = \bigcup_{i \in I} \PO_i$, where for any $i \in I$, $\PO_i$ is a strict, 
total order over $\T_i$\footnote{Recall that a relation $R \subseteq \T \times \T$ is a strict partial order 
if it is irreflexive and transitive. It is a strict total order if it enjoys the additional property that 
for any $T_1, T_2 \in \T$, either $T_1 = T_2$, $(T_1, T_2) \in R$ or $(T_2, T_1) \in R$.},
\item $\VIS \subseteq \T \times \T$ is a strict, partial order such that $\PO \subseteq \VIS$, and $\VIS \rcomp \VIS \subseteq 
\VIS$,
\item $\AR \subseteq \T \times \T$ is a strict, total order such that $\VIS \subseteq \AR$,
\item for any location $[n] \in \locs$ let $\WTr_{[n]} = \{S \in \T \mid S \ni \WR\;[n]:\_\}$. 
Given $T \in \T$, let also $\pw_{\aexec}([n], T) = \{S \mid S \in \VIS^{-1}(T)\} \cap \WTr_{[n]})$. 
Whenever $T \ni \RD\;[n]: m$ for some transaction $T \in \T$, location $[n] \in \locs$ and 
value $m \in \mathbb{N}$, then either $\pw_{\aexec}([n], T) = \emptyset$ and $m = 0$, 
or $\max_{\AR}(\pw_{\aexec}([n], T)) \ni \WR\;[n]: m$.
\end{enumerate}

\end{definition}
The set of all abstract executions is denoted as $\aeset$.
In the following, for an abstract execution $\aexec = (\T, \PO, \VIS, \AR)$, we let 
$\T_{\aexec} = \T$, $\PO_{\aexec} = \PO$, $\VIS_{\aexec} = \VIS$, $\AR_{\aexec} = \AR$. 
We often use the notation $T \xrightarrow{R} S$ instead of $(T,S) \in R$.

\paragraph{\textbf{Specification of Weak Consistency Models.}}
We use the style of specification for weak consistency models 
proposed in \cite{laws}. 

\begin{definition}
A specification function $\rho$ is an endo-function of relations over 
transactions, $\rho: (\TrSet \times \TrSet) \rightarrow (\TrSet \times \TrSet)$,
such that for any abstract execution $\aexec$ and relation $R \subseteq \T_{\aexec} \times \T_{\aexec}$, 
$\rho(R) = \rho(\T_{\aexec} \times \T_{\aexec}) \cap R?$. 

A consistency guarantee is a pair $(\rho, \pi)$ of specification functios.
An abstract execution based specification of weak consistency models, or simply \emph{x-specification}, 
is a (possibly empty, possibly infinite) set of consistency guarantees: $\xspec = \{(\rho_i, \pi_i)\}_{i \in I}$ 
for some index set $I$.
\end{definition}

\begin{definition}
An abstract execution $\aexec$ is allowed by the consistency model specification $\xspec$, 
written $\xspec \models \aexec$, if and only if, for any $(\rho, \pi) \in \xspec$, we have that $\rho(\VIS_{\aexec}) \rcomp \AR_{\aexec} 
\rcomp \VIS_{\aexec} \subseteq \AR_{\aexec}$.
\end{definition}

\begin{example}
Let $\rho_{\Id} = \lambda \_. \Id$, $\rho_{\SI} = \lambda R. (R \setminus \Id)$, and $\rho_[n] = 
\lambda \_. [\WTr_{[n]}]$ for any location $[n] \in \locs$. Here, given a set $X \subseteq \TrSet$, 
$[X]$ is defined as $\Id \cap (X \times X)$. We specify \emph{Snapshot Isolation} via the set 
of consistency guarantees $\xspec_{\SI} = \{(\rho_{\Id}, \rho_{\SI})\} \cup \bigcup_{[n] \in \locs} \{(\rho_{[n]}, \rho_{[n]}\}$. 

An abstract execution $\aexec$ is allowed by $\xspec_{\SI}$ if and only if 
$\AR_{\aexec} \rcomp \VIS_{\aexec} \subseteq \VIS_{\aexec}$, 
and for any $[n] \in \locs$, $[\WTr_{[n]}] \rcomp \AR_{\aexec} \rcomp [\WTr_{[n]}] \subseteq \VIS$.
\end{example}

In the following, we will use an incremental approach to build abstract executions from transactions. 
Suppose that an abstract execution $\aexec$ has been obtained as the (partial) result of a program $P$ running 
in a system that implements the x-specification $\xspec$. 
Suppose also that $T \in \T_{\aexec}$ is the transaction-instance associated with the last transactional 
code that has been executed by some thread, and that the same thread executes another piece of transactional 
code next, which results in the transaction instance $S$. This may result in an abstract execution $\aexec'$, 
where the new transaction instance $S$ follows $T$ in the program order $\PO_{\aexec'}$, and $\VIS_{\aexec'}, 
\AR_{\aexec'}$ are computed according to the axioms of $\xspec$.
$T \in \T_{\aexec}$. Note that the result of this procedure may result in an abstract execution that 
is not allowed by $\xspec$, hence it is not always defined.
Formally, we define an operator $\aeplus_{\xspec} : (\aeset \times \TrSet) \rightharpoonup 
\aeset$ as follows:

\begin{definition}
Let $\xspec$ be a x-specification. 
Let $\aexec \in \aeset$, and let $T \in \T_{\aexec}$. 
Also, let $S \in \TrSet \setminus \T_{\aexec}$.
Define the abstract execution $\aexec'$ as follows: 
in which case we have
\begin{gather*}
\PO_{\aexec}' = (\PO_{\aexec} \cup \{(T,S)\})^{+}\\
\AR_{\aexec}' = \{(T', S), (S, T'') \mid T' \in \AR_{\aexec}^{-1}(T) \wedge T'' \in \AR_{\aexec}(T)\}^{+}\\
\VIS_{\aexec}' = \mu V.(\PO_{\aexec}' \cup \VIS_{\aexec} \cup \bigcup_{(\rho, \pi \in \xspec)} \rho(V) \rcomp \AR_{\aexec}' \rcomp \pi(V) )^{+}
\end{gather*}
The abstract execution $(\aexec, T) \aeplus_{\xspec} S$ is defined to be exactly $\aexec'$ 
if whenever $S \ni \WR\;[n]:\_$ and $S \xrightarrow{\VIS_{\aexec}'} T$, then $T \not\ni \RD\;[n]:\_$ 
and $T \not\ni \WR\;[n]:\_$, 
it is undefined otherwise.
\end{definition}

\begin{proposition}
Let $\xspec$ be a x-specification, and suppose that $\xspec \models \aexec$ for some abstract
execution $\aexec$. Let $T, S$ be two transactions such that $(\aexec, T) \aeplus_{\xspec} S$ is
defined. Then $\xspec \models (\aexec, T) \aeplus_{\xspec} S$.
\end{proposition}
\ac{Not sure whether it's true. Needs to be checked.}

Note that, for a transaction $T_0$ such that $T_0 \ni o$ for no operation $o \in \Op$, 
$(\aexec, T) \aeplus_{\xspec} T_0$ is always defined (provided $T_0 \notin \T_{\aexec}, T \in \T_{\aexec})$.

Given an abstract execution and a x-specification $\aexec$, we can map any transaction $T \in \T_{\aexec}$ 
to a heap $\heap_{\aexec}^{\xspec}(T)$. Intuitively, the latter corresponds to the heap that would be observed 
by a client that interact with a system implementing the x-specification $\xspec$, assuming that 
the set of transactions processed by the system so far resulted has given rise to the abstract execution 
$\aexec$, and that the last transaction instance of $\aexec$ observed by the client is $T$.

\begin{definition}
Let$\xspec$ be a consistency model specification, and $\aexec$ be an abstract execution. For any $T \in \T_{\aexec}$, 
let $\aexec' = (\aexec, T) \aeplus_{\xspec} T_0$, where $T_0 \notin \T_{\aexec}$ and $T_0 \ni o$ for no 
$o \in \Op$. We can always assume that such a transaction exists. 

We define $\heap_{\aexec}^{\xspec}(T)$ as follows:
\[
\heap_{\aexec}(T) = \lambda [n] \in \locs.
\begin{cases}
0 &\impliedby \pw_{\aexec'}([n], T) = \emptyset\\
m & \impliedby \max_{\AR_{\aexec'}}(\pw_{\aexec'}([n], T_0)) \ni \WR\;[n]: m 
\end{cases}
\]
\end{definition}
\ac{I don't really like this definition, but for the moment it will do...}

\begin{example}
Consider the abstract execution $\aexec$ depicted below, denoting the write-skew anomaly 
allowed by snapshot isolation. 

\begin{center}
\begin{tikzpicture}
\node(Rx0) {$\RD\;[1]: 0$};
\path(Rx0.center) + (0,-0.5) node (Wy1) {$\WR\;[2]: 1$};
\path(Rx0.center) + (4,0) node (Ry0) {$\RD\;[2]: 0$};
\path(Ry0.center) + (0,-0.5) node (Wx1) {$\WR\;[1]: 1$};
%
\begin{pgfonlayer}{background}
\node(t1)[background, fit=(Rx0)(Wy1), inner sep=0.15cm] {};
\node(t2)[background, fit=(Ry0)(Wx1), inner sep=0.15cm] {};
\path(t1.west) + (-0.25,0) node (T) {$T$};
\path(t2.east) + (0.25,0) node(S) {$S$};
\path[->, thick]
(t2.west) edge node[above] {$\AR$} (t1.east);
\end{pgfonlayer}
\end{tikzpicture}
\end{center}
Let us calculate $\heap_{\aexec}^{\xspec_{\SI}}(T)$. 
Let then $T_0$ be a transaction with no operation associated, 
and let us compute $\aexec' = (\aexec, T) \aeplus_{\xspec_{\SI}} T_0$. 
By definition, we have that $T \xrightarrow{\PO_{\aexec'}} T_0$, hence 
$T \xrightarrow{\VIS_{\aexec'}} T_0$. Because $S \xrightarrow{\AR_{\aexec}}T$, 
we also have that $S \xrightarrow{\AR_{\aexec}} T$, and now from 
$S \xrightarrow{\AR_{\aexec'}} T \xrightarrow{\VIS_{\aexec'}} T_0$, 
we obtain that $S \xrightarrow{\VIS_{\aexec'}} T_0$. By definition, 
we also know that $S \xrightarrow{\AR_{\aexec}} T$ implies that 
$S \xrightarrow{\AR_{\aexec'}} T_0$. The final result is the abstract 
execution $\aexec'$ depicted below: 
\begin{center}
\begin{tikzpicture}
\node(Rx0) {$\RD\;[1]: 0$};
\path(Rx0.center) + (0,-0.5) node (Wy1) {$\WR\;[2]: 1$};
\path(Rx0.center) + (4,0) node (Ry0) {$\RD\;[2]: 0$};
\path(Ry0.center) + (0,-0.5) node (Wx1) {$\WR\;[1]: 1$};
\path(Wy1.center) + (0,-2.5) node (phantom) {\phantom{$\WR\;[2]: 1$}};
%
\begin{pgfonlayer}{background}
\node(t1)[background, fit=(Rx0)(Wy1), inner sep=0.15cm] {};
\node(t2)[background, fit=(Ry0)(Wx1), inner sep=0.15cm] {};
\node(t3)[background, fit=(phantom), inner sep=0.15cm] {};
\path(t1.west) + (-0.25,0) node (T) {$T$};
\path(t2.east) + (0.25,0) node(S) {$S$};
\path(t3.west) + (-0.3,0) node(T0) {$T_0$};
\path[->, thick]
(t2.west) edge node[above] {$\AR$} (t1.east)
(t1.south) edge node[left] {$\PO, \VIS,\AR$} (t3.north)
(t2.south west) edge node[right] {\;\;\;$\VIS, \AR$} (t3.north east);
\end{pgfonlayer}
\end{tikzpicture}
\end{center}
It is easy to see that $\pw_{\aexec'}([1], T_0) = \{S\}$, and $\pw_{\aexec'}([2], T_0) = \{T\}$. 
Because $S \ni \WR\;[1]:1$, we have that $\heap_{\aexec}^{\xspec_{\SI}}(T)([1]) = 1$, 
and because $T \ni \WR\;[2]:1$, we have that $\heap_{\aexec}^{\xspec_{\SI}}(T)([2]) = 1$.

Next, we want to calculate $\heap_{\aexec}^{\xspec_{\SI}}(S)$. To this end, we need first 
to retrieve the abstract execution $\aexec'' = (\aexec, S) \aeplus_{\xspec_{\SI}} T_0$, 
which is depicted below:
\begin{center}
\begin{tikzpicture}
\node(Rx0) {$\RD\;[1]: 0$};
\path(Rx0.center) + (0,-0.5) node (Wy1) {$\WR\;[2]: 1$};
\path(Rx0.center) + (4,0) node (Ry0) {$\RD\;[2]: 0$};
\path(Ry0.center) + (0,-0.5) node (Wx1) {$\WR\;[1]: 1$};
\path(Wx1.center) + (0,-2.5) node (phantom) {\phantom{$\WR\;[1]: 1$}};
%
\begin{pgfonlayer}{background}
\node(t1)[background, fit=(Rx0)(Wy1), inner sep=0.15cm] {};
\node(t2)[background, fit=(Ry0)(Wx1), inner sep=0.15cm] {};
\node(t3)[background, fit=(phantom), inner sep=0.15cm] {};
\path(t1.west) + (-0.25,0) node (T) {$T$};
\path(t2.east) + (0.25,0) node(S) {$S$};
\path(t3.east) + (0.25,0) node(T0) {$T_0$};
\path[->, thick]
(t2.west) edge node[above] {$\AR$} (t1.east)
(t2.south) edge node[right] {$\PO, \VIS,\AR$} (t3.north)
(t3.north west) edge node[right] {\;\;\;$\AR$} (t1.south east);
\end{pgfonlayer}
\end{tikzpicture}
\end{center}
In this case we have that $\pw_{\aexec''}([1],T_0) = \{S\}$, 
and $\pw_{\aexec''}([2], T_0) = \emptyset$. By definition, 
we have that $\heap_{\aexec}^{\xspec_{\SI}}(S)([1]) = 1$, 
and $\heap_{\aexec}^{\xspec_{\SI}}(S)([2]) = 0$.
\end{example}

\paragraph{\textbf{Semantics of Commands.}}
Judgements for programs take the form 
$\langle \aexec, T, \thdstack \Cmd \rangle \rightarrow \langle \aexec', T',  \thdstack', \Cmd' \rangle
$.Here $\aexec$ is an abstract execution that represent 
the global run of the database, 
$T$ represents the last transaction executed by the command, in the abstract execution, 
and $\thdstack$ is the thread local stack associated with the transaction.

The rule for evaluating a non-transactional primitive command is straightforward, as it 
does only require to manipulate the thread-local stack associated  with the command. 
\[
\infer[{\scriptstyle{(prim-c)}}]
{\langle \aexec, T, \thdstack, \primc.\Cmd \rangle \rightarrow \langle \aexec, T, \thdstack', \Cmd \rangle}
{\thdstack \rightsquigarrow_c \thdstack'} 
\]

Next, we give the rule for evaluating a transaction in a command of the form $\TxOp{\Tx}.\Cmd$. 
First, given a read-set $\RS$ and a write-set $\WS$, we define the set of transaction $\makeTx(\RS,\WS)$ 
to be the largest set of transactions such that, whenever $T \in \makeTx(\RS, \WS)$, then $T \ni \RD\;[n]:m$, if and only if $([n], m) \in \RS$, and $T \ni 
\WR\;[n]:m$ if and only if $([n], m) \in \WS$. 
\[
\infer[{\scriptstyle{(Tx-exec)}}]{\langle \aexec, T, \thdstack, \TxOp{\Tx}.\Cmd \rangle \rightarrow 
\langle \aexec', T', \thdstack[\retvar \mapsto \txstack'(\retvar)], \Cmd \rangle}
{
\begin{array}{lll}T \xrightarrow{\AR_{\aexec}} S &  T' \in (\makeTx(\RS,\WS) \setminus \T_{\aexec}) & \aexec' = (\aexec, S) \aeplus_{\xspec} T'\\[4pt]
\multicolumn{3}{c}{\thdstack \vdash \langle \txstack_0, \heap_{\aexec}^{\xspec}(S), \emptyset, \emptyset, \Tx \rangle \rightarrow^\ast \langle \txstack', \heap', \RS, \WS, \nil \rangle}
\end{array}}
\]
The three remaining rules are standard.
\[
\infer[{\scriptstyle{(C-choice-L)}}]
{\langle \aexec, T, \thdstack, \Cmd_1 + \Cmd_2 \rangle \rightarrow \langle \aexec, \Cmd_1, \thdstack, \Cmd \rangle}
{} 
\]

\[
\infer[{\scriptstyle{(C-choice-R)}}]
{\langle \aexec, T, \thdstack, \Cmd_1 + \Cmd_2 \rangle \rightarrow \langle \aexec, \Cmd_2, \thdstack, \Cmd \rangle}
{} 
\]

\[
\infer[{\scriptstyle{(C-fix)}}]
{\langle \aexec, T, \thdstack, \mu X.\Cmd \rangle \rightarrow \langle \aexec, \{\nicefrac{\mu X.\Cmd}{X}\}\Cmd, \thdstack, \Cmd \rangle}
{} 
\]

\paragraph{\textbf{Semantics of Programs.}}

\bibliographystyle{abbrv}
\bibliography{bibliography2}

\end{document}

