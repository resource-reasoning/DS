In this Section we propose an alternative 
semantics of programs. In this semantics, states 
correspond to \emph{abstract executions} \cite{framework-concur}, 
overloaded with information regarding the transactions that are made 
visible to individual threads. 
The abstract execution semantics provides a bridge between specification 
of consistency models given in terms of history heaps, and the declarative 
specification of consistency models, which have been already proved 
to be equivalent to the operational definitions of such consistency models 
given in the literature. This section makes the following contributions: 
\begin{itemize}
\item a definition of (overloaded) abstract executions, and an encoding 
into history heaps and views,
\item an operational semantics based on (overloaded) abstract executions, 
which is parametric in the specification of a consistency model given using 
the declarative style of \cite{framework-concur,SIanalysis,laws},
\item a proof that the semantics is \emph{thorough}: for any program $\prog$ and consistency model specification $\mathsf{x-CM}$, 
the abstract execution semantics captures all the potential behaviours that $\prog$ can 
exhibit under $\mathsf{x-CM}$. Thoroughness is necessary to validate the soundness of 
any program analysis techniques, such as program logics, with respect to arbitrary consistency model 
specifications,
\ac{Before I ws referring to what I call thoroughness as completeness. I am now changing this, because 
it looks like it only created confusion. In short words, this result requires defining the anarchic model 
of transactions - one in which the database actually reads and writes non-deterministic values 
despite the client requests, and prove that any abstract execution which is 
valid w.r.t. $\mathsf{x-CM}$ and can be obtained in the anarchic semantics, can also be obtained 
in the $\mathsf{x-CM}$ semantics. More details on this later.} 
\item a proof that the specifications of consistency models in terms of history heaps 
are sound and complete with respect to the specifications of history heaps given 
in terms of abstract execution: 
\begin{description}
\item[Soundness - ] for any program $\prog$, any execution of 
$\prog$ under the history heap semantics and consistency model 
specification $\mathsf{CM}$ can be simulated by an execution 
of $\prog$ under the abstract execution semantics and the 
declarative specification of $\mathsf{CM}$, 
\item[Completeness - ] for any program $\prog$, any 
execution of $\prog$ under the abstract execution semantics 
and the declarative specification of $\mathsf{CM}$ 
can be simulated by an execution of $\prog$ under the history 
heap semantics and consistency model specification $\mathsf{CM}$.
\end{description}
\end{itemize}

\subsection{Overloaded Abstract Executions}

\ac{Note to self - Stop Here! I reaaally need to put everything into a consistent state before proceeding. 
Inconsistency of the document was fine up to now, but now that I am going into theorems 
and proofs I cannot be inconsistent anymore. Go back to square one, fix everything, then repeat 
another time.}


\begin{definition}
An overloaded abstract execution (OAE) is a tuple $\hat{\aexec} = (\mathscr{T}, \I, \PO, \VIS, \AR)$ where: 
\begin{enumerate}
\item $\mathscr{T} : \TransID \rightharpoonup 2^{\Op}$ is a set of transactions, each of which is equipped with a set of 
operations.
\item $\I \subseteq \tidset$ is a set of thread identifiers.
\item $\PO \subseteq (\dom(\mathscr{T}) \times \dom(\mathscr{T}) \cup \I$ is the program order, and it corresponds 
to the union of total orders defined over a partition of $\dom(\mathscr{T}) \cup \I$ that also partitions 
$\I$ into singletons. That is, for any $\tid \in \I$ there exists a subset $\T_{\tid}$ of $\dom(\mathscr{T})$ 
such that for any $\tid,\tid' \in \I$, $\T_{\tid} \cap \T_{\tid'} \neq \emptyset \implies \tid = \tid'$; 
$\bigcup_{\tid \in \I} \T_{\tid} = \dom(\mathscr{T})$; 
for each $\tid \in \I$ there exists a strict, total order $\PO_{i} \subseteq \T_{\tid} \times (\T_{\tid} \cup \{\tid\})$, 
and $\PO = \left( \bigcup_{\tid \in \I} \PO_{\tid} \right)$.
\item $\VIS \subseteq \dom(\mathscr{T}) \times \dom(\mathscr{T})$ is a partial order, 
\item $\AR \subseteq \dom(\mathscr{T}) \times \dom(\mathscr{T})$ is a total order such that $\VIS \subseteq \AR$.
\end{enumerate}
\end{definition}

