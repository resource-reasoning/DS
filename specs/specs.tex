\subsection{Specifications of Consistency Models}
\begin{figure}
\begin{tabular}{ l @{} r }
\hline
Consistency Model & Execution Test: \((\hh, \vi) \csat \opset : \vi'\)\\
\hline
\MRd & $\vi \viewleq \vi'$\\
\MW & 
$j \in \vi(\ke) \wedge \WTx(\hh(\ke', i)) \xrightarrow{\PO?} \WTx(\hh(\ke, j)) 
\implies i \in \vi(\ke')$
\\
\RYW & $ \mkvs' = \updateKV(\hh, \vi, \txid, \opset) \implies \WTx( \mkvs'(\ke, i) ) \leq \txid \implies i \in \vi'(\ke) $\\
\WFR & $j \in \vi(\ke) \wedge \txid \in \RTx(\hh(\ke', i)) \wedge \txid {\xrightarrow{\PO?}}
\WTx(\ke, j) ) \implies i \in \vi(\ke')$\\
\CC & $\ET_{\CC} = \ET_{\MRd} \cap \ET_{\MW} \cap \ET_{\RYW} \cap \ET_{\WFR}$\\
\hline
\hline
\UA & $(\otW, \ke,  \stub) \in \opset \land 0 \leq i < \lvert \hh(\ke) \rvert \implies i \in \vi(\ke) $\\
\CP & \( \Setcon{(\mkvs, \vi, \f, \vi')}{\ddagger} \cap \ET_\MRd \cap \ET_\RYW \) \\
\PSI & $\ET_{\PSI} = \ET_{\CC} \cap \ET_{\UA}$\\
$\SI$ & $\Setcon{(\mkvs, \vi, \f, \vi')}{\dagger} \cap \ET_\MRd \cap \ET_\RYW  \cap \ET_\UA $\\
\SER & $ 0 \leq i < \lvert \hh(\ke) \rvert \implies  \in \vi(\ke) $\\
\hline
\end{tabular}

\[
    \begin{rclarray}
        \func{RW^{-1}}{\mkvs, \ke, i} & \defeq & \Setcon{\txid}{\exsts{ j < i } \txid \in \RTx(\mkvs(\ke,j))} \\
        \func{SO^{-1}}{\txid} & \defeq & \Setcon{\txid'}{ \exsts{ \cl, m, n } \txid = \txid_{\cl}^{n} \land \txid' = \txid_{\cl}^{m} \land m < n } \\
        \dagger & \equiv &
        \begin{array}[t]{@{}l@{}}
            \fora{\ke, \ke', i, j, m, \txid, \txid', \txid''} \\
            \begin{array}{@{}l@{}}
            i \in \vi(\ke) 
            \land \txid \in \Set{\WTx(\mkvs(\ke,i))} \cup \func{RW^{-1}}{\mkvs, \ke, i} \land {} \\
            \quad \left(
                \begin{array}{@{}l @{}}
                    \left( \begin{array}{@{}l@{}}
                        \txid' \in \func{SO^{-1}}{\txid}
                        \land \txid' \in \Set{\WTx(\mkvs(\ke',j))} \cup  \RTx(\mkvs(\ke',j))
                    \end{array} \right)  \lor {} \\
                    \left( \begin{array}{@{}l@{}}
                        \txid \in \RTx(\mkvs(\ke',j)) 
                        \land \txid' = \WTx(\mkvs(\ke',j))
                    \end{array} \right) \lor {} \\ 
                    \left( \begin{array}{@{}l@{}}
                        \txid = \WTx(\mkvs(\ke',m)) 
                        \land \txid' = \WTx(\mkvs(\ke',j)) \land m > j
                    \end{array} \right) 
                \end{array}
                \right)  \\
            \qquad \implies j \in \vi(\ke') 
            \end{array}
        \end{array} \\

        \ddagger & \equiv &
        \begin{array}[t]{@{}l@{}}
            \fora{\ke, \ke', i, j, m, \txid, \txid', \txid''} \\
            \left( \begin{array}{@{}l@{}}
            i \in \vi(\ke) 
            \land \txid \in \Set{\WTx(\mkvs(\ke,i))} \cup \func{RW^{-1}}{\mkvs, \ke, i} \land {} \\
            \quad \left(
                \begin{array}{@{}l @{}}
                    \left( \begin{array}{@{}l@{}}
                        \txid' \in \func{SO^{-1}}{\txid}
                        \land \txid' \in \Set{\WTx(\mkvs(\ke',j))} \cup  \RTx(\mkvs(\ke',j))
                    \end{array} \right)  \lor {} \\
                    \left( \begin{array}{@{}l@{}}
                            \txid \in \RTx(\mkvs(\ke',j)) \land \txid' = \WTx(\mkvs(\ke',j))
                    \end{array} \right)
                    \end{array} \right) 
                \end{array}
                \right)  \\
                {} \lor \left( \begin{array}{@{}l@{}}
                        i \in \vi(\ke) \land \ke = \ke' \land j < i
                \end{array} \right) \\
                \qquad \implies j \in \vi(\ke') 
        \end{array} \\
    \end{rclarray}
\]
\caption{Execution tests for both client-centric (top) and data-centric consistency (bottom) models. 
    %The condition column define a necessary and sufficient condition for inferring $\ET_{\CM} \vdash (\hh, \vi) \csat \opset : \vi'$.
All the free variables are universally quantified.
}
\label{fig:execution.tests}
\label{fig:execution-tests}
\end{figure}

\input{\RootPath/specs/anomalies-fig.tex}

We now give the execution tests for widely adopted consistency models of distributed and replicated databases. 
These are summarised in \cref{fig:execution.tests}.
Following \cite{distrprinciples}, we distinguish between client-centric and data-centric consistency models. 
The former constrain the versions of keys that individual clients can observe. 
%such consistency models  
%include the session guarantees from \cite{terry1994sessions}, namely \emph{monotonic reads} (\MRd), \emph{monotonic writes} (\MW), \emph{read your writes} (\RYW) and \emph{write follows reads} (\WFR).
%The client-centric consistency model is also known as \emph{session guarantees} \cite{terry1994sessions}.
The latter impose conditions on the shape of the state of the database, in our case the structure of the kv-store.
%The data-centric consistency models include \emph{update atomic} (\UA), \emph{consistent prefix} (\CP) and \emph{serialisability} (\SER).
%The remained models are combinations of both types, including \emph{causal consistency} (\CC), \emph{parallel snapshot Isolation} (\PSI) and \emph{snapshot Isolation} (\(\SI\)).
%Both kinds of models can be induced by execution tests. 
In \cref{sec:spec-proof} we prove that specification of consistency models using execution tests
are both sound and complete with respect to alternative specifications from the literature.
Due to space constraints, we only give examples of allowed and disallowed key-value stores for relevant consistency models. 

\paragraph{Monotonic Reads ($\MRd$).}
It ensures that read operations from subsequent transactions always return a more up-to-date versions.
For example, the key-value store of \cref{fig:mr-disallowed} is disallowed by $\MRd$.
Because the client $\cl$ first observes the latest version of $\ke$ in $\txid_{\cl}^{1}$,
then it observes the initial version of $\ke$ in $\txid_{\cl}^{2}$.
The execution test $\ET_{\MRd}$ prevents this scenario by forcing clients to always update their views to newer ones. 
%Because the versions observed by a client of a kv-store 
%are determined by the view of the former, monotonic reads can be enforced in our framework by ensuring that 
%a client can never replace its view with an older one. According to the definition of $\CMs(\_)$, 
%a client can only update its view to an older one upon committing a transaction. 
%$\ET_{\MRd}$ in \cref{fig:execution.tests} forces clients to always update their views to newer ones.

\paragraph{Monotonic Writes ($\MW$).}
It states that whenever a transaction observes the effects of a version installed by some client $\cl$,
then the transaction observes all the transactions executed by the client. 
It prevents the scenario of \cref{fig:mw-disallowed}, 
where transaction $\txid'$ observes the second version of $\ke_2$ carrying value $\val_2$, written by client $\cl$;
but it does not observe the second version of $\ke_1$ carrying value $\val_1$, previously written by the same client.
The execution test $\ET_{\MW}$ (\cref{fig:execution.tests}) ensures that, prior to executing a transaction,
the set of versions included in the view of the client must be prefix-closed with respect to the relation $\xrightarrow{\PO}$.
%The order of updates of transaction identifiers is embedded in the set of transaction identifiers, 
%and it is given by $\txid \xrightarrow{\PO} \txid' \iff \exists \cl, n,m. n < m \wedge \txid = \txid_{\cl}^{n} \wedge 
%\txid' = \txid_{\cl}^{m}$. 

\paragraph{Read Your Writes (\RYW).}
It states that a client must always be able to read any version of a key that was previously written by the same client.
This prevents the key-value store of \cref{fig:ryw-disallowed}. 
In the \cref{fig:ryw-disallowed}, the initial version of $\ke$ carries value $0$, 
and the client $\cl$ tries to increment the value of $\ke$ by $1$ twice.
For the first time, it reads the initial value $0$ and then installing a new version carrying  value $1$ within a single transaction.
However, since the client does not need to read its own writes, 
the client might read the initial value $0$ again in the second increment transaction \( \txid_\cl^2 \),
and install a new version carrying value $1$.
The Read Your Writes ($\RYW$) (\cref{fig:execution.tests}) enforces that after committing a transaction, 
a client includes all the versions it wrote.  
%A client always appends the version of a key written by  
%a transaction at the tail of the version list for such a key. Therefore, to enforce the 

\paragraph{Write Follows Reads (\WFR).}
It states that if a client \( \cl \) writes some version $\ver$ in a transaction,
following  another transaction (or in the same transaction of) who reads of some version $\ver'$, 
then a transaction may observe version $\ver$ only if it also observes $\ver'$. 
The Write Follow Reads ($\WFR$) disallows the scenario of \cref{fig:wfr-disallowed} 
where a transaction $\txid$ observes the version $\ver_2$ of $\ke_2$ carrying value $\val_2$ written by client $\cl$,
but the same transaction $\txid$ does not observe the version of $\ke_1$ carrying value $\val_1$, read by $\cl$ prior to writing $\ver$. 
The execution test $\ET_{\WFR}$ (\cref{fig:execution.tests}) prevents this scenarios 
by enforcing a view includes all the versions previous read by some client \( \cl \), 
if the view already include a write from that client \( \cl \).

\paragraph{Causal Consistency (\CC).}
Causal Consistency requires that if a client observes a version $\ver$, 
then it must also observe any version $\ver'$ from which $\ver$ potentially depends \cite{cops}. 
The dependency here means session order and write-read relation.
For session order, it means when a view includes some effect from a client, 
it must include previous effect from the same client.
For write-read relation, it means when a view includes a transaction (the versions it write),
it must include all the writes that the transaction read from.
A necessary and sufficient condition is to enforce the four session guarantees $\MRd, \MW, \RYW$ and $\WFR$ \cite{session2causal}.
Therefore, we let $\ET_{\CC} = \ET_{\MRd} \cap \ET_{\MW} \cap \ET_{\RYW} \cap \ET_{\WFR}$. 
%By \cref{prop:et.compositional}, 
%kv-stores disallowed by causal consistency are exactly the kv-stores disallowed by at least one of the 
%four session guarantees.
%However, for the sake of completeness we prefer to 
%give a definition of execution test for causal consistency after the standard definition. 
%The notion of \emph{potential dependency} $\xrightrrow{\pdep}$ between versions is defined by 
%letting $\ver \xrightarrow{\pdep} \ver'$ if  
%$\exists \txid, \txid'. \txid \in \{\WTx(\ver)\} \cup \RTx(\ver) \wedge 
%\txid' \in \{\WTx(\ver')\} \cup \RTx(\ver') \wedge \txid \xrightarrow{\SO} \txid'$: 
%this corresponds to the intuition that operations within a session potentially depends from previous operations in the same session.
%The notion of \emph{potential data dependency} between versions is given 
%by $\ver \xrightarrow{\ddep} \ver'$ if $\WTx(\ver') \in  \RTx(\ver)$.

\paragraph{Update Atomic ($\UA$).}
This consistency model has been proposed in \cite{framework-concur}, 
though we are not aware of any implementation. 
However, many implemented consistency models can be obtained by strengthening Update Atomic.
Update Atomic disallows concurrent transactions writing to the same key. 
This property is known as \emph{write conflict detection}.
For example, $\UA$ prevents the key-value store of \cref{fig:ua-disallowed},
where two transactions $\txid, \txid'$ concurrently increment the initial version of $\ke$ by $1$.
Note that this scenario generalises the one exhibited by $\RYW$, 
since we do not require $\txid, \txid'$ to be executed by the same client.
%(in fact, the kv-store to the right is allowed by causal consistency and monotonic writes).
To prevent this scenario, the execution test $\ET_\UA$ requires that 
a client $\cl$ can write to key $\ke$ in a transaction,
only if its view prior to the execution includes the last version of $\ke$.
%framework, we can compute the set of transactions that are concurrent by transaction $\txid$ 
%immediately before executing such a transaction. At the moment a client $\cl$ tries to 
%commit the effects of transaction $\txid$, then any transaction $\txid'$ that read or wrote versions not included 
%in the view of $\cl$ is concurrent to $\txid$. Following this intuition, we can enforce write 
%conflict detection by requiring that whenever a client $\cl$ wants to commit the effect of 
%transactions writing key $\ke$ in the kv-store $\hh$, then the view of $\cl$ must include all the versions of $\ke$. 
%Formally, this leads to the execution test $\ET_{\UA}$ defined in \cref{fig:execution.tests}

\paragraph{Consistent Prefix ($\CP$).}
\label{para:cp}
In centralised databases, where there is a total order in which transactions commit, 
Consistent Prefix is described by the following property: 
if a client observes the effect of a transaction $\txid$,
then it also observe the effect of any transaction $\txid'$ that commits before $\txid$.
It is difficult to formulate in key-value store,
because key-value stores do not contain the full information about the total order in which transactions committed. 
Inspired by dependency graph \cite{.....},
there are minimum observable transactions for each transaction derived from the following:
\[
    \SO  \subseteq  \VIS \qquad
    ( ( ( \SO \cup \WR ) ; \RW? )^* \cup \WW ) ; \VIS \subseteq \VIS
\]
where the \( R? \) is the reflexive closure of the relation \( R \) 
and \( R_1 ; R_2 \defeq \Setcon{(a,b)}{\exsts{c} (a,c) \in R_1 \land (c,b) \in R_2 } \) is the composition of the two relation.
The session order relation \( (\txid, \txid') \in \SO \) means the session order;
write-read relation \( (\txid, \txid') \in \WR \) means \( \txid' \) reads the write of \( \txid \);
read-write relation \( (\txid, \txid') \in \RW \) means \( \txid' \) read a old version of a key 
and \( \txid' \) installs a new version for the same key;
and \( (\txid, \txid') \in \VIS \) means the view exactly before \( \txid' \) should include all effect \( \txid \).
Given the minimum observable transactions, we can specify $\CP$. 
First, \( \SO \subseteq \VIS \) means a transaction observes all previous transactions from the same client,
and it is enforced by \( \ET_\RYW \).
Then the combination of \( \ddagger\) (\cref{fig:execution-tests}) and \( \ET_\MRd \) gives us \( ( ( ( \SO \cup \WR ) ; \RW? )^* \cup \WW ) ; \VIS \subseteq \VIS \).
Let consider a client \( \cl \) and the view \( \vi \).
Assume two transactions \( \txid, \txid' \)  such that \( \txid' \) is in the view \( \vi \) and \( \txid \toEdge{( ( ( \SO \cup \WR ) ; \RW? )^* \cup \WW )} \txid' \).
If \( \txid' \) is a transaction already observable by some previous transaction from the client \( \cl \), 
the transaction \( \txid \) must be observable by that time,
therefore by the \( \ET_\MRd \), the transaction \( \txid \) is in the current view \( \vi \).
Otherwise, if \( \txid' \) is a transaction that is first time observed by the client \( \cl \),
the \( \dagger \) predicate enforces \( \txid \) is also in the view \( \vi \).
Intuitively, the \( \CP \) disallows that a transaction observes updates in different order (\cref{fig:cp-disallowed-1}).
In \cref{fig:cp-disallowed-1}, transactions $\txid_{3}$ and \( \txid_4 \) observes updates in different order.
That is, \( \txid_3 \) observes that the update of $\ke_2$ carrying value $\val_2$ happens before the update of $\ke_1$ carrying value $\val_2$,
yet $\txid_{4}$ observes that the update of $\ke_1$ carrying value $\val_1$ happens before the update of $\ke_2$ carrying value $\val_2$. 
\ac{
    \sx{ Not sure I understand the words but the counterexample has  been ruled out by \( \ddagger \). 
         It looks like the same as observe update in different order without having a transaction actually reading. }
The second property required by $\CP$ is that at any given time, 
a client observes the effects of all the transactions that  
executed before the last transaction that such a client executed. 
This property prevents a scenario like the one depicted to the 
right: client $\cl$ does not observe the update to $\ke_2$ performed 
by $\cl'$, and $\cl'$ does not observe the update to $\ke_1$ performed 
by $\cl$. This property can be formalised by requiring that, after 
a client executes a transaction, its view is shifted to the most recent 
view of the data. The execution test $\ET_{\CP}$ is defined formally 
in \cref{fig:execution.tests}; in \cref{sec:?} we prove that our specification  
of $\CP$ using execution tests is precise. 
}

\sx{introduce transaction in a view before}
%First, clients agree on the order in which transactions install versions in a kv-store; 
%and a client $\cl$ always observes all the transactions that executed before its last transaction. 


%Recall that in our setting clients shift their view upon executing the 
%transaction: the initial view abstracts the starting point of the 
%transaction, while the final view abstracts its commit point.
%Following this intuition, we compute an 
%under-approximation $\CBef_{\CP}(\cl, \vi, \hh, \opset)$ 
%of the set of transactions that a client $\cl$ with view $u$ 
%must observe to have committed, when executing a transaction with 
%fingerprint $\opset$. The definition of $\CBef_{\CP}$ is recursive, 
%and follows an approach similar to the one proposed in \cite{laws}.
%Formally, we let $\CBef_{\CP}(\cl, \vi, \hh, \opset)$ 
%be the smallest set such that for all $i, j, j', n, m \in \Nat$, $\ke, \ke' \in \Keys$, 
%$\val \in \Val$ and $\cl' \in \Clients$:
%\[
%\begin{array}{l}
%%Base Cases
%(\otR, \ke, \val) \in  \opset \implies   \WTx(\hh(\ke, \vi)) \in \CBef_{\CP}(\cl, \vi, \hh, \opset)\\
%%(\oTW, \ke, \val) \in \opset \implies  \WTx(\hh(\ke, i)) \in \CBef_{\CP}(\cl, \vi, \hh, \opset)\\
%\txid_{\cl}^{n} \text{ appears in } \hh \implies \txid_{\cl}^{n} \in \CBef_{\CP}(\cl, \vi, \hh \opset)\\
%%Inductive Cases
%% \WR \subseteq \AR
%(\RTx(\hh(\ke, i)) \cap \CBef_{\CP}(\cl, \vi, \hh, \opset) \neq \emptyset \implies  \WTx(\hh(\ke,i)) \in \CBef_{\CP}(\cl, \vi, \hh, \opset)\\
%%\VO \subseteq \AR
%i < j \wedge \WTx(\hh(\ke,j)) \in \CBef_{\CP}(\cl, \vi, \hh, \opset) \implies  \WTx(\hh(\ke, i)) \in \CBef_{\CP}(\cl, \vi, \hh, \opset)\\
%% PO \subseteq \AR 
%m \leq n \wedge \txid_{\cl}^{n} \in \CBef_{\CP}(\cl, \vi, \hh, \opset) \implies  \txid_{\cl}^{m} \in \CBef_{\CP}(\cl, \vi, \hh, \opset)\\
%% RF;RW \subseteq \AR
%\txid \in \RTx(\hh(\ke, i)) \cap \RTx(\hh(\ke', j)) \wedge j < j' \wedge \WTx(\hh(\ke', j')) \in \CBef_{\CP}(\cl, \vi, \hh, \opset) 
%\implies \\ \hspace{20pt} \WTx(\hh(\ke, i)) \in \CBef_{\CP}(\cl, \vi, \hh, \opset)\\
%%\PO;RW \subseteq \AR 
%m < n \wedge \txid_{\cl}^{n} \in \RTx(\hh(\ke,i)) \wedge i < j \wedge \WTx(\hh(\ke, j)) \in \CBef_{\CP}(\cl, \vi, \hh, \opset) 
%\implies \\ \hspace{20pt} \txid_{\cl}^{m} \in \CBef_{\CP}(\cl, \vi, \hh, \opset)
%\end{array}
%\]
%\begin{itemize}
%\item if $(\oTR, \ke, \_) \in \opset$, then $\WTx(\hh(\ke, u)) \in \CB(\hh, \vi, \opset)$: 
%because the $\txid_{\mathsf{now}}$ reads the version of 
%$\ke$ at $\hh(\ke, \vi)$, then the transaction $\txid$ that wrote such 
%a version must commit before $\txid_{\mathsf{now}}$,
%\item for any $\txid_{\cl}^{n}$ appearing in the kv-store, $\txid_{\cl}^{n} 
%\in \CB(\cl, \vi, \hh, \opset)$: any previous transaction executed by $\cl$ 
%must commit before $\txid_{\mathsf{now}}$, 
%\item 
%\end{itemize}
%However, suppose that in the kv-store $\hh$, a client $\cl$ with view $\vi$
%wants to execute a transaction with fingerprint $\opset$. In the case 
%that $(\otR, \ke, ) \in \opset$, then we can observe the following: 
%\begin{itemize}
%\item{\color{red} note to self: in CP $\AR_{\CP} = (\PO \cup \RF \cup \VO \cup \PO;\AD \cup \RF;\AD)^{+}$}
%\item the client will read the value of $\ke$ from the version $\hh(\ke,u)$. 
%For this to be possible, the transaction $\WTx(\hh(\ke,u))$ must have committed 
%before the transaction to be executed by $\cl$, {\color{red} Note to self: base case}, 
%\item for any client $\cl'$ and index $n$, $\txid_{\cl'}^{m}$ commits before $\txid_{\cl}^{n}$ 
%for all $m < n$, {\color{red} - case $\PO \subseteq \AR_{\CP}$}
%\item for any key $\ke'$ and index $i$, the transaction $\WTx(\hh(\ke', i))$ commits 
%before all of the transactions in $\RTx(\hh(\ke', i))$, {\color{red} - case $\RF \subseteq \AR_{\CP}$}, 
%\item for any $\ke'$ and index $i$, then $\WTx(\hh(ke', j))$ commits before $\WTx(\hh(\ke', i))$ for 
%any $j < i$,  {\color{red} - case $\VO \subseteq \AR_{\CP}$}
%\item for any $\ke'$ and integers $i,n$, if $\txid_{\cl'}^{n} \in \RTx(\hh(\ke', i))$, 
%then for any $j: i < j \leq \lvert \hh(\ke') \rvert - 1$, and index $m < n$, then 
%$\txid_{\cl'}^{m}$ commits before $\WTx(\hh(\ke,j))$ {\color{red} - to be explained 
%why: intuitively if $\txid_{\cl'}^{m}$ committed after $\WTx(\hh(\ke, j))$, 
%then $\txid_{\cl}^{m}$ would start after $\WTx(\hh(\ke, j))$ committed, 
%hence it would not be able to read a former version of $\ke$. This case corresponds 
%to $\PO; \AD \subseteq \AR_{\CP}$},
%\item for any $\ke',\ke''$ and indexes $i,j$, if $\txid \in \RTx(\hh(\ke', i)) \cap 
%\RTx(\hh(\ke'', j))$, then for any $j': j < j' \leq \lvert \hh(\ke'') \rvert - 1$, 
%$\WTx(\hh(\ke',i))$ comitted before $\WTx(\hh(\ke'', j'))$ {\color{red} 
%explanation similar to the case above - this is the case $\RF ; \AD \subseteq \AR_{\CP}$}, 
%\item if $\txid$ committed before $\txid'$, and $\txid'$ committed before $\txid''$, 
%then $\txid$ committed before $\txid''$.
%\end{itemize}
%We can define a relation $\mathsf{CommitBefore}_{\CP}(\hh, \cl, \vi, \ke)$ that 
%includes all the transactions that we know must have committed prior to the 
%execution of a transaction from client $\cl$, whose view on $\hh$ is $\vi$, 
%assuming that said transaction will read value $\ke$.
%Using a technique similar to the one proposed in \cite{laws}, it is possible to prove 
%that for $\cl$ to execute safely a transaction with fingerprint $\opset$, 
%then for each $\ke$ that is read in $\opset$, the view of $\cl$ must include 
%at least the transactions in $\mathsf{CommitsBefore}_{\CP}$. Following this intuition, 
%we let 
%\[ 
%\ET_{\CP} \vdash \hh, \vi \triangleright \opset: \vi' \iff 
%\forall (\otR, \ke, \_) \in \opset.\; \forall \ke', j. \WTx(\hh(\ke', j)) \in \mathsf{CommitBefore}_{\CP}(\hh, \cl, \vi, \ke) 
%\implies j \leq \vi(\ke)
%\]

%{\color{red} the execution test as it is right now does not enforce consistent 
%prefix. An alternative would be to encode kv-stores into dependency graphs, 
%define the relation $\mathsf{CB} = 
%((\PO \cup \RF) ; \AD?) \cup \VO)^{+}$ - I know, it does not make any sense, 
%will try to explain at the meeting - and require that if $\txid$ is included 
%in a view $\vi$, then all the transactions $\txid'$ such that $\txid' \xrightarrow{\mathsf{CB}} 
%\txid$ must also be included in $\txid$. This works, but the problem is going to be how 
%to explain it to people.}
%An alternative 
%formulation is that concurrent transactions never observe updates on the kv-store 
%in different order. Consistent Prefix prevents the scenario depicted to the right: 
%transactions $\txid_4$ reads the up-to-date version of $\ke_1$ and a stale version 
%of $\ke_2$; in contrast, transaction $\txid_3$ reads a stale version of $\ke_2$ and 
%an up-to-date version of $\ke_1$.
%The execution test $\ET_{\CP}$ prevents this scenario by requiring that, immediately 
%after committing a transaction $\txid$, a client $\cl$ brings its view to point to the 
%most recent version of each key: this amount to require that the next time that $\cl$ 
%executes a transaction, it will observe at least the effects of all the transactions that 
%committed before $\txid$.
%By Looking at the structure 
%of a kv-store, it is not immediate to infer a total order in which transactions have been 
%executed (this problem has been analysed in a slightly different setting, see \cite{SIanalysis,laws} 
%for details). An equivalent definition of consistent prefix requires that different clients 
%never see updates to the kv-stores performed in different order. We can enforce this property 
%by strengthening causal consistency with the requirement that clients, 
%after committing the effects of a transaction, always shift their view to 
%the most recent version of each key.  
%The execution $\ET_{\CP}$ for consistent 
%prefix is defined in \cref{fig:execution.tests}.

\paragraph{Parallel Snapshot Isolation (\PSI)} 
Parallel Snapshot Isolation (\PSI) can be obtained by combining causal consistency with update atomic, 
$\ET_{\PSI} = \ET_{\CC} \cap \ET_{\UA}$, and $\ET_{\SI} = \ET_{\CC} \cap \ET_{\UA}$.

\paragraph{Snapshot Isolation (\SI)}
When the total order in which transactions commit is known,
SI can be specified as the weakest consistency model that guarantees both 
Consistency Prefix and Update Atomic \cite{gsi,framework-concur}. 
Yet, it is not true in our framework, since transactions are not totally ordered.
For example, the kv-store of \cref{fig:si-disallowed} is included in both $\CMs(\ET_{\CP})$ and $\CMs(\ET_{\UA})$, 
but it is forbidden by snapshot isolation in general.
The reason is \( \CMs(\ET_1 \cap \ET_2) = \CMs(\ET_1) \cap \CMs(\ET_2) \) holds 
only under some conditions of the \( \ET_1 \) and \( \ET_2 \) (more detail in \cref{thm:et-comm} \cref{sec:et-comp}).
\footnote{%
    This problem is not limited to our setting: 
    because kv-stores are isomorphic to Adya's dependency 
    graph, the same problem arises there.%
} 
We are inspired by the following constraint that has been proven satisfying \( \SI \) \cite{cerone:snapshot}:
\[
    (\SO \cup \WW) \subseteq \VIS \quad  ( (\SO \cup \WW \cup \WR) ; \RW? ) ; \VIS \subseteq \VIS
\]
where write-write relation \( (\txid, \txid') \in \WW \) means the transaction \( \txid \) installs a version for a key \( \ke \) following by \( \txid' \) installing a new version for the key \( \ke \).
The constraint \( \SO \subseteq \VIS \) coincides with \( \ET_\RYW \).
The \( \WW \subseteq \VIS \) means two transactions cannot concurrently write to the same key,
which is enforced by \( \ET_\UA \).
Let consider \( ( (\SO \cup \WW \cup \WR) ; \RW? ) ; \VIS \subseteq \VIS \).
Similar to the argument we made in Consistent Prefix (\pageref{para:cp}), 
let assume a client \( \cl \), its view \( \vi \) and two transactions \( \txid, \txid' \) such that 
\( \txid' \) is in the view \( \vi \)
and \( \txid \toEdge{(\SO \cup \WW \cup \WR) ; \RW?} \txid' \).
If \( \txid' \) is observable by any previous transaction of the client \( \cl \),
then \( \txid \) is also observable before.
By \( \ET_\MRd\), it is the case \( \txid \) is in the view \( \vi \).
If \( \txid' \) is a new transaction observed by the client \( \cl \),
the \( \dagger \) enforces that \( \txid \) should be included \( \vi \).

\ac{\color{red} This is going to be difficult to be put in words: 
both SI and CP require that the snapshot taken by clients are monotonically 
increasing (at least for transactions that write to at least one key). 
In both SI and CP, we enforce this property by computing, at the moment 
of trying to commit a transaction, a view of all the transactions that executed before 
(and hence appear in the kv-store); then we require that such views do not cross 
with the one that is being used to commit the current transaction. Here is where 
the twist happens: the way in which the relevant fragment of a view of 
a transaction is obtained is different for $\CP$ and $\SI$. 
For $\CP$, this relevant fragment is obtained 
by looking at the version reads for a transaction. If transaction $\txid$ read the 
$i$-th version of $\ke$, then we can be sure that the view $\vi_{\txid}$ 
that was used to execute $\txid$ was such that $\vi_{\txid}(\ke) = i$. 
For $\SI$ we also know that if transaction $\txid$ wrote the $i$-th version 
of key $\ke$, then because of write conflict detection, $\vi_{\txid}$ pointed 
to the previous version of $\ke$ i.e. $\vi_{\txid}(\ke) = i - 1$. 
In \cref{fig:execution.tests}, the execution test $\ET_{\SI}$ enforces three properties: 
the check on the first line mandates that  if a transaction wants to write key $\ke$, then the view of the client wishing 
to execute such a transaction must be up-to-date for that client; the check 
on the second line mandates that upon committing 
a transaction, a client shifts its view to the most up-to-date version of each 
key (this is done to ensure both $\RYW$ and $\MRd$); 
the check on the last two lines ensures that, in order to commit a transaction, the 
view of a client must not be crossing the view that was used to commit a previous 
transactions $\txid'$, at least for the objects that were accessed by $\txid'$.\\
Following a chat with Shale: it looks that there is a check on the program order missing 
here. I need to correct this.}
%We basically compute the relevant fragment of the view that we
%To overcome this problem, we place in 
%$\ET_{\SI}$ one more constraint in addition to the ones that 
%define $\ET_{\CP}$ and $\ET_{\UA}$: if a version read by transaction $\txid$ 
%is to the left of the view $\vi$ of the client wishing to update a transaction, then 
%all the versions written by $\txid$ must be to the left of $\vi$. In \cref{sec:?} 
%we prove that the execution test $\ET_{\SI}$, defined in \cref{fig:execution.tests}, 
%precisely capture SI.

\sx{put back long fork graph}
\paragraph{(Strict) serialisability (\SER)}
Serialisability is the strongest consistency model, 
which requires that there exists a serial or sequential schedule of transaction. 
This prevents scenarios of \cref{fig:ser-disallowed},
which is instead allowed by all the other execution tests that we have presented.
The execution test $\ET_{\SER}$ requires 
clients to execute transactions only when their view of the key-value store is up-to-date.
