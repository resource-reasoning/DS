\section{Conclusions and Related Work}
\label{sec:conclusions}
\sx{A cite here \cite{surech-session-guarantee} who mentions composition of 4 session guarantees. 
    \cite{principle-eventual-consistency} mentions causal consistency is combination of session guarantees,
    yet they only define 3 types of session guarantees.
}
We have introduced  an  operational semantics for 
transactional distributed databases, based on a global, centralised 
kv-stores and partial client views. 


In our semantics is simple: transactions are executed atomically in an interleaving; on the other hand, it 
is  expressive enough to capture anomalous behaviours that are proper
of weak consistency models. 



The semantics is parametric in the definition of an execution test, and we capture different consistency 
models by tweaking the execution test. We have captured a large variety of well-known consistency 
models, 
%we have captured a large variety of well-known consistency models 
%for distributed databases by tweaking the execution tests, 
and we have identified interesting consistency models that have not been 
implemented yet.
We have proved the correctness of two real-world protocols employed by distributed 
databases: COPS~\cite{cops}, a 
protocol for replicated databases that satisfies our definition of causal consistency;
and Clock-SI~\cite{clocksi}, a protocol for partitioned databases that satisfies our
definition of snapshot isolation. We have also demonstrated the usefulness of our framework
for program analysis, by proving the robustness of simple transactional 
libraries against different consistency models. 
%We believe that we are
%the first to show such  results for  databases which  allow
%the grouping of  transactions into sessions. 

In the future, we plan to extend our framework to handle a larger variety 
of weak consistency models: we believe that, by introducing promises 
in the style of \cite{promises}, we can capture  consistency models such 
as \emph{Read Committed}. We also plan to validate further the usefulness of our framework
by verifying other well-known protocols of 
distributed databases, e.g. Eiger~\cite{eiger}, Wren~\cite{wren} and
Red-Blue~\cite{redblue}; by exploring robustness results for OLTP
workloads  such as TPC-C~\cite{tpcc} and RUBiS~\cite{rubis}; 
and by exploring other program analysis techniques, e.g. 
transaction chopping \cite{chopping,psi-chopping}, invariant checking 
\cite{cise,repliss} and program logics \cite{alonetogether}. 

\mypar{Related Work} 
In the introduction, we highlight three general operational semantics for 
distributed transactional databases. We discuss these semantics in more detail here 
and also some additional related work on program analysis for such transactional 
systems.

\citeN{alonetogether} propose an operational semantics of SQL transactional programs 
under the consistency models given by the standard ANSI/SQL isolation levels \cite{si}.
%several transactional consistency models, 
%corresponding to the ANSI/SQL isolation levels \cite{si}.
In their  framework, transactions work on a local copy of the global state 
of the system, and the local effects of a transaction are committed to the  
system state when it terminates. Because state changes 
are made immediately available to all clients of a system, this model 
is not suitable to capture weak consistency models such as \(\PSI\) or \(\CC\). 
They introduce a program logics and prototype verification tool for reasoning 
about client programs. However, their definitions of consistency models 
%Also, the definitions given 
are not validated against previously known 
formal definitions.

\citeN{sureshConcur} propose an operational semantics for weak consistency 
based on abstract executions. Their semantics 
is parametric in the declarative definition of a consistency model. 
%in their model abstract executions are not equipped with sessions, they cannot 
%specify a large variety of consistency models as we do, such as the session guarantees. 
The authors introduce a static-analysis tool for checking the robustness of transactional  
libraries.
They focus on consistency models with atomic visibility, but confusingly allow 
the interleaving of fine-grained operations between different transactions. 
This results in an unnecessary explosion of the space of traces generated by 
the program. In our semantics, the interleaving is between transactions.
%Also, they focus on databases 
%without sessions. Because the session order cannot be determined at compile time, 
%their tool cannot be easily extended to a setting which includes sessions. 

\citeN{seebelieve} propose a state-based formal framework for weak consistency models, 
that also employs notions similar to execution tests and views, called commit tests and read states 
respectively.
They prove that consistency models previously thought to be different 
are in fact equivalent in their semantics.
They capture 
a wide range of consistency models including read committed which we cannot do. 
In their semantics, one-step trace reduction is determined by the whole previous history of the trace. 
In contrast, our reduction step only depends on the current configuration (kv-store and view).
They do not consider program analysis. Their notion of commit tests and read states requires 
the knowledge of information that is not known to clients of the system, i.e. the total order of system changes that happened in the database 
prior to committing a transaction. For this reason, we believe that their framework is not suitable for the development of program analysis techniques.

Several other works have focused on program analysis for transactional systems. 
%Concerning robustness, 
\citeN{dias-tm} developed a separation logic for
the robustness of applications against SI. \citeN{fekete-tods} derived 
a static analysis check for SI based on dependency graph. \citeN{giovanni_concur16}
developed a static analysis check for several consistency models with atomic visibility. 
\citeN{laws} investigated the relationship between abstract 
executions and dependency graphs from an algebraic perspective, and applied it to infer 
robustness checks for several consistency models. 

