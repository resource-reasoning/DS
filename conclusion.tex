\section{Conclusions and Related Work}
\label{sec:conclusions}
We have introduced  an  operational semantics for 
transactional distributed databases, based on a global, centralised 
kv-store and partial client views. 
Our semantics is parametric in the definition of an execution test.
We capture a large variety of well-known consistency models 
for replicated and partitioned databases by simple changes to  the execution tests. 
We have proved the correctness of two real-world protocols employed by distributed 
databases: COPS~\cite{cops}, a 
protocol for replicated databases that satisfies our definition of causal consistency, 
and Clock-SI~\cite{clocksi}, a protocol for partitioned databases that satisfies our
definition of 
snapshot isolation. We have also demonstrated the usefulness of our frameworks 
for program analysis, by proving the robustness of different transactional 
libraries against different consistency models. We believe that we are
the first to show robustness results for  databases which  allow
the grouping of  transactions into sessions. 

In future, we plan to validate further the usefulness of our framework
by verifying the correctness of other well-known protocols employed by
distributed databases, such as Eiger~\cite{eiger}, Wren~\cite{wren} and
Red-Blue~\cite{redblue}; by exploring robustness results for OLTP
workloads  such as TPC-C~\cite{tpcc} and RUBiS~\cite{rubis};
and by exploring other program-analysis techniques such as
transactional chopping \cite{chopping,psi-chopping}, invariant checking 
\cite{cise,repliss} and program logics \cite{alonetogether}. 

\mypar{Related Work}
\citeauthor{alonetogether} proposed an operational semantics of programs 
under different transactional consistency models \cite{alonetogether}, 
corresponding to the ANSI/SQL isolation levels \cite{si}.
In the proposed framework, transactions work on a local copy of the global state 
of the system, and the local effects of a transaction are pushed as 
system state changes upon commit. Because state changes 
are made immediately available to all clients of a system, this model 
is not suitable to capture weak consistency models such as \(\PSI\) or \(\CC\). 
Also, the specification given are not validated against previously known 
formal specifications.
%Like us, 
%their semantics is parametric in the definition of a consistency model, it 
%involves a notion of global state, 
%and clients work on a local copy of the state 
%before pushing their updates onto the central state. Unlike 
%us, their notion of state does not employ multi-versions, 
%which prevents the possibility to specify Parallel Snapshot Isolation 
%and other weaker consistency models. 
%%this makes it impossible only to define weak consistency models 
%%where clients observe updates in different orders, such as PSI. 
%Furthermore, operations of transactions are interleaved with each 
%other: this makes it possible to capture consistency guarantees that 
%do not enjoy atomic visiblity, such as read committed, but it comes 
%at the price of making the task analysing applications without the aid 
%of automatic tools difficult.

\citeauthor{sureshConcur} proposed an operational semantics for weak consistency 
based on abstract executions \cite{sureshConcur}. Their semantics 
is parametric in the declarative specification of a consistency model. Because 
in their model abstract executions are not equipped with sessions, they cannot 
specify a large variety of consistency models as we do, such as the session guarantees. 
The authors also present a static analysis tool for determining the robustness of transactional 
libraries; however, their robustness results rely on the assumption that the underlying database 
is not equipped with sessions. Because the session order cannot be determined at compile time, 
their tool cannot be easily extended to a setting where sessions are provided by the database. 

%Like us, their semantics is parametric in the specification of a consistency model, 
%and takes into account very weak consistency models such as PSI. 
%The authors also present a static analysis technique for checking the robustness of applications 
%under a given consistency model. Unlike us, their work does not take into account 
%sessions and session guarantees, thus limiting the robustness results only to databases 
%that do not provide sessions. The 
%operational semantics presented in this  work also allows for the execution of transactions to be interleaved 
%with each other, which we already argued complicates the task of program analysis. 

\citeauthor{seebelieve} \cite{seebelieve} proposed a state-based formal framework for weak consistency models, 
that also employs notions similar to execution tests and views: commit tests and read states.
On one side, the authors capture 
a greater range of consistency models that we do (in particular, the Read Committed isolation level), 
and they also exploit their formalism to verify the correctness of protocols
However, they do not consider program analysis. Because their notion of commit tests and read states requires 
the knowledge of information that cannot be determined at compile time, i.e. the total order of system changes that happened in the database 
we believe that their framework is not suitable for the development of program analysis techniques.
%to our definition 
%Like us, clients use a notion similar 
%to the view mechanism to determine the values read for keys in a transaction, 
%and a notion of commit test to  determine whether a transaction is allowed to commit. 
%Unlike us, their notion of state consists of a mapping from keys to values, and 
%commit tests need access to the total order of state changes, to determine whether a transaction can commit.
%While approach has been showed to be successful for verifying the correctness of protocols for transactional consistency models, 
%the problem of analysing transactional applications is not addressed.
%We believe that the requirement for commit test to know the total order 
%of state changes hinders the development of program analysis
%techniques.

Several other works have focused on program analsysis for transactional systems. 
%Concerning robustness, 
\citeauthor{dias-tm} \cite{dias-tm} developed a separation logic for
the robustness of applications under SI. \citeauthor{fekete-tods} \cite{fekete-tods} derived 
a static analysis check for SI based on dependency graph. \citeauthor{giovanni_concur16} \cite{giovanni_concur16} 
developed a static analysis check for several consistency models with atomic visibility. 
\citeauthor{laws} \cite{laws} investigated the relationship between abstract 
executions and dependency graph from an algebraic perspective, and applied it to infer 
robustness checks for several consistency models. 

%Other forms of program analysis that have been considered for transactional systems 
%are transaction chopping \cite{chopping,psi-chopping} and techniques for proving 
%invariants of transactional applications \cite{cise,repliss}.

%Our view mechanism has been inspired by the work of Kang \etal \cite{promises}, 
%which proposes an operational semantics for programs running under the C11 memory model.
\ac{The comment on the promising semantics is already in the introduction, so it can be removed from here.}
