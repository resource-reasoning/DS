\section{Conclusion}
 

Kaki et al. proposed an operational semantics of programs 
under different transactional consistency models \cite{alonetogether}. Like us, 
their semantics is parametric in the definition of a consistency model, it 
involves a notion of global state, 
and clients work on a local copy of the state 
before pushing their updates onto the central state. Unlike 
us, their notion of state does not employ multi-versions: 
this makes it possible only to define weak consistency models 
where clients observe updates in different orders, such as PSI. 
Furthermore, operations of transactions are interleaved within each 
other; while this approach makes it possible to parameterise the 
operational semantics in non-atomically visible consistency models, 
such as read committed, it makes the task of analysing applications, without the aid 
of automated verification tools, difficult.

Nagar et al. proposed an operational semantics for weak consistency 
models using abstract executions as a state of the system \cite{sureshConcur}. 
Like us, their semantics is parametric in the specification of a consistency model, 
and takes into account very weak consistency models such as PSI and Read Atomic. 
The authors also present a static analysis technique for checking the robustness of applications 
under a given consistency model. Unlike us, their work does not take into account 
sessions and session guarantees, which makes it not possible to check the robustness 
of applications involving multiple transactions being executed within a session. The 
operational semantics presented in this  work also allows for the execution of transactions to be interleaved 
with each other, which we already argued complicates the task of program analysis. 

Crooks et al. proposed a state-based formal framework for weak consistency models, 
which also employs the notion of commit test. Like us, clients use a notion similar 
to the view mechanism to determine the values read for keys in a transaction, 
and a notion of commit test to  determine whether a transaction is allowed to commit. 
Unlike us, their notion of state consists of a mapping from keys to values, and 
commit test require the knowledge of the list of changes that happened to the 
system state, before deciding if a transaction can commit; this approach 
makes it easy to verify the correctness of protocols for transactional consistency models. 
However, this work does not address operational semantics and program analysis, 
and we believe that the development of such methodologies in this framework 
would be extremely difficult, due to the requirement that transactions must have 
access to the global list of state changes in the system, to check if they can commit.

Several other works have addressed the issue of robustness pf applications in transactional systems. 
Dias et al. \cite{dias-tm} developed a static analysis technique, based on separation logic, 
to check the robustness of applications under SI. Fekete et al. \cite{fekete-tods} derived 
a static analysis check for SI based on dependency graph. Bernardi et al. \cite{giovanni-concur16} 
developed a static analysis check for several consistency models with atomic visibility. 
Cerone et al. \cite{laws} gave a systematic account of the relationship between abstract 
executions and dependency graph from an algebraic perspective, and applied it to infer 
robustness check for several transactional consistency models.

Our view mechanism has been inspired by the work of Kang et al. \cite{promises}, 
which proposes an operational semantics for programs running under the C11 memory model.