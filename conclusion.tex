\section{Conclusion and Related Work}
\label{sec:conclusions}
We have presented a novel operational semantics for 
transactional distributed databases, based on kv-store and views. 
Our semantics is parametric in the definition of an execution test, 
and we capture a large variety of well known consistency models 
for replicated and partitioned databases by tweaking the execution test. 
We have proved the correctness of two protocols employed by distributed 
databases against our specifications of consistency models: COPS, a 
protocol for replicated databases that guarantees Causal Consistency, 
and CLOCK-SI, a protocol for partitioned databases that guarantees 
Snapshot Isolation. We have also shown the usefulness of our frameworks 
for program analysis, by proving the robustness of different transactional 
libraries against different consistency models. We believe that our proofs of 
robustness are the first one that are valid in the case that the database allows 
to group transactions into sessions. 

In the future, we plan to further validate the usefulness of our framework by 
verifying the correctness of other well-known protocols employed by 
distributed databases; and by developing other program analysis techniques 
for proving properties of transactional libraries. In particular, we are currently 
developing a separation logic for our operational semantics.

\mypar{Related Work}
Kaki \etal proposed an operational semantics of programs 
under different transactional consistency models \cite{alonetogether}, 
corresponding to the ANSI/SQL isolation levels \cite{si}.
In the proposed framework, transactions work on a local copy of the global state 
of the system, and the local effects of a transaction are pushed as 
system state changes upon commit. Because state changes 
are made immediately available to all clients of a system, this model 
is not suitable to capture weak consistency models such as PSI or CC. 
Also, the specification given are not validated against previously known 
formal specifications.
%Like us, 
%their semantics is parametric in the definition of a consistency model, it 
%involves a notion of global state, 
%and clients work on a local copy of the state 
%before pushing their updates onto the central state. Unlike 
%us, their notion of state does not employ multi-versions, 
%which prevents the possibility to specify Parallel Snapshot Isolation 
%and other weaker consistency models. 
%%this makes it impossible only to define weak consistency models 
%%where clients observe updates in different orders, such as PSI. 
%Furthermore, operations of transactions are interleaved with each 
%other: this makes it possible to capture consistency guarantees that 
%do not enjoy atomic visiblity, such as read committed, but it comes 
%at the price of making the task analysing applications without the aid 
%of automatic tools difficult.

Nagar \etal proposed an operational semantics for weak consistency 
based on abstract executions \cite{sureshConcur}. Their semantics 
is parametric in the declarative specification of a consistency model. Because 
in their model abstract executions are not equipped with sessions, they cannot 
specify a large variety of consistency models as we do, such as the session guarantees. 
The authors also present a static analysis tool for determining the robustness of transactional 
libraries; however, their robustness results rely on the assumption that the underlying database 
is not equipped with sessions. Because the session order cannot be determined at compile time, 
their tool cannot be easily extended to a setting where sessions are provided by the database. 

%Like us, their semantics is parametric in the specification of a consistency model, 
%and takes into account very weak consistency models such as PSI. 
%The authors also present a static analysis technique for checking the robustness of applications 
%under a given consistency model. Unlike us, their work does not take into account 
%sessions and session guarantees, thus limiting the robustness results only to databases 
%that do not provide sessions. The 
%operational semantics presented in this  work also allows for the execution of transactions to be interleaved 
%with each other, which we already argued complicates the task of program analysis. 

Crooks \etal proposed a state-based formal framework for weak consistency models, 
which also employs the notion of commit test and read states, which are similar 
to our notions of execution tests and views, respectively. On one side, the authors capture 
a greater range of consistency models that we do (in particular, the Read Committed isolation level), 
and they also exploit their formalism to verify the correctness of protocols
However, they do not consider program analysis. Because their notion of commit tests and read states requires 
the knowledge of information that cannot be determined at compile time, i.e. the total order of system changes that happened in the database 
we believe that their framework is not suitable for the development of program analysis techniques.
%to our definition 
%Like us, clients use a notion similar 
%to the view mechanism to determine the values read for keys in a transaction, 
%and a notion of commit test to  determine whether a transaction is allowed to commit. 
%Unlike us, their notion of state consists of a mapping from keys to values, and 
%commit tests need access to the total order of state changes, to determine whether a transaction can commit.
%While approach has been showed to be successful for verifying the correctness of protocols for transactional consistency models, 
%the problem of analysing transactional applications is not addressed.
%We believe that the requirement for commit test to know the total order 
%of state changes hinders the development of program analysis techniques.

Several other works have addressed the task of program analsysis transactional systems. 
Concerning robustness, 
Dias \etal \cite{dias-tm} developed a static analysis technique, based on separation logic, 
to check the robustness of applications under SI. Fekete \etal \cite{fekete-tods} derived 
a static analysis check for SI based on dependency graph. Bernardi \etal \cite{giovanni-concur16} 
developed a static analysis check for several consistency models with atomic visibility. 
Cerone \etal \cite{laws} investigated the relationship between abstract 
executions and dependency graph from an algebraic perspective, and applied it to infer 
robustness check for several transactional consistency models. 
%Other forms of program analysis that have been considered for transactional systems 
%are transaction chopping \cite{chopping,psi-chopping} and techniques for proving 
%invariants of transactional applications \cite{cise,repliss}.

Our view mechanism has been inspired by the work of Kang \etal \cite{promises}, 
which proposes an operational semantics for programs running under the C11 memory model.