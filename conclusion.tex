\section{Conclusion}
 

Kaki et al. proposed an operational semantics of programs 
under different transactional consistency models \cite{alonetogether}. Like us, 
their semantics is parametric in the definition of a consistency model, it 
involves a notion of global state, 
and clients work on a local copy of the state 
before pushing their updates onto the central state. Unlike 
us, their notion of state does not employ multi-versions, 
which prevents the possibility to specify Parallel Snapshot Isolation 
and other weaker consistency models. 
%this makes it impossible only to define weak consistency models 
%where clients observe updates in different orders, such as PSI. 
Furthermore, operations of transactions are interleaved with each 
other: this makes it possible to capture consistency guarantees that 
do not enjoy atomic visiblity, such as read committed, but it comes 
at the price of making the task analysing applications without the aid 
of automatic tools difficult.

Nagar et al. proposed an operational semantics for weak consistency 
models using abstract executions as a state of the system \cite{sureshConcur}. 
Like us, their semantics is parametric in the specification of a consistency model, 
and takes into account very weak consistency models such as PSI. 
The authors also present a static analysis technique for checking the robustness of applications 
under a given consistency model. Unlike us, their work does not take into account 
sessions and session guarantees, thus limiting the robustness results only to databases 
that do not provide sessions. The 
operational semantics presented in this  work also allows for the execution of transactions to be interleaved 
with each other, which we already argued complicates the task of program analysis. 

Crooks et al. proposed a state-based formal framework for weak consistency models, 
which also employs the notion of commit test. Like us, clients use a notion similar 
to the view mechanism to determine the values read for keys in a transaction, 
and a notion of commit test to  determine whether a transaction is allowed to commit. 
Unlike us, their notion of state consists of a mapping from keys to values, and 
commit tests need access to the total order of state changes, to determine whether a transaction can commit.
While approach has been showed to be successful for verifying the correctness of protocols for transactional consistency models, 
the problem of analysing transactional applications is not addressed.
We believe that the requirement for commit test to know the total order 
of state changes hinders the development of program analysis techniques.

Several other works have addressed the issue of robustness of applications in transactional systems. 
Dias et al. \cite{dias-tm} developed a static analysis technique, based on separation logic, 
to check the robustness of applications under SI. Fekete et al. \cite{fekete-tods} derived 
a static analysis check for SI based on dependency graph. Bernardi et al. \cite{giovanni-concur16} 
developed a static analysis check for several consistency models with atomic visibility. 
Cerone et al. \cite{laws} investigated the relationship between abstract 
executions and dependency graph from an algebraic perspective, and applied it to infer 
robustness check for several transactional consistency models.

Our view mechanism has been inspired by the work of Kang et al. \cite{promises}, 
which proposes an operational semantics for programs running under the C11 memory model.