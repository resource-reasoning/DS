\subsection{Traces of Programs under Key-value Stores}
\label{sec:kv-sound-complete-theorem}
In this Section we define the set of $\ET$-traces generated by a program 
$\prog$. Our main goal is that of proving that our semantics is correct, 
meaning that if a program $\prog$ executing under the execution 
test $\ET$ terminates in a state $(\hh, \_)$, then $\hh \in \CMs(\ET)$. 

\begin{definition}
Let $\ET$ be an execution test. For each program $\prog$ and state 
$(\hh, \viewFun, \thdenv)$, we define $\OPtraces(\ET, \prog, \hh, \viewFun, \thdenv)$ 
as the smallest set such that 
\begin{itemize}
\item $(\hh, \viewFun) \in \OPtraces(\ET, \prog, \hh, \viewFun, \thdenv)$, 
\item if $\tr \in \OPtraces(\ET, \prog', \hh', \viewFun',\thdenv')$, 
and $((\hh, \viewFun, \thdenv) , \prog) \toT{(\cl, \iota)}_{\ET} (\hh', \viewFun', \thdenv')$, 
then $\tr \in \OPtraces(\ET, \prog, \hh, \viewFun, \thdenv')$, 
\item if $\tr$ in $\OPtraces(\ET, \prog', \hh', \viewFun', \thdenv')$ and 
\newline $(\hh, \viewFun, \thdenv), \prog) \toT{(\cl, \vi, \opset)} ((\hh', \viewFun', \thdenv'), \prog')$,  
then $(\hh, \viewFun) \xrightarrowtriangle{(\cl, \varepsilon)}_{\ET} (\hh, \viewFun\rmto{\cl}{\vi}) 
\xrightarrowtriangle{(\cl, \opset)}_{\ET} \tr$ in $\OPtraces(\ET, \prog, \hh, \viewFun, \thdenv)$. 
\end{itemize}

The set of traces generated by a program $\prog$ under the execution test $\ET$ is 
then defined as $\OPtraces(\ET, \prog) \triangleq (\OPtraces(\ET, \prog, \hh_{0}, \viewFun_{0}, 
\thdenv_{0})$, where $\viewFun_{0} = \lambda \cl \in \dom(\prog).\lambda \ke.\{0\}$, and 
$\thdenv_{0} = \lambda \cl \in \dom(\prog).\lambda a.0$.

\end{definition}

\begin{proposition}
    \label{prop:program-trace-in-et-trace}
For each program $\prog$ and execution test $\ET$, 
$\OPtraces(\ET, \prog) \subseteq \Confs(\ET)$. 
Furthermore, each $\tr \in \OPtraces(\ET, \prog)$ is in normal form. 
\end{proposition}
\begin{proof}
    First, by the definition of \( \OPtraces \), 
    it only constructs trace in normal form.
    It is easy to prove that for any trace \( \tau \) in \( \OPtraces(\ET, \prog) \), by induction on the trace length,
    the trace is also in \( \Confs(\ET) \).
\end{proof}

\begin{corollary}
If $(\hh_{0}, \viewFun_{0}, \thdenv_{0}), \prog) \toL_{\ET} \cdots \toL_{\ET} 
(\hh, \viewFun, \thdenv, \lambda \cl \in \dom(\prog). \pskip)$, then $\hh \in \CMs(\ET)$.
\end{corollary}
\begin{proof}
    By the definition of \( \OPtraces \), 
    there exists a corresponding trace \( \tau \in \OPtraces(\ET, \prog) \).
    By \cref{prop:program-trace-in-et-trace}, such trace \( \tau \in \Confs(\ET) \),
    therefore \( \mkvs \in \CMs(\ET)\) by definition of \( \CMs(\ET) \).
\end{proof}

\begin{proposition}
For any program $\prog$ and execution test $\ET$, $\OPtraces(\ET, \prog) = \OPtraces(\ET_{\top}, \prog) 
\cap \Confs(\ET)$.
\end{proposition}
\begin{proof}
    It is easy to see \(\OPtraces(\ET, \prog) \subseteq \OPtraces(\ET_\top, \prog) \).
    By \cref{prop:program-trace-in-et-trace}, we know \( \OPtraces(\ET, \prog) \subseteq \Confs(\ET)\).
    Therefore \(  \OPtraces(\ET, \prog) \subseteq \OPtraces(\ET_\top, \prog) \cap \Confs(\ET) \).

    Let consider a trace \( \tau \) in \( \OPtraces(\ET_\top, \prog) \cap \Confs(\ET) \).
    By inductions on the length of trace, 
    every step that commits a new transaction  must satisfy \( \ET \) as \( \tau \in \Confs(\ET) \).
    It also reduce the program \( \prog \) as \( \tau \in \OPtraces(\ET_\top, \prog) \).
    By the definition \( \OPtraces(\ET, \prog) \),
    we can construct the same trace \( \tau \),
    so \( \tau \in \OPtraces(\ET, \prog) \).
\end{proof}

%\ac{These results should be easy to prove, either I or somebody else will type up a proof 
%at some point.}

\subsection{Comparing the Abstract Execution and key-value Store Semantics}

Suppose that a given execution test $\ET$ captures precisely 
a consistency model specified in the axiomatic style, using a set of 
axioms $\Ax$ and a resolution policy $\RP$ over abstract executions.
That is, for any abstract execution $\aexec$ that satisfies 
the axioms $\Ax$ and the resolution policy $\RP$, then $\KVtrace(\ET_{\top}, \aexec) \cap \CMs(\ET) \neq \emptyset$; 
and for any $\tr \in \CMs(\ET)$, there exists an abstract execution 
$\aexec \in \aeset(\tr)$ that satisfies the axioms $\Ax$ and the resolution policy $\RP$. 
\ac{In practice, the functions $\KVtrace(\ET, \aexec) = \KVtrace(\ET_{\top}, \aexec) \cap \CMs(\ET)$, 
and $\aeset(\Ax, \aexec) = \aeset(\ET_{\top}, \aexec) \cap \aeset(\Ax)$, abstracted over the second 
argument and lifted to sets of abstract executions/traces, 
define a Galois Connection between the powerset of abstract executions in the axiomatic specification 
of the consistency model, and the powerset of kv-stores generated by such a consistency model.}
Our main aim in this section consists in proving that, for each program $\prog$, the 
set of kv-stores generated by $\prog$ under $\ET$ corresponds to all the possible kv-stores 
that could be obtained by running $\prog$ on a database that satisfies the axiomatic specification 
$\Ax$. In this sense, we aim to establish that our operational semantics is \emph{adequate}.

To tackle this question, we need to define what is the set of all possible behaviours 
that can be produced by a program $\prog$ under a given consistency model $\CM$, for 
which an axiomatic specification $(\RP, \Ax)$ is known. This in turn requires addressing two orthogonal 
problems: \textbf{(i)} defining the set of all possible behaviours that may be exhibited by a program 
$\prog$, independently of the consistency model; and \textbf{(ii)} defining the set of all possible 
behaviours that are allowed by a given consistency model $\CM$. Then the set of all 
possible behaviours of $\prog$ under $\CM$ is obtained by intersecting the two sets 
above.

The kv-store semantics is intrinsically not expressive enough to tackle problem \textbf{(i)}. 
By \cref{cor:kvtrace2aexec}, only kv-stores arising 
from abstract executions satisfying the last write wins resolution policy can be captured in the kv-store 
framework; instead, we seek to model all the behaviours of a program independently of a consistency 
models, and therefore independently of a resolution policy. 

\begin{proposition}
\label{prop:kv2aexec_transition}
Suppose that $(\hh, \viewFun, \thdenv), \prog \toT{(\cl, \vi, \opset)}_{\ET_{\top}} (\hh', 
\viewFun', \thdenv'), \prog'$. Let $\aexec$ be an abstract execution 
such that $\hh_{\aexec} = \hh$, and let $\T \subseteq \T_{\aexec}$ be a 
set of read-only transactions. Then there exists an abstract execution $\aexec'$ 
such that $\hh_{\aexec'} = \hh'$, and 
\[
(\aexec, \thdenv), \prog \toA{(\cl, \T \cup \Tx(\hh, \vi), \opset)}_{(\RP_{\LWW}, \emptyset)}. 
(\aexec', \thdenv'), \prog'
\]
\end{proposition}
\begin{proof}
See \cref{sec:kv2aexec-transaction}.
\end{proof}

\begin{proposition}
\label{prop:aexec2kv_transition}
Suppose that $(\aexec, \thdenv), \prog \toA{(\cl, \T, \opset)}_{(\RP_{\LWW})} (\aexec', \thdenv'), \prog'$. 
Then for any $\viewFun$ and $\vi \in \Views(\hh_{\aexec})$ such that $\vi \viewleq \getView(\aexec, \T)$, 
we have that 
\[
(\hh_{\aexec}, \viewFun\rmto{\cl}{\vi}, \thdenv), \prog \toA{(\cl, \getView(\aexec, \T), \opset)}_{\ET_{\top}} (\hh_{\aexec'}, \viewFun, \thdenv'), \prog'.
\]
\end{proposition}
\begin{proof}
See \cref{sec:aexec2kv-transaction}.
\end{proof}

\begin{corollary}
For any program $\prog$, 
\[
\interpr{\prog}_{\ET_{\top}} = \{\hh_{\aexec} \mid \aexec \in \interpr{\prog}_{(\RP_{\LWW}, \emptyset)}\}
\]
\end{corollary}
\begin{proof}
    It can be derived by \cref{prop:aexec2kv_transition} and \cref{prop:kv2aexec_transition}.
\end{proof}


\subsection{Soundness and Completeness Judgements}

To conclude this Section, we show how all the results illustrated so far 
can be put together to show that the kv-store operational semantics is adequate. 
\begin{definition}
A \emph{client-based invariant condition}, or simply \emph{invariant}, is a 
function $I : \aeset \times \Clients \rightarrow \powerset{\TxID}$ 
such that for any $\cl$ we have that $I(\aeset, \cl) \subseteq \T_{\aexec}$, and 
for any  $\cl'$ such that $\cl' \neq \cl$ we have that 
$I(\extend(\aexec, \txid_{\cl'}^{\cdot}, \_, \_), \cl) = I(\aexec, \cl)$.
\end{definition}
\ac{The idea behind client-based invariant being that $I(\aexec, \cl)$ represents 
the minimal set of transactions that $\cl$ must see in $\aexec$, before 
updating the view and performing a transaction. Such a set of transaction 
roughly correspond to the view of the client before performing a 
sequence of \emph{update view+execute transaction} operations, 
or equivalently from the view obtained after the execution of the 
last transaction from that client.}


\begin{definition}
\label{def:et_sound}
An execution test $\ET$ is sound with respect to an axiomatic 
specification $(\RP_{\LWW}, \Ax)$ if and only if there exists an 
invariant condition $I$ such that whenever $\ET \vdash (\hh, \vi) 
\triangleright \opset: \vi'$, for any $\aexec$ such that 
$\hh_{\aexec} = \hh$, for any client $\cl$, for any 
transaction identifier $\txid \in \nextTxId(\hh, \cl)$, 
such that  $I(\aexec, \cl) \subseteq \Tx(\hh, \vi)$, then  
there exist two other sets of transactions $\T_{\rd}$, 
such that 
\begin{itemize}
\item $\forall \A \in \Ax. \Setcon{\txid' }{ (\txid', \txid) \in \A(\aexec')} \subseteq \Tx(\hh, \vi) \cup \T_{\rd}$, 
\item $I(\aexec', \cl) \subseteq \Tx(\mkvs_{\aexec'}, \vi')$
\end{itemize}
\end{definition}

\begin{theorem}
\label{thm:et_soundness}
If $\ET$ is sound with respect to $(\RP_{\LWW}, \Ax)$, then 
\[
    \CMs(\ET) \subseteq \{ \hh \mid \exists \aexec \in \CMa(\RP_{\LWW}, \Ax)).\;\hh_{\aexec} = \hh\}
\].
\end{theorem}
\begin{proof}
    See \cref{sec:thm-et-soundness}.
\end{proof}

\begin{corollary}
\label{cor:et-soundness}
If $\ET$ is sound with respect to $(\RP_{\LWW}, \Ax)$, then 
for any program $\prog$, $\interpr{\prog}_{\ET} \subseteq \{ \hh_{\aexec} \mid \aexec \in \interpr{P}_{(\RP_{\LWW}, \Ax)} \}$.
\end{corollary}
\begin{proof}
See \cref{sec:cor-et-soundness}.
\end{proof}

\begin{definition}
\label{def:et_complete}
An execution test $\ET$ is \emph{complete} with respect 
to an axiomatic specification $(\RP_{\LWW}, \Ax)$ if, for any 
abstract execution $\aexec \in \CMa(\RP_{\LWW}, \Ax)$ 
such that $\AR_{\aexec} = \{(\txid_{i}, \txid_{i+1})\}_{i=1}^{\lvert \T_{\aexec} \rvert - 1}$, 
and for any $i=1,\cdots, n$, there exist two views $\vi_{i}, \vi_{i}'$ such that 
\begin{itemize}
\item $\vi_{i} = \getView(\aexec, \VIS_{\aexec}^{-1}(\txid_{i}))$, 
\item let $\txid_{i} = \txid_{\cl}^{n}$ for some $\cl, n$; if the
transaction $\txid_{i}' = \min_{\PO_{\aexec}}\{\txid' \mid \txid_i \xrightarrow{\PO_{\aexec}} \txid'\}$  
is defined, then $\vi' = \getView(\aexec, \T_{i})$, where $\T_{i} \subseteq (\AR_{\aexec}^{-1})?(\txid_{i}) \cap \VIS_{\aexec}^{-1}(\txid_{i}'))$; 
otherwise $\vi' = \getView(\aexec, \T_{i})$, where $\T_{i} \subseteq (\AR_{\aexec}^{-1})?(\txid_{i})$, 
\item $\ET \vdash (\hh_{\cut(\aexec, i-1)}, \vi_{i}) \triangleright \TtoOp{T}_{\aexec}(\txid_{i}) : \vi_{i}'$.
\end{itemize}
\end{definition}

\begin{theorem}
\label{thm:et_complete}
Let $\ET$ be an execution test that is complete with respect to 
an axiomatic specification $(\RP_{\LWW}, \Ax)$. Then 
$\CMa(\RP_{\LWW}, \Ax) \subseteq \CMs(\ET)$.
\end{theorem}
\begin{proof}
See \cref{sec:et-completeness}.
\end{proof}
