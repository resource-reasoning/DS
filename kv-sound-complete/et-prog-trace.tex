\subsection{Traces of Programs under Key-value Stores}
\label{sec:kv-sound-complete-theorem}

The \( \OPtraces(\ET, \prog) \) is the set of all possible traces generated by the program \( \prog \)
starting from the initial configuration \( ( \mkvs_0, \viewFun_0 ) \).

\begin{definition}
Given an execution test $\ET$ a program $\prog$ and a state 
$(\hh, \viewFun, \thdenv)$, the  $\OPtraces(\ET, \prog, \hh, \viewFun, \thdenv)$ function
is defined as the smallest set such that:
\begin{itemize}
\item $(\hh, \viewFun) \in \OPtraces(\ET, \prog, \hh, \viewFun, \thdenv)$
\item if $\tr \in \OPtraces(\ET, \prog', \hh', \viewFun',\thdenv')$
and $((\hh, \viewFun, \thdenv) , \prog) \toT{(\cl, \iota)}_{\ET} (\hh', \viewFun', \thdenv')$, 
then $\tr \in \OPtraces(\ET, \prog, \hh, \viewFun, \thdenv')$
\item if $\tr \in \OPtraces(\ET, \prog', \hh', \viewFun', \thdenv')$ and 
$(\hh, \viewFun, \thdenv), \prog) \toT{(\cl, \vi, \opset)} ((\hh', \viewFun', \thdenv'), \prog')$,  
then $
\left( 
\begin{array}{l}
(\hh, \viewFun) \xrightarrowtriangle{(\cl, \varepsilon)}_{\ET} \\
\quad (\hh, \viewFun\rmto{\cl}{\vi}) \xrightarrowtriangle{(\cl, \opset)}_{\ET} \tr 
\end{array}
\right) \in \OPtraces(\ET, \prog, \hh, \viewFun, \thdenv)
$
\end{itemize}
The set of traces generated by a program $\prog$ under the execution test $\ET$ is 
then defined as $\OPtraces(\ET, \prog) \defeq \OPtraces(\ET, \prog, \hh_{0}, \viewFun_{0}, \thdenv_{0})$, 
where $\viewFun_{0} = \lambda \cl \in \dom(\prog).\lambda \ke.\{0\}$, and 
$\thdenv_{0} = \lambda \cl \in \dom(\prog).\lambda a.0$.
\end{definition}


\begin{proposition}
\label{prop:program-trace-in-et-trace}
For any program $\prog$ and execution test $\ET$, 
$\OPtraces(\ET, \prog) \subseteq \Confs(\ET)$ and $\tr \in \OPtraces(\ET, \prog)$ is in normal form. 
\end{proposition}
\begin{proof}
    First, by the definition of \( \OPtraces \), 
    it only constructs trace in normal form.
    It is easy to prove that for any trace \( \tau \) in \( \OPtraces(\ET, \prog) \), by induction on the trace length,
    the trace is also in \( \Confs(\ET) \).
\end{proof}

\begin{corollary}
If a trace in the following form
\[
    (\hh_{0}, \viewFun_{0}, \thdenv_{0}), \prog) \toL_{\ET} \cdots \toL_{\ET} 
    (\hh, \viewFun, \thdenv, \lambda \cl \in \dom(\prog). \pskip)
\]
then $\hh \in \CMs(\ET)$.
\end{corollary}
\begin{proof}
    By the definition of \( \OPtraces \), 
    there exists a corresponding trace \( \tau \in \OPtraces(\ET, \prog) \).
    By \cref{prop:program-trace-in-et-trace}, such trace \( \tau \in \Confs(\ET) \),
    therefore \( \mkvs \in \CMs(\ET)\) by definition of \( \CMs(\ET) \).
\end{proof}

\begin{proposition}
For any program $\prog$ and execution test $\ET$, $\OPtraces(\ET, \prog) = \OPtraces(\ET_{\top}, \prog) 
\cap \Confs(\ET)$.
\end{proposition}
\begin{proof}
    It is easy to see \(\OPtraces(\ET, \prog) \subseteq \OPtraces(\ET_\top, \prog) \).
    By \cref{prop:program-trace-in-et-trace}, we know \( \OPtraces(\ET, \prog) \subseteq \Confs(\ET)\).
    Therefore \(  \OPtraces(\ET, \prog) \subseteq \OPtraces(\ET_\top, \prog) \cap \Confs(\ET) \).

    Let consider a trace \( \tau \) in \( \OPtraces(\ET_\top, \prog) \cap \Confs(\ET) \).
    By inductions on the length of trace, 
    every step that commits a new transaction  must satisfy \( \ET \) as \( \tau \in \Confs(\ET) \).
    It also reduce the program \( \prog \) since \( \tau \in \OPtraces(\ET_\top, \prog) \).
    By the definition \( \OPtraces(\ET, \prog) \), we can construct the same trace \( \tau \) so that \( \tau \in \OPtraces(\ET, \prog) \).
\end{proof}
