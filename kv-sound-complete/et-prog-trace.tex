\subsection{Traces of Programs under Key-value Stores}
\label{sec:kv-sound-complete-theorem}
In this Section we define the set of $\ET$-traces generated by a program 
$\prog$. Our main goal is that of proving that our semantics is correct, 
meaning that if a program $\prog$ executing under the execution 
test $\ET$ terminates in a state $(\hh, \_)$, then $\hh \in \CMs(\ET)$. 

\begin{definition}
Let $\ET$ be an execution test. For each program $\prog$ and state 
$(\hh, \viewFun, \thdenv)$, we define $\OPtraces(\ET, \prog, \hh, \viewFun, \thdenv)$ 
as the smallest set such that 
\begin{itemize}
\item $(\hh, \viewFun) \in \OPtraces(\ET, \prog, \hh, \viewFun, \thdenv)$, 
\item if $\tr \in \OPtraces(\ET, \prog', \hh', \viewFun',\thdenv')$, 
and $((\hh, \viewFun, \thdenv) , \prog) \toT{(\cl, \iota)}_{\ET} (\hh', \viewFun', \thdenv')$, 
then $\tr \in \OPtraces(\ET, \prog, \hh, \viewFun, \thdenv')$, 
\item if $\tr$ in $\OPtraces(\ET, \prog', \hh', \viewFun', \thdenv')$ and 
\newline $(\hh, \viewFun, \thdenv), \prog) \toT{(\cl, \vi, \opset)} ((\hh', \viewFun', \thdenv'), \prog')$,  
then $(\hh, \viewFun) \xrightarrowtriangle{(\cl, \varepsilon)}_{\ET} (\hh, \viewFun\rmto{\cl}{\vi}) 
\xrightarrowtriangle{(\cl, \opset)}_{\ET} \tr$ in $\OPtraces(\ET, \prog, \hh, \viewFun, \thdenv)$. 
\end{itemize}

The set of traces generated by a program $\prog$ under the execution test $\ET$ is 
then defined as $\OPtraces(\ET, \prog) \triangleq (\OPtraces(\ET, \prog, \hh_{0}, \viewFun_{0}, 
\thdenv_{0})$, where $\viewFun_{0} = \lambda \cl \in \dom(\prog).\lambda \ke.\{0\}$, and 
$\thdenv_{0} = \lambda \cl \in \dom(\prog).\lambda a.0$.

\end{definition}

\begin{proposition}
    \label{prop:program-trace-in-et-trace}
For each program $\prog$ and execution test $\ET$, 
$\OPtraces(\ET, \prog) \subseteq \Confs(\ET)$. 
Furthermore, each $\tr \in \OPtraces(\ET, \prog)$ is in normal form. 
\end{proposition}
\begin{proof}
    First, by the definition of \( \OPtraces \), 
    it only constructs trace in normal form.
    It is easy to prove that for any trace \( \tau \) in \( \OPtraces(\ET, \prog) \), by induction on the trace length,
    the trace is also in \( \Confs(\ET) \).
\end{proof}

\begin{corollary}
If $(\hh_{0}, \viewFun_{0}, \thdenv_{0}), \prog) \toL_{\ET} \cdots \toL_{\ET} 
(\hh, \viewFun, \thdenv, \lambda \cl \in \dom(\prog). \pskip)$, then $\hh \in \CMs(\ET)$.
\end{corollary}
\begin{proof}
    By the definition of \( \OPtraces \), 
    there exists a corresponding trace \( \tau \in \OPtraces(\ET, \prog) \).
    By \cref{prop:program-trace-in-et-trace}, such trace \( \tau \in \Confs(\ET) \),
    therefore \( \mkvs \in \CMs(\ET)\) by definition of \( \CMs(\ET) \).
\end{proof}

\begin{proposition}
For any program $\prog$ and execution test $\ET$, $\OPtraces(\ET, \prog) = \OPtraces(\ET_{\top}, \prog) 
\cap \Confs(\ET)$.
\end{proposition}
\begin{proof}
    It is easy to see \(\OPtraces(\ET, \prog) \subseteq \OPtraces(\ET_\top, \prog) \).
    By \cref{prop:program-trace-in-et-trace}, we know \( \OPtraces(\ET, \prog) \subseteq \Confs(\ET)\).
    Therefore \(  \OPtraces(\ET, \prog) \subseteq \OPtraces(\ET_\top, \prog) \cap \Confs(\ET) \).

    Let consider a trace \( \tau \) in \( \OPtraces(\ET_\top, \prog) \cap \Confs(\ET) \).
    By inductions on the length of trace, 
    every step that commits a new transaction  must satisfy \( \ET \) as \( \tau \in \Confs(\ET) \).
    It also reduce the program \( \prog \) as \( \tau \in \OPtraces(\ET_\top, \prog) \).
    By the definition \( \OPtraces(\ET, \prog) \),
    we can construct the same trace \( \tau \),
    so \( \tau \in \OPtraces(\ET, \prog) \).
\end{proof}

