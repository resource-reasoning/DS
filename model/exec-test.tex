\subsection{Consistency Models and Execution Tests}
%We formalise the notion of \emph{consistency models}. 
\ac{intuitive notion of consistency of the data as a 
property to be satisfied by key-value stores $\rightarrow$
set of key-value stores that preserve this notion of data consistency to be taken as the formal definition 
of weak consistency model $\rightarrow$ execution tests introduced as a way of preventing a client to commit 
a transaction that would cause the key-value store to violate the consistency of the data it stores.}
Intuitively, a consistency model can be thought as a property on key-value stores 
defining the degree of consistency of the data stored in it.
From a formal point of view, we define a consistency model 
$\CMs$ to be a set of key-value stores.  
Each $\hh \in \CMs$ represents a possible outcome that 
can be obtained as the result of multiple clients committing several transactions each. 
However, depending on the particular consistency model being considered, the set of transactions that a client is allowed to commit  
from a configuration $\conf$, must be restricted to those whose effects comply with the data-consistency guarantee associated with 
the consistency model. 
To this end, we introduce the notion of \emph{execution tests}, 
execution tests are used to determine whether a client may commit a transaction into a key-value store.

\subsubsection{Execution Tests}
An execution test of a transaction is a quadruple $(\hh, \vi, \opset, \vi')$, where $\hh$ denotes a kv-store;
the $\vi$ denotes the \emph{initial} view, recorded at the beginning of the transaction; 
the $\opset$ denotes the fingerprint of the transaction; and 
$\vi'$ demotes the \emph{final} view of the transaction, obtained after committing the transaction. 
An execution test $(\mkvs, \vi, \opset, \vi')$ states that when the kv-store is described by $\hh$, a client with view $\vi$ is allowed to execute a single transaction with fingerprint $\opset$, commit the transaction and obtain an updated view $\vi'$. 

\ac{
For example, \emph{serialisability} can be described as the set 
of key-value stores for which it is possible to recover a total schedule of transactions, 
such that each read operation on key $\ke$ fetches its value from the 
most recent write on the same key \cite{??????}.
In this sense, the kv-store $\hh$ from \cref{fig:hheap-a} is not serialisable: 
transaction $\txid_1$ reads the initial version carrying value $\val'_0$ for key $\ke_{2}$, 
and installs a new version of $\ke_{2}$ carrying value $\val_1$. The transaction $\txid_2$ 
reads the initial version carrying value $\val'_0$, and therefore, 
cannot be scheduled after $\txid_1$. Similarly, $\txid_2$ cannot be scheduled after $\txid_1$.
}

\begin{definition}
\label{def:execution.test}
An \emph{execution test} is a set of tuples $\ET \subseteq \HisHeaps \times \Views \times \powerset{\Ops} \times \Views$ 
such that for all $(\hh, \vi, \opset, \vi') \in \ET$:
\begin{align}
    & \fora{\otR, \ke, \val} (\otR, \ke, \val) \in \opset \implies \hh(\ke, \max{}_{<}(\vi(\ke))) = \val \tag{Ext} \label{eq:read-external} \\
    & \fora{\ke} \vi(\ke) \neq \vi'(\ke) \implies
    ( (\otR, \ke, \_) \in \opset \vee (\otW, \ke, \_)) \in \opset) \tag{ValidViewUpd} \label{eq:valid-view-update}
\end{align}
\end{definition}

Execution tests enforce last write win,
\ie a transaction always reads the most recent writes from the initial view (\cref{eq:read-external}).
For minimum footprint on the views, a transaction is only allowed to update the view for those keys that have been read or overwritten (\cref{eq:valid-view-update}).

\azalea{Explain the two conditions in 1 and 2.}

%Given an execution test $\ET$, 
%then $(\hh, \vi, \opset, \vi') \in \ET$ means that 
%a client whose view over the key-value store $\hh$ is $\vi$, 
%can commit a transaction whose fingerprint is $\opset$;
%as a result of this operation, the view of the client must be updated to $\vi'$.
Hereafter, we adopt a more suggestive notation and write $\ET \vdash (\hh, \vi) \triangleright \opset: \vi'$ 
for $(\hh, \vi, \opset, \vi') \in \ET$.
Execution tests induce \emph{consistency models} \( \CMs(\ET) \) as defined in \cref{def:reduction,def:cm}.

\azalea{Add an example of execution test, \eg for serialisability.}
An example of execution test is serialisability (\SER).
The execution test for \( \SER \) requires the initial view  \( \vi \) contains all the versions in the key-value store \( \mkvs \), that is, \( \fora{\ke, i < \abs{\mkvs(\ke)} } i \in \vi(\ke)\).
It matches the intuition that a transaction should observe the up-to-date state of the database.
Later in \cref{sec:spec} we present more examples of execution tests of well-known consistency models in the literature. 

\sx{ The following might go to appendix as it seems not very useful in the main body and cut the flow a bit}

\begin{definition}[$\ET$-reductions]
\label{def:reduction}
An \emph{action} $\alpha \in \Act$ has either the form $(\cl, \varepsilon)$, 
or $(\cl, \opset)$, 
where $\cl$ is a client and $\opset$ is a fingerprint. 
Given an execution test $\ET$, the $\ET$-\emph{reduction}, 
$\xrightarrowtriangle{}_{\ET} \subseteq \Confs \times \Act \times \Confs$, 
is the smallest relation such that for all $\vi, \vi', \cl, \hh, \hh', \viewFun, \opset$:
\begin{enumerate}
	\item 
    $
    \viewFun(\cl) = \vi 
    \wedge \vi \sqsubseteq \vi' 
    \implies (\hh, \viewFun) \xrightarrowtriangle{(\cl, \varepsilon)}_{\ET} 
    (\hh, \viewFun\rmto{\cl}{\vi'})$; and
	\item 
    $\viewFun(\cl) = \vi
        \wedge (\ET \vdash (\hh, \vi) \triangleright \opset: \vi')  
        \wedge \hh' \in \updateKV(\hh, \vi, \cl, \opset) \implies
	$  \\
	\phantom{a} \hfill 
	$(\hh, \viewFun) \xrightarrowtriangle{(\cl, \opset)}_{\ET} (\hh', \viewFun\rmto{\cl}{\vi'})$
\end{enumerate}
%Such relations take the name of $\ET$-reductions, or simply reductions.
%
Given an execution test $\ET$, an \emph{$\ET$-trace} is a sequence of $\ET$-reductions of the form $\conf_{0} \xrightarrowtriangle{\alpha_{0}}_{\ET} \cdots 
\xrightarrow{\alpha_{n-1}} \conf_{n}$.
\end{definition}
%
%
%
%
\subsubsection{Consistency Models}
Consistency models are computed from execution tests by closing the set of initial key-value stores with respect to two operations: 
\begin{enumerate*}[label=(\arabic*)]
	\item advancing the view of a client; and 
	\item committing a fingerprint of a transaction. 
\end{enumerate*}
Lastly, consistency models induced by execution tests are \emph{monotonic} (\cref{prop:mono-et}).
%
%
\begin{definition}[Consistency Models]
\label{def:cm}
Given an execution test $\ET$, the set of configurations induced by $\ET$ is given by:
\[
\Confs(\ET) \defeq \Setcon{ \conf}{ \exsts{\conf_0} \conf_0 \text{ is initial } \wedge \conf_0 \xrightarrowtriangle{\stub}_{\ET} \cdots \xrightarrowtriangle{\stub}_{\ET} \conf }
\]
The \emph{consistency model} induced by $\ET$ is:
\( 
\CMs(\ET) \defeq \Setcon{ \hh }{ (\hh, \stub) \in \Confs(\ET) }
\)
\end{definition}




\begin{proposition}
\label{prop:mono-et}
Let $\ET_1 \subseteq \ET_2$. Then $\CMs(\ET_1) \subseteq \CMs(\ET_2)$.
\end{proposition}
\begin{proof}
    \ifTechReport
    \input{\RootPath/semantics/et-mono.tex}
    \else
    See \cref{sec:mono-et}.
    \fi
\end{proof}

\begin{definition}
Two triples $(\cl_1, \opset_1)$ and $(\cl_2, \opset_2)$ are 
conflicting if either $\cl_1 = \cl_2$, or there exists a key $\ke$ such that 
$(\otW, \ke, \_) \in \opset_1, (\otW, \ke, \_) \in \opset_2$. 

An execution test is $\ET$ is \emph{commutative} if, whenever $(\cl_1, \vi_1, \opset_1)$, 
$(\cl_2, \vi_2, \opset_2)$ are non-conflicting, and $\vi_1, \vi_2 \in \Views(\hh_0)$,  
then for any $\hh_0, \hh', \viewFun, \viewFun'$ we have that 
\[
\begin{array}{lr}
(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} 
\_ \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} (\hh', \viewFun') &\implies \\
(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} 
\_ \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} (\hh', \viewFun')
\end{array}
\]
\end{definition}

\begin{definition}
An execution test $\ET$ has \emph{no blind writes} if, whenever $\ET \vdash (\hh, \vi) \triangleright \opset \cup \{(\otW, \ke, \_)\} : \vi'$, 
then $(\otR, \ke, \_) \in \opset$.
\end{definition}

\begin{definition}
An execution test $\ET$ has \emph{minimum footprints} if for any key-value store \( \hh \)
views \( \vi, \vi',\vi''\) and fingerprint \( \f \),
\[
\begin{array}{@{}l@{}}
    ( \fora{ \ke} (\stub, \ke, \stub) \in \f \implies \vi(\ke) = \vi'(\ke) ) \land {} \\
    \quad \ET \vdash (\hh, \vi) \triangleright \opset : \vi'' \implies \ET \vdash (\hh, \vi') \triangleright \opset : \vi''
\end{array}
\]
\end{definition}

\begin{definition}
An execution test $\ET$ has \emph{continuous post-views} if for any key-value store \( \hh \)
views \( \vi, \vi',\vi''\) and fingerprint \( \f \), 
\[
\begin{array}{@{}l@{}}
    \quad \ET \vdash (\hh, \vi) \triangleright \opset : \vi' \land \vi' \sqsubseteq \vi'' \implies \ET \vdash (\hh, \vi) \triangleright \opset : \vi''
\end{array}
\]
\end{definition}

\begin{theorem}                                                                            
Let $\ET_1, \ET_2$ be two execution tests has no blind writes, minimum footprints and continuous post-views.
If $\ET_1$ is commutative, 
then $\CMs(\ET_1 \cap \ET_2) = \CMs(\ET_1) \cap \CMs(\ET_2)$. 
Furthermore, if $\ET_1, \ET_2$ are commutative, then $\ET_1 \cap \ET_2$ 
is commutative.
\end{theorem}
\begin{proof}
    See \cref{sec:et-comm}.
\end{proof}
