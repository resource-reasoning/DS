\subsection{Multi-version Key-value Stores and Views}
\label{sec:mkvs-view}

\subsubsection{Multi-version Key-value Stores} 
We assume a countably infinite set of \emph{client identifiers} $\Clients \defeq \Set{\cl, \cl',\cdots}$. 
We define the set of \emph{transaction identifiers} 
$\TxID \defeq  \Set{\txid_{0}} \uplus \Set{ \txid_{\cl}^{n} \mid \cl \in \Clients \wedge n \geq 0 }$, where 
 $\txid_0$ denotes a designated transaction used for initialisation, 
 and for each $n \in \mathbb{N}$, $\txid_{\cl}^{n}$ identifies the $n$\textsuperscript{th} transaction of client $\cl$. 
Elements of $\TxID$ are ranged over by $\txid, \txid', \cdots$, 
while subsets of $\TxID$ are ranged over by $\txidset, \txidset', \cdots$. 
We define $\TxID_{0} \defeq \TxID \setminus \{ \txid_0\}$.
As we will see, we assume that each client is bound to a single session, and 
we use the superscript $n$, in a transaction identifier $\txid_{\cl}^{n}$, 
to embed the information about the session order in which clients execute 
transactions:  
%
%The structure of $\TxID$  
%embeds the transaction execution order for each client, or the \emph{session order} $\PO$. 
%More concretely, 
$\PO \defeq \Set{ (\txid, \txid') \mid \exsts{ \cl, n,m } \txid = \txid_{\cl}^{n} \wedge \txid' = \txid_{\cl}^{m} \wedge n < m}$.
%As such, $(\txid, \txid') \in \PO$ denotes that 
%client $\cl$ executes $\txid$ before $\txid'$.
For readability, we often write  $\txid \xrightarrow{\PO} \txid'$ for $(\txid, \txid') \in \PO$.

%Given a set $X$, 
%%then $\powerset{X}$ denotes 
%%the powerset of $X$,
%we write $X^{\ast}$ for the free monoid induced by $X$.
%We next define the notion of \emph{multi-version key-value stores}.


\begin{definition}[Multi-version Key-value Stores]
\label{def:his_heap}
\label{def:mkvs}
Assume a countably infinite set of \emph{keys} $\Keys = \Set{\ke, \ke', \cdots}$, 
and a set of \emph{values} $\Val = \{\val, \val', \cdots\}$.

A \emph{version} is a triple $\ver \in \Versions \defeq \Val \times \TxID \times \powerset{\TxID_{0}}$. 
%The set of versions is denoted by $$.
A \emph{key-value store} is a mapping $\hh: \Keys \rightarrow \Versions^{\ast}$, 
where we recall that $\Versions^{\ast}$ is the free monoid generated by $\Versions$.
%\ac{ The superscript fin over the $\rightharpoonup$ needs to be fixed. You may want to look at the package extpfeil.}
\end{definition}

For simplicity, we instantiate the set of values as  $\Val \eqdef \Nat \uplus \Keys$,
and assume a default value $\val_0 \in \Val$. 
A \emph{version} $\ver = (\val, \txid, \txidset)$ comprises a value $\val$,
and the meta-data of the transactions that accessed it.
Specifically, the \emph{writer} $\txid$ identifies the transaction that wrote version $\ver$, 
and the \emph{readers} $\txidset$ denotes the set of transactions that read from $\ver$.
Given a version $\ver = (\val, \txid, \txidset)$, we define $\valueOf(\ver) \defeq \val$,
$\WTx(\ver) \defeq \txid$ and $\RTx(\ver) \defeq \txidset$.
Lists of versions (\ie elements of $\Versions^{\ast}$) are ranged over by $\vilist, \vilist',\cdots$.

A \emph{multi-version key-value store}, or \emph{kv-store}, 
is a mapping from keys to lists of versions. 
Given kv-store $\hh$, key $\ke$ and index $i \geq 0$, 
we write $\hh(\ke, i)$ for the $i$-th version (starting from $0$) of $\ke$.
That is, if $\hh(\ke) = \ver_0 \cdots\ver_{n}$, then $\hh(\ke, i) \defeq \ver_{i}$ for $i \leq n$; 
and is undefined otherwise. 
We write $\lvert \hh(\ke) \rvert$ for the length of $\hh(\ke)$. 

We focus on key-value stores whose consistency model enforces the \emph{atomic visibility} of transactions~\cite{framework-concur}. 
This amounts to requiring that transaction reads at most one version of each key, and similarly 
it writes at most one version for each key. From the point of view of key-value stores, 
these conditions amount to require that 
$\fora{\ke i, j} (o \leq i, j \abs{ \hh(\ke) } \land \RTx(\hh(\ke, i)) \cap \RTx(\hh(\ke, j)) \neq \emptyset ) \implies i = j$, 
and 
$\fora{\ke, i, j} (0 \leq i,j < \abs{ \hh(\ke) } \wedge \WTx(\hh(\ke, i)) = \WTx(\hh(\ke, j)) ) \implies i = j$. 
We also assume that each key has an initial version carrying a default value $\val_0$, 
written by the designated initialisation transaction $\txid_0$: $\fora{\ke} \hh(\ke, 0) = (\val_0, \txid_0, \stub)$.
Finally, assume that the state of a key-value store is consistent with 
the session order of clients; a client cannot read a version of a key that has 
been installed by a future transactions within the same session, and 
the order in which versions are installed by a single client must agree 
with its session order:  
$\fora{ \ke, \cl, i,j, n, m} 0 \leq i < j < \abs{\hh(\ke)} 
    \land \txid_{\cl}^{n} = \WTx(\hh(\ke,i)) {} \wedge \txid_{\cl}^{m} \in \Set{\WTx(\hh(\ke,j))} \cup \RTx(\hh(\ke, i))
    \implies n < m $.
%
%Formally, we require the following well-formedness requirement from key-value stores: 
%
%\begin{enumerate}%[label=(\roman*)]
%\item\label{kv:wf.init} 
%    $\hh(\ke, 0) = (\val_0, \txid_0, \stub)$ for $\ke \in \dom(\hh)$, where $\val_0$ is the default value in $\Val$;
%\item\label{kv:wf.onewrite} 
%    transactions write at most one version for each key:
%\[
%\fora{\ke, i,j }
%0 \leq i, j < \abs{ \hh(\ke) }
%\land \WTx(\hh(\ke, i)) = \WTx(\hh(\ke, j))
%\implies i = j 
%\]
%\item\label{kv:wf.oneread} 
%    transactions read at most one version for each key:
%\[
%\fora{\ke, i,j } 
%0 \leq i, j < \abs{ \hh(\ke) }
%\land \RTx(\hh(\ke, i)) \cap \RTx(\hh(\ke, j)) \neq \emptyset 
%\implies i = j
%\]
%\item\label{kv:wf.so} 
%	transactions (of the same client) install different versions of a key in the session order; 
%%    the order in which transactions issued by the same client install different versions for a key $\ke$, 
%%    is consistent with the session order;
%    a client $\cl$ can read versions written by $\cl$ itself only after they have been installed:
%\begin{multline*}
%    \fora{ \ke, \cl, i,j, n, m} 
%    0 \leq i < j < \abs{\hh(\ke)} 
%    \land \txid_{\cl}^{n} = \WTx(\hh(\ke,i)) \\
%    {} \wedge \txid_{\cl}^{m} \in \Set{\WTx(\hh(\ke,j))} \cup \RTx(\hh(\ke, i))
%    \implies n < m
%\end{multline*}
%\end{enumerate}
%
Henceforth, we assume that kv-stores are always well-formed, and we use $\HisHeaps$ to denote 
the set of well-formed kv-stores.

\subsubsection{Views and Configurations}

Key-value stores track the global state of a database. 
However, when executing transactions,
different \emph{clients} may observe different versions of the same key. 
To keep track of the versions they observe,
clients are associated with \emph{views} (\cref{def:view}). 
A view of a kv-store $\hh$ is a mapping from the keys in $\hh$ on to a set of natural numbers. 
For each $\ke \in \dom(\hh)$, the $\vi(\ke)$ denotes the indices of versions in $\hh(\ke)$ recorded in $\vi$. 
As such, when $i \in \vi(\ke)$ then $ i < \abs{ \hh(\ke) }$. 
Moreover, the initialisation version (at index $0$) must be included in all views. 
These two properties are captured by \eqref{eq:view.wf} in \cref{def:view} below. 
Lastly, views cannot observe \emph{partial} effects of a given transaction. 
That is, if a view includes a version written by a transaction $\txid$, it must include \emph{all} versions written by $\txid$. 
This is formalised by \eqref{eq:view.atomic} in \cref{def:view} below, and captures the \emph{atomic visibility} of transactions. 


At any point during execution, the overall state is captured by \emph{a configuration}. 
A configuration includes a kv-store and a partial mapping from clients to views.
The view of the client $\cl$ in $\hh$ reflects the set of versions for each key 
that the client \(\cl \) observes upon executing a transaction. 
%The constraint of \cref{eq:view.atomic} establishes that if a client observes 
%a version of some key written by a transaction $\txid$, then it must observe all the versions of 
%all keys that $\txid$ wrote. 


\begin{definition}[Views, configurations]
\label{def:view}
\label{def:cuts}
\label{def:views}
\label{def:configuration}
A \emph{view} of a kv-store $\hh$ is a mapping  
$\vi \in \Views(\mkvs) \defeq \dom(\hh) \to\powerset{\Nat}$ such that:
\begin{align}
    & \fora{ \ke } 
    0 \in \vi(\ke) 
    \wedge \fora{ i \in \vi(\ke) } 
    i < \abs{ \hh(\ke) } 
    \tag{WF}
    \label{eq:view.wf}\\
    %\Set{0} \subseteq \vi(\ke) \subseteq \Setcon{i}{ 0 \leq i < \abs{\mkvs(\ke)}}
    & 
    \fora{ \ke,\ke', i,j} 
	j \in \vi(\ke) 
	\land \WTx(\hh(\ke, j)) = \WTx(\hh(\ke', i) 
	\implies i \in \vi(\ke')
	\tag{Atomic}
	\label{eq:view.atomic}
\end{align}

\emph{The set of views} is
$
\Views \defeq \bigcup_{\hh \in \HisHeaps} \Views(\hh)
$.
A \emph{configuration}, $\conf \in \Confs$, is a pair $(\hh, \viewFun)$, 
where $\hh \in \HisHeaps$ and
$\viewFun : \Clients \parfinfun \Views(\hh)$. 
The $\conf_{0} = (\hh_{0}, \viewFun_{0})$ is an
\emph{initial configuration} if, $\hh_{0}(\ke) = (\val_0, \txid_0, \emptyset)$ for all $\ke \in \Keys$.
\end{definition}



Given a kv-store $\hh$ and two views $\vi, \vi' \in \Views(\hh)$, 
we write $\vi \viewleq \vi'$ when $\vi(k) \subseteq \vi'(\ke)$ for all $\ke \in \dom(\hh)$. 
Also, we commit an abuse of notation and write $\hh(\ke, \vi)$ as a shorthand 
for $\hh(\ke, \max_{<}(\vi(\ke)))$. 
Note that such a version always exists as
$\vi(\ke) \neq \emptyset$ (see \eqref{eq:view.wf} above).

\subsubsection{Snapshots}
Transactions are executed with respect to a \emph{snapshot} of a kv-store.
A snapshot $\h$ is a mapping from keys to values (\cref{def:snapshot}). 
Given a view $\vi$ of a transaction, a snapshot can be induced 
by extracting the value of the latest observable version for each key $\ke \in \dom(\hh)$. 
%Views are used to determine the snapshot in which a transaction 
%is executed, according to the following definition.


\begin{definition}[Snapshots]
\label{def:heaps}
\label{def:snapshot}
A snapshot is a mapping from keys to values \( \ss \in \Snapshots  \defeq \Keys \to \Val\).
Given $\hh \in \HisHeaps$ and $\vi \in \Views(\hh)$, the \emph{snapshot} of $\vi$ in 
$\hh$ is defined as $\snapshot(\hh, \vi) \defeq \lambda \ke \ldotp \valueOf(\hh(\ke, \max_{<}(\vi(\ke)))$.
\end{definition}

\paragraph{Fingerprints}
Once the execution of a transaction is completed, its effects are committed to the kv-store. 
The effects of transactions are modelled as a \emph{fingerprint} $\opset$. 
A finger print comprises a set of \emph{operations} $\Ops$: $\opset \subseteq \Ops$. 
An operation is a triple of the form $(l, \ke, \val)$ with $l \in \{\otR, \otW\}$.    
Intuitively, given the fingerprint $\opset$ of a transaction $\txid$, 
$(\otR, \ke, \val) \in \opset$ denotes that 
$\txid$ requested to read key $\ke$ from the kv-store, 
and it fetched a version carrying value $\val$.
Similarly, $(\otW, \ke, \val) \in \opset$ denotes that 
$\txid$ attempted to write value $v$ for key $\ke$. 
A fingerprint includes at most one read operation per key;
this formalises the intuition that, in our setting, 
transactions always read from an atomic snapshot of the kv-store. 
Analogously, a fingerprint includes at most one write operation per key.
%because a client either observes none or all the updates of a transaction.

\begin{definition}[Fingerprints]
The set of \emph{operations} is
$\Ops \defeq \{(l, \ke, \val) \mid$ $ l \in \Set{\otW, \otR} \land \ke \in \Keys \wedge \val \in \Val \}$.
A \emph{fingerprint} $\opset$ is a subset of operations, $\opset \subseteq \Ops$,
such that for all $\ke \in \Keys$ and \( l \in \Set{\otW, \otR} \),
if $(l, \ke, \val_1), (l, \ke, \val_2) \in \opset$, then $\val_1 = \val_2$.
\end{definition}



%\ac{Note that I now require fingerprints to be non-empty sets of transactions. This simplifies a lot the development of 
%the theory of kv-stores, and it fixes a problem that was spotted by Shale, that breaks the compositionality of 
%execution tests (see later). The main reason why we allowed empty fingerprints is that in the semantics, a client can 
%execute a transaction with no access to the memory. In practice, in the semantics we can require that at least 
%one access to the database must be performed in transactions. This can be checked syntactically, and nobody 
%should complain about that. I can put a remark about how this is a natural requirement that, if violated, 
%breaks the compositionality of consistency models.\\ 
%\textbf{Update 02/08/2018}: empty fingerprints are now allowed again. We still had some problems with compositionality, 
%one of which has to do with the fact that we allow the view of a client over some key to move freely after executing a transaction, 
%even if such a key was not accessed by the transaction. Later, I forbid this behaviour by requiring in execution tests that the 
%view of an client for a given key cannot be shifted if the transaction executed by the client did not access such a key.}
%$(\otW, \ke, \val) \in \opset$ means that the transaction writes a new version, carrying value $\val$, for key $\ke$. 




%of $\vi$ by accessing the value of 
%A view $\vi$ in $\hh$ naturally defines a snapshot $\snapshot(\hh, \nu)$
%A MKVS tracks the global state of the system; however, different \emph{clients} may observe different versions of the same key. 
%To model this, we introduce the notion of \emph{views} (\cref{def:views}). 
%A view $V$ reflects the particular version for each key that a client observes upon executing a transaction. 
%%We present an example of views in \cref{fig:hheap-a} with two views: $\client_1$ in red and $\client_2$ in blue.
%More concretely, the view for \( \client_1 \) is given formally as $\vi_1 = \Set{\key{k}_1 \mapsto 1, \key{k}_2 \mapsto 0}$.
%That is, the client with view $\vi_1$ observes the second version (at index 1) of key \( \ke_{1} \) with value $v_1$, and the first version (at index 0) of key \( \ke_2 \) with value $v'_0$.
%%, and 
%%the first version of $\key{k}_2$, carrying value $0$. Similarly, according to its view 
%%$V_2 = [\key{k}_1 \mapsto 2, \key{k}_2 \mapsto 2]$, the client $\txid_2$ observes 
%%in $\hh$the second and most up-to-date version for both $\key{k}_1$ and $\key{k}_2$.
%
%\begin{definition}[Views]
%\label{def:view}
%\label{def:cuts}
%\label{def:views}
%\emph{A view} is a partial finite function from keys to indexes:
%$
%\vi \in \Views \defeq \Addr \parfinfun \Nat 
%%\begin{rclarray}
%%    \vi \in \Views & \defeq & \Addr \parfinfun \Nat 
%%\end{rclarray}
%$.                                                                 
%The \emph{view composition}, $\composeVI: \Views \times \Views \rightharpoonup \Views$ is defined as the standard disjoint function union: $\composeVI \eqdef \uplus$. 
%% \( \vi \composeVI \vi' \defeq \vi \uplus \vi'\) 
%The \emph{unit view}, $\unitVI \in \Views$, is a function with an empty domain: $\unitVI \eqdef \emptyset$. 
%% and the unit is \( \unitVI \defeq \emptyset\).
%The \emph{order relation} on views, $\orderVI: \Views \times \Views$, is defined between two views with the same domain as the point-wise comparison of their indexes for each entry: 
%\[
%\begin{rclarray}
%    \vi \orderVI \vi' & \defiff & \dom(\vi) = \dom(\vi') \land \fora{\ke} \cu(\ke) \leq \cu'(\ke) \\
%\end{rclarray}
%\]
%\end{definition}
%%
%We say view $\vi$ is \emph{older} than view $\vi'$ (or $\vi'$ is \emph{newer} than $\vi$) whenever $\vi \orderVI \vi'$ holds.
%
%
%\mypar{Configurations} A \emph{configuration} comprises an MKVS, and the views associated with clients.
%In \cref{fig:hheap-a} we present an example of a configuration comprising an MKVS and the two views associated with clients $\client_1$ and $\client_2$. 
%We write $\version(\hh, \ke, \vi)$ for $\hh(\ke, \vi(\ke))$; 
%and write $\valueOf(\hh, \ke, \vi)$ as a shorthand for $ \valueOf(\version(\hh, \key{k}, V))$; similarly for $\WTx, \RTx$.
%%we commit an abuse of notation and often write $\valueOf(\hh, \ke, \vi)$ in lieu of $ \valueOf(\version(\hh, \key{k}, V))$, and similarly for $\WTx, \RTx$.
%When $\ver = \version(\hh, \ke, \vi)$, we say that \emph{$\vi$ $\ke$-points to $\ver$ in $\hh$}. 
%When $\ver = \hh(\ke, i)$ for some $0 \leq i \le \vi(\ke)$, we say that \emph{$\vi$ $\ke$-includes $\ver$ in $\hh$}.
%Lastly, we always assume that MKVSs, views, and configurations are well-formed, unless otherwise stated.
%
%
%
%\begin{definition}[Configurations]
%A view $\vi$ is \emph{well-formed with respect to an MKVS} $\mkvs$, written \( \wfV{\mkvs, \vi} \),  iff they have the same domain and every index from $\vi$ is within the range of the corresponding entry in $\mkvs$ and the view is \emph{atomic} with  respect to the key-value store: 
%\[
%\begin{rclarray}
%    \wfV{\mkvs, \vi} & \defeq & \dom(\mkvs) = \dom(\vi) \land \fora{\ke \in \dom(\vi)} 0 \leq \vi(\ke) < \lvert \mkvs(\ke) \rvert \\
%    \pred{atomic}{\vi ,\hh} & \eqdef & \fora{\txid } \exsts{\ke, i} i \leq \vi(\ke) \land \hh(\ke,i) = (\stub, \txid, \stub) \implies \pred{visible}{\txid, \vi, \hh} \\ 
%    \pred{visible}{\txid, \vi, \hh} & \eqdef & \fora{\ke, i} \hh(\ke,i) = (\stub, \txid, \stub) \implies i \leq \vi(\ke) 
%\end{rclarray}
%\]
%%
%\azalea{We need a symbol for this to fill the ???? above. Also ???? below. \sx{Done}}
%A \emph{configuration} $\conf$ is a pair of the form $(\hh, \viewFun)$, where $\hh$ denotes an MKVS, and $\viewFun: \Clients \parfinfun \Views$ is a partial finite function from clients to views. 
%A configuration $\conf = (\hh, \viewFun)$ is \emph{well-formed}, written \( \wfC{\conf}\), iff for all clients $\cl \in \dom(\viewFun)$, the view $\viewFun(\txid)$ is well-formed with respect to $\hh$. 
%%We say that a view $V$ is well-defined with respect to the 
%%MKVS $\hh$ if, $\forall \key{k} \in \ke. 0 < V(\key{k}) \leq 
%%\lvert \hh(\key{k}) \rvert$. 
%%Given a view $V$ that is well-defined 
%%with respect to a 
%
%\end{definition}
%
%\mypar{Snapshots} When a client executes a transaction on the $\mkvs$ MKVS, it extracts a \emph{snapshot} of it via the \( \func{snapshot}{\mkvs, \vi} \) function, extracting the values corresponding to the versions indexed by its view \( \vi \) (\cref{def:snapshot}).
%For instance, for client \( \client_1 \) in \cref{fig:hheap-a}, the $\func{snapshot}{\cdots}$ functions yields a state where key $\ke_1$ carries value $v_1$ and second key \( \ke_2 \) carries value $v'_0$.
%%The concrete state extracted in this way takes the name of the \emph{snapshot} of the transaction.
%%In general, the process of determining the view of a client, hence the snapshot in which such a client executes transactions, is non-deterministic.
%
%\azalea{Before in MKVSs we had values drawn from $\Nat$ in \cref{def:mkvs}. Now we use $\Val$. I think you mean to use $\Val$ in both places? \sx{I would say so} }
%\begin{definition}[Snapshots]
%\label{def:heaps}
%\label{def:snapshot}
%Given the sets of values $\Val$  and keys \( \Addr\)  (\cref{def:mkvs}), the set of \emph{snapshots} is:
%$
%    \h \in \Heaps \eqdef \Addr \parfinfun \Val
%$. 
%%\[
%%\begin{rclarray}
%%    \h \in \Heaps & \eqdef & \Addr \parfinfun \Val
%%\end{rclarray}
%%\]
%The \emph{snapshot composition function}, $\composeH: \Heaps \times \Heaps \parfun \Heaps$, is defined as $\composeH \eqdef \uplus$, where $\uplus$ denotes the standard disjoint function union. The \emph{ snapshot unit element} is $\unitH \eqdef \emptyset$, denoting a function with an empty domain.
%The \emph{partial commutative monoid of snapshots} is $(\Heaps, \composeH, \{\unitH\})$.
%Given an MKVS $\hh$ and a view $\vi$, the snapshot of $\vi$ in $\hh$, written $\snapshot(\hh, \vi) $, is defined as:
%$
%    \snapshot(\hh, \vi) \defeq \lambda \ke \ldotp \valueOf(\hh, \ke, \vi)
%$.
%%\[
%%\begin{rclarray}
%%    \snapshot(\hh, \vi) & \defeq & \lambda \ke \ldotp \valueOf(\hh, \ke, \vi).
%%\end{rclarray}
%%\]
%\end{definition}
%
%\sx{Need some explanation}
%\ac{General Comment on this Section: it is too abstract. We 
%should give either here or in the introduction an example of computation - 
%the write skew program should be okay that helps the reader understanding 
%what's going on. Also, it could be also good to illustrate the notions 
%of execution tests and consistency models.}
%
%\sx{From Andrea: introduce the execution test here with a table, also introduce fingerprint here}

