\begin{definition}[Multi-version Key-value Stores]
\label{def:mkvs-appendix}
Assume a countably infinite set of \emph{keys} $\Keys \ni \ke$, 
and a countably infinite set of  \emph{values} $\Val \ni \val$, 
including an \emph{initialisation value} $\val_0 $.
The set of \emph{versions}, $\Versions \ni \ver$, is: $\Versions \defeq \Val \times \TxID \times \powerset{\TxID_{0}}$. 
A \emph{key-value store}, abbreviated to kv-store,  is a function $\hh: \Keys \rightarrow \Versions^{\ast}$, 
where $\Versions^{\ast}$ is the free monoid on $\Versions$. 
The \emph{initial key-value store} is given by $\hh_0$, where 
$\hh_{0}(\ke)\defeq  (\val_0, \txid_0, \emptyset)$ for
all $\ke \in \Keys$.
Well-formed key-values store satisfy:
\begin{align}
& \fora{\ke, i, j} 
\RTx(\hh(\ke, i)) \cap \RTx(\hh(\ke, j)) \neq \emptyset \lor
\WTx(\hh(\ke, i)) = \WTx(\hh(\ke, j))
\implies i = j  \\
& \fora{\ke} \hh(\ke, 0) = (\val_0, \txid_0, \stub) \\
& \fora{ \ke, \cl, i,j, n, m} 
\txid_{\cl}^{n} = \WTx(\hh(\ke,i)) \wedge \txid_{\cl}^{m} \in
\Set{\WTx(\hh(\ke,j))} \cup \RTx(\hh(\ke, i)) \implies n < m
\end{align}
\end{definition}

%Among the elements of $\Val$, we distinguish a default value $\val_0 \in \Val$. 
%A \emph{version} $\ver = (\val, \txid, \txidset)$ comprises a value $\val$,
%and the meta-data of the transactions that accessed it.
%Specifically, the \emph{writer} $\txid$ identifies the transaction that wrote version $\ver$, 
%and the \emph{readers} $\txidset$ denote the set of transactions that read from $\ver$.
%Given a version $\ver = (\val, \txid, \txidset)$, we define $\valueOf(\ver) \defeq \val$,
%$\WTx(\ver) \defeq \txid$ and $\RTx(\ver) \defeq \txidset$. 
%Lists of versions (\ie elements of $\Versions^{\ast}$) are ranged over by $\vilist, \vilist',\cdots$.
%Given a key-value store $\hh$ and a transaction identifier $\txid$, we write 
%$\txid \in \hh$ if $\txid$ appears as either the writer or reader of 
%some version included in $\hh$:  $\txid \in \hh \defeq 
%\exists \ke, i. 0 \leq i < \lvert \hh(\ke) \rvert \wedge (\txid \in \RTx(\hh(\ke, i)) \cup \{\WTx(\hh(\ke, i))\})$.

%Given kv-store $\hh$, key $\ke$ and index $i \geq 0$, 
%we write $\hh(\ke, i)$ for the $i$-th version (starting from $0$) of $\ke$.
%That is, if $\hh(\ke) = \ver_0 \cdots\ver_{n}$, then $\hh(\ke, i) \defeq \ver_{i}$ for $i \leq n$; 
%and it is undefined otherwise. 
%We write $\lvert \hh(\ke) \rvert$ for the length of $\hh(\ke)$. 

%We focus on key-value stores whose consistency model enforces the \emph{atomic visibility} of transactions~\cite{framework-concur}. 
%This amounts to requiring that transaction reads at most one version of each key, and similarly 
%it writes at most one version for each key. From the point of view of key-value stores, 
%these conditions amount to require that \textbf{(i)}
%$\fora{\ke, i, j} (o \leq i, j \leq \abs{ \hh(\ke) } \land \RTx(\hh(\ke, i)) \cap \RTx(\hh(\ke, j)) \neq \emptyset ) \implies i = j$, 
%\textbf{(ii)}
%$\fora{\ke, i, j} (0 \leq i,j < \abs{ \hh(\ke) } \wedge \WTx(\hh(\ke, i)) = \WTx(\hh(\ke, j)) ) \implies i = j$. 
%We also assume that the list of version for each key has an initial version carrying a default value $\val_0$, 
%written by the designated initialisation transaction $\txid_0$: \textbf{(iii)} $\fora{\ke} \hh(\ke, 0) = (\val_0, \txid_0, \stub)$.
%Finally, we assume that the state of a key-value store is consistent with 
%the session order of clients; a client cannot read a version of a key that has 
%been installed by a future transactions within the same session, and 
%the order in which versions are installed by a single client must agree 
%with its session order: \textbf{(iv)}
%$\fora{ \ke, \cl, i,j, n, m} 0 \leq i < j < \abs{\hh(\ke)} 
    %\land \txid_{\cl}^{n} = \WTx(\hh(\ke,i)) {} \wedge \txid_{\cl}^{m} \in \Set{\WTx(\hh(\ke,j))} \cup \RTx(\hh(\ke, i))
    %\implies n < m $.

%We say that kv-stores that satisfy the conditions \textbf{(i)}-\textbf{(iv)} above are 
%\emph{well-formed}.
%Henceforth, we will always assume kv-stores tp be well-formed, and we use $\HisHeaps$ to denote 
%the set of well-formed kv-stores.

%\subsubsection{Views and Configurations}

%Key-value stores track the global state of a database. 
%However, clients do not need to agree on the portion of 
%the state of the database that they observe. Different clients 
%may observe different different subsets of versions of the same key.
%When executing transactions,
%To keep track of the versions observed by clients,
%we introduce the notion of \emph{views} (\cref{def:view}). 
%
%\begin{definition}[Views, configurations]
%\label{def:view}
%\label{def:cuts}
%\label{def:views}
%\label{def:configuration}
%A \emph{view} of a kv-store $\hh$ is a mapping  
%$\vi \in \Views(\hh) \defeq \Keys \to\powerset{\Nat}$ such that:
%\begin{align}
    %& \fora{ \ke } 
    %0 \in \vi(\ke) 
    %\wedge \fora{ i \in \vi(\ke) } 
    %i < \abs{ \hh(\ke) } 
    %\tag{WF}
    %\label{eq:view.wf}\\
    %& 
    %\fora{ \ke_1,\ke_2, i_1, i_2} 
	%i_1 \in \vi(\ke_1) 
	%\land \WTx(\hh(\ke_1, i_1)) = \WTx(\hh(\ke_2, i_2)) 
	%\implies i_2 \in \vi(\ke_2)
	%\tag{Atomic}
	%\label{eq:view.atomic}
%\end{align}
%A \emph{configuration} $\conf \in \Confs$, is a pair $(\hh, \viewFun)$, 
%where $\hh \in \HisHeaps$ and
%$\viewFun : \Clients \parfinfun \Views(\hh)$. 
%\end{definition}
%Configurations extend key-value stores with the information of 
%the views of each client. In a configuration $\conf = (\hh, \viewFun)$, the view of client 
%$\cl$, $\vi = \viewFun(\cl)$ (if defined) determines for each key $\ke \in \Keys$ the sub-list of versions in $\hh$ 
%that the client is aware of, or equivalently that it can observe. If $i,j \in \vi(\ke)$ and $i < j$, then the client is 
%aware of the fact that $\hh$ contains the versions $\hh(\ke, i)$, $\hh(\ke, j)$, and that $\hh(\ke, j)$ is more 
%up-to-date than $\hh(\ke, i)$. The client also observes the information relative to the versions $\hh(\ke, i)$ and 
%$\hh(\ke, j)$, i.e. the value they carry and the meta-data relative to writing and reading transactions of such 
%versions. 
%Equation \eqref{eq:view.wf} in \cref{def:view} is a natural requirement, while \eqref{eq:view.atomic} 
%models the atomic visibility of transactions: if a client observes the updates of a transaction $\txid$, then 
%it must observe all the updates from $\txid$. 
%We let $\Views = \bigcup_{\hh \in \HisHeaps} \Views(\hh)$ be the set of all view. 
%Given a kv-store $\hh$ and two views $\vi, \vi' \in \Views(\hh)$, 
%we write $\vi \viewleq \vi'$ when $\vi(k) \subseteq \vi'(\ke)$ for all $\ke \in \dom(\hh)$. 
%The initial view $\vi_{0}$ is defined as $\vi_{0}(\ke) = \{0\}$ for each $\ke \in \Keys$.
%A configuration $\conf_{0} = (\hh_{0}, \viewFun_{0})$ is
%\emph{initial} if $\hh_{0}(\ke) = (\val_0, \txid_0, \emptyset)$ for all $\ke \in \Keys$.
%
%Given a configuration $\conf = (\hh, \viewFun)$ and a client $\cl$ for which 
%$\viewFun(\cl)$ is defined, the view $\vi(\cl)$ is used to determine a \emph{snapshot}, i.e. 
%a mapping from each key to a unique value that the client observes when executing a transaction. 
%In general, the snapshot of a transaction is also determined by a \emph{resolution policy} 
%cite{}. Throughout this paper, we assume that the database employ the \emph{Last Writer 
%Wins} \cite{} resolution policy to determine the snapshot of clients, although generalisation 
%to different resolution policies is straightforward.
%
%\begin{definition}[Snapshots]
%\label{def:heaps}
%\label{def:snapshot}
%A snapshot is a mapping from keys to values \( \ss \in \Snapshots  \defeq \Keys \to \Val\).
%Given $\hh \in \HisHeaps$ and $\vi \in \Views(\hh)$, the \emph{snapshot} of $\vi$ in 
%$\hh$ is defined as $\snapshot(\hh, \vi) \defeq \lambda \ke \ldotp \valueOf(\hh(\ke, \max_{<}(\vi(\ke)))$, 
%where we recall that $\max_{<}(\vi(\ke))$ is the maximum element in $\vi(\ke)$ with respect to the natural 
%order $<$ over $\mathbb{N}$.
%\end{definition}
%Given a kv-store $\hh$, a key $\ke$ and a view $\vi$, we often commit an abuse of notation and write 
%$\hh(\ke, vi)$ as a shorthand for 
%$\hh(\ke, \max_{<}(\vi(\ke))$. Thus, $\snapshot(\hh, \vi) = \lambda \ke \ldotp \valueOf(\hh(\ke, \vi))$. 
%
%\begin{remark}
%Because the function $\snapshot(\hh, \vi)$ only selects the last version of $\hh$ comprised 
%in $\vi$, one may wonder about the necessity of including multiple versions in the view of a 
%key $\ke$.  Here we only point that requiring a view to contain a single version for each key 
%would impair the expressiveness of our framework in terms of consistency models that it captures; 
%unfortunately, we have to wait until \cref{........} before giving more details on this issue.
%\end{remark}


%\paragraph{Committing a Transaction.}
%Until now we have only discussed the structure of key-value stores. 
%Next, we describe how the state of a key-value store changes, when 
%one client executes a transaction. 
%In our framework, transactions are executed atomically. 
%Roughly speaking, given a configuration $\conf = (\hh, \viewFun)$, 
%when a client $\cl$ executes some transactional code $\ptrans{\trans}$, 
%then it performs the following steps: 
%\textbf{(i)} it constructs a snapshot of $\hh$ from the view $\viewFun(\cl)$ that 
%the client has over $\hh$; \textbf{(ii)} it executes the code $\trans$ in isolation, using the 
%snapshot constructed in the previous step as the initial, local state of the client, and it determines the visible 
%effects that such an execution has on the key-value store; \textbf{(iii)} it incorporates 
%the effects of executing the code $\trans$ in the initial state determined by the snapshot into 
%the key-value store.

%We have already discussed how to construct a snapshot of the key-value store. 
%We represent the \emph{visible effects} of the execution of a transaction as \emph{Read-Write Sets}. 
%Roughly speaking, a read-write set is a labelling of the operations that the client performs on  
%the key-value store when executing a transaction: each of these labelling includes the kind of 
%operation performed (either a $\mathsf{R}$ead or a $\mathsf{W}$rite), 
%the key on which the operation has been performed, and either the value hat has been fetched from 
%(in the case of a read operation), or the value that has been inserted into the key-value store.
%We defer the discussion of how to determine the read-write set $\ptrans{\trans}$, 
%when executing from some initial client-local state, formalised as a mapping from keys to values, to 
%\cref{........}. 

%\begin{definition}[Read-Write Sets]
%Let 
%$\Ops \defeq \{(l, \ke, \val) \mid$ $ l \in \Set{\otW, \otR} \land \ke \in \Keys \wedge \val \in \Val \}$ 
%be a set of operations. 
%A \emph{Read-Write Set} $\opset$ is a subset of operations, $\opset \subseteq \Ops$,
%such that for all $\ke \in \Keys$ and \( L \in \Set{\otW, \otR} \),
%if $(L, \ke, \val_1), (L, \ke, \val_2) \in \opset$, then $\val_1 = \val_2$.
%\end{definition}
%Note that we have placed a constraint that read-write sets contains at most one value read, 
%and at most one value written, per key. This reflects the fact that we only consider transactions 
%that are atomically visible \cite{laws}.

%Finally, we need to address how the effects of a transaction executed by client $\cl$, formalised 
%as a read-write set $\opset$, are pushed into a key-value store $\hh$. To this end, we also 
%need to know the view $\vi$ that the client has on $\hh$.
%First, we must associate the read-write set $\opset$ with a transaction identifier $\txid$.  
%Because we are assuming that the read-write set is being merged into the key-value store from client $\cl$, 
%it is natural to choose $\txid$ from the set $\{\txid_{\cl}^{n} \mid n \in \mathbb{N}\}$. 
%Furthermore, we must choose a transaction identifier of the form 
%$\txid_{\cl}^{n}$, where $n$ is greater than any index $m$ such that 
%$\txid_{\cl}^{m} \in \hh$: because such transaction identifiers are already present 
%in the key-value store, they correspond to transactions that have been previously executed 
%by $\cl$, and thus they must precede the transaction identifier $\txid_{\cl}^{n}$ in the session 
%order. Formally, we define the set $\nextTxId(\cl, \hh) = \{ \txid_{\cl}^{n} \mid \forall m \in \mathbb{N}. \; 
%\txid_{\cl}^{m} \in \hh \implies m < n\}$, and we require that $\txid_{\cl}^{n} \in \nextTxId(\cl,\hh)$. 
%Having selected a suitable transaction identifier $\txid_{\cl}^{n}$, we push the read-write set $\opset$ 
%into $\hh$ as follows: for each read operation $(\otR, \ke, \_) \in \opset$, we add $\txid_{\cl}^{n}$ 
%to the set of readers to the last version of $\ke$ that is included in the view $\vi$ of the client; 
%for each write operation $(\otW, \ke, \val)$, we append a new version $(\val, \txid_{\cl}^{n}, \emptyset)$ 
%to the tail of $\hh(\ke)$.
%In the definition below, we use $\lcat$ to denote the concatenation of two lists; 
%if $\vilist = \ver_0, \cdots, \ver_n$ and $i=0,\cdots,n$, 
%$\vilist\rmto{i}{\ver}$ denotes the updated list 
%$\vilist' = \ver_0, \cdots, \ver_{i-1}, \ver, \ver_{i+1}, \cdots, \ver_{n}$. 
%\begin{definition}[Transaction Commit]
%Let $\hh \in \HisHeaps, \vi \in \Views(\hh)$, $\cl \in \ClSet$, and $\opset \subseteq \powerset{\Ops}$. 
%Then the set of possible key-value stores obtained by letting client $\cl$ with view $\vi$ pushing $\opset$ into $\hh$, 
%is defined inductively on $\opset$ as follows: let $\txid$ be a transaction identifier;  
%\begin{equation*}
%\begin{rclarray}         
    %\updateKV(\hh, \vi, \txid, \emptyset) &\defeq & \hh \\
    %\updateKV(\hh, \vi, \txid, \opset \uplus \Set{(\otR, \ke, \stub)}) & \defeq &  
    %\begin{array}[t]{@{}l}
        %\texttt{let } (\val, \txid', \txidset) = \hh(\ke, \vi), \\
        %\vilist = \hh(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val, \txid', \txidset \uplus \{ t \})}\\
        %\quad \texttt{in } \updateKV(\hh\rmto{\ke}{\vilist}, \vi, \txid, \opset)
    %\end{array} \\
    %\updateKV(\hh, \vi, \txid, \opset \uplus \Set{(\otW, \ke, \val)} )& \defeq &  
    %\begin{array}[t]{@{}l}
        %\texttt{let } \hh' = \hh\rmto{\ke}{ ( \hh(\ke) \lcat (\val, \txid, \emptyset) ) } \\
        %\quad \texttt{in } \updateKV(\hh', \vi, \txid, \opset)
    %\end{array} 
%\end{rclarray}
%\label{eq:updatekv}
%\end{equation*}
%\begin{equation*}
	%\updateKV(\hh, \vi, \cl, \opset) = \{\updateKV(\hh, \vi, \txid, \opset) \mid \txid \in \nextTxId(\hh, \cl)\}.
%\end{equation*}
%\end{definition}
	%Note that all the key-value stores in $\updateKV(\hh, \vi, \cl, \opset)$ are equivalent, up-to the transaction 
	%identifier $\txid_{\cl}^{n} \in \nextTxId(\hh, \cl)$ that is associated with the read-write set $\opset$.

%The set $\HisHeaps$ is closed with respect to applications of the operator $\updateKV$. Furthermore, 
%let us say that two read-write sets $\opset_1, \opset_2$ are \emph{conflict-free} if 
%$\forall \ke \in \Keys.\; (\otW,\ke, \_) \in \opset_1 \implies \forall \val \in \Val.\; (\otW, \ke, \val) \notin \opset_2$: 
%then the set of key-value stores obtained by letting two different clients $\cl_1, \cl_2$ committing the read-write sets 
%$\opset_1, \opset_2$ into a key-value store $\hh$, respectively, does not depend on the order in which the commits 
%are performed. 

%\begin{proposition}
%\label{prop:updatekv_commutative}
%Let $\hh \in \HisHeaps$, $\vi_1, \vi_2 \in \Views(\hh)$, $\opset_1, \opset_2 \subseteq \Ops$, and $\cl_1, \cl_2 \in \Clients$. 
%Then $\updateKV(\hh, \vi_1, \cl_1, \opset_1) \in \HisHeaps$. Furthermore, if $\cl_1 \neq \cl_2$ and $\opset_1, \opset_2$ 
%are conflict-free, then 
%\begin{multline*}
%\updateKV(\updateKV(\hh, \vi_1, \cl_1, \opset_1), \vi_2, \cl_2, \opset_2)  =\\ 
%\updateKV(\updateKV(\hh, \vi_2, \cl_2, \opset_2), \vi_1, \cl_1, \opset_1).
%\end{multline*}
%\ac{in both the LHS and RHS of the formula above, the outermost application of $\updateKV$ is implicitly lifted from type 
%$\HisHeaps \rightarrow \powerset{\HisHeaps}$ to $\powerset{\HisHeaps} \rightarrow \powerset{\HisHeaps}$. This should 
%be made present to the reader without spending too much time on it. Maybe using the notation $\overline{\updateKV}$ for 
%the lifting of functions, and just say that it is the lifting of functions to power-sets could be enough?}
%\end{proposition}
