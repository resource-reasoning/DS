\subsection{Multi-version Key-value Stores and Views}
\label{sec:mkvs-view}

\subsubsection{Multi-version Key-value Stores} 
We assume a countably infinite set of \emph{client identifiers} $\Clients \defeq \Set{\cl, \cl',\cdots}$. 
We define the set of \emph{transaction identifiers} 
$\TxID \defeq  \Set{\txid_{0}} \uplus \Set{ \txid_{\cl}^{n} \mid \cl \in \Clients \wedge n \geq 0 }$, where 
 $\txid_0$ denotes a designated transaction used for initialisation, 
 and for each $n \in \mathbb{N}$, $\txid_{\cl}^{n}$ identifies a transaction 
 committed by client $\cl$.
% the $n$\textsuperscript{th} transaction of client $\cl$. 
Elements of $\TxID$ are ranged over by $\txid, \txid', \cdots$, 
while subsets of $\TxID$ are ranged over by $\txidset, \txidset', \cdots$. 
We define $\TxID_{0} \defeq \TxID \setminus \{ \txid_0\}$.
As we will see, we assume that each client is bound to a single session, and 
we use the superscript $n$, in a transaction identifier $\txid_{\cl}^{n}$, 
to embed the information about the session order $\PO$ in which clients execute 
transactions:  
%
%The structure of $\TxID$  
%embeds the transaction execution order for each client, or the \emph{session order} $\PO$. 
%More concretely, 
$\PO \defeq \Set{ (\txid, \txid') \mid \exsts{ \cl, n,m } \txid = \txid_{\cl}^{n} \wedge \txid' = \txid_{\cl}^{m} \wedge n < m}$.
%As such, $(\txid, \txid') \in \PO$ denotes that 
%client $\cl$ executes $\txid$ before $\txid'$.
For readability, we often write  $\txid \xrightarrow{\PO} \txid'$ for $(\txid, \txid') \in \PO$.

%Given a set $X$, 
%%then $\powerset{X}$ denotes 
%%the powerset of $X$,
%we write $X^{\ast}$ for the free monoid induced by $X$.
%We next define the notion of \emph{multi-version key-value stores}.


\begin{definition}[Multi-version Key-value Stores]
\label{def:his_heap}
\label{def:mkvs}
Assume a countably infinite set of \emph{keys} $\Keys = \Set{\ke, \ke', \cdots}$, 
and a set of \emph{values} $\Val = \{\val, \val', \cdots\}$.

A \emph{version} is a triple $\ver \in \Versions \defeq \Val \times \TxID \times \powerset{\TxID_{0}}$. 
%The set of versions is denoted by $$.
A \emph{key-value store} is a mapping $\hh: \Keys \rightarrow \Versions^{\ast}$, 
where we recall that $\Versions^{\ast}$ is the free monoid generated by $\Versions$.
%\ac{ The superscript fin over the $\rightharpoonup$ needs to be fixed. You may want to look at the package extpfeil.}
\end{definition}

%For simplicity, we instantiate the set of values as  $\Val \eqdef \Nat \uplus \Keys$,
Among the elements of $\Val$, we distinguish a default value $\val_0 \in \Val$. 
A \emph{version} $\ver = (\val, \txid, \txidset)$ comprises a value $\val$,
and the meta-data of the transactions that accessed it.
Specifically, the \emph{writer} $\txid$ identifies the transaction that wrote version $\ver$, 
and the \emph{readers} $\txidset$ denote the set of transactions that read from $\ver$.
Given a version $\ver = (\val, \txid, \txidset)$, we define $\valueOf(\ver) \defeq \val$,
$\WTx(\ver) \defeq \txid$ and $\RTx(\ver) \defeq \txidset$. 
Lists of versions (\ie elements of $\Versions^{\ast}$) are ranged over by $\vilist, \vilist',\cdots$.
Given a key-value store $\hh$ and a transaction identifier $\txid$, we write 
$\txid \in \hh$ if $\txid$ appears as either the writer or reader of 
some version included in $\hh$:  $\txid \in \hh \defeq 
\exists \ke, i. 0 \leq i < \lvert \hh(\ke) \rvert \wedge (\txid \in \RTx(\hh(\ke, i)) \cup \{\WTx(\hh(\ke, i))\})$.

%A \emph{multi-version key-value store}, or \emph{kv-store}, 
%is a mapping from keys to lists of versions. 
Given kv-store $\hh$, key $\ke$ and index $i \geq 0$, 
we write $\hh(\ke, i)$ for the $i$-th version (starting from $0$) of $\ke$.
That is, if $\hh(\ke) = \ver_0 \cdots\ver_{n}$, then $\hh(\ke, i) \defeq \ver_{i}$ for $i \leq n$; 
and it is undefined otherwise. 
We write $\lvert \hh(\ke) \rvert$ for the length of $\hh(\ke)$. 

We focus on key-value stores whose consistency model enforces the \emph{atomic visibility} of transactions~\cite{framework-concur}. 
This amounts to requiring that transaction reads at most one version of each key, and similarly 
it writes at most one version for each key. From the point of view of key-value stores, 
these conditions amount to require that \textbf{(i)}
$\fora{\ke i, j} (o \leq i, j \abs{ \hh(\ke) } \land \RTx(\hh(\ke, i)) \cap \RTx(\hh(\ke, j)) \neq \emptyset ) \implies i = j$, 
\textbf{(ii)}
$\fora{\ke, i, j} (0 \leq i,j < \abs{ \hh(\ke) } \wedge \WTx(\hh(\ke, i)) = \WTx(\hh(\ke, j)) ) \implies i = j$. 
We also assume that the list of version for each key has an initial version carrying a default value $\val_0$, 
written by the designated initialisation transaction $\txid_0$: \textbf{(iii)} $\fora{\ke} \hh(\ke, 0) = (\val_0, \txid_0, \stub)$.
Finally, we assume that the state of a key-value store is consistent with 
the session order of clients; a client cannot read a version of a key that has 
been installed by a future transactions within the same session, and 
the order in which versions are installed by a single client must agree 
with its session order: \textbf{(iv)}
$\fora{ \ke, \cl, i,j, n, m} 0 \leq i < j < \abs{\hh(\ke)} 
    \land \txid_{\cl}^{n} = \WTx(\hh(\ke,i)) {} \wedge \txid_{\cl}^{m} \in \Set{\WTx(\hh(\ke,j))} \cup \RTx(\hh(\ke, i))
    \implies n < m $.
%
%Formally, we require the following well-formedness requirement from key-value stores: 
%
%\begin{enumerate}%[label=(\roman*)]
%\item\label{kv:wf.init} 
%    $\hh(\ke, 0) = (\val_0, \txid_0, \stub)$ for $\ke \in \dom(\hh)$, where $\val_0$ is the default value in $\Val$;
%\item\label{kv:wf.onewrite} 
%    transactions write at most one version for each key:
%\[
%\fora{\ke, i,j }
%0 \leq i, j < \abs{ \hh(\ke) }
%\land \WTx(\hh(\ke, i)) = \WTx(\hh(\ke, j))
%\implies i = j 
%\]
%\item\label{kv:wf.oneread} 
%    transactions read at most one version for each key:
%\[
%\fora{\ke, i,j } 
%0 \leq i, j < \abs{ \hh(\ke) }
%\land \RTx(\hh(\ke, i)) \cap \RTx(\hh(\ke, j)) \neq \emptyset 
%\implies i = j
%\]
%\item\label{kv:wf.so} 
%	transactions (of the same client) install different versions of a key in the session order; 
%%    the order in which transactions issued by the same client install different versions for a key $\ke$, 
%%    is consistent with the session order;
%    a client $\cl$ can read versions written by $\cl$ itself only after they have been installed:
%\begin{multline*}
%    \fora{ \ke, \cl, i,j, n, m} 
%    0 \leq i < j < \abs{\hh(\ke)} 
%    \land \txid_{\cl}^{n} = \WTx(\hh(\ke,i)) \\
%    {} \wedge \txid_{\cl}^{m} \in \Set{\WTx(\hh(\ke,j))} \cup \RTx(\hh(\ke, i))
%    \implies n < m
%\end{multline*}
%\end{enumerate}
%
We say that kv-stores that satisfy the conditions \textbf{(i)}-\textbf{(iv)} above are 
\emph{well-formed}.
Henceforth, we will always assume kv-stores tp be well-formed, and we use $\HisHeaps$ to denote 
the set of well-formed kv-stores.

\subsubsection{Views and Configurations}

Key-value stores track the global state of a database. 
However, clients do not need to agree on the portion of 
the state of the database that they observe. Different clients 
may observe different different subsets of versions of the same key.
when executing transactions,
%different \emph{clients} may observe different versions of the same key. 
To keep track of the versions observed by clients,
we introduce the notion of \emph{views} (\cref{def:view}). 

\begin{definition}[Views, configurations]
\label{def:view}
\label{def:cuts}
\label{def:views}
\label{def:configuration}
A \emph{view} of a kv-store $\hh$ is a mapping  
$\vi \in \Views(\hh) \defeq \Keys \to\powerset{\Nat}$ such that:
\begin{align}
    & \fora{ \ke } 
    0 \in \vi(\ke) 
    \wedge \fora{ i \in \vi(\ke) } 
    i < \abs{ \hh(\ke) } 
    \tag{WF}
    \label{eq:view.wf}\\
    %\Set{0} \subseteq \vi(\ke) \subseteq \Setcon{i}{ 0 \leq i < \abs{\mkvs(\ke)}}
    & 
    \fora{ \ke_1,\ke_2, i_1, i_2} 
	i_1 \in \vi(\ke_1) 
	\land \WTx(\hh(\ke_1, i_1)) = \WTx(\hh(\ke_2, i_2)) 
	\implies i_2 \in \vi(\ke_2)
	\tag{Atomic}
	\label{eq:view.atomic}
\end{align}
A \emph{configuration} $\conf \in \Confs$, is a pair $(\hh, \viewFun)$, 
where $\hh \in \HisHeaps$ and
$\viewFun : \Clients \parfinfun \Views(\hh)$. 
\end{definition}
Configurations extend key-value stores with the information of 
the views of each client. In a configuration $\conf = (\hh, \viewFun)$, the view of client 
$\cl$, $\vi = \viewFun(\cl)$ (if defined) determines for each key $\ke \in \Keys$ the sub-list of versions in $\hh$ 
that the client is aware of, or equivalently that it can observe. If $i,j \in \vi(\ke)$ and $i < j$, then the client is 
aware of the fact that $\hh$ contains the versions $\hh(\ke, i)$, $\hh(\ke, j)$, and that $\hh(\ke, j)$ is more 
up-to-date than $\hh(\ke, i)$. The client also observes the information relative to the versions $\hh(\ke, i)$ and 
$\hh(\ke, j)$, i.e. the value they carry and the meta-data relative to writing and reading transactions of such 
versions. 
Equation \eqref{eq:view.wf} in \cref{def:view} is a natural requirement, while \eqref{eq:view.atomic} 
models the atomic visibility of transactions: if a client observes the updates of a transaction $\txid$, then 
it must observe all the updates from $\txid$. 
We let $\Views = \bigcup_{\hh \in \HisHeaps} \Views(\hh)$ be the set of all view. 
Given a kv-store $\hh$ and two views $\vi, \vi' \in \Views(\hh)$, 
we write $\vi \viewleq \vi'$ when $\vi(k) \subseteq \vi'(\ke)$ for all $\ke \in \dom(\hh)$. 
The initial view $\vi_{0}$ is defined as $\vi_{0}(\ke) = \{0\}$ for each $\ke \in \Keys$.
A configuration $\conf_{0} = (\hh_{0}, \viewFun_{0})$ is
\emph{initial} if $\hh_{0}(\ke) = (\val_0, \txid_0, \emptyset)$ for all $\ke \in \Keys$.

Given a configuration $\conf = (\hh, \viewFun)$ and a client $\cl$ for which 
$\viewFun(\cl)$ is defined, the view $\vi(\cl)$ is used to determine a \emph{snapshot}, i.e. 
a mapping from each key to a unique value that the client observes when executing a transaction. 
In general, the snapshot of a transaction is also determined by a \emph{resolution policy} 
cite{}. Throughout this paper, we assume that the database employ the \emph{Last Writer 
Wins} \cite{} resolution policy to determine the snapshot of clients, although generalisation 
to different resolution policies is straightforward.

\begin{definition}[Snapshots]
\label{def:heaps}
\label{def:snapshot}
A snapshot is a mapping from keys to values \( \ss \in \Snapshots  \defeq \Keys \to \Val\).
Given $\hh \in \HisHeaps$ and $\vi \in \Views(\hh)$, the \emph{snapshot} of $\vi$ in 
$\hh$ is defined as $\snapshot(\hh, \vi) \defeq \lambda \ke \ldotp \valueOf(\hh(\ke, \max_{<}(\vi(\ke)))$, 
where we recall that $\max_{<}(\vi(\ke))$ is the maximum element in $\vi(\ke)$ with respect to the natural 
order $<$ over $\mathbb{N}$.
\end{definition}
Given a kv-store $\hh$, a key $\ke$ and a view $\vi$, we often commit an abuse of notation and write 
$\hh(\ke, vi)$ as a shorthand for 
$\hh(\ke, \max_{<}(\vi(\ke))$. Thus, $\snapshot(\hh, \vi) = \lambda \ke \ldotp \valueOf(\hh(\ke, \vi))$. 

\begin{remark}
Because the function $\snapshot(\hh, \vi)$ only selects the last version of $\hh$ comprised 
in $\vi$, one may wonder about the necessity of including multiple versions in the view of a 
key $\ke$.  Here we only point that requiring a view to contain a single version for each key 
would impair the expressiveness of our framework in terms of consistency models that it captures; 
unfortunately, we have to wait until \cref{} before giving more details on this issue.
\end{remark}

%Let $\vi$ be on a key-value store $\hh$; the view $\vi$ determines, 
%for each key $\ke \in \Keys$, the sub-list of versions in $\hh(\ke)$ 
%$\vi(\ke)$ determines the subset of versions that 
%  
%\emph{The set of views} 
%$
%\Views \defeq \bigcup_{\hh \in \HisHeaps} \Views(\hh)
%$.
%A \emph{configuration}, $\conf \in \Confs$, is a pair $(\hh, \viewFun)$, 
%where $\hh \in \HisHeaps$ and
%$\viewFun : \Clients \parfinfun \Views(\hh)$. 
%The $\conf_{0} = (\hh_{0}, \viewFun_{0})$ is an
%\emph{initial configuration} if, $\hh_{0}(\ke) = (\val_0, \txid_0, \emptyset)$ for all $\ke \in \Keys$.
%
%A view of a kv-store $\hh$ is a mapping from the keys in $\hh$ to a non-empty set of natural numbers. 
%For each $\ke \in \dom(\hh)$, $\vi(\ke)$ denotes the indices of versions in $\hh(\ke)$ recorded in $\vi$. 
%As such, when $i \in \vi(\ke)$ then $ i < \abs{ \hh(\ke) }$. 
%Moreover, the initialisation version (at index $0$) must be included in all views. 
%These two properties are captured by \eqref{eq:view.wf} in \cref{def:view} below. 
%Lastly, views cannot observe \emph{partial} effects of a given transaction. 
%That is, if a view includes a version written by a transaction $\txid$, it must include \emph{all} versions written by $\txid$. 
%This is formalised by \eqref{eq:view.atomic} in \cref{def:view} below, and captures the \emph{atomic visibility} of transactions. 


%At any point during execution, the overall state is captured by \emph{a configuration}. 
%A configuration includes a kv-store and a partial mapping from clients to views.
%The view of the client $\cl$ in $\hh$ reflects the set of versions for each key 
%that the client \(\cl \) observes upon executing a transaction. 
%The constraint of \cref{eq:view.atomic} establishes that if a client observes 
%a version of some key written by a transaction $\txid$, then it must observe all the versions of 
%all keys that $\txid$ wrote. 


%\begin{definition}[Views, configurations]
%\label{def:view}
%\label{def:cuts}
%\label{def:views}
%\label{def:configuration}
%A \emph{view} of a kv-store $\hh$ is a mapping  
%$\vi \in \Views(\mkvs) \defeq \dom(\hh) \to\powerset{\Nat}$ such that:
%\begin{align}
%    & \fora{ \ke } 
%    0 \in \vi(\ke) 
%    \wedge \fora{ i \in \vi(\ke) } 
%    i < \abs{ \hh(\ke) } 
%    \tag{WF}
%    \label{eq:view.wf}\\
%    %\Set{0} \subseteq \vi(\ke) \subseteq \Setcon{i}{ 0 \leq i < \abs{\mkvs(\ke)}}
%    & 
%    \fora{ \ke,\ke', i,j} 
%	j \in \vi(\ke) 
%	\land \WTx(\hh(\ke, j)) = \WTx(\hh(\ke', i) 
%	\implies i \in \vi(\ke')
%	\tag{Atomic}
%	\label{eq:view.atomic}
%\end{align}
%
%\emph{The set of views} is
%$
%\Views \defeq \bigcup_{\hh \in \HisHeaps} \Views(\hh)
%$.
%A \emph{configuration}, $\conf \in \Confs$, is a pair $(\hh, \viewFun)$, 
%where $\hh \in \HisHeaps$ and
%$\viewFun : \Clients \parfinfun \Views(\hh)$. 
%The $\conf_{0} = (\hh_{0}, \viewFun_{0})$ is an
%\emph{initial configuration} if, $\hh_{0}(\ke) = (\val_0, \txid_0, \emptyset)$ for all $\ke \in \Keys$.
%\end{definition}



%Given a kv-store $\hh$ and two views $\vi, \vi' \in \Views(\hh)$, 
%we write $\vi \viewleq \vi'$ when $\vi(k) \subseteq \vi'(\ke)$ for all $\ke \in \dom(\hh)$. 
%Also, we commit an abuse of notation and write $\hh(\ke, \vi)$ as a shorthand 
%for $\hh(\ke, \max_{<}(\vi(\ke)))$. 
%Note that such a version always exists as
%$\vi(\ke) \neq \emptyset$ (see \eqref{eq:view.wf} above).

%\subsubsection{Snapshots}
%Transactions are executed with respect to a \emph{snapshot} of a kv-store.
%A snapshot $\h$ is a mapping from keys to values (\cref{def:snapshot}). 
%Given a view $\vi$ of a transaction, a snapshot can be induced 
%by extracting the value of the latest observable version for each key $\ke \in \dom(\hh)$. 
%%Views are used to determine the snapshot in which a transaction 
%%is executed, according to the following definition.


%\begin{definition}[Snapshots]
%\label{def:heaps}
%\label{def:snapshot}
%A snapshot is a mapping from keys to values \( \ss \in \Snapshots  \defeq \Keys \to \Val\).
%Given $\hh \in \HisHeaps$ and $\vi \in \Views(\hh)$, the \emph{snapshot} of $\vi$ in 
%$\hh$ is defined as $\snapshot(\hh, \vi) \defeq \lambda \ke \ldotp \valueOf(\hh(\ke, \max_{<}(\vi(\ke)))$.
%\end{definition}

\paragraph{Committing a Transaction.}
Until now we have only discussed the structure of key-value stores. 
Next, we describe how the state of a key-value store changes, when 
one client executes a transaction. 
In our framework, transactions are executed atomically. 
Roughly speaking, given a configuration $\conf = (\hh, \viewFun)$, 
when a client $\cl$ executes some transactional code $\ptrans{\trans}$, 
then it performs the following steps: 
\textbf{(i)} it constructs a snapshot of $\hh$ from the view $\viewFun(\cl)$ that 
the client has over $\hh$; \textbf{(ii)} it executes the code $\trans$ in isolation, using the 
snapshot constructed in the previous step as the initial, local state of the client, and it determines the visible 
effects that such an execution has on the key-value store; \textbf{(iii)} it incorporates 
the effects of executing the code $\trans$ in the initial state determined by the snapshot into 
the key-value store.

We have already discussed how to construct a snapshot of the key-value store. 
We represent the \emph{visible effects} of the execution of a transaction as \emph{Read-Write Sets}. 
Roughly speaking, a read-write set is a labelling of the operations that the client performs on  
the key-value store when executing a transaction: each of these labelling includes the kind of 
operation performed (either a $\mathsf{R}$ead or a $\mathsf{W}$rite), 
the key on which the operation has been performed, and either the value hat has been fetched from 
(in the case of a read operation), or the value that has been inserted into the key-value store.
% (this being either the value being 
%fetched from the key-value store, in the case of a read operation, or the value being inserted in the 
%key-value store, in 
%the case of a write operation). 
We defer the discussion of how to determine the read-write set $\ptrans{\trans}$, 
when executing from some initial client-local state, formalised as a mapping from keys to values, to 
\cref{}. 

\begin{definition}[Read-Write Sets]
Let 
%The set of \emph{operations} is
$\Ops \defeq \{(l, \ke, \val) \mid$ $ l \in \Set{\otW, \otR} \land \ke \in \Keys \wedge \val \in \Val \}$ 
be a set of operations. 
A \emph{Read-Write Set} $\opset$ is a subset of operations, $\opset \subseteq \Ops$,
such that for all $\ke \in \Keys$ and \( L \in \Set{\otW, \otR} \),
if $(L, \ke, \val_1), (L, \ke, \val_2) \in \opset$, then $\val_1 = \val_2$.
\end{definition}
Note that we have placed a constraint that read-write sets contains at most one value read, 
and at most one value written, per key. This reflects the fact that we only consider transactions 
that are atomically visible \cite{laws}.

Finally, we need to address how the effects of a transaction executed by client $\cl$, formalised 
as a read-write set $\opset$, are pushed into a key-value store $\hh$. To this end, we also 
need to know the view $\vi$ that the client has on $\hh$.
First, we must associate the read-write set $\opset$ with a transaction identifier $\txid$.  
Because we are assuming that the read-write set is being merged into the key-value store from client $\cl$, 
it is natural to choose $\txid$ from the set $\{\txid_{\cl}^{n} \mid n \in \mathbb{N}\}$. 
Furthermore, we must choose a transaction identifier of the form 
$\txid_{\cl}^{n}$, where $n$ is greater than any index $m$ such that 
$\txid_{\cl}^{m} \in \hh$: because such transaction identifiers are already present 
in the key-value store, they correspond to transactions that have been previously executed 
by $\cl$, and thus they must precede the transaction identifier $\txid_{\cl}^{n}$ in the session 
order. Formally, we define the set $\nextTxId(\cl, \hh) = \{ \txid_{\cl}^{n} \mid \forall m \in \mathbb{N}. \; 
\txid_{\cl}^{m} \in \hh \implies m < n\}$, and we require that $\txid_{\cl}^{n} \in \nextTxId(\cl,\hh)$. 
Having selected a suitable transaction identifier $\txid_{\cl}^{n}$, we push the read-write set $\opset$ 
into $\hh$ as follows: for each read operation $(\otR, \ke, \_) \in \opset$, we add $\txid_{\cl}^{n}$ 
to the set of readers to the last version of $\ke$ that is included in the view $\vi$ of the client; 
for each write operation $(\otW, \ke, \val)$, we append a new version $(\val, \txid_{\cl}^{n}, \emptyset)$ 
to the tail of $\hh(\ke)$.
In the definition below, we use $\lcat$ to denote the concatenation of two lists; 
if $\vilist = \ver_0, \cdots, \ver_n$ and $i=0,\cdots,n$, 
$\vilist\rmto{i}{\ver}$ denotes the updated list 
$\vilist' = \ver_0, \cdots, \ver_{i-1}, \ver, \ver_{i+1}, \cdots, \ver_{n}$. 
\begin{definition}[Transaction Commit]
Let $\hh \in \HisHeaps, \vi \in \Views(\hh)$, $\cl \in \ClSet$, and $\opset \subseteq \powerset{\Ops}$. 
Then the set of possible key-value stores obtained by letting client $\cl$ with view $\vi$ pushing $\opset$ into $\hh$, 
is defined inductively on $\opset$ as follows: let $\txid$ be a transaction identifier;  
\begin{equation*}
\begin{rclarray}         
    \updateKV(\hh, \vi, \txid, \emptyset) &\defeq & \hh \\
    \updateKV(\hh, \vi, \txid, \opset \uplus \Set{(\otR, \ke, \stub)}) & \defeq &  
    \begin{array}[t]{@{}l}
        \texttt{let } (\val, \txid', \txidset) = \hh(\ke, \vi), \\
        \vilist = \hh(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val, \txid', \txidset \uplus \{ t \})}\\
        \quad \texttt{in } \updateKV(\hh\rmto{\ke}{\vilist}, \vi, \txid, \opset)
    \end{array} \\
    \updateKV(\hh, \vi, \txid, \opset \uplus \Set{(\otW, \ke, \val)} )& \defeq &  
    \begin{array}[t]{@{}l}
        \texttt{let } \hh' = \hh\rmto{\ke}{ ( \hh(\ke) \lcat (\val, \txid, \emptyset) ) } \\
        \quad \texttt{in } \updateKV(\hh', \vi, \txid, \opset)
    \end{array} 
\end{rclarray}
\label{eq:updatekv}
\end{equation*}
\begin{equation*}
	\updateKV(\hh, \vi, \cl, \opset) = \{\updateKV(\hh, \vi, \txid, \opset) \mid \txid \in \nextTxId(\hh, \cl)\}.
\end{equation*}
\end{definition}
	Note that all the key-value stores in $\updateKV(\hh, \vi, \cl, \opset)$ are equivalent, up-to the transaction 
	identifier $\txid_{\cl}^{n} \in \nextTxId(\hh, \cl)$ that is associated with the read-write set $\opset$.

The set $\HisHeaps$ is closed with respect to applications of the operator $\updateKV$. Furthermore, 
let us say that two read-write sets $\opset_1, \opset_2$ are \emph{conflict-free} if 
$\forall \ke \in \Keys.\; (\otW,\ke, \_) \in \opset_1 \implies \forall \val \in \Val.\; (\otW, \ke, \val) \notin \opset_2$: 
then the set of key-value stores obtained by letting two different clients $\cl_1, \cl_2$ committing the read-write sets 
$\opset_1, \opset_2$ into a key-value store $\hh$, respectively, does not depend on the order in which the commits 
are performed. 

\begin{proposition}
\label{prop:updatekv_commutative}
Let $\hh \in \HisHeaps$, $\vi_1, \vi_2 \in \Views(\hh)$, $\opset_1, \opset_2 \subseteq \Ops$, and $\cl_1, \cl_2 \in \Clients$. 
Then $\updateKV(\hh, \vi_1, \cl_1, \opset_1) \in \HisHeaps$. Furthermore, if $\cl_1 \neq \cl_2$ and $\opset_1, \opset_2$ 
are conflict-free, then 
\begin{multline*}
\updateKV(\updateKV(\hh, \vi_1, \cl_1, \opset_1), \vi_2, \cl_2, \opset_2)  =\\ 
\updateKV(\updateKV(\hh, \vi_2, \cl_2, \opset_2), \vi_1, \cl_1, \opset_1).
\end{multline*}
\ac{in both the LHS and RHS of the formula above, the outermost application of $\updateKV$ is implicitly lifted from type 
$\HisHeaps \rightarrow \powerset{\HisHeaps}$ to $\powerset{\HisHeaps} \rightarrow \powerset{\HisHeaps}$. This should 
be made present to the reader without spending too much time on it. Maybe using the notation $\overline{\updateKV}$ for 
the lifting of functions, and just say that it is the lifting of functions to power-sets could be enough?}
\end{proposition}
%
%Once the execution of a transaction is completed, its effects are committed to the kv-store. 
%The effects of transactions are modelled as a \emph{fingerprint} $\opset$. 
%A finger print comprises a set of \emph{operations} $\Ops$: $\opset \subseteq \Ops$. 
%An operation is a triple of the form $(l, \ke, \val)$ with $l \in \{\otR, \otW\}$.    
%Intuitively, given the fingerprint $\opset$ of a transaction $\txid$, 
%$(\otR, \ke, \val) \in \opset$ denotes that 
%$\txid$ requested to read key $\ke$ from the kv-store, 
%and it fetched a version carrying value $\val$.
%Similarly, $(\otW, \ke, \val) \in \opset$ denotes that 
%$\txid$ attempted to write value $v$ for key $\ke$. 
%A fingerprint includes at most one read operation per key;
%this formalises the intuition that, in our setting, 
%transactions always read from an atomic snapshot of the kv-store. 
%Analogously, a fingerprint includes at most one write operation per key.
%because a client either observes none or all the updates of a transaction.

%\begin{definition}[Fingerprints]
%The set of \emph{operations} is
%$\Ops \defeq \{(l, \ke, \val) \mid$ $ l \in \Set{\otW, \otR} \land \ke \in \Keys \wedge \val \in \Val \}$.
%A \emph{fingerprint} $\opset$ is a subset of operations, $\opset \subseteq \Ops$,
%such that for all $\ke \in \Keys$ and \( l \in \Set{\otW, \otR} \),
%if $(l, \ke, \val_1), (l, \ke, \val_2) \in \opset$, then $\val_1 = \val_2$.
%\end{definition}



%\ac{Note that I now require fingerprints to be non-empty sets of transactions. This simplifies a lot the development of 
%the theory of kv-stores, and it fixes a problem that was spotted by Shale, that breaks the compositionality of 
%execution tests (see later). The main reason why we allowed empty fingerprints is that in the semantics, a client can 
%execute a transaction with no access to the memory. In practice, in the semantics we can require that at least 
%one access to the database must be performed in transactions. This can be checked syntactically, and nobody 
%should complain about that. I can put a remark about how this is a natural requirement that, if violated, 
%breaks the compositionality of consistency models.\\ 
%\textbf{Update 02/08/2018}: empty fingerprints are now allowed again. We still had some problems with compositionality, 
%one of which has to do with the fact that we allow the view of a client over some key to move freely after executing a transaction, 
%even if such a key was not accessed by the transaction. Later, I forbid this behaviour by requiring in execution tests that the 
%view of an client for a given key cannot be shifted if the transaction executed by the client did not access such a key.}
%$(\otW, \ke, \val) \in \opset$ means that the transaction writes a new version, carrying value $\val$, for key $\ke$. 




%of $\vi$ by accessing the value of 
%A view $\vi$ in $\hh$ naturally defines a snapshot $\snapshot(\hh, \nu)$
%A MKVS tracks the global state of the system; however, different \emph{clients} may observe different versions of the same key. 
%To model this, we introduce the notion of \emph{views} (\cref{def:views}). 
%A view $V$ reflects the particular version for each key that a client observes upon executing a transaction. 
%%We present an example of views in \cref{fig:hheap-a} with two views: $\client_1$ in red and $\client_2$ in blue.
%More concretely, the view for \( \client_1 \) is given formally as $\vi_1 = \Set{\key{k}_1 \mapsto 1, \key{k}_2 \mapsto 0}$.
%That is, the client with view $\vi_1$ observes the second version (at index 1) of key \( \ke_{1} \) with value $v_1$, and the first version (at index 0) of key \( \ke_2 \) with value $v'_0$.
%%, and 
%%the first version of $\key{k}_2$, carrying value $0$. Similarly, according to its view 
%%$V_2 = [\key{k}_1 \mapsto 2, \key{k}_2 \mapsto 2]$, the client $\txid_2$ observes 
%%in $\hh$the second and most up-to-date version for both $\key{k}_1$ and $\key{k}_2$.
%
%\begin{definition}[Views]
%\label{def:view}
%\label{def:cuts}
%\label{def:views}
%\emph{A view} is a partial finite function from keys to indexes:
%$
%\vi \in \Views \defeq \Addr \parfinfun \Nat 
%%\begin{rclarray}
%%    \vi \in \Views & \defeq & \Addr \parfinfun \Nat 
%%\end{rclarray}
%$.                                                                 
%The \emph{view composition}, $\composeVI: \Views \times \Views \rightharpoonup \Views$ is defined as the standard disjoint function union: $\composeVI \eqdef \uplus$. 
%% \( \vi \composeVI \vi' \defeq \vi \uplus \vi'\) 
%The \emph{unit view}, $\unitVI \in \Views$, is a function with an empty domain: $\unitVI \eqdef \emptyset$. 
%% and the unit is \( \unitVI \defeq \emptyset\).
%The \emph{order relation} on views, $\orderVI: \Views \times \Views$, is defined between two views with the same domain as the point-wise comparison of their indexes for each entry: 
%\[
%\begin{rclarray}
%    \vi \orderVI \vi' & \defiff & \dom(\vi) = \dom(\vi') \land \fora{\ke} \cu(\ke) \leq \cu'(\ke) \\
%\end{rclarray}
%\]
%\end{definition}
%%
%We say view $\vi$ is \emph{older} than view $\vi'$ (or $\vi'$ is \emph{newer} than $\vi$) whenever $\vi \orderVI \vi'$ holds.
%
%
%\mypar{Configurations} A \emph{configuration} comprises an MKVS, and the views associated with clients.
%In \cref{fig:hheap-a} we present an example of a configuration comprising an MKVS and the two views associated with clients $\client_1$ and $\client_2$. 
%We write $\version(\hh, \ke, \vi)$ for $\hh(\ke, \vi(\ke))$; 
%and write $\valueOf(\hh, \ke, \vi)$ as a shorthand for $ \valueOf(\version(\hh, \key{k}, V))$; similarly for $\WTx, \RTx$.
%%we commit an abuse of notation and often write $\valueOf(\hh, \ke, \vi)$ in lieu of $ \valueOf(\version(\hh, \key{k}, V))$, and similarly for $\WTx, \RTx$.
%When $\ver = \version(\hh, \ke, \vi)$, we say that \emph{$\vi$ $\ke$-points to $\ver$ in $\hh$}. 
%When $\ver = \hh(\ke, i)$ for some $0 \leq i \le \vi(\ke)$, we say that \emph{$\vi$ $\ke$-includes $\ver$ in $\hh$}.
%Lastly, we always assume that MKVSs, views, and configurations are well-formed, unless otherwise stated.
%
%
%
%\begin{definition}[Configurations]
%A view $\vi$ is \emph{well-formed with respect to an MKVS} $\mkvs$, written \( \wfV{\mkvs, \vi} \),  iff they have the same domain and every index from $\vi$ is within the range of the corresponding entry in $\mkvs$ and the view is \emph{atomic} with  respect to the key-value store: 
%\[
%\begin{rclarray}
%    \wfV{\mkvs, \vi} & \defeq & \dom(\mkvs) = \dom(\vi) \land \fora{\ke \in \dom(\vi)} 0 \leq \vi(\ke) < \lvert \mkvs(\ke) \rvert \\
%    \pred{atomic}{\vi ,\hh} & \eqdef & \fora{\txid } \exsts{\ke, i} i \leq \vi(\ke) \land \hh(\ke,i) = (\stub, \txid, \stub) \implies \pred{visible}{\txid, \vi, \hh} \\ 
%    \pred{visible}{\txid, \vi, \hh} & \eqdef & \fora{\ke, i} \hh(\ke,i) = (\stub, \txid, \stub) \implies i \leq \vi(\ke) 
%\end{rclarray}
%\]
%%
%\azalea{We need a symbol for this to fill the ???? above. Also ???? below. \sx{Done}}
%A \emph{configuration} $\conf$ is a pair of the form $(\hh, \viewFun)$, where $\hh$ denotes an MKVS, and $\viewFun: \Clients \parfinfun \Views$ is a partial finite function from clients to views. 
%A configuration $\conf = (\hh, \viewFun)$ is \emph{well-formed}, written \( \wfC{\conf}\), iff for all clients $\cl \in \dom(\viewFun)$, the view $\viewFun(\txid)$ is well-formed with respect to $\hh$. 
%%We say that a view $V$ is well-defined with respect to the 
%%MKVS $\hh$ if, $\forall \key{k} \in \ke. 0 < V(\key{k}) \leq 
%%\lvert \hh(\key{k}) \rvert$. 
%%Given a view $V$ that is well-defined 
%%with respect to a 
%
%\end{definition}
%
%\mypar{Snapshots} When a client executes a transaction on the $\mkvs$ MKVS, it extracts a \emph{snapshot} of it via the \( \func{snapshot}{\mkvs, \vi} \) function, extracting the values corresponding to the versions indexed by its view \( \vi \) (\cref{def:snapshot}).
%For instance, for client \( \client_1 \) in \cref{fig:hheap-a}, the $\func{snapshot}{\cdots}$ functions yields a state where key $\ke_1$ carries value $v_1$ and second key \( \ke_2 \) carries value $v'_0$.
%%The concrete state extracted in this way takes the name of the \emph{snapshot} of the transaction.
%%In general, the process of determining the view of a client, hence the snapshot in which such a client executes transactions, is non-deterministic.
%
%\azalea{Before in MKVSs we had values drawn from $\Nat$ in \cref{def:mkvs}. Now we use $\Val$. I think you mean to use $\Val$ in both places? \sx{I would say so} }
%\begin{definition}[Snapshots]
%\label{def:heaps}
%\label{def:snapshot}
%Given the sets of values $\Val$  and keys \( \Addr\)  (\cref{def:mkvs}), the set of \emph{snapshots} is:
%$
%    \h \in \Heaps \eqdef \Addr \parfinfun \Val
%$. 
%%\[
%%\begin{rclarray}
%%    \h \in \Heaps & \eqdef & \Addr \parfinfun \Val
%%\end{rclarray}
%%\]
%The \emph{snapshot composition function}, $\composeH: \Heaps \times \Heaps \parfun \Heaps$, is defined as $\composeH \eqdef \uplus$, where $\uplus$ denotes the standard disjoint function union. The \emph{ snapshot unit element} is $\unitH \eqdef \emptyset$, denoting a function with an empty domain.
%The \emph{partial commutative monoid of snapshots} is $(\Heaps, \composeH, \{\unitH\})$.
%Given an MKVS $\hh$ and a view $\vi$, the snapshot of $\vi$ in $\hh$, written $\snapshot(\hh, \vi) $, is defined as:
%$
%    \snapshot(\hh, \vi) \defeq \lambda \ke \ldotp \valueOf(\hh, \ke, \vi)
%$.
%%\[
%%\begin{rclarray}
%%    \snapshot(\hh, \vi) & \defeq & \lambda \ke \ldotp \valueOf(\hh, \ke, \vi).
%%\end{rclarray}
%%\]
%\end{definition}
%
%\sx{Need some explanation}
%\ac{General Comment on this Section: it is too abstract. We 
%should give either here or in the introduction an example of computation - 
%the write skew program should be okay that helps the reader understanding 
%what's going on. Also, it could be also good to illustrate the notions 
%of execution tests and consistency models.}
%
%\sx{From Andrea: introduce the execution test here with a table, also introduce fingerprint here}

