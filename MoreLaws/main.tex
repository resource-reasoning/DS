\documentclass[a4paper,UKenglish]{article}%This is a template for producing LIPIcs articles. 
%See lipics-manual.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
% for section-numbered lemmas etc., use "numberwithinsect"

%DOI commented out in the class file for space purposes: 
%to put back, uncomment lines 419-422 in the style file.
 
\usepackage{microtype}%if unwanted, comment out or use option "draft"
%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

%\bibliographystyle{plainurl}% the recommended bibstyle

%\usepackage[a4paper]{geometry}
%\usepackage[letterpaper,left=2.4cm,right=2.4cm,top=2.4cm,bottom=2.4cm]{geometry}

\usepackage{amsthm}
%\usepackage{paralist}
\usepackage[numbers,sort]{natbib}
\usepackage{hyperref}

\usepackage{stmaryrd}

\usepackage{tabulary}
\looseness=-18
\clubpenalty=15
\widowpenalty=0
\displaywidowpenalty=50

\renewcommand\floatpagefraction{.9}
\renewcommand\topfraction{.9}
\renewcommand\bottomfraction{.9}
\renewcommand\textfraction{.1}

%\include{largepage}
%\renewcommand{\baselinestretch}{1.2}
%\renewcommand{\rmdefault}{ptm}

%\usepackage[numbers,sort]{natbib}
\usepackage{etex}

\usepackage{authblk}
%\usepackage[normalem]{ulem} % either use this (simple) or
%\usepackage{enumitem}

\newif\iflong
\longfalse  % uncomment for short version
%\longtrue  % uncomment for long version

\newif\ifdraft
%\draftfalse %uncomment for deleting notes
\drafttrue %uncomment for showing notes

\usepackage{myfloat}
\floatstyle{ruled}
\restylefloat{figure}

\newcommand{\tr}[2]{\iflong{}\S#1\else{}\cite[\S{}#2]{ext}\fi}
\newcommand{\tra}[2]{\iflong{}(\S#1)\else{}\cite[\S{}#2]{ext}\fi}

\newcommand{\nanomalies}{A}
\newcommand{\ngeneral}{B}
\newcommand{\nproofs}{C}
\newcommand{\ncompleteness}{D}

\renewcommand{\ttdefault}{cmtt}
\renewcommand{\sfdefault}{cmss}

\usepackage{pifont}
\newcommand{\cross}{\ding{56}}


%\renewcommand{\rmdefault}{ptm}

\renewcommand{\O}{\mathcal{O}}

\newcommand{\theproof}{{\noindent\hskip\labelsep
        \color{darkgray}\sffamily\bfseries \proofname.}}
        
\newcommand{\myparagraph}[1]{\textbf{\color{darkgray}\sffamily#1.}}
% comments

\newcommand{\ac}[1]{\ifdraft{}{\color{blue}#1}\else{}\fi}

%\newcommand{\gb}[1]{\ifdraft{} {\color{DarkGreen} {GB: \bf #1}} \else{} \fi}

%\newcommand{\ag}[1]{\ifdraft{} {\color{red}{AG: \bf #1}} \else{}\fi}

%\newcommand{\agdone}[1]{\ifdraft{} {\color{DarkGreen} {\bf AG : #1} {\color{DarkGreen}$\checkmark$}} \else {} \fi}
%\newcommand{\agdone}[1]{}

%\newcommand{\hy}[1]{\ifdraft{} {\bf HY: #1} \else{} \fi}

\newcommand{\newtext}[1]{{\color{red}{\bf #1}}}

\newcommand{\dfont}[1]{{\bf\em #1}}

\usepackage[frame,all]{xy}
\usepackage{xspace}
\usepackage{amsmath}
%\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{empheq}
%\usepackage{mathenvs}
\usepackage{graphicx}
%\usepackage{color}
\usepackage{mathtools}
%\usepackage[noend]{libraries/algorithmic}
%\usepackage{dashrule}
%\usepackage{wrapfig}
%\usepackage{multirow}
%\usepackage{tabularx}
\usepackage{nicefrac}
\usepackage{relsize}

\usepackage{wrapfig}
%\usepackage{multirow}

%\usepackage{ifthen}

\DeclareMathAlphabet{\mathpzc}{OT1}{pzc}{m}{it}

%\usepackage{tabularx}

%\usepackage{algorithmic}
%\usepackage{my modathrsfs}


%\usepackage[svgnames]{xcolor}
%\usepackage{bbding}

%\usepackage{tabularx}


%\newtheorem{law}[theorem]{Algebraic Law}
\newtheorem{theorem}{Theorem}
%\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
%\newtheorem{lemma}[theorem]{Lemma}
%\newtheorem{example}[theorem]{Example}

\theoremstyle{plain}
\newtheorem{proposition}[theorem]{Proposition}

\newtheorem{thm}{\sc Theorem}
\newtheorem{cor}[thm]{\sc Corollary}
%\newtheorem{corollary}[thm]{\sc Corollary}
\newtheorem{mylemma}[thm]{\sc Lemma}
\newtheorem{lemma}[thm]{\sc Lemma}
\newtheorem{defn}[thm]{\sc Definition}
%\newtheorem{definition}[thm]{\sc Definition}
\newtheorem{prop}[thm]{\sc Proposition}
\newtheorem{example}[thm]{\sc Example}
%\newcommand{\qed}{$\Box$}
%\newenvironment{proof}{\begin{trivlist}
%\item[\hskip\labelsep{\sc Proof.}]}
%{$\hfill\Box$\end{trivlist}}
\newenvironment{sketch}{\begin{trivlist}
\item[\hskip\labelsep{\sc Proof sketch.}]}
{$\hfill\Box$\end{trivlist}}
\newenvironment{scheme}{\begin{trivlist}
\item[\hskip\labelsep{\sc Proof scheme.}]}
{$\hfill\Box$\end{trivlist}}

\usepackage{executions}
\usepackage{execgraphs}

\newcommand{\account}{\ensuremath{\mathsf{acct}}}
\newcommand{\emptytxt}{{\ensuremath{\mathsf{empty}}}}
\newcommand{\post}{\ensuremath{\mathsf{post}}}
\newcommand{\comment}{\ensuremath{\mathsf{comment}}}

%\def\qed{\ifmmode\squareforqed\else{\unskip\nobreak\hfil
%\penalty50\hskip1em\null\nobreak\hfil\squareforqed
%\parfillskip=0pt\finalhyphendemerits=0\endgraf}\fi}


\newcommand{\leaveout}[1]{}

\newcommand\Tstrut{\rule{0pt}{3.5ex}}         % = `top' strut
\newcommand\Bstrut{\\[3pt]}   % = `bottom' strut

\usepackage{paralist}
\setdefaultleftmargin{10pt}{}{}{}{}{}
\setlength{\topsep}{3pt}
\setlength{\itemsep}{2pt}
% \setlength{\partopsep}{0pt}
% \setlength{\parsep}{0pt}
%\setlength{\parskip}{0pt}

\newenvironment{subitemize}{
\begin{itemize}
 \setlength{\topsep}{0pt}
  \setlength{\itemsep}{0pt}
  \setlength{\parskip}{0pt}
}{\end{itemize}}

\multlinegap=3pt
\setlength{\jot}{2pt}
\newcommand{\ms}{\\[2pt]}

%
\setlength{\floatsep}{10pt plus 6pt minus 2pt}
\setlength{\textfloatsep}{10pt plus 6pt minus 3pt}
\setlength{\intextsep}{10pt plus 6pt minus 3pt}
\setlength{\dblfloatsep}{18pt plus 4pt minus 2pt}
\setlength{\dbltextfloatsep}{20pt plus 4pt minus 3pt}

\newenvironment{mywrapfigure}[3][]{
  \floatstyle{boxed}
  \restylefloat{figure}
  \wrapfigure[#1]{#2}{#3}}
  {\endwrapfigure
    \floatstyle{ruled}
    \restylefloat{figure}
    }
    
%readapted from the CAT language paper
\newcommand{\catsemanticsoperator}{\raisebox{-0.5ex}{\includegraphics[width=1em]{cat_outline}}}
\newcommand{\catinterpr}[1]{\ensuremath{\catsemanticsoperator\llbracket{#1}\rrbracket}}



% \setlength{\floatsep}{18pt plus 4pt minus 2pt}
% \setlength{\textfloatsep}{18pt plus 4pt minus 3pt}
% \setlength{\intextsep}{10pt plus 4pt minus 3pt}
% \setlength{\dblfloatsep}{18pt plus 4pt minus 2pt}
% \setlength{\dbltextfloatsep}{20pt plus 4pt minus 3pt}
%
%\makeatletter
%\renewcommand{\section}{\@startsection{section}{1}{0pt}%
%{-3ex plus -1ex minus -.2ex}{1.5ex plus.2ex}%
%{\normalfont\large\bfseries}}
%\renewcommand{\subsection}{\@startsection{subsection}{1}{0pt}%
%{-2ex plus -1ex minus -.2ex}{1ex plus.2ex}%
%{\bfseries}}
%\def \@begintheorem #1#2{%                      {name}{number}
%  \trivlist
%  \item[\hskip \labelsep \textbf{#1 #2.}]%
%  \itshape\selectfont
%  \ignorespaces}
%\newcommand{\nut}{\hspace{.35em}}
%\def \@opargbegintheorem #1#2#3{%               {name}{number}{title}
%  \trivlist
%  \item[%
%    \hskip\labelsep \textsc{#1\ #2}\nut (#3).]%
%  \itshape\selectfont
%  \ignorespaces}
%
%\def\@listI{\leftmargin\leftmargini
%            \parsep 0\p@ \@plus1\p@ \@minus\p@
%            \topsep 6\p@ \@plus2\p@ \@minus0\p@
%            \itemsep 0\p@}
%\let\@listi\@listI
%\@listi
%
%\makeatother
%
%\sloppy

%Labels for groups of inequations
\newcommand{\txlaws}{{\textbf{(a)}}}
\newcommand{\deplaws}{{\textbf{(b)}}}
\newcommand{\allexeclaws}{{\textbf{(c)}}}
\newcommand{\cmexeclaws}{{\textbf{(d)}}}

%Labels for individual inequations
\newcommand{\txId}{{\textbf{(a.1)}}}
\newcommand{\txComp}{{\textbf{(a.2)}}}
\newcommand{\txCap}{{\textbf{(a.5)}}}
\newcommand{\txCup}{{\textbf{(a.6)}}}
\newcommand{\txDistrR}{{\textbf{(a.3)}}}
\newcommand{\txDistrL}{{\textbf{(a.4)}}}
%
\newcommand{\depWRTx}{{\textbf{(b.1)}}}
\newcommand{\depWWTx}{{\textbf{(b.2)}}}
\newcommand{\depRWTx}{{\textbf{(b.3)}}}
\newcommand{\depWRIrrefl}{{\textbf{(b.4)}}}
\newcommand{\depWWIrrefl}{{\textbf{(b.5)}}}
\newcommand{\depRWIrrefl}{{\textbf{(b.6)}}}
%
\newcommand{\ARtrans}{{\textbf{(c.5)}}}
\newcommand{\VIStrans}{{\textbf{(c.4)}}}
\newcommand{\VISinAR}{{\textbf{(c.6)}}}
\newcommand{\ARirrefl}{{\textbf{(c.12)}}}
\newcommand{\VISnotAVIS}{{\textbf{(c.11)}}}
\newcommand{\POinVIS}{{\textbf{(c.0)}}}
\newcommand{\WRinVIS}{{\textbf{(c.1)}}}
\newcommand{\WWinAR}{{\textbf{(c.2)}}}
\newcommand{\LWW}{{\textbf{(c.7)}}}
\newcommand{\RWinAVIS}{{\textbf{(c.3)}}}
\newcommand{\AVISright}{{\textbf{(c.8)}}}
\newcommand{\AVISleft}{{\textbf{(c.9)}}}
\newcommand{\AVISnotVIS}{{\textbf{(c.10)}}}
\newcommand{\CompIrrefl}{{\textbf{(c.13)}}}
%
\newcommand{\Axiom}{{\textbf{(d.1)}}}
\newcommand{\CoAxiomAR}{{\textbf{(d.2)}}}
\newcommand{\CoAxiomL}{{\textbf{(d.3)}}}
\newcommand{\CoAxiomR}{{\textbf{(d.4)}}}

\newcommand{\Spo}{\text{(V0)}}
\newcommand{\Srf}{\text{(V1)}}
\newcommand{\Sconflict}{\text{(V3)}}
\newcommand{\SvisTrans}{\text{(V2)}}
\newcommand{\Saxiom}{\text{(V4)}}
\newcommand{\Svo}{\text{(A1)}}
\newcommand{\Svis}{\text{(A2)}}
\newcommand{\SarTrans}{\text{(A4)}}
\newcommand{\Scoaxiom}{\text{(A5)}}
\newcommand{\Sext}{\text{(A3)}}
\newcommand{\Sad}{\text{(N1)}}
\newcommand{\SavisL}{\text{(N2)}}
\newcommand{\SavisR}{\text{(N3)}}

\newcommand{\palette}{\ensuremath{\mathop{\raisebox{-4pt}{\includegraphics[scale=0.4]{palette2.png}}}}}
\newcommand{\gspec}{\ensuremath{\mathsf{gSpec}}}

% Author macros:begin %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\iflong
\title{More Algebraic Laws for Weak Consistency\\{\Large Technical Report}}
%\titlerunning{Algebraic Laws for Weak Consistency (Extended Version)} %optional, in case that the title is too long; the running title should fit into the top page column
\else
\title{More Algebraic Laws for Weak Consistency\\{\Large Technical Report}}
%\titlerunning{Algebraic Laws for Weak Consistency}
\fi

%% Please provide for each author the \author and \affil macro, even when authors have the same affiliation, i.e. for each author there needs to be the  \author and \affil macros
\iflong

\author[1]{Andrea Cerone}
\author{Who else?}
%\author[2]{Alexey Gotsman}
%\author[3]{Hongseok Yang\vspace{-5pt}}
\affil[1]{Imperial College London, UK}
%\affil[2]{IMDEA Software Institute, Madrid, Spain, \texttt{alexey.gotsman@imdea.org}}
%\affil[3]{University of Oxford, UK, \texttt{hongseok.yang@cs.ox.ac.uk} \vspace{-15pt}}
%\authorrunning{A. Cerone} %mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et. al.'
\else

\author[1]{Andrea Cerone}
%\author[2]{Alexey Gotsman}
%\author[3]{Hongseok Yang}
\affil[1]{Imperial College London, UK, \texttt{a.cerone@imperial.ac.uk}}
%\affil[2]{IMDEA Software Institute, Madrid, Spain, \texttt{alexey.gotsman@imdea.org}}
%\affil[3]{University of Oxford, UK, \texttt{hongseok.yang@cs.ox.ac.uk}}
%\authorrunning{A. Cerone,\, A. Gotsman,\, H. Yang} %mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et. al.'
\fi

%\Copyright{Andrea Cerone, Alexey Gotsman and Hongseok Yang}%mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/
%%
%\subjclass{C.2.4 Distributed Databases}% mandatory: Please choose ACM 1998 classifications from http://www.acm.org/about/class/ccs98-html . E.g., cite as "F.1.1 Models of Computation". 
%\keywords{Weak Consistency Models, Distributed Databases, Dependency Graphs.}% mandatory: Please provide 1-5 keywords
%%% Author macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%\EventEditors{Roland Meyer and Uwe Nestmann}
%\EventNoEds{2}
%\EventLongTitle{28th International Conference on Concurrency Theory (CONCUR 2017)}
%\EventShortTitle{CONCUR 2017}
%\EventAcronym{CONCUR}
%\EventYear{2017}
%\EventDate{September 5--8, 2017}
%\EventLocation{Berlin, Germany}
%\EventLogo{}
%\SeriesVolume{85}
%\ArticleNo{22} % "New number" (=<article-no>) goes here!

\begin{document}
%
%\setlength{\abovedisplayskip}{7pt plus 2pt minus 2pt}
%\setlength{\belowdisplayskip}{7pt plus 2pt minus 2pt}
%\setlength{\abovedisplayshortskip}{0pt plus 2pt}
%\setlength{\belowdisplayshortskip}{0pt plus 2pt}

%\begin{titlepage} 

\maketitle

\begin{abstract}
Todo list: 
\begin{itemize}
\item Abstract Execution Framework, similar to the algebraic laws for weak consistency. This 
is done in the same way as in \cite{laws}; it is important to understand if I want to introduce 
causality and session guarantees, in which case the completeness theorem of concur needs 
to be re-checked for simple consistency models with no causality guarantees, and 
need to be checked for consistency models with no consistency guarantee and at most 
one causality guarantee,
\item Dependency graphs and the CAT language (?) for specifying consistency models; for the 
sake of this paper, we can look at CAT expressions as inequalities of the form $R \cap \Id \subseteq \emptyset$, 
where $R$ is obtained from Tarki's calculus of binary relation with fixed points (henceforth $T^{+}$), where ground 
terms are dependencies of dependency graphs, 
\item Result: CAT specifications are not compositional,
\item Execution Kernels: the set of visibility and arbitration that are shared by all abstract 
executions with an underlying dependency graph, 
\item The use of algebraic laws for determining edges in execution kernels, 
\item Conjecture 1: Execution kernels cannot be completely captured using $T^{+}$,
\item Conjecture: specifying a consistency model in terms of a CAT expression is equivalent  
to determining the structure of execution kernels in $T^{+}$. 
\item Open problem 1: extending $T^{+}$ to capture execution kernels of consistency models, 
and to recover CAT-like specifications of consistency models using dependecy graphs,
\item Open problem 2: Making CAT-like specifications of consistency models with respect to 
abstract execution specifications,
\end{itemize}
\end{abstract}
%\vspace{1cm}

\section{Histories}
We assume that the \emph{database} consists of a set of 
integer-valued \emph{objects} $x, y, \cdots \in \Obj$. 
Such objects are accessed and updated via \emph{read} and 
\emph{write} operations, respectively. We also assume that 
the database provide other operations to users, which we leave unspecified. Formally, we assume a 
set of operations $\Op \supseteq \{\RD\;x: n, \WR\; x: n \mid x \in \Obj, n \in \mathbb{N} \}$
Operations over objects are grouped within \emph{transactions}. Formally, 
we assume a set of (run-time) transactions $\TrSet$, whose elements are ranged over by 
$T,S, \cdots$, and a function $\behav: \TrSet \rightarrow 2^{\Op}_{\text{fin}}$ 
that maps transactions into their run-time behaviour. $(\RD\;x: n) \in \behav(T)$ 
means that transaction $T$ fetched the value $n$ for object $x$ from the database, 
while $(\WR\;x:n) \in \behav(T)$ means that transaction $T$ updated the value 
of object $x$ to $n$. We commit an abuse of notation and write 
$(\RD\;x:n) \in T$ - $(\WR\;x:n) \in T$ in lieu of $(\RD\;x:n) \in \behav(T)$ 
- $(\WR\;x:n) \in \behav(T)$. Also, we prefer to write 
$T \ni (\RD\;x:n)$ for $(\RD\;x;n) \in T$, and similarly for write operations.
For any object $x$, we let $\WTr_x = \{ T \mid T \ni (\WR\;x:\_)\}$, 
and $\RTr_x = \{T \mid T \ni (\WR\;x:\_)\}$.

We assume that transactions run in \emph{isolation}, and enjoy 
\emph{atomic visibility}. The first constraint amounts to requiring that a transaction 
never observes updates to some object in the database while it is running: 
if $T \ni (\RD\;x:n), T \ni (\RD\;x:m)$ for some $x \in \Obj$ 
and $n,m \in \mathbb{N}$, then $n = m$. 
The latter constraint amounts to requiring that a transaction observes either 
none or all the operations of another transaction $S$. As a consequence, 
only the last update to each object performed by transaction $S$ will be 
visible to other transactions. We model this by requiring that whenever 
$S \ni (\WR\;x:n)$, $ S \ni (\WR\;x:m)$ for some object 
$x \in \Obj$, and values $n,m \in \mathbb{N}$, then $n = m$. 


Clients execute transactions inside \emph{sessions}. We record 
this information by keeping track of a \emph{session order} among 
transactions. 

\begin{definition}
A \emph{history} is a pair $\hist = (\T, \PO)$, where $\T$ is a finite, non-empty 
set of transactions, and $\PO \subseteq \T \times \T$ is the union of strict total orders, each of which 
is defined over a distinct element of a partition of $\T$. That is, given a partition $\{T_i\}_{i \in I}$ 
of $\T$\footnote{Recall that $\{T_i\}_{i \in I}$ is a partition of $\T$ if and only if 
$\T = \left( \bigcup_{i \in I} \T_i \right)$, and whenever 
$T_i \cap T_j \neq \emptyset$ for some $i, j \in I$, then $\T_i = T_j$.}, 
then $\PO = \left( \bigcup_{i \in I} \PO_i \right)$, where for all $i \in I$, 
$\PO_i \subseteq (\T_i \times \T_i)$ is a strict total order\footnote{A relation $\R \subseteq \T \times \T$ is a strict partial order 
if it is transitive and irreflexive; it is a strict total order if it enjoys the further property that for 
any $T, S \in \T$, either $T = S$, $(T,S) \in \R$, or $(S,T) \in \R$.}.
\end{definition}
Given a history $\hist = (\T, \PO)$, we let $\T_{\hist} = \T, \PO_{\hist} = \PO$. 
Sometimes we write $T \xrightarrow{\PO} S$ instead of $(T,S) \in \PO$, 
and similarly for other binary relations over transactions.
The session order models the order in which a client requested transactions 
within the same session. No other information about the time of execution 
of transactions is given in histories. 

A consistency model is the set of run-time behaviours, or histories, 
allowed by the database.
\begin{definition}
A consistency model $\Gamma$ is a set of histories.
\end{definition}

\section{Specification of Consistency Models using Abstract Executions}
To specify weak consistency models, we augment histories with two 
relations between transactions: 
\begin{itemize}
\item \textbf{VIS}ibility specifies when a transaction is aware of the effects 
of another one, 
\item \textbf{AR}bitration is used to resolve conflicts between concurrent 
transactions accessing/updating the same object,
\end{itemize} 

\begin{definition}
An abstract execution is a tuple $\aexec = (\T, \PO, \VIS, \AR)$, 
where $(\T, \PO)$ is a history, $\VIS \subseteq \T \times \T$, $\AR \subseteq \T \times \T$ 
are two relations between transactions such that $\VIS \subseteq \AR$, and $\AR$ 
is a strict total order over $\T$. 
\end{definition}

\begin{definition}
An abstract execution $\aexec = (\T, \PO, \VIS, \AR)$ satisfies the \emph{Last Write Wins} ({\bf LWW}) 
policy if whenever $T \in \T$ is such that $T \ni (\RD\;x:n)$, then $S := \max_{\AR}(\VIS^{-1}(T) \cap \WTr_x)$ 
is defined; furthermore, $S \ni (\WR\;x:n)$.
\end{definition}

To determine whether a history $\hist$ is allowed by a consistency model, it suffices 
to find two witness relations $\VIS, \AR \subseteq \T_{\hist} \times \T_{\hist}$ 
such that $\aexec = (\T_{\hist}, \PO_{\hist}, \VIS, \AR)$ is an abstract execution 
that satisfies the LWW policy. Furthermore, we require that $\aexec$ satisfies additional 
constraints, corresponding to the specification of the consistency model. 
We distinguish between three different kinds of properties that we consider 
when specifying consistency models: 
\begin{itemize}
\item Session guarantees, that establish when the database may or may 
not re-order the processing of transactions within the same session: 
these properties take the form $R \subseteq \VIS$, where $\R \subseteq \PO_{\hist}$, 
\item Causality guarantees, that establish in which case a relevant subset of the causal dependencies of a 
transaction observed by $T$, must also be observed by the same transaction; these properties 
take the form $R_1 \rcomp \R_2 \subseteq \VIS$, where both $R_1$ and $R_2$ are subsets 
of the reflexive closure of $\VIS$, namely $\VIS?$, 
\item Synchronisation guarantees, which establish when two transactions cannot be executed 
concurrently; properties of this kind have the form $R_1 \rcomp \AR \rcomp R_2 \subseteq \VIS$, 
where $R_1, \R_2 \subseteq \VIS?$.
\end{itemize}

To formalise this intuition, we introduce the notion of session function and specification function: 
\begin{definition}
A session guarantee is a function $\sigma: (\times \TrSet \times \TrSet) \rightarrow (\TrSet \times \TrSet)$ 
such that $\sigma(R) \subseteq R$; 
a specification function is a function $\rho: (\Hist \times (\TrSet \times \TrSet)) \rightarrow (\TrSet \times \TrSet)$ 
such that for any $\hist \in \Hist, R \subseteq \TrSet \times \TrSet$, $\rho(\hist, R) = \rho(\hist, (\TrSet \times \TrSet)) \cap R?$. 
\end{definition}
The intuition behind these definitions are explained in \cite{laws}. 

\begin{definition}
An \emph{Abstract Execution Based Consistency Model Specification}, or simply x-specification, 
is a triple $\Sigma = (\{\sigma_i\}_{i \in I}, \{(\gamma_j, \beta_j)\}_{j \in J}, \{(\rho_k, \pi_k)\}_{k \in K})$, 
where $I, J, K$ are (possibly empty) index sets, for any $i \in I$, $\sigma_i$ is a session guarantee, and 
for any $j \in J, k \in K$, $\beta_j, \gamma_j, \rho_k, \pi_k$ are specification functions. Each 
of the pairs $(\gamma_j, \beta_j)$, $j \in J$, is called a \emph{causality guarantee}. Each of the 
pairs $(\rho_k, \pi_k)$, $k \in K$, is called a \emph{synchronisation guarantee}.

An abstract execution $\aexec = (\T, \PO, \VIS, \AR)$ conforms to the x-specification 
$\Sigma = (\{\sigma_i\}_{i \in I}, \{(\gamma_j, \beta_j)\}_{j \in J}, \{(\rho_k, \pi_k)\}_{k \in K})$ 
if and only if 
\begin{itemize}
\item $\left(\bigcup_{i \in I} \sigma_i(\PO) \right) \subseteq \VIS$, 
\item for any $j \in J$, $\gamma_j(\hist, \VIS) \rcomp \beta_j(\hist, \VIS) \subseteq \VIS$, 
\item for any $k \in K$, $\rho_k(\hist, \VIS) \rcomp \AR \rcomp \pi_k(\hist, \VIS) \subseteq \VIS$.
\end{itemize}
We use the symbols $\sessionG, \causalG, \syncG$ to range over sets of session, causality and 
synchronisation guarantees, respectively.

The set of abstract executions conforming to the x-specification $\Sigma$ is denoted 
$\aeset(\Sigma)$.
\end{definition}
Given an abstract execution $\aexec$ and a x-specification $\Sigma$, we write 
$\aexec \models \Sigma$ as a short-cut for 
$\aexec \in \aeset(\Sigma)$. Also, given two x-specifications $\Sigma_1 = (\sessionG_1, \causalG_1, \syncG_1)$, 
$\Sigma_2 = (\sessionG_2, \causalG_2, \syncG_2)$, we let $\Sigma_1 \sqcup \Sigma_2 = (\sessionG_1 \cup \sessionG_2, 
\causalG_1 \cup \causalG_2, \syncG_1 \cup \syncG_2)$. We also let $\Sigma_1 \sqsubseteq \Sigma_2$ if and only if there 
exists a $\Sigma'$ such that $\Sigma_2 = \Sigma_1 \sqcup \Sigma'$. Clearly, $\Sigma_1\sqsubseteq \Sigma_2$ 
if and only if $\sessionG_1 \subseteq \sessionG_2, \causalG_1 \subseteq \causalG_2, \syncG_1 \subseteq \syncG_2$.
\begin{lemma}
\label{lem:xspec.exec}
For any $\Sigma_1, \Sigma_2$ such that $\Sigma_1 \sqsubseteq \Sigma_2$, 
we have that $\aeset(\Sigma_2) \subseteq \aeset(\Sigma_1)$.
\end{lemma}
\begin{proof}
Let $\Sigma_2 = (\sessionG_2, \causalG_2, \syncG_2)$, and let 
$\aexec$ be such that $\aexec \models \Sigma_2$. We need to show 
that $\aexec \models \Sigma_1$. Let $\Sigma_1 = (\sessionG_1, \causalG_1, \syncG_1)$;  
by hypothesis, $\Sigma_1 \sqsubseteq \Sigma_2$, i.e. $\sessionG_1 \subseteq \sessionG_2, 
\causalG_1 \subseteq \causalG_2, \syncG_1 \subseteq \syncG_2)$. Therefore, we have that 
\begin{itemize}
\item for all $\sigma \in \sessionG_1$, $\sigma(\PO_{\aexec}) \subseteq \VIS_{\aexec}$: 
this is because $\sessionG_1 \subseteq \sessionG_2$, hence $\sigma \in \sessionG_2$, and 
because $\aexec \models \Sigma_2$ we have that $\sigma(\PO_{\aexec}) \subseteq \VIS_{\aexec}$, 
\item for all $(\gamma, \beta) \in \causalG_1$, $\gamma(\VIS_\aexec) \rcomp \beta(\VIS_{\aexec}) \subseteq 
\VIS_{\aexec}$: this can be proved in a way similar as below, 
\item for all $(\rho, \pi) \in \syncG_1$, $\rho(\VIS_{\aexec}) \rcomp \AR_{\aexec} \rcomp \pi(\VIS_{\aexec}) \subseteq \VIS_{\aexec}$: 
again, the proof is similar to the other two cases.
\end{itemize}
We may conclude that $\aexec \models \Sigma_1$, as we wanted to prove.
\end{proof}

\ac{Todo: I never checked thoroughly that the definitions of Session Guarantees 
and Causality Guarantees are the appropriate ones. Some examples of consistency 
models that can be captured are necessary here.}
\ac{Also todo: I remember that I needed the constraint that $\rho(\VIS) \subseteq \VIS?$ 
back when the definition of specification functions was quite restrictive, but I am 
not sure whether I have used this anywhere. It could be that I can replace $\rho(\VIS)$ 
without losing any of the results in CONCUR}.


\begin{definition}
The consistency model underlying the x-specification $\Sigma$ is defined as $
\modelof(\Sigma) = \{(\T, \PO) \mid 
\exists \VIS, \AR.\; (\T, \PO, \VIS, \AR) \in \aeset(\Sigma)\}$.
\end{definition}

\section{Specification of Consistency Models using Dependency Graphs} 

\begin{definition}
A dependency graph $\G = (\T, \PO, \RF, \VO, \AD)$ is a
tuple such that $(\T, \PO)$ is a history, and $\RF, \VO, \AD: \Obj \rightarrow (\T \times \T)$ 
are functions such that
\begin{description}
\item[Write-read dependencies: ] for any object $x \in \Obj$, $T,S,S' \in \T$, 
\begin{enumerate}
\item if $T \ni (\RD\;x:n)$, there exists $S \neq T$ such that $S \xrightarrow{\RF(x)} T$, 
\item whenever $S \xrightarrow{\RF(x)} T$, then $T \ni (\RD\;x:n)$ and $S \ni (\WR\;x:n)$ 
for some $n \in \mathbb{N}$, 
\item whenever $S \xrightarrow{\RF(x)} T$, $S' \xrightarrow{\RF(x)} T$, then $S = S'$,
\end{enumerate}
\item[Write-write dependencies: ] for any object $x \in \Obj$, $\VO(x) \subseteq (\T \cap \WTr_x) \times (\T \cap \WTr_x)$ is a strict total 
order,
\item[Anti-dependencies: ] for any $T,S \in \T$, $T \xrightarrow{\AD(x)} S$ if and only if $T \neq S$, and there exists $T'$ 
such that $T' \xrightarrow{\RF(x)} T$, and $T' \xrightarrow{\VO(x)} S$.
\end{description}
\end{definition}
The set of all dependency graphs is denoted as $\graphs$.

Abstract executions can be easily converted into dependency graphs: 
\begin{definition}
Given an abstract execution $\aexec = (\T, \PO, \VIS, \AR)$, we define 
$\graphof(\aexec) = (\T, \PO, \RF_{\aexec}, \VO_{\aexec}, \AD_{\aexec)}$ as follows: 
\begin{enumerate} 
\item $T \xrightarrow{\RF_{\aexec}(x)} S$ if and only if $S \ni (\RD\;x: n)$, and 
$T = \max_{\AR}(\VIS^{-1}(T) \cap \WTr_x)$, 
\item $T \xrightarrow{\VO_{\aexec}(x)} S$ if and only if $S \ni (\WR\;x: \_)$, 
$T \ni (\WR\;x: \_)$, and $T \xrightarrow{\AR} S$, 
\item $T \xrightarrow{\AD_{\aexec}(x)} S$ if $T \neq S$, and there exists 
$V$ such that $V \xrightarrow{\RF_{\aexec}(x)} T$, $V \xrightarrow{\VO_{\aexec}(x)} S$.
\end{enumerate}
\end{definition}

A consistency model can be specified by imposing certain requirements 
over dependency graphs, and then projecting graphs satisfying said 
requirements to histories. In general, the requirements that we 
impose over dependency graphs amount to requiring that cycles 
of a certain form cannot happen. 

\begin{definition}
A g-specification is a set $\Delta = \{\delta_1, \cdots, \delta_n\}$, 
where for any $i=1,\cdots, n$ $\delta_i : \graphs \rightarrow 2^{(\TrSet \times \TrSet)}$ 
is such that for any $\G \in \graphs$, $\delta_i(\G) \subseteq (\PO_{\G} \cup \RF_{\G} \cup \VO_{\G} \cup \AD_{\G})^{+}$.
\ac{Need to decide, it could be that I may want to admit also $\RF_{\G}^{-1}, \VO_{\G}^{-1}$ and $\AD_{\G}^{-1}$ 
as edges.}
\end{definition}

\begin{definition}
A dependency graph $\G$ is allowed by the g-specification $\Delta = \{\delta_1, \cdots, \delta_n\}$ if, 
for any $i=1,\cdots,n$, $\delta_i(\G) \cap \Id = \emptyset$. Recall that $\Id = \{(T, T) \mid T \in \TrSet\}$.
We let $\graphs(\Delta)$ be the set of dependency graphs allowed by $\Delta$, and define $\modelof(\Delta) = 
\{\hist_{\G} \mid \G \in \graphs(\Delta) \}$.
\end{definition}

\subsection{The Kitten Language}
Below we introduce the \emph{Kitten} language to formalise g-specifications: the language 
is obtained as a fragment of the \emph{CAT} language for specifying weak 
memory models. We believe that Kitten and CAT have the same expressive power. 

\[
\begin{array}{lcl}
D &::=& \RF(x) \;\lvert\; \VO(x) \;\lvert\; \AD(x) \;\lvert\; 0 \;\lvert\; 1\;\lvert\; [\mathsf{O}]\\
K &::=& D \;\lvert\; X \;\lvert\; K \cdot K \;\lvert\; K + K \;\lvert\; K \times K \;\lvert\; K^{\smallsmile} \;\lvert\; K - K \;\lvert \; \mu X. K
\end{array}
\]
$D$-terms in the grammar above can have the form $[\mathsf{O}]$: here $\mathsf{O}$ is symbol from some set $\Omega$, and 
we assume that there is a mapping $\omega: \Omega \rightarrow 2^{\TrSet}$. For example, we assume that for any 
object $x \in \Obj$, $\Omega$ contains the symbol $\mathsf{W}(x)$, and $\omega(\mathsf{W}(x)) = \{T \in \TrSet \mid T \ni (\WR\;x:\_)\}$.
The variable symbol $X$ in $K$-terms represent a variable taken from a set $\mathsf{Var}$.

Each (closed) term $K$ in kitten is interpreted into a function $\catinterpr{K} : \graphs \rightarrow 2^{\TrSet \times \TrSet}$. 
To define such an interpretation formally, we first need to introduce the notion of environment: an environment is a 
function $\varepsilon: \graphs \times \mathsf{Var} \rightarrow 2^{\TrSet \times \TrSet}$, such that 
for any $\G \in \graphs$ and $X \in \mathsf{Var}$, $\varepsilon(\G)(X) \subseteq 2^{(\RF_{\G} \cup \VO_{\G} \cup \AD_{\G})^{\ast}}$. 
The interpretation of a possibly open $K$-term is a function $\catinterpr{K} : \graphs \rightarrow \mathsf{Env} \rightarrow 2^{\TrSet \times \TrSet}$, 
and is defined as follows: 
\[
\begin{array}{lcl}
\catinterpr{\RF(x)}(\G)(\_) &=& \RF_{\G}(x)\\
\catinterpr{\VO(x)}(\G)(\_) &=& \VO_{\G}(x)\\
\catinterpr{\AD(x)}(\G)(\_) &=& \AD_{\G}(x)\\
\catinterpr{0}(\_)(\_) &=& \emptyset\\
\catinterpr{1}(\G)(\_) &=& \Id_{\G}\\
\catinterpr{[\mathsf{O}]}(\G) &=& \{(T,T) \mid T \in \omega(\mathsf{O}) \cap \T_{\G}\}\\
&&\\
\catinterpr{X}(\G)(\varepsilon) &=& \varepsilon(\G)(X)\\
\catinterpr{K_1 \cdot K_2}(\G)(\varepsilon) &=& \catinterpr{K_1}(\G)(\varepsilon) \rcomp \catinterpr{K_2}(\G)(\varepsilon)\\
\catinterpr{K_1 \times K_2}(\G)(\varepsilon) &=& \catinterpr{K_1}(\G)(\varepsilon) \cap \catinterpr{K_2}(\G)(\varepsilon)\\
\catinterpr{K_1 + K_2}(\G)(\varepsilon) &=& \catinterpr{K_1}(\G)(\varepsilon) \cup \catinterpr{K_2}(\G)(\varepsilon)\\
\catinterpr{K^{\smallsmile}}(\G)(\varepsilon) &=& \catinterpr{K}(\G)(\varepsilon)^{-1}\\
\catinterpr{K_1 - K_2}(\G)(\varepsilon) &=& \catinterpr{K_1}(\G)(\varepsilon) \setminus \catinterpr{K_2}(\G)(\varepsilon)\\
\catinterpr{\mu X. K}(\G)(\varepsilon) &=& \bigcap \{ P \mid \catinterpr{K}(\G)(\varepsilon[X \mapsto P]) \subseteq P\}\\
\end{array}
\]

\section{Execution Kernels}
Our ultimate goal is that of recovering, given a x-specification, an equivalent g-specification. 
That is, given a x-specificaiton $\Sigma$, we want to find a g-specification $\Delta := \gspec(\Sigma)$ 
such that $\modelof(\Sigma) = \modelof(\Delta)$. Our first step to achieve this ultimate goal is 
that of connecting abstract executions to dependency graphs.
 
Throughout this Section we work with the x-specification $\Sigma_{\CP} = (\{\sigma_{S}\}, \{(\rho_{V}, \rho_{V})\}, 
\{(\rho_\Id, \rho_V)\})$, where $\sigma_{S}(R) = R$, $\rho_V(R) = R \setminus \Id$, and $\rho_\Id(R) = \Id$. 
By definition, abstract executions $\aexec = (\T, \PO, \VIS, \AR)$ in $\aeset(\Sigma_{\CP})$ must satisfy the following axioms:
\[
\begin{array}{lcl}
\PO &\subseteq& \VIS\\
\VIS \rcomp \VIS &\subseteq& \VIS\\
\AR \rcomp \VIS &\subseteq& \VIS
\end{array}
\]
\ac{The causal consistency axiom is not really needed here, as it is going to be implied by 
prefix consistency and the requirement of abstract executions that $\VIS \subseteq \AR$.}
The first axiom, induced by the session guarantee $\sigma_S$, corresponds to the \emph{strong 
session guarantees} of database systems": transactions processed by a client must appear to 
execute sequentially, in the order in which they are requested by the client.
%$\sigma_S$ corresponds to the \emph{strong session guarantee} of database systems; 
The second axiom, induced by the causality guarantee $(\rho_V, \rho_V)$, models \emph{causal consistency}: 
when a transaction $T$ observes the effects of another transaction $S$, it must also observe the effects of 
those transaction on which $S$ depends.
% must observe the causal dependencies of causal 
%the causality guarantee $(\rho_{V}, \rho_{V})$ models \emph{causal consistency}, while 
Finally, the last axiom, induced by the synchronisation guarantee 
$(\rho_\Id, \rho_V)$, models \emph{prefix consistency}, also known as \emph{multi-atomic}: 
the set of transactions observed by a transaction $T$ is a prefix of the arbitration relation, 
which ensures that concurrent transactions never observe different states of the database. 

Given dependency graph $\G$, we want to establish whether we can recover a witness abstract 
execution $\aexec$ such that $\aexec \models \Sigma_{\CP}$, and $\graphof(\aexec) = \G$. 
To build such an abstract execution $\aexec$, we must construct two relations $\VIS_{\aexec}$ and 
$\AR_{\aexec}$ that satisfy all the consistency guarantees of $\Sigma_{\CP}$, plus the constraints 
required by abstract executions. In particular, we require $\AR_{\aexec}$ to be a total order.

The next example shows that, when constructing the relations $\VIS_{\aexec}$, $\AR_{\aexec}$ as 
to satisfy the requirements above, the orientation of some $\AR_{\aexec}$ edges between two 
transactions $T,S \in \T_{\G}$ is not relevant; similarly, the presence of a $\VIS_{\aexec}$ edge 
connecting two transactions may also be not relevant.

\begin{example}
\label{ex:writeskew}
Consider the depedency graph $\G_1$ depicted below:
\begin{center}
\begin{tikzpicture}
\node (Rx0) {$\RD\;x:0$};
\path (Rx0) + (2,0) node (Wy1) {$\WR\;y:1$};
\path (Rx0) + (0,-2) node (Ry0) {$\RD\;y:0$};
\path (Wy1) + (0,-2) node (Wx1) {$\WR\;x:1$};
%
\begin{pgfonlayer}{background}
\node (t1) [background, fit=(Rx0) (Wy1)] {};
\node (t2) [background, fit=(Ry0) (Wx1)] {};
%
\path (t1.south) + (-2,0) node (ad1to2s) {};
\path (t1.south) + (2,0) node (ad2to1e) {};
%
\path (t2.north) + (-2,0) node (ad1to2e) {};
\path (t2.north) + (2,0) node (ad2to1s) {};
%
\path[thick,->] 
 (ad1to2s.center) edge[bend right=30] node[left] {$\AD$} (ad1to2e.center)
 (ad2to1s.center) edge[bend right=30] node[right] {$\AD$} (ad2to1e.center);
%
\path (t1.east) + (0.5,0.2) node (T1) {$T$};
\path (t2.east) + (0.5,-0.2) node (T2) {$S$};
\end{pgfonlayer}
\end{tikzpicture}
\end{center}
To prove that $(\T, \PO) \in \modelof(\Sigma_{\CP})$, we need to 
find an abstract execution $\aexec$ such that $\T_{\aexec} = \T, \PO_{\aexec} = \PO$, 
and $\aexec \models \Sigma_{\CP}$. In fact, there are two such abstract executions, 
$\aexec_1, \aexec_2$. They are defined by letting $\VIS_{\aexec_1} = \VIS_{\aexec_2} = \emptyset$,
$\AR_{\aexec_1} = \{(T,S)\}$, and $\AR_{\aexec_2} = \{(S,T)\}$.  \qed
\end{example}
%In Example \ref{ex:writeskew}, the orientation of the arbitration edge between transactions $T,S$ is 
%not relevant to the end of proving that the history depicted in such an example is included in $\modelof(\Sigma_{\CP})$. 
However, in some other cases, all the abstract executions $\aexec$ that can be used as witnesses to prove 
that the history of a given dependency graph $\G$ gives rise to a history allowed by $\modelof(\Sigma_{\CP})$, 
must agree on the orientation of some arbitration edges. This is shown in the next example. 

\begin{example}
\label{ex:critical.edge}
Consider the dependency graph $\G_2$ depicted below: 
\begin{center}
\begin{tikzpicture}[every node/.style={transform shape}]
%\node (R1y) {$\rd(y,0)$}; 
\node (W1x) {$\WR\;x: 1$};
%\path (W1x.center) + (3.5,0) node (R1x) {$\rd(x, 1)$};
\path(W1x.center) + (3.5,0) node (R1y) {$\RD\;y:1$}; 
\path(R1y.center) + (0,-2) node(W1y) {$\WR\;y:1$};
\path(R1y.center) + (3.5,0) node (W2y) {$\WR\;y:2$};
%
%
%\path (W1x) + (0,-2.0) node (W2x) {$\rd(x, 1)$}; 
%\path(Wy.center) + (3.5,0) node (R4x) {$\rd(x, 0)$}; 
%\path(R4x.center) + (2.0,0) node (R4y) {$\rd(y, 1)$};
%
%\path[->] 
%  (Wy.east) edge[thick] node[above] {$\hb$} (R4x.west)
   %(R4x.east) edge node[above] {} (R4y.west);
%
\begin{pgfonlayer}{background}
\node(t1) [background, fit=(W1x), inner sep=0.1cm] {};
\node(t2) [background, fit=(R1y), inner sep=0.1cm] {};
\node(t3) [background, fit=(W1y), inner sep=0.1cm] {};
\node(t4) [background, fit=(W2y), inner sep=0.1cm] {};
\path(t1.north west) + (0.5,0.3) node[font=\normalsize] (T1) {$T_1$};
\path(t3.south west) + (0.5,-0.3) node[font=\normalsize] (T3) {$T_3$};
\path(t2.north east) + (-0.5,0.3) node[font=\normalsize] (T2) {$T_2$};
\path(t4.north east) + (-0.5,0.3) node[font=\normalsize] (T4) {$T_4$};
%
\path[thick,->] 
  (t1.east) edge node[above] {$\PO$} (t2.west)
 (t3.north) edge node[right] {$\RF$} (t2.south)
 (t2.east) edge node[above] {$\AD$} (t4.west)
 (t3.east) edge node[right] {$\VO$} (t4.south);
\end{pgfonlayer}
\end{tikzpicture}
\end{center}
We argue that, in any abstract execution $\aexec$ such that $\aexec \models \in \Sigma_{\CP}$ 
and $\graphof(\aexec) = \G$, it must be $T_1 \xrightarrow{\AR_{\aexec}} T_4$. 
To see why this is true, suppose that $\aexec \models \Sigma_{\CP}$, and $\graphof(\aexec) = \G$. 
We must have $T_1 \xrightarrow{\VIS_{\aexec}} T_2$, 
because by the strong session guarantee $\PO \subseteq \VIS$. Because $\graphof(\aexec) = \G$, 
we must have that $\T_3 \xrightarrow{\VIS_{\aexec}} T_2$ (since $\RF_{\G}$ is a subset of $\VIS_{\aexec}$ by definition), 
and $T_3 \xrightarrow{\AR} T_4$ (ecause $\VO_{\G}$ is a subset of $\AR_{\aexec}$ by definition). 
$\AR_{\aexec}$ needs to be a total order, either $T_1 \xrightarrow{\AR_{\aexec}} T_4$ 
or $T_4 \xrightarrow{\AR_{\aexec}} T_1$. But if it were the latter case, we would have 
$T_4 \xrightarrow{\AR_{\aexec}} T_1 \xrightarrow{\VIS_{\aexec}} T_2$. Recall that 
$\Sigma_{\CP}$ has the prefix consistency guarantee, which ensures that  
$\AR_{\aexec} \rcomp \VIS_{\aexec} \subseteq \VIS_{\aexec}$\
%, which enforces that $\AR_{\aexec} \rcomp \VIS_{\aexec} \subseteq \VIS_{\aexec}$
: this means that it must be the case that $T_4 \xrightarrow{\VIS_{\aexec}} T_2$. But 
now we have that $T_4$ is the last transaction (with respect to $\AR_{\aexec}$ 
that $T_2$ sees, and writes to object $y$. Furthermore, $T_4$ reads value $1$ for $y$, 
whereas $T_2$ writes value $2$ for $y$. This means that $\aexec$ does not satisfy the 
last write wins policy, which leads to a contradiction. The contradiction was caused 
by the assumption that $T_4 \xrightarrow{\AR_{\aexec}} T_1$, hence we must have 
that $T_1 \xrightarrow{\AR_{\aexec}} T_4$, as we wanted to prove.
\end{example}

Fix a x-specification $\Sigma$. For a dependency graph $\G = (\T, \PO, \RF, \VO, \AD)$, we define 
its execution kernel as the pair $(\VIS_{\G}, \AR_{\G}, \AVIS_{\G})$, where: 
\[
\begin{array}{lcl}
\VIS_{\Sigma}(\G) &=& \bigcap \{ \VIS_{\aexec} \mid \aexec \models \Sigma \wedge \graphof(\aexec) = \G\}\\
\AR_{\Sigma}(\G) &=& \bigcap \{ \AR_{\aexec} \mid \aexec \models \Sigma \wedge \graphof(\aexec) = \G\}\\
\AVIS_{\Sigma}(\G) &=& \bigcap \{ \overline{\VIS_{\aexec}^{-1}} \mid \aexec \models \Sigma \wedge \graphof(\aexec) = \G\}
\end{array}
\]

\begin{lemma}
\label{lem:kernel.inclusion}
Let $\Sigma_1 \sqsubseteq \Sigma_2$; for any dependency graph $\G$, 
we have that $\AR_{\Sigma_1}(\G) \subseteq \AR_{\Sigma_2}(\G)$; 
similar results apply to $\VIS_{\_}(\G)$ and $\AVIS_{\_}(\G)$.
\end{lemma}

\begin{proof}
Recall, that for any two collections of sets $\{A_i\}_{i \in I}, \{B_j\}_{j \in J}$, 
we have that 
\[
\bigcap \left( \{ A_i \}_{i \in I} \cup \{B_j \}_{j \in J} \right) = \left( \bigcap \{ A_i \}_{i \in I} \right) \cap \left( \bigcap \{B_j\}_{j \in J} \right).
\]
In fact, let $K = I \uplus J$, and for any $k \in K$ (that is, for any $k \in K$, we have that either $k = \mathsf{injl}(i)$ for some $i \in I$, 
or $k = \mathsf{injr}(j)$ for some $j \in J$). Define $C_k = A_i$ if $k = \mathsf{injl}(i)$ for some $i \in I$, and 
$C_k = B_k$ if $k = \mathsf{injr}(j)$ for some $j \in J$. Then we have that $\{C_k\}_{k \in K} = \{A_i\}_{i \in I} \cup \{B_j\}_{j \in J}$, 
from which the following follows:
\[
\begin{array}{lcl}
\bigcap \left( \{ A_i \}_{i \in I} \cup \{B_j \}_{j \in J} \right) &=& \left( \bigcap \{ C_k \}_{k \in K} \right) = \\
&=& \{ x \mid \forall k \in K.\, x \in C_k\}\\
&=& = \{x \mid \forall k \in K.\,\\
&& \phantom{( x \mid {}} (\exists i \in I.\, k = \mathsf{injl}(i) \implies x \in A_i) 
\wedge {}\\ 
&&\phantom{(x \mid {} }(\exists j.\, k = \mathsf{injr}(j) \in J \implies x \in B_j) \}\\
&=& \{ x \mid (\forall i \in I.\, x \in A_i) \wedge (\forall j \in J).\, x \in B_j) \}\\
&=& \{ x \mid \forall i \in I.\, x \in A_i) \} \cap \{ x \mid \forall j \in J.\, x \in B_j \}\\
&=& \left( \bigcap \{A_i\}_{i \in I} \right) \cap \left( \bigcap \{B_j\}_{j \in J} \right)
\end{array}
\]
\ac{Here I have to be clear about notation: the union above refers to a union of two sets, whose 
elements are sets of sets. That is, if $i = 1, \cdots, n$, $j = 1, \cdots, m$, then 
$\{A_1, \cdots, A_n\} \cup \{B_1, \cdots, B_m\} = \{A_1, \cdots, A_n, B_1, \cdots, B_m\}$. 
In contrast, the $\bigcap{}$ operator refers to the intersections of all sets contained within a set 
of sets, i.e. $\bigcap \{A_1, \cdots, A_n,  B_1, \cdots B_m\} = A_1 \cap \cdots \cap A_n \cap B_1 \cap \cdots B_n$.}

In particular, we have that if $\{A_i\}_{i \in I} \subseteq \{B_j\}_{j \in J}$, then 
$\left( \bigcap \{B_j\}_{j \in J} \right) \subseteq \left( \bigcap \{A_i\}_{i \in I} \right)$. 
In fact, we have that 
\[
\begin{array}{lcl}
\left(\bigcap \{B_j\}_{j \in J} \right) &=& \bigcap \left( \{A_i\}_{i \in I} \cup \{B_j\}_{j \in J} \right)\\
&=& \left( \bigcap \{ A_i \}_{i \in I} \right) \cap \left( \bigcap \{ B_j \}_{j \in J} \} \right)\\
&\subseteq& \left( \bigcap \{A_i\}_{i \in I} \right)
\end{array}
\]

We are now ready to prove Lemma \ref{lem:kernel.inclusion}. Suppose that $\Sigma_1 \sqsubseteq \Sigma_2$
By Lemma \ref{lem:xspec.exec}, we have that whenever $\aexec \models \Sigma_2$, then $\aexec \models \Sigma_1$, 
and in particular 
\[
\{\AR_{\aexec} \mid \aexec \models \Sigma_2 \wedge \graphof(\aexec) = \G \} \subseteq 
\{\AR_{\aexec} \mid \aexec \models \Sigma_1 \wedge \graphof(\aexec) = \G \}
\]

from which it follows that  
\[
\begin{array}{lcl}
\AR_{\Sigma_1}(\G) &=& \left( \bigcap \{ \AR_{\aexec} \mid \aexec \models \Sigma_1 \models \aexec \wedge \graphof(\aexec) = \G \} \right)\\
&\subseteq& \left( \bigcap \{\AR_{\aexec} \mid \aexec \models \Sigma_2 \wedge \graphof(\aexec) = \G \} \right)\\ 
&=& \AR_{\Sigma_2}(\G),
\end{array}
\]
as we wanted to prove.
\end{proof}

There is a non-trivial connection between execution kernels, x-specifications and g-specification. 
\begin{theorem}
\label{thm:kernel}
Let $\Sigma$ be a x-specification, and define $\delta_{\Sigma} : \G \mapsto \AR_{\Sigma}(\G)$. 
Then $\modelof(\Sigma) = \modelof(\{\delta_{\Sigma}\})$.
\end{theorem}

\begin{proof}
We prove that 
\begin{enumerate} 
\item\label{thm:kernel.1} whenever $\aexec \models \Sigma$, then $\AR_{\Sigma}(\graphof(\aexec))\cap \Id = \emptyset$, and 
\item\label{thm:kernel.2} whenever $\AR_{\Sigma}(\G) \cap \Id = \emptyset$, then there exists $\aexec$ such that 
$\aexec \models \Sigma$ and $\graphof(\aexec) = \G$. 
\end{enumerate}
As a consequence, we get that whenever $\hist \in \modelof(\Sigma)$, then there exists an abstract execution 
$\aexec$ such that $\aexec \models \Sigma$ and $\hist_{\aexec} = \hist$. Also, we know by \eqref{thm:kernel.1} 
that for the dependency  graph $\G := \graphof(\aexec)$, the relation $\AR_{\Sigma}(\graphof(\aexec)) \cap \Id = \emptyset$, 
hence $\G \in \graphs(\{\delta_{\Sigma}\})$, from which $\hist = \hist_{\G} \in \modelof(\{\delta_{\Sigma}\})$ follows. 
Similarly, if we assume that $\hist \in \modelof(\{\delta_{\Sigma}\}$, then there exists a dependency graph
$\G \in \graphs(\{\delta_{\Sigma}\})$ such that $\hist_{\G} = \hist$. Then by \eqref{thm:kernel.2} we have 
that there exists an abstract execution $\aexec \models \Sigma$, and $\graphof(\aexec) = \G$. In particular, 
$\aexec \models \Sigma$ and $\hist_{\aexec} = \hist_{\G} = \hist$, from which it follows that $\hist \in \modelof(\Sigma)$.

It remains to prove \eqref{thm:kernel.1} and \eqref{thm:kernel.2} above. For \eqref{thm:kernel.1}, let $\aexec$ be 
such that $aexec \models \Sigma$, and let $\G := \graphof(\aexec)$. By definition, we have 
that 
\[
\AR_{\Sigma}(\G) = \bigcap \{ \aexec \mid \aexec \models \Sigma \wedge \graphof(\aexec) = \G\} \subseteq 
\AR_{\aexec}
\]
and because $\AR_{\aexec} \cap \Id = \emptyset$, we also have that $\AR_{\Sigma}(\G) \cap \Id = \subseteq \emptyset$. 

For \eqref{thm:kernel.2}, let us first assume that $\hist_{\G} = (\emptyset, \emptyset)$. In this case it is trivial to 
show that $\hist_{\G} \in \modelof(\Sigma)$ for any x-specification $\Sigma$: in particular 
the abstract execution $\aexec_0 = (\emptyset, \emptyset, \emptyset)$ is such that 
$\aexec_0 \models \Sigma$. 
Let then $\G = (\T, \PO, \RF, \VO, \AD)$, 
where $\T \supset \emptyset$. Suppose that $\AR_{\Sigma}(\G) \cap \Id = \emptyset$. In particular, there exists 
a transaction $T \in \T$ such that $(T,T) \notin \AR_{\Sigma}(\G)$. Suppose also that there exists no abstract execution 
$\aexec$ such that $\aexec \models \Sigma$, and $\graphof(\aexec) = \G$. By definition, $\AR_{\Sigma}(\G) = (\T \times \T)$, 
and in particular $(T,T) \in \AR_{\Sigma}(\G)$. Contradiction.
\end{proof}
\ac{It seems that this proof did not require the results from Concur'17, though it is by Reduction ad Absurdum. 
Curiousy enough, it does not even rely on the structure imposed on the axioms of the consistency models.}
\ac{Thus, when I define the acyclicity check of dependency graphs, I actually define an underapproximation of $\AR_{\Sigma}(\G)$ - cf. 
the algebraic laws. Now, if in this under-approximation I get a cycle, then for sure $\AR_{\Sigma}(\G)$ has a cycle too, hence 
the graph cannot be obtained from an abstract execution in $\aeset(\Sigma)$. What I need to show is that, if this 
underapproximation is acyclic, then it is exact, meaning that it coincides with $\AR_{\Sigma}(\G)$. By Theorem \ref{thm:kernel.2}, 
I can reconstruct an abstract execution $\aexec$ such that  $\aexec \models \Sigma$, and $\graphof(\aexec) = \G$.}

Thus, given a x-specification $\Sigma$, to recover an equivalent g-specification $\Delta$ it 
suffices to characterise the relation $\AR_{\Sigma}(\G)$ for any dependency graph $\G$. 
We now set to determining whether such a relation can be expressed in the Kitten language.

\section{Correspondence Between Execution Kernels and g-Specifications}

\subsection{Inexpressiveness of Kitten?}
In \cite{laws} we identified a class of x-specifications for which it is possible 
to recover an equivalent g-specification using the Kitten language. These specifications 
are called \emph{simple}. They assume no session guarantees, causal consistency, and 
at most one synchronisation guarantee. 
Recall that $\rho_V = \lambda R. (R \setminus \Id)$, and the causality guarantee $(\rho_V, \rho_V)$ 
mandates that abstract executions $(\aexec, \PO, \VIS, \AR)$ satisfy the axiom $\VIS \rcomp \VIS \subseteq \VIS$.
\begin{definition}
A x-specification $\Sigma$ is \emph{simple} if there exists two specification 
functions $\rho, \pi$ such that $\Sigma = (\emptyset, \{(\rho_V, \rho_V)\}, \{(\rho, \pi)\})$. 
\end{definition}

\begin{theorem}[\cite{laws}]
\label{thm:minimisation.simple}
Let $\Sigma$ be a simple x-specification. There exists an expression $E$ in the 
Kitten language such that $\modelof(\Sigma) = \modelof(\{\catinterpr{E}\})$.
\end{theorem}
Unfortunately, the question of whether Theorem \ref{thm:minimisation.simple} 
holds for arbitrary x-specifications has not been addressed anywhere.

In view of Theorem \ref{thm:kernel}, to recover an equivalent g-specification 
from a x-specification $\Sigma$, using the Kitten language, 
it is sufficient to find a (closed) expression $E_{\Sigma}$ of Kitten such that 
\begin{enumerate}
\item for any graph $\G$, $\catinterpr{E_{\Sigma}}(\G) \subseteq \AR_{\Sigma}(\G)$, and 
\item if $\catinterpr{E}_{\Sigma}(\G)$ is irreflexive, then $\AR_{\Sigma}(\G) \subseteq \catinterpr{E_{\Sigma}}(\G)$.
\end{enumerate}

However, in this section we argue that it may not be possible to find the expression $E_{\Sigma}$, for an  
arbitrary consistency model $\Sigma$. 

\section{Recap of the Algebraic Laws for Weak Consistency.}
In \cite{laws} we proposed an algebraic theory, based on Tarski's Calculus 
of Binary Relations, to infer edges of execution kernels, in abstract executions. 
Below we give a summary of some of such laws. 

\begin{proposition}
\label{prop:laws}
Let $\aexec$ be an abstract execution with dependency graph $\G := \graphof(\aexec)$. 
Let also $\Sigma$ be a x-specification for which $\aexec \models \Sigma$ holds. 
Then we have the following: 
\begin{enumerate}
\item\label{prop:laws.deps} $\RF_{\G} \subseteq \VIS_{\Sigma}(\G)$, $\VO_{\G} \subseteq \AR_{\Sigma}(\G)$, and $\AD_{\G} \subseteq \AVIS_{\Sigma}(\G)$, 
\item\label{prop:laws.coaxiomAR} if $(\rho, \pi) \in \Sigma$, then $\big( \pi(\hist_{\G}, \VIS_{\Sigma}(\G)) \rcomp \AVIS_{\Sigma}(\G) 
\rcomp \rho(hist_{\G}, \VIS_{\Sigma}(\G)) \big) \setminus \Id \subseteq \AR_{\Sigma}(\G)$, 
\item\label{prop:laws.coaxiomAVIS} if $(\rho, \pi) \in \Sigma$, then $\big(\AVIS_{\Sigma}(\G) \rcomp \rho(\hist_{\G}, \VIS_{\G}) \rcomp \AR_{\Sigma}(\G) \big)
\rcomp \rho(\hist_{\G}, \T_{\G} \times \T_{\G})^{-1} \subseteq \AVIS_{\Sigma}(\G)$.
\end{enumerate}
\end{proposition}

\begin{proof}
See \cite{laws},Page 10 and Proposition 29.
\end{proof}

Below we devise newer algebraic laws for characterising execution kernels.

\begin{proposition}
Let $\Sigma$ be a x-specification such that $\{(\rho_i, \pi_i)\}_{i=1}^{3} \subseteq_3 \Sigma$.
For an abstract execution $\aexec$ such that $\aexec \models \Sigma$, and two transactions 
$S,T \in \T_{\aexec}$, let $P_{\aexec}$ be the binary relation between transactions in $\T_{\aexec}$ defined by 
\begin{multline*} 
  (T \rightarrow{P_{\aexec}} S) \iff \exists S',S'',T',T''. S \neq T \wedge S' \xrightarrow{\rho_1(\hist_{\aexec}, \VIS_{\aexec})} S \wedge \\
    T \xrightarrow{\pi_1(\hist_{\aexec}, \VIS_{\aexec})} T' \wedge 
    S' \xrightarrow{\rho_2(\hist_{\aexec}, \T_{\aexec} \times \T_{\aexec})} T' \wedge 
    S'' \xrightarrow{\overline{\VIS_{\aexec}^{-1}}} S' \wedge T' \xrightarrow{\AR_{\aexec}} T'' \wedge{}\\
    T'' \xrightarrow{\pi_2(\hist_{\aexec}, \T_{\aexec} \times \T_{\aexec})} S'' \wedge 
    T \xrightarrow{\pi_3(\hist_{\aexec}, \VIS_{\aexec})} S'' \wedge 
    T'' \xrightarrow{\rho_3(\hist_{\aexec}, \VIS_{\aexec})} S. 
\end{multline*}
Then $P_{\aexec} \subseteq \AR_{\aexec}$.
\end{proposition}

\begin{proof}
Let $T,S \in \T_{\aexec}$ be such that $T \xrightarrow{P_{\aexec} S}$; by definition 
$T \neq S$. Also, because $\AR_{\aexec}$ is a total order, either $T \xrightarrow{\AR_{\aexec}} S$ or 
$S \xrightarrow{\AR_{\aexec}} T$. In the former case, there is nothing to prove. 
Suppose then that $S \xrightarrow{\AR_{\aexec}} T$. Because $T \xrightarrow{P_{\aexec}} S$, then there 
exist $T',T'',S',S''$ such that
\begin{itemize}
\item $S' \xrightarrow{\rho_1(\hist_{\aexec}, \VIS_{\aexec})} S \xrightarrow{\AR_{\aexec}} T \xrightarrow{\pi_1(\hist_{\aexec}, \VIS_{\aexec})}$, 
and because $(\rho_1, \pi_1) \in_3 \Sigma$, then $S' \xrightarrow{\VIS_{\aexec}} T'$; because $S' \xrightarrow{\rho_2(\hist_{\aexec}, \T_{\aexec} \times \T_{\aexec})} T'$, 
by definition of specification function it also follows that $S' \xrightarrow{\rho(\hist_{\aexec}, \VIS_{\aexec})} T'$, 
\item $S'' \xrightarrow{\overline{\VIS^{-1}}} S' \xrightarrow{\rho_2(\hist_{\aexec}, \VIS_{\aexec})} T' \xrightarrow{\AR_{\aexec}} T''$, and 
$T'' \xrightarrow{\pi(\hist_{\aexec}, \T \times \T)} S''$. Beacuse $(\pi_2, \rho_2) \in_3 \Sigma$, and because of Proposition \ref{prop:laws}\eqref{prop:laws.coaxiomAVIS}, 
we have that $S'' \xrightarrow{\overline{\VIS_{\aexec}^{-1}}} T''$,
\item $T \xrightarrow{\rho_3(\hist_{\aexec}, \VIS_{\aexec})} S'' \xrightarrow{\overline{\VIS_{\aexec}^{-1}}} T'' \xrightarrow{\pi_3(\hist_{\aexec}, \VIS_{\aexec})} S$, 
and $T \neq S$. It follows from Proposition \ref{prop:laws}\eqref{prop:laws.coaxiomAR} that $T \xrightarrow{\AR_{\aexec}} S$, as we wanted to prove. 
\end{itemize} 
\end{proof}

\begin{theorem}
Let $\Sigma = \{\emptyset, \emptyset, \{(\rho_i, \pi_i)\}_{i=1}^3\}$ for some specification 
functions $\rho_i,\pi_i, i=1,\cdots,3$. 
There exists no expression $E$ of Kitten such that 
$\catinterpr{E}(\G) = P_{\aexec}$ for any abstract execution $\aexec$ such that $\aexec \models(\Sigma)$ 
and $\graphof(\aexec) = \G$.
\end{theorem}

\begin{proof}
Wannabe Theorem.
\end{proof}
%\subsection{Basic x-Specifications of Consistency Models}
%
%Below we re-adapt Theorem \ref{thm:minimisation.simple} to the wider setting 
%considered in this report. In \cite{laws}, only consistency models with causal consistency, 
%and no synchronisation guarantees, were considered. In this restricted setting, any x-specification 
%can be obtained as a combination of multiple (possibly infinite) consistency guarantees. 
%Here we also wish to identify a class of x-specification that can be used as a \emph{base}\footnote{
%Recall that in Algebra, a base of a set $X$ equipped with a binary operation $\sqcup: X \times X \rightarrow X$ 
%is a set $Y \subset X$ such that any element $x \in X$ can be expressed as $\bigsqcup_{i \in I} y_i$, where 
%$y_i \in Y$ for all $i \in I$.} for the space of x-specifications. The natural choice of such a class leads 
%to the following definition: 
%
%\begin{definition}
%A x-specification $\Sigma$ is \emph{basic} if and only if either 
%\begin{itemize}
%\item $\Sigma = (\{\sigma\}, \emptyset, \emptyset)$ for some 
%session function $\sigma$, or 
%\item $\Sigma = (\emptyset, \{(\gamma,\beta)\},\emptyset )$ 
%for some causality guarantee $(\gamma, \beta)$, or 
%\item $\Sigma = (\emptyset, \emptyset, \{(\rho, \pi)\})$ for some 
%synchronisation guarantee $(\rho, \pi)$.
%\end{itemize}
%\end{definition}
%
%Clearly, any x-specification $\Sigma$ can be obtained as the composition of 
%several basic x-specifications, with respect to the composition operator $\sqcup$ 
%introduced previously. For basic consistency models, we have the following result:
%
%\begin{theorem}
%\label{thm:minimisation.basic}
%Let $\Sigma$ be a basic x-specification. There exists an expression $E$ 
%in Kitten such that $\modelof(\Sigma) = \modelof(\{\catinterpr{E}\})$.
%\end{theorem}
%
%In practice, Theorem \ref{thm:minimisation.basic} is consequence of 
%a stronger result, which we prove presently. 
%\begin{theorem}
%Let $\Sigma$ be a basic x-specification. Then 
%\begin{enumerate}
%\item for any abstract execution $\aexec \in \aeset(\Sigma)$ with 
%underlying dependency graph $\G := \graphof(\aexec)$, the relation 
%$\AR_{\Sigma}(\G)$ is irreflexive: $\AR_{\Sigma}(\G) \cap \Id \subseteq \emptyset$, 
%\item for any dependency graph $\G$ 
%\end{enumerate}
%\end{theorem}
%
%\subsection{Inexpressiveness of Kitten}


%\section{Consequences} 
%\[
%\begin{array}{lcl}
%\gspec(\Sigma_1 \sqcup \Sigma_2) &\neq& \gspec(\Sigma_1) \cup \gspec(\Sigma_2)\\
%\gspec(\Sigma_1 \sqcup \Sigma_2) &=& \gspec(\Sigma_1) \palette \gspec(\Sigma_2)
%\end{array}
%\]
%
%\section{Going beyond Kitten: the Palette Language}

%\input{introduction}
%
%\input{absexec}
%
%\input{depgraphs}
%
%\input{algebraiclawsnew}
%
%\input{appsnew}
%
%\input{completenessnewnew}
%
%\input{conclusion}

\bibliographystyle{abbrv}
\bibliography{bibliography2}

\iflong

\appendix

\clearpage

\makeatletter
%\renewcommand{\@oddhead}{\sf \textbf{APPENDIX}}
%\renewcommand{\@evenhead}{\sf \textbf{APPENDIX}}
\renewcommand{\@evenhead}{\large\sffamily\bfseries
                   \llap{\hbox to0.5\oddsidemargin{\ifx\@ArticleNo\@empty\textcolor{blue}{XX}\else\@ArticleNo\fi:\thepage\hss}}APPENDIX\hfil}
\renewcommand{\@oddhead}{\large\sffamily\bfseries APPENDIX\hfil
                  \rlap{\hbox to0.5\oddsidemargin{\hss\ifx\@ArticleNo\@empty\textcolor{blue}{XX}\else\@ArticleNo\fi:\thepage}}}              
\makeatother

\newcommand\Item[1][]{%
  \ifx\relax#1\relax  \item \else \item[#1] \fi
  \abovedisplayskip=0pt\abovedisplayshortskip=0pt~\vspace*{-\baselineskip}}

%\input{anomalies}
%
%\input{generalapproach}
%
%\input{lawsappendix}
%
%\input{completenessapp}

\else 
\fi

\end{document}

