The goal of our operational semantics is to reason about client
programs and verify implementations **in the same framework**.  We
prove robustness for counter and banking ADTs, and we believe our
techniques can be applied to the recently published transactional
examples in [CAV '19 checking robustness against snapshot isolation].
We have verified COPS and Clock-SI protocols. If extra pages are
allowed, we will give more details of the COPS verification, give the
much easier Clock-SI verification, and explore the robustness examples
from CAV'19.

# Reviewer A

Weaknesses

Kv-stores. Kv-stores are important for distributed databases, so was a natural
starting point for us. As the reviewer points out, we are thinking of the
kv-store as the memory and building up ADTs.
Although they need to be represented explicitly, 
however, we do not believe this is a severe limitation.
One of our intended application is that of proving the correctness of
ADTs against a formal specification, one example is given in section
6.1 as robustness of counter ADT implies its correctness.

Related work.

Our model vs Axiomatic models. The model in Cerone's et al, in contrast with us, does not explain
how abstract executions can be obtained in term of incremental
transaction commits.  We believe that our operational semantics is the
natural middle point between dependency graphs and abstract executions. 
as it enables both program analysis and verification of
implementations.


We are aware of the log-based implementations and models in the literature and we
should have compared our work with them.
We think that log-based implementations of kv-stores can be verified in our model.
The work in the push/pull model is orthogonal to ours, in that it
focuses on serialisability. We chose to ground our work on kv-stores.
It should be straightforward to generalise as in the pull/push model,
but it would not add any additional insight.

Robustness. Our robustness proof techniques can be applied to more complicated
transactional applications such as those presented in [CAV '19
checking robustness against snapshot isolation].

Detailed Comments

ET-traces vs operational semantics and Thm 4.4. 
Our operational semantics focuses on the client-observable behaviours,
therefore clients update their views only when they commit transactions.
The ET-traces, in contrast to the semantics, allows arbitrary view shifts;
this is useful for verification of implementations.
In the verification of implementations, we use views to model both the state of clients and distributed sites,
and the arbitrarily view shifts are analogous to synchronisation between distributed sites.
Then the Theorem 4.4 shows the equal expressiveness between the operational semantics and ET-traces. 

Closure.  The definition of closed in the paper is indeed hard to read,
mainly because it mixes the notion of visible transactions with the
one of a set of transactions closed with respect to a relation.  We
will split the definition, hoping to make it more clear.

Strict serilizability. Strict serializability  is the strongest consistency model in
framework that abstracts from aborted transactions, as is ours.  When
aborted transactions are considered, this claim is not valid any more,
ie opacity.

Abort. In our operational semantics, we focus on client-observable
behaviour of atomic transactions, thus abstracting from aborted
transactions.

# Reviewer B

Weaknesses

Self-contained. We believe that the definitions of consistency models in our
framework are self-contained, in particular all the definitions are
developed around kv-stores and views.  Although for some of them (WR,
WW and RW relations), we decide to use the same names as in dependency
graphs to emphasis similarity between the two.


Robustness. The goal of our operational semantics is to reason about client
programs and verify implementations **in the same framework**.
Therefore this robustness result is crucial.
We are aware of [CAV '19 checking robustness against snapshot isolation] after the submission.
We already started investigating the examples presented in
[CAV '19 checking robustness against snapshot isolation] 
and possible implementations for WSI.

Related work.

With respect to [Nagar and Jagannathan], in their semantics on
abstract executions, the execution of transactions requires several
steps of reductions.  In the appendix of our paper, we give an
alternative semantics based on abstract executions that can be seen as
a simplification without losing in expressiveness. We use the semantics 
on abstract executions as an intermediate step to prove the correctness
of our consistency model definitions on our kv-store semantics.

Minor

Typos. We will fix the typos in Fig 5 (g) and (e).

# Reviewer C

Weaknesses

Being able to faithfully model the behaviour transactional
applications under weak consistency models without 
dealing multiple transactions being executed at
the same time is a strength not a weakness.  It significantly
simplifies program reasoning. 

Robustness. The proofs of robustness results are inductive and not axiomatic.
We do not rely on the acyclicity of the dependency graphs among the
assumptions of our theorems, but rather this is a property that we
prove (which is, indeed, equivalent to robustness).  It would not be
difficult to rewrite the proofs to exhibit directly a serialisable
execution trace of the program, without involving any acyclicity
property.  As the reviewer suggests, we already started investigating other examples 
such as examples presented in [CAV '19 checking robustness against snapshot isolation] 
and we are thinking about developing a tool.

Verification of Implementation. Because of operational nature of our
framework, we can also verify implementation. Our proof of COPS
protocol is obtained via a trace refinement from an encoding of the
pseudo-code from the original paper of COPS, which we have improved in
the summer.  For the COPS protocol, although data are not shared but replicated, however
We can model the collections of all COPS replica states as our centralised kv-store
by treating the replicated data as the same copy. We then model the state of single replica
as a view on the kv-store. The proof of Clock-SI is simpler and we will include it
in the final version.          

Minor.

We include non-determinism for building up a simple while-language.

# Reviewer D

Weaknesses

Our model is significantly different from dependency graphs and
abstract executions as explained in our response to the Reviewer A.

Progress. Concerning progress properties, it is relatively easy to prove
that: none of the consistency models that we consider hinders progress
if a program does not get stuck under serilizability, then it will not
get stuck under any of the considered consistency models.

Precision and presentation. As the Reviewer C pointed out, we tried to get the right balance
between precise and readable definitions. We will take the suggestion
into account and improve in the final version.

Minor.

Kv-store should only contain finite many transactions.

We will use different names in the definition 4.1 in the final version.

The SER* is a typos and should be removed.

The comment about theorem 4.4 refers to our response to Reviewer A.
The proof involves in swapping operations in ET-trace.

Definition 5.2.1 It should be finite graphs.
