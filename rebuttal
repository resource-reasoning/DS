Our operational semantics aims to reason about client programs and verify implementations in the same framework.
We prove robustness for counter and banking ADTs, 
and we believe that our robustness proof technique can be applied to more complicated transactional applications
such as examples in [CAV '19 checking robustness against snapshot isolation].
We have verified COPS and Clock-SI protocols.
In the current version of the paper, we present the verification for COPS protocol, which is the more difficult one.
We will give more details about COPS and Clock-SI if extra pages are allowed.

# Reviewer A

(1) As pointed out by the review, ADTs can be implemented on the low level kv-store,
although they need to be represented explicitly, however, we do not believe this is a severe limitation.
One of our intended application is that of proving the correctness of ADTs against a formal specification,
one example is given in section 6.1 as robustness of counter ADT implies its correctness.

(2) We are aware of the log-based models in the literature and we should have compared our work with them.
For example, the push/pull model is orthogonal to ours.
In contrast with us, the push/pull model only focuses on serialisiblity,
on the other hand it does not restrict to kv-stores.
It would be interesting to see we could generalise our model beyond key-value stores.

(3) We believe that our robustness proof technique can be applied to more complicated transactional applications.
We already started investigating the examples presented in [CAV '19 checking robustness against snapshot isolation].

(4) The model in Cerone's et al, in contrast with us, 
does not explain how abstract executions can be obtained in term of incremental transaction commits.
We believe that our operational semantics is the natural middle point between dependency graphs and abstract executions 
as it enables both program analysis and verification of implementations.

(5) The Theorem 4.4 shows the equal expressiveness between our operational semantics and ET-traces.
The ET-traces are especially useful for verification of implementations given the arbitrary view shifts.

(6) The definition of closed in the paper is indeed hard to read, mainly because it mixes the 
notion of visible transactions with the one of a set of transactions closed with respect to a relation. 
We will split the definition, hoping to make it more clear.

(7) Strict serilizability is the strongest consistency model in framework that abstracts from aborted transactions, as is ours.
When aborted transactions are considered, this claim is not valid any more, ie opacity.

(8) In our operational semantics, we abstract from aborted transactions 
but focus on client-observable behaviour of atomic transactions.

# Reviewer B

(9) We believe that the definitions of consistency models in our framework are self-contained, 
in particular all the definitions are developed around kv-stores and views.
Although for some of them (WR, WW and RW relations), we decide to use the same names as in dependency graphs
to emphasis similarity between the two.

(10) We will fix the typos in Fig 5 (g) and (e).

(11) Our goal is provide an interleaving semantics that can be used to reason about client programs and verify implementation in the same framework. 
We already started investigating the examples presented in [CAV '19 checking robustness against snapshot isolation] and more implementations.

(12) With respect to [Nagar and Jagannathan], in their semantics on abstract executions,
the execution of transactions requires several steps of reductions.
In the appendix of our paper, we give an alternative semantics 
based on abstract executions that can be seen as a simplification without losing in expressiveness.

# Reviewer C

(13) Being able to faithfully model the behaviour transactional applications under weak consistency models the comment about theorem 4.4 refers to 
without dealing multiple transactions being executed at the same time is a strength not a weakness.
It significantly simplifies program reasoning.
Because of operational nature of our framework, we can also verify implementation.
Our proof of COPS protocol is obtained via a trace refinement from an encoding of the pseudo-code from the original paper of COPS,
which we have improved in the summer.
The proof of Clock-SI is simpler and we will include it in the final version.

(14) The proofs of robustness results are inductive and not axiomatic.
We do not rely on the acyclicity of the dependency graphs among the assumptions of our theorems, 
but rather this is a property that we prove (which is, indeed, equivalent to robustness). 
It would not be difficult to rewrite the proofs to exhibit directly a serialisable execution trace of the program,
without involving any acyclicity property.

(15) As the reviewer suggests, 
we already started investigating the examples presented in [CAV '19 checking robustness against snapshot isolation]
and we are thinking about developing a tool.

# Reviewer D

(16) Our model is significantly different from dependency graphs and abstract executions as explained in (4).

(17) Concerning progress properties, it is relatively easy to prove that:
none of the consistency models that we consider hinders progress if a program does not get stuck under serilizability,
then it will not get stuck under any of the considered consistency models.

(18) As review C pointed out, we tried to get the right balance between precise and readable definitions.
We will take the suggestion into account and improve in the final version.

(19) We will clarify the definition 4.1 in the final version.

(20) The SER* is a typos and should be removed.

(21) the comment about theorem 4.4 refers to (5).
The proof involves in swapping operations in ET-trace.
