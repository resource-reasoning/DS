The goal of our operational semantics is to reason about client
programs and verify implementations **in the same framework**.  We
prove robustness for counter and banking ADTs, and we believe our
techniques can be applied to the recently published transactional
examples in [CAV '19 checking robustness against snapshot isolation].
We have verified COPS and Clock-SI protocols. If extra pages are
allowed, we will give more details of the COPS verification, give the
much easier Clock-SI verification, and explore the robustness examples
from CAV'19.

# Reviewer A

Weaknesses

Kv-stores. …..not good…..Kv-stores are important for distributed databases, so was a natural
starting point for us. As the reviewer points out, we are thinking of the
kv-store as the memory and building …..As pointed out by the review, ADTs can be implemented
on the low level kv-store, although they need to be represented
explicitly, however, we do not believe this is a severe limitation.
One of our intended application is that of proving the correctness of
ADTs against a formal specification, one example is given in section
6.1 as robustness of counter ADT implies its correctness.

Related work.

The model in Cerone's et al, in contrast with us, does not explain
how abstract executions can be obtained in term of incremental
transaction commits.  We believe that our operational semantics is the
natural middle point between dependency graphs and abstract executions. 
as it enables both program analysis and verification of
implementations.


We are aware of the log-based models in the literature and we
should have compared our work with them.

....Balakrishen, Mahesh......logs, implementations,....

The work in the push/pull model is orthogonal to ours, in that it
focuses on serialisability. We chose to ground our work on kv-stores.
It should be straightforward to generalise as in the pull/push model,
but it would not add any additional insight


Robustness. Our robustness proof techniques can be applied to more complicated
transactional applications such as those presented in [CAV '19
checking robustness against snapshot isolation].

Detailed Comments

ET-traces v operational  semantics. give a good answer here then you can refer to it later.
also mentioned in Q3 so I don't know why you have left it out. Line 516: .....

Thm 4.4. The Theorem 4.4 shows the equal expressiveness between our
operational semantics and ET-traces.  The ET-traces are especially
useful for verification of implementations given the arbitrary view
shifts.

Closure.  The definition of closed in the paper is indeed hard to read,
mainly because it mixes the notion of visible transactions with the
one of a set of transactions closed with respect to a relation.  We
will split the definition, hoping to make it more clear.

Strict serilizability. Strict serializability  is the strongest consistency model in
framework that abstracts from aborted transactions, as is ours.  When
aborted transactions are considered, this claim is not valid any more,
ie opacity.

Abort. In our operational semantics, we focus on client-observable
behaviour of atomic transactions, thus abstracting from aborted
transactions.

# Reviewer B

(9) We believe that the definitions of consistency models in our
framework are self-contained, in particular all the definitions are
developed around kv-stores and views.  Although for some of them (WR,
WW and RW relations), we decide to use the same names as in dependency
graphs to emphasis similarity between the two.

(10) We will fix the typos in Fig 5 (g) and (e).

(11) Our goal is provide an interleaving semantics that can be used to
reason about client programs and verify implementation in the same
framework.  We already started investigating the examples presented in
[CAV '19 checking robustness against snapshot isolation] and more
implementations.

(12) With respect to [Nagar and Jagannathan], in their semantics on
abstract executions, the execution of transactions requires several
steps of reductions.  In the appendix of our paper, we give an
alternative semantics based on abstract executions that can be seen as
a simplification without losing in expressiveness.

# Reviewer C

(13) Being able to faithfully model the behaviour transactional
applications under weak consistency models the comment about theorem
4.4 refers to without dealing multiple transactions being executed at
the same time is a strength not a weakness.  It significantly
simplifies program reasoning.  Because of operational nature of our
framework, we can also verify implementation.  Our proof of COPS
protocol is obtained via a trace refinement from an encoding of the
pseudo-code from the original paper of COPS, which we have improved in
the summer.  The proof of Clock-SI is simpler and we will include it
in the final version.

(14) The proofs of robustness results are inductive and not axiomatic.
We do not rely on the acyclicity of the dependency graphs among the
assumptions of our theorems, but rather this is a property that we
prove (which is, indeed, equivalent to robustness).  It would not be
difficult to rewrite the proofs to exhibit directly a serialisable
execution trace of the program, without involving any acyclicity
property.

(15) As the reviewer suggests, we already started investigating the
examples presented in [CAV '19 checking robustness against snapshot
isolation] and we are thinking about developing a tool.

# Reviewer D

(16) Our model is significantly different from dependency graphs and
abstract executions as explained in (4).

(17) Concerning progress properties, it is relatively easy to prove
that: none of the consistency models that we consider hinders progress
if a program does not get stuck under serilizability, then it will not
get stuck under any of the considered consistency models.

(18) As review C pointed out, we tried to get the right balance
between precise and readable definitions.  We will take the suggestion
into account and improve in the final version.

(19) We will clarify the definition 4.1 in the final version.

(20) The SER* is a typos and should be removed.

(21) the comment about theorem 4.4 refers to (5).
The proof involves in swapping operations in ET-trace.
