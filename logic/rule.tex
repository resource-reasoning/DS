\subsection{Rules for Local}

The proof rules (\cref{fig:rule-trans}) are standard except \rl{TRLookup} and \rl{TRMutate}.
The \rl{TRLookup} rule adds read fingerprint only if there is no write fingerprint.
This is because once an address has been re-written, the rest reads are local.
The\rl{TRMutate} rule adds write fingerprint if there no write fingerprint and keeps the last written value.


\begin{figure}[!t]
\sx{Font for E}
\hrule
\begin{mathpar}
    \inferrule[\rl{TRLookup}]{%
        \var \notin \func{fv}{\lexpr}  
        \\ \lpre \toFP{\otR(\expr, \lexpr)} \lpost
    }{%
        \tripleL{ \lpre }{ \plookup{\var}{\expr} }{\var \dot= \lexpr \sep \lpost\sub{\var}{\lexpr} }
    }
    \and
    \inferrule[\rl{TRMutate}]{
        \lpre \toFP{\otW(\expr_{1},\expr_{2})} \lpost
    }{%
        \tripleL{ \lpre }{ \pmutate{\expr_1}{\expr_2} }{ \lpost } 
    }
    \and
    \inferrule[\rl{TRAss}]{
        \var \notin \func{fv}{\lexpr}
    }{%
        \tripleL{\var \dot= \lexpr }{ \pass{\var}{\expr} }{\var \dot= \expr\sub{\var}{\lexpr} }
    }
    \and
    \inferrule[\rl{TRAssume}]{ }{%
        \tripleL{ \expr \dot\neq 0 }{ \passume{\expr} }{ \expr \dot\neq 0 } 
    }
    \and
    \inferrule[\rl{TRChoice}]{%
        \tripleL{ \lpre }{ \trans_{1} }{ \lpost } 
        \\ \tripleL{ \lpre }{ \trans_{2} }{ \lpost } 
    }{%
        \tripleL{ \lpre }{ \trans_{1} \pchoice \trans_{2} }{ \lpost }
    }
    \and
    \inferrule[\rl{TRSeq}]{%
        \tripleL{ \lpre }{ \trans_{1} }{ \lframe }
        \\ \tripleL{ \lframe }{ \trans_{2} }{ \lpost }
    }{%
        \tripleL{ \lpre }{ \trans_{1} \pseq \trans_{2} }{ \lpost }
    }
    \and
    \inferrule[\rl{TRIter}]{%
        \tripleL{ \lpre }{ \trans }{ \lpre } 
    }{%
        \tripleL{ \lpre }{ \trans\prepeat }{ \lpre }
    }
    \and
    \inferrule[\rl{TRFrame}]{%
        \tripleL{ \lpre }{ \trans }{ \lpost } 
         %&& \func{fv}{\lpre} \cap \func{fv}{\lframe} = \emptyset
         %&& \func{fv}{\lpost} \cap \func{fv}{\lframe} = \emptyset
    }{%
        \tripleL{ \lpre \sep \lframe }{ \trans }{ \lpost \sep \lframe }
    }
    \and
    \inferrule[\rl{TRSkip}]{ }{%
        \tripleL{\assemp }{ \pskip }{\assemp }
    }
\end{mathpar}


\hrule
%\sx{The% font is a bit overwhelming}
\[
\begin{array}{@{} c c @{}}
\begin{rclarray}
    \lexpr \fpI \lexpr' & \toFP{\otR(\lexpr,\lexpr')} & \lexpr \fpR \lexpr' \\
    \lexpr \fpR \lexpr' & \toFP{\otR(\lexpr,\lexpr')} & \lexpr \fpR \lexpr' \\
    \lexpr \fpW \lexpr' & \toFP{\otR(\lexpr,\lexpr')} & \lexpr \fpW \lexpr' \\
    \lexpr \fpRW (\lexpr'', \lexpr') & \toFP{\otR(\lexpr,\lexpr')} & \lexpr \fpRW (\lexpr'', \lexpr') \\
\end{rclarray}
&
\begin{rclarray}
    \lexpr \fpI \lexpr' & \toFP{\otW(\lexpr,\lexpr'')} & \lexpr \fpW \lexpr'' \\
    \lexpr \fpR \lexpr' & \toFP{\otW(\lexpr,\lexpr'')} & \lexpr \fpRW (\lexpr',\lexpr'') \\
    \lexpr \fpW \lexpr' & \toFP{\otW(\lexpr,\lexpr'')} & \lexpr \fpW \lexpr'' \\
    \lexpr \fpRW (\lexpr'', \lexpr') & \toFP{\otW(\lexpr,\lexpr''')} & \lexpr \fpRW (\lexpr'', \lexpr''') \\
\end{rclarray}
\end{array}
\]
\hrule
\caption{The rules for transactions}
\label{fig:rule-trans}
 \end{figure}

\subsubsection{Rely and Guarantee}

The \emph{rely} and \emph{guarantee} describes the world transformation for the environment and for the current client (\cref{def:rely-guarantee}).
To recall, a world includes local capabilities and a shared state, and a shared state is a client's view for the key-value store.
The \emph{rely} \( \Rely \) is a set of pairs on worlds, describing how the environment can change the state of the key-value store.
Given the local capabilities \( \ca_l \), the environment might own any capabilities \( \ca_e\) that is compatible, \ie \( (\ca_l \composeC \ca_e)\isdef \).
Therefore, the environment can perform actions associated with the their capabilities \( \ca_e \) with their own view \( \vi_e \) to update the key-value store and shared capabilities.
For technical reasons, even though the environment cannot change the view of the current client \( \vi_r\), but it is allowed to arbitrarily shift to the later versions due to the fact that for certain execution tests, the old view might be valid under the new key-value store.

The \emph{guarantee} \( \Guar \) describes the allowed actions for the current client.
The current client can perform actions associated with the local capabilities \( \ca_l \) to update the shared state and the local capabilities.
Yet it should ensure no resource created or deleted by requiring the \emph{orthogonal} of local capabilities and shared capabilities together remains unchanged.
The orthogonal of local capabilities \( \ca \) is a set of capabilities that are compatible with the local capabilities \( \ca \).
This constraint disallow any creation and deletion for capabilities, but it allows to update capabilities.
Note that in the rely and guarantee, it is allowed to update several regions, but each region can be updated at most once.
\begin{definition}[Rely and guarantee]
\label{def:rely-guarantee}
Given the set of worlds $\World$ (\cref{def:world}), the \emph{update rely} relation, $\relyU \subseteq \World \times \World$, is defined as follows:
\sx{In case I get confused again, it is world to world so the shared and local capabilities should always make sense.}
\[	
    \begin{rclarray}
	\relyU & \eqdef &
	\Setcon{
		((\ca_l,\gs), (\ca_l, \gs'))	
	}{
        \exsts{\ca_e}
        (\ca_e \composeC \ca_l) \isdef
        \land \fora{\rid}
        \gs(\rid) = \gs'(\rid) \lor 
        \exsts{\kap, \hh, \hh', \vi_\rid, \vi_{\rid}', \vi_{e}, \vi_{e}', \ca_\rid, \ca_{\rid}', \intf}   \\
        \quad \gs(\rid) = (\hh, \vi_\rid, \ca_\rid, \intf)
        \land \gs'(\rid) = (\hh', \vi_{\rid}', \ca_{\rid}',\intf) \\
        \quad {} \land \kap \sqsubseteq \ca_{e}(\rid) 
        \land ( (\hh, \vi_e, \ca_e), (\hh', \vi_{e}', \ca_{e}') )  \in \intf(\kap)
        \land \vi_{\rid}' \geq \vi_\rid
	} \\
    \end{rclarray}
\]
The \emph{view shift rely} relation $\relyV \subseteq \World \times \World$, is defined as follows:
\[
    \begin{rclarray}
	\relyV & \eqdef &
	\Setcon{
		((\ca_l,\gs), (\ca_l, \gs'))	
	}{
        \exsts{\ca_e}
        (\ca_e \composeC \ca_l) \isdef
        \land \fora{\rid}
        \gs(\rid) = \gs'(\rid) \lor 
        \exsts{\hh, \vi, \vi'\ca, \ca, \intf}   \\
        \quad \gs(\rid) = (\hh, \vi, \ca, \intf)
        \land \gs'(\rid) = (\hh, \vi', \ca, \intf) 
	} \\
    \end{rclarray}
\]
The \emph{rely} relation is transitive closure of updates and view shift: \( \Rely = (\relyU \cup \relyV)^{*} \).
The \emph{guarantee} relation, $\Guar: \World \times \World$, is defined as follows:
\[	
    \begin{rclarray}
	\Guar & \eqdef &
	\Setcon{
		((\ca_l,\gs), (\ca_{l}', \gs'))	
	}{
        \fora{\rid}
        \gs(\rid) = \gs'(\rid) \lor {}
        \exsts{\kap, \hh, \hh', \vi_\rid, \vi_{\rid}', \ca_\rid, \ca_{\rid}', \intf}   \\
        \quad \gs(\rid) = (\hh, \vi_\rid, \ca_\rid,\intf)
        \land \gs'(\rid) = (\hh', \vi_{\rid}', \ca_{\rid}',\intf) 
        \land \kap \sqsubseteq \ca_{l}(\rid)  \\
        \quad {} \land ( (\hh, \vi_\rid, \ca_\rid), (\hh', \vi_{\rid}', \ca_{\rid}') )  \in \intf(\kap)
        \land (\ca_{l} \composeC \ca_\rid)^{\perp} = (\ca_{l}' \composeC \ca_{\rid}')^{\perp}
	} \\
    \end{rclarray}
\]
where for any element \( m \) from its domain \( \sort{M} \), the  \emph{orthogonal} is defined as:
\[
\begin{rclarray}
m^{\perp} & \defeq & \Setcon{m'}{(m \compose{} m')\isdef \land m' \in \sort{M}} 
\end{rclarray}
\]
\end{definition}

The stabilisation says assertions remain true against the environment.
Formally a set of worlds \( \setworld \) is stable under certain execution tests \( \et \) if the set is closed under rely relation under the side conditions: (a) the key-value store transfer is allowed by the execution tests \( (\mkvs, \mkvs') \in \et \);
and (b) the new view under the new key-value store is able to progress.
The first condition says there is at least one view from the environment that can trigger the transformation on the key-value store, and it is allowed by the execution tests.
The second condition is more subtle, as it allows to also update the view to a new view \( \vi' \) so that for all the possible transactions with the fingerprints \( \opset \), if they can execute under the old view, it should be able to execute under the new view.

\begin{definition}[Stable]
\label{def:stable}
A set of worlds $\setworld \subseteq \World$ is \emph{stable}, written $\stable{\setworld, \como}$, if and only if it is closed under the rely relation: 
\[
    \begin{rclarray}
        \stable{\setworld, \como} & \eqdef & 
        \begin{array}[t]{@{}l}
            \fora{\w, \w'} 
            \w \in \setworld 
            \land (\w, \w') \in \Rely  
            \land \exsts{\hh, \hh', \vi, \opset} \\
            \quad (\hh, \vi) = \eraseW{\w}
            \land (\hh', \vi') = \eraseW{\w'} 
            \land (\hh, \hh') \in \como 
            \land \pred{progress}{\w, \et} \\
            \qqquad \implies \w' \in \setworld
        \end{array} \\
    \end{rclarray}
\]
A update history heap update is allowed by consistency model, \ie \( (\hh, \hh') \in \como \), iff there exist some view \( \vi \) and operation set \( \opset \) allowed by the consistency model and the history is updated to \( \hh' \) via them:
\[
    \begin{rclarray}
        (\hh, \hh') \in \como & \eqdef & 
        \begin{array}[t]{@{}l}
            \hh = \hh' \lor 
            \exsts{ \vi, \vi', \opset, \txid, \cl}  \\
            \quad (\hh, \vi) \csat \opset : \vi' 
            \land \txid \in \fresh{\hh, \cl} 
            \land \hh'  = \updM{\hh,\vi, \txid, \opset}
        \end{array}
    \end{rclarray}
\]
A world is able to progress under an execution test \( \et \), iff it is able to execute the empty fingerprint:
\[
    \begin{rclarray}
        \pred{progress}{\w, \et} & \defeq & \exsts{\vi} \eraseW{\w} \csat \unitO :  \vi
    \end{rclarray}
\]
\end{definition}


\subsection{Rules for Global}

The \rl{PRCommit} rule lifts the local effect of transaction \( \trans \) to global level by first converting global state to (local) observable state and then propagating the local fingerprint to the global state.
%The \( \predn{down} \) predicate asserts that the local predicate \( \lpre \) is a over-approximation of the valid observation that is given by the interference.
%The \( \predn{up} \) predicate says the post-condition \( \gpost \) is the result by lifting the local fingerprints \( \fp \) to pre-condition \( \gpre \).


\begin{figure}[t!]
\hrule\vspace{5pt}

\begin{mathpar}
    \inferrule[\rl{PRCommit}]{%
        \tripleL{\lpre}{\trans}{\lpost} 
        \\ \repartition{\gpre}{\gpost}{\lpre}{\lpost}
        \\\\ \stable{\gpre, \como} 
        \\ \stable{\gpost, \como} 
    }{%
        \tripleG{\gpre}{ \ptrans{\trans} }{\gpost}
    }
    \and
    \inferrule[\rl{PRPar}]{%
        \tripleG{ \gpre_{1} }{ \cmd_{1} }{ \gpost_{1} }
        \\ \tripleG{ \gpre_{2} }{ \cmd_{2} }{ \gpost_{2} } 
        \\\\ \stable{\gpre_{1}, \como} 
        \\ \stable{\gpre_{2}, \como} 
    }{%
        \tripleG{ \gpre_{1} \sep \gpre_{2} }{ \cmd_{1} \ppar \cmd_{2} }{ \gpost_{1} \sep \gpost_{2} }
    }
    \and
    \inferrule[\rl{PRAss}]{%
        \thvar \notin \func{fv}{\lexpr} 
    }{%
        \tripleG{\thvar \dot= \lexpr }{ \pass{\thvar}{\expr} }{\thvar \dot= \expr\sub{\thvar}{\lexpr} }
    }
    \and
    \inferrule[\rl{PRAssume}]{ }{%
        \tripleG{ \expr \dot\neq 0 }{ \passume{\expr} }{ \expr \dot\neq 0 } 
    }
    \and
    \inferrule[\rl{PRChoice}]{%
        \tripleG{ \gpre }{ \cmd_{1} }{ \gpost } 
        \\ \tripleG{ \gpre }{ \cmd_{2} }{ \gpost } 
    }{%
        \tripleG{ \gpre }{ \cmd_{1} \pchoice \cmd_{2} }{ \gpost }
    }
    \and
    \inferrule[\rl{PRSeq}]{%
        \tripleG{ \gpre }{ \cmd_{1} }{ \gframe }
        \\ \tripleG{ \gframe }{ \cmd_{2} }{ \gpost }
    }{%
        \tripleG{ \gpre }{ \cmd_{1} \pseq \cmd_{2} }{ \gpost }
    }
    \and
    \inferrule[\rl{PRIter}]{%
        \tripleG{ \gpre }{ \cmd }{ \gpre } 
    }{%
        \tripleG{ \gpre }{ \cmd\prepeat }{ \gpre }
    }
    \and
    \inferrule[\rl{PRFrame}]{%
        \tripleG{ \gpre }{ \cmd }{ \gpost } 
        \\ \stable{\gframe, \como}
        \\ \func{fv}{\gframe} \cap \func{modify}{\cmd} = \emptyset 
    }{%
        \tripleG{ \gpre \sep \gframe }{ \cmd }{ \gpost \sep \gframe }
    }
\end{mathpar}


\hrule\vspace{5pt}
\[
\begin{rclarray}
    \repartition{\gpre}{\gpost}{\lpre}{\lpost} & \defeq & 
    \begin{array}[t]{@{}l@{}}
        \fora{ \w, \lenv, \stk } 
        \w \in \evalW{\gpre} 
        \implies 
        (\getSN{\eraseW{\w}}, \unitO) \in \evalLS{\lpre}  \\
        \quad {} \land \fora{\stk', \txid, \opset, \w', \cl} 
        \txid \in \fresh{\eraseW{\w}\projection{1}, \cl} 
        \land (\stub, \opset) \in \evalF[\lenv, \stk']{\lpost} \\
        \qquad {} \land \eraseW{\w'}\projection{1} = \updM{\eraseW{\w}, \txid, \opset} 
        \land \eraseW{\w}\projection{2} \leq \eraseW{\w'}\projection{2} \\
        \qquad {} \land (\w, \w') \in \Guar  
        \land \eraseW{\w} \csat \opset : \eraseW{\w'}\projection{2}
        \implies \w' \in \evalW[\lenv, \stk']{\gpost}
    \end{array} 
\end{rclarray}                          
\]

\hrule\vspace{5pt}
\caption{The rules for programs}
\label{fig:rule-prog}
\end{figure}

%\azalea{
    %\sx{How to deal with the stack here? As the stack for P and Q are different, just for all quantify two stacks??}
%The quantification seems wrong. Especially, the $\extopset$ needs to be for all quantified, $\h$ needs to be there exist quantified.
%\[
     %\repartition{\gpre}{\gpost}{\lpre}{\lpost} \defeq 
     %\begin{array}[t]{@{}l@{}}
		 %\fora{\w, \hh, \vi, \lenv, \stk, \txid } 
            %\w \in \evalW{\gpre} 
            %\land (\hh, \cu) \in \eraseW{\w}
            %\Rightarrow\\
            %\quad \exsts{\h}
            %\begin{array}[t]{@{} l @{}}
			%\h = \getSN{\hh, \cu}  
                %\land (\h, \unitO) \in \evalLS{\lpre} \\
                %\land\, \fora{\extopset \in \evalF{\lpost}} 
                    %\exsts{\w', \hh', \vi'} \\
                        %\quad \hh' = \updM{\hh, \vi, \txid, \extopset} 
                       %\land \cu' = \updV{\hh, \vi, \extopset} 
                       %\land (\hh',\vi') \in \eraseW{\w'} \\
                        %\quad \land (\w, \w') \in \Guar  
                        %\land (\w, \w') \in \como
                        %\land \w' \in \evalW{\gpost}			
		%\end{array}	
%%		\right)			        	
    %\end{array} 
%\]
%}

%The \( \HHupdate \) and \( \Vupdate \) in the repartition can be replaced by syntactic rules.

%\begin{figure}
%\hrule\vspace{5pt}

%\[
   %\infer[\rl{FInit}]{%
       %\tripleF{ \lexpr \pt \lexpr }{ \lexpr \fpI \lexpr }{ \lexpr \pt \lexpr }
   %}{}
%\]

%\[
   %\infer[\rl{FRead}]{%
       %\tripleF{ \lexpr \pt \lexpr }{ \lexpr \fpR \lexpr }{ \lexpr \pt \lexpr }
   %}{}
%\]

%\[
   %\infer[\rl{FWrite}]{%
       %\tripleF{ \lexpr \pt \lexpr  }{  \lexpr \fpW \lexpr' }{ \lexpr \pt \lexpr' }
   %}{}
%\]

%\[
   %\infer[\rl{FReWrt}]{%
       %\tripleF{ \lexpr \pt \lexpr  }{  \lexpr \fpRW (\lexpr,\lexpr') }{ \lexpr \pt \lexpr' }
   %}{}
%\]

%\[
   %\infer[\rl{FFrame}]{%
       %\tripleF{ \bar{\lpre}_{1} \sep \bar{\lpre}_{2}  }{  \bar{\fp}_{1} \sep \bar{\fp}_{2} }{ \bar{\lpost}_{1} \sep \bar{\lpost}_{2} }
   %}{
       %\tripleF{ \bar{\lpre}_{1} }{ \bar{\fp}_{1} }{ \bar{\lpost}_{1} }
       %&& \tripleF{ \bar{\lpre}_{2}  }{ \bar{\fp}_{2} }{ \bar{\lpost}_{2} }
    %}
%\]


%\hrule\vspace{5pt}
%\caption{Syntactic rule for \( \HHupdate \) and \( \Vupdate \) functions}
%\label{fig:rule-prog}
%\end{figure}

