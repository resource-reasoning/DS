\subsection{Rules for Local}

The proof rules (\cref{fig:rule-trans}) are standard except \rl{TRLookup} and \rl{TRMutate}.
The \rl{TRLookup} rule adds read fingerprint only if there is no write fingerprint.
This is because once an address has been re-written, the rest reads are local.
The\rl{TRMutate} rule adds write fingerprint if there no write fingerprint and keeps the last written value.


\begin{figure}[!t]
\sx{Font for E}
\hrule
\begin{mathpar}
    \inferrule[\rl{TRLookup}]{%
        \var \notin \func{fv}{\lexpr}  
        \\ \lpre \toFP{\otR(\expr, \lexpr)} \lpost
    }{%
        \tripleL{ \lpre }{ \plookup{\var}{\expr} }{\var \dot= \lexpr \sep \lpost\sub{\var}{\lexpr} }
    }
    \and
    \inferrule[\rl{TRMutate}]{
        \lpre \toFP{\otW(\expr_{1},\expr_{2})} \lpost
    }{%
        \tripleL{ \lpre }{ \pmutate{\expr_1}{\expr_2} }{ \lpost } 
    }
    \and
    \inferrule[\rl{TRAss}]{
        \var \notin \func{fv}{\lexpr}
    }{%
        \tripleL{\var \dot= \lexpr }{ \pass{\var}{\expr} }{\var \dot= \expr\sub{\var}{\lexpr} }
    }
    \and
    \inferrule[\rl{TRAssume}]{ }{%
        \tripleL{ \expr \dot\neq 0 }{ \passume{\expr} }{ \expr \dot\neq 0 } 
    }
    \and
    \inferrule[\rl{TRChoice}]{%
        \tripleL{ \lpre }{ \trans_{1} }{ \lpost } 
        \\ \tripleL{ \lpre }{ \trans_{2} }{ \lpost } 
    }{%
        \tripleL{ \lpre }{ \trans_{1} \pchoice \trans_{2} }{ \lpost }
    }
    \and
    \inferrule[\rl{TRSeq}]{%
        \tripleL{ \lpre }{ \trans_{1} }{ \lframe }
        \\ \tripleL{ \lframe }{ \trans_{2} }{ \lpost }
    }{%
        \tripleL{ \lpre }{ \trans_{1} \pseq \trans_{2} }{ \lpost }
    }
    \and
    \inferrule[\rl{TRIter}]{%
        \tripleL{ \lpre }{ \trans }{ \lpre } 
    }{%
        \tripleL{ \lpre }{ \trans\prepeat }{ \lpre }
    }
    \and
    \inferrule[\rl{TRFrame}]{%
        \tripleL{ \lpre }{ \trans }{ \lpost } 
         %&& \func{fv}{\lpre} \cap \func{fv}{\lframe} = \emptyset
         %&& \func{fv}{\lpost} \cap \func{fv}{\lframe} = \emptyset
    }{%
        \tripleL{ \lpre \sep \lframe }{ \trans }{ \lpost \sep \lframe }
    }
    \and
    \inferrule[\rl{TRSkip}]{ }{%
        \tripleL{\assemp }{ \pskip }{\assemp }
    }
\end{mathpar}


\hrule
%\sx{The% font is a bit overwhelming}
\[
\begin{array}{@{} c c @{}}
\begin{rclarray}
    \lexpr \fpI \lexpr' & \toFP{\otR(\lexpr,\lexpr')} & \lexpr \fpR \lexpr' \\
    \lexpr \fpR \lexpr' & \toFP{\otR(\lexpr,\lexpr')} & \lexpr \fpR \lexpr' \\
    \lexpr \fpW \lexpr' & \toFP{\otR(\lexpr,\lexpr')} & \lexpr \fpW \lexpr' \\
    \lexpr \fpRW (\lexpr'', \lexpr') & \toFP{\otR(\lexpr,\lexpr')} & \lexpr \fpRW (\lexpr'', \lexpr') \\
\end{rclarray}
&
\begin{rclarray}
    \lexpr \fpI \lexpr' & \toFP{\otW(\lexpr,\lexpr'')} & \lexpr \fpW \lexpr'' \\
    \lexpr \fpR \lexpr' & \toFP{\otW(\lexpr,\lexpr'')} & \lexpr \fpRW (\lexpr',\lexpr'') \\
    \lexpr \fpW \lexpr' & \toFP{\otW(\lexpr,\lexpr'')} & \lexpr \fpW \lexpr'' \\
    \lexpr \fpRW (\lexpr'', \lexpr') & \toFP{\otW(\lexpr,\lexpr''')} & \lexpr \fpRW (\lexpr'', \lexpr''') \\
\end{rclarray}
\end{array}
\]
\hrule
\caption{The rules for transactions}
\label{fig:rule-trans}
 \end{figure}

\subsubsection{Rely and Guarantee}

The \emph{rely} and \emph{guarantee} describes the world transformation for the environment and for the current client (\cref{def:rely-guarantee}).
To recall, a world includes local capabilities and a shared state, and a shared state is a client's view for the key-value store.
The \emph{rely} \( \Rely \) is a set of pairs on worlds, describing how the environment can change the state of the key-value store.
Given the local capabilities \( \ca_l \), the environment might own any capabilities \( \ca_e\) that is compatible, \ie \( (\ca_l \composeC \ca_e)\isdef \).
Therefore, the environment can perform actions associated with the their capabilities \( \ca_e \) with their own view \( \vi_e \) to update the key-value store and shared capabilities.
For technical reasons, even though the environment cannot change the view of the current client \( \vi_r\), but it is allowed to arbitrarily shift to the later versions due to the fact that for certain execution tests, the old view might be valid under the new key-value store.

The \emph{guarantee} \( \Guar \) describes the allowed actions for the current client.
The current client can perform actions associated with the local capabilities \( \ca_l \) to update the shared state and the local capabilities.
Yet it should ensure no resource created or deleted by requiring the \emph{orthogonal} of local capabilities and shared capabilities together remains unchanged.
The orthogonal of capabilities \( \ca \) is a set of capabilities that is compatible with the capabilities \( \ca \).
This constraint disallow any creation and deletion for capabilities, but it allows to update capabilities.

We allow a transaction to update several regions together, but each region can be updated at most once.
Given that, the guarantee is a set of pairs of worlds that are allowed by the local capabilities.
Each pairs assertions how a world can evolve.
The rely is a set of pairs of worlds asserting how the history heaps are changed with respect to capabilities the current thread does not own.
Note that the rely does not change the view, because this corresponds a thread from the environment that change the history heap with respect to its own view.


\begin{definition}[Rely and guarantee]
\label{def:rely-guarantee}
Given the set of worlds $\World$ (\cref{def:world}), the \emph{rely} relation, $\Rely \subseteq \World \times \World$, is defined as follows,
\sx{In case I get confused again, it is world to world so the shared and local capabilities should always make sense.}
\[	
    \begin{rclarray}
	\Rely & \eqdef &
	\Setcon{
		((\ca_l,\gs), (\ca_l, \gs'))	
	}{
        \exsts{\ca_e}
        (\ca_e \composeC \ca_l) \isdef
        \land \fora{\rid}
        \gs(\rid) = \gs'(\rid) \lor 
        \exsts{\kap, \hh, \hh', \vi_\rid, \vi_{\rid}', \vi_{e}, \vi_{e}', \ca_\rid, \ca_{\rid}', \intf}   \\
        \quad \gs(\rid) = (\hh, \vi_\rid, \ca_\rid, \intf)
        \land \gs'(\rid) = (\hh', \vi_{\rid}', \ca_{\rid}',\intf) \\
        \quad {} \land \kap \sqsubseteq \ca_{e}(\rid) 
        \land ( (\hh, \vi_e, \ca_e), (\hh', \vi_{e}', \ca_{e}') )  \in \intf(\kap)
        \land \vi_{\rid}' \geq \vi_\rid
	} \\
    \end{rclarray}
\]
The \emph{guarantee} relation, $\Guar: \World \times \World$, is defined as follows:
\[	
    \begin{rclarray}
	\Guar & \eqdef &
	\Setcon{
		((\ca_l,\gs), (\ca_{l}', \gs'))	
	}{
        \fora{\rid}
        \gs(\rid) = \gs'(\rid) \lor {}
        \exsts{\kap, \hh, \hh', \vi_\rid, \vi_{\rid}', \ca_\rid, \ca_{\rid}', \intf}   \\
        \quad \gs(\rid) = (\hh, \vi_\rid, \ca_\rid,\intf)
        \land \gs'(\rid) = (\hh', \vi_{\rid}', \ca_{\rid}',\intf) 
        \land \kap \sqsubseteq \ca_{l}(\rid)  \\
        \quad {} \land ( (\hh, \vi_\rid, \ca_\rid), (\hh', \vi_{\rid}', \ca_{\rid}') )  \in \intf(\kap)
        \land (\ca_{l} \composeC \ca_\rid)^{\perp} = (\ca_{l}' \composeC \ca_{\rid}')^{\perp}
	} \\
    \end{rclarray}
\]
where for any element \( m \) from its domain \( \sort{M} \), the  \emph{orthogonal} is defined as:
\[
\begin{rclarray}
m^{\perp} & \defeq & \Setcon{m'}{(m \compose{} m')\isdef \land m' \in \sort{M}} 
\end{rclarray}
\]
%The \emph{guarantee} relation, $\GuarI \subseteq \World \times \World$, is defined as follows:
%\sx{take away of the closure}
%\[
	%\GuarI \eqdef \guarU
%\]
\end{definition}

The stabilisation says assertions remain true against the environment.
Formally a set of worlds \( \setworld \) is stable under certain execution tests \( \et \) if the set is closed under rely relation under the side conditions: (a) the key-value store transfer is allowed by the execution tests \( (\mkvs, \mkvs') \in \et \); and (b) the new view under the new key-value store is able to progress.
The first condition says there is at least one view from the environment that can trigger the transformation on the key-value store, and it is allowed by the execution tests.
The second condition is more subtle, as it requires to also update the view to a new view \( \vi' \) so that there exists some non-empty fingerprints that is allowed to execute under the new view.
It is especially useful when the execution tests are for serialisibility, which means that the view always shift to the end when the key-value store has been updated by the environment.

\begin{definition}[Stable]
A set of worlds $\setworld \subseteq \World$ is \emph{stable}, written $\stable{\setworld, \como}$, if and only if it is closed under the rely relation: 
\[
    \begin{rclarray}
        \stable{\setworld, \como} & \eqdef & 
        \begin{array}[t]{@{}l}
            \fora{\w, \w'} 
            \w \in \setworld 
            \land (\w, \w') \in \Rely  
            \land \exsts{\hh, \hh', \vi, \vi', \opset} \\
            \quad (\hh, \vi) \in \eraseW{\w}
            \land (\hh', \vi') \in \eraseW{\w'} 
            \land (\hh, \hh') \in \como \\
            \quad {} \land \opset \neq \unitO 
            \land \vi' \geq \vi
            \land (\hh', \vi) \csat \opset : \stub \\
            \qqquad \implies \w' \in \setworld
        \end{array}
    \end{rclarray}
\]
If a update history heap update is allowed by consistency model, \ie \( (\hh, \hh') \in \como \), it means there exist some view \( \vi \) and operation set \( \opset \) allowed by the consistency model and the history is updated to \( \hh' \) via them.
\[
    \begin{rclarray}
        (\hh, \hh') \in \como & \eqdef & 
        \begin{array}[t]{@{}l}
            \hh = \hh' \lor 
            \exsts{ \vi, \vi', \opset, \txid}  \\
            \quad (\hh, \vi) \csat \opset : \vi' 
            \land \txid \in \fresh{\hh} 
            \land \hh'  = \updM{\hh,\vi, \txid, \opset}
        \end{array}
    \end{rclarray}
\]
\end{definition}

\subsection{Rules for Global}

The \rl{PRCommit} rule lifts the local effect of transaction \( \trans \) to global level by first converting global state to (local) observable state and then propagating the local fingerprint to the global state.
%The \( \predn{down} \) predicate asserts that the local predicate \( \lpre \) is a over-approximation of the valid observation that is given by the interference.
%The \( \predn{up} \) predicate says the post-condition \( \gpost \) is the result by lifting the local fingerprints \( \fp \) to pre-condition \( \gpre \).


\begin{figure}[t!]
\hrule\vspace{5pt}

\begin{mathpar}
    \inferrule[\rl{PRCommit}]{%
        \tripleL{\lpre}{\trans}{\lpost} 
        \\ \repartition{\gpre}{\gpost}{\lpre}{\lpost}
        \\\\ \stable{\gpre, \como} 
        \\ \stable{\gpost, \como} 
    }{%
        \tripleG{\gpre}{ \ptrans{\trans} }{\gpost}
    }
    \and
    \inferrule[\rl{TRPar}]{%
        \tripleG{ \gpre_{1} }{ \cmd_{1} }{ \gpost_{1} }
        \\ \tripleG{ \gpre_{2} }{ \cmd_{2} }{ \gpost_{2} } 
        \\\\ \stable{\gpre_{1}, \como} 
        \\ \stable{\gpre_{2}, \como} 
    }{%
        \tripleG{ \gpre_{1} \sep \gpre_{2} }{ \cmd_{1} \ppar \cmd_{2} }{ \gpost_{1} \sep \gpost_{2} }
    }
    \and
    \inferrule[\rl{PRAss}]{%
        \thvar \notin \func{fv}{\lexpr} 
    }{%
        \tripleG{\thvar \dot= \lexpr }{ \pass{\thvar}{\expr} }{\thvar \dot= \expr\sub{\thvar}{\lexpr} }
    }
    \and
    \inferrule[\rl{PRAssume}]{ }{%
        \tripleG{ \expr \dot\neq 0 }{ \passume{\expr} }{ \expr \dot\neq 0 } 
    }
    \and
    \inferrule[\rl{PRChoice}]{%
        \tripleG{ \gpre }{ \cmd_{1} }{ \gpost } 
        \\ \tripleG{ \gpre }{ \cmd_{2} }{ \gpost } 
    }{%
        \tripleG{ \gpre }{ \cmd_{1} \pchoice \cmd_{2} }{ \gpost }
    }
    \and
    \inferrule[\rl{TRSeq}]{%
        \tripleG{ \gpre }{ \cmd_{1} }{ \gframe }
        \\ \tripleG{ \gframe }{ \cmd_{2} }{ \gpost }
    }{%
        \tripleG{ \gpre }{ \cmd_{1} \pseq \cmd_{2} }{ \gpost }
    }
    \and
    \inferrule[\rl{TRIter}]{%
        \tripleG{ \gpre }{ \cmd }{ \gpre } 
    }{%
        \tripleG{ \gpre }{ \cmd\prepeat }{ \gpre }
    }
    \and
    \inferrule[\rl{TRFrame}]{%
        \tripleG{ \gpre }{ \cmd }{ \gpost } 
        \\ \stable{\gframe, \como}
    }{%
        \tripleG{ \gpre \sep \gframe }{ \cmd }{ \gpost \sep \gframe }
    }
\end{mathpar}


\hrule\vspace{5pt}
\[
\begin{rclarray}
    \repartition{\gpre}{\gpost}{\lpre}{\lpost} & \defeq & 
    \begin{array}[t]{@{}l@{}}
        \fora{ \w, \hh, \vi, \lenv, \stk } 
        \w \in \evalW{\gpre} 
        \land (\hh, \cu) \in \eraseW{\w} \implies \\
        \quad \exsts{\h}
        \h = \getSN{\hh, \cu} 
        \land (\h, \unitO) \in \evalLS{\lpre}\\
        \qquad {} \land
        \fora{\stk', \txid, \opset, \hh', \vi'} 
        \exsts{ \w'} 
        \txid \in \fresh{\hh} 
        \land (\stub, \opset) \in \evalF[\lenv, \stk']{\lpost} \\
        \qqquad {} \land \hh' = \updM{\hh, \vi, \txid, \opset} 
        \land \vi' \geq \updV{\hh, \vi, \opset} \\
        \qqquad {} \land (\w, \w') \in \Guar  
        \land (\hh,\vi) \csat \opset : \vi'
        \land (\hh',\vi') \in \eraseW{\w'} \land \w' \in \evalW[\lenv, \stk']{\gpost}
    \end{array} 
\end{rclarray}                          
\]

\hrule\vspace{5pt}
\caption{The rules for programs}
\label{fig:rule-prog}
\end{figure}

%\azalea{
    %\sx{How to deal with the stack here? As the stack for P and Q are different, just for all quantify two stacks??}
%The quantification seems wrong. Especially, the $\extopset$ needs to be for all quantified, $\h$ needs to be there exist quantified.
%\[
     %\repartition{\gpre}{\gpost}{\lpre}{\lpost} \defeq 
     %\begin{array}[t]{@{}l@{}}
		 %\fora{\w, \hh, \vi, \lenv, \stk, \txid } 
            %\w \in \evalW{\gpre} 
            %\land (\hh, \cu) \in \eraseW{\w}
            %\Rightarrow\\
            %\quad \exsts{\h}
            %\begin{array}[t]{@{} l @{}}
			%\h = \getSN{\hh, \cu}  
                %\land (\h, \unitO) \in \evalLS{\lpre} \\
                %\land\, \fora{\extopset \in \evalF{\lpost}} 
                    %\exsts{\w', \hh', \vi'} \\
                        %\quad \hh' = \updM{\hh, \vi, \txid, \extopset} 
                       %\land \cu' = \updV{\hh, \vi, \extopset} 
                       %\land (\hh',\vi') \in \eraseW{\w'} \\
                        %\quad \land (\w, \w') \in \Guar  
                        %\land (\w, \w') \in \como
                        %\land \w' \in \evalW{\gpost}			
		%\end{array}	
%%		\right)			        	
    %\end{array} 
%\]
%}
The \( \HHupdate \) and \( \Vupdate \) in the repartition can be replaced by syntactic rules.

\begin{figure}
\hrule\vspace{5pt}

\[
   \infer[\rl{FInit}]{%
       \tripleF{ \lexpr \pt \lexpr }{ \lexpr \fpI \lexpr }{ \lexpr \pt \lexpr }
   }{}
\]

\[
   \infer[\rl{FRead}]{%
       \tripleF{ \lexpr \pt \lexpr }{ \lexpr \fpR \lexpr }{ \lexpr \pt \lexpr }
   }{}
\]

\[
   \infer[\rl{FWrite}]{%
       \tripleF{ \lexpr \pt \lexpr  }{  \lexpr \fpW \lexpr' }{ \lexpr \pt \lexpr' }
   }{}
\]

\[
   \infer[\rl{FReWrt}]{%
       \tripleF{ \lexpr \pt \lexpr  }{  \lexpr \fpRW (\lexpr,\lexpr') }{ \lexpr \pt \lexpr' }
   }{}
\]

\[
   \infer[\rl{FFrame}]{%
       \tripleF{ \bar{\lpre}_{1} \sep \bar{\lpre}_{2}  }{  \bar{\fp}_{1} \sep \bar{\fp}_{2} }{ \bar{\lpost}_{1} \sep \bar{\lpost}_{2} }
   }{
       \tripleF{ \bar{\lpre}_{1} }{ \bar{\fp}_{1} }{ \bar{\lpost}_{1} }
       && \tripleF{ \bar{\lpre}_{2}  }{ \bar{\fp}_{2} }{ \bar{\lpost}_{2} }
    }
\]


\hrule\vspace{5pt}
\caption{Syntactic rule for \( \HHupdate \) and \( \Vupdate \) functions}
\label{fig:rule-prog}
\end{figure}

