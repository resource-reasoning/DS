\subsection{Reasoning programs}

\begin{definition}[Capabilities]
\label{def:capabilities}
Assume a \emph{partial commutative monoid (PCM)} of \emph{client-specified capabilities} \( (\Kaps, \composeK, \unitK) \) with \( \kap \in \Kaps \), the composition \( \composeK \) the units set \( \unitK \).
Then given a set of \emph{region identifiers} \( \rid \in \RegionID \), the 
%\emph{capability composition function} or 
\emph{capabilities} \( \ca \in \Caps \defeq \RegionID \parfun \Kaps \), where the composition \( \composeC \) is defined as the follows:
\[
    \begin{rclarray}
        (\ca_{l} \composeC \ca_{r})(\rid) & \defeq  &
        \begin{cases}
            \ca_{l}(\rid) \composeK \ca_{r}(\rid) & \rid \in \dom(\ca_{l}) \cap \dom(\ca_{l}) \\
            \ca_{l}(\rid)  & \rid \in \dom(\ca_{l}) \setminus \dom(\ca_{l}) \\
            \ca_{r}(\rid) & \rid \in \dom(\ca_{r}) \setminus \dom(\ca_{l}) \\
            \text{undefined} & \text{otherwise} \\
        \end{cases}
    \end{rclarray}
\]
and the units set \( \unitC \defeq \Setcon{\ca}{\fora{\rid} \ca(\rid) \in \unitK } \) .
A capability assertion is in the form of \( \cass{\kap(\vec{\lvar})}{\lrid} \in \CAst \), where \( \kap(\vec{\lvar}) \) is a token parametrised by logical variables and \( \lrid \) is the region identifiers.
The capability assertion is interpreted to a capability in the model by interpreting all the logical expressions,
\[
\begin{rclarray}
    \evalC{\cass{\kap(\vec{\lvar})}{\lrid}} & \defeq & \Set{\lrid \mapsto \kap(\evalLE{\vec{\lvar}})} \\
\end{rclarray}
\]
\end{definition}

The capability are used, first, as a token that grants some abilities to access to access the database if a thread holds the token.
Second, it is ghost resources to help the reasoning.
%For brevity, when we write \( \cass{\kap}{\lrid} \), and this means there are implicit parameters.

We will use fingerprint assertions to specify interference (shown later), therefore we also have special fingerprint for transferring of capabilities, \ie adding to the shared state \( \fpA \cass{\kap}{\lrid} \), deleting from the shared state \( \fpD \cass{\kap}{\lrid} \) and updating the capabilities \( \cass{\kap(\vec{\lvar})}{\lrid} \fpU \cass{\kap(\vec{\lvar})}{\lrid} \).
The shared state, intuitively, is the state aware by all threads and we will explain the details later.

\begin{definition}[Fingerprint Assertions]
\label{def:fingerprint}
The \emph{fingerprint assertion}, \( \fp \in \FAst \), is defined as the follows, 
\[
\begin{rclarray}    
    \fp, \fp' & ::= & 
    \lexpr \fpI \lexpr 
    \mid \lexpr \fpR \lexpr 
    \mid \lexpr \fpW \lexpr 
    \mid \lexpr \fpRW (\lexpr, \lexpr) 
    \mid \null \fpA \cass{\kap(\vec{\lvar})}{\lrid}  
    \mid \null \fpD \cass{\kap(\vec{\lvar})}{\lrid} 
    \mid \cass{\kap(\vec{\lvar})}{\lrid} \fpU \cass{\kap(\vec{\lvar})}{\lrid} 
    \mid \fp \sep \fp'
\end{rclarray}
\] 
%The fingerprint assertions is interpreted to a triple \( (\ops, \ca, \ca) \)  containing operations, capabilities added in and capabilities moved out.
Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stacks$, the \emph{fingerprint} is interpreted through function, $\evalF[(., .)]{.}: \FAst \times \LEnv \times \Stacks \parfun \Heaps \times \Opsets \times \Caps \times \Caps$.

%It is extended from \( \Ops \) by including tuples for adding capability \( (\otA, \ca) \) and removing capability \( (\otD, \ca) \).
%The well-form condition is also extended so that capabilities can transfer only one way. 
%\[
%\begin{rclarray}
    %\wfO{\extopset} & \defeq & 
    %\begin{array}[t]{@{}l}
        %\fora{ \otag, \otag', \addr, \addr', \ca, \ca'}  \\
        %\quad (\otag, \addr, \stub),(\otag', \addr', \stub) \in \extopset  \implies \otag \neq \otag' \lor \addr \neq \addr' \\
        %\quad {} \land (\otag, \ca),(\otag', \ca') \in \extopset  \implies \ca \neq \ca' \\
    %\end{array}
%\end{rclarray}
%\] 
%The composition \(\extopset_{1} \composeO \extopset_{2} \) is disjointed set union if the result is well-formed.

%\azalea{
    %\sx{Keep the set but separate the capabilities from the set.}
%First, see my comment on page \pageref{comm:operations}.\\
%The above definition is wrong; for instance, you can have $(\otA, c \composeC c'), \in (\otA, c) \in \extopset$, even though $c \composeC c' \ne c$. \\
%Given my definition on \pageref{comm:operations}, we can then define 
%$\extopset: (\Addr \fm \Val \times \pset{\Set{\otR, \otW}}) \times \Caps \times \Caps$, where the first part of the triple is as before, the second part tracks the capabilities added, the third part tracks the capabilities removed.\\
%Again, you won't need the well-formedness. \\
%You can define composition component-wise as $(\uplus, \composeC, \composeC)$.\\
%You will need to adjust the interpretation below. 
%}

\[
\begin{rclarray}
    \evalF{\lexpr_{1} \fpI \lexpr_{2} } & \defeq &
        \Setcon{(\h, \unitO, \ca, \ca')}{
            \exsts{\addr, \val} \addr = \evalLE{\lexpr_{1}} \land \val = \evalLE{\lexpr_{2}} \\ \quad {} \land \h = \Set{\addr \mapsto \val} \land \ca, \ca' \in \unitC
        } \\
    \evalF{\lexpr_{1} \fpR \lexpr_{2}} & \defeq & 
        \Setcon{(\h, \opset, \ca, \ca')}{
            \exsts{\addr, \val} \addr = \evalLE{\lexpr_{1}} \land \val = \evalLE{\lexpr_{2}} \\ \quad {} \land \h = \Set{\addr \mapsto \val} \land \opset = \Set{(\otR, \addr, \val)} \land \ca, \ca' \in \unitC
        } \\
    \evalF{\lexpr_{1} \fpW \lexpr_{2}} & \defeq & 
        \Setcon{(\h, \opset, \ca, \ca')}{
            \exsts{\addr, \val} \addr = \evalLE{\lexpr_{1}} \land \val = \evalLE{\lexpr_{2}} \\ \quad {} \land \h = \Set{\addr \mapsto \val} \land \opset = \Set{(\otW, \addr, \val)} \land \ca, \ca' \in \unitC
        } \\
    \evalF{\lexpr_{1} \fpRW (\lexpr_{2}, \lexpr_{3}) } & \defeq & 
        \Setcon{(\h, \opset, \ca, \ca')}{
            \exsts{\addr, \val, \val'} \addr = \evalLE{\lexpr_{1}} \land \val = \evalLE{\lexpr_{2}} \land \val' = \evalLE{\lexpr_{3}} \\ \quad {} \land \h = \Set{\addr \mapsto \val'} \land \opset = \Set{(\otR, \addr, \val), (\otW, \addr, \val')} \land \ca, \ca' \in \unitC
        } \\
    \evalF{\null \fpA \cass{\kap(\vec{\lvar})}{\lrid} } & \defeq & 
        \Setcon{(\unitH, \unitO, \ca, \ca')}{
            \ca = \evalC{\cass{\kap(\vec{\lvar})}{\lrid}} \land \ca' \in \unitC
        } \\
    \evalF{\null \fpD \cass{\kap(\vec{\lvar})}{\lrid} } & \defeq &
        \Setcon{(\unitH, \unitO, \ca, \ca')}{
            \ca \in \unitC \land \ca'  = \evalC{\cass{\kap(\vec{\lvar})}{\lrid}} 
        } \\
    \evalF{\cass{\kap(\vec{\lvar})}{\lrid} \fpU \cass{\kap'(\vec{\lvar}')}{\lrid} } & \defeq &
        \Setcon{(\unitH, \unitO, \ca, \ca')}{
            \ca = \evalC{\cass{\kap(\vec{\lvar})}{\lrid}} \land \ca'  = \evalC{\cass{\kap'(\vec{\lvar}')}{\lrid}} 
        } \\
    \evalF{\fp_{1} \sep \fp_{2}} & \defeq & \Setcon{ ( \h_{1} \composeH \h_{2}, \opset_{1} \composeO \opset_{2}, \ca_{1} \composeC \ca_{2}, \ca'_{1} \composeC \ca'_{2} ) }{(\h_{1}, \opset_{1}, \ca_{1}, \ca'_{1}) \in \evalF{\fp_{1}}  \\ {} \land (\h_{2}, \opset_{2}, \ca_{2}, \ca'_{2}) \in \evalF{\fp_{2}}}\\

\end{rclarray}
\]
\end{definition}

%\sx{ It should be fine for local assertion to include the capabilities, as it either becomes frame or (not sure) helps local reasoning}

%The standard separation assertions describe the current local state, while the fingerprints are all the local effects that will be committed to the database.


%\azalea{
    %\sx{Leave this notation for now, when settle other parts, we can change the macro systematically for confused notations.}
    %The definition of $\evalLS{ \bar{\fp} }$ looks cyclic as you use the same notation for interpreting local assertions and fingerprint assertions.
%}

Because the local assertions do not contain any assertions related to capabilities, it is enough to interpret them to heaps and sets of operations \( \Opsets \).

\begin{lemma}
\(
    \fora{\bar{\fp},\ca,\ca'} (\stub, \stub, \ca, \ca') \in \evalF{\bar{\fp}} \implies \ca,\ca' \in \unitC
\)
\end{lemma}
\begin{proof}
Induction on the structures.
\end{proof}

%For readability, we will write angle brackets, \eg \( \fpass{(\etR, \vx, 0)} \) instead of curly brackets \( \fpto{\Set{(\etR, \vx, 0)}} \) for fingerprint assertions.


%The interference \( \exsts{\vec{\lvar}} \perm{\kap} : \bar{\lpre} \mat \fp \) says if a thread holds the capability \( \perm{\kap}\) and \emph{the current state of database} satisfies the assertions \( \bar{\lpre} \), the thread is allowed to commit a transaction that has the fingerprint \( \fp \).
%The current state of database refers to the state that all the committed transactions are visible.

%\begin{definition}[Interference]
%\label{def:intf}
%Assume standard separation logic assertion \( \bar{\lpre}\) (the local assertion \( \LAst \) without fingerprint).
%Given the fingerprint assertion \( \fp \in \Fingerprint \) (\defref{def:fingerprint}), the grammar of \emph{interference assertions}, \( \intass \in \IAst \), is defined as the follows,
%\[
%\begin{rclarray}
	%\intass & ::=  &
	%\emptyset \mid \Set{ \perm{\kap} :  \exsts{\vec{\lvar}} \bar{\lpre} \mat \fp } \cup \intass 
%\end{rclarray}
%\]
%The interference assertions are interpreted to a set of \emph{interference environments} that is a function from client-specified capabilities to pairs of history heaps and operations,
%\[
%\begin{rclarray}
    %\inter \in \Interference & \defeq & \Kaps \to \powerset{\HisHeaps \times \Opsets}
%\end{rclarray}
%\]
%Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stacks$, the \emph{interference interpretation} function, $\evalI[(., .)]{.}: \IAst \times \LEnv \times \Stacks \to \Interference$, is defined as follows,
%%
%\[
%\begin{rclarray}
	%\evalI{\emptyset}(\kap) & \eqdef & \emptyset \\
	%\evalI{\Set{ \perm{\kap} : \exsts{\vec{\lvar}} \bar{\lpre} \mat \fp } \cup \intass }(\kap') & \eqdef &
    %\begin{cases}
    %\Setcon{(\hh, \evalF[\lenv',\stk]{\fp})}{\exsts{\h} \h \in \evalLS[\lenv',\stk]{\bar{\lpre}} \land {} \\ \h = \clpsHH{\hh} } \cup \evalI{\intass}(\kap')  & \kap = \kap' \\
    %\evalI{\intass}(\kap') & \text{ otherwise} \\
    %\end{cases} \\
    %& & \text{where there exists a vector of values \( \vec{\val}\) such that } \lenv' = \lenv\rmto{\vec{\lvar}}{\vec{\val}} \\
%\end{rclarray}
%\] 
%\end{definition}

%We will write \( \intfH(\kap) \)  and \( \intfO(\kap) \) for the first and second projections of all the elements.

The interference \( \exsts{\vec{\lvar}} \perm{\kap} : \fp \) says if a thread holds the capability \( \perm{\kap} \), it is allowed to commit a transaction that has the fingerprint \( \fp \).
The existential is for binding variables between the capability and the fingerprint assertions.

\sx{Parameter of the \( \kap \)? 
The \( \intf \) might simplify to single view to single view.
}
\begin{definition}[Interference]
\label{def:intf}
Given the fingerprint assertion \( \fp \in \Fingerprint \) (\cref{def:fingerprint}), the grammar of \emph{interference assertions}, \( \intass \in \IAst \), is defined as the follows,
\[
\begin{rclarray}
	\intass & ::=  &
	\emptyset \mid \Set{ \exsts{\vec{\lvar}} \perm{\kap} : \fp } \cup \intass 
\end{rclarray}
\]
The interference assertions are interpreted to \emph{interference environments} that is a set of transitions on history heap, a set of views, and capabilities,
\[
\begin{rclarray}
    \inter \in \Interference & \defeq & \Kaps \to ( \HisHeaps \times \Views \times \Caps ) \times  ( \HisHeaps \times \Views \times \Caps )
\end{rclarray}
\]
Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stacks$, the \emph{interference interpretation} function, $\evalI[(., .)]{.}: \IAst \times \LEnv \times \Stacks \to \Interference$, is defined as follows,
\sx{
    Notations are confused, there is different between syntactic \( \kap \) which can be parametrised by logical variables, and client-specified capabilities \( \kap' \).
    Fix the typesetting later.
    } 
\[
\begin{array}{@{}l}
	\evalI{\Set{ \exsts{\vec{\lvar}} \perm{\kap} : \fp } \cup \intass }(\kap') \eqdef \\
    	\quad \begin{cases}
	    		\Setcon{
                    \begin{B}
	    				(\hh, \vi, \ca_r \composeC \ca_f ), \\ 
	    				(\hh',\vi', \ca_f \composeC \ca_a)
                    \end{B}
	    		}{ 
	    			\exsts{\txid, \opset, \cl} \\
	    				\quad ( \stub, \opset, \ca_{a}, \ca_{r} ) \in \evalF[\lenv',\stk]{\fp}   \\
					\quad {} \land \txid \in \func{nextTxid}{\hh, \cl}  \\
	       			\quad {} \land \hh' = \updM{\hh, \vi, \txid, \opset}  \\
		        	\quad {} \land \pred{readFrom}{\hh, \vi, \opset} 
                    \land \vi' \geq \vi \\
	    		} 
	    		\cup \evalI{\intass}(\kap')  
    		& \text{ if } \dagger \\\\
    		
	    	\evalI{\intass}(\kap') 
	    	& \text{ otherwise} \\
    	\end{cases}  \\
        \qquad \dagger \equiv \exsts{\vec{\val}, \lenv'} \lenv' = \lenv\rmto{\vec{\lvar}}{\vec{\val}} \land \kap' = \evalI[\lenv', \stk]{\kap} \\
\end{array}
\]
The \( \predn{readFrom} \) asserts the fingerprint make sense with respect to the view:
\[
\begin{rclarray}
    \pred{readFrom}{\hh, \vi, \opset} & \defeq & \fora{\ke, \val} (\otR, \ke, \val) \in \opset \implies \valueOf(\hh(\ke,\vi(\ke))) = \val
\end{rclarray}
\]
%
%\[
%\begin{rclarray}
	%\evalI{\emptyset}(\kap) & \eqdef & \emptyset \\
	%\evalI{\Set{ \exsts{\vec{\lvar}} \perm{\kap} : \fp } \cup \intass }(\kap') & \eqdef &
    %\begin{cases}
    %\evalF[\lenv',\stk]{\fp} \cup \evalI{\intass}(\kap')  & \text{if } \exsts{\vec{\val}, \lenv'} \lenv' = \lenv\rmto{\vec{\lvar}}{\vec{\val}} \land \kap' = \evalI[\lenv', \stk]{\kap} \\
    %\evalI{\intass}(\kap') & \text{ otherwise} \\
    %\end{cases} \\
%\end{rclarray}
%\] 

\end{definition}

%\begin{definition}[Labelled transition system]
%\label{def:labelled-transition-system}
%The labelled transition system is a tuple \( ( \hhset \times \cuset, \opsetset,\toLTS{}, \hhset_{0} \times \cuset_{0}, \como) \) consisting of pairs of history heaps and cuts \( \hhset \times \cuset \), a set of sets of operations \( \opsetset \subseteq \Opsets \), a relation \( \toLTS{} : \HisHeaps \times \Opsets \times \HisHeaps \), a set of initial history heaps and cuts \( \hhset_{0} \times \cuset_{0} \) and the consistency model associated with the transition system \( \como \).
%Assume all the initial abstract executions satisfies the consistency model.
%The relation \( \toLTS{}\) is defined as the follows,
%\[
%\begin{rclarray}
    %(\hh, \cu) \toLTS{\opset} (\hh',\cu') & \defeq &
    %\begin{array}[t]{@{}l}
        %\exsts{\thcu, \thcu', \txid, \thid}
        %\txid \in \fresh{\hh} 
        %\land \hh' = \updM{\hh, \cu, \txid, \opset} 
        %\land \cu' = \updV{\hh', \cu, \opset} \\
        %\quad {} \land ((\hh,\thcu),(\hh',\thcu')) \in \como
        %\land \h = \clpsHH{\hh,\cu} 
        %\land \thcu(\thid) = \cu 
        %\land \thcu'(\thid) = \cu' \\
        %\quad {} \land \fora{\addr,\val} (\otR, \addr, \val)  \in \opset \implies \h(\addr) = \val
    %\end{array}
%\end{rclarray}
%\]
%\end{definition}

%We lift the interference to a invariant.
%The invariant is a labelled transition system that describes how a region evolves providing all the allowed operations.
%Note that the labels are capabilities (with region identifiers) instead of client-specified capabilities, which is only for technical reason.

\begin{definition}[Invariant of a region]
\label{def:invariant-region}
Assume a global function, \( \funcn{init} : \RegionID \to \powerset{ \HisHeaps } \) returning initial key-value stores for regions.
Given the initial states for a region \( \func{init}{\rid}\), the invariant of a region, written \( \func{inv}{\rid, \intf} \), is a set of key-value stores that is closed under the interference \( \intf \):
\[
\begin{array}[t]{@{}l}
    \func{init}{\rid} \in \func{inv}{\rid, \intf} \land 
    \fora{\mkvs, \mkvs'} 
    \exsts{\w, \w', \kap} \\
    \quad \mkvs \in \func{inv}{\rid, \intf} \land  ( \mkvs, \stub ) = \eraseW{\w} \land ( \mkvs', \stub ) = \eraseW{\w'} \land (\w, \w') \in \intf(\kap) \implies \mkvs' \in \func{inv}{\rid, \intf} 
\end{array}
\]
\end{definition}

%For brevity, \( (\hh,\cu) \in \func{inv}{\rid, \intf} \) denotes \( (\hh,\cu) \in \func{inv}{\rid,\intf}\projection{1} \), and similarly \( (\hh,\cu) \toLTS{\opset} (\hh',\cu') \in \func{inv}{\rid, \intf} \).

%\sx{This well form condition allows one to write weaker interference, \eg interference satisfies both SI and SER but to prove the correctness of SER. It is fine since logic only need to be sound?}
%\begin{definition}[Well-form of a region]
%\label{def:well-form-region}
%The well-form condition of the interference, namely \( \pred{wfintf}{\rid, \intf} \) predicate, assertions for any concrete events \( \opset \), the state before the events must be included in the interference.
%\[
%\begin{rclarray}
    %\pred{wfintf}{\rid, \intf} & \defeq & 
    %\begin{array}[t]{@{}l}
        %\fora{\hh, \hh', \opset} 
        %(\hh, \stub) \toLTS{\opset} (\hh',\stub) \in \func{inv}{\rid, \intf} 
        %\implies \exsts{ \kap}
        %(\hh, \opset ) \in \intf( \kap )
    %\end{array} \\
%\end{rclarray}
%\]
%\end{definition}

\begin{definition}[Worlds]
\label{def:world}
Given the set of history heaps $\HisHeaps$ (\cref{def:his_heap}), views \( \Views \) (\cref{def:views}), capabilities \( \Caps\) (\cref{def:capabilities}) and region identifiers \( \RegionID \), the set of \emph{shared states} is \( \SStates \eqdef \RegionID \parfun \HisHeaps \times \Views \times \Caps \times \Interference \).
Each region has its current state and the interference.
The \emph{shared state composition function}, $\composeS: \SStates \times \SStates \parfun \SStates$, is defined as $\composeS \eqdef \composeEq$, where for all domains $\sort M$ and all $m, m' \in \sort M$,
%
\[
\begin{rclarray}
	m \composeEq m' &  \eqdef  &
	\begin{cases}
		m & \text{if } m = m'\\
		\text{undefined} & \text{otherwise}
	\end{cases}
\end{rclarray}
\]
A \emph{world} \( \w \in \World \) is a pair of capabilities \( \ca \) (\cref{def:capabilities}) and a shared state \( \gs \) in which regions are well-formed, \ie (a) they are associated with disjointed part of history heaps; (b) the domain of the view in a region is the same as the domain of the history heap; and (c) the views should not be out of the range of history heaps.
Separately, capabilities from regions and local capabilities are compatible.
These constraints are derived by the clap \(\eraseS{(\ca, \gs)} \neq \emptyset \).
Finally, there is no garbage capability, a capability where the associated region identifier never appear in the shared state.
\[
\begin{rclarray}
	\world \in \World  & \eqdef & 
    \Setcon{
        (\ca, \gs) 
    }{ 
        \ca \in \Caps \land \gs \in \SStates
        \land \exsts{ \ca' } 
        (\stub, \stub, \ca') \in \func{collapse}{\gs}
        \land \dom(\ca \composeC \ca') \subseteq \dom(\gs)  \\
        \quad {} \land \fora{\rid}
        \exsts{\hh, \vi, \intf} 
        \gs(\rid) = (\hh, \vi, \stub, \intf) 
        \land \dom(\hh) = \dom(\vi) 
        \land \mkvs \in \func{inv}{\rid, \intf} \\
        \quad {} \land \fora{ \addr \in \dom(\vi) }
        0 \leq \cu( \addr ) \le \left| \hh(\addr) \right|
    }
\end{rclarray}
\]
where the \(\funcn{collapse} \) function collapses a shared state by erasing the region identifiers:
\[
\begin{rclarray}
    \func{collapse}{\emptyset} & \defeq & \Set{(\unitHH, \unitVI, \unitC )} \\
    \func{collapse}{\Set{\rid \mapsto (\hh, \vi, \ca, \intf)} \uplus \gs } & \defeq & 
        \Setcon{ 
            (\hh \composeHH \hh', \vi \composeCU \vi', \ca \composeC \ca') 
        }{ 
            \land (\hh', \vi', \ca') \in \func{collapse}{\gs} }\\
\end{rclarray}
\] 
% 
The \emph{world composition function}, $\composeW: \World \times \World \parfun \World$, is defined component-wise as: $\composeW \eqdef (\composeC, \composeS)$.
The \emph{world unit set} is $\unitW \eqdef \Setcon{(\ca, \gs)}{(\ca, \gs) \in \World \land \ca \in \unitC}$.
The \emph{partial commutative monoid of worlds} is $(\World, \composeW, \unitW)$.
Because of the well-formedness condition, the function \( \eraseW{.} : \World \to \HisHeaps \times \Views \) collapses a world to \emph{a unique pair of a key-value store and a view}:
\[
\begin{rclarray}
    \eraseW{\w} & \defeq & (\hh, \vi) \text{  where } (\hh, \vi, \stub) \in \func{collapse}{\w\projection{2}}\\
\end{rclarray}
\] 
\end{definition}

\begin{definition}[Assertions]
\label{def:assertion}
Given the set of logical expression \( \lexpr \subseteq \LExpr\), the set of \emph{assertions}, $\gpre, \gpost \in \Ast$, are defined by the following inductive grammar:
\[
\begin{rclarray}
    \bar{\lpre}, \bar{\lpost} & ::= & \False \mid \True \mid \bar{\lpre} \land \bar{\lpost} \mid \bar{\lpre} \lor \bar{\lpost} \mid \exsts{\lvar} \bar{\lpre} \mid \bar{\lpre} \implies \bar{\lpost} \mid \assemp \mid \cass{\kap}{\lrid} \mid \lexpr \pt \lexpr \mid \bar{\lpre} \sep \bar{\lpost} \\
	\gpre , \gpost & ::= & \False \mid \True \mid \gpre \land \gpost \mid \gpre \lor \gpost \mid \exsts{\lvar}\gpre \mid \gpre \implies \gpost \mid \assemp \mid \cass{\kap}{\lrid} \mid \gpre \sep \gpost \mid \boxass{\bar{\lpre}}{\lrid}{\intass}\\
\end{rclarray}
\]
%
where $\lvar, \lrid \in \LVar$, $\lexpr_1, \lexpr_2 \in \LExpr$ (\cref{def:local_assertions}), $\kap \in \Kaps$ (\cref{def:capabilities}) and $\intass \in \IAst$ (\cref{def:intf}).
Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stacks$, the \emph{assertion interpretation} function, $\evalW[(., .)]{.}: \Ast \times \LEnv \times \Stacks \to \powerset{\World}$, is defined as follows,
%
\[
\begin{rclarray}
	\evalW{\False} & \defeq & \emptyset \\
	\evalW{\True} & \defeq & \World \\
	\evalW{\emp} & \defeq & \unitW \\
	\evalW{\gpre \land \gpost} & \defeq & \evalW{\gpre} \cap \evalW{\gpost} \\
	\evalW{\gpre \lor \gpost} & \defeq & \evalW{\gpre} \cup \evalW{\gpost} \\ 
	\evalW{\exsts{\lvar}  \gpre} & \defeq & \bigcup\limits_{\val \in \textnormal{\Val}} \evalW[\lenv\remapsto{\lvar}{\val}, \stk]{\gpre} \\
	\evalW{\gpre \implies \gpost} & \defeq & \Setcon{\w}{\w \in \evalW{\gpre} \implies \w \in \evalW{\gpost}} \\
	\evalW{\cass{\kap}{\lrid}} & \defeq & \Setcon{ (\Set{\lrid \mapsto \evalI{\kap}}, \gs) }{\gs \in \SStates} \\
	\evalW{ \gpre \sep \gpost } & \defeq & 
	\Setcon{
	   (\world_1 \composeW \world_2) 
    }{
       \world_1 \in \evalW{\gpre} \land \world_2 \in \evalW{\gpost}
	} \\
	\evalW{ \boxass{\bar{\lpre}}{\lrid}{\intass} } & \defeq & 
    \Setcon{
        (\ca, \gs)
    }{         
        \exsts{\hh, \vi, \ca', \intf}
        \ca \in \unitC  \\
        \quad {} \land \intf = \evalI{\intass} 
        \land \gs(\lrid) = (\hh, \vi, \ca', \intf) 
        \land (\hh, \vi, \ca') \in \func{intp}{\bar{\lpre}, \lenv, \stk} 
    } \\
    \\
    \func{intp}{\assfalse,\lenv,\stk} & \defeq & \emptyset \\
    \func{intp}{\asstrue,\lenv,\stk} & \defeq & \HisHeaps \times \Views \times \Caps \\
    \func{intp}{\assemp,\lenv,\stk} & \defeq & \Setcon{ (\unitHH, \unitVI, \ca) }{\ca \in \unitC } \\
    \func{intp}{\bar{\lpre} \land \bar{\lpost},\lenv,\stk} & \defeq & \func{intp}{\bar{\lpre},\lenv,\stk} \cap \func{intp}{\bar{\lpost},\lenv,\stk} \\ 
    \func{intp}{\bar{\lpre} \lor \bar{\lpost},\lenv,\stk} & \defeq & \func{intp}{\bar{\lpre},\lenv,\stk} \cup \func{intp}{\bar{\lpost},\lenv,\stk} \\ 
    \func{intp}{\exsts{\lvar} \bar{\lpre},\lenv,\stk} & \defeq & \bigcup\limits_{\val \in \Val} \func{intp}{\bar{\lpre}, \lenv\rmto{\lvar}{\val}, \stk} \\
    \func{intp}{\bar{\lpre} \implies \bar{\lpost},\lenv,\stk} & \defeq & \Setcon{ (\hh, \vi, \ca) }{ (\hh, \vi, \ca) \in \func{intp}{\bar{\lpre},\lenv,\stk} \implies (\hh, \vi, \ca) \in \func{intp}{\bar{\lpost},\lenv,\stk} }\\
    \func{intp}{\cass{\kap}{\lrid},\lenv,\stk} & \defeq & \Set{ (\unitHH, \unitVI, \Set{\lrid \mapsto \evalC{\kap}}) }\\
    \func{intp}{\lexpr_{1} \pt \luexpr_2,\lenv,\stk} & \defeq & \Setcon{ (\hh, \vi, \ca) }{ \Set{ \evalLE{\lexpr_{1}} \mapsto \evalLE{\luexpr_{1}} } = \clpsHH{\hh, \vi} \land \ca \in \unitC } \\
    \func{intp}{\lexpr_{1} \pt \lexpr_2,\lenv,\stk} & \defeq & 
    \Setcon{ (\hh, \vi, \ca) }{%
        \exsts{\ke = \evalLE{\lexpr_{1}}} \Set{ \ke \mapsto \evalLE{\lexpr_{2}} } = \clpsHH{\hh, \vi} \\ 
        \quad {} \land \vi(\ke) = \lvert \mkvs(\ke) \rvert - 1 \land \ca \in \unitC
    } \\
    \func{intp}{\bar{\lpre} \sep \bar{\lpost},\lenv,\stk} & \defeq & 
    \Setcon{ (\hh \composeHH \hh', \vi \composeVI \vi', \ca \composeC \ca') }{ (\hh, \vi, \ca) \in \func{intp}{\bar{\lpre},\lenv,\stk} \\ {} \land (\hh', \vi', \ca') \in \func{intp}{\bar{\lpost},\lenv,\stk} } \\
\end{rclarray}
\]
\end{definition}



\subsubsection{Rely and Guarantee}

The \emph{rely} and \emph{guarantee} describes the world transformation for the environment and for the current client (\cref{def:rely-guarantee}).
To recall, a world includes local capabilities and a shared state, and a shared state is a client's view for the key-value store.
The \emph{rely} \( \Rely \) is a set of pairs on worlds, describing how the environment can change the state of the key-value store.
Given the local capabilities \( \ca_l \), the environment might own any capabilities \( \ca_e\) that is compatible, \ie \( (\ca_l \composeC \ca_e)\isdef \).
Therefore, the environment can perform actions associated with the their capabilities \( \ca_e \) with their own view \( \vi_e \) to update the key-value store and shared capabilities.
For technical reasons, even though the environment cannot change the view of the current client \( \vi_r\), but it is allowed to arbitrarily shift to the later versions due to the fact that for certain execution tests, the old view might be valid under the new key-value store.

The \emph{guarantee} \( \Guar \) describes the allowed actions for the current client.
The current client can perform actions associated with the local capabilities \( \ca_l \) to update the shared state and the local capabilities.
Yet it should ensure no resource created or deleted by requiring the \emph{orthogonal} of local capabilities and shared capabilities together remains unchanged.
The orthogonal of local capabilities \( \ca \) is a set of capabilities that are compatible with the local capabilities \( \ca \).
This constraint disallow any creation and deletion for capabilities, but it allows to update capabilities.
Note that in the rely and guarantee, it is allowed to update several regions, but each region can be updated at most once.
\begin{definition}[Rely and guarantee]
\label{def:rely-guarantee}
Given the set of worlds $\World$ (\cref{def:world}), the \emph{update rely} relation, $\relyU \subseteq \World \times \World$, is defined as follows:
\sx{In case I get confused again, it is world to world so the shared and local capabilities should always make sense.}
\[	
    \begin{rclarray}
	\relyU & \eqdef &
	\Setcon{
		((\ca_l,\gs), (\ca_l, \gs'))	
	}{
        \exsts{\ca_e}
        (\ca_e \composeC \ca_l) \isdef
        \land \fora{\rid}
        \gs(\rid) = \gs'(\rid) \lor 
        \exsts{\kap, \hh, \hh', \vi_\rid, \vi_{\rid}', \vi_{e}, \vi_{e}', \ca_\rid, \ca_{\rid}', \intf}   \\
        \quad \gs(\rid) = (\hh, \vi_\rid, \ca_\rid, \intf)
        \land \gs'(\rid) = (\hh', \vi_{\rid}', \ca_{\rid}',\intf) \\
        \quad {} \land \kap \sqsubseteq \ca_{e}(\rid) 
        \land ( (\hh, \vi_e, \ca_e), (\hh', \vi_{e}', \ca_{e}') )  \in \intf(\kap)
        \land \vi_{\rid}' \geq \vi_\rid
	} \\
    \end{rclarray}
\]
The \emph{view shift rely} relation $\relyV \subseteq \World \times \World$, is defined as follows:
\[
    \begin{rclarray}
	\relyV & \eqdef &
	\Setcon{
		((\ca_l,\gs), (\ca_l, \gs'))	
	}{
        \exsts{\ca_e}
        (\ca_e \composeC \ca_l) \isdef
        \land \fora{\rid}
        \gs(\rid) = \gs'(\rid) \lor 
        \exsts{\hh, \vi, \vi'\ca, \ca, \intf}   \\
        \quad \gs(\rid) = (\hh, \vi, \ca, \intf)
        \land \gs'(\rid) = (\hh, \vi', \ca, \intf) 
	} \\
    \end{rclarray}
\]
The \emph{rely} relation is transitive closure of updates and view shift: \( \Rely = (\relyU \cup \relyV)^{*} \).
The \emph{guarantee} relation, $\Guar: \World \times \World$, is defined as follows:
\[	
    \begin{rclarray}
	\Guar & \eqdef &
	\Setcon{
		((\ca_l,\gs), (\ca_{l}', \gs'))	
	}{
        \fora{\rid}
        \gs(\rid) = \gs'(\rid) \lor {}
        \exsts{\kap, \hh, \hh', \vi_\rid, \vi_{\rid}', \ca_\rid, \ca_{\rid}', \intf}   \\
        \quad \gs(\rid) = (\hh, \vi_\rid, \ca_\rid,\intf)
        \land \gs'(\rid) = (\hh', \vi_{\rid}', \ca_{\rid}',\intf) 
        \land \kap \sqsubseteq \ca_{l}(\rid)  \\
        \quad {} \land ( (\hh, \vi_\rid, \ca_\rid), (\hh', \vi_{\rid}', \ca_{\rid}') )  \in \intf(\kap)
        \land (\ca_{l} \composeC \ca_\rid)^{\perp} = (\ca_{l}' \composeC \ca_{\rid}')^{\perp}
	} \\
    \end{rclarray}
\]
where for any element \( m \) from its domain \( \sort{M} \), the  \emph{orthogonal} is defined as:
\[
\begin{rclarray}
m^{\perp} & \defeq & \Setcon{m'}{(m \compose{} m')\isdef \land m' \in \sort{M}} 
\end{rclarray}
\]
\end{definition}

The stabilisation says assertions remain true against the environment.
Formally a set of worlds \( \setworld \) is stable under certain execution tests \( \et \) if the set is closed under rely relation under the side conditions: (a) the key-value store transfer is allowed by the execution tests \( (\mkvs, \mkvs') \in \et \);
and (b) the new view under the new key-value store is able to progress.
The first condition says there is at least one view from the environment that can trigger the transformation on the key-value store, and it is allowed by the execution tests.
The second condition is more subtle, as it allows to also update the view to a new view \( \vi' \) so that for all the possible transactions with the fingerprints \( \opset \), if they can execute under the old view, it should be able to execute under the new view.

\begin{definition}[Stable]
\label{def:stable}
A set of worlds $\setworld \subseteq \World$ is \emph{stable}, written $\stable{\setworld, \como}$, if and only if it is closed under the rely relation: 
\[
    \begin{rclarray}
        \stable{\setworld, \como} & \eqdef & 
        \begin{array}[t]{@{}l}
            \fora{\w, \w'} 
            \w \in \setworld 
            \land (\w, \w') \in \Rely  
            \land \exsts{\hh, \hh', \vi, \opset} \\
            \quad (\hh, \vi) = \eraseW{\w}
            \land (\hh', \vi') = \eraseW{\w'} 
            \land (\hh, \hh') \in \como 
            \land \pred{progress}{\w, \et} \\
            \qqquad \implies \w' \in \setworld
        \end{array} \\
    \end{rclarray}
\]
A update history heap update is allowed by consistency model, \ie \( (\hh, \hh') \in \como \), iff there exist some view \( \vi \) and operation set \( \opset \) allowed by the consistency model and the history is updated to \( \hh' \) via them:
\[
    \begin{rclarray}
        (\hh, \hh') \in \como & \eqdef & 
        \begin{array}[t]{@{}l}
            \hh = \hh' \lor 
            \exsts{ \vi, \vi', \opset, \txid, \cl}  \\
            \quad (\hh, \vi) \csat \opset : \vi' 
            \land \txid \in \fresh{\hh, \cl} 
            \land \hh'  = \updM{\hh,\vi, \txid, \opset}
        \end{array}
    \end{rclarray}
\]
A world is able to progress under an execution test \( \et \), iff it is able to execute the empty fingerprint:
\[
    \begin{rclarray}
        \pred{progress}{\w, \et} & \defeq & \exsts{\vi} \eraseW{\w} \csat \unitO :  \vi
    \end{rclarray}
\]
\end{definition}


\subsection{Rules for Global}

The \rl{PRCommit} rule lifts the local effect of transaction \( \trans \) to global level by first converting global state to (local) observable state and then propagating the local fingerprint to the global state.
%The \( \predn{down} \) predicate asserts that the local predicate \( \lpre \) is a over-approximation of the valid observation that is given by the interference.
%The \( \predn{up} \) predicate says the post-condition \( \gpost \) is the result by lifting the local fingerprints \( \fp \) to pre-condition \( \gpre \).


\begin{figure}[t!]
\hrule\vspace{5pt}

\begin{mathpar}
    \inferrule[\rl{PRCommit}]{%
        \tripleL{\lpre}{\trans}{\lpost} 
        \\ \repartition{\gpre}{\gpost}{\lpre}{\lpost}
        \\\\ \stable{\gpre, \como} 
        \\ \stable{\gpost, \como} 
    }{%
        \tripleG{\gpre}{ \ptrans{\trans} }{\gpost}
    }
    \and
    \inferrule[\rl{PRPar}]{%
        \tripleG{ \gpre_{1} }{ \cmd_{1} }{ \gpost_{1} }
        \\ \tripleG{ \gpre_{2} }{ \cmd_{2} }{ \gpost_{2} } 
        \\\\ \stable{\gpre_{1}, \como} 
        \\ \stable{\gpre_{2}, \como} 
    }{%
        \tripleG{ \gpre_{1} \sep \gpre_{2} }{ \cmd_{1} \ppar \cmd_{2} }{ \gpost_{1} \sep \gpost_{2} }
    }
    \and
    \inferrule[\rl{PRAss}]{%
        \thvar \notin \func{fv}{\lexpr} 
    }{%
        \tripleG{\thvar \dot= \lexpr }{ \pass{\thvar}{\expr} }{\thvar \dot= \expr\sub{\thvar}{\lexpr} }
    }
    \and
    \inferrule[\rl{PRAssume}]{ }{%
        \tripleG{ \expr \dot\neq 0 }{ \passume{\expr} }{ \expr \dot\neq 0 } 
    }
    \and
    \inferrule[\rl{PRChoice}]{%
        \tripleG{ \gpre }{ \cmd_{1} }{ \gpost } 
        \\ \tripleG{ \gpre }{ \cmd_{2} }{ \gpost } 
    }{%
        \tripleG{ \gpre }{ \cmd_{1} \pchoice \cmd_{2} }{ \gpost }
    }
    \and
    \inferrule[\rl{PRSeq}]{%
        \tripleG{ \gpre }{ \cmd_{1} }{ \gframe }
        \\ \tripleG{ \gframe }{ \cmd_{2} }{ \gpost }
    }{%
        \tripleG{ \gpre }{ \cmd_{1} \pseq \cmd_{2} }{ \gpost }
    }
    \and
    \inferrule[\rl{PRIter}]{%
        \tripleG{ \gpre }{ \cmd }{ \gpre } 
    }{%
        \tripleG{ \gpre }{ \cmd\prepeat }{ \gpre }
    }
    \and
    \inferrule[\rl{PRFrame}]{%
        \tripleG{ \gpre }{ \cmd }{ \gpost } 
        \\ \stable{\gframe, \como}
        \\ \func{fv}{\gframe} \cap \func{modify}{\cmd} = \emptyset 
    }{%
        \tripleG{ \gpre \sep \gframe }{ \cmd }{ \gpost \sep \gframe }
    }
\end{mathpar}


\hrule\vspace{5pt}
\[
\begin{rclarray}
    \repartition{\gpre}{\gpost}{\lpre}{\lpost} & \defeq & 
    \begin{array}[t]{@{}l@{}}
        \fora{ \w, \lenv, \stk } 
        \w \in \evalW{\gpre} 
        \implies 
        (\getSN{\eraseW{\w}}, \unitO) \in \evalLS{\lpre}  \\
        \quad {} \land \fora{\stk', \txid, \opset, \w', \cl} 
        \txid \in \fresh{\eraseW{\w}\projection{1}, \cl} 
        \land (\stub, \opset) \in \evalF[\lenv, \stk']{\lpost} \\
        \qquad {} \land \eraseW{\w'}\projection{1} = \updM{\eraseW{\w}, \txid, \opset}  \\
        %\land \eraseW{\w}\projection{2} \leq \eraseW{\w'}\projection{2} \\
        \qquad {} \land (\w, \w') \in \Guar  
        \land \eraseW{\w} \csat \opset : \eraseW{\w'}\projection{2}
        \implies \w' \in \evalW[\lenv, \stk']{\gpost}
    \end{array} 
\end{rclarray}                          
\]

\hrule\vspace{5pt}
\caption{The rules for programs}
\label{fig:rule-prog}
\end{figure}

%\azalea{
    %\sx{How to deal with the stack here? As the stack for P and Q are different, just for all quantify two stacks??}
%The quantification seems wrong. Especially, the $\extopset$ needs to be for all quantified, $\h$ needs to be there exist quantified.
%\[
     %\repartition{\gpre}{\gpost}{\lpre}{\lpost} \defeq 
     %\begin{array}[t]{@{}l@{}}
		 %\fora{\w, \hh, \vi, \lenv, \stk, \txid } 
            %\w \in \evalW{\gpre} 
            %\land (\hh, \cu) \in \eraseW{\w}
            %\Rightarrow\\
            %\quad \exsts{\h}
            %\begin{array}[t]{@{} l @{}}
			%\h = \getSN{\hh, \cu}  
                %\land (\h, \unitO) \in \evalLS{\lpre} \\
                %\land\, \fora{\extopset \in \evalF{\lpost}} 
                    %\exsts{\w', \hh', \vi'} \\
                        %\quad \hh' = \updM{\hh, \vi, \txid, \extopset} 
                       %\land \cu' = \updV{\hh, \vi, \extopset} 
                       %\land (\hh',\vi') \in \eraseW{\w'} \\
                        %\quad \land (\w, \w') \in \Guar  
                        %\land (\w, \w') \in \como
                        %\land \w' \in \evalW{\gpost}			
		%\end{array}	
%%		\right)			        	
    %\end{array} 
%\]
%}

%The \( \HHupdate \) and \( \Vupdate \) in the repartition can be replaced by syntactic rules.

%\begin{figure}
%\hrule\vspace{5pt}

%\[
   %\infer[\rl{FInit}]{%
       %\tripleF{ \lexpr \pt \lexpr }{ \lexpr \fpI \lexpr }{ \lexpr \pt \lexpr }
   %}{}
%\]

%\[
   %\infer[\rl{FRead}]{%
       %\tripleF{ \lexpr \pt \lexpr }{ \lexpr \fpR \lexpr }{ \lexpr \pt \lexpr }
   %}{}
%\]

%\[
   %\infer[\rl{FWrite}]{%
       %\tripleF{ \lexpr \pt \lexpr  }{  \lexpr \fpW \lexpr' }{ \lexpr \pt \lexpr' }
   %}{}
%\]

%\[
   %\infer[\rl{FReWrt}]{%
       %\tripleF{ \lexpr \pt \lexpr  }{  \lexpr \fpRW (\lexpr,\lexpr') }{ \lexpr \pt \lexpr' }
   %}{}
%\]

%\[
   %\infer[\rl{FFrame}]{%
       %\tripleF{ \bar{\lpre}_{1} \sep \bar{\lpre}_{2}  }{  \bar{\fp}_{1} \sep \bar{\fp}_{2} }{ \bar{\lpost}_{1} \sep \bar{\lpost}_{2} }
   %}{
       %\tripleF{ \bar{\lpre}_{1} }{ \bar{\fp}_{1} }{ \bar{\lpost}_{1} }
       %&& \tripleF{ \bar{\lpre}_{2}  }{ \bar{\fp}_{2} }{ \bar{\lpost}_{2} }
    %}
%\]


%\hrule\vspace{5pt}
%\caption{Syntactic rule for \( \HHupdate \) and \( \Vupdate \) functions}
%\label{fig:rule-prog}
%\end{figure}

