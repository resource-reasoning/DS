\subsection{Reasoning programs}

%\subsubsection{assertions}
\emph{Capabilities} (\cref{def:capabilities}) are used to specify the allowed operations on concurrent modules.
Each module is associated with \emph{client-specified capabilities} that forms \emph{a partial commutative monoid (PCM)}.
To recall, \emph{a PCM} is a partially ordered set that is closed under a commutative binary operation \( \compose \) and has a set of identify elements \( \unitelem \).
The client-specified capabilities are lifted to \emph{capability composition function} with their associated region identifiers.
For brevity, we often use \emph{capabilities} for \emph{capability composition function}.
The composition function for \emph{capabilities} \( \ca_l \composeC \ca_r \) is defined as point-wise compositing each region and the units \( \unitC \) are functions where regions map to units of client-specified capabilities.


\begin{definition}[Capabilities]
\label{def:capabilities}
Assume a \emph{partial commutative monoid (PCM)} of \emph{client-specified capabilities} \( (\Kaps, \composeK, \unitK) \) with \( \kap \in \Kaps \), the composition \( \composeK \) the units set \( \unitK \).
Then given a set of \emph{region identifiers} \( \rid \in \RegionID \), 
the \emph{capability composition function} or \emph{capabilities} \( \ca \in \Caps \defeq \RegionID \parfun \Kaps \), where the composition \( \composeC \) is defined as the follows:
\[
    \begin{rclarray}
        (\ca_{l} \composeC \ca_{r})(\rid) & \defeq  &
        \begin{cases}
            \ca_{l}(\rid) \composeK \ca_{r}(\rid) & \rid \in \dom(\ca_{l}) \cap \dom(\ca_{l}) \\
            \ca_{l}(\rid)  & \rid \in \dom(\ca_{l}) \setminus \dom(\ca_{l}) \\
            \ca_{r}(\rid) & \rid \in \dom(\ca_{r}) \setminus \dom(\ca_{l}) \\
            \text{undefined} & \text{otherwise} \\
        \end{cases}
    \end{rclarray}
\]
and the units set \( \unitC \defeq \Setcon{\ca}{\fora{\rid} \ca(\rid) \in \unitK } \) .
A capability assertion is in the form of \( \cass{\kap(\vec{\lvar})}{\lrid} \in \CAst \), where \( \kap(\vec{\lvar}) \) is a token parametrised by logical variables and \( \lrid \) is the region identifiers.
The capability assertion is interpreted to a capability in the model by interpreting all the logical expressions,
\[
\begin{rclarray}
    \evalC{\cass{\kap(\vec{\lvar})}{\lrid}} & \defeq & \Set{\lrid \mapsto \kap(\evalLE{\vec{\lvar}})} \\
\end{rclarray}
\]
\end{definition}

The \emph{capability assertions} are in the form of \( \cass{\kap(\vec{\lvar})}{\lrid} \) where \( \kap(\vec{\lvar}) \) is a syntactic capability and \( \lrid \) is a region identifier
They are interpreted to some capabilities by interpreting the syntactic capabilities \( \kap(\vec{\lvar}) \).:
They are resources that grant abilities to access the module, which we will explain later, or act as ghost resources to provide extra information about the module.

Each region is associated with a \emph{interference assertions} to specify how the region can evolve (\cref{def:intf}).
A action in the interference \( \exsts{\vec{\lvar}} \perm{\kap} : \bar{\fp} \) says if a client holds the capability \( \perm{\kap} \), it is allowed to commit a transaction that has the \emph{fingerprint with capabilities} \( \bar{\fp} \).
The existential quantification is for binding variables between the capability \( \kap \) and the assertions \( \bar{\fp}\).
The \emph{fingerprint with capabilities} \( \bar{fp} \) are fingerprint assertion (\cref{def:fingerprint}) extended with special one for transferring of capabilities, \ie adding to the shared state \( \fpA \cass{\kap}{\lrid} \), deleting from the shared state \( \fpD \cass{\kap}{\lrid} \) and updating the capabilities \( \cass{\kap(\vec{\lvar})}{\lrid} \fpU \cass{\kap(\vec{\lvar})}{\lrid} \). 
Those assertions \( \bar{\fp} \) are interpreted as quadruples of local snapshots \( \h \), fingerprints \( \opset \), capabilities that moves into the region \( \ca \) and capabilities that moves out of the region \( \ca' \).

\emph{Interference environment} also \emph{interference} is a function from \emph{client-specified capabilities} \( \kap \) to set of possible transitions over triples consisting of key-value stores, views, and (shared) capabilities. 
Given a fingerprint \( \bar{\fp} \) that is associated with \( \kap \) and any initial state \( (\hh, \vi, \ca_r \composeC \ca_f ) \) , the final states \( (\hh',\vi', \ca_f \composeC \ca_a) \) are defined by committing the fingerprint \( \opset \) through \( \HHupdate \) function, updating the view \( \vi \leq \vi' \), taking out \( \ca_r \) and adding \( \ca_a \).
Note that \( \ca_f \) are arbitrary frames of capabilities as long as they are compatible with the update.
All the read values should match to the versions with respect to the view \( \vi \).
For technical reasons, the view \( \vi' \) after updating is any view greater than before.

\begin{definition}[Interference]
\label{def:intf}
The \emph{fingerprint with capabilities transformation} is defined by the follows:
\[
\begin{rclarray}    
    \bar{\fp}, \bar{\fp}' & ::= & 
    \lexpr \fpI \lexpr 
    \mid \lexpr \fpR \lexpr 
    \mid \lexpr \fpW \lexpr 
    \mid \lexpr \fpRW (\lexpr, \lexpr) \\
    & & \mid \null \fpA \cass{\kap(\vec{\lvar})}{\lrid}  
    \mid \null \fpD \cass{\kap(\vec{\lvar})}{\lrid} 
    \mid \cass{\kap(\vec{\lvar})}{\lrid} \fpU \cass{\kap(\vec{\lvar})}{\lrid} 
    \mid \bar{\fp} \sep \bar{\fp}'
\end{rclarray}
\] 
Given a logical environment $\lenv \in \LEnv$, a stack $\stk \in \Stacks$ and the fingerprint interpretation function (\cref{def:fingerprint}), the \emph{fingerprint with capabilities transformation} is interpreted through function, $\evalF[(., .)]{.}: \FAst \times \LEnv \times \Stacks \parfun \Opsets \times \Caps \times \Caps$:
\[
\begin{rclarray}
    \evalF{ \bar{\fp} } & \defeq &
        \Setcon{(\opset, \ca, \ca')}{
            (\stub,\opset) \in \evalLS{\bar{\fp}} \land \ca, \ca' \in \unitC
        } \quad \text{where} \ \bar{\fp} \in \LAst \\
    \evalF{\null \fpA \cass{\kap(\vec{\lvar})}{\lrid} } & \defeq & 
        \Setcon{(\unitO, \ca, \ca')}{
            \ca = \evalC{\cass{\kap(\vec{\lvar})}{\lrid}} \land \ca' \in \unitC
        } \\
    \evalF{\null \fpD \cass{\kap(\vec{\lvar})}{\lrid} } & \defeq &
        \Setcon{(\unitO, \ca, \ca')}{
            \ca \in \unitC \land \ca'  = \evalC{\cass{\kap(\vec{\lvar})}{\lrid}} 
        } \\
    \evalF{\cass{\kap(\vec{\lvar})}{\lrid} \fpU \cass{\kap'(\vec{\lvar}')}{\lrid} } & \defeq &
        \Setcon{(\unitO, \ca, \ca')}{
            \ca = \evalC{\cass{\kap(\vec{\lvar})}{\lrid}} \land \ca'  = \evalC{\cass{\kap'(\vec{\lvar}')}{\lrid}} 
        } \\
    \evalF{\fp_{1} \sep \fp_{2}} & \defeq & \Setcon{ ( \opset_{1} \composeO \opset_{2}, \ca_{1} \composeC \ca_{2}, \ca'_{1} \composeC \ca'_{2} ) }{(\opset_{1}, \ca_{1}, \ca'_{1}) \in \evalF{\fp_{1}}  \land (\opset_{2}, \ca_{2}, \ca'_{2}) \in \evalF{\fp_{2}}}\\

\end{rclarray}
\]
The grammar of \emph{interference assertions}, \( \intass \in \IAst \), is defined as the follows:
\[
\begin{rclarray}
	\intass & ::=  & \emptyset \mid \Set{ \exsts{\vec{\lvar}} \perm{\kap} : \fp } \cup \intass 
\end{rclarray}
\]
The interference assertions are interpreted to \emph{interference environments} \( \intf \):
\[
\begin{rclarray}
    \inter \in \Interference & \defeq & \Kaps \to ( \HisHeaps \times \Views \times \Caps ) \times  ( \HisHeaps \times \Views \times \Caps )
\end{rclarray}
\]
The \emph{interference interpretation} function, $\evalI[(., .)]{.}: \IAst \times \LEnv \times \Stacks \to \Interference$, is defined as follows:
\sx{
    Notations are confused, there is different between syntactic \( \kap \) which can be parametrised by logical variables, and client-specified capabilities \( \kap' \).
    Fix the typesetting later.
    } 
\[
\begin{array}{@{}l}
	\evalI{\Set{ \exsts{\vec{\lvar}} \perm{\kap} : \fp } \cup \intass }(\kap') \eqdef \\
    	\quad \left\{ 
            \begin{array}{@{}l @{\qqquad} l}
            \multicolumn{2}{@{}l@{}}{
                    \Setcon{
                        \begin{B}
                            (\hh, \vi, \ca_r \composeC \ca_f ), \\ 
                            (\hh',\vi', \ca_f \composeC \ca_a)
                        \end{B}
                    }{ 
                        \exsts{\txid, \opset, \cl} 
                        ( \opset, \ca_{a}, \ca_{r} ) \in \evalF[\lenv',\stk]{\fp}
                        \land \txid \in \func{nextTxid}{\hh, \cl}  \\
                        \quad {} \land \hh' = \updM{\hh, \vi, \txid, \opset}  \\
                        \quad {} \land \pred{readFrom}{\hh, \vi, \opset} 
                        \land \vi' \geq \vi \\
                    } 
                    \cup \evalI{\intass}(\kap')%
            } \\
            & \text{if there exist a logical environment} \ \lenv' \ \text{by replacing} \ \vec{\lvar} \ \text{with some} \ \vec{\val} \ \text{\ie} \\ 
            & \lenv' = \lenv\rmto{\vec{\lvar}}{\vec{\val}}, \ \text{and under the new logical environment} \ \kap' = \evalI[\lenv', \stk]{\kap} \\
            \evalI{\intass}(\kap') 
            & \text{otherwise} \\
    	    \end{array}
        \right.  \\
\end{array}
\]
The \( \predn{readFrom} \) asserts the fingerprint makes sense with respect to the view:
\[
\begin{rclarray}
    \pred{readFrom}{\hh, \vi, \opset} & \defeq & \fora{\ke, \val} (\otR, \ke, \val) \in \opset \implies \valueOf(\hh(\ke,\vi(\ke))) = \val
\end{rclarray}
\]
\end{definition}

A \emph{world} \( \w \in \World \) (\cref{def:world}) is a pair of \emph{local capabilities} \( \ca \) (\cref{def:capabilities}) and \emph{a shared state} \( \gs \) in which regions are well-formed.
The shared state is a function from region identifiers to quadruples consisting of key-value stores, views, shared capabilities and interference.
The well-formed conditions for a world are:
(a) the key-value store from a region is disjointed with others, and satisfies the invariant of the region \( \mkvs \in \func{inv}{\rid, \intf}\); 
(b) the domain of the view in a region is the same as the domain of the key-value store, \ie they have the same keys; 
(c) the views should not be out of the range of key-value store;
(d) capabilities from regions and local capabilities are compatible;
and (e) there is no capability where region identifier never appear in the shared state.
In the \cref{def:world}, the \( \funcn{collapse} \) function gets rid of the region identifiers and composites the states point-wise:
\[
\begin{rclarray}
    \func{collapse}{\emptyset} & \defeq & \Set{(\unitHH, \unitVI, \unitC )} \\
    \func{collapse}{\Set{\rid \mapsto (\hh, \vi, \ca, \intf)} \uplus \gs } & \defeq & 
        \Setcon{ 
            (\hh \composeHH \hh', \vi \composeCU \vi', \ca \composeC \ca') 
        }{ 
            \land (\hh', \vi', \ca') \in \func{collapse}{\gs} }\\
\end{rclarray}
\] 
because of the well-formedness, we introduce the \emph{erase function} \( \eraseW{.} : \World \to \HisHeaps \times \Views \) that collapses a world to \emph{a unique pair of a key-value store and a view}:
\[
\begin{rclarray}
    \eraseW{\w} & \defeq & (\hh, \vi) \text{  where } (\hh, \vi, \stub) \in \func{collapse}{\w\projection{2}}\\
\end{rclarray}
\] 
Assuming a global function \( \funcn{init} : \RegionID \to \powerset{ \HisHeaps } \) returning initial key-value stores for regions,
the invariant of a region, written \( \func{inv}{\rid, \intf} \), is a set of key-value stores that is closed under the interference \( \intf \):
\[
\begin{array}[t]{@{}l}
    \func{init}{\rid} \in \func{inv}{\rid, \intf} \land 
    \fora{\mkvs, \mkvs'} 
    \exsts{\w, \w', \kap} \\
    \quad \mkvs \in \func{inv}{\rid, \intf} \land  ( \mkvs, \stub ) = \eraseW{\w} \land ( \mkvs', \stub ) = \eraseW{\w'} \land (\w, \w') \in \intf(\kap) \implies \mkvs' \in \func{inv}{\rid, \intf} 
\end{array}
\]

\begin{definition}[Worlds]
\label{def:invariant-region}
\label{def:world}
Given the set of key-value stores $\HisHeaps$ (\cref{def:his_heap}), views \( \Views \) (\cref{def:views}), capabilities \( \Caps\) (\cref{def:capabilities}) and region identifiers \( \RegionID \), the set of \emph{shared states} is \( \SStates \eqdef \RegionID \parfun \HisHeaps \times \Views \times \Caps \times \Interference \).
%Each region has its current state and the interference.
The \emph{shared state composition function}, $\composeS: \SStates \times \SStates \parfun \SStates$, is defined as $\composeS \eqdef \composeEq$, where for all domains $\sort M$ and all $m, m' \in \sort M$:
%
\[
\begin{rclarray}
	m \composeEq m' &  \eqdef  &
	\begin{cases}
		m & \text{if } m = m'\\
		\text{undefined} & \text{otherwise}
	\end{cases}
\end{rclarray}
\]
The set of \emph{worlds} is defined as the follows:
\[
\begin{rclarray}
	\world \in \World  & \eqdef & 
    \Setcon{
        (\ca, \gs) 
    }{ 
        \ca \in \Caps \land \gs \in \SStates
        \land \exsts{ \ca' } 
        (\stub, \stub, \ca') \in \func{collapse}{\gs} \\
        \quad {} \land \dom(\ca \composeC \ca') \subseteq \dom(\gs) 
        \land \fora{\rid}
        \exsts{\hh, \vi, \intf}  \\
        \qquad \gs(\rid) = (\hh, \vi, \stub, \intf) 
        \land \dom(\hh) = \dom(\vi) 
        \land \mkvs \in \func{inv}{\rid, \intf} \\
        \qquad {} \land \fora{ \addr \in \dom(\vi) }
        0 \leq \cu( \addr ) < \left| \hh(\addr) \right|
    }
\end{rclarray}
\]
% 
The \emph{world composition function}, $\composeW: \World \times \World \parfun \World$, is defined component-wise as: $\composeW \eqdef (\composeC, \composeS)$.
The \emph{world unit set} is $\unitW \eqdef \Setcon{(\ca, \gs)}{(\ca, \gs) \in \World \land \ca \in \unitC}$.
The \emph{partial commutative monoid of worlds} is $(\World, \composeW, \unitW)$.
\end{definition}

The \emph{program assertions} also \emph{assertions} (\cref{def:assertion}) have capability assertions \( \cass{\kap}{\lrid} \) for local capabilities, and \emph{shared region assertions} also known as \emph{boxed assertions} \( \boxass{\bar{\lpre}}{\lrid}{\intass} \) for the local views on the shared key-value stores.
Since the entire key-value store are shared, we do not have assertions related to key-value stores outside a box.

The assertions inside a box \( \bar{\lpre} \) are standard separation logic assertions plus capability assertions for shared capabilities and two types of single key assertions with different values, normal values \( \lexpr \) and underline values \( \luexpr \).
These two is to distinguish an up-to-date view on the key, which is represented by a normal value, or \emph{a potentially out-of-date view} by a underline value.
This is important as many consistency models have different constraints based on if the values is up-to-date.
The assertion that a key points to a up-to-date value, \( \lexpr_1 \pt \lexpr_2 \), is interpreted into any key-value store \( \mkvs \) and view \( \vi \) where the store has only one key \( \evalLE{\lexpr_1 }\) of which the last version has value \( \evalLE{\lexpr_2}\), and the view points to the last version.
The assertion with a underline value, \( \lexpr_1 \pt \luexpr_2 \), is interpreted to any key-value store and view where the view points to a version of key \( \evalLE{\lexpr_1 }\) in the store with value \( \evalLE{\lexpr_2}\).
The interpretation for the rest of \( \bar{\gpre} \) are standard.

Given \( \bar{\lpre} \) and its interpretation, a boxed assertion \( \boxass{\bar{\lpre}}{\lrid}{\intass} \) describes any shared state \( \gs \) where the state of the region \( \lrid \) satisfies the assertion \( \bar{\lpre} \).
Because the composition of worlds is defined when the shared states are identical, it means \( \boxass{\bar{\lpre}}{\lrid}{\intass} \sep \boxass{\bar{\lpost}}{\lrid}{\intass} \implies \boxass{\bar{\lpre} \land \bar{\lpost} }{\lrid}{\intass} \).

\begin{definition}[Assertions]
\label{def:assertion}
Given the set of logical expression \( \lexpr \in \LExpr\), the set of \emph{assertions}, $\gpre, \gpost \in \Ast$, are defined by the following inductive grammar:
\[
\begin{rclarray}
    \bar{\lpre}, \bar{\lpost} & ::= & \False \mid \True \mid \bar{\lpre} \land \bar{\lpost} \mid \bar{\lpre} \lor \bar{\lpost} \mid \exsts{\lvar} \bar{\lpre} \mid \bar{\lpre} \implies \bar{\lpost} \mid \assemp \mid \cass{\kap}{\lrid} \mid \lexpr \pt \lexpr \mid \lexpr \pt \luexpr \mid \bar{\lpre} \sep \bar{\lpost} \\
	\gpre , \gpost & ::= & \False \mid \True \mid \gpre \land \gpost \mid \gpre \lor \gpost \mid \exsts{\lvar}\gpre \mid \gpre \implies \gpost \mid \assemp \mid \cass{\kap}{\lrid} \mid \boxass{\bar{\lpre}}{\lrid}{\intass} \mid \gpre \sep \gpost \\
\end{rclarray}
\]
%
where $\lvar, \lrid \in \LVar$, $\lexpr_1, \lexpr_2 \in \LExpr$ (\cref{def:local_assertions}), $\kap \in \Kaps$ (\cref{def:capabilities}) and $\intass \in \IAst$ (\cref{def:intf}).
Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stacks$, the \emph{assertion interpretation} function, $\evalW[(., .)]{.}: \Ast \times \LEnv \times \Stacks \to \powerset{\World}$, is defined as follows:
%
\[
\begin{array}{@{} l @{\qquad} l @{}}
\begin{rclarray}
	\evalW{\False} & \defeq & \emptyset \\
	\evalW{\True} & \defeq & \World \\
	\evalW{\gpre \land \gpost} & \defeq & \evalW{\gpre} \cap \evalW{\gpost} \\
	\evalW{\gpre \lor \gpost} & \defeq & \evalW{\gpre} \cup \evalW{\gpost} \\ 
\end{rclarray} 
&
\begin{rclarray}
	\evalW{\exsts{\lvar}  \gpre} & \defeq & \bigcup\limits_{\val \in \textnormal{\Val}} \evalW[\lenv\remapsto{\lvar}{\val}, \stk]{\gpre} \\
	\evalW{\gpre \implies \gpost} & \defeq & \Setcon{\w}{\w \in \evalW{\gpre} \implies \w \in \evalW{\gpost}} \\
	\evalW{\emp} & \defeq & \unitW \\
	\evalW{\cass{\kap}{\lrid}} & \defeq & \Setcon{ (\Set{\lrid \mapsto \evalI{\kap}}, \gs) }{\gs \in \SStates} \\
\end{rclarray}  
\\
\multicolumn{2}{@{}l@{}}{%
\begin{rclarray}
	\evalW{ \boxass{\bar{\lpre}}{\lrid}{\intass} } & \defeq & 
    \Setcon{
        (\ca, \gs)
    }{         
        \exsts{\hh, \vi, \ca'}
        \ca \in \unitC
        \land \gs(\lrid) = (\hh, \vi, \ca', \intf\evalI{\intass}) 
        \land (\hh, \vi, \ca') \in \evalAUX{\bar{\lpre}} 
    } \\
	\evalW{ \gpre \sep \gpost } & \defeq & 
	\Setcon{
	   (\world_1 \composeW \world_2) 
    }{
       \world_1 \in \evalW{\gpre} \land \world_2 \in \evalW{\gpost}
	} \\
\end{rclarray}%
} \\
\end{array}
\]
The function \( \evalAUX[(., .)]{.} \) evaluates the assertions inside a box:
\[
\begin{array}{@{} l @{\qquad} l @{}}
\begin{rclarray}
    \evalAUX{\assfalse} & \defeq & \emptyset \\
    \evalAUX{\asstrue} & \defeq & \HisHeaps \times \Views \times \Caps \\
    \evalAUX{\bar{\lpre} \land \bar{\lpost}} & \defeq & \evalAUX{\bar{\lpre}} \cap \evalAUX{\bar{\lpost}} \\ 
    \evalAUX{\bar{\lpre} \lor \bar{\lpost}} & \defeq & \evalAUX{\bar{\lpre}} \cup \evalAUX{\bar{\lpost}} \\ 
\end{rclarray} 
&
\begin{rclarray}
    \evalAUX{\exsts{\lvar} \bar{\lpre}} & \defeq & \bigcup\limits_{\val \in \Val} \evalAUX[\lenv\rmto{\lvar}{\val}, \stk]{\bar{\lpre}} \\
    \evalAUX{\bar{\lpre} \implies \bar{\lpost}} & \defeq & \Setcon{ (\hh, \vi, \ca) }{ (\hh, \vi, \ca) \in \evalAUX{\bar{\lpre}} \\ \quad \implies (\hh, \vi, \ca) \in \evalAUX{\bar{\lpost}} }\\
    \evalAUX{\assemp} & \defeq & \Setcon{ (\unitHH, \unitVI, \ca) }{\ca \in \unitC } \\
\end{rclarray}
\\
\multicolumn{2}{@{}l@{}}{%
\begin{rclarray}
    \evalAUX{\cass{\kap}{\lrid}} & \defeq & \Set{ (\unitHH, \unitVI, \Set{\lrid \mapsto \evalC{\kap}}) }\\
    \evalAUX{\lexpr_{1} \pt \lexpr_2} & \defeq & 
    \Setcon{ (\hh, \vi, \ca) }{%
        \exsts{\ke = \evalLE{\lexpr_{1}}} \\
        \quad \Set{ \ke \mapsto \evalLE{\lexpr_{2}} } = \clpsHH{\hh, \vi} 
        \land \vi(\ke) = \lvert \mkvs(\ke) \rvert - 1 \land \ca \in \unitC
    } \\
    \evalAUX{\lexpr_{1} \pt \luexpr_2} & \defeq & \Setcon{ (\hh, \vi, \ca) }{ \Set{ \evalLE{\lexpr_{1}} \mapsto \evalLE{\luexpr_{1}} } = \clpsHH{\hh, \vi} \land \ca \in \unitC } \\
    \evalAUX{\bar{\lpre} \sep \bar{\lpost}} & \defeq & 
    \Setcon{ (\hh \composeHH \hh', \vi \composeVI \vi', \ca \composeC \ca') }{ (\hh, \vi, \ca) \in \evalAUX{\bar{\lpre}} \land (\hh', \vi', \ca') \in \evalAUX{\bar{\lpost}} } \\
\end{rclarray}%
} \\
\end{array}
\]
\end{definition}


%\subsubsection{Rely and Guarantee}

The \emph{rely} and \emph{guarantee} describes the world transformation for the environment and for the current client (\cref{def:rely-guarantee}).
To recall, a world includes local capabilities and a shared state, and a shared state is a client's view for the key-value store.
The \emph{rely} \( \Rely \) is a set of pairs on worlds, describing how the environment can change the state of the key-value store.
Given the local capabilities \( \ca_l \), the environment might own any capabilities \( \ca_e\) that is compatible, \ie \( (\ca_l \composeC \ca_e)\isdef \).
Therefore, the environment can perform actions associated with the their capabilities \( \ca_e \) with their own view \( \vi_e \) to update the key-value store and shared capabilities.
For technical reasons, even though the environment cannot change the view of the current client \( \vi_r\), but it is allowed to arbitrarily shift to the later versions due to the fact that for certain execution tests, the old view might be valid under the new key-value store.

The \emph{guarantee} \( \Guar \) describes the allowed actions for the current client.
The current client can perform actions associated with the local capabilities \( \ca_l \) to update the shared state and the local capabilities.
Yet it should ensure no resource created or deleted by requiring the \emph{orthogonal} of local capabilities and shared capabilities together remains unchanged.
The orthogonal of local capabilities \( \ca \) is a set of capabilities that are compatible with the local capabilities \( \ca \).
This constraint disallow any creation and deletion for capabilities, but it allows to update capabilities.
Note that in the rely and guarantee, it is allowed to update several regions, but each region can be updated at most once.
\begin{definition}[Rely and guarantee]
\label{def:rely-guarantee}
Given the set of worlds $\World$ (\cref{def:world}), the \emph{update rely} relation, $\relyU \subseteq \World \times \World$, is defined as follows:
\sx{In case I get confused again, it is world to world so the shared and local capabilities should always make sense.}
\[	
    \begin{rclarray}
	\relyU & \eqdef &
	\Setcon{
		((\ca_l,\gs), (\ca_l, \gs'))	
	}{
        \exsts{\ca_e}
        (\ca_e \composeC \ca_l) \isdef
        \land \fora{\rid}
        \gs(\rid) = \gs'(\rid) \lor 
        \exsts{\kap, \hh, \hh', \vi_\rid, \vi_{\rid}', \vi_{e}, \vi_{e}', \ca_\rid, \ca_{\rid}', \intf}   \\
        \quad \gs(\rid) = (\hh, \vi_\rid, \ca_\rid, \intf)
        \land \gs'(\rid) = (\hh', \vi_{\rid}', \ca_{\rid}',\intf) \\
        \quad {} \land \kap \sqsubseteq \ca_{e}(\rid) 
        \land ( (\hh, \vi_e, \ca_e), (\hh', \vi_{e}', \ca_{e}') )  \in \intf(\kap)
        \land \vi_{\rid}' \geq \vi_\rid
	} \\
    \end{rclarray}
\]
The \emph{view shift rely} relation $\relyV \subseteq \World \times \World$, is defined as follows:
\[
    \begin{rclarray}
	\relyV & \eqdef &
	\Setcon{
		((\ca_l,\gs), (\ca_l, \gs'))	
	}{
        \exsts{\ca_e}
        (\ca_e \composeC \ca_l) \isdef
        \land \fora{\rid}
        \gs(\rid) = \gs'(\rid) \lor 
        \exsts{\hh, \vi, \vi'\ca, \ca, \intf}   \\
        \quad \gs(\rid) = (\hh, \vi, \ca, \intf)
        \land \gs'(\rid) = (\hh, \vi', \ca, \intf) 
	} \\
    \end{rclarray}
\]
The \emph{rely} relation is transitive closure of updates and view shift: \( \Rely = (\relyU \cup \relyV)^{*} \).
The \emph{guarantee} relation, $\Guar: \World \times \World$, is defined as follows:
\[	
    \begin{rclarray}
	\Guar & \eqdef &
	\Setcon{
		((\ca_l,\gs), (\ca_{l}', \gs'))	
	}{
        \fora{\rid}
        \gs(\rid) = \gs'(\rid) \lor {}
        \exsts{\kap, \hh, \hh', \vi_\rid, \vi_{\rid}', \ca_\rid, \ca_{\rid}', \intf}   \\
        \quad \gs(\rid) = (\hh, \vi_\rid, \ca_\rid,\intf)
        \land \gs'(\rid) = (\hh', \vi_{\rid}', \ca_{\rid}',\intf) 
        \land \kap \sqsubseteq \ca_{l}(\rid)  \\
        \quad {} \land ( (\hh, \vi_\rid, \ca_\rid), (\hh', \vi_{\rid}', \ca_{\rid}') )  \in \intf(\kap)
        \land (\ca_{l} \composeC \ca_\rid)^{\perp} = (\ca_{l}' \composeC \ca_{\rid}')^{\perp}
	} \\
    \end{rclarray}
\]
where for any element \( m \) from its domain \( \sort{M} \), the  \emph{orthogonal} is defined as:
\[
\begin{rclarray}
m^{\perp} & \defeq & \Setcon{m'}{(m \compose{} m')\isdef \land m' \in \sort{M}} 
\end{rclarray}
\]
\end{definition}

Assertions are \emph{stable} if they remain true against the environment.
Formally speaking, a set of worlds \( \setworld \) is stable under certain execution tests \( \et \) if the set is closed under rely relation \( (\w, \w') \in \Rely \) with the side conditions:
(a) the transformation of key-value stores is allowed by the execution tests \( (\mkvs, \mkvs') \in \et \), which means there is a view from environment that executes some fingerprints allowed by the execution test;
and (b) the new view under the new key-value store is able to progress, \ie \( \eraseW{\w} \csat \unitO :  \vi' \).
The update is allowed by the execution test \( (\mkvs, \mkvs') \in \et \) iff there exist a view \( \vi \) and fingerprint \( \opset \) allowed by the execution test:
\[
    \begin{rclarray}
        (\hh, \hh') \in \como & \eqdef & 
        \begin{array}[t]{@{}l}
            \hh = \hh' \lor 
            \exsts{ \vi, \vi', \opset, \txid, \cl}  \\
            \quad (\hh, \vi) \csat \opset : \vi' 
            \land \txid \in \fresh{\hh, \cl} 
            \land \hh'  = \updM{\hh,\vi, \txid, \opset}
        \end{array}
    \end{rclarray}
\]
The progress condition is more subtle, as under the new view it at least allows to execute a \emph{dummy transaction}, \ie a transaction with empty fingerprint.
It ensures under serialisibility the new view is up-to-date while for most weaker consistency models, it usually guarantees \emph{atomic read}.

\begin{definition}[Stable]
\label{def:stable}
A set of worlds $\setworld \subseteq \World$ is \emph{stable}, written $\stable{\setworld, \como}$, if and only if it is closed under the rely relation: 
\[
    \begin{rclarray}
        \stable{\setworld, \como} & \eqdef & 
        \begin{array}[t]{@{}l}
            \fora{\w, \w'} 
            \w \in \setworld 
            \land (\w, \w') \in \Rely  
            \land \exsts{\hh, \hh', \vi, \opset} \\
            \quad (\hh, \stub) = \eraseW{\w}
            \land (\hh', \stub) = \eraseW{\w'} 
            \land (\hh, \hh') \in \como 
            \land \eraseW{\w'} \csat \unitO :  \vi \\
            \qqquad \implies \w' \in \setworld
        \end{array} \\
    \end{rclarray}
\]
\end{definition}


%\subsubsection{Rules for Global}

The triple \( \tripleG{\gpre}{\prog}{\gpost} \) asserts given any state satisfying the precondition \( \gpre \), if the program \( \prog \) terminates under the execution test \( \et \), the state after satisfies the postcondition \( \gpost \).
The \rl{PRCommit} rule (\cref{fig:rule-prog} commits the local effect of a transaction \( \trans \) to key-value store, which is the key rule of the logic.
We generalise the \emph{repartitioning} from CAP.
The repartitioning \( \repartition{\gpre}{\gpost}{\lpre}{\lpost} \) means:
\begin{itemize}
\item
for any possible worlds \( \w \) from the precondition \( \gpre \), there exist some snapshots of those worlds satisfying the transactional precondition \( \lpre \);
\item
for any possible fingerprints  \( \fp \), there exists a world \( \w' \) satisfying the postcondition \( \gpost \), such that:
\begin{itemize}
\item 
the key-value store in the new world \( \eraseW{\w'}\projection{1} \) is updated from the previous one by committing the fingerprints \( \fp \);
\item
the new view \( \eraseW{\w'}\projection{2} \) is picked so that the overall update passes the execution test \( \eraseW{\w} \csat \opset : \eraseW{\w'}\projection{2} \);
\item
and, the update is allowed by the guarantee \( (\w, \w') \in \Guar\).
\end{itemize}
\end{itemize}


\begin{figure}[t!]
\hrule\vspace{5pt}

\begin{mathpar}
    \inferrule[\rl{PRCommit}]{%
        \tripleL{\lpre}{\trans}{\lpost} 
        \\ \repartition{\gpre}{\gpost}{\lpre}{\lpost}
        \\\\ \stable{\gpre, \como} 
        \\ \stable{\gpost, \como} 
    }{%
        \tripleG{\gpre}{ \ptrans{\trans} }{\gpost}
    }
    \and
    \inferrule[\rl{PRPar}]{%
        \tripleG{ \gpre_{1} }{ \cmd_{1} }{ \gpost_{1} }
        \\ \tripleG{ \gpre_{2} }{ \cmd_{2} }{ \gpost_{2} } 
        \\\\ \stable{\gpre_{1}, \como} 
        \\ \stable{\gpre_{2}, \como} 
    }{%
        \tripleG{ \gpre_{1} \sep \gpre_{2} }{ \cmd_{1} \ppar \cmd_{2} }{ \gpost_{1} \sep \gpost_{2} }
    }
    \and
    \inferrule[\rl{PRAss}]{%
        \thvar \notin \func{fv}{\lexpr} 
    }{%
        \tripleG{\thvar \dot= \lexpr }{ \pass{\thvar}{\expr} }{\thvar \dot= \expr\sub{\thvar}{\lexpr} }
    }
    \and
    \inferrule[\rl{PRAssume}]{ }{%
        \tripleG{ \expr \dot\neq 0 }{ \passume{\expr} }{ \expr \dot\neq 0 } 
    }
    \and
    \inferrule[\rl{PRChoice}]{%
        \tripleG{ \gpre }{ \cmd_{1} }{ \gpost } 
        \\ \tripleG{ \gpre }{ \cmd_{2} }{ \gpost } 
    }{%
        \tripleG{ \gpre }{ \cmd_{1} \pchoice \cmd_{2} }{ \gpost }
    }
    \and
    \inferrule[\rl{PRSeq}]{%
        \tripleG{ \gpre }{ \cmd_{1} }{ \gframe }
        \\ \tripleG{ \gframe }{ \cmd_{2} }{ \gpost }
    }{%
        \tripleG{ \gpre }{ \cmd_{1} \pseq \cmd_{2} }{ \gpost }
    }
    \and
    \inferrule[\rl{PRIter}]{%
        \tripleG{ \gpre }{ \cmd }{ \gpre } 
    }{%
        \tripleG{ \gpre }{ \cmd\prepeat }{ \gpre }
    }
    \and
    \inferrule[\rl{PRFrame}]{%
        \tripleG{ \gpre }{ \cmd }{ \gpost } 
        \\ \stable{\gframe, \como}
        \\ \func{fv}{\gframe} \cap \func{modify}{\cmd} = \emptyset 
    }{%
        \tripleG{ \gpre \sep \gframe }{ \cmd }{ \gpost \sep \gframe }
    }
\end{mathpar}


\hrule\vspace{5pt}
\[
\begin{rclarray}
    \repartition{\gpre}{\gpost}{\lpre}{\lpost} & \defeq & 
    \begin{array}[t]{@{}l@{}}
        \fora{ \w, \lenv, \stk } 
        \w \in \evalW{\gpre} 
        \implies 
        (\getSN{\eraseW{\w}}, \unitO) \in \evalLS{\lpre}  \\
        \quad {} \land \fora{\stk', \txid, \opset, \w', \cl} 
        \txid \in \fresh{\eraseW{\w}\projection{1}, \cl} 
        \land (\stub, \opset) \in \evalLS[\lenv, \stk']{\lpost} \\
        \qquad {} \land \eraseW{\w'}\projection{1} = \updM{\eraseW{\w}, \txid, \opset}  \\
        %\land \eraseW{\w}\projection{2} \leq \eraseW{\w'}\projection{2} \\
        \qquad {} \land \eraseW{\w} \csat \opset : \eraseW{\w'}\projection{2}
        \land (\w, \w') \in \Guar
        \implies \w' \in \evalW[\lenv, \stk']{\gpost}
    \end{array} 
\end{rclarray}                          
\]

\hrule\vspace{5pt}
\caption{The rules for programs}
\label{fig:rule-prog}
\end{figure}

%\azalea{
    %\sx{How to deal with the stack here? As the stack for P and Q are different, just for all quantify two stacks??}
%The quantification seems wrong. Especially, the $\extopset$ needs to be for all quantified, $\h$ needs to be there exist quantified.
%\[
     %\repartition{\gpre}{\gpost}{\lpre}{\lpost} \defeq 
     %\begin{array}[t]{@{}l@{}}
		 %\fora{\w, \hh, \vi, \lenv, \stk, \txid } 
            %\w \in \evalW{\gpre} 
            %\land (\hh, \cu) \in \eraseW{\w}
            %\Rightarrow\\
            %\quad \exsts{\h}
            %\begin{array}[t]{@{} l @{}}
			%\h = \getSN{\hh, \cu}  
                %\land (\h, \unitO) \in \evalLS{\lpre} \\
                %\land\, \fora{\extopset \in \evalF{\lpost}} 
                    %\exsts{\w', \hh', \vi'} \\
                        %\quad \hh' = \updM{\hh, \vi, \txid, \extopset} 
                       %\land \cu' = \updV{\hh, \vi, \extopset} 
                       %\land (\hh',\vi') \in \eraseW{\w'} \\
                        %\quad \land (\w, \w') \in \Guar  
                        %\land (\w, \w') \in \como
                        %\land \w' \in \evalW{\gpost}			
		%\end{array}	
%%		\right)			        	
    %\end{array} 
%\]
%}

%The \( \HHupdate \) and \( \Vupdate \) in the repartition can be replaced by syntactic rules.

%\begin{figure}
%\hrule\vspace{5pt}

%\[
   %\infer[\rl{FInit}]{%
       %\tripleF{ \lexpr \pt \lexpr }{ \lexpr \fpI \lexpr }{ \lexpr \pt \lexpr }
   %}{}
%\]

%\[
   %\infer[\rl{FRead}]{%
       %\tripleF{ \lexpr \pt \lexpr }{ \lexpr \fpR \lexpr }{ \lexpr \pt \lexpr }
   %}{}
%\]

%\[
   %\infer[\rl{FWrite}]{%
       %\tripleF{ \lexpr \pt \lexpr  }{  \lexpr \fpW \lexpr' }{ \lexpr \pt \lexpr' }
   %}{}
%\]

%\[
   %\infer[\rl{FReWrt}]{%
       %\tripleF{ \lexpr \pt \lexpr  }{  \lexpr \fpRW (\lexpr,\lexpr') }{ \lexpr \pt \lexpr' }
   %}{}
%\]

%\[
   %\infer[\rl{FFrame}]{%
       %\tripleF{ \bar{\lpre}_{1} \sep \bar{\lpre}_{2}  }{  \bar{\fp}_{1} \sep \bar{\fp}_{2} }{ \bar{\lpost}_{1} \sep \bar{\lpost}_{2} }
   %}{
       %\tripleF{ \bar{\lpre}_{1} }{ \bar{\fp}_{1} }{ \bar{\lpost}_{1} }
       %&& \tripleF{ \bar{\lpre}_{2}  }{ \bar{\fp}_{2} }{ \bar{\lpost}_{2} }
    %}
%\]


%\hrule\vspace{5pt}
%\caption{Syntactic rule for \( \HHupdate \) and \( \Vupdate \) functions}
%\label{fig:rule-prog}
%\end{figure}

