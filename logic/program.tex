\subsection{Reasoning programs}

%\subsubsection{assertions}
%\emph{Capabilities} (\cref{def:capabilities}) are used to specify the allowed operations on concurrent modules.
Each module is associated with \emph{client-specified capabilities} \( \kap \in \Kaps \) that forms \emph{a partial commutative monoid (PCM)}.
To recall, \emph{a PCM} is a partially ordered set that is closed under a commutative binary operation \( \compose \) and has a set of identify elements \( \unitelem \).
The client-specified capabilities are lifted to \emph{capability composition function} \( \ca \in \Caps \) with their associated region identifiers.
For brevity, we often use \emph{capabilities} for \emph{capability composition function}.
The composition function for \emph{capabilities} \( \ca_l \composeC \ca_r \) is defined as compositing each region point-wise and the units \( \unitC \) are functions where regions map to units of client-specified capabilities.


\begin{definition}[Capabilities]
\label{def:capabilities}
Assume a \emph{partial commutative monoid (PCM)} of \emph{client-specified capabilities} \( (\Kaps, \composeK, \unitK) \) with \( \kap \in \Kaps \), the composition \( \composeK \) the units set \( \unitK \).
Then given a set of \emph{region identifiers} \( \rid, \lrid \in \RegionID \), 
the \emph{capability composition function} or \emph{capabilities} \( \ca \in \Caps \defeq \RegionID \parfun \Kaps \), where the composition \( \composeC \) is defined as the follows:
\[
    \begin{rclarray}
        (\ca_{l} \composeC \ca_{r})(\rid) & \defeq  &
        \begin{cases}
            \ca_{l}(\rid) \composeK \ca_{r}(\rid) & \rid \in \dom(\ca_{l}) \cap \dom(\ca_{l}) \\
            \ca_{l}(\rid)  & \rid \in \dom(\ca_{l}) \setminus \dom(\ca_{l}) \\
            \ca_{r}(\rid) & \rid \in \dom(\ca_{r}) \setminus \dom(\ca_{l}) \\
            \text{undefined} & \text{otherwise} \\
        \end{cases}
    \end{rclarray}
\]
and the units set \( \unitC \defeq \Setcon{\ca}{\fora{\rid} \ca(\rid) \in \unitK } \) .
A capability assertion is in the form of \( \cass{\kap(\vec{\lvar})}{\lrid} \in \CAst \), which is interpreted to a capability in the model:
\[
\begin{rclarray}
    \evalC{\cass{\kap(\vec{\lvar})}{\lrid}} & \defeq & \Set{\lrid \mapsto \kap(\evalLE{\vec{\lvar}})} \\
\end{rclarray}
\]
\end{definition}

The \emph{capability assertions} are in the form of \( \cass{\kap(\vec{\lvar})}{\lrid} \) where \( \kap(\vec{\lvar}) \) is a syntactic capability and \( \lrid \) is a region identifier.
They are interpreted to some capabilities \( \Caps \) by interpreting the syntactic capabilities \( \kap(\vec{\lvar}) \).

Capabilities are resources that grant abilities to access the module.
That is, certain capabilities are associated with some operations, which we will explain together with \emph{interference} (\cref{def:intf}),
and if a client holds those capabilities, it is allowed to perform those operations.
Capabilities can be used as ghost resources to track extra information and/or build protocols between clients.

Each boxed assertion is associated with a \emph{interference assertions} to specify how the region can evolve (\cref{def:intf}).
\emph{A action} in the interference \( \exsts{\vec{\lvar}} \perm{\kap} : \bar{\fp} \) says if a client holds the capability \( \perm{\kap} \), it is allowed to change the region with respect to \( \bar{\fp} \).
The \emph{fingerprint and capability transferring assertions} \( \bar{\fp} \) are fingerprint assertion (\cref{def:fingerprint}) extended with assertions for transferring of capabilities, \ie adding to the shared region \( \fpA \cass{\kap}{\lrid} \), deleting from the shared region \( \fpD \cass{\kap}{\lrid} \) and updating the shared capabilities \( \cass{\kap(\vec{\lvar})}{\lrid} \fpU \cass{\kap(\vec{\lvar})}{\lrid} \). 
Those assertions \( \bar{\fp} \) are interpreted as triples \( ( \fp, \ca, \ca' ) \) of fingerprints \( \opset \), capabilities that moves into the region \( \ca \) and capabilities that moves out of the region \( \ca' \).
The existential quantification is for binding variables between the capability \( \kap \) and the assertions \( \bar{\fp}\).

\emph{Interference assertions} are interpreted to \emph{Interference environment}, \( \intf \in \Interference \) (\cref{def:intf}).
\emph{Interference environment} also \emph{interference} is a function from \emph{client-specified capabilities} \( \kap \) to set of possible transitions over triples consisting of key-value stores, views, and (shared) capabilities. 
Given a action \( \exsts{\vec{\lvar}} \perm{\kap} : \bar{\fp} \) and any initial state \( (\hh, \vi, \ca_r \composeC \ca_f ) \) , the final states \( (\hh',\vi', \ca_f \composeC \ca_a) \) are defined by committing the fingerprint \( \opset \) through \( \HHupdate \) function, updating the view \( \vi \leq \vi' \), taking out \( \ca_r \) and adding \( \ca_a \), where \( (\fp, \ca_d, \ca_a) \in \evalF[\lenv',\stk]{\bar{\fp}} \).
Note that \( \ca_f \) are arbitrary frames of capabilities as long as they are compatible with the update.
All the read values should match to the versions with respect to the view \( \vi \).
For technical reasons, the view \( \vi' \) after updating is any view greater than before.

\begin{definition}[Interference]
\label{def:intf}
The \emph{fingerprint and capability transferring assertions} is defined as:
\[
\begin{rclarray}    
    \bar{\fp}, \bar{\fp}' & ::= & 
    %\lexpr \fpI \lexpr 
    %\mid 
    \lexpr \fpR \lexpr 
    \mid \lexpr \fpW \lexpr 
    \mid \lexpr \fpRW (\lexpr, \lexpr)
    \mid \null \fpA \cass{\kap(\vec{\lvar})}{\lrid}  
    \mid \null \fpD \cass{\kap(\vec{\lvar})}{\lrid} 
    \mid \cass{\kap(\vec{\lvar})}{\lrid} \fpU \cass{\kap(\vec{\lvar})}{\lrid} 
    \mid \bar{\fp} \sep \bar{\fp}'
\end{rclarray}
\] 
Given a logical environment $\lenv \in \LEnv$ (\cref{def:local_assertions}), a stack $\stk \in \Stacks$ (\cref{def:stacks}) and the  interpretation function for transactional assertions \( \evalLS[(.,.)]{.} \) (\cref{def:fingerprint}), the \emph{fingerprint and capability transferring assertions} is interpreted through function, $\evalF[(., .)]{.}: \FAst \times \LEnv \times \Stacks \parfun \Opsets \times \Caps \times \Caps$:
\[
\begin{rclarray}
    \evalF{ \bar{\fp} } & \defeq &
        \Setcon{(\opset, \ca, \ca')}{
            (\stub,\opset) \in \evalLS{\bar{\fp}} \land \ca, \ca' \in \unitC
        } \quad \text{where} \ \bar{\fp} \in \LAst \\
    \evalF{\null \fpA \cass{\kap(\vec{\lvar})}{\lrid} } & \defeq & 
        \Setcon{(\unitO, \ca, \ca')}{
            \ca = \evalC{\cass{\kap(\vec{\lvar})}{\lrid}} \land \ca' \in \unitC
        } \\
    \evalF{\null \fpD \cass{\kap(\vec{\lvar})}{\lrid} } & \defeq &
        \Setcon{(\unitO, \ca, \ca')}{
            \ca \in \unitC \land \ca'  = \evalC{\cass{\kap(\vec{\lvar})}{\lrid}} 
        } \\
    \evalF{\cass{\kap(\vec{\lvar})}{\lrid} \fpU \cass{\kap'(\vec{\lvar}')}{\lrid} } & \defeq &
        \Setcon{(\unitO, \ca, \ca')}{
            \ca = \evalC{\cass{\kap(\vec{\lvar})}{\lrid}} \land \ca'  = \evalC{\cass{\kap'(\vec{\lvar}')}{\lrid}} 
        } \\
    \evalF{\fp_{1} \sep \fp_{2}} & \defeq & \Setcon{ ( \opset_{1} \composeO \opset_{2}, \ca_{1} \composeC \ca_{2}, \ca'_{1} \composeC \ca'_{2} ) }{(\opset_{1}, \ca_{1}, \ca'_{1}) \in \evalF{\fp_{1}}  \land (\opset_{2}, \ca_{2}, \ca'_{2}) \in \evalF{\fp_{2}}}\\

\end{rclarray}
\]
The grammar of \emph{interference assertions}, \( \intass \in \IAst \), is defined as the follows:
\[
\begin{rclarray}
	\intass & ::=  & \emptyset \mid \Set{ \exsts{\vec{\lvar}} \perm{\kap} : \fp } \cup \intass 
\end{rclarray}
\]
The interference assertions are interpreted to \emph{interference environments} \( \intf \):
\[
\begin{rclarray}
    \inter \in \Interference & \defeq & \Kaps \to ( \HisHeaps \times \Views \times \Caps ) \times  ( \HisHeaps \times \Views \times \Caps )
\end{rclarray}
\]
The \emph{interference interpretation} function, $\evalI[(., .)]{.}: \IAst \times \LEnv \times \Stacks \to \Interference$, is defined as follows:
%\sx{
    %Notations are confused, there is different between syntactic \( \kap \) which can be parametrised by logical variables, and client-specified capabilities \( \kap' \).
    %Fix the typesetting later.
    %} 
\[
\begin{array}{@{}l}
	\evalI{\Set{ \exsts{\vec{\lvar}} \perm{\kap} : \fp } \cup \intass }(\kap') \eqdef \\
    	\quad \left\{ 
            \begin{array}{@{}l @{\qqquad} l}
            \multicolumn{2}{@{}l@{}}{
                    \Setcon{
                        \begin{B}
                            (\hh, \vi, \ca_r \composeC \ca_f ), \\ 
                            (\hh',\vi', \ca_f \composeC \ca_a)
                        \end{B}
                    }{ 
                        \pred{atomic}{\hh, \vi} 
                        \land \exsts{\txid, \opset, \cl} 
                        ( \opset, \ca_{a}, \ca_{r} ) \in \evalF[\lenv',\stk]{\fp} \\
                        \quad {} \land \txid \in \func{nextTxid}{\hh, \cl}
                        \land \hh' = \updM{\hh, \vi, \txid, \opset}  \\
                        \quad {} \land \pred{readFrom}{\hh, \vi, \opset} 
                        \land \vi' \geq \vi 
                        \land \pred{atomic}{\hh', \vi'}
                        \\
                    } 
                    \cup \evalI{\intass}(\kap')%
            } \\
            & \text{if there exist a logical environment} \ \lenv' \ \text{by replacing} \ \vec{\lvar} \ \text{with some} \ \vec{\val} \ \text{\ie} \\ 
            & \lenv' = \lenv\rmto{\vec{\lvar}}{\vec{\val}}, \ \text{and under the new logical environment} \ \kap' = \evalI[\lenv', \stk]{\kap} \\
            \evalI{\intass}(\kap') 
            & \text{otherwise} \\
    	    \end{array}
        \right.  \\
\end{array}
\]
\sx{maybe put readfrom as a side condition to the updateMKVS }
The \( \predn{readFrom} \) asserts the fingerprint makes sense with respect to the view:
\[
\begin{rclarray}
    \pred{readFrom}{\hh, \vi, \opset} & \defeq & \fora{\ke, \val} (\otR, \ke, \val) \in \opset \implies \valueOf(\hh(\ke,\vi(\ke))) = \val
\end{rclarray}
\]
\end{definition}

A \emph{world} \( \w \in \World \) (\cref{def:world}) is a pair of \emph{local capabilities} \( \ca \) (\cref{def:capabilities}) and \emph{a shared state} \( \gs \).
The shared state is a function from region identifiers to quadruples consisting of key-value stores, views, shared capabilities and interference environment.
The well-formed conditions for a world are:
(a) the state of every region \( (\mkvs, \vi, \ca'') \) is disjointed with each others, and satisfies the invariant of the region \( (\mkvs, \vi, \ca'') \in \func{inv}{\rid, \intf}\); 
(b) the domain of the view in a region is the same as the domain of the key-value store, \ie they have exactly the same keys; 
(c) the view should not be out of the range of the key-value store;
(d) capabilities from regions and local capabilities are compatible;
and (e) there is no capability of which the region identifier never appears in the shared state.
In the \cref{def:world}, the \( \funcn{collapse} \) function gets rid of the region identifiers and composites the states point-wise.
Because of the well-formedness, we introduce the \emph{erase function} \( \eraseW{.} : \World \to \HisHeaps \times \Views \) that collapses a world to \emph{a unique pair of a key-value store and a view}:
\[
\begin{rclarray}
    \eraseW{\w} & \defeq & (\hh, \vi) \text{  where } (\hh, \vi, \stub) \in \func{collapse}{\w\projection{2}}\\
\end{rclarray}
\] 

\begin{definition}[Worlds]
\label{def:invariant-region}
\label{def:world}
Given the set of key-value stores $\HisHeaps$ (\cref{def:his_heap}), views \( \Views \) (\cref{def:views}), capabilities \( \Caps\) (\cref{def:capabilities}) and region identifiers \( \RegionID \), the set of \emph{shared states} is \( \SStates \eqdef \RegionID \parfun \HisHeaps \times \Views \times \Caps \times \Interference \).
%Each region has its current state and the interference.
The \emph{shared state composition function}, $\composeS: \SStates \times \SStates \parfun \SStates$, is defined as $\composeS \eqdef \composeEq$, where for all domains $\sort M$ and all $m, m' \in \sort M$:
%
\[
\begin{rclarray}
	m \composeEq m' &  \eqdef  &
	\begin{cases}
		m & \text{if } m = m'\\
		\text{undefined} & \text{otherwise}
	\end{cases}
\end{rclarray}
\]
The set of \emph{worlds} \( \World \) is defined as the follows:
\[
\begin{rclarray}
	\world \in \World  & \eqdef & 
    \Setcon{
        (\ca, \gs) 
    }{ 
        \ca \in \Caps \land \gs \in \SStates
        \land \exsts{ \ca' } 
        (\stub, \stub, \ca') \in \func{collapse}{\gs} \\
        \quad {} \land \dom(\ca \composeC \ca') \subseteq \dom(\gs) 
        \land \fora{\rid \in \dom(\gs)}
        \exsts{\hh, \vi, \ca'', \intf}  \\
        \qquad \gs(\rid) = (\hh, \vi, \ca'', \intf) 
        \land \dom(\hh) = \dom(\vi) 
        \land ( \mkvs, \vi, \ca'' ) \in \func{inv}{\rid, \intf} \\
        \qquad {} \land \fora{ \addr \in \dom(\vi) }
        0 \leq \cu( \addr ) < \left| \hh(\addr) \right|
    }
\end{rclarray}
\]               
where \( \funcn{collapse}\) function is defined as the follows:
\[
\begin{rclarray}
    \func{collapse}{\emptyset} & \defeq & \Setcon{(\unitHH, \unitVI, \ca )}{ \ca \in \unitC } \\
    \func{collapse}{\Set{\rid \mapsto (\hh, \vi, \ca, \intf)} \uplus \gs } & \defeq & 
        \Setcon{ 
            (\hh \composeHH \hh', \vi \composeCU \vi', \ca \composeC \ca') 
        }{ 
            \land (\hh', \vi', \ca') \in \func{collapse}{\gs} }\\
\end{rclarray}
\] 
and assuming a global function \( \funcn{init} : \RegionID \to \HisHeaps \times \Views \times \Caps \) returning the initial state for a region,
the \( ( \mkvs, \vi, \ca ) \in \func{inv}{\rid, \intf} \) iff:
\[
\begin{array}[t]{@{}l}
    ( \mkvs, \vi, \ca ) = \func{init}{\rid} 
    \lor \exsts{\mkvs', \vi', \ca'}
    ( \mkvs' , \vi', \ca' ) \in \func{inv}{\rid, \intf} \land (( \mkvs' , \vi', \ca' ), ( \mkvs, \vi, \ca )) \in \intf(\kap) 
\end{array}
\]
% 
The \emph{world composition function}, $\composeW: \World \times \World \parfun \World$, is defined component-wise as: $\composeW \eqdef (\composeC, \composeS)$.
The \emph{world unit set} is $\unitW \eqdef \Setcon{(\ca, \gs)}{(\ca, \gs) \in \World \land \ca \in \unitC}$.
The \emph{partial commutative monoid of worlds} is $(\World, \composeW, \unitW)$.
\end{definition}

The \emph{program assertions} also \emph{assertions} (\cref{def:assertion}) have capability assertions \( \cass{\kap}{\lrid} \) for local capabilities, \emph{shared region assertions} also known as \emph{boxed assertions} \( \boxass{\bar{\lpre}}{\lrid}{\intass} \) for the shared states and other standard separation logic assertions.
We assume the entire key-value store are shared, so we do not have assertions related to key-value stores outside a box.

The assertions inside a box \( \bar{\lpre} \) have capability assertions for shared capabilities, two types of single key assertions with different values, normal values \( \lexpr \) and underline values \( \luexpr \) and standard separation logic assertions.
The two different single key assertions are to distinguish \emph{an up-to-date view} on the key represented by a normal value, or \emph{a potentially out-of-date view} by a underline value.
This is important as many consistency models have different constraints based on if the values is up-to-date.
Both up-to-date assertion \( \lexpr_1 \pt \lexpr_2 \)  potentially out-of-date assertion \( \lexpr_1 \pt \luexpr_2 \) are interpreted to any key-value store and view where the view points to a version of key \( \evalLE{\lexpr_1 }\) in the store with value \( \evalLE{\lexpr_2}\).
While the view  for \( \lexpr_1 \pt \lexpr_2 \) must points to the last version.
The interpretation for the rest of \( \bar{\gpre} \) are standard.

Given \( \bar{\lpre} \) and its interpretation, a boxed assertion \( \boxass{\bar{\lpre}}{\lrid}{\intass} \) is interpreted to any shared state \( \gs \) where the state of the region \( \lrid \) satisfies the assertion \( \bar{\lpre} \).
Because the composition of worlds is defined when the shared states are identical, it means \( \boxass{\bar{\lpre}}{\lrid}{\intass} \sep \boxass{\bar{\lpost}}{\lrid}{\intass} \implies \boxass{\bar{\lpre} \land \bar{\lpost} }{\lrid}{\intass} \).

\begin{definition}[Program assertions]
\label{def:assertion}
\label{def:prog-assertion}
Given the set of logical expression \( \lexpr \in \LExpr\), the set of \emph{program assertions}, $\gpre, \gpost \in \Ast$, are defined by the following inductive grammar:
\[
\begin{rclarray}
    \bar{\lpre}, \bar{\lpost} & ::= & \False \mid \True \mid \bar{\lpre} \land \bar{\lpost} \mid \bar{\lpre} \lor \bar{\lpost} \mid \exsts{\lvar} \bar{\lpre} \mid \bar{\lpre} \implies \bar{\lpost} \mid \assemp \mid \cass{\kap}{\lrid} \mid \lexpr \pt \lexpr \mid \lexpr \pt \luexpr \mid \bar{\lpre} \sep \bar{\lpost} \\
	\gpre , \gpost & ::= & \False \mid \True \mid \gpre \land \gpost \mid \gpre \lor \gpost \mid \exsts{\lvar}\gpre \mid \gpre \implies \gpost \mid \assemp \mid \cass{\kap}{\lrid} \mid \boxass{\bar{\lpre}}{\lrid}{\intass} \mid \gpre \sep \gpost \\
\end{rclarray}
\]
%
where $\lvar, \lrid \in \LVar$, $\lexpr_1, \lexpr_2 \in \LExpr$ (\cref{def:local_assertions}), $\kap \in \Kaps$ (\cref{def:capabilities}) and $\intass \in \IAst$ (\cref{def:intf}).
Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stacks$, the \emph{assertion interpretation} function, $\evalW[(., .)]{.}: \Ast \times \LEnv \times \Stacks \to \powerset{\World}$, is defined as follows:
%
\[
\begin{array}{@{} l @{\qquad} l @{}}
\begin{rclarray}
	\evalW{\False} & \defeq & \emptyset \\
	\evalW{\True} & \defeq & \World \\
	\evalW{\gpre \land \gpost} & \defeq & \evalW{\gpre} \cap \evalW{\gpost} \\
	\evalW{\gpre \lor \gpost} & \defeq & \evalW{\gpre} \cup \evalW{\gpost} \\ 
\end{rclarray} 
&
\begin{rclarray}
	\evalW{\exsts{\lvar}  \gpre} & \defeq & \bigcup\limits_{\val \in \textnormal{\Val}} \evalW[\lenv\remapsto{\lvar}{\val}, \stk]{\gpre} \\
	\evalW{\gpre \implies \gpost} & \defeq & \Setcon{\w}{\w \in \evalW{\gpre} \implies \w \in \evalW{\gpost}} \\
	\evalW{\emp} & \defeq & \unitW \\
	\evalW{\cass{\kap}{\lrid}} & \defeq & \Setcon{ (\Set{\lrid \mapsto \evalI{\kap}}, \gs) }{\gs \in \SStates} \\
\end{rclarray}  
\\
\\
\multicolumn{2}{@{}l@{}}{%
\begin{rclarray}
	\evalW{ \boxass{\bar{\lpre}}{\lrid}{\intass} } & \defeq & 
    \Setcon{
        (\ca, \gs)
    }{         
        \exsts{\hh, \vi, \ca'}
        \ca \in \unitC
        \land \gs(\lrid) = (\hh, \vi, \ca', \intf\evalI{\intass}) 
        \land (\hh, \vi, \ca') \in \evalAUX{\bar{\lpre}} 
    } \\
	\evalW{ \gpre \sep \gpost } & \defeq & 
	\Setcon{
	   (\world_1 \composeW \world_2) 
    }{
       \world_1 \in \evalW{\gpre} \land \world_2 \in \evalW{\gpost}
	} \\
\end{rclarray}%
} \\
\end{array}
\]
The function \( \evalAUX[(., .)]{.} \) evaluates the assertions \( \bar{\lpre} \):
\[
\begin{array}{@{} l @{\qquad} l @{}}
\begin{rclarray}
    \evalAUX{\assfalse} & \defeq & \emptyset \\
    \evalAUX{\asstrue} & \defeq & \HisHeaps \times \Views \times \Caps \\
    \evalAUX{\bar{\lpre} \land \bar{\lpost}} & \defeq & \evalAUX{\bar{\lpre}} \cap \evalAUX{\bar{\lpost}} \\ 
    \evalAUX{\bar{\lpre} \lor \bar{\lpost}} & \defeq & \evalAUX{\bar{\lpre}} \cup \evalAUX{\bar{\lpost}} \\ 
\end{rclarray} 
&
\begin{rclarray}
    \evalAUX{\exsts{\lvar} \bar{\lpre}} & \defeq & \bigcup\limits_{\val \in \Val} \evalAUX[\lenv\rmto{\lvar}{\val}, \stk]{\bar{\lpre}} \\
    \evalAUX{\bar{\lpre} \implies \bar{\lpost}} & \defeq & \Setcon{ (\hh, \vi, \ca) }{ (\hh, \vi, \ca) \in \evalAUX{\bar{\lpre}} \\ \quad \implies (\hh, \vi, \ca) \in \evalAUX{\bar{\lpost}} }\\
    \evalAUX{\assemp} & \defeq & \Setcon{ (\unitHH, \unitVI, \ca) }{\ca \in \unitC } \\
\end{rclarray}
\\
\\
\multicolumn{2}{@{}l@{}}{%
\begin{rclarray}
    \evalAUX{\cass{\kap}{\lrid}} & \defeq & \Set{ (\unitHH, \unitVI, \Set{\lrid \mapsto \evalC{\kap}}) }\\
    \evalAUX{\lexpr_{1} \pt \lexpr_2} & \defeq & 
    \Setcon{ (\hh, \vi, \ca) }{%
        (\hh, \vi, \ca) \in \evalAUX{\lexpr_{1} \pt \luexpr_2}
        \land \exsts{\ke = \evalLE{\lexpr_{1}}} 
        \vi(\ke) = \lvert \mkvs(\ke) \rvert - 1
    } \\
    \evalAUX{\lexpr_{1} \pt \luexpr_2} & \defeq & \Setcon{ (\hh, \vi, \ca) }{ \Set{ \evalLE{\lexpr_{1}} \mapsto \evalLE{\luexpr_{2}} } = \clpsHH{\hh, \vi} \land \ca \in \unitC } \\
    \evalAUX{\bar{\lpre} \sep \bar{\lpost}} & \defeq & 
    \Setcon{ (\hh \composeHH \hh', \vi \composeVI \vi', \ca \composeC \ca') }{ (\hh, \vi, \ca) \in \evalAUX{\bar{\lpre}} \land (\hh', \vi', \ca') \in \evalAUX{\bar{\lpost}} } \\
\end{rclarray}%
} \\
\end{array}
\]
\end{definition}


%\subsubsection{Rely and Guarantee}

The \emph{rely} describes the allowed actions for the environment (\cref{def:rely-guarantee}).
It is a set of transitions over worlds, especially the shared states, to describe how the environment can change the state of the shared regions.
Given the local capabilities \( \ca_l \) and shared capabilities \( \ca_r \), the environment might own any capabilities \( \ca\) that is compatible, \ie \( (\ca \composeC \ca_l \composeC \ca_r)\isdef \).
Then the \emph{update rely} \( \relyU \) allows the environment to perform those actions associated with the capabilities \( \ca \) with their own view \( \vi_e \) to update the key-value store and shared capabilities.
Note that the \emph{update rely} does not change the views, since the views are actually local for clients.
Separately, the \emph{view shift rely} \( \relyV \) allows to advanced the view.
%For technical reasons, even though the environment cannot change the view of the current client \( \vi_r\), but it is allowed to arbitrarily shift to the later versions due to the fact that for certain execution tests, the old view might be valid under the new key-value store.

The \emph{guarantee} \( \Guar \) describes the allowed actions for the current client (\cref{def:rely-guarantee}).
The current client can perform actions associated with the local capabilities \( \ca_l \) to update the shared region and the local capabilities.
Yet it should ensure no resource created or deleted by requiring the \emph{orthogonal} of local capabilities and shared capabilities together remains unchanged.
The orthogonal of some capabilities \( \ca \) is a set of capabilities that are compatible with the capabilities \( \ca \).
Note that the guarantee allows to update several regions, but each region can be updated at most once.

\begin{definition}[Rely and guarantee]
\label{def:rely-guarantee}
Given the set of worlds $\World$ (\cref{def:world}), the \emph{update rely} relation, $\relyU \subseteq \World \times \World$, is defined as follows:
\sx{In case I get confused again, it is world to world so the shared and local capabilities should always make sense.}
\[	
    \begin{rclarray}
	\relyU & \eqdef &
	\Setcon{
		((\ca_l,\gs), (\ca_l, \gs'))	
	}{
        \fora{\rid}
        \gs(\rid) = \gs'(\rid) \lor 
        \exsts{\kap, \hh, \hh', \vi_\rid, \vi_{e}, \vi_{e}', \ca, \ca_\rid, \ca_{\rid}', \intf}   \\
        \quad \gs(\rid) = (\hh, \vi_\rid, \ca_\rid, \intf)
        \land \gs'(\rid) = (\hh', \vi_{\rid}, \ca_{\rid}',\intf) 
        \land ( \ca \composeC \ca_l \composeC \ca_r )\isdef
        \\
        \quad {} \land \kap \sqsubseteq \ca(\rid) 
        \land ( (\hh, \vi_e, \ca_\rid), (\hh', \vi_{e}', \ca_{\rid}') )  \in \intf(\kap)
        \land \vi_{\rid}' \geq \vi_\rid
	} \\
    \end{rclarray}
\]
The \emph{view shift rely} relation $\relyV \subseteq \World \times \World$, is defined as follows:
\[
    \begin{rclarray}
	\relyV & \eqdef &
	\Setcon{
		((\ca_l,\gs), (\ca_l, \gs'))	
	}{
        \fora{\rid}
        \gs(\rid) = \gs'(\rid) \lor 
        \exsts{\hh, \vi, \vi'\ca, \ca, \intf}
        \gs(\rid) = (\hh, \vi, \ca, \intf)
        \land \gs'(\rid) = (\hh, \vi', \ca, \intf) 
	} \\
    \end{rclarray}
\]
The \emph{rely} relation is transitive closure of updates and view shift: \( \Rely = (\relyU \cup \relyV)^{*} \).
The \emph{guarantee} relation, $\Guar: \World \times \World$, is defined as follows:
\[	
    \begin{rclarray}
	\Guar & \eqdef &
	\Setcon{
		((\ca_l,\gs), (\ca_{l}', \gs'))	
	}{
        \fora{\rid}
        \gs(\rid) = \gs'(\rid) \lor {}
        \exsts{\kap, \hh, \hh', \vi_\rid, \vi_{\rid}', \ca_\rid, \ca_{\rid}', \intf}   \\
        \quad \gs(\rid) = (\hh, \vi_\rid, \ca_\rid,\intf)
        \land \gs'(\rid) = (\hh', \vi_{\rid}', \ca_{\rid}',\intf) 
        \land \kap \sqsubseteq \ca_{l}(\rid)  \\
        \quad {} \land ( (\hh, \vi_\rid, \ca_\rid), (\hh', \vi_{\rid}', \ca_{\rid}') )  \in \intf(\kap)
        \land (\ca_{l} \composeC \ca_\rid)^{\perp} = (\ca_{l}' \composeC \ca_{\rid}')^{\perp}
	} \\
    \end{rclarray}
\]
where for any element \( m \) from its domain \( \sort{M} \), the  \emph{orthogonal} is defined as:
\[
\begin{rclarray}
m^{\perp} & \defeq & \Setcon{m'}{(m \compose{} m')\isdef \land m' \in \sort{M}} 
\end{rclarray}
\]
\end{definition}

Assertions are \emph{stable} if they remain true against the rely.
Formally speaking, a set of worlds \( \setworld \) is stable under certain execution tests \( \et \) if the set is closed under rely relation \( (\w, \w') \in \Rely \) with the side conditions:
(a) the transformation of key-value store is allowed by the execution tests \( (\mkvs, \mkvs') \in \et \), which means the environment executes a fingerprint \( \fp \) under its view and it passes the execute test;
and (b) the new view under the new key-value store is able to progress, \ie \( (\mkvs', \vi') \csat \unitO :  \vi'' \).
Given the progress condition the new view is at least able to execute a \emph{dummy transaction}, \ie a transaction with empty fingerprint.
It ensures that under serialisibility the new view is up-to-date with respect to the key-value store, while for other consistency models, it usually guarantees the view is atomic.

\begin{definition}[Stable]
\label{def:stable}
A set of worlds $\setworld \subseteq \World$ is \emph{stable}, written $\stable{\setworld, \como}$, if and only if it is closed under the rely relation: 
\[
    \begin{rclarray}
        \stable{\setworld, \como} & \eqdef & 
        \begin{array}[t]{@{}l}
            \fora{\w, \w', \mkvs, \mkvs', \vi, \vi', \vi''} 
            \w \in \setworld 
            \land (\w, \w') \in \Rely  
            \land (\hh, \vi) = \eraseW{\w} \\
            \quad \land (\hh', \vi') = \eraseW{\w'} 
            \land (\hh, \hh') \in \como 
            \land (\mkvs', \vi') \csat \unitO :  \vi'' 
            \implies \w' \in \setworld
        \end{array} \\
    \end{rclarray}
\]
where the \( (\hh, \hh') \in \como\) is defined as:
\[
    \begin{rclarray}
        (\hh, \hh') \in \como & \eqdef & 
        \begin{array}[t]{@{}l}
            \hh = \hh' \lor 
            \exsts{ \vi, \vi', \opset, \txid, \cl}  \\
            \quad (\hh, \vi) \csat \opset : \vi' 
            \land \txid \in \fresh{\hh, \cl} 
            \land \hh'  = \updM{\hh,\vi, \txid, \opset}
        \end{array}
    \end{rclarray}
\]
\end{definition}


%\subsubsection{Rules for Global}

The triple for program \( \tripleG{\gpre}{\prog}{\gpost} \) asserts that given any state satisfying the precondition \( \gpre \), if the program \( \prog \) terminates under the execution test \( \et \), the state after satisfies the postcondition \( \gpost \).
The \rl{PRCommit} rule (\cref{fig:rule-prog}) is the key rule.
It commits the local effect of a transaction \( \trans \) via \emph{repartitioning} \( \repartition{\gpre}{\gpost}{\lpre}{\lpost} \).
It means:
\begin{itemize}
\item
for any possible world \( \w \) satisfying the precondition \( \gpre \), there exists a snapshot of the world \( \getSN{(\mkvs, \vi)} \) with empty fingerprint \( \unitO \) which overall satisfies the transactional precondition \( \lpre \);
\item
for any possible fingerprints  \( \opset \) satisfying the transactional postcondition \( \lpost \), there exists a world \( \w' \) satisfying the postcondition \( \gpost \) such that:
\begin{itemize}
\item 
the new key-value store in the new world \( \mkvs' \) is updated committing the fingerprints \( \opset \) to \( \mkvs \);
\item
the new view \( \vi' \) is picked so that the update passes the execution test \( (\mkvs,\vi) \csat \opset : \vi' \);
\item
and, the update is allowed by the guarantee \( (\w, \w') \in \Guar\).
\end{itemize}
\end{itemize}


\begin{figure}[t!]
\hrule\vspace{5pt}

\begin{mathpar}
    \inferrule[\rl{PRCommit}]{%
        \tripleL{\lpre}{\trans}{\lpost} 
        \\ \repartition{\gpre}{\gpost}{\lpre}{\lpost}
        \\\\ \stable{\gpre, \como} 
        \\ \stable{\gpost, \como} 
    }{%
        \tripleG{\gpre}{ \ptrans{\trans} }{\gpost}
    }
    \and
    \inferrule[\rl{PRPar}]{%
        \tripleG{ \gpre_{1} }{ \cmd_{1} }{ \gpost_{1} }
        \\ \tripleG{ \gpre_{2} }{ \cmd_{2} }{ \gpost_{2} } 
        \\\\ \stable{\gpre_{1}, \como} 
        \\ \stable{\gpre_{2}, \como} 
    }{%
        \tripleG{ \gpre_{1} \sep \gpre_{2} }{ \cmd_{1} \ppar \cmd_{2} }{ \gpost_{1} \sep \gpost_{2} }
    }
    \and
    \inferrule[\rl{PRAss}]{%
        \thvar \notin \func{fv}{\lexpr} 
    }{%
        \tripleG{\thvar \dot= \lexpr }{ \pass{\thvar}{\expr} }{\thvar \dot= \expr\sub{\thvar}{\lexpr} }
    }
    \and
    \inferrule[\rl{PRAssume}]{ }{%
        \tripleG{ \expr \dot\neq 0 }{ \passume{\expr} }{ \expr \dot\neq 0 } 
    }
    \and
    \inferrule[\rl{PRChoice}]{%
        \tripleG{ \gpre }{ \cmd_{1} }{ \gpost } 
        \\ \tripleG{ \gpre }{ \cmd_{2} }{ \gpost } 
    }{%
        \tripleG{ \gpre }{ \cmd_{1} \pchoice \cmd_{2} }{ \gpost }
    }
    \and
    \inferrule[\rl{PRSeq}]{%
        \tripleG{ \gpre }{ \cmd_{1} }{ \gframe }
        \\ \tripleG{ \gframe }{ \cmd_{2} }{ \gpost }
    }{%
        \tripleG{ \gpre }{ \cmd_{1} \pseq \cmd_{2} }{ \gpost }
    }
    \and
    \inferrule[\rl{PRIter}]{%
        \tripleG{ \gpre }{ \cmd }{ \gpre } 
    }{%
        \tripleG{ \gpre }{ \cmd\prepeat }{ \gpre }
    }
    \and
    \inferrule[\rl{PRFrame}]{%
        \tripleG{ \gpre }{ \cmd }{ \gpost } 
        \\ \stable{\gframe, \como}
        \\ \func{fv}{\gframe} \cap \func{modify}{\cmd} = \emptyset 
    }{%
        \tripleG{ \gpre \sep \gframe }{ \cmd }{ \gpost \sep \gframe }
    }
\end{mathpar}


\hrule\vspace{5pt}
\[
\begin{rclarray}
    \repartition{\gpre}{\gpost}{\lpre}{\lpost} & \defeq & 
    \begin{array}[t]{@{}l@{}}
        \fora{ \w, \mkvs, \vi, \lenv, \stk } 
        \w \in \evalW{\gpre} 
        \land (\mkvs, \vi) = \eraseW{\w}
        \implies 
        (\getSN{\mkvs, \vi}, \unitO) \in \evalLS{\lpre}  \\
        \quad {} \land \fora{\w', \mkvs', \vi', \stk', \txid, \opset, \cl} 
        \txid \in \fresh{\mkvs, \cl} 
        \land (\stub, \opset) \in \evalLS[\lenv, \stk']{\lpost} \\
        \qquad {} \land \mkvs' = \updM{\mkvs, \vi, \txid, \opset}
        %\land \eraseW{\w}\projection{2} \leq \eraseW{\w'}\projection{2} 
        \land (\mkvs, \vi) \csat \opset : \vi' \\
        \qquad {} \land (\mkvs', \vi') = \eraseW{\w'} 
        \land (\w, \w') \in \Guar
        \implies \w' \in \evalW[\lenv, \stk']{\gpost}
    \end{array} 
\end{rclarray}                          
\]

\hrule\vspace{5pt}
\caption{The rules for programs}
\label{fig:rule-prog}
\end{figure}

%\azalea{
    %\sx{How to deal with the stack here? As the stack for P and Q are different, just for all quantify two stacks??}
%The quantification seems wrong. Especially, the $\extopset$ needs to be for all quantified, $\h$ needs to be there exist quantified.
%\[
     %\repartition{\gpre}{\gpost}{\lpre}{\lpost} \defeq 
     %\begin{array}[t]{@{}l@{}}
		 %\fora{\w, \hh, \vi, \lenv, \stk, \txid } 
            %\w \in \evalW{\gpre} 
            %\land (\hh, \cu) \in \eraseW{\w}
            %\Rightarrow\\
            %\quad \exsts{\h}
            %\begin{array}[t]{@{} l @{}}
			%\h = \getSN{\hh, \cu}  
                %\land (\h, \unitO) \in \evalLS{\lpre} \\
                %\land\, \fora{\extopset \in \evalF{\lpost}} 
                    %\exsts{\w', \hh', \vi'} \\
                        %\quad \hh' = \updM{\hh, \vi, \txid, \extopset} 
                       %\land \cu' = \updV{\hh, \vi, \extopset} 
                       %\land (\hh',\vi') \in \eraseW{\w'} \\
                        %\quad \land (\w, \w') \in \Guar  
                        %\land (\w, \w') \in \como
                        %\land \w' \in \evalW{\gpost}			
		%\end{array}	
%%		\right)			        	
    %\end{array} 
%\]
%}

%The \( \HHupdate \) and \( \Vupdate \) in the repartition can be replaced by syntactic rules.

%\begin{figure}
%\hrule\vspace{5pt}

%\[
   %\infer[\rl{FInit}]{%
       %\tripleF{ \lexpr \pt \lexpr }{ \lexpr \fpI \lexpr }{ \lexpr \pt \lexpr }
   %}{}
%\]

%\[
   %\infer[\rl{FRead}]{%
       %\tripleF{ \lexpr \pt \lexpr }{ \lexpr \fpR \lexpr }{ \lexpr \pt \lexpr }
   %}{}
%\]

%\[
   %\infer[\rl{FWrite}]{%
       %\tripleF{ \lexpr \pt \lexpr  }{  \lexpr \fpW \lexpr' }{ \lexpr \pt \lexpr' }
   %}{}
%\]

%\[
   %\infer[\rl{FReWrt}]{%
       %\tripleF{ \lexpr \pt \lexpr  }{  \lexpr \fpRW (\lexpr,\lexpr') }{ \lexpr \pt \lexpr' }
   %}{}
%\]

%\[
   %\infer[\rl{FFrame}]{%
       %\tripleF{ \bar{\lpre}_{1} \sep \bar{\lpre}_{2}  }{  \bar{\fp}_{1} \sep \bar{\fp}_{2} }{ \bar{\lpost}_{1} \sep \bar{\lpost}_{2} }
   %}{
       %\tripleF{ \bar{\lpre}_{1} }{ \bar{\fp}_{1} }{ \bar{\lpost}_{1} }
       %&& \tripleF{ \bar{\lpre}_{2}  }{ \bar{\fp}_{2} }{ \bar{\lpost}_{2} }
    %}
%\]


%\hrule\vspace{5pt}
%\caption{Syntactic rule for \( \HHupdate \) and \( \Vupdate \) functions}
%\label{fig:rule-prog}
%\end{figure}

