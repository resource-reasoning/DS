\subsection{Reasoning programs}

\emph{Capabilities} (\cref{def:capabilities}) are used to specify the allowed operations on concurrent modules.
Each module is associated with \emph{client-specified capabilities} that forms \emph{a partial commutative monoid (PCM)}.
To recall, \emph{a PCM} is a partially ordered set that is closed under a commutative binary operation \( \compose \) and has a set of identify elements \( \unitelem \).
The client-specified capabilities are lifted to \emph{capability composition function} with their associated region identifiers.
For brevity, we often use \emph{capabilities} for \emph{capability composition function}.
The composition function for \emph{capabilities} \( \ca_l \composeC \ca_r \) is defined as point-wise compositing each region and the units \( \unitC \) are functions where regions map to units of client-specified capabilities.


\begin{definition}[Capabilities]
\label{def:capabilities}
Assume a \emph{partial commutative monoid (PCM)} of \emph{client-specified capabilities} \( (\Kaps, \composeK, \unitK) \) with \( \kap \in \Kaps \), the composition \( \composeK \) the units set \( \unitK \).
Then given a set of \emph{region identifiers} \( \rid \in \RegionID \), 
the \emph{capability composition function} or \emph{capabilities} \( \ca \in \Caps \defeq \RegionID \parfun \Kaps \), where the composition \( \composeC \) is defined as the follows:
\[
    \begin{rclarray}
        (\ca_{l} \composeC \ca_{r})(\rid) & \defeq  &
        \begin{cases}
            \ca_{l}(\rid) \composeK \ca_{r}(\rid) & \rid \in \dom(\ca_{l}) \cap \dom(\ca_{l}) \\
            \ca_{l}(\rid)  & \rid \in \dom(\ca_{l}) \setminus \dom(\ca_{l}) \\
            \ca_{r}(\rid) & \rid \in \dom(\ca_{r}) \setminus \dom(\ca_{l}) \\
            \text{undefined} & \text{otherwise} \\
        \end{cases}
    \end{rclarray}
\]
and the units set \( \unitC \defeq \Setcon{\ca}{\fora{\rid} \ca(\rid) \in \unitK } \) .
A capability assertion is in the form of \( \cass{\kap(\vec{\lvar})}{\lrid} \in \CAst \), where \( \kap(\vec{\lvar}) \) is a token parametrised by logical variables and \( \lrid \) is the region identifiers.
The capability assertion is interpreted to a capability in the model by interpreting all the logical expressions,
\[
\begin{rclarray}
    \evalC{\cass{\kap(\vec{\lvar})}{\lrid}} & \defeq & \Set{\lrid \mapsto \kap(\evalLE{\vec{\lvar}})} \\
\end{rclarray}
\]
\end{definition}

The \emph{capability assertions} are in the form of \( \cass{\kap(\vec{\lvar})}{\lrid} \) where \( \kap(\vec{\lvar}) \) is a syntactic capability and \( \lrid \) is a region identifier
They are interpreted to some capabilities by interpreting the syntactic capabilities \( \kap(\vec{\lvar}) \).:
They are resources that grant abilities to access the module, which we will explain later, or act as ghost resources to provide extra information about the module.

Each region is associated with a \emph{interference} to specify how the region can evolve (\cref{def:invariant-region}).
A action in the interference is in the form of \( \exsts{\vec{\lvar}} \perm{\kap} : \bar{\fp} \) and it says if a client holds the capability \( \perm{\kap} \), it is allowed to commit a transaction that has the \emph{fingerprint with capabilities transformation} \( \bar{\fp} \).
The existential is for binding variables between the capability and the fingerprint assertions.
The \emph{fingerprint with capabilities transformation} are fingerprint assertion (\cref{def:fingerprint}) extended with special one for transferring of capabilities, \ie adding to the shared state \( \fpA \cass{\kap}{\lrid} \), deleting from the shared state \( \fpD \cass{\kap}{\lrid} \) and updating the capabilities \( \cass{\kap(\vec{\lvar})}{\lrid} \fpU \cass{\kap(\vec{\lvar})}{\lrid} \). 

\begin{definition}[Interference]
\label{def:intf}
The \emph{fingerprint with capabilities transformation} is defined by the follows:
\[
\begin{rclarray}    
    \bar{\fp}, \bar{\fp}' & ::= & 
    \lexpr \fpI \lexpr 
    \mid \lexpr \fpR \lexpr 
    \mid \lexpr \fpW \lexpr 
    \mid \lexpr \fpRW (\lexpr, \lexpr) \\
    & & \mid \null \fpA \cass{\kap(\vec{\lvar})}{\lrid}  
    \mid \null \fpD \cass{\kap(\vec{\lvar})}{\lrid} 
    \mid \cass{\kap(\vec{\lvar})}{\lrid} \fpU \cass{\kap(\vec{\lvar})}{\lrid} 
    \mid \bar{\fp} \sep \bar{\fp}'
\end{rclarray}
\] 
Given a logical environment $\lenv \in \LEnv$, a stack $\stk \in \Stacks$ and the fingerprint interpretation function (\cref{def:fingerprint}), the \emph{fingerprint with capabilities transformation} is interpreted through function, $\evalF[(., .)]{.}: \FAst \times \LEnv \times \Stacks \parfun \Heaps \times \Opsets \times \Caps \times \Caps$:
\[
\begin{rclarray}
    \evalF{ \bar{\fp} } & \defeq &
        \Setcon{(\h, \opset, \ca, \ca')}{
            (\h,\opset) \in \evalLS{\bar{\fp}} \land \ca, \ca' \in \unitC
        } \quad \text{where} \ \bar{\fp} \in \LAst \\
    \evalF{\null \fpA \cass{\kap(\vec{\lvar})}{\lrid} } & \defeq & 
        \Setcon{(\unitH, \unitO, \ca, \ca')}{
            \ca = \evalC{\cass{\kap(\vec{\lvar})}{\lrid}} \land \ca' \in \unitC
        } \\
    \evalF{\null \fpD \cass{\kap(\vec{\lvar})}{\lrid} } & \defeq &
        \Setcon{(\unitH, \unitO, \ca, \ca')}{
            \ca \in \unitC \land \ca'  = \evalC{\cass{\kap(\vec{\lvar})}{\lrid}} 
        } \\
    \evalF{\cass{\kap(\vec{\lvar})}{\lrid} \fpU \cass{\kap'(\vec{\lvar}')}{\lrid} } & \defeq &
        \Setcon{(\unitH, \unitO, \ca, \ca')}{
            \ca = \evalC{\cass{\kap(\vec{\lvar})}{\lrid}} \land \ca'  = \evalC{\cass{\kap'(\vec{\lvar}')}{\lrid}} 
        } \\
    \evalF{\fp_{1} \sep \fp_{2}} & \defeq & \Setcon{ ( \h_{1} \composeH \h_{2}, \opset_{1} \composeO \opset_{2}, \ca_{1} \composeC \ca_{2}, \ca'_{1} \composeC \ca'_{2} ) }{(\h_{1}, \opset_{1}, \ca_{1}, \ca'_{1}) \in \evalF{\fp_{1}}  \\ {} \land (\h_{2}, \opset_{2}, \ca_{2}, \ca'_{2}) \in \evalF{\fp_{2}}}\\

\end{rclarray}
\]
The grammar of \emph{interference assertions}, \( \intass \in \IAst \), is defined as the follows:
\[
\begin{rclarray}
	\intass & ::=  & \emptyset \mid \Set{ \exsts{\vec{\lvar}} \perm{\kap} : \fp } \cup \intass 
\end{rclarray}
\]
The interference assertions are interpreted to \emph{interference environments} \( \intf \):
\[
\begin{rclarray}
    \inter \in \Interference & \defeq & \Kaps \to ( \HisHeaps \times \Views \times \Caps ) \times  ( \HisHeaps \times \Views \times \Caps )
\end{rclarray}
\]
The \emph{interference interpretation} function, $\evalI[(., .)]{.}: \IAst \times \LEnv \times \Stacks \to \Interference$, is defined as follows:
\sx{
    Notations are confused, there is different between syntactic \( \kap \) which can be parametrised by logical variables, and client-specified capabilities \( \kap' \).
    Fix the typesetting later.
    } 
\[
\begin{array}{@{}l}
	\evalI{\Set{ \exsts{\vec{\lvar}} \perm{\kap} : \fp } \cup \intass }(\kap') \eqdef \\
    	\quad \left\{ 
            \begin{array}{@{}l @{\qquad} l}
            \multicolumn{2}{@{}l@{}}{
                    \Setcon{
                        \begin{B}
                            (\hh, \vi, \ca_r \composeC \ca_f ), \\ 
                            (\hh',\vi', \ca_f \composeC \ca_a)
                        \end{B}
                    }{ 
                        \exsts{\txid, \opset, \cl} \\
                            \quad ( \stub, \opset, \ca_{a}, \ca_{r} ) \in \evalF[\lenv',\stk]{\fp}   \\
                        \quad {} \land \txid \in \func{nextTxid}{\hh, \cl}  \\
                        \quad {} \land \hh' = \updM{\hh, \vi, \txid, \opset}  \\
                        \quad {} \land \pred{readFrom}{\hh, \vi, \opset} 
                        \land \vi' \geq \vi \\
                    } 
                    \cup \evalI{\intass}(\kap')%
            } \\
            & \text{if there exist a logical environment} \ \lenv' \ \text{by replacing} \ \vec{\lvar} \ \text{with some} \ \vec{\val} \ \text{\ie} \\ 
            & \lenv' = \lenv\rmto{\vec{\lvar}}{\vec{\val}}, \ \text{and under the new logical environment} \ \kap' = \evalI[\lenv', \stk]{\kap} \\
            \evalI{\intass}(\kap') 
            & \text{otherwise} \\
    	    \end{array}
        \right.  \\
\end{array}
\]
The \( \predn{readFrom} \) asserts the fingerprint makes sense with respect to the view:
\[
\begin{rclarray}
    \pred{readFrom}{\hh, \vi, \opset} & \defeq & \fora{\ke, \val} (\otR, \ke, \val) \in \opset \implies \valueOf(\hh(\ke,\vi(\ke))) = \val
\end{rclarray}
\]
\end{definition}


%The interference \( \exsts{\vec{\lvar}} \perm{\kap} : \bar{\lpre} \mat \fp \) says if a thread holds the capability \( \perm{\kap}\) and \emph{the current state of database} satisfies the assertions \( \bar{\lpre} \), the thread is allowed to commit a transaction that has the fingerprint \( \fp \).
%The current state of database refers to the state that all the committed transactions are visible.

%\begin{definition}[Interference]
%\label{def:intf}
%Assume standard separation logic assertion \( \bar{\lpre}\) (the local assertion \( \LAst \) without fingerprint).
%Given the fingerprint assertion \( \fp \in \Fingerprint \) (\defref{def:fingerprint}), the grammar of \emph{interference assertions}, \( \intass \in \IAst \), is defined as the follows,
%\[
%\begin{rclarray}
	%\intass & ::=  &
	%\emptyset \mid \Set{ \perm{\kap} :  \exsts{\vec{\lvar}} \bar{\lpre} \mat \fp } \cup \intass 
%\end{rclarray}
%\]
%The interference assertions are interpreted to a set of \emph{interference environments} that is a function from client-specified capabilities to pairs of history heaps and operations,
%\[
%\begin{rclarray}
    %\inter \in \Interference & \defeq & \Kaps \to \powerset{\HisHeaps \times \Opsets}
%\end{rclarray}
%\]
%Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stacks$, the \emph{interference interpretation} function, $\evalI[(., .)]{.}: \IAst \times \LEnv \times \Stacks \to \Interference$, is defined as follows,
%%
%\[
%\begin{rclarray}
	%\evalI{\emptyset}(\kap) & \eqdef & \emptyset \\
	%\evalI{\Set{ \perm{\kap} : \exsts{\vec{\lvar}} \bar{\lpre} \mat \fp } \cup \intass }(\kap') & \eqdef &
    %\begin{cases}
    %\Setcon{(\hh, \evalF[\lenv',\stk]{\fp})}{\exsts{\h} \h \in \evalLS[\lenv',\stk]{\bar{\lpre}} \land {} \\ \h = \clpsHH{\hh} } \cup \evalI{\intass}(\kap')  & \kap = \kap' \\
    %\evalI{\intass}(\kap') & \text{ otherwise} \\
    %\end{cases} \\
    %& & \text{where there exists a vector of values \( \vec{\val}\) such that } \lenv' = \lenv\rmto{\vec{\lvar}}{\vec{\val}} \\
%\end{rclarray}
%\] 
%\end{definition}

%We will write \( \intfH(\kap) \)  and \( \intfO(\kap) \) for the first and second projections of all the elements.


%\begin{definition}[Labelled transition system]
%\label{def:labelled-transition-system}
%The labelled transition system is a tuple \( ( \hhset \times \cuset, \opsetset,\toLTS{}, \hhset_{0} \times \cuset_{0}, \como) \) consisting of pairs of history heaps and cuts \( \hhset \times \cuset \), a set of sets of operations \( \opsetset \subseteq \Opsets \), a relation \( \toLTS{} : \HisHeaps \times \Opsets \times \HisHeaps \), a set of initial history heaps and cuts \( \hhset_{0} \times \cuset_{0} \) and the consistency model associated with the transition system \( \como \).
%Assume all the initial abstract executions satisfies the consistency model.
%The relation \( \toLTS{}\) is defined as the follows,
%\[
%\begin{rclarray}
    %(\hh, \cu) \toLTS{\opset} (\hh',\cu') & \defeq &
    %\begin{array}[t]{@{}l}
        %\exsts{\thcu, \thcu', \txid, \thid}
        %\txid \in \fresh{\hh} 
        %\land \hh' = \updM{\hh, \cu, \txid, \opset} 
        %\land \cu' = \updV{\hh', \cu, \opset} \\
        %\quad {} \land ((\hh,\thcu),(\hh',\thcu')) \in \como
        %\land \h = \clpsHH{\hh,\cu} 
        %\land \thcu(\thid) = \cu 
        %\land \thcu'(\thid) = \cu' \\
        %\quad {} \land \fora{\addr,\val} (\otR, \addr, \val)  \in \opset \implies \h(\addr) = \val
    %\end{array}
%\end{rclarray}
%\]
%\end{definition}

%We lift the interference to a invariant.
%The invariant is a labelled transition system that describes how a region evolves providing all the allowed operations.
%Note that the labels are capabilities (with region identifiers) instead of client-specified capabilities, which is only for technical reason.

\begin{definition}[Invariant of a region]
\label{def:invariant-region}
Assume a global function, \( \funcn{init} : \RegionID \to \powerset{ \HisHeaps } \) returning initial key-value stores for regions.
Given the initial states for a region \( \func{init}{\rid}\), the invariant of a region, written \( \func{inv}{\rid, \intf} \), is a set of key-value stores that is closed under the interference \( \intf \):
\[
\begin{array}[t]{@{}l}
    \func{init}{\rid} \in \func{inv}{\rid, \intf} \land 
    \fora{\mkvs, \mkvs'} 
    \exsts{\w, \w', \kap} \\
    \quad \mkvs \in \func{inv}{\rid, \intf} \land  ( \mkvs, \stub ) = \eraseW{\w} \land ( \mkvs', \stub ) = \eraseW{\w'} \land (\w, \w') \in \intf(\kap) \implies \mkvs' \in \func{inv}{\rid, \intf} 
\end{array}
\]
\end{definition}

%For brevity, \( (\hh,\cu) \in \func{inv}{\rid, \intf} \) denotes \( (\hh,\cu) \in \func{inv}{\rid,\intf}\projection{1} \), and similarly \( (\hh,\cu) \toLTS{\opset} (\hh',\cu') \in \func{inv}{\rid, \intf} \).

%\sx{This well form condition allows one to write weaker interference, \eg interference satisfies both SI and SER but to prove the correctness of SER. It is fine since logic only need to be sound?}
%\begin{definition}[Well-form of a region]
%\label{def:well-form-region}
%The well-form condition of the interference, namely \( \pred{wfintf}{\rid, \intf} \) predicate, assertions for any concrete events \( \opset \), the state before the events must be included in the interference.
%\[
%\begin{rclarray}
    %\pred{wfintf}{\rid, \intf} & \defeq & 
    %\begin{array}[t]{@{}l}
        %\fora{\hh, \hh', \opset} 
        %(\hh, \stub) \toLTS{\opset} (\hh',\stub) \in \func{inv}{\rid, \intf} 
        %\implies \exsts{ \kap}
        %(\hh, \opset ) \in \intf( \kap )
    %\end{array} \\
%\end{rclarray}
%\]
%\end{definition}

\begin{definition}[Worlds]
\label{def:world}
Given the set of history heaps $\HisHeaps$ (\cref{def:his_heap}), views \( \Views \) (\cref{def:views}), capabilities \( \Caps\) (\cref{def:capabilities}) and region identifiers \( \RegionID \), the set of \emph{shared states} is \( \SStates \eqdef \RegionID \parfun \HisHeaps \times \Views \times \Caps \times \Interference \).
Each region has its current state and the interference.
The \emph{shared state composition function}, $\composeS: \SStates \times \SStates \parfun \SStates$, is defined as $\composeS \eqdef \composeEq$, where for all domains $\sort M$ and all $m, m' \in \sort M$,
%
\[
\begin{rclarray}
	m \composeEq m' &  \eqdef  &
	\begin{cases}
		m & \text{if } m = m'\\
		\text{undefined} & \text{otherwise}
	\end{cases}
\end{rclarray}
\]
A \emph{world} \( \w \in \World \) is a pair of capabilities \( \ca \) (\cref{def:capabilities}) and a shared state \( \gs \) in which regions are well-formed, \ie (a) they are associated with disjointed part of history heaps; (b) the domain of the view in a region is the same as the domain of the history heap; and (c) the views should not be out of the range of history heaps.
Separately, capabilities from regions and local capabilities are compatible.
These constraints are derived by the clap \(\eraseS{(\ca, \gs)} \neq \emptyset \).
Finally, there is no garbage capability, a capability where the associated region identifier never appear in the shared state.
\[
\begin{rclarray}
	\world \in \World  & \eqdef & 
    \Setcon{
        (\ca, \gs) 
    }{ 
        \ca \in \Caps \land \gs \in \SStates
        \land \exsts{ \ca' } 
        (\stub, \stub, \ca') \in \func{collapse}{\gs}
        \land \dom(\ca \composeC \ca') \subseteq \dom(\gs)  \\
        \quad {} \land \fora{\rid}
        \exsts{\hh, \vi, \intf} 
        \gs(\rid) = (\hh, \vi, \stub, \intf) 
        \land \dom(\hh) = \dom(\vi) 
        \land \mkvs \in \func{inv}{\rid, \intf} \\
        \quad {} \land \fora{ \addr \in \dom(\vi) }
        0 \leq \cu( \addr ) \le \left| \hh(\addr) \right|
    }
\end{rclarray}
\]
where the \(\funcn{collapse} \) function collapses a shared state by erasing the region identifiers:
\[
\begin{rclarray}
    \func{collapse}{\emptyset} & \defeq & \Set{(\unitHH, \unitVI, \unitC )} \\
    \func{collapse}{\Set{\rid \mapsto (\hh, \vi, \ca, \intf)} \uplus \gs } & \defeq & 
        \Setcon{ 
            (\hh \composeHH \hh', \vi \composeCU \vi', \ca \composeC \ca') 
        }{ 
            \land (\hh', \vi', \ca') \in \func{collapse}{\gs} }\\
\end{rclarray}
\] 
% 
The \emph{world composition function}, $\composeW: \World \times \World \parfun \World$, is defined component-wise as: $\composeW \eqdef (\composeC, \composeS)$.
The \emph{world unit set} is $\unitW \eqdef \Setcon{(\ca, \gs)}{(\ca, \gs) \in \World \land \ca \in \unitC}$.
The \emph{partial commutative monoid of worlds} is $(\World, \composeW, \unitW)$.
Because of the well-formedness condition, the function \( \eraseW{.} : \World \to \HisHeaps \times \Views \) collapses a world to \emph{a unique pair of a key-value store and a view}:
\[
\begin{rclarray}
    \eraseW{\w} & \defeq & (\hh, \vi) \text{  where } (\hh, \vi, \stub) \in \func{collapse}{\w\projection{2}}\\
\end{rclarray}
\] 
\end{definition}

\begin{definition}[Assertions]
\label{def:assertion}
Given the set of logical expression \( \lexpr \subseteq \LExpr\), the set of \emph{assertions}, $\gpre, \gpost \in \Ast$, are defined by the following inductive grammar:
\[
\begin{rclarray}
    \bar{\lpre}, \bar{\lpost} & ::= & \False \mid \True \mid \bar{\lpre} \land \bar{\lpost} \mid \bar{\lpre} \lor \bar{\lpost} \mid \exsts{\lvar} \bar{\lpre} \mid \bar{\lpre} \implies \bar{\lpost} \mid \assemp \mid \cass{\kap}{\lrid} \mid \lexpr \pt \lexpr \mid \bar{\lpre} \sep \bar{\lpost} \\
	\gpre , \gpost & ::= & \False \mid \True \mid \gpre \land \gpost \mid \gpre \lor \gpost \mid \exsts{\lvar}\gpre \mid \gpre \implies \gpost \mid \assemp \mid \cass{\kap}{\lrid} \mid \gpre \sep \gpost \mid \boxass{\bar{\lpre}}{\lrid}{\intass}\\
\end{rclarray}
\]
%
where $\lvar, \lrid \in \LVar$, $\lexpr_1, \lexpr_2 \in \LExpr$ (\cref{def:local_assertions}), $\kap \in \Kaps$ (\cref{def:capabilities}) and $\intass \in \IAst$ (\cref{def:intf}).
Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stacks$, the \emph{assertion interpretation} function, $\evalW[(., .)]{.}: \Ast \times \LEnv \times \Stacks \to \powerset{\World}$, is defined as follows,
%
\[
\begin{rclarray}
	\evalW{\False} & \defeq & \emptyset \\
	\evalW{\True} & \defeq & \World \\
	\evalW{\emp} & \defeq & \unitW \\
	\evalW{\gpre \land \gpost} & \defeq & \evalW{\gpre} \cap \evalW{\gpost} \\
	\evalW{\gpre \lor \gpost} & \defeq & \evalW{\gpre} \cup \evalW{\gpost} \\ 
	\evalW{\exsts{\lvar}  \gpre} & \defeq & \bigcup\limits_{\val \in \textnormal{\Val}} \evalW[\lenv\remapsto{\lvar}{\val}, \stk]{\gpre} \\
	\evalW{\gpre \implies \gpost} & \defeq & \Setcon{\w}{\w \in \evalW{\gpre} \implies \w \in \evalW{\gpost}} \\
	\evalW{\cass{\kap}{\lrid}} & \defeq & \Setcon{ (\Set{\lrid \mapsto \evalI{\kap}}, \gs) }{\gs \in \SStates} \\
	\evalW{ \gpre \sep \gpost } & \defeq & 
	\Setcon{
	   (\world_1 \composeW \world_2) 
    }{
       \world_1 \in \evalW{\gpre} \land \world_2 \in \evalW{\gpost}
	} \\
	\evalW{ \boxass{\bar{\lpre}}{\lrid}{\intass} } & \defeq & 
    \Setcon{
        (\ca, \gs)
    }{         
        \exsts{\hh, \vi, \ca', \intf}
        \ca \in \unitC  \\
        \quad {} \land \intf = \evalI{\intass} 
        \land \gs(\lrid) = (\hh, \vi, \ca', \intf) 
        \land (\hh, \vi, \ca') \in \func{intp}{\bar{\lpre}, \lenv, \stk} 
    } \\
    \\
    \func{intp}{\assfalse,\lenv,\stk} & \defeq & \emptyset \\
    \func{intp}{\asstrue,\lenv,\stk} & \defeq & \HisHeaps \times \Views \times \Caps \\
    \func{intp}{\assemp,\lenv,\stk} & \defeq & \Setcon{ (\unitHH, \unitVI, \ca) }{\ca \in \unitC } \\
    \func{intp}{\bar{\lpre} \land \bar{\lpost},\lenv,\stk} & \defeq & \func{intp}{\bar{\lpre},\lenv,\stk} \cap \func{intp}{\bar{\lpost},\lenv,\stk} \\ 
    \func{intp}{\bar{\lpre} \lor \bar{\lpost},\lenv,\stk} & \defeq & \func{intp}{\bar{\lpre},\lenv,\stk} \cup \func{intp}{\bar{\lpost},\lenv,\stk} \\ 
    \func{intp}{\exsts{\lvar} \bar{\lpre},\lenv,\stk} & \defeq & \bigcup\limits_{\val \in \Val} \func{intp}{\bar{\lpre}, \lenv\rmto{\lvar}{\val}, \stk} \\
    \func{intp}{\bar{\lpre} \implies \bar{\lpost},\lenv,\stk} & \defeq & \Setcon{ (\hh, \vi, \ca) }{ (\hh, \vi, \ca) \in \func{intp}{\bar{\lpre},\lenv,\stk} \implies (\hh, \vi, \ca) \in \func{intp}{\bar{\lpost},\lenv,\stk} }\\
    \func{intp}{\cass{\kap}{\lrid},\lenv,\stk} & \defeq & \Set{ (\unitHH, \unitVI, \Set{\lrid \mapsto \evalC{\kap}}) }\\
    \func{intp}{\lexpr_{1} \pt \luexpr_2,\lenv,\stk} & \defeq & \Setcon{ (\hh, \vi, \ca) }{ \Set{ \evalLE{\lexpr_{1}} \mapsto \evalLE{\luexpr_{1}} } = \clpsHH{\hh, \vi} \land \ca \in \unitC } \\
    \func{intp}{\lexpr_{1} \pt \lexpr_2,\lenv,\stk} & \defeq & 
    \Setcon{ (\hh, \vi, \ca) }{%
        \exsts{\ke = \evalLE{\lexpr_{1}}} \Set{ \ke \mapsto \evalLE{\lexpr_{2}} } = \clpsHH{\hh, \vi} \\ 
        \quad {} \land \vi(\ke) = \lvert \mkvs(\ke) \rvert - 1 \land \ca \in \unitC
    } \\
    \func{intp}{\bar{\lpre} \sep \bar{\lpost},\lenv,\stk} & \defeq & 
    \Setcon{ (\hh \composeHH \hh', \vi \composeVI \vi', \ca \composeC \ca') }{ (\hh, \vi, \ca) \in \func{intp}{\bar{\lpre},\lenv,\stk} \\ {} \land (\hh', \vi', \ca') \in \func{intp}{\bar{\lpost},\lenv,\stk} } \\
\end{rclarray}
\]
\end{definition}



\subsubsection{Rely and Guarantee}

The \emph{rely} and \emph{guarantee} describes the world transformation for the environment and for the current client (\cref{def:rely-guarantee}).
To recall, a world includes local capabilities and a shared state, and a shared state is a client's view for the key-value store.
The \emph{rely} \( \Rely \) is a set of pairs on worlds, describing how the environment can change the state of the key-value store.
Given the local capabilities \( \ca_l \), the environment might own any capabilities \( \ca_e\) that is compatible, \ie \( (\ca_l \composeC \ca_e)\isdef \).
Therefore, the environment can perform actions associated with the their capabilities \( \ca_e \) with their own view \( \vi_e \) to update the key-value store and shared capabilities.
For technical reasons, even though the environment cannot change the view of the current client \( \vi_r\), but it is allowed to arbitrarily shift to the later versions due to the fact that for certain execution tests, the old view might be valid under the new key-value store.

The \emph{guarantee} \( \Guar \) describes the allowed actions for the current client.
The current client can perform actions associated with the local capabilities \( \ca_l \) to update the shared state and the local capabilities.
Yet it should ensure no resource created or deleted by requiring the \emph{orthogonal} of local capabilities and shared capabilities together remains unchanged.
The orthogonal of local capabilities \( \ca \) is a set of capabilities that are compatible with the local capabilities \( \ca \).
This constraint disallow any creation and deletion for capabilities, but it allows to update capabilities.
Note that in the rely and guarantee, it is allowed to update several regions, but each region can be updated at most once.
\begin{definition}[Rely and guarantee]
\label{def:rely-guarantee}
Given the set of worlds $\World$ (\cref{def:world}), the \emph{update rely} relation, $\relyU \subseteq \World \times \World$, is defined as follows:
\sx{In case I get confused again, it is world to world so the shared and local capabilities should always make sense.}
\[	
    \begin{rclarray}
	\relyU & \eqdef &
	\Setcon{
		((\ca_l,\gs), (\ca_l, \gs'))	
	}{
        \exsts{\ca_e}
        (\ca_e \composeC \ca_l) \isdef
        \land \fora{\rid}
        \gs(\rid) = \gs'(\rid) \lor 
        \exsts{\kap, \hh, \hh', \vi_\rid, \vi_{\rid}', \vi_{e}, \vi_{e}', \ca_\rid, \ca_{\rid}', \intf}   \\
        \quad \gs(\rid) = (\hh, \vi_\rid, \ca_\rid, \intf)
        \land \gs'(\rid) = (\hh', \vi_{\rid}', \ca_{\rid}',\intf) \\
        \quad {} \land \kap \sqsubseteq \ca_{e}(\rid) 
        \land ( (\hh, \vi_e, \ca_e), (\hh', \vi_{e}', \ca_{e}') )  \in \intf(\kap)
        \land \vi_{\rid}' \geq \vi_\rid
	} \\
    \end{rclarray}
\]
The \emph{view shift rely} relation $\relyV \subseteq \World \times \World$, is defined as follows:
\[
    \begin{rclarray}
	\relyV & \eqdef &
	\Setcon{
		((\ca_l,\gs), (\ca_l, \gs'))	
	}{
        \exsts{\ca_e}
        (\ca_e \composeC \ca_l) \isdef
        \land \fora{\rid}
        \gs(\rid) = \gs'(\rid) \lor 
        \exsts{\hh, \vi, \vi'\ca, \ca, \intf}   \\
        \quad \gs(\rid) = (\hh, \vi, \ca, \intf)
        \land \gs'(\rid) = (\hh, \vi', \ca, \intf) 
	} \\
    \end{rclarray}
\]
The \emph{rely} relation is transitive closure of updates and view shift: \( \Rely = (\relyU \cup \relyV)^{*} \).
The \emph{guarantee} relation, $\Guar: \World \times \World$, is defined as follows:
\[	
    \begin{rclarray}
	\Guar & \eqdef &
	\Setcon{
		((\ca_l,\gs), (\ca_{l}', \gs'))	
	}{
        \fora{\rid}
        \gs(\rid) = \gs'(\rid) \lor {}
        \exsts{\kap, \hh, \hh', \vi_\rid, \vi_{\rid}', \ca_\rid, \ca_{\rid}', \intf}   \\
        \quad \gs(\rid) = (\hh, \vi_\rid, \ca_\rid,\intf)
        \land \gs'(\rid) = (\hh', \vi_{\rid}', \ca_{\rid}',\intf) 
        \land \kap \sqsubseteq \ca_{l}(\rid)  \\
        \quad {} \land ( (\hh, \vi_\rid, \ca_\rid), (\hh', \vi_{\rid}', \ca_{\rid}') )  \in \intf(\kap)
        \land (\ca_{l} \composeC \ca_\rid)^{\perp} = (\ca_{l}' \composeC \ca_{\rid}')^{\perp}
	} \\
    \end{rclarray}
\]
where for any element \( m \) from its domain \( \sort{M} \), the  \emph{orthogonal} is defined as:
\[
\begin{rclarray}
m^{\perp} & \defeq & \Setcon{m'}{(m \compose{} m')\isdef \land m' \in \sort{M}} 
\end{rclarray}
\]
\end{definition}

The stabilisation says assertions remain true against the environment.
Formally a set of worlds \( \setworld \) is stable under certain execution tests \( \et \) if the set is closed under rely relation under the side conditions: (a) the key-value store transfer is allowed by the execution tests \( (\mkvs, \mkvs') \in \et \);
and (b) the new view under the new key-value store is able to progress.
The first condition says there is at least one view from the environment that can trigger the transformation on the key-value store, and it is allowed by the execution tests.
The second condition is more subtle, as it allows to also update the view to a new view \( \vi' \) so that for all the possible transactions with the fingerprints \( \opset \), if they can execute under the old view, it should be able to execute under the new view.

\begin{definition}[Stable]
\label{def:stable}
A set of worlds $\setworld \subseteq \World$ is \emph{stable}, written $\stable{\setworld, \como}$, if and only if it is closed under the rely relation: 
\[
    \begin{rclarray}
        \stable{\setworld, \como} & \eqdef & 
        \begin{array}[t]{@{}l}
            \fora{\w, \w'} 
            \w \in \setworld 
            \land (\w, \w') \in \Rely  
            \land \exsts{\hh, \hh', \vi, \opset} \\
            \quad (\hh, \vi) = \eraseW{\w}
            \land (\hh', \vi') = \eraseW{\w'} 
            \land (\hh, \hh') \in \como 
            \land \pred{progress}{\w, \et} \\
            \qqquad \implies \w' \in \setworld
        \end{array} \\
    \end{rclarray}
\]
A update history heap update is allowed by consistency model, \ie \( (\hh, \hh') \in \como \), iff there exist some view \( \vi \) and operation set \( \opset \) allowed by the consistency model and the history is updated to \( \hh' \) via them:
\[
    \begin{rclarray}
        (\hh, \hh') \in \como & \eqdef & 
        \begin{array}[t]{@{}l}
            \hh = \hh' \lor 
            \exsts{ \vi, \vi', \opset, \txid, \cl}  \\
            \quad (\hh, \vi) \csat \opset : \vi' 
            \land \txid \in \fresh{\hh, \cl} 
            \land \hh'  = \updM{\hh,\vi, \txid, \opset}
        \end{array}
    \end{rclarray}
\]
A world is able to progress under an execution test \( \et \), iff it is able to execute the empty fingerprint:
\[
    \begin{rclarray}
        \pred{progress}{\w, \et} & \defeq & \exsts{\vi} \eraseW{\w} \csat \unitO :  \vi
    \end{rclarray}
\]
\end{definition}


\subsection{Rules for Global}

The \rl{PRCommit} rule lifts the local effect of transaction \( \trans \) to global level by first converting global state to (local) observable state and then propagating the local fingerprint to the global state.
%The \( \predn{down} \) predicate asserts that the local predicate \( \lpre \) is a over-approximation of the valid observation that is given by the interference.
%The \( \predn{up} \) predicate says the post-condition \( \gpost \) is the result by lifting the local fingerprints \( \fp \) to pre-condition \( \gpre \).


\begin{figure}[t!]
\hrule\vspace{5pt}

\begin{mathpar}
    \inferrule[\rl{PRCommit}]{%
        \tripleL{\lpre}{\trans}{\lpost} 
        \\ \repartition{\gpre}{\gpost}{\lpre}{\lpost}
        \\\\ \stable{\gpre, \como} 
        \\ \stable{\gpost, \como} 
    }{%
        \tripleG{\gpre}{ \ptrans{\trans} }{\gpost}
    }
    \and
    \inferrule[\rl{PRPar}]{%
        \tripleG{ \gpre_{1} }{ \cmd_{1} }{ \gpost_{1} }
        \\ \tripleG{ \gpre_{2} }{ \cmd_{2} }{ \gpost_{2} } 
        \\\\ \stable{\gpre_{1}, \como} 
        \\ \stable{\gpre_{2}, \como} 
    }{%
        \tripleG{ \gpre_{1} \sep \gpre_{2} }{ \cmd_{1} \ppar \cmd_{2} }{ \gpost_{1} \sep \gpost_{2} }
    }
    \and
    \inferrule[\rl{PRAss}]{%
        \thvar \notin \func{fv}{\lexpr} 
    }{%
        \tripleG{\thvar \dot= \lexpr }{ \pass{\thvar}{\expr} }{\thvar \dot= \expr\sub{\thvar}{\lexpr} }
    }
    \and
    \inferrule[\rl{PRAssume}]{ }{%
        \tripleG{ \expr \dot\neq 0 }{ \passume{\expr} }{ \expr \dot\neq 0 } 
    }
    \and
    \inferrule[\rl{PRChoice}]{%
        \tripleG{ \gpre }{ \cmd_{1} }{ \gpost } 
        \\ \tripleG{ \gpre }{ \cmd_{2} }{ \gpost } 
    }{%
        \tripleG{ \gpre }{ \cmd_{1} \pchoice \cmd_{2} }{ \gpost }
    }
    \and
    \inferrule[\rl{PRSeq}]{%
        \tripleG{ \gpre }{ \cmd_{1} }{ \gframe }
        \\ \tripleG{ \gframe }{ \cmd_{2} }{ \gpost }
    }{%
        \tripleG{ \gpre }{ \cmd_{1} \pseq \cmd_{2} }{ \gpost }
    }
    \and
    \inferrule[\rl{PRIter}]{%
        \tripleG{ \gpre }{ \cmd }{ \gpre } 
    }{%
        \tripleG{ \gpre }{ \cmd\prepeat }{ \gpre }
    }
    \and
    \inferrule[\rl{PRFrame}]{%
        \tripleG{ \gpre }{ \cmd }{ \gpost } 
        \\ \stable{\gframe, \como}
        \\ \func{fv}{\gframe} \cap \func{modify}{\cmd} = \emptyset 
    }{%
        \tripleG{ \gpre \sep \gframe }{ \cmd }{ \gpost \sep \gframe }
    }
\end{mathpar}


\hrule\vspace{5pt}
\[
\begin{rclarray}
    \repartition{\gpre}{\gpost}{\lpre}{\lpost} & \defeq & 
    \begin{array}[t]{@{}l@{}}
        \fora{ \w, \lenv, \stk } 
        \w \in \evalW{\gpre} 
        \implies 
        (\getSN{\eraseW{\w}}, \unitO) \in \evalLS{\lpre}  \\
        \quad {} \land \fora{\stk', \txid, \opset, \w', \cl} 
        \txid \in \fresh{\eraseW{\w}\projection{1}, \cl} 
        \land (\stub, \opset) \in \evalF[\lenv, \stk']{\lpost} \\
        \qquad {} \land \eraseW{\w'}\projection{1} = \updM{\eraseW{\w}, \txid, \opset}  \\
        %\land \eraseW{\w}\projection{2} \leq \eraseW{\w'}\projection{2} \\
        \qquad {} \land (\w, \w') \in \Guar  
        \land \eraseW{\w} \csat \opset : \eraseW{\w'}\projection{2}
        \implies \w' \in \evalW[\lenv, \stk']{\gpost}
    \end{array} 
\end{rclarray}                          
\]

\hrule\vspace{5pt}
\caption{The rules for programs}
\label{fig:rule-prog}
\end{figure}

%\azalea{
    %\sx{How to deal with the stack here? As the stack for P and Q are different, just for all quantify two stacks??}
%The quantification seems wrong. Especially, the $\extopset$ needs to be for all quantified, $\h$ needs to be there exist quantified.
%\[
     %\repartition{\gpre}{\gpost}{\lpre}{\lpost} \defeq 
     %\begin{array}[t]{@{}l@{}}
		 %\fora{\w, \hh, \vi, \lenv, \stk, \txid } 
            %\w \in \evalW{\gpre} 
            %\land (\hh, \cu) \in \eraseW{\w}
            %\Rightarrow\\
            %\quad \exsts{\h}
            %\begin{array}[t]{@{} l @{}}
			%\h = \getSN{\hh, \cu}  
                %\land (\h, \unitO) \in \evalLS{\lpre} \\
                %\land\, \fora{\extopset \in \evalF{\lpost}} 
                    %\exsts{\w', \hh', \vi'} \\
                        %\quad \hh' = \updM{\hh, \vi, \txid, \extopset} 
                       %\land \cu' = \updV{\hh, \vi, \extopset} 
                       %\land (\hh',\vi') \in \eraseW{\w'} \\
                        %\quad \land (\w, \w') \in \Guar  
                        %\land (\w, \w') \in \como
                        %\land \w' \in \evalW{\gpost}			
		%\end{array}	
%%		\right)			        	
    %\end{array} 
%\]
%}

%The \( \HHupdate \) and \( \Vupdate \) in the repartition can be replaced by syntactic rules.

%\begin{figure}
%\hrule\vspace{5pt}

%\[
   %\infer[\rl{FInit}]{%
       %\tripleF{ \lexpr \pt \lexpr }{ \lexpr \fpI \lexpr }{ \lexpr \pt \lexpr }
   %}{}
%\]

%\[
   %\infer[\rl{FRead}]{%
       %\tripleF{ \lexpr \pt \lexpr }{ \lexpr \fpR \lexpr }{ \lexpr \pt \lexpr }
   %}{}
%\]

%\[
   %\infer[\rl{FWrite}]{%
       %\tripleF{ \lexpr \pt \lexpr  }{  \lexpr \fpW \lexpr' }{ \lexpr \pt \lexpr' }
   %}{}
%\]

%\[
   %\infer[\rl{FReWrt}]{%
       %\tripleF{ \lexpr \pt \lexpr  }{  \lexpr \fpRW (\lexpr,\lexpr') }{ \lexpr \pt \lexpr' }
   %}{}
%\]

%\[
   %\infer[\rl{FFrame}]{%
       %\tripleF{ \bar{\lpre}_{1} \sep \bar{\lpre}_{2}  }{  \bar{\fp}_{1} \sep \bar{\fp}_{2} }{ \bar{\lpost}_{1} \sep \bar{\lpost}_{2} }
   %}{
       %\tripleF{ \bar{\lpre}_{1} }{ \bar{\fp}_{1} }{ \bar{\lpost}_{1} }
       %&& \tripleF{ \bar{\lpre}_{2}  }{ \bar{\fp}_{2} }{ \bar{\lpost}_{2} }
    %}
%\]


%\hrule\vspace{5pt}
%\caption{Syntactic rule for \( \HHupdate \) and \( \Vupdate \) functions}
%\label{fig:rule-prog}
%\end{figure}

