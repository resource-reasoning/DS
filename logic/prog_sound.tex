\subsection{Program Soundness}

\emph{The soundness judgement for commands} (\cref{def:soundness-judgement-cmd}) says that for any terminated trace with the initial state satisfying the precondition, if every step in the trace is either a rely step from the environment,
or the command runs one step, the postcondition should satisfy the final world \( \w' \in \evalW[\lenv,\stk']{\gpost} \).
The trace is defined by \( \pred{stepc}{\nat, \w, \w', \stk, \stk', \cmd, \et} \) predicate (\cref{def:soundness-judgement}).
It asserts that given a world \( \w \) and a local stack \( \stk \), after \( \nat \) steps of relies and local executions, the \( \cmd \) reaches \( \pskip \) and the final world and stack are \( \w'\) and \( \stk' \).
Note that \( (\mkvs, \mkvs') \in \et \) denotes the transformation on key-value store is allowed by the execution test \( \et \).
Given the soundness judgement for commands, \emph{the soundness for commands} (\cref{thm:command-soundness}) asserts given any precondition \( \gpre \) and command \( \cmd \), all the drivable postcondition \( \gpost \) from the logic rules should also derivable from the soundness judgement for commands.

\begin{definition}[soundness judgement for commands]
\label{def:soundness-judgement-cmd}
\label{def:semantic-triple}
\label{def:triple-semantic}
\label{def:semantic-steps}
The \( \predn{stepc} \) predicate is defined as the follows:
\[
\begin{rclarray}
    \pred{stepc}{0,\w, \w', \stk, \stk',\pskip, \como} & \defeq & 
    \begin{array}[t]{@{}l}
    \stk = \stk' \land \w = \w'
    \end{array} \\
    \pred{stepc}{\nat + 1,\w, \w', \stk, \stk', \cmd, \como} & \defeq &
    \begin{array}[t]{@{}l}
        \exsts{ \hh, \hh'', \w''}  
        (\w,\w'') \in \Rely  
        \land (\hh, \stub ) = \clpsW{\w}
        \land (\hh'', \stub ) = \clpsW{\w''} \\
        \qquad {} \land (\hh, \hh'') \in \como 
        \land \pred{stepc}{\nat, \w'', \w', \stk, \stk', \cmd, \como} \\
    \end{array} \\
    \pred{stepc}{\nat + 1,\w, \w', \stk, \stk', \cmd, \como} & \defeq &
    \begin{array}[t]{@{}l}
        \exsts{\cl, \w'', \stk'', \thid, \cmd'}
        \land (\clpsW{\w}, \stk), \cmd \toT{\como} ( \clpsW{\w''}, \stk'' ), \cmd' \\
        \quad {} \land (\w, \w'') \in \Guar
        \land \pred{stepc}{\nat, \w'', \w', \stk'', \stk', \cmd', \como} \\
    \end{array}
\end{rclarray}
\]
The \emph{soundness judgement for commands} is as the follows:
\[
\begin{rclarray}
    \como \tripleSemG{\gpre}{\cmd}{\gpost} & \defeq &
    \begin{array}[t]{@{}l@{}}
        \fora{ \w,\w', \stk, \stk', \lenv, \nat }  
        \w \in \evalW[\lenv, \stk]{\gpre} 
        \land \pred{stepc}{\nat, \w, \w', \stk, \stk', \cmd, \como}
        \implies \w' \in \evalW[\lenv, \stk']{\gpost} 
    \end{array}
\end{rclarray}
\]
\end{definition}                                         

\begin{theorem}[soundness for commands]
\label{thm:command-soundness}
\label{thm:per-thread-soundness}
The \emph{soundness for commands} is:
\[
    \fora{\gpre, \cmd, \gpost}
    \como \tripleG{\gpre}{\cmd}{\gpost} 
    \implies 
    \como \tripleSemG{\gpre}{\cmd}{\gpost} 
\]
\end{theorem}
\begin{proof}
It can be proved by induction on the derivations.

\caseB{\rl{PRCommit}}

Assume pre- and post- conditions such that \( \tripleG{\gpre}{\ptrans{\trans}}{\gpost}  \).
By the seminars for execution a single transaction \rl{PCommit} (\cref{fig:program_semantics}), it suffices to prove for any world \( \w \) that satisfies pre-condition, after arbitrary steps of rely, \ie \( (\w, \w') \in \Rely^{*} \) (\cref{equ:stable-pre-condition}) if the corresponding machine state \(\clpsW{\w'}\), can transfers to a new state \((\hh'',\vi'')\) (\cref{equ:commit-transaction}) then followed by arbitrary steps of rely \((\w'',\w''') \in \Rely^{*} \), the final world \( \w''' \) should satisfy the post-condition \(\gpost\) (\cref{equ:stable-post-condition}).
\sx{How to deal the \( \cl \)}
\begin{gather}
    \begin{array}{@{}l}
    \stable{\gpre, \como}  
    \implies 
    \fora{\w, \w',\lenv, \stk}  
    \exsts{ \hh, \hh' } 
    \w \in \evalW{\gpre} 
    \land (\w, \w') \in \Rely \\
    \qquad {} \land (\hh, \stub) = \clpsW{\w}
    \land (\hh', \stub) = \clpsW{\w'}
    \land (\hh, \hh') \in \como
    \implies \w' \in \evalW{\gpre} 
    \end{array} \tag{Stable Pre} \label{equ:stable-pre-condition} \\
    \nonumber \\
%
    \begin{array}{@{}l}
    \tripleL{\lpre}{\trans}{\lpost}
    \land \repartition{\gpre}{\gpost}{\lpre}{\lpost}
    \implies 
    \fora{\w, \w', \cl, \lenv, \stk, \stk'} \\
    \quad \w \in \evalW{\gpre}
    \land \cl \vdash (\eraseW{\w}, \stk), \ptrans{\trans} 
    \toT{\como} (\eraseW{\w'}, \stk'), \pskip 
    \land (\w, \w') \in \Guar \\
    \qquad \implies \w' \in \evalW[\lenv, \stk']{\gpost} 
    \end{array} \tag{Commit} \label{equ:commit-transaction} \\
    \nonumber \\
%
    \begin{array}{@{}l}
    \stable{\gpost, \como}  
    \implies 
    \fora{\w, \w',\lenv, \stk}  
    \exsts{ \hh, \hh' } 
    \w \in \evalW{\gpre} 
    \land (\w, \w') \in \Rely \\
    \qquad {} \land (\hh, \stub) = \clpsW{\w}
    \land (\hh', \stub) = \clpsW{\w'}
    \land (\hh, \hh') \in \como
    \implies \w' \in \evalW{\gpost} 
    \end{array} \tag{Stable Post} \label{equ:stable-post-condition} 
\end{gather}


\mypar{Stable pre-condition.} 
The \( \stable{\gpre, \como} \) (\cref{def:stable}) asserts any world \( \w \) that satisfies the pre-condition \( \gpre \), 
if the world can transfer to another world \( \w' \) through rely \( \Rely \), and if the transformation passes the execution test \( \como \), 
the new world \( \w' \) satisfies the pre-condition.
Thus It implies \cref{equ:stable-pre-condition}. 

\mypar{Commit.}
For any \( \w \lenv, \stk \) such that \( \w \in \evalW{\gpre} \), by the first part of repartitioning, we know \( (\clpsHH{\hh, \vi}, \unitO) \in \evalLS{\lpre} \):
\begin{equation}
\label{equ:local-pre-condition}
\fora{\w, \lenv, \stk} \w \in \evalW{P} \implies (\clpsHH{\clpsW{\w}}, \unitO) \in \evalLS{\lpre}
\end{equation}
Because of the soundness for transactions (\cref{thm:transaction-soundness}) that for any initial stacks \( \stk \), logical environments \( \lenv \) and snapshots \( \h \), if the initial configuration \( (\stk, \h, \unitO), \trans \) satisfies the pre-condition, \ie \( (\h, \unitO) \in \evalLS[\lenv,\stk]{\lpre} \), the final state \( (\stk', \h', \opset), \pskip \) should satisfy the post-condition \( \lpost \):
\begin{equation}
\label{equ:local-transaction-sound}
\begin{array}{@{}l}
    \tripleL{\lpre}{\trans}{\lpost} \implies 
    \fora{\lenv, \stk, \stk', \w, \h', \opset}
    (\getSN{\eraseW{\w}}, \unitO) \in \evalLS[\lenv,\stk]{\lpre} \\
    \quad {} \land (\stk, \getSN{\eraseW{\w}}, \unitO), \trans \toL (\stk', \h', \opset), \pskip
    \implies (\h', \opset) \in \evalLS[\lenv,\stk']{\lpost}
\end{array}
\end{equation}
The repartition \( \repartition{\gpre}{\gpost}{\lpre}{\lpost} \) also asserts that any world \( \w \) satisfying the pre-condition \( \gpre \), if the corresponding machine of the world \( \eraseW{\w} \) can transfer to a new state \( \eraseW{\w'} \) by executing the fingerprint \( \opset \), and if the world transformation \( (\w, \w') \) is allowed by the guarantee, the new world \( \w' \) should satisfy the post-condition.
\begin{equation}
\label{equ:repartition}
\begin{array}{@{}l}
    \fora{\w, \w', \cl, \lenv, \stk, \stk', \txid, \opset} \\
    \quad \w \in \evalW{\gpre}
    \land \txid \in \fresh{\eraseW{\w}\projection{1}, \cl} 
    \land (\stub,\opset) \in \evalLS[\lenv, \stk']{\lpost} \\
    \quad {} \land \eraseW{\w'}\projection{1} = \updM{\eraseW{\w}, \txid, \opset}  
    \land \eraseW{\w'}\projection{2} \geq \updV{\eraseW{\w}, \opset} \\
    \quad {} \land (\w, \w') \in \Guar 
    \land \eraseW{\w} \csat \opset : \eraseW{\w'}\projection{2} 
    \implies \w' \in \evalW[\lenv, \stk']{\gpost}
\end{array}
\end{equation}
First by \cref{equ:local-transaction-sound}, we substitute the \( (\stub, \opset) \in \evalLS[\lenv, \stk']{\lpost}\) in \cref{equ:repartition} by the semantics for transactions,
\begin{equation}
\label{equ:combined-transaction-sound}
\begin{array}{@{}l}
    \fora{\w, \w', \cl, \lenv, \stk, \stk', \h', \txid, \opset} \\
    \quad \w \in \evalW{\gpre}
    \land \txid \in \fresh{\eraseW{\w}\projection{1}, \cl} 
    \land {} \vdash (\stk, \clpsHH{\eraseW{\w}}, \unitO), \trans \toL (\stk', \h', \opset), \pskip  \\
    \quad {} \land \eraseW{\w'}\projection{1} = \updM{\eraseW{\w}, \txid, \opset}  
    \land \eraseW{\w'}\projection{1} \geq \updV{\eraseW{\w}, \opset} \\
    \quad {} \land (\w, \w') \in \Guar 
    \land \eraseW{\w} \csat \opset : \vi' 
    \implies \w' \in \evalW[\lenv, \stk']{\gpost}
\end{array}
\end{equation}
Hence we prove \cref{equ:commit-transaction} by folding all the side conditions for a atomic transaction,
\[
\begin{array}{@{}l}
    \fora{\w, \w', \stk, \stk', \lenv, \cl} \\
    \quad \w \in \evalW{\gpre}
    \land {} \cl \vdash (\eraseW{\w}, \stk), \ptrans{\trans} \toT{\como} (\eraseW{\w'}, \stk'), \pskip
    \land (\w, \w') \in \Guar 
    \implies \w' \in \evalW[\lenv, \stk']{\gpost}
\end{array}
\]

\mypar{Stable post-condition.} 
It can be proven for the similar reason as the proof for stable pre-condition.

\caseB{\rl{PRAss}}
We have \( \gpre \equiv \vx \dot= \lexpr\), \( \cmd = \passign{\vx}{\expr}\) and \( \gpost = \vx \dot= \expr\sub{\lexpr}{\vx}\) for some \( \vx, \lexpr \) and \( \expr \).
The precondition is interpreted to unit worlds \( \unitW = \evalW{\gpre} \), which is closed under rely.
If it takes one step to a new state where the stack is updated to \( \stk' = \stk\rmto{\vx}{\evalE{\expr}} \), it is easy to see that the logical value is evaluated to the same as before \( \evalLE[\lenv, \stk']{\lexpr} = \evalLE{\lexpr} \) and thus \( \evalLE[\lenv, \stk']{\expr\sub{\lexpr}{\vx}} = \evalLE[\lenv, \stk]{\expr} \).
We also know local assignment does not change the state of the world:
\[
    \fora{\w, \w', \stk, \stk', \lenv} \w \in \evalLE{\gpre} \land \eraseW{\w}, \stk, \passign{\vx}{\expr} \toT{\stub} \eraseW{\w'}, \stk', \pskip \implies \w = \w' \land \w' \in \evalLE[\lenv, \stk']{\gpost}
\]
Last, for the similar reasons the rely does not affect the post-condition.

\caseB{\rl{PRAssume}}
We have \( \gpre \equiv \gpost \equiv \expr \dot\neq 0\) and \( \cmd = \passume{\expr}\) for some \( \vx \) and \( \expr \).
The rely does not affect the pre- and post-condition because of they are interpreted to unit worlds \( \unitW\).
The semantics for assume \( \passume{\expr} \) does not change the state of the world, so we have the proof.

\caseI{\rl{PRChoice}}
We have \( \cmd \equiv \cmd_1 \pchoice \cmd_2 \) for some \( \cmd_1 \) and \( \cmd_2 \) such that \( \tripleSemG{\gpre}{\cmd_1}{\gpost} \) and \( \tripleSemG{\gpre}{\cmd_2}{\gpost} \) for some \( \cmd_1 \) and \( \cmd_2 \).
Because the semantics for non-deterministic choice \( \cmd_1 \pchoice \cmd_2 \) does not change the state of the world, It is easy to see:
\[
    \tripleSemG{\gpre}{\cmd_1}{\gpost} \land \tripleSemG{\gpre}{\cmd_2}{\gpost} \implies \tripleSemG{\gpre}{\cmd_1 \pchoice \cmd_2}{\gpost}
\]

\caseI{\rl{PRSeq}}
We have \( \cmd \equiv \cmd_1 \pseq \cmd_2 \) for some \( \cmd_1 \) and \( \cmd_2 \) such that \( \tripleSemG{\gpre}{\cmd_1}{\gframe} \) and \( \tripleSemG{\gframe}{\cmd_2}{\gpost} \) for some \( \cmd_1, \cmd_2\) and \( \gframe \).
By the semantics  we know for any world \( \w \) and stack \( \stk \):
\[
    (\eraseW{\w}, \stk), \pskip \pseq \cmd_2 \toT{\stub} (\eraseW{\w}, \stk), \cmd_2
\]
it is easy to see:
\[
    \tripleSemG{\gpre}{\cmd_1 }{\gframe} \land \tripleSemG{\gframe}{\cmd_2}{\gpost} \implies \tripleSemG{\gpre}{\cmd_1 \pseq \cmd_2}{\gpost}
\]

\caseI{\rl{PRIter}}
By the definition of \( \predn{stepc}\), it suffice to prove:
\[
    \fora{\nat} \tripleG{\gpre}{\cmd^{\nat}}{\gpre} \implies \tripleSemG{\gpre}{\cmd^{\nat}}{\gpre} 
\]
We prove this by induction on the number \( \nat \).
When \( \nat = 1 \), it holds by the \ih
If it holds when \( \nat = i\), let consider \( \nat = i + 1 \).
By the semantics  we know for any world \( \w \) and stack \( \stk \):
\[
    (\eraseW{\w}, \stk), \pskip \pseq \cmd \toT{\stub} (\eraseW{\w}, \stk), \cmd
\]
it is easy to see:
\[
    \fora{\nat} \tripleSemG{\gpre}{\cmd^{i}}{\gpre} \land \tripleSemG{\gpre}{\cmd}{\gpre} \implies \tripleSemG{\gpre}{\cmd^{i+1}}{\gpre} 
\]

\caseI{\rl{PRFrame}}

Given \( \tripleG{\gpre}{\cmd}{\gpost} \) and \( \stable{\gframe, \como}\), we need to prove \( \tripleSemG{\gpre \sep \gframe }{\cmd}{\gpost \sep \gframe } \).
By the \ih that  \( \tripleG{\gpre}{\cmd}{\gpost} \implies \tripleSemG{\gpre}{\cmd}{\gpost} \), we know that for any trace defined by the \( \predn{stepc} \) predicate with an initial world \( \w \) satisfying the precondition \( \gpre \), the finial world \( \w' \) satisfies the postcondition \( \gpost \). 
Now we need to prove the frame does not invalidate the trace:
\[
\begin{array}[t]{@{}l}
    \fora{ \w,\w', \stk, \stk', \lenv, \nat, \et }  
    \land \pred{stepc}{\nat, \w, \w', \stk, \stk', \cmd, \como} 
    \land \w' \in \evalW[\lenv, \stk']{\gpost} 
    \land \stable{\gframe, \et} \\
    \quad \fora{\w_{f}} \exsts{\w''}
    \pred{stepc}{\nat, \w \composeW \w_f, \w'', \stk, \stk', \cmd, \como} 
    \land \w_f \in \evalW[\lenv, \stk]{\gframe} 
    \land \w'' \in \evalW[\lenv, \stk']{\gframe \sep \gpost}
\end{array}
\]
We prove it by induction on the number \( \nat \).
If \( \nat = 0 \),  we know \( \w = \w'\), \( \stk = \stk'\) and \( \cmd = \pskip \).
We can pick \( \w'' = \w \composeW \w_f\).
Assume it holds for \( \nat = i \) steps, let consider \( i + 1 \) steps.
Assume some initial worlds \( \w \), stacks \( \stk \) and logical environments \( \lenv \), and worlds from the frame \( \w_f \in \evalW[\lenv, \stk]{\gframe}\) such that \( (\w \composeW \w_f)\isdef \).
Given the definition of \( \predn{stepc}\) predicate, the next step may be a step of guarantee which change the command or a step of rely.

First let consider a guarantee step.
Let \( \cmd' \) and \( \cmd' \) be the new command and stack after the transformation \( (\w, \w') \in \Guar \) for some new world \( \w'\).
Assuming a world \( \w'' \) such that \( (\w \composeW \w_f, \w'') \in \Guar \), we want to prove \( \w''  = \w' \composeW \w_f'' \) for some worlds from the frame \( \w_f'' \in \evalW[\lenv, \stk']{\gframe} \).
Because of the side condition \( \func{fv}{\gframe} \cap \func{modify}{\cmd} = \emptyset \), the stack does not affect the interpretation of the frame \( \evalW{\gframe} = \evalW[\stk',\lenv]{\gframe}\).
Because of the \cref{lem:locality-update} and the stabilisation of the frame, there exists a rely step \( (\w_f, \w_{f}') \in \Rely \) where the key-value store has been updated to match up with \( \w' \), yet the view remain the same, \ie \( \eraseW{\w_{f}'}\projection{1} = \eraseW{\w}\projection{1}\) and \( \eraseW{\w_f}\projection{2} = \eraseW{\w'_{f}}\projection{2}\).
We also know the local capabilities of \( \w'_{f}\) are compatible with the ones of \( \w' \), \ie \( (\w'\projection{1} \composeC \w'_{f}\projection{1})\isdef\).
By the \cref{lem:mono-view}, the view of \( \w'\) is greater than the view of \( \w \).
Since the rely allows arbitrarily to shift the view to the right, there exists a world \( \w_f''\) by shifting the view from \( \w_f' \) such that \( \w_f, \w_f'') \in \Rely \) and therefore \( (\w' \composeW \w_f'')\isdef \).
%Last, we need to check the execution test, especially when \( \eraseW{\w} \neq \eraseW{\w'}\).
%It means a transaction has been committed, so there exist some fingerprints \( \opset \) such that \( \eraseW{\w} \csat \opset : \eraseW{\w'}\projection{2}\), which then implies \( (\eraseW{\w}\projection{1},\eraseW{\w'}\projection{1}) \in \et \).
Therefore, for any world transformation via guarantee \( (\w, \w') \in \Guar \), there exists \( \w_f, \w_f'' \in \evalW[\lenv,\stk']{\gframe}\)  such that \( (\w composeW \w_f)\isdef\) and \( (\w' composeW \w_f'')\isdef\).
By the definition of guarantee we have \( (\w composeW \w_f, \w' composeW \w''_f) \in \Guar \).
Finally, by applying \ih when \( \nat = i \), we can now fold the \( \predn{stepc} \) predicate for \( \nat = i + 1 \).

If it is a rely step, let assume \( (\w, \w') \in \Rely \) and \( (\w \composeW \w_f, \w'') \in \Rely \) for some world \( \w'' \) and we want to prove \( \w''  = \w' \composeW \w_f'' \) and \( \w_f'' \in \evalW[\lenv, \stk]{\gframe} \).
By \( (\w \composeW \w_f, \w'') \in \Rely \), the world transformation is allowed by some capabilities, says \( \ca\), that compatible with the local capabilities from \( \w \composeW \w_f \), \ie \( (\ca \composeC (\w\projection{1} \composeC \w_f\projection{1}) )\isdef \).
This means the capabilities \( \ca \) are disjointed with the local capabilities \( \w\projection{1} \) and local capabilities \( \w_f\projection{1}\) respectively.
Because of the stable of \( \gframe \), there is a world \( \w_f'' \) such that \( \w_f'' \in \evalW{\gframe}\) and \( \eraseW{\w_f''} = \eraseW{\w'} = \eraseW{\w''}\).
Then because the rely and stable does not alter the local capabilities, thus we prove \( \w'' = \w' \composeW \w_f'' \).
Finally, by applying \ih when \( \nat = i \), we can now fold the \( \predn{stepc} \) predicate for \( \nat = i + 1 \).

%Assume a world that satisfying the precondition \( \w \in \evalW{\gpre} \).
%Because the assertion \( \gpre \sep \gframe \) holds, by the interpretation function (\cref{def:assertion}), assume a world \( \w_{f}\) that satisfies the frame and is compatible with the precondition, \ie \( (\w \composeW \w_f)\isdef \).
%It means the machine states are the same \( \eraseW{\w} = \eraseW{\w_f}\) and the local capabilities are disjointed, \( \w\projection{1} \composeC \w_{f}\projection{1} \).
%This mean the for every step from the first trace \( \w_i \) there exists a world \( \w_i \compose \w_f\) where \( \w_f \in \evalW{}\)
%We prove that by induction on the length of the first trace.
%Assume after \( i \) steps, the first trace ends up with a world \( \w' \composeW \w_{f}'\), and the second trace ends up with \( \w' \).
%Let consider the next step for the first trace.
%If the next step executes the commands, it means the transformation of the world is allowed by guarantee.
\end{proof}


\begin{lemma}[Locality of update]
When a client executes a transaction allowed by guarantee, the effect to the key-value store is included in the rely of other clients.
\label{lem:locality-update}
\[
\begin{array}{@{}l}
    \fora{\w, \w', \w''} (\w\projection{1} \composeC \w'\projection{1})\isdef \land \clpsW{\w}\projection{1} = \clpsW{\w'}\projection{1} \land (\w, \w'') \in \Guar  \\
    \quad \implies \exsts{\w'''} (\w', \w''') \in \Rely \land (\w''\projection{1} \composeC \w'''\projection{1})\isdef \land \clpsW{\w''}\projection{1} = \clps{\w'''}\projection{1}
\end{array} 
\]
\end{lemma}
\begin{proof}
Assume two worlds \( \w \) and \( \w' \) where the local capabilities are compatible \((\w\projection{1} \composeC \w'\projection{1})\isdef\) and the key-value stores are the same, \ie \( \clpsW{\w}\projection{1} = \clpsW{\w'}\projection{1} \).
If the first world can transfer to a new world \( \w'' \) allowed by guarantee \( (\w, \w'' ) \in \Guar \) so that for any region \( \rid \) that has been updated, there exists a \( \kap \) such that \( \kap \sqsubseteq \ca(\rid) \) which gives the permission.
Formally, let \( (\ca, \gs) = \w \) and \( (\ca'', \gs'') = \w'' \):
\[
\begin{array}{@{}l}
    \fora{\rid} 
    \gs(\rid) = \gs''(\rid) \lor {} \\
    \quad \gs(\rid) \neq \gs''(\rid) 
    \land \exsts{\hh, \hh', \vi, \vi', \ca_s, \ca_{s}', \intf, \kap} \\
    \qquad \gs(\rid) = (\hh, \vi, \ca_{s}, \intf) 
    \land \gs''(\rid) = (\hh', \vi', \ca_{s}', \intf)
    \land \kap \sqsubseteq \ca(\rid) \\
    \qquad {} \land ((\hh, \vi, \ca_{s}), (\hh', \vi', \ca_{s}')) \in \intf(\kap)
\end{array} 
\]
We want to construct a world \( \w''' = (\ca''', \gs''') \) that satisfies the rely \( (\w', \w''') \in \Rely \).
First, we take the same local capabilities as the \( \w' \):
\begin{equation}
\label{equ:construct-local-ca}
    \ca''' = \ca''
\end{equation}
Then we propagate updates for key-value store and shared capabilities from \( \w'' \) to \( \w''' \) but keep the views as the same in the \( \w' \),
\begin{equation}
\label{equ:construct-gs}
    \fora{\rid} \exsts{\hh,\vi,\ca,\intf} \gs'''(\rid) = (\hh, \vi, \ca, \intf) \land \gs''(\rid) = (\hh, \stub, \ca, \intf) \land \w'\projection{2}(\rid) = (\stub, \vi, \stub, \intf)
\end{equation}
Combining \cref{equ:construct-local-ca}, \cref{equ:construct-gs} and that the local capabilities are compatible \( ( \ca \composeC \ca' )\isdef \), it is easy to see \( ( \w', \w''' ) \in \relyU \) by \cref{def:rely-guarantee}, therefore \( ( \w', \w''' ) \in \Rely \).
Given the way we construct \( \w''' \), it directly proves \( \clps{\w''}\projection{1} = \clps{\w'''}\projection{1} \).
Because the guarantee require the orthogonal of capabilities remains the same, the local capabilities are still compatible.
\end{proof}

\begin{lemma}[Monotonicity of view]
\label{lem:mono-view}
The view monotonically increases with respect to the operational semantic for commands:
\[
    \begin{array}{@{}l}
        \fora{\mkvs, \mkvs', \stk, \stk', \vi, \vi', \cmd, \cmd'} (\mkvs, \vi, \stk), \cmd \toT{\et} (\mkvs', \vi', \stk'), \cmd' \implies \vi \leq \vi'
    \end{array}
\]
\end{lemma}
\begin{proof}
    It can be proved by induction on the derivations.
    \caseB{\rl{PCommit}}
    By the definition of \( \Vupdate \), we know the updated view is greater than the view before, \ie \( \fora{\mkvs, \vi, \vi', \opset} \vi' = \updV{\mkvs, \vi, \opset} \implies \vi' \geq \vi\).
    By the semantics, the finial view \( \vi' \) after executing a transaction is \( \vi' \geq \updV{\mkvs', \vi'', \opset} \) where \( \vi'' \geq \vi\).
    Thus, we prove \( \vi' \geq \vi \).
    \caseB{\rl{PAssign}, \rl{Passume}, \rl{PChoice}, \rl{Iter}, \rl{PSeq}}
    For these cases, we have \( \vi' = \vi\).
    \caseI{\rl{PSeq}}
    It can be directly derived from \ih
\end{proof}


\emph{The soundness for programs} (\cref{def:soundness-prog}) is a non-trivial proof as clients have the up-to-date key-value store because of the interleaving semantics but not the views.
\emph{The soundness judgement for programs} (\cref{def:soundness-judgement-prog}) asserts that given a world environment \( \wenv \) that are worlds indexed by clients, an initial client environment \( \thdenv \), and a program \( \prog\), after \( \nat \)  steps of executions or rely all clients reach \( \pskip \), the finial world environment and client environment are \( \wenv' \) and \( \thdenv' \).
Assuming all clients start from the same world \( \w \) satisfying the overall precondition, \emph{The soundness for programs} requires the finial world environment \( \wenv' \) defined by \( \predn{stepp} \) satisfying the postcondition.

\begin{definition}[Soundness judgement for programs]
\label{def:soundness-judgement-prog}
Assume \emph{world environments} \( \wenv \in \ClientID \parfinfun \World\), the \emph{soundness judgement for program} asserts either one client executes a its commands or all clients take rely steps:
\[
\begin{rclarray}
    \pred{stepp}{0,\wenv, \wenv', \thdenv, \thdenv',\prog, \como} & \defeq &  
    \\
    \multicolumn{3}{@{}l}{%
    \qqquad 
    \begin{array}[t]{@{}l}
    \wenv = \wenv' \land \thdenv = \thdenv' 
    \land \dom(\wenv) = \dom(\thdenv) = \dom(\prog)
    \land \fora{\client \in \dom(\prog)} \prog(\client) = \pskip
    \end{array}%
    }
    \\
    \pred{stepp}{ \nat + 1, \wenv, \wenv', \thdenv, \thdenv',\prog, \como} & \defeq & \\
    \multicolumn{3}{@{}l}{%
    \qqquad 
    \begin{array}[t]{@{}l}
    \exsts{\wenv'', \thdenv'', \prog'', \cl, \w, \w'} 
    \fora{\cl \in \dom(\wenv)} \\
    \quad (\wenv(\cl), \wenv(\cl)'') \in \Rely 
    \land \pred{compatible}{\wenv''} 
    \land \pred{stepp}{ \nat, \wenv'', \wenv', \thdenv'', \thdenv',\prog'', \como} 
    \end{array}%
    }
    \\
    \pred{stepp}{ \nat + 1, \wenv, \wenv', \thdenv, \thdenv',\prog, \como} & \defeq & \\
    \multicolumn{3}{@{}l}{%
    \qqquad 
    \begin{array}[t]{@{}l}
    \exsts{\wenv'', \thdenv'', \prog'', \cl, \w, \w'} 
    \wenv(\cl) = \w 
    \land \wenv'(\cl) = \w' 
    \land (\w, \w') \in \Guar \\
    \quad {} \land \func{world2conf}{\wenv}, \thdenv, \prog \toG{\como} \func{world2conf}{\wenv''}, \thdenv'', \prog'' \\
    \quad {} \land \pred{compatible}{\wenv''} 
    \land \pred{stepp}{ \nat, \wenv'', \wenv', \thdenv'', \thdenv',\prog'', \como} 
    \end{array}%
    }
    \\
\end{rclarray}
\]
where the \( \predn{compatible} \) asserts all clients have the same key-value store and shared capabilities, but not necessary for views, and the \( \funcn{world2conf}\)collapse a world environment to a configuration:
\[
\begin{rclarray}
    \pred{compatible}{\wenv} & \defeq & 
    \begin{array}[t]{@{}l}
        \exsts{\wenv'}
        (\circledast_{\cl \in \dom{\wenv'}} \wenv'{\cl} )\isdef
        \fora{\cl \in \dom{\wenv}} (\wenv(\cl), \wenv'(\cl)) \relyV 
    \end{array} \\
    \func{world2conf}{\wenv} & \defeq & 
    \begin{cases}
        (\mkvs, \lambda \client \ldotp \eraseW{\wenv(\client)}\projection{2}) & \text{if } \fora{ \client }  \eraseW{\wenv(\client)}\projection{1} = \mkvs \\
        \text{undefined} & \text{otherwise}
    \end{cases} \\
\end{rclarray}
\]
\end{definition}

\begin{theorem}[Soundness for programs]
\label{def:soundness-prog}
For any program \( \prog \), if a world \( \w \) satisfying the precondition \( \gpre \), and for any world environment and thread environment \( \wenv', \thdenv' \) satisfying the \( \predn{stepp} \), the \( \wenv' \) satisfies the postcondition \( \gpost \):
\[
\begin{array}{@{}l}
\fora{\gpre, \gpost, \prog, \lenv, \como, \stk, \w, \wenv, \wenv', \thdenv, \thdenv', \nat}  \exsts{\stk'}
    \tripleG{\gpre}{\prog}{\gpost} \\
    \quad {} \land \w \in \evalW{\gpre}
    \land \dom(\wenv) = \dom(\prog) = \dom(\thdenv)
    \land \prod\limits_{\cl \in \dom(\wenv)} \wenv(\cl) = \w \\
    \quad {} \land \fora{\thid} \thdenv(\thid) = (\stk)
    \land \pred{steps}{\nat,\wenv, \wenv', \thdenv, \thdenv',\prog, \como}  \\
    \qquad {} \implies \prod\limits_{\cl \in \dom(\wenv')} \wenv'(\cl) \in \evalW[\lenv, \stk']{\gpost}
\end{array}
\] 
\end{theorem}
\begin{proof}
It can be proved by induction on derivations.

\caseB{\( \prog = \Set{\txid \mapsto \cmd} \)}
 
If there is only one client, we want to prove:
\[
    \pred{stepp}{\nat, \Set{\cl \mapsto \w},\Set{\cl \mapsto \w'}, \Set{\cl \mapsto \stk}, \Set{ \cl \mapsto \stk'}, \Set{\cl \mapsto \cmd}, \et} \implies \w' \in \evalW[\lenv, \stk']{\gpost}
\]
Because the \cref{lem:prgram-step-to-command-step} that the \( \predn{stepp} \) implies \( \predn{stepc}\), then because of the soundness for commands (\cref{thm:per-thread-soundness}) \( \tripleSemG{\gpre}{\cmd}{\gpost}\), we prove \( \w' \in \evalW[\lenv, \stk']{\gpost} \).

\caseI{\( \prog \ppar \cmd \)}

We want to prove that \( \tripleG{\gpre_{1} \sep \gpre_{2}}{\prog \ppar \cmd}{ \gpost_{1} \sep \gpost_{2} } \), \( \tripleSemG{\gpre_{1}}{\prog}{ \gpost_{1} } \) and \( \tripleSemG{\gpre_{2}}{\cmd}{ \gpost_{2} } \) implies \( \tripleSemG{\gpre_{1} \sep \gpre_{2}}{\prog \ppar \cmd}{ \gpost_{1} \sep \gpost_{2} } \).
Because \( \gpre_{1} \sep \gpre_{2} \), we have \( \wenv \) and \( \w \) such that \( \prod\limits_{\cl \in \dom(\wenv)} \wenv(\cl) \in \evalW{\gpre_{1}} \) and \( \w \in \evalW{\gpre_{2}}\) for some \( \lenv \) and \( \stk \), which implies \( \pred{compatible}{\wenv \uplus \Set{\cl \mapsto \w}}\).
Note that since stacks are local for clients, it is safe to assume variables from different stacks are disjointed and we will omit the stacks.
Give the \ih that \( \prog \) holds and the soundness result for commands \( \cmd \), we want to prove the follows:
\[
\begin{array}{@{}l}
    \fora{\nat, \wenv, \wenv', \thdenv, \thdenv', \w, \w', \stk, \stk', \cl, \et} 
    \pred{stepp}{\nat, \wenv, \wenv', \thdenv, \thdenv', \prog, \et}  \\
    \quad {} \land \pred{stepc}{\nat, \w, \w', \stk, \stk', \cmd, \et} 
    \land \pred{compatible}{\wenv \uplus \Set{\cl \mapsto \w}} \\
    \qquad \exsts{\wenv'', \thdenv'', \stk'' } 
    \pred{stepp}{\nat, \wenv \uplus \Set{\cl \mapsto \w}, \wenv'', \thdenv \uplus \Set{\cl \mapsto \stk}, \thdenv'', \prog \uplus \Set{\cl \mapsto \cmd}, \et}  \\
    \qqquad {} \land \prod\limits_{\cl' \in \dom(\wenv'') } \wenv''(\cl')  \in \evalW[\lenv, \stk']{\gpost_{1} \sep \gpost_{2}}
\end{array}
\]
We prove it by induction on the number \( \nat \).
If \( \nat = 0\), it holds trivially by picking \( \wenv'' = \wenv \uplus \Set{\cl \mapsto \w} \).
If it holds when \( \nat = i\), let considers \( \nat = i + 1\).
There are three cases, one client from \( prog \) executes its commands, the client \( \cl \) executes its commands or both take rely steps to cope with potentially other clients from environment.
If one client is going to take a guarantee step, by unfolding the definition of \( \predn{stepp} \), the \( \prog \) takes one step to a new \( \wenv_i\), \( \prog_i \) and \( \thdenv_i \):
\[
\exsts{\cl'} (\wenv(\cl'), \wenv_i(\cl')) \in \Guar \land  \pred{compatible}{\wenv_i} \land \pred{steppp}{i, \wenv_i, \wenv', \thdenv_i, \thdenv', \prog_i, \et}
\]
Because the of the compatibility \( \pred{compatible}{\wenv \uplus \Set{\cl \mapsto \w}} \) and the \cref{lem:locality-update}, there exists a world \( \w''\) by unfolding \( \predn{stepc} \):
\[
    (\w, \w'') \in \Rely \land \pred{stepc}{i, \w'', \w', \stk, \stk', \cmd, \et}  \land \pred{compatible}{\wenv_i \uplus \Set{\cl \mapsto \w''}}
\]
Because of \cref{lem:locality-update}, we have the proof by applying \ih and then folding back.
Similarly, Let consider that the \( \cmd \) takes one step transferring the world to \( \w'' \) as \( (\w, \w'') \in \Guar \).
Because the of the compatibility \( \pred{compatible}{\wenv \uplus \Set{\cl \mapsto \w}} \) and the \cref{lem:locality-update}, there exists a world \( \wenv''\) by unfolding \( \predn{stepp} \):
\[
    \fora{\cl' \in \dom(\wenv)} \land (\wenv(\cl'), \wenv(\cl')'') \in \Rely \land \pred{compatible}{\wenv''} \land \pred{stepp}{ \nat, \wenv'', \wenv', \thdenv'', \thdenv',\prog'', \como} 
\]
Therefore we have the proof by applying \ih when \( \nat = i \) and folding back.
Last, It is trivial true when both \( \prog\) and \( \cmd \) take a rely step as the local capabilities are compatible with each others.

\end{proof}


\begin{lemma}
\label{lem:prgram-step-to-command-step}
\[
\begin{array}{@{}l}
    \for{\nat, \w, \w', \stk, \stk', \cmd, \et, \cl} \\
    \pred{stepp}{\nat, \Set{\cl \mapsto \w},\Set{\cl \mapsto \w'}, \Set{\cl \mapsto \stk}, \Set{ \cl \mapsto \stk'}, \Set{\cl \mapsto \cmd}, \et}  \\
    \quad \implies \pred{stepc}{\nat, \w, \w', \stk, \stk', \cmd, \et} \\
\end{array}
\]
\end{lemma}
\begin{proof}
Induction on the number \( \nat \).

\caseB{\nat = 0}
It is easy to see that \( \cmd = \pskip \), \( \w = \w'\) and \( \stk = \stk' \) by the definition of \(  \predn{stepp}\), so we have the proof.

\caseI{\nat = i + 1}

Assume it holds when \( \nat = i \), let consider \( \nat = i + 1 \).
The if the \( i + 1\) step is a rely step, it trivially holds by applying the \ih and then folding back the \( \predn{stepc} \).
Let consider a guarantee step.
By the definition \( \predn{stepp}\), there exists a world \( \w'' \), a stack \( \stk'' \) and commands \( \cmd' \) such that:
\[
    (\w, \w'') \in \Guar \land \pred{stepp}{ i, \Set{\cl \mapsto \w''},\Set{\cl \mapsto \w'}, \Set{\cl \mapsto \stk''}, \Set{ \cl \mapsto \stk'}, \Set{\cl \mapsto \cmd'}, \como}
\]
First by \ih, we know  \( \pred{steps}{ i, \w'', \w', \stk'', \stk', \cmd', \como} \) holds.
Since there is only one client, by the semantics for commands and programs (\cref{fig:program_semantics}), we know \( (\eraseW{\w}, \stk ), \cmd \toL{\et} (\eraseW{\w''}, \stk'), \cmd' \).
Thus, by folding the predicate, we have that \( \pred{steps}{ i + 1, \w, \w', \stk, \stk', \cmd', \como} \).
\end{proof}
