\subsection{Program Soundness}

The soundness judgement says for any terminated trace, a trace reaching \( \pskip \), where every step in the trace is either a environment step that is allowed by the rely and consistency model, or the command get reduced one step, then if the precondition satisfies the initial world of the trace \( \w \in \evalW{\gpre} \) the postcondition should satisfy the final world \( \w' \in \evalW[\lenv,\stk']{\gpost} \).

\begin{definition}[Soundness Judgement]
\label{def:semantic-triple}
\label{def:triple-semantic}
\label{def:semantic-steps}
\label{def:soundness-judgement}
The \( \predn{step} \) predicate is defined as the follows,
\[
\begin{rclarray}
    \pred{step}{0,\w, \w', \stk, \stk',\pskip, \como} & \defeq & 
    \begin{array}[t]{@{}l}
    \stk = \stk' \land \w = \w'
    \end{array} \\
    \pred{step}{\nat + 1,\w, \w', \stk, \stk', \cmd, \como} & \defeq &
    \begin{array}[t]{@{}l}
    \exsts{ \hh, \hh', \w''}  \\
        \quad (\w,\w'') \in \Rely  
        \land (\hh, \stub ) \in \clpsW{\w}
        \land (\hh', \stub ) \in \clpsW{\w'} \\
        \qquad {} \land (\hh, \hh') \in \como 
        \land \pred{step}{\nat, \w'', \w', \stk, \stk', \cmd, \como} \\
    \end{array} \\
    \pred{step}{\nat + 1,\w, \w', \stk, \stk', \cmd, \como} & \defeq &
    \begin{array}[t]{@{}l}
        \fora{\hh, \hh'', \vi, \vi'', \stk'', \lb, \thid, \cmd'}
        (\hh,\vi) \in \clpsW{\w} \\
        \quad {} \land (\stk, \hh, \vi), \cmd \toT{\como} ( \stk'', \hh'', \vi'' ), \cmd' \\
        \qquad {} \land \exsts{\w''}
        (\w, \w'') \in \Guar
        \land (\hh'',\vi'') \in \clpsW{\w''} 
        \land \pred{step}{\nat, \w'', \w', \stk'', \stk', \cmd', \como} \\
    \end{array}
\end{rclarray}
\]
Given above the soundness judgement is as the follows,                                                  
\[
\begin{rclarray}
    \como \tripleSemG{\gpre}{\cmd}{\gpost} & \defeq &
    \begin{array}[t]{@{}l@{}}
        \fora{ \w,\w', \stk, \stk', \lenv, \nat }  
        \w \in \evalW[\lenv, \stk]{\gpre} 
        \land \pred{step}{\nat, \w, \w', \stk, \stk', \cmd, \como}
        \implies \w' \in \evalW[\lenv, \stk']{\gpost} 
    \end{array}
\end{rclarray}
\]
\end{definition}                                         

Here it is a over approximation of the view environment that assumes the view environment does not intertwine with the current view.
For many consistency models this judgement is good enough, because the specifications do not mentioned the view environment.
Yet the soundness judgement for SI, for example, is not very strong since it includes some cases that are allowed locally but might be disallowed when the view environment comes in.

\begin{theorem}[soundness for a client]
\label{thm:per-thread-soundness}
The per-thread soundness is the follows,
\[
    \fora{\gpre, \cmd, \gpost}
    \como \tripleG{\gpre}{\cmd}{\gpost} 
    \implies 
    \como \tripleSemG{\gpre}{\cmd}{\gpost} 
\]
\end{theorem}
\begin{proof}
Induction on the derivations.

\caseB{\rl{PRCommit}}

We have \( \prog \equiv \ptrans{\trans} \).
Because a transaction \( \ptrans{\trans} \) is reduced by one step in the semantics, it is sufficient to prove for any world \(\w\) that satisfies pre-condition, after arbitrary steps of rely, \ie \( (\w, \w') \in \Rely^{*} \) (\cref{equ:stable-pre-condition}) if the corresponding machine state \((\hh',\vi') \in \clpsW{\w'}\), can transfers to a new state \((\hh'',\vi'')\) (\cref{equ:commit-transaction}) then followed by arbitrary steps of rely \((\w'',\w''') \in \Rely^{*} \), the final world \( \w''' \) should satisfy the post-condition \(\gpost\) (\cref{equ:stable-post-condition}).
\sx{typesetting is a bit strange}
\begin{gather}
    \begin{array}{@{}l}
    \stable{\gpre, \como}  
    \implies 
    \fora{\w, \w',\lenv, \stk}  
    \exsts{ \hh, \hh' } \\
    \quad \w \in \evalW{\gpre} 
    \land (\w, \w') \in \Rely \\
    \qquad {} \land (\hh, \stub) \in \clpsW{\w}
    \land (\hh', \stub) \in \clpsW{\w'}
    \land (\hh, \hh') \in \como
    \implies \w' \in \evalW{\gpre} 
    \end{array} \tag{Stable Pre} \label{equ:stable-pre-condition} \\
%
    \begin{array}{@{}l}
    \tripleL{\lpre}{\trans}{\lpost}
    \land \repartition{\gpre}{\gpost}{\lpre}{\lpost}
    \implies 
    \fora{\w, \hh, \hh', \vi, \vi', \thid, \lenv, \stk, \stk'} \\
    \quad \w \in \evalW{\gpre}
    \land (\hh, \vi) \in \clpsW{\w} 
    \land \thid, (\stk, \hh, \vi), \ptrans{\trans} 
    \toT{\como} (\stk', \hh', \vi'), \pskip  \\
    \qquad {} \land \exsts{\w'}
    (\w, \w') \in \Guar
    (\hh', \vi') \in \clpsW{\w'} 
    \land \w' \in \evalW[\lenv, \stk']{\gpost} 
    \end{array} \label{equ:commit-transaction} \tag{Commit} \\
%
    \begin{array}{@{}l}
    \stable{\gpost, \como}  
    \implies 
    \fora{\w, \w',\lenv, \stk}  
    \exsts{ \hh, \hh' } \\
    \quad \w \in \evalW{\gpre} 
    \land (\w, \w') \in \Rely \\
    \qquad {} \land (\hh, \stub) \in \clpsW{\w}
    \land (\hh', \stub) \in \clpsW{\w'}
    \land (\hh, \hh') \in \como
    \implies \w' \in \evalW{\gpost} 
    \end{array} \tag{Stable Post} \label{equ:stable-post-condition} 
\end{gather}

\sx{make sure the stack is correct}

\noindent\textbf{Stable pre-condition.} 
The \( \stable{\gpre, \como} \) predicate asserts any world \( \w \) that satisfies the pre-condition \( \gpre \), if the world can transfer to another world \( \w' \) through rely \( \Rely \), and if the transfer also satisfies the consistency model \( \como \), the new world \( \w' \) satisfies the pre-condition, which implies \cref{equ:stable-pre-condition}. 
\\
\textbf{Commit.}
For any \( \w, \hh, \vi, \lenv, \stk \) such that \( \w \in \evalW{\gpre} \) and \( (\hh, \vi) \in \clpsW{\w} \), we know \( (\clpsHH{\hh, \vi}, \unitO) \in \evalLS{\lpre} \), this is,
\begin{equation}
\label{equ:local-pre-condition}
\fora{\w, \hh, \vi, \lenv, \stk} \w \in \evalW{P} \land (\hh, \vi) \in \clpsW{\w} \implies (\clpsHH{\hh, \vi}, \unitO) \in \evalLS{\lpre}
\end{equation}
Because of the soundness of transaction (\cref{thm:transaction-soundness}), given an initial stack \( \stk \) and a logical environment \( \lenv \), if the initial configuration \( (\stk, \h, \unitO), \trans \) satisfies the pre-condition, \ie \( (\h, \unitO) \in \evalLS[\lenv,\stk]{\lpre} \), and if it can transfer to a final configuration \( (\stk', \h', \opset), \pskip \), the final state should satisfy the post-condition \( \lpost \).
This is,
\begin{equation}
\label{equ:local-transaction-sound}
\begin{array}{@{}l}
    \tripleL{\lpre}{\trans}{\lpost} \implies \\
    \quad \fora{\lenv, \stk, \stk', \hh, \vi, \h', \opset}  
    (\getSN{\hh,\vi}, \unitO) \in \evalLS[\lenv,\stk]{\lpre}
    \land \vdash (\stk, \h, \unitO), \trans \toL (\stk', \h', \opset), \pskip
    \implies (\h', \opset) \in \evalLS[\lenv,\stk']{\lpost}
\end{array}
\end{equation}
The repartition \( \repartition{\gpre}{\gpost}{\lpre}{\lpost} \) also asserts that any world \( \w \) satisfying the pre-condition \( \gpre \), if the corresponding machine of the world (ignoring the capabilities here), \ie \( (\hh, \vi) \), can transfer to a new state \( (\hh',\vi') \), by committing the operations \( \opset \), then if a world \( \w' \) can collapses to the new machine state \( (\hh',\vi') \) and the transition \( (\w, \w') \) is allowed by both the guarantee and the consistency model, the new world \( \w' \) should satisfy the post-condition.
\begin{equation}
\label{equ:repartition}
\begin{array}{@{}l}
    \fora{\w,  \hh, \hh', \vi, \vi', \lenv, \stk, \stk', \txid, \opset} \exsts{\w'} \\
    \quad \w \in \evalW{\gpre}
    \land (\hh, \vi, \stub) \in \eraseW{\w}
    \land \txid \in \fresh{\hh} 
    \land (\stub,\opset) \in \evalLS[\lenv, \stk']{\lpost} \\
    \quad {} \land \hh' = \updM{\hh, \vi, \txid, \opset}  
    \land \vi' \geq \updV{\hh', \vi, \opset} \\
    \quad {} \land (\hh',\vi', \stub) \in \eraseW{\w'}
    \land (\w, \w') \in \Guar 
    \land (\hh, \vi') \csat \opset : \vi' 
    \land \w' \in \evalW[\lenv, \stk']{\gpost}
\end{array}
\end{equation}
First by \cref{equ:local-transaction-sound}, we substitute the \( (\stub, \opset) \in \evalLS[\lenv, \stk']{\lpost}\) in \cref{equ:repartition} by the transaction semantics,
\begin{equation}
\label{equ:combined-transaction-sound}
\begin{array}{@{}l}
    \fora{\w,  \hh, \hh', \vi, \vi', \lenv, \stk, \stk', \txid, \opset} \exsts{\w'} \\
    \quad \w \in \evalW{\gpre}
    \land (\hh, \vi, \stub) \in \eraseW{\w}
    \land \txid \in \fresh{\hh}  \\
    \quad {} \land {} \vdash (\stk, \clpsHH{\hh, \cu}, \unitO), \trans \toL (\stk', \h', \opset), \pskip  \\
    \quad {} \land \hh' = \updM{\hh, \vi, \txid, \opset}  
    \land \vi' \geq \updV{\hh', \vi, \opset} \\
    \quad {} \land (\hh',\vi', \stub) \in \eraseW{\w'}
    \land (\w, \w') \in \Guar 
    \land (\hh, \vi') \csat \opset : \vi' 
    \land \w' \in \evalW[\lenv, \stk']{\gpost}
\end{array}
\end{equation}
Hence we prove \cref{equ:commit-transaction} by folding all the side conditions for a atomic transaction,
\[
\begin{array}{@{}l}
    \fora{\w,  \hh, \hh', \vi, \vi', \lenv, \stk, \stk', \txid, \opset} \exsts{\w'} \\
    \quad \w \in \evalW{\gpre}
    \land (\hh, \vi, \stub) \in \eraseW{\w} 
    \land {} (\stk, \hh, \vi), \ptrans{\trans} \toT{\como} (\stk', \hh', \vi'), \pskip  \\
    \quad {} \land (\hh',\vi', \stub) \in \eraseW{\w'}
    \land (\w, \w') \in \Guar 
    \land \w' \in \evalW[\lenv, \stk']{\gpost}
\end{array}
\]
\textbf{Stable post-condition.} 
It can be proven for the similar reason as the proof for stable pre-condition.

\caseI{\rl{TRFrame}}

%Now we need to prove the frame \( \gframe \) does not invalidate the triple.

Given \( \tripleG{\gpre}{\cmd}{\gpost} \) and \( \stable{\gframe, \como}\), we need to prove \( \tripleSemG{\gpre \sep \gframe }{\cmd}{\gpost \sep \gframe } \).
By the \ih that  \( \tripleG{\gpre}{\cmd}{\gpost} \implies \tripleSemG{\gpre}{\cmd}{\gpost} \), we know that for any trace defined by the \( \predn{step} \) predicate with an initial world \( \w \) satisfying the precondition \( \gpre \), the finial world \( \w' \) satisfies the postcondition \( \gpost \). 
Now we need to prove the frame does not invalidate the trace:
%It means that given \( \tripleSemG{\gpre}{\cmd}{\gpost} \) and \( \stable{\gframe} \), there exists a trace \( \trc_f\) corresponding to \( \tripleSemG{\gpre \sep \gframe }{\cmd}{\gpost \sep \gframe } \) when \( \stable{\gframe}\):
\[
\begin{array}[t]{@{}l}
    \fora{ \w,\w', \stk, \stk', \lenv, \nat, \et }  
    \land \pred{step}{\nat, \w, \w', \stk, \stk', \cmd, \como} 
    \land \w' \evalW[\lenv, \stk']{\gpost} 
    \land \stable{\gframe, \et} \\
    \quad \fora{\w_{f}} \exsts{\w''}
    \pred{step}{\nat, \w \composeW \w_f, \w'', \stk, \stk', \cmd, \como} 
    \land \w_f \in \evalW[\lenv, \stk]{\gframe} 
    \land \w'' \in \evalW[\lenv, \stk']{\gframe \sep \gpost}
\end{array}
\]
We prove it by induction on the number \( \nat \).
If \( \nat = 0 \),  we know \( \w = \w'\), \( \stk = \stk'\) and \( \cmd = \pskip \).
The new world is \( \w'' = \w \composeW \w_f\).
Assume it holds for \( \nat = i \) steps, let consider \( i + 1 \) steps.
Assume some initial worlds \( \w \), stacks \( \stk \) and logical environments \( \lenv \), and worlds from the frame \( \w_f \in \evalW[\lenv, \stk]{\gframe}\) such that \( \w \composeW \w_f\).
Given the definition of \( \predn{step}\) predicate, the next step may be a step of guarantee which change the command or a step of rely.

If it is a guarantee, this mean the command changes.
Let \( \cmd' \) and \( \cmd' \) be the new command and stack after the transformation \( (\w, \w') \).
Assuming \( (\w, \w') \in \Guar \) and \( (\w \composeW \w_f, \w'') \in \Guar \) for some world \( \w'' \), we want to prove \( \w''  = \w' \composeW \w_f'' \) and \( \w_f'' \in \evalW[\lenv, \stk']{\gframe} \).
Because of the side condition \( \func{fv}{\gframe} \cap \func{modify}{\cmd} = \emptyset \), we know the stack does not affect the interpretation of the frame \( \evalW{\gframe} = \evalW[\stk',\lenv]{\gframe}\).
Because of the \cref{lem:locality-update} and the stabilisation of the frame, we know there exists a rely step \( (\w_f, \w_{f}') \in \Rely \), \( \eraseW{\w_{f}'}\projection{1} = \eraseW{\w}\projection{1}\), \( (\w'\projection{1} \composeC \w'_{f}\projection{1})\isdef\) and \( \eraseW{\w_f}\projection{2} = \eraseW{\w_f}\projection{2}\).
It means there exists a world \( \w_{f}' \) via rely that collapses to the same key-value store as \( \w'\)  and the local capabilities of \( \w_{f}' \) are disjointed with the one of \( \w' \), but the view of \( \w_{f}' \)  remains the same as \( \w_f\).
By the \cref{lem:mono-view}, we know that the view of \( \w'\) is greater than the view of \( \w \).
Since the rely allows arbitrarily to shift the view to the right, there exists a world \( \w_f''\) by shifting the view from \( \w_f' \) such that \( \w_f, \w_f'') \in \Rely \) and \( (\w' \composeW \w_f'')\isdef \).
Last, we need to check the execution test, especially when \( \eraseW{\w} \neq \eraseW{\w'}\).
It means a transaction has been committed, so there exist some fingerprints \( \opset \) such that \( \eraseW{\w} \csat \opset : \eraseW{\w'}\projection{2}\), which then implies \( (\eraseW{\w}\projection{1},\eraseW{\w'}\projection{1}) \in \et \).
Therefore, for any world transformation via guarantee \( (\w, \w') \in \Guar \), there exists \( \w_f, \w_f'' \in \evalW[\lenv,\stk']{\gframe}\)  such that \( (\w composeW \w_f)\isdef\) and \( (\w' composeW \w_f'')\isdef\).
By the definition of guarantee we have \( (\w composeW \w_f, \w' composeW \w''_f) \in \Guar \).
Finally, by applying \ih when \( \nat = i \), we have the prove for \( \nat = i + 1 \).

If it is a rely step, this mean the command remains untouched.
Assuming \( (\w, \w') \in \Rely \) and \( (\w \composeW \w_f, \w'') \in \Rely \) for some world \( \w'' \), we want to prove \( \w''  = \w' \composeW \w_f'' \) and \( \w_f'' \in \evalW[\lenv, \stk]{\gframe} \).
By \( (\w \composeW \w_f, \w'') \in \Rely \), we know the world transformation is triggered by some capabilities, says \( \ca\), that compatible with the local capabilities from \( \w \composeW \w_f \), \ie \( (\ca \composeC (\w\projection{1} \composeC \w_f\projection{1}) )\isdef \).
It means the capabilities \( \ca \) are disjointed with the local capabilities \( \w\projection{1} \) and local capabilities \( \w_f\projection{1}\) respectively.
Because of the stable of \( \gframe \), there is a world \( \w_f'' \) such that \( \w_f'' \in \evalW{\gframe}\) and \( \eraseW{\w_f''} = \eraseW{\w'} = \eraseW{\w''}\).
Because the rely and stable does not alter the local capabilities, thus we prove \( \w'' = \w' \composeW \w_f'' \).
Finally, by applying \ih when \( \nat = i \), we have the prove for \( \nat = i + 1 \).


%Assume a world that satisfying the precondition \( \w \in \evalW{\gpre} \).
%Because the assertion \( \gpre \sep \gframe \) holds, by the interpretation function (\cref{def:assertion}), assume a world \( \w_{f}\) that satisfies the frame and is compatible with the precondition, \ie \( (\w \composeW \w_f)\isdef \).
%It means the machine states are the same \( \eraseW{\w} = \eraseW{\w_f}\) and the local capabilities are disjointed, \( \w\projection{1} \composeC \w_{f}\projection{1} \).
%This mean the for every step from the first trace \( \w_i \) there exists a world \( \w_i \compose \w_f\) where \( \w_f \in \evalW{}\)
%We prove that by induction on the length of the first trace.
%Assume after \( i \) steps, the first trace ends up with a world \( \w' \composeW \w_{f}'\), and the second trace ends up with \( \w' \).
%Let consider the next step for the first trace.
%If the next step executes the commands, it means the transformation of the world is allowed by guarantee.
\end{proof}


\begin{lemma}[Locality of update]
When a thread commits a transaction that is allowed by guarantee, the effect to the history heap is included in the rely of other threads.
\label{lem:locality-update}
\[
\begin{array}{@{}l}
    \fora{\w, \w', \w''} (\w\projection{1} \composeC \w'\projection{1})\isdef \land \clpsW{\w}\projection{1} = \clpsW{\w'}\projection{1} \land (\w, \w'') \in \Guar  \\
    \quad \implies \exsts{\w'''} (\w', \w''') \in \Rely \land (\w''\projection{1} \composeC \w'''\projection{1})\isdef \land \clpsW{\w''}\projection{1} = \clps{\w'''}\projection{1}
\end{array} 
\]
\end{lemma}
\begin{proof}
Assume two worlds \( \w \) and \( \w' \) such that the composition of the local capabilities is defined \((\w\projection{1} \composeC \w'\projection{1})\isdef\) and the global history heap states are the same, \ie \( \clpsW{\w}\projection{1} = \clpsW{\w'}\projection{1} \).
If the first world can transfer to a new world \( \w'' \) allowed by guarantee \( (\w, \w'' ) \in \Guar \), by the \cref{def:rely-guarantee}, we know that for any region \( \rid \) that has been updated, there exists a \( \kap \) such that \( \kap \sqsubseteq \ca(\rid) \) which gives the permission.
Formally, let \( (\gs, \ca) = \w \) and \( (\gs', \ca') = \w' \), 
\[
\begin{array}{@{}l}
    \fora{\rid} 
    \gs(\rid) = \gs'(\rid) \lor {} \\
    \quad \gs(\rid) \neq \gs'(\rid) 
    \land \exsts{\hh, \hh', \vi, \vi', \ca'', \ca''', \intf, \kap} \\
    \qquad \gs(\rid) = (\hh, \vi, \ca'', \intf) 
    \land \gs'(\rid) = (\hh', \vi', \ca''', \intf)
    \land \kap \sqsubseteq \ca(\rid) \\
    \qquad {} \land ((\hh, \vi, \ca''), (\hh', \vi', \ca''')) \in \intf(\kap)
\end{array} 
\]
We can construct a world \( \w''' = (\ca''', \gs''') \) that satisfies the rely \( (\w', \w''') \in \Rely \).
First, we take the same local capabilities as the \( \w' \).
This is,
\[
    \ca''' = \w'\projection{1}
\]
Then we propagate history heaps and shared capabilities from \( \w'' \) to \( \w''' \) but keep the views as the same in the \( \w' \),
\[
    \fora{\rid} \exsts{\hh,\vi,\ca,\intf} \gs'''(\rid) = (\hh, \vi, \ca, \intf) \land \w''\projection{2}(\rid) = (\hh, \stub, \ca, \intf) \land \w'\projection{2}(\rid) = (\stub, \vi, \stub, \intf)
\]
Combining the two formulae with the local capabilities are compatible \( ( \ca \composeC \ca' )\isdef \), It is easy to see \( ( \w', \w''' ) \in \relyU \) by \cref{def:rely-guarantee}, therefore \( ( \w', \w''' ) \in \Rely \).
Given the way we construct \( \w''' \), it directly proves \( \clps{\w''}\projection{1} = \clps{\w'''}\projection{1} \).
Because the guarantee require the orthogonal of capabilities remains the same so alter the update, the local capabilities are still compatible.
\end{proof}

\begin{lemma}[monotonicity of view]
\label{lem:mono-view}
Given a state for a client \( (\mkvs, \stk, \vi )\), the view monotonically increases with respect to the operational semantic for a client.
\[
    \begin{array}{@{}l}
        \fora{\mkvs, \mkvs', \stk, \stk', \vi, \vi', \cmd, \cmd'} (\mkvs, \stk, \vi), \cmd \toT (\mkvs', \stk', \vi'), \cmd \implies \vi' \geq \vi
    \end{array}
\]
\end{lemma}
\begin{proof}
    Induction on the derivations.
    \caseB{\rl{PCommit}}
    By the definition of \( \Vupdate \), we know the updated view is greater than the view before, \ie \( \fora{\mkvs, \vi, \vi', \opset} \vi' = \updV{\mkvs, \vi, \opset} \implies \vi' \geq \vi\).
    By the semantics, the finial view \( \vi' \) after executing a transaction is \( \vi' \geq \updV{\mkvs', \vi'', \opset} \) where \( \vi'' \geq \vi\).
    Thus, we prove \( \vi' \geq \vi \).
    \caseB{\rl{PAssign}, \rl{Passume}, \rl{PChoice}, \rl{Iter}, \rl{PSeq}}
    For these cases, we have \( \vi' = \vi\).
    \caseI{\rl{PSeq}}
    It can be directly derived from \ih
\end{proof}


The program soundness is for the parallel rule.
This is non-trivial as threads have the up-to-date history heap but not the views.
\begin{definition}
\[
\begin{rclarray}
    \func{world2conf}{\wenv} & \defeq & 
    \begin{cases}
        (\mkvs, \lambda \client \ldotp \eraseW{\wenv(\client)}\projection{2}) & \text{if } \fora{ \client }  \eraseW{\wenv(\client)}\projection{1} = \mkvs \\
        \text{undefined} & \text{otherwise}
    \end{cases}\\
    \pred{stepp}{0,\wenv, \wenv', \thdenv, \thdenv',\prog, \como} & \defeq & 
    \begin{array}[t]{@{}l}
    \wenv = \wenv' \land \thdenv = \thdenv' \land {} \\
    \dom(\wenv) = \dom(\thdenv) = \dom(\prog) \\
    \quad {} \land \fora{\client \in \dom(\prog)} \prog(\client) = \pskip
    \end{array} \\
    \pred{stepp}{ \nat + 1, \wenv, \wenv', \thdenv, \thdenv',\prog, \como} & \defeq & 
    \begin{array}[t]{@{}l}
    \exsts{\wenv'', \thdenv'', \prog''} \\
    \func{world2conf}{\wenv}, \thdenv, \prog \toG{\como} \func{world2conf}{\wenv''}, \thdenv'', \prog'' \\
    \quad {} \land \pred{steps}{ \nat, \wenv'', \wenv', \thdenv'', \thdenv',\prog'', \como} 
    \end{array} \\
\end{rclarray}
\]
\end{definition}

\begin{theorem}[Program soundness]
For any program \( \prog \), if a precondition \( \gpre \) satisfies a history heap \( \hh \) and a thread environment \( \thdenv \), and if there exist a final history heap and thread environment \( \hh', \thdenv' \)  such that \( (\hh, \thdenv, \prog) \toG{\como} (\hh', \thdenv', (\lambda \thid \ldotp \pskip) ) \) holds, then the post-condition \( \gpost \) derived from the logic rules should satisfies the final configuration.
This is,
\[
\begin{array}{@{}l}
\fora{\gpre, \gpost, \prog, \lenv, \como, \stk, \w, \wenv, \wenv', \thdenv, \thdenv', \nat}  \exsts{\stk'}
    \tripleG{\gpre}{\prog}{\gpost} \\
    \quad {} \land \w \in \evalW{\gpre}
    \land \dom(\wenv) = \dom(\prog) = \dom(\thdenv)
    \land \prod\limits_{\cl \in \dom(\wenv)} \wenv(\cl) = \w \\
    \quad {} \land \fora{\thid} \thdenv(\thid) = (\stk)
    \land \pred{steps}{\nat,\wenv, \wenv', \thdenv, \thdenv',\prog, \como}  \\
    \qquad {} \implies \prod\limits_{\cl \in \dom(\wenv')} \wenv'(\cl) \in \evalW[\lenv, \stk']{\gpost}
\end{array}
\] 
\end{theorem}
\begin{proof}
Induction on derivations.

\caseB{\( \dom(\prog) \equiv \Set{\txid} \)}
 
If there is only one thread, it derives from the \cref{thm:per-thread-soundness}.

\caseB{\( \dom(\prog) \equiv \Set{\txid, \txid'} \)}

We have \( \tripleG{\gpre_{1} \sep \gpre_{2}}{\cmd_{1} \ppar \cmd_{2}}{ \gpost_{1} \sep \gpost_{2} } \) and \( \tripleG{\gpre_{i}}{\cmd_{i}}{ \gpost_{i} } \) for \( i \in \Set{1,2} \).
Give the \ih and the soundness result per thread, we need to prove for any possible traces for the entire program \( \theta \), there exists traces \( \tau_{1} \) and \( \tau_{2} \) from the first thread and second thread with the same state for history heap in each step.
For brevity, we use numbers \( 1\)  and \(2\) both as subscript for two traces and the thread identifiers.
The following also proves the local capabilities from the two local traces always compatible.
\[
\begin{array}{@{}l}
    \fora{\theta} \exsts{\tau_{1}, \tau_{2}} \\
    \quad 
    \begin{B}
        \fora{\hh, \hh', \thdenv, \thdenv'} 
        ((\hh,\thdenv), (\hh', \thdenv')) \in \theta \\
        \quad {} \land \dom(\thdenv) = \dom(\thdenv') = \Set{1,2} 
        \land \exsts{\w_{1}, \w_{2}, \w_{1}', \w_{2}, i \in \Set{1,2}} \\
        \qquad (\w_{i}, \w_{i}') \in \tau_{i}
        \land \hh = \clps{\w_{i}}\projection{1} 
        \land \hh' = \clps{\w_{i}'}\projection{1} 
        \land (\w_{1}\projection{1} \composeC \w_{2}\projection{1})\isdef
        \land (\w_{1}'\projection{1} \composeC \w_{2}'\projection{1})\isdef  \\
        \qquad {} \land \thdenv(i)\projection{2} = \clpsW{\w_{i}}\projection{2}
        \land \thdenv'(i)\projection{2} = \clpsW{\w_{i}'}\projection{2}
    \end{B}
\end{array}
\]
We prove by constructing the traces \( tau_{1}\) and \( \tau_{2} \) inductively.
Initially, because \( \gpre_{1} \sep \gpre_{2} \) is defined, we pick any states \( \w_{1}^{0} \)  and \( \w_{2}^{0} \) such that \( \w_{1}^{0} \in \evalW{\gpre_{1}}\), \( \w_{2}^{0} \in \evalW{\gpre_{2}}\) and \( (\w_{1}^{0} \composeW \w_{2}^{0})\isdef\).
This means the initial history heaps and views match, \ie 
\[ 
    \fora{i \in \Set{1,2}} 
    \hh^{0} = \clps{\w_{1}^{0} \composeW \w_{2}^{0}}\projection{1} = \clps{\w_{i}^{0}}\projection{1}
    \land \thdenv^{0}(i)\projection{2} = \clps{\w_{i}^{0}}\projection{2}
\]
and the local capabilities are compatible,
\[ 
    (\w_{1}^{0}\projection{1} \composeC \w_{2}^{0}\projection{1})\isdef 
\]
Assume there exists two traces \( \tau_{1}, \tau_{2}\) after \( i \) steps, let consider the next step for the entire program.
Now two traces \( \tau_{1}\) and \( \tau_{2} \) where the current finial states are \( \w_{1}^{i} \) and \( \w_{2}^{j} \) such that \( \clps{\w_{1}^{i}}\projection{1} = \clps{\w_{2}^{j}}\projection{1} \) and \( (\w_{1}^{i}\projection{1} \composeC \w_{2}^{j}\projection{1})\isdef \).
There are two possibilities for the first thread: (a) it commits a transaction; or (b) it take a rely step which updates the history heap and shared capabilities.
If the first thread commits a transaction, which means the last step of the new trace \( \tau_{1}' = \tau_{1} \cup \Set{(\w_{1}^{i}, \w_{1}^{i+1})} \) it is allowed by the guarantee \( (\w_{1}^{i}, \w_{1}^{i+1}) \in \Guar \).
By the \cref{lem:locality-update}, there exists \( \w_{2}^{j+1} \) satisfying the conditions, therefore we can construct the new trace for the second thread as \( \tau_{2}' = \tau_{2} \cup \Set{(\w_{2}^{j},\w_{2}^{j+1})} \).
If the first thread take a rely step, \ie \( \tau_{1}' = \tau_{1} \cup \Set{(\w_{1}^{i}, \w_{1}^{i+1})} \) such that \( (\w_{1}^{i}, \w_{1}^{i+1}) \in \Rely \), there are two possibilities, this transfer is triggered by a capability is either included in the second thread or not.

\end{proof}


\begin{lemma}
\[
\begin{array}{@{}l}
    \for{\nat, \w, \w', \stk, \stk', \cmd, \et, \cl}
    \pred{step}{\nat, \w, \w', \stk, \stk', \cmd, \et} \implies {}  \\
    \pred{stepp}{\nat, \Set{\cl \mapsto \w},\Set{\cl \mapsto \w'}, \Set{\cl \mapsto \stk}, \Set{ \cl \mapsto \stk'}, \Set{\cl \mapsto \cmd}, \et}
\end{array}
\]
\end{lemma}
