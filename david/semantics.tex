\section{Operational Semantics}

\subsubsection{Storage Values}

The set of storage values is denoted by \textsf{Val} and is defined as the set of integers $\mathds{Z}$. It is ranged over by $v, v_1, v_2, \ldots$

\subsubsection{Storage Keys}

The set of keys used to index the storage is defined as \textsf{Key} and it is equivalent to the set of positive integers $\mathds{Z}^+$.

\subsubsection{Transaction Stack}

Every transaction is free to assign and use local variables as part of its body. They are defined as a partial function $\mathsf{Stack} \triangleq \mathsf{Var} \rightharpoonup \mathsf{Val}$ and ranged over by $s, s_1, s_2, \ldots$

\subsubsection{Storage}

A storage is defined to be a partial function from storage keys to values and it is denoted by $\mathsf{Storage} \triangleq \mathsf{Key} \rightharpoonup \mathsf{Val}$. We use $h, h_1, h_2$ to range over it.

\subsubsection{Transaction Identifiers}

Every transaction that is executed as part of a program is associated with a numerical and unique identifier. The set of identifiers \textsf{Tid} is defined to be the set of positive integers $\mathds{Z}^+$. We denote a transaction with identifier $k$ as $\mathds{T}_k$.

\subsubsection{Lock Manager}

A lock manager is defined as a total function from a set of storage keys to transaction identifiers and lock modes. Formally we say that $\mathsf{LMan} \triangleq \mathsf{Key} \rightarrow \{ \mathsf{Tid} \} \times \mathsf{Lock}$ and we can range over the possible functions using $\Phi, \Phi_1, \Phi_2, \ldots$

\subsubsection{Transactions State}

The state of all transactions running as part of a program is a total function $\mathsf{TState} : \mathsf{Tid} \rightarrow \mathsf{Stack}$ which is ranged over by $S$.

\subsection{Numerical Expressions}

We define the semantics of expressions with respect to a transaction stack, $\llbracket - \rrbracket_- : \mathsf{Expr} \times \mathsf{Stack} \rightarrow \mathsf{Val}$, as follows.
\begin{align*}
\llbracket v \rrbracket_s &\triangleq v \\
\llbracket \pvar{x} \rrbracket_s &\triangleq
\bigg\{ \begin{array}{l l}
s(\pvar{x}) &\text{if } \pvar{x} \in \textsf{dom}(s)\\
0&\text{otherwise}
\end{array} \\
\llbracket \mathds{E}_1 + \mathds{E}_2 \rrbracket_s &\triangleq \llbracket \mathds{E}_1 \rrbracket_s + \llbracket \mathds{E}_2 \rrbracket_s \\
\llbracket \mathds{E}_1 - \mathds{E}_2 \rrbracket_s &\triangleq \llbracket \mathds{E}_1 \rrbracket_s - \llbracket \mathds{E}_2 \rrbracket_s \\
\llbracket \mathds{E}_1 \times \mathds{E}_2 \rrbracket_s &\triangleq \llbracket \mathds{E}_1 \rrbracket_s \times \llbracket \mathds{E}_2 \rrbracket_s \\
\llbracket \mathds{E}_1 \div \mathds{E}_2 \rrbracket_s &\triangleq 
\Bigg\{ \begin{array}{l l}
1 &\text{ if } \llbracket \mathds{E}_2 \rrbracket_s = 0 \\
\llbracket \mathds{E}_1 \rrbracket_s \div \llbracket \mathds{E}_2 \rrbracket_s &\text{ otherwise} \\
\end{array}
\end{align*}

\subsection{Boolean Expressions}

We define the semantics of boolean expressions with respect to a transaction stack, $\llbracket - \rrbracket_-^B : \mathsf{BExpr} \times \mathsf{Stack} \rightarrow \{ \bot, \top \}$, as follows.
\begin{align*}
\llbracket \true \rrbracket_s^B &\triangleq \top \\
\llbracket \false \rrbracket_s^B &\triangleq \bot \\
\llbracket \mathds{B}_1 \land \mathds{B}_2 \rrbracket_s^B &\triangleq \llbracket \mathds{B}_1 \rrbracket_s^B \land \llbracket \mathds{B}_2 \rrbracket_s^B \\
\llbracket \mathds{B}_1 \lor \mathds{B}_2 \rrbracket_s^B &\triangleq \llbracket \mathds{B}_1 \rrbracket_s^B \lor \llbracket \mathds{B}_2 \rrbracket_s^B \\
\llbracket \mathds{E}_1 > \mathds{E}_2 \rrbracket_s^B &\triangleq \llbracket \mathds{E}_1 \rrbracket_s > \llbracket \mathds{E}_2 \rrbracket_s \\
\llbracket \mathds{E}_1 < \mathds{E}_2 \rrbracket_s^B &\triangleq \llbracket \mathds{E}_1 \rrbracket_s < \llbracket \mathds{E}_2 \rrbracket_s \\
\llbracket \mathds{E}_1 \geq \mathds{E}_2 \rrbracket_s^B &\triangleq \llbracket \mathds{E}_1 \rrbracket_s \geq \llbracket \mathds{E}_2 \rrbracket_s \\
\llbracket \mathds{E}_1 \leq \mathds{E}_2 \rrbracket_s^B &\triangleq \llbracket \mathds{E}_1 \rrbracket_s \leq \llbracket \mathds{E}_2 \rrbracket_s \\
\end{align*}

\subsection{Locked Commands}

The operational semantics of commands are defined as a transition relation through the following rules, where $\iota \in \mathsf{Tid}$ is the identifier of the transaction as part of which the command is executed.
\begin{gather*}
(-, -, -, -) \rightsquigarrow (-, -, -, -) \\
: \mathsf{Storage} \times \mathsf{LMan} \times \mathsf{Stack} \times \mathsf{LCmd} \times \mathsf{Storage} \times \mathsf{LMan} \times \mathsf{Stack} \times \mathsf{LCmd}
\end{gather*}

\[
\infer[\textsc{Assign}]
{
	\iota \vdash (h, \Phi, s, \passign{\pvar{x}}{\mathds{E}})
	\rightsquigarrow
	(h, \Phi, s[\pvar{x} \mapsto v], \pskip)
}
{
	v = \llbracket \mathds{E} \rrbracket_s
}
\]

\[
\infer[\textsc{Read}]
{
	\iota \vdash (h, \Phi, s, \pderef{\pvar{x}}{\mathds{E}})
	\rightsquigarrow
	(h, \Phi, s[\pvar{x} \mapsto v], \pskip)
}
{
	k = \llbracket \mathds{E} \rrbracket_s\ \
	k \in \pred{dom}{h}\ \
	v = h(k)\ \
	(I, \textsc{s}) = \Phi(k)\ \
	\iota \in I
}
\]

\[
\infer[\textsc{ReadX}]
{
	\iota \vdash (h, \Phi, s, \pderef{\pvar{x}}{\mathds{E}})
	\rightsquigarrow
	(h, \Phi, s[\pvar{x} \mapsto v], \pskip)
}
{
	k = \llbracket \mathds{E} \rrbracket_s\ \
	k \in \pred{dom}{h}\ \
	v = h(k)\ \
	(\{\iota\}, \textsc{x}) = \Phi(k)
}
\]

\[
\infer[\textsc{Write}]
{
	\iota \vdash (h, \Phi, s, \pmutate{\mathds{E}_1}{\mathds{E}_2})
	\rightsquigarrow
	(h[k \mapsto v], \Phi, s, \pskip)
}
{
	k = \llbracket \mathds{E}_1 \rrbracket_s\ \
	k \in \pred{dom}{h}\ \
	v = \llbracket \mathds{E}_2 \rrbracket_s\ \
	(\{ \iota \}, \textsc{x}) = \Phi(k)
}
\]

\[
\infer[\textsc{CondT}]
{
	\iota \vdash (h, \Phi, s, \pif{\mathds{B}}{\mathds{K}_1}{\mathds{K}_2})
	\rightsquigarrow
	(h, \Phi, s, \mathds{K}_1)
}
{
	\llbracket \mathds{B} \rrbracket_s^B = \top
}
\]

\[
\infer[\textsc{CondF}]
{
	\iota \vdash (h, \Phi, s, \pif{\mathds{B}}{\mathds{K}_1}{\mathds{K}_2})
	\rightsquigarrow
	(h, \Phi, s, \mathds{K}_2)
}
{
	\llbracket \mathds{B} \rrbracket_s^B = \bot
}
\]

\[
\infer[\textsc{LoopT}]
{
	\iota \vdash (h, \Phi, s, \ploop{\mathds{B}}{\mathds{K}})
	\rightsquigarrow
	(h, \Phi, s, \mathds{K}; \ploop{\mathds{B}}{\mathds{K}})
}
{
	\llbracket \mathds{B} \rrbracket_s^B = \top
}
\]

\[
\infer[\textsc{LoopF}]
{
	\iota \vdash (h, \Phi, s, \ploop{\mathds{B}}{\mathds{K}})
	\rightsquigarrow
	(h, \Phi, s, \pskip)
}
{
	\llbracket \mathds{B} \rrbracket_s^B = \bot
}
\]

\[
\infer[\textsc{SeqSkip}]
{
	\iota \vdash (h, \Phi, s, \pskip ; \mathds{K})
	\rightsquigarrow
	(h, \Phi, s, \mathds{K})
}
{}
\]

\[
\infer[\textsc{Seq}]
{
	\iota \vdash (h, \Phi, s, \mathds{K}_1 ; \mathds{K}_2)
	\rightsquigarrow
	(h', \Phi', s', \mathds{K}_1' ; \mathds{K}_2)
}
{
	\iota \vdash (h, \Phi, s, \mathds{K}_1)
	\rightsquigarrow
	(h', \Phi', s', \mathds{K}_1')
}
\]

\[
\infer[\textsc{LockU}]
{
	\iota \vdash (h, \Phi, s, \pfuncallnr{lock}{\mathds{E}, \kappa})
	\rightsquigarrow
	(h, \Phi[k \mapsto (\{\iota\}, \kappa)], s, \pskip)
}
{
	k = \llbracket \mathds{E} \rrbracket_s\ \
	k \in \pred{dom}{h}\ \
	(\emptyset, \textsc{u}) = \Phi(k)
}
\]

\[
\infer[\textsc{LockS}]
{
	\iota \vdash (h, \Phi, s, \pfuncallnr{lock}{\mathds{E}, \textsc{s}})
	\rightsquigarrow
	(h, \Phi[k \mapsto (\{\iota\} \cup I, \kappa)], s, \pskip)
}
{
	k = \llbracket \mathds{E} \rrbracket_s\ \
	k \in \pred{dom}{h}\ \
	(I, \kappa) = \Phi(k)\ \
	(\kappa = \textsc{s} \lor I \equiv \{\iota\})
}
\]

\[
\infer[\textsc{LockX}]
{
	\iota \vdash (h, \Phi, s, \pfuncallnr{lock}{\mathds{E}, \textsc{x}})
	\rightsquigarrow
	(h, \Phi[k \mapsto (\{\iota\}, \textsc{x})], s, \pskip)
}
{
	k = \llbracket \mathds{E} \rrbracket_s\ \
	k \in \pred{dom}{h}\ \
	(\{\iota\}, \kappa) = \Phi(k)
}
\]

\[
\infer[\textsc{Unlock}]
{
	\iota \vdash (h, \Phi, s, \pfuncallnr{unlock}{\mathds{E}})
	\rightsquigarrow
	(h, \Phi[k \mapsto (\emptyset, \textsc{u})], s, \pskip)
}
{
	k = \llbracket \mathds{E} \rrbracket_s\ \
	k \in \pred{dom}{h}\ \
	(\{\iota\}, \kappa) = \Phi(k)
}
\]

\[
\infer[\textsc{UnlockS}]
{
	\iota \vdash (h, \Phi, s, \pfuncallnr{unlock}{\mathds{E}})
	\rightsquigarrow
	(h, \Phi[k \mapsto (I, \textsc{s})], s, \pskip)
}
{
	k = \llbracket \mathds{E} \rrbracket_s\ \
	k \in \pred{dom}{h}\ \
	(\{\iota\} \cup I, \textsc{s}) = \Phi(k)\ \
	I \not\equiv \emptyset
}
\]

\subsection{Programs \& Transactions}
The operational semantics of programs are defined as a transition relation through the following rules, where $\iota \in \mathsf{Tid}$ is the identifier of the transaction which is being executed.
\begin{gather*}
(-, -, -, -) \twoheadrightarrow (-, -, -, -) \\: \mathsf{Storage} \times \mathsf{LMan} \times \mathsf{Stack} \times \mathsf{Prog} \times \mathsf{Storage} \times \mathsf{LMan} \times \mathsf{Stack} \times \mathsf{Prog}
\end{gather*}

\[
\infer[\textsc{Step}]
{
	\iota \vdash (h, \Phi, s, \mathtt{begin}\ \mathds{K}\ \mathtt{end})
	\twoheadrightarrow
	(h', \Phi', s', \mathtt{begin}\ \mathds{K}'\ \mathtt{end})
}
{
	\iota \vdash (h, \Phi, s, \mathds{K})
	\rightsquigarrow
	(h', \Phi', s', \mathds{K}')
}
\]

\[
\infer[\textsc{SeqSkipT}]
{
	\iota \vdash (h, \Phi, s, \mathtt{begin}\ \pskip\ \mathtt{end}; \mathds{P})
	\twoheadrightarrow
	(h', \Phi', s', \mathds{P})
}
{}
\]

\[
\infer[\textsc{SeqT}]
{
	\iota \vdash (h, \Phi, s, \mathds{L}; \mathds{P})
	\twoheadrightarrow
	(h', \Phi', s', \mathds{L}'; \mathds{P})
}
{
	\iota \vdash (h, \Phi, s, \mathds{L})
	\rightsquigarrow
	(h', \Phi', s', \mathds{L}')
}
\]

\subsection{Executions}

The operational semantics of executions are defined as a transition relation through the following rules.
\[ (-, -, -, -) \rightarrowtail (-, -, -, -) : \mathsf{Storage} \times \mathsf{LMan} \times \mathsf{TState} \times \mathsf{Exec} \times \mathsf{Storage} \times \mathsf{LMan} \times \mathsf{TState} \times \mathsf{Exec} \]

\[
\infer[\textsc{Exec}]
{
	\vdash (h, \Phi, S, \mathds{P}_\iota)
	\rightarrowtail
	(h', \Phi', S[\iota \mapsto s'], \mathds{P}_\iota')
}
{
	s = S(\iota)\ \
	\iota \vdash (h, \Phi, s, \mathds{P}_\iota)
	\twoheadrightarrow
	(h', \Phi', s', \mathds{P}_\iota')
}
\]

\[
\infer[\textsc{ParL}]
{
	\vdash (h, \Phi, S, \mathds{X}_1\ ||\ \mathds{X}_2)
	\rightarrowtail
	(h', \Phi', S', \mathds{X}_1'\ ||\ \mathds{X}_2)
}
{
	\vdash (h, \Phi, S, \mathds{X}_1)
	\rightarrowtail
	(h', \Phi', S', \mathds{X}_1')
}
\]

\[
\infer[\textsc{ParR}]
{
	\vdash (h, \Phi, S, \mathds{X}_1\ ||\ \mathds{X}_2)
	\rightarrowtail
	(h', \Phi', S', \mathds{X}_1\ ||\ \mathds{X}_2')
}
{
	\vdash (h, \Phi, S, \mathds{X}_2)
	\rightarrowtail
	(h', \Phi', S', \mathds{X}_2')
}
\]

\[
\infer[\textsc{ParEndL}]
{
	\vdash (h, \Phi, S, \mathds{X}\ ||\ \mathtt{begin}\ \pskip\ \mathtt{end})
	\rightarrowtail
	(h, \Phi, S, \mathds{X})
}
{}
\]

\[
\infer[\textsc{ParEndR}]
{
	\vdash (h, \Phi, S, \mathtt{begin}\ \pskip\ \mathtt{end}\ ||\ \mathds{X})
	\rightarrowtail
	(h, \Phi, S, \mathds{X})
}
{}
\]