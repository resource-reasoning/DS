\section{Operational Semantics}

\subsubsection{Storage Values}

The set of storage values is denoted by \textsf{Val} and is defined as the set of integers $\mathds{Z}$. It is ranged over by $v, v_1, v_2, \ldots$

\subsubsection{Storage Keys}

The set of keys used to index the storage is defined as \textsf{Key} and it is equivalent to the set of positive integers $\mathds{Z}^+$.

\subsubsection{Transaction Stack}

Every transaction is free to assign and use local variables as part of its body. They are defined as a partial function $\mathsf{Stack} \triangleq \mathsf{Var} \rightharpoonup \mathsf{Val}$ and ranged over by $s, s_1, s_2, \ldots$

\subsubsection{Storage}

A storage is defined to be a partial function from storage keys to values and it is denoted by $\mathsf{Storage} \triangleq \mathsf{Key} \rightharpoonup \mathsf{Val}$. We use $h, h_1, h_2$ to range over it.

\subsubsection{Transaction Identifiers}

Every transaction that is executed as part of a program is associated with a numerical and unique identifier. The set of identifiers \textsf{Tid} is defined to be the set of positive integers $\mathds{Z}^+$. We denote a transaction with identifier $\iota$ as $\mathds{T}_\iota$.

\subsubsection{Lock Manager}

A lock manager is defined as a total function from a set of storage keys to transaction identifiers and lock modes. Formally we say that $\mathsf{LMan} \triangleq \mathsf{Key} \rightarrow \{ \mathsf{Tid} \} \times \mathsf{Lock}$ and we can range over the possible functions using $\Phi, \Phi_1, \Phi_2, \ldots$

\subsubsection{Transactions State}

The state of all transactions running as part of a program is a total function $\mathsf{TState} : \mathsf{Tid} \rightarrow \mathsf{Stack}$ which is ranged over by $S$.

\subsection{Numerical Expressions}

We define the semantics of expressions with respect to a transaction stack, $\llbracket - \rrbracket_- : \mathsf{Expr} \times \mathsf{Stack} \rightarrow \mathsf{Val}$, as follows.
\begin{align*}
\llbracket v \rrbracket_s &\triangleq v \\
\llbracket \pvar{x} \rrbracket_s &\triangleq
\bigg\{ \begin{array}{l l}
s(\pvar{x}) &\text{if } \pvar{x} \in \textsf{dom}(s)\\
0&\text{otherwise}
\end{array} \\
\llbracket \mathds{E}_1 + \mathds{E}_2 \rrbracket_s &\triangleq \llbracket \mathds{E}_1 \rrbracket_s + \llbracket \mathds{E}_2 \rrbracket_s \\
\llbracket \mathds{E}_1 - \mathds{E}_2 \rrbracket_s &\triangleq \llbracket \mathds{E}_1 \rrbracket_s - \llbracket \mathds{E}_2 \rrbracket_s \\
\llbracket \mathds{E}_1 \times \mathds{E}_2 \rrbracket_s &\triangleq \llbracket \mathds{E}_1 \rrbracket_s \times \llbracket \mathds{E}_2 \rrbracket_s \\
\llbracket \mathds{E}_1 \div \mathds{E}_2 \rrbracket_s &\triangleq 
\Bigg\{ \begin{array}{l l}
1 &\text{ if } \llbracket \mathds{E}_2 \rrbracket_s = 0 \\
\llbracket \mathds{E}_1 \rrbracket_s \div \llbracket \mathds{E}_2 \rrbracket_s &\text{ otherwise} \\
\end{array}
\end{align*}

\subsection{Boolean Expressions}

We define the semantics of boolean expressions with respect to a transaction stack, $\llbracket - \rrbracket_-^B : \mathsf{BExpr} \times \mathsf{Stack} \rightarrow \{ \bot, \top \}$, as follows.
\begin{align*}
\llbracket \true \rrbracket_s^B &\triangleq \top \\
\llbracket \false \rrbracket_s^B &\triangleq \bot \\
\llbracket \mathds{B}_1 \land \mathds{B}_2 \rrbracket_s^B &\triangleq \llbracket \mathds{B}_1 \rrbracket_s^B \land \llbracket \mathds{B}_2 \rrbracket_s^B \\
\llbracket \mathds{B}_1 \lor \mathds{B}_2 \rrbracket_s^B &\triangleq \llbracket \mathds{B}_1 \rrbracket_s^B \lor \llbracket \mathds{B}_2 \rrbracket_s^B \\
\llbracket \mathds{E}_1 > \mathds{E}_2 \rrbracket_s^B &\triangleq \llbracket \mathds{E}_1 \rrbracket_s > \llbracket \mathds{E}_2 \rrbracket_s \\
\llbracket \mathds{E}_1 < \mathds{E}_2 \rrbracket_s^B &\triangleq \llbracket \mathds{E}_1 \rrbracket_s < \llbracket \mathds{E}_2 \rrbracket_s \\
\llbracket \mathds{E}_1 \geq \mathds{E}_2 \rrbracket_s^B &\triangleq \llbracket \mathds{E}_1 \rrbracket_s \geq \llbracket \mathds{E}_2 \rrbracket_s \\
\llbracket \mathds{E}_1 \leq \mathds{E}_2 \rrbracket_s^B &\triangleq \llbracket \mathds{E}_1 \rrbracket_s \leq \llbracket \mathds{E}_2 \rrbracket_s \\
\end{align*}

\subsection{Locked Commands}

The operational semantics of commands are defined as a transition relation through the following rules, where $\iota \in \mathsf{Tid}$ is the identifier of the transaction as part of which the command is executed.
\begin{gather*}
(-, -, -, -) \rightsquigarrow (-, -, -, -) \\
: \mathsf{Storage} \times \mathsf{LMan} \times \mathsf{Stack} \times \mathsf{LCmd} \times \mathsf{Storage} \times \mathsf{LMan} \times \mathsf{Stack} \times \mathsf{LCmd}
\end{gather*}

The \textsc{Assign} rule works in a standard way, by updating the value associated to a variable in the transaction's stack with the assigned expression evaluated under $s$. It then resolves into a $\pskip$ command without touching the global storage or the lock manager.
\[
\infer[\textsc{Assign}]
{
	\iota \vdash (h, \Phi, s, \passign{\pvar{x}}{\mathds{E}})
	\rightsquigarrow
	(h, \Phi, s[\pvar{x} \mapsto v], \pskip)
}
{
	v = \llbracket \mathds{E} \rrbracket_s
}
\]

The two conditional rules cope with the two cases where the boolean condition $\mathds{B}$ is evaluated to $\top$ or $\bot$ under the current stack $s$. In the first case, the execution will proceed to the $\mathds{K}_1$ body while in the second one to $\mathds{K}_2$.

\[
\infer[\textsc{CondT}]
{
	\iota \vdash (h, \Phi, s, \pif{\mathds{B}}{\mathds{K}_1}{\mathds{K}_2})
	\rightsquigarrow
	(h, \Phi, s, \mathds{K}_1)
}
{
	\llbracket \mathds{B} \rrbracket_s^B = \top
}
\]

\[
\infer[\textsc{CondF}]
{
	\iota \vdash (h, \Phi, s, \pif{\mathds{B}}{\mathds{K}_1}{\mathds{K}_2})
	\rightsquigarrow
	(h, \Phi, s, \mathds{K}_2)
}
{
	\llbracket \mathds{B} \rrbracket_s^B = \bot
}
\]

Loops are supported in a similar way to the if statement, with the \textsc{LoopT} and \textsc{LoopF} rules that either unroll the loop for an iteration at a time, or get out of the loop in the case where $\mathds{B}$ is semantically evaluated to $\bot$.

\[
\infer[\textsc{LoopT}]
{
	\iota \vdash (h, \Phi, s, \ploop{\mathds{B}}{\mathds{K}})
	\rightsquigarrow
	(h, \Phi, s, \mathds{K}; \ploop{\mathds{B}}{\mathds{K}})
}
{
	\llbracket \mathds{B} \rrbracket_s^B = \top
}
\]

\[
\infer[\textsc{LoopF}]
{
	\iota \vdash (h, \Phi, s, \ploop{\mathds{B}}{\mathds{K}})
	\rightsquigarrow
	(h, \Phi, s, \pskip)
}
{
	\llbracket \mathds{B} \rrbracket_s^B = \bot
}
\]

The \textsc{Seq} rules cope with sequential composition of commands inside a transaction. The first command in a composition is ran one step at a time until it is eventually resolved to $\pskip$ and at that point, the execution proceeds to the next command $\mathds{K}$.

\[
\infer[\textsc{SeqSkip}]
{
	\iota \vdash (h, \Phi, s, \pskip ; \mathds{K})
	\rightsquigarrow
	(h, \Phi, s, \mathds{K})
}
{}
\]

\[
\infer[\textsc{Seq}]
{
	\iota \vdash (h, \Phi, s, \mathds{K}_1 ; \mathds{K}_2)
	\rightsquigarrow
	(h', \Phi', s', \mathds{K}_1' ; \mathds{K}_2)
}
{
	\iota \vdash (h, \Phi, s, \mathds{K}_1)
	\rightsquigarrow
	(h', \Phi', s', \mathds{K}_1')
}
\]

In order to read a value from a storage cell we require the current transaction to hold the corresponding lock in a mode $\kappa$ such that $\kappa \geq \textsc{s}$. We indicate this by making sure that the transaction identifier $\iota$ is in the set of owners $I$ as recorded by the lock manager $\Phi$. In fact, there are two scenarios to consider: either $\kappa = \textsc{s}$ and all it's needed is for $\iota$ to already be in the set $I$, or $\kappa = \textsc{x}$ and we require that $I \equiv \{ \iota \}$, since in the exclusive case $I$ is a singleton set, which also implies that $\iota \in I$.

\[
\infer[\textsc{Read}]
{
	\iota \vdash (h, \Phi, s, \pderef{\pvar{x}}{\mathds{E}})
	\rightsquigarrow
	(h, \Phi, s[\pvar{x} \mapsto v], \pskip)
}
{
	k = \llbracket \mathds{E} \rrbracket_s\ \
	k \in \pred{dom}{h}\ \
	v = h(k)\ \
	(I, \kappa) = \Phi(k)\ \
	\iota \in I
}
\]

In order to write a value to a storage cell, it is mandatory for the transaction to be the sole owner of an exclusive lock to the cell, as described by the \textsc{Write} rule's premiss.

\[
\infer[\textsc{Write}]
{
	\iota \vdash (h, \Phi, s, \pmutate{\mathds{E}_1}{\mathds{E}_2})
	\rightsquigarrow
	(h[k \mapsto v], \Phi, s, \pskip)
}
{
	k = \llbracket \mathds{E}_1 \rrbracket_s\ \
	k \in \pred{dom}{h}\ \
	v = \llbracket \mathds{E}_2 \rrbracket_s\ \
	(\{ \iota \}, \textsc{x}) = \Phi(k)
}
\]

Whenever the lock manager's entry associated to a cell is in the unlocked mode, a transaction can acquire that lock in shared or exclusive mode and set its identifier as the owner in a singleton set through the \textsc{LockU} rule.

\[
\infer[\textsc{LockU}]
{
	\iota \vdash (h, \Phi, s, \pfuncallnr{lock}{\mathds{E}, \kappa})
	\rightsquigarrow
	(h, \Phi[k \mapsto (\{\iota\}, \kappa)], s, \pskip)
}
{
	\kappa \in \{ \textsc{s}, \textsc{x} \}\ \	
	k = \llbracket \mathds{E} \rrbracket_s\ \
	k \in \pred{dom}{h}\ \
	(\emptyset, \textsc{u}) = \Phi(k)
}
\]

The \textsc{LockS} rule deals with the situation where a transaction needs to lock a cell $k$ in shared mode and the lock manager already contains a locked entry for $k$. At this point, the transaction can proceed either if the current lock mode $\kappa$ is \textsc{s} or if it is \textsc{x} and the owners set only includes the transaction itself. The latter requirements are expressed through the $(\kappa = \textsc{s} \lor I \equiv \{\iota\})$ disjunction.

\[
\infer[\textsc{LockS}]
{
	\iota \vdash (h, \Phi, s, \pfuncallnr{lock}{\mathds{E}, \textsc{s}})
	\rightsquigarrow
	(h, \Phi[k \mapsto (\{\iota\} \cup I, \kappa)], s, \pskip)
}
{
	k = \llbracket \mathds{E} \rrbracket_s\ \
	k \in \pred{dom}{h}\ \
	(I, \kappa) = \Phi(k)\ \
	(\kappa = \textsc{s} \lor I \equiv \{\iota\})
}
\]

A transaction can \textit{upgrade} a shared lock it is currently holding on a cell $k$, into an exclusive one, if there are no other transactions in the owners set $I$ associated to $k$. This is allowed by the \textsc{LockX} rule which also extends the locking behaviour to a reentrant one by permitting a single transaction to lock the same cell multiple times as long as it is its sole owner.

\[
\infer[\textsc{LockX}]
{
	\iota \vdash (h, \Phi, s, \pfuncallnr{lock}{\mathds{E}, \textsc{x}})
	\rightsquigarrow
	(h, \Phi[k \mapsto (\{\iota\}, \textsc{x})], s, \pskip)
}
{
	k = \llbracket \mathds{E} \rrbracket_s\ \
	k \in \pred{dom}{h}\ \
	(\{\iota\}, \kappa) = \Phi(k)
}
\]

The two unlock rules have the effect of releasing any cells previously acquired by a transaction with identifier $\iota$. In the first case, \textsc{Unlock} will set the mode to \textsc{u} and clear the owners set when its only member is $\iota$ while \textsc{UnlockS} deals with releasing a shared lock that still has transactions holding the same lock. In this situation, we simply remove $\iota$ from the owners set.

\[
\infer[\textsc{Unlock}]
{
	\iota \vdash (h, \Phi, s, \pfuncallnr{unlock}{\mathds{E}})
	\rightsquigarrow
	(h, \Phi[k \mapsto (\emptyset, \textsc{u})], s, \pskip)
}
{
	k = \llbracket \mathds{E} \rrbracket_s\ \
	k \in \pred{dom}{h}\ \
	(\{\iota\}, \kappa) = \Phi(k)
}
\]

\[
\infer[\textsc{UnlockS}]
{
	\iota \vdash (h, \Phi, s, \pfuncallnr{unlock}{\mathds{E}})
	\rightsquigarrow
	(h, \Phi[k \mapsto (I, \textsc{s})], s, \pskip)
}
{
	k = \llbracket \mathds{E} \rrbracket_s\ \
	k \in \pred{dom}{h}\ \
	(\{\iota\} \cup I, \textsc{s}) = \Phi(k)\ \
	I \not\equiv \emptyset
}
\]

\subsection{Programs \& Transactions}
The operational semantics of programs are defined as a transition relation through the following rules, where $\iota \in \mathsf{Tid}$ is the identifier of the transaction which is being executed.
\begin{gather*}
(-, -, -, -) \twoheadrightarrow (-, -, -, -) \\: \mathsf{Storage} \times \mathsf{LMan} \times \mathsf{Stack} \times \mathsf{Prog} \times \mathsf{Storage} \times \mathsf{LMan} \times \mathsf{Stack} \times \mathsf{Prog}
\end{gather*}

\[
\infer[\textsc{Step}]
{
	\iota \vdash (h, \Phi, s, \mathtt{begin}\ \mathds{K}\ \mathtt{end})
	\twoheadrightarrow
	(h', \Phi', s', \mathtt{begin}\ \mathds{K}'\ \mathtt{end})
}
{
	\iota \vdash (h, \Phi, s, \mathds{K})
	\rightsquigarrow
	(h', \Phi', s', \mathds{K}')
}
\]

\[
\infer[\textsc{SeqSkipT}]
{
	\iota \vdash (h, \Phi, s, \mathtt{begin}\ \pskip\ \mathtt{end}; \mathds{P})
	\twoheadrightarrow
	(h', \Phi', s', \mathds{P})
}
{}
\]

\[
\infer[\textsc{SeqT}]
{
	\iota \vdash (h, \Phi, s, \mathds{L}; \mathds{P})
	\twoheadrightarrow
	(h', \Phi', s', \mathds{L}'; \mathds{P})
}
{
	\iota \vdash (h, \Phi, s, \mathds{L})
	\rightsquigarrow
	(h', \Phi', s', \mathds{L}')
}
\]

\subsection{Executions}

The operational semantics of executions are defined as a transition relation through the following rules.
\begin{gather*}
(-, -, -, -) \rightarrowtail (-, -, -, -) \\
: \mathsf{Storage} \times \mathsf{LMan} \times \mathsf{TState} \times \mathsf{Exec} \times \mathsf{Storage} \times \mathsf{LMan} \times \mathsf{TState} \times \mathsf{Exec}
\end{gather*}

\[
\infer[\textsc{Exec}]
{
	\vdash (h, \Phi, S, \mathds{P}_\iota)
	\rightarrowtail
	(h', \Phi', S[\iota \mapsto s'], \mathds{P}_\iota')
}
{
	s = S(\iota)\ \
	\iota \vdash (h, \Phi, s, \mathds{P}_\iota)
	\twoheadrightarrow
	(h', \Phi', s', \mathds{P}_\iota')
}
\]

\[
\infer[\textsc{ParL}]
{
	\vdash (h, \Phi, S, \mathds{X}_1\ ||\ \mathds{X}_2)
	\rightarrowtail
	(h', \Phi', S', \mathds{X}_1'\ ||\ \mathds{X}_2)
}
{
	\vdash (h, \Phi, S, \mathds{X}_1)
	\rightarrowtail
	(h', \Phi', S', \mathds{X}_1')
}
\]

\[
\infer[\textsc{ParR}]
{
	\vdash (h, \Phi, S, \mathds{X}_1\ ||\ \mathds{X}_2)
	\rightarrowtail
	(h', \Phi', S', \mathds{X}_1\ ||\ \mathds{X}_2')
}
{
	\vdash (h, \Phi, S, \mathds{X}_2)
	\rightarrowtail
	(h', \Phi', S', \mathds{X}_2')
}
\]

\[
\infer[\textsc{ParEndL}]
{
	\vdash (h, \Phi, S, \mathds{X}\ ||\ \mathtt{begin}\ \pskip\ \mathtt{end})
	\rightarrowtail
	(h, \Phi, S, \mathds{X})
}
{}
\]

\[
\infer[\textsc{ParEndR}]
{
	\vdash (h, \Phi, S, \mathtt{begin}\ \pskip\ \mathtt{end}\ ||\ \mathds{X})
	\rightarrowtail
	(h, \Phi, S, \mathds{X})
}
{}
\]