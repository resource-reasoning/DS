\section{Operational Semantics}

\subsubsection{Storage Values}

The set of storage values is denoted by \textsf{Val} and is defined as the set of integers $\mathds{Z}$. It is ranged over by $v, v_1, v_2, \ldots$

\subsubsection{Storage Keys}

The set of keys used to index the storage is defined as \textsf{Key} and it is equivalent to the set of natural numbers $\mathds{N}$.

\subsubsection{Transaction Stack}

Every transaction is free to assign and use local variables as part of its body. They are defined as a partial function $\mathsf{Stack} \triangleq \mathsf{Var} \rightharpoonup \mathsf{Val}$ and ranged over by $s, s_1, s_2, \ldots$

\subsubsection{Locking Phase}

Under the \textsc{2pl} protocol a running transaction $\mathds{T}$ is initially in the \textit{growing} phase ($\curlywedge$), where it is free to lock any cell it needs. Once it releases a lock, the transaction enters the \textit{shrinking} phase ($\curlyvee$). Here $\mathds{T}$ is denied any new lock acquisitions while it is allowed to gradually release the locks that are still being held. Phases come from the set $\mathsf{Phase} \triangleq \{ \curlywedge, \curlyvee \}$ and are ranged over by $p$.

\subsubsection{Storage}

A storage is defined to be a partial function from storage keys to values and it is denoted by $\mathsf{Storage} \triangleq \mathsf{Key} \rightharpoonup \mathsf{Val}$. We use $h, h_1, h_2$ to range over it.

\subsubsection{Transaction Identifiers}

Every transaction that is executed as part of a program is associated with a numerical and unique identifier. The set of identifiers \textsf{Tid} is defined to be the set of positive integers $\mathds{Z}^+$. We denote a transaction with identifier $\iota$ as $\mathds{T}_\iota$.

\subsubsection{Lock Manager}

A lock manager is defined as a total function from a set of storage keys to transaction identifiers and lock modes. Formally we say that $\mathsf{LMan} \triangleq \mathsf{Key} \rightarrow \{ \mathsf{Tid} \} \times \mathsf{Lock}$ and we can range over the possible functions using $\Phi, \Phi_1, \Phi_2, \ldots$

\subsubsection{Transactions State}

The state of all transactions running as part of a program is a total function $\mathsf{TState} : \mathsf{Tid} \rightarrow (\mathsf{Stack}, \mathsf{Phase})$ which is ranged over by $S$. Informally, it associates each transaction which is currently being executed to its own stack and locking phase.

\subsection{Numerical Expressions}

We define the semantics of expressions with respect to a transaction stack, $\llbracket - \rrbracket_- : \mathsf{Expr} \times \mathsf{Stack} \rightarrow \mathsf{Val}$, as follows.
\begin{align*}
\llbracket v \rrbracket_s &\triangleq v \\
\llbracket \pvar{x} \rrbracket_s &\triangleq
\bigg\{ \begin{array}{l l}
s(\pvar{x}) &\text{if } \pvar{x} \in \textsf{dom}(s)\\
0&\text{otherwise}
\end{array} \\
\llbracket \mathds{E}_1 + \mathds{E}_2 \rrbracket_s &\triangleq \llbracket \mathds{E}_1 \rrbracket_s + \llbracket \mathds{E}_2 \rrbracket_s \\
\llbracket \mathds{E}_1 - \mathds{E}_2 \rrbracket_s &\triangleq \llbracket \mathds{E}_1 \rrbracket_s - \llbracket \mathds{E}_2 \rrbracket_s \\
\llbracket \mathds{E}_1 \times \mathds{E}_2 \rrbracket_s &\triangleq \llbracket \mathds{E}_1 \rrbracket_s \times \llbracket \mathds{E}_2 \rrbracket_s \\
\llbracket \mathds{E}_1 \div \mathds{E}_2 \rrbracket_s &\triangleq 
\Bigg\{ \begin{array}{l l}
1 &\text{ if } \llbracket \mathds{E}_2 \rrbracket_s = 0 \\
\llbracket \mathds{E}_1 \rrbracket_s \div \llbracket \mathds{E}_2 \rrbracket_s &\text{ otherwise} \\
\end{array}
\end{align*}

\subsection{Boolean Expressions}

We define the semantics of boolean expressions with respect to a transaction stack, $\llbracket - \rrbracket_-^B : \mathsf{BExpr} \times \mathsf{Stack} \rightarrow \mathsf{Bool}$, as follows.
\begin{align*}
\llbracket \true \rrbracket_s^B &\triangleq \top \\
\llbracket \false \rrbracket_s^B &\triangleq \bot \\
\llbracket \mathds{B}_1 \land \mathds{B}_2 \rrbracket_s^B &\triangleq \llbracket \mathds{B}_1 \rrbracket_s^B \land \llbracket \mathds{B}_2 \rrbracket_s^B \\
\llbracket \mathds{B}_1 \lor \mathds{B}_2 \rrbracket_s^B &\triangleq \llbracket \mathds{B}_1 \rrbracket_s^B \lor \llbracket \mathds{B}_2 \rrbracket_s^B \\
\llbracket \lnot \mathds{B} \rrbracket_s^B &\triangleq \lnot \llbracket \mathds{B} \rrbracket_s^B \\
\llbracket \mathds{E}_1 = \mathds{E}_2 \rrbracket_s^B &\triangleq \llbracket \mathds{E}_1 \rrbracket_s = \llbracket \mathds{E}_2 \rrbracket_s \\
\llbracket \mathds{E}_1 > \mathds{E}_2 \rrbracket_s^B &\triangleq \llbracket \mathds{E}_1 \rrbracket_s > \llbracket \mathds{E}_2 \rrbracket_s \\
\llbracket \mathds{E}_1 < \mathds{E}_2 \rrbracket_s^B &\triangleq \llbracket \mathds{E}_1 \rrbracket_s < \llbracket \mathds{E}_2 \rrbracket_s \\
\llbracket \mathds{E}_1 \geq \mathds{E}_2 \rrbracket_s^B &\triangleq \llbracket \mathds{E}_1 \rrbracket_s \geq \llbracket \mathds{E}_2 \rrbracket_s \\
\llbracket \mathds{E}_1 \leq \mathds{E}_2 \rrbracket_s^B &\triangleq \llbracket \mathds{E}_1 \rrbracket_s \leq \llbracket \mathds{E}_2 \rrbracket_s \\
\end{align*}

\subsection{Commands}

The operational semantics of commands are defined as a transition relation through the following rules, where $\iota \in \mathsf{Tid}$ is the identifier of the transaction as part of which the command is executed.
\begin{gather*}
(-, -, -, -, -) \rightsquigarrow (-, -, -, -, -) 
: (\mathsf{Storage} \times \mathsf{LMan} \times \mathsf{Stack} \times \mathsf{Phase} \times \mathsf{Cmd})^2
\end{gather*}

The \textsc{Assign} rule works in a standard way, by updating the value associated to a variable in the transaction's stack with the assigned expression evaluated under $s$. It then resolves into a $\pskip$ command without touching the global storage or the lock manager.
\[
\infer[\textsc{Assign}]
{
	\iota \vdash (h, \Phi, s, p, \passign{\pvar{x}}{\mathds{E}})
	\rightsquigarrow
	(h, \Phi, s[\pvar{x} \mapsto v], p, \pskip)
}
{
	v = \llbracket \mathds{E} \rrbracket_s
}
\]

The two conditional rules cope with the two cases where the boolean condition $\mathds{B}$ is evaluated to $\top$ or $\bot$ under the current stack $s$. In the first case, the execution will proceed to the $\mathds{K}_1$ body while in the second one to $\mathds{K}_2$.

\[
\infer[\textsc{CondT}]
{
	\iota \vdash (h, \Phi, s, p, \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2})
	\rightsquigarrow
	(h, \Phi, s, p, \mathds{C}_1)
}
{
	\llbracket \mathds{B} \rrbracket_s^B = \top
}
\]

\[
\infer[\textsc{CondF}]
{
	\iota \vdash (h, \Phi, s, p, \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2})
	\rightsquigarrow
	(h, \Phi, s, p, \mathds{C}_2)
}
{
	\llbracket \mathds{B} \rrbracket_s^B = \bot
}
\]

Loops are supported in a similar way to the if statement, with the \textsc{LoopT} and \textsc{LoopF} rules that either unroll the loop for an iteration at a time, or get out of the loop in the case where $\mathds{B}$ is semantically evaluated to $\bot$.

\[
\infer[\textsc{LoopT}]
{
	\iota \vdash (h, \Phi, s, p, \ploop{\mathds{B}}{\mathds{C}})
	\rightsquigarrow
	(h, \Phi, s, p, \mathds{C}; \ploop{\mathds{B}}{\mathds{C}})
}
{
	\llbracket \mathds{B} \rrbracket_s^B = \top
}
\]

\[
\infer[\textsc{LoopF}]
{
	\iota \vdash (h, \Phi, s, p, \ploop{\mathds{B}}{\mathds{C}})
	\rightsquigarrow
	(h, \Phi, s, p, \pskip)
}
{
	\llbracket \mathds{B} \rrbracket_s^B = \bot
}
\]

The \textsc{Seq} rules cope with sequential composition of commands inside a transaction. The first command in a composition is ran one step at a time until it is eventually resolved to $\pskip$ and at that point, the execution proceeds to the next command $\mathds{K}$.

\[
\infer[\textsc{SeqSkip}]
{
	\iota \vdash (h, \Phi, s, p, \pskip ; \mathds{C})
	\rightsquigarrow
	(h, \Phi, s, p, \mathds{C})
}
{}
\]

\[
\infer[\textsc{Seq}]
{
	\iota \vdash (h, \Phi, s, p, \mathds{C}_1 ; \mathds{C}_2)
	\rightsquigarrow
	(h', \Phi', s', p', \mathds{C}_1' ; \mathds{C}_2)
}
{
	\iota \vdash (h, \Phi, s, p, \mathds{C}_1)
	\rightsquigarrow
	(h', \Phi', s', p', \mathds{C}_1')
}
\]

A transaction can allocate fresh storage cells through the use of the $\mathtt{alloc}$ command by specifying the amount of necessary space $n$ needed. The \textsc{Alloc} rule's premiss requires $n$ to be a natural number and to pick a sequence of $n$ contiguous cells which have not yet been allocated and are therefore not currently part of the storage's domain.
\[
\infer[\textsc{Alloc}]
{
	\iota \vdash (h, \Phi, s, p, \palloc{\pvar{x}}{\mathds{E}})
	\rightsquigarrow
	(h[l \mapsto 0] \ldots [l + n - 1 \mapsto 0], \Phi', s[\pvar{x} \mapsto l], p, \pskip)
}
{
	n = \llbracket \mathds{E} \rrbracket_s\ \
	l, \ldots, l + n - 1 \not\in \pred{dom}{h}\ \
	\Phi' = \Phi[l \mapsto (\emptyset, \textsc{u})]\ldots[l + n - 1 \mapsto (\emptyset, \textsc{u})]
}
\]

In order to read a value from a storage cell we require the current transaction to hold the corresponding lock in a mode $\kappa$ such that $\kappa \geq \textsc{s}$. We indicate this by making sure that the transaction identifier $\iota$ is in the set of owners $I$ as recorded by the lock manager $\Phi$. In fact, there are two scenarios to consider: either $\kappa = \textsc{s}$ and all it's needed is for $\iota$ to already be in the set $I$, or $\kappa = \textsc{x}$ and we require that $I \equiv \{ \iota \}$, since in the exclusive case $I$ is a singleton set, which also implies that $\iota \in I$.

\[
\infer[\textsc{Read}]
{
	\iota \vdash (h, \Phi, s, p, \pderef{\pvar{x}}{\mathds{E}})
	\rightsquigarrow
	(h, \Phi, s[\pvar{x} \mapsto v], p, \pskip)
}
{
	k = \llbracket \mathds{E} \rrbracket_s\ \
	k \in \pred{dom}{h}\ \
	v = h(k)\ \
	(I, \kappa) = \Phi(k)\ \
	\iota \in I\ \
	\kappa \geq \textsc{s}
}
\]

In order to write a value to a storage cell, it is mandatory for the transaction to be holding an exclusive lock to the cell or to be the sole owner of a shared one, as described by the \textsc{Write} rule's premiss. The latter case allows a transaction to \textit{upgrade} the shared lock it is currently holding on a cell $k$.

\[
\infer[\textsc{Write}]
{
	\iota \vdash (h, \Phi, s, p, \pmutate{\mathds{E}_1}{\mathds{E}_2})
	\rightsquigarrow
	(h[k \mapsto v], \Phi[k \mapsto (\{\iota\}, \textsc{x})], s, p, \pskip)
}
{
	k = \llbracket \mathds{E}_1 \rrbracket_s\ \
	k \in \pred{dom}{h}\ \
	v = \llbracket \mathds{E}_2 \rrbracket_s\ \
	(\{ \iota \}, \kappa) = \Phi(k)\ \
	\kappa \geq \textsc{s}
}
\]

Whenever the lock manager's entry associated to a cell is in the unlocked mode, a transaction can acquire that lock in shared or exclusive mode and set its identifier as the owner in a singleton set through the \textsc{Lock} rule. Note that this rule applies nondeterministically with any rule for a given command $\mathds{C}$. This means that at any point in time a transaction will either try and reduce command $\mathds{C}$ or acquire a lock for some cell $k$ in the domain of the storage $h$.

\[
\infer[\textsc{Lock}]
{
	\iota \vdash (h, \Phi, s, \curlywedge, \mathds{C})
	\rightsquigarrow
	(h, \Phi[k \mapsto (\{\iota\}, \kappa)], s, \curlywedge, \mathds{C})
}
{
	k \in \pred{dom}{h}\ \
	\kappa \geq \textsc{s}\ \
	(\emptyset, \textsc{u}) = \Phi(k)
}
\]

The \textsc{LockS} rule deals with the situation where a transaction needs to lock a cell $k$ in shared mode and the lock manager already contains a locked entry for $k$. At this point, the transaction can proceed only if the current lock mode $\kappa$ is \textsc{s}.

\[
\infer[\textsc{LockS}]
{
	\iota \vdash (h, \Phi, s, \curlywedge, \mathds{C})
	\rightsquigarrow
	(h, \Phi[k \mapsto (\{\iota\} \cup I, \textsc{s})], s, \curlywedge, \mathds{C})
}
{
	k \in \pred{dom}{h}\ \
	(I, \textsc{s}) = \Phi(k)
}
\]

The two unlock rules have the effect of releasing any cells previously acquired by a transaction with identifier $\iota$. In the first case, \textsc{Unlock} will set the mode to \textsc{u} and clear the owners set when its only member is $\iota$ while \textsc{UnlockS} deals with releasing a shared lock that still has transactions holding the same lock. In this situation, we simply remove $\iota$ from the owners set.

\[
\infer[\textsc{Unlock}]
{
	\iota \vdash (h, \Phi, s, p, \mathds{C})
	\rightsquigarrow
	(h, \Phi[k \mapsto (\emptyset, \textsc{u})], s, \curlyvee, \mathds{C})
}
{
	k = \llbracket \mathds{E} \rrbracket_s\ \
	k \in \pred{dom}{h}\ \
	(\{\iota\}, \kappa) = \Phi(k)
}
\]

\[
\infer[\textsc{UnlockS}]
{
	\iota \vdash (h, \Phi, s, p, \mathds{C})
	\rightsquigarrow
	(h, \Phi[k \mapsto (I, \textsc{s})], s, \curlyvee, \mathds{C})
}
{
	k = \llbracket \mathds{E} \rrbracket_s\ \
	k \in \pred{dom}{h}\ \
	(\{\iota\} \cup I, \textsc{s}) = \Phi(k)\ \
	I \not\equiv \emptyset
}
\]

\subsection{Transactions}
The operational semantics of transactions are defined as a transition relation through the following rule, where $\iota \in \mathsf{Tid}$ is the identifier of the transaction which is being executed.
\begin{gather*}
(-, -, -, -, -) \twoheadrightarrow (-, -, -, -, -) : (\mathsf{Storage} \times \mathsf{LMan} \times \mathsf{Stack} \times \mathsf{Phase} \times \mathsf{Trans})^2
\end{gather*}

\[
\infer[\textsc{Step}]
{
	\iota \vdash (h, \Phi, s, p, \mathtt{begin}\ \mathds{C}\ \mathtt{end})
	\twoheadrightarrow
	(h', \Phi', s', p', \mathtt{begin}\ \mathds{C}'\ \mathtt{end})
}
{
	\iota \vdash (h, \Phi, s, \mathds{C})
	\rightsquigarrow
	(h', \Phi', s', \mathds{C}')
}
\]

\subsection{Programs}

\sx{Here the grammar of \(\mathsf{Prog}\) does not have the form like \( (\mathtt{begin}\ - \mathtt{end})_\iota \), you can say, we extend the grammar when we give the semantics. }

The operational semantics of programs are defined as a transition relation through the following rules.
\begin{gather*}
(-, -, -, -) \rightarrowtail (-, -, -, -) 
: (\mathsf{Storage} \times \mathsf{LMan} \times \mathsf{TState} \times \mathsf{Prog})^2
\end{gather*}

\[
\infer[\textsc{Exec}]
{
	\vdash (h, \Phi, S, \mathds{T}_\iota)
	\rightarrowtail
	(h', \Phi', S[\iota \mapsto (s', p')], \mathds{T}_\iota')
}
{
	(s, p) = S(\iota)\ \
	\iota \vdash (h, \Phi, s, p, \mathds{T}_\iota)
	\twoheadrightarrow
	(h', \Phi', s', p', \mathds{T}_\iota')
}
\]

\[
\infer[\textsc{SeqSkipT}]
{
	\vdash (h, \Phi, S, (\mathtt{begin}\ \pskip\ \mathtt{end})_\iota; \mathds{P})
	\rightarrowtail
	(h, \Phi, S \setminus \{\iota\}, \mathds{P})
}
{
	\{ k\ |\ (I, \kappa) = \Phi(k) \land \iota \in I \} \equiv \emptyset
}
\]

\[
\infer[\textsc{SeqT}]
{
	\vdash (h, \Phi, s, p, \mathds{P}_1; \mathds{P}_2)
	\rightarrowtail
	(h', \Phi', s', p', \mathds{P}_1'; \mathds{P}_2)
}
{
	\vdash (h, \Phi, s, \mathds{P}_1)
	\rightarrowtail
	(h', \Phi', s', \mathds{P}_1')
}
\]

\[
\infer[\textsc{ParL}]
{
	\vdash (h, \Phi, S, \mathds{P}_1 \| \mathds{P}_2)
	\rightarrowtail
	(h', \Phi', S', \mathds{P}_1' \| \mathds{P}_2)
}
{
	\vdash (h, \Phi, S, \mathds{P}_1)
	\rightarrowtail
	(h', \Phi', S', \mathds{P}_1')
}
\]

\[
\infer[\textsc{ParR}]
{
	\vdash (h, \Phi, S, \mathds{P}_1 \| \mathds{P}_2)
	\rightarrowtail
	(h', \Phi', S', \mathds{P}_1 \| \mathds{P}_2')
}
{
	\vdash (h, \Phi, S, \mathds{P}_2)
	\rightarrowtail
	(h', \Phi', S', \mathds{P}_2')
}
\]

\[
\infer[\textsc{ParEndL}]
{
	\vdash (h, \Phi, S, \mathtt{begin}\ \pskip\ \mathtt{end}_\iota \| \mathds{P})
	\rightarrowtail
	(h, \Phi, S, \mathds{P})
}
{
	\{ k\ |\ (I, \kappa) = \Phi(k) \land \iota \in I \} \equiv \emptyset
}
\]

\[
\infer[\textsc{ParEndR}]
{
	\vdash (h, \Phi, S, \mathds{P} \| \mathtt{begin}\ \pskip\ \mathtt{end}_\iota)
	\rightarrowtail
	(h, \Phi, S, \mathds{P})
}
{
	\{ k\ |\ (I, \kappa) = \Phi(k) \land \iota \in I \} \equiv \emptyset
}
\]
