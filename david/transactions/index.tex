\section{A Logic for Transactions}

\begin{defn}
	(Machine states pcm).
	The partial commutative monoid with multiple units for machine states is instantiated to:
	\[
		(\mathsf{Storage} \times \mathsf{Stack}, \uplus_2, \{ (\emptyset, \emptyset) \})
	\]
	where the union of tuples of partial functions with disjoint domains, $\uplus_2$, is defined as:
	\[
		(h, s) \uplus_2 (h', s') \triangleq (h \uplus h', s \uplus s')
	\]
\end{defn}

\begin{defn}
	(Numerical expression semantics).
	The semantics of numerical expressions are expressed through a function, $\tsem{-}_{-,-}^\textsc{e} : \mathsf{Expr} \times \mathsf{LEnv} \times \mathsf{Stack} \rightarrow \mathsf{Val}$, defined as:
	\begin{align*}
		\llbracket v \rrbracket^\textsc{e}_{e, s} &\triangleq v \\
		\llbracket \pvar{x} \rrbracket^\textsc{e}_{e, s} &\triangleq
		\begin{cases}
		s(\pvar{x}), &\text{if } \pvar{x} \in \textsf{dom}(s)\\
		0,&\text{otherwise}
		\end{cases} \\
		\llbracket x \rrbracket^\textsc{e}_{e, s} &\triangleq \begin{cases}
			e(x), & \text{if } x \in \pred{dom}{e} \\
			0, & \text{otherwise}
		\end{cases} \\
		\llbracket \mathds{E}_1 + \mathds{E}_2 \rrbracket^\textsc{e}_{e, s} &\triangleq \llbracket \mathds{E}_1 \rrbracket^\textsc{e}_{e, s} + \llbracket \mathds{E}_2 \rrbracket^\textsc{e}_{e, s} \\
		\llbracket \mathds{E}_1 - \mathds{E}_2 \rrbracket^\textsc{e}_{e, s} &\triangleq \llbracket \mathds{E}_1 \rrbracket^\textsc{e}_{e, s} - \llbracket \mathds{E}_2 \rrbracket^\textsc{e}_{e, s} \\
		\llbracket \mathds{E}_1 \times \mathds{E}_2 \rrbracket^\textsc{e}_{e, s} &\triangleq \llbracket \mathds{E}_1 \rrbracket^\textsc{e}_{e, s} \times \llbracket \mathds{E}_2 \rrbracket^\textsc{e}_{e, s} \\
		\llbracket \mathds{E}_1 \div \mathds{E}_2 \rrbracket^\textsc{e}_{e, s} &\triangleq 
		\begin{cases}
		1, &\text{ if } \llbracket \mathds{E}_2 \rrbracket^\textsc{e}_{e, s} = 0 \\
		\llbracket \mathds{E}_1 \rrbracket^\textsc{e}_{e, s} \div \llbracket \mathds{E}_2 \rrbracket^\textsc{e}_{e, s}, &\text{ otherwise} \\
		\end{cases}
	\end{align*}
\end{defn}
Whenever we encounter a use of the semantics expression that only provides a $\mathsf{Stack}$ component, i.e. $\tsem{\mathds{E}}_s^\textsc{e}$, we implicitly refer to $\tsem{\mathds{E}}_{\emptyset, s}^\textsc{e}$.

\begin{defn}
	(Boolean expression semantics).
	The semantics of boolean expressions are expressed through a function, $\tsem{-}_-^\textsc{b} : \mathsf{BExpr} \rightarrow (\mathsf{Storage} \times \mathsf{Stack}) \rightarrow \mathsf{Bool}$, defined as:
	\begin{align*}
		\llbracket \true \rrbracket_{(h, s)}^\textsc{b} &\triangleq \top \\
		\llbracket \false \rrbracket_{(h, s)}^\textsc{b} &\triangleq \bot \\
		\llbracket \mathds{B}_1 \land \mathds{B}_2 \rrbracket_{(h, s)}^\textsc{b} &\triangleq \llbracket \mathds{B}_1 \rrbracket_{(h, s)}^\textsc{b} \land \llbracket \mathds{B}_2 \rrbracket_{(h, s)}^\textsc{b} \\
		\llbracket \mathds{B}_1 \lor \mathds{B}_2 \rrbracket_{(h, s)}^\textsc{b} &\triangleq \llbracket \mathds{B}_1 \rrbracket_{(h, s)}^\textsc{b} \lor \llbracket \mathds{B}_2 \rrbracket_{(h, s)}^\textsc{b} \\
		\llbracket \lnot \mathds{B} \rrbracket_{(h, s)}^\textsc{b} &\triangleq \lnot \llbracket \mathds{B} \rrbracket_{(h, s)}^\textsc{b} \\
		\llbracket \mathds{E}_1 = \mathds{E}_2 \rrbracket_{(h, s)}^\textsc{b} &\triangleq \llbracket \mathds{E}_1 \rrbracket_{s}^\textsc{e} = \llbracket \mathds{E}_2 \rrbracket_{s}^\textsc{e} \\
		\llbracket \mathds{E}_1 > \mathds{E}_2 \rrbracket_{(h, s)}^\textsc{b} &\triangleq \llbracket \mathds{E}_1 \rrbracket_{s}^\textsc{e} > \llbracket \mathds{E}_2 \rrbracket_{s}^\textsc{e} \\
		\llbracket \mathds{E}_1 < \mathds{E}_2 \rrbracket_{(h, s)}^\textsc{b} &\triangleq \llbracket \mathds{E}_1 \rrbracket_{s}^\textsc{e} < \llbracket \mathds{E}_2 \rrbracket_{s}^\textsc{e}
	\end{align*}
\end{defn}
Note that we only provide one function to cover the semantics of boolean expressions appearing inside machine states (Parameter \ref{param:boolMachine}) and concrete states (Parameter \ref{param:boolConcrete}) because we instantiate the two to the same set.

\begin{defn}
	(Machine state assertions).
	Machine state assertions are instantiated to be the standard separation logic ones, describing a variable in the stack and a cell in the heap.
		\[
			\mathcal{M} \in \mathsf{MAssn} ::= x = \mathds{E}\ |\ \pvar{x} = \mathds{E}\ |\ \mathds{E}_1 \mapsto \mathds{E}_2
		\]
		The associated semantics function, which maps such assertions to elements of the machine state pcm, $\tsem{-}_-^\textsc{m} : \mathsf{MAssn} \rightarrow \mathsf{LEnv} \rightarrow \mathcal{P}(\mathbb{M})$, is defined as:
		\begin{align*}
			\tsem{x = \mathds{E}}^\textsc{m}_e &\triangleq \big\{ (h, s)\ |\ h \in \mathsf{Storage} \land s \in \mathsf{Stack} \land  e(x) = \tsem{\mathds{E}}^\textsc{e}_{e, s} \big\}
			\\
			\tsem{\pvar{x} = \mathds{E}}^\textsc{m}_e &\triangleq \big\{ (h, s)\ |\ h \in \mathsf{Storage} \land s(\pvar{x}) = \tsem{\mathds{E}}^\textsc{e}_{e, s} \big\}
			\\
			\tsem{\mathds{E}_1 \mapsto \mathds{E}_2}_e^\textsc{m} &\triangleq \big\{ (h, s)\ |\ \pred{dom}{h} = \{\tsem{\mathds{E}_1}_e^\textsc{e}\} \land h(\tsem{\mathds{E}_1}_e^\textsc{e}) = \tsem{\mathds{E}_2}_{e,s}^\textsc{e} \big\}
		\end{align*}
		It is assumed that the function for logical expressions semantics, $\tsem{-}_-^\textsc{e} : \mathsf{Expr} \rightarrow \mathsf{LEnv} \rightarrow \mathsf{Val}$, is appropriately defined and provided.
\end{defn}

\begin{defn}
	\label{defn:ecmd}
	(Elementary commands).
	The set of \emph{elementary commands}, \textsf{ECmd}, is instantiated through the following grammar where $\pvar{x} \in \mathsf{Var}$.
	\[
		\hat{\mathds{C}} ::=
			\passign{\pvar{x}}{\mathds{E}}\
			|\ \pderef{\pvar{x}}{\mathds{E}}\
			|\ \palloc{\pvar{x}}{\mathds{E}}\
			|\ \pmutate{\mathds{E}_1}{\mathds{E}_2}
	\]
	The commands allow variable assignment, memory dereference, mutation and allocation.
\end{defn}

\begin{defn}
	(Elementary command axioms).
	The set of \emph{elementary command axioms} $\textsc{Ax}_{\hat{\mathsf{C}}} : \mathcal{P}(\mathsf{Storage} \times \mathsf{Stack}) \times \mathsf{Cmd} \times \mathcal{P}(\mathsf{Storage} \times \mathsf{Stack})$ are defined to be the standard separation logic ones, describing the heap (our storage) and the variable store, i.e. the stack.

	\iffalse	
	For every rule's triple $\Delta \vdash \triple{P}{\hat{\mathds{C}}}{Q}$, logical environment $e \in \mathsf{LEnv}$ and predicate environment $\delta \in \mathsf{PEnv}$, we define the corresponding axiom as $\lfloor \tsem{P}_{e, \delta} \rfloor_W \times \hat{\mathds{C}} \times \lfloor \tsem{Q}_{e, \delta} \rfloor_W$.
	\begin{gather*}
		\infer[\textsc{Write}]
		{
			\vdash
			\triple
				{\mathds{E}_1 \mapsto -}
				{\pmutate{\mathds{E}_1}{\mathds{E}_2}}
				{\mathds{E}_1 \mapsto \mathds{E}_2}
		}
		{}
		\\
		\infer[\textsc{Read}]
		{
			\vdash
			\triple
				{\pvar{x} \doteq \mathds{E}_1 \sep \cell{\mathds{E}}{\mathds{E}_2}}
				{\pderef{\pvar{x}}{\mathds{E}}}
				{\pvar{x} \doteq \mathds{E}_2[\mathds{E}_1/\pvar{x}] \sep \cell{\mathds{E}[\mathds{E}_1/\pvar{x}]}{\mathds{E}_2[\mathds{E}_1/\pvar{x}]}}
		}
		{}
		\\
		\infer[\textsc{Assign}]
		{
			\vdash
			\triple
				{P}
				{\passign{\pvar{x}}{\mathds{E}}}
				{\exists x \ldotp \pvar{x} \doteq \mathds{E}[x/\pvar{x}] \sep P[x/\pvar{x}]}	
		}
		{}
		\\
		\infer[\textsc{Alloc}]
		{
			\vdash
			\triple
				{\mathtt{emp}}
				{\palloc{\pvar{x}}{\mathds{E}}}
				{\exists y \ldotp \pvar{x} \doteq y \sep \circledast_{0 \leq i < \mathds{E}} \left(\cell{y + i}{0}\right)}
		}
		{}
	\end{gather*}
	The listed axioms come directly from the ones in standard separation logic.
	\fi
\end{defn}

\begin{defn}
	(Concrete states).
	The set of \emph{concrete states} $\mathcal{S}$ is instantiated to $(\mathsf{Storage} \times \mathsf{Stack}) \uplus \{\lightning\}$, where $\lightning$ represents a faulting state..
\end{defn}

\begin{defn}
	(Elementary commands interpretation).
	\label{ecmdint} The \emph{interpretation function} for elementary commands, formally $\tsem{-}_{\hat{\mathsf{C}}} : \mathsf{ECmd} \rightarrow \mathcal{S} \rightarrow \mathcal{P}(\mathcal{S})$, describes how elements of $\mathsf{ECmd}$ affect the concrete state and a transaction-local state. The function is defined in the following way.
	\begin{align*}
		\tsem{\passign{\pvar{x}}{\mathds{E}}}_{\hat{\mathsf{C}}}(h, s) &\triangleq \{ (h, s[\pvar{x} \mapsto \tsem{\mathds{E}}_s^\textsc{e}]) \}
		\\
		\tsem{\palloc{\pvar{x}}{\mathds{E}}}_{\hat{\mathsf{C}}}(h, s) &\triangleq
			\begin{cases}
				\{ (h[\vec{a} \mapsto 0], s[\pvar{x} \mapsto l])
				&
				\text{if } n = \tsem{\mathds{E}}_s^\textsc{e} \text{ and } n > 0 \text{ and } l \in \mathsf{Key}\\ & \text{and } \vec{a} = (l, \ldots, l + n - 1) \text{ and } \\
				& \{ l, \ldots, l + n - 1 \} \cap \pred{dom}{h} \equiv \emptyset \\
				\{(\emptyset, s)\}, & \text{if } n = \tsem{\mathds{E}}_s^\textsc{e} \text{ and } n > 0 \text{ and } l \in \mathsf{Key} \\ & \text{and } \{ l, \ldots, l + n - 1 \} \cap \pred{dom}{h} \not\equiv \emptyset \\
				& \text{or } n > 0 \text{ and } l \not\in \mathsf{Key} \\
				\{ \lightning \}, & \text{otherwise}
			\end{cases}
		\\
		\tsem{\pderef{\pvar{x}}{\mathds{E}}}_{\hat{\mathsf{C}}}(h, s) &\triangleq
			\begin{cases}
				\{ (h, s[\pvar{x} \mapsto v]) \}, & \text{if } k = \tsem{\mathds{E}}_s^\textsc{e} \text{ and } k \in \pred{dom}{h} \text{ and } h(k) = v \\
				\{ (\emptyset, s) \}, & \text{if } k = \tsem{\mathds{E}}_s^\textsc{e} \text{ and } k \in \pred{dom}{h} \text{ and } h(k) \neq v \\
				\{ \lightning \}, & \text{otherwise}
			\end{cases}
		\\
		\tsem{\pmutate{\mathds{E}_1}{\mathds{E}_2}}_{\hat{\mathsf{C}}}(h, s) &\triangleq
		\begin{cases}
			\{ (h[k \mapsto v] \}, s) \}, & \text{if } k = \tsem{\mathds{E}_1}_s^\textsc{e} \text{ and } v = \tsem{\mathds{E}_2}_s^\textsc{e} \text{ and } k \in \pred{dom}{h} \\
			\{ \lightning \}, & \text{otherwise}
		\end{cases}
	\end{align*}
	A variable assignment to $\pvar{x}$ only updates the local variable stack to map variable $\pvar{x}$ to the evaluated expression $\mathds{E}$ under $s$, leaving the heap component unmodified. A memory allocation succeeds when it is possible to expand the current heap $h$ to hold a sequence of $n$ cells that are currently not in its domain. In all other cases, the command fails. A memory dereference succeeds in reading a value $v$ associated to key $k$ only when $k$ is in the heap's domain and the value mapped to it is effectively $v$. Last, we can mutate memory at location $k$ only when it is part of the domain of the heap $h$.
\end{defn}

\begin{defn}
	(Machine state reification).
	Given that the concrete states set, $\mathcal{S}$, is defined to be $(\mathsf{Storage} \times \mathsf{Stack}) \uplus \{\lightning\}$, and $\mathbb{M}$ is instantiated to $\mathsf{Storage} \times \mathsf{Stack}$, the machine state \emph{reification function} $\lfloor - \rfloor_\mathbb{M} : \mathbb{M} \rightarrow \mathcal{P}(\mathcal{S})$ is defined as:
	\[
		\lfloor m \rfloor_\mathbb{M} \triangleq \{ m \}
	\]
\end{defn}