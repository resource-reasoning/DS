\section{Proof of Serializability}

\begin{gather*}
a \rightarrow^*_\alpha b \overset{\text{def}}{\iff} \exists a', b' \ldotp a \rightarrow^* a' \xrightarrow{\alpha} b' \rightarrow^* b
\\
A(h, \mathds{P}) \triangleq \{ \alpha\ |\ \exists h', S' \ldotp (h, \emptyset, \emptyset, \mathds{P}) \rightarrow_\alpha^* (h', \emptyset, S', \pskip) \}
\\
h, \mathds{P} \vDash \alpha < \alpha' \overset{\text{def}}{\iff} \exists b, h', S' \ldotp (h, \emptyset, \emptyset, \mathds{P}) \rightarrow_\alpha^* b \rightarrow^*_{\alpha'} (h', \emptyset, S', \pskip)
\\
\alpha_\iota \triangleq \alpha \text{ s.t. } \alpha \in \{ \actalloc{\iota}{n}{l}, \actlock{\iota}{k}{\kappa}, \actunlock{\iota}{k}, \\ \actread{\iota}{k}{v}, \actwrite{\iota}{k}{v}\ |\ k, v, n, l \in \mathsf{Val}, \kappa \in \mathsf{Lock} \}
\\
\alpha(\iota, k) \triangleq \alpha \text{ s.t. } \alpha \in \{ \actread{\iota}{k}{v}, \actwrite{\iota}{k}{v}\ |\ v \in \mathsf{Val} \}
\end{gather*}
\begin{align*}
\pred{conflict}{\actwrite{i}{k}{v}, \actwrite{j}{k}{v'}} &\triangleq i \neq j
\\
\pred{conflict}{\actwrite{i}{k}{v}, \actread{j}{k}{v'}} &\triangleq i \neq j
\\
\pred{conflict}{\actread{i}{k}{v}, \actwrite{j}{k}{v'}} &\triangleq i \neq j
\\
\pred{conflict}{\alpha, \alpha'} &\triangleq \bot 
\end{align*}
\begin{align*}
\pred{SG}{h, \mathds{P}} &\triangleq (N, E) \\
\text{where } N &\triangleq \{ \iota\ |\ \exists \alpha_\iota \ldotp \alpha_\iota \in A(h, \mathds{P}) \} \\
E &\triangleq \{ (i, j)\ |\ \pred{conflict}{\alpha(i, k), \alpha(j, k)} \land h, P \vDash \alpha(i, k) < \alpha(j, k) \}
\end{align*}

\lem All reads are preceded by the appropriate shared lock acquisition which is later released.
\begin{gather*}
\forall h, \iota, k, v, \kappa \ldotp \\
\actread{\iota}{k}{v} \in A(h, \mathds{P}) \implies \left( h, \mathds{P} \vDash \actlock{\iota}{k}{\kappa} < \actread{\iota}{k}{v} < \actunlock{\iota}{k} \land \kappa \geq \textsc{s} \right)
\end{gather*}

\begin{proof}
Let's pick an arbitrary storage $h \in \mathsf{Storage}$, transaction identifier $\iota \in \mathsf{Tid}$, storage key $k \in \mathsf{Key}$, storage value $v \in \mathsf{Val}$ and lock mode $\kappa \in \mathsf{Lock}$. Now we assume that there exists an action label $\alpha = \actread{\iota}{k}{v}$ such that $\alpha \in A(h, \mathds{P})$ (\textsc{i}). So $\alpha$ labels one of the transitions which is part of the sequence that reduces $\mathds{P}$ to $\pskip$ starting with storage $h$ (reduced to $h_{end}$), empty lock manager $\Phi_0 \equiv \emptyset$ (reduced to another empty one $\Phi_{end} \equiv \emptyset$) and empty transactions' state (reduced to $S_{end}$). It must be the case that the $\alpha$ action label was produced by the following \textsc{Read} reduction rule $(h', \Phi', S', \mathds{P}') \xrightarrow{\alpha} (h', \Phi', S'', \mathds{P}'')$, which, in order to succeed, requires that $\hat{\Phi}'(k) = (\{ \iota \} \cup I, \kappa)$ for some set of transaction identifiers $I$ and lock mode $\kappa \geq \textsc{s}$.

Then we assume that there is no action $\alpha' = \actlock{\iota}{k}{\kappa}$ such that $h, \mathds{P} \vDash \alpha' < \alpha$, and given that the lock manager is only updated for acquisition through reductions labelled with \textsf{lock} as part of the explicit \textsc{Lock} and \textsc{LockS} rules, then there is no possible way that the state $(h', \Phi', S', \mathds{P}')$ succesfully reduced through $\alpha$ since $\hat{\Phi}'(k) = (I'
, \kappa)$ would be such that $\iota \not\in I'$. By contradiction, this means that we must have an $\alpha' = \actlock{\iota}{k}{\kappa}$ such that $h, \mathds{P} \vDash \alpha' < \alpha$.

Now we assume that there is no action $\alpha'' = \actunlock{\iota}{k}$ such that $h, \mathds{P} \vDash \alpha < \alpha ''$. We know $\alpha$ required $\hat{\Phi}'(k) = (\{ \iota \} \cup I, \kappa)$ which means that $\Phi' \not\equiv \emptyset$ but then by assumption (\textsc{i}) we know that $\mathds{P}''$ succesfully reduces to $\pskip$ with $\Phi_{end} \equiv \emptyset$. This means that along the chain of reductions that brought $\Phi'$ to $\Phi_{end}$ there has been an update to the lock manager which removed the entry associated with $k$. This can only happen explicitly through actions labelled with \textsf{unlock} that are only produced by the \textsc{Unlock} and \textsc{UnlockS} rules. This means that there is no possible way that $\mathds{P}''$ reduces to $\pskip$ with $\Phi_{end} \equiv \emptyset$, then by contradiction we must have an $\alpha'' = \actunlock{\iota}{k}$ such that $h, \mathds{P} \vDash \alpha < \alpha ''$.
\end{proof}

\lem All writes are preceded by the appropriate exclusive lock acquisition which is later released.
\begin{gather*}
\forall h, \iota, k, v \ldotp \\
\actwrite{\iota}{k}{v} \in A(h, \mathds{P}) \implies \left( h, \mathds{P} \vDash \actlock{\iota}{k}{\textsc{x}} < \actwrite{\iota}{k}{v} < \actunlock{\iota}{k} \right)
\end{gather*}

\lem If two transactions run conflicting operations on the same item, either one releases its lock before the other acquires it or vice versa.
\begin{gather*}
\forall h, i, j, k, \kappa \ldotp 
\{ \alpha(i, k), \alpha(j, k) \} \subseteq A(h, \mathds{P}) \land \pred{conflict}{\alpha(i, k), \alpha(j, k)} 
\\
\implies \left( h, \mathds{P} \vDash \actunlock{i}{k} < \actlock{j}{k}{\kappa} \right) \lor \left( h, \mathds{P} \vDash \actunlock{j}{k} < \actlock{i}{k}{\kappa} \right)
\end{gather*}

\lem No lock is acquired by a transaction after one gets released by the same transaction.
\begin{gather*}
\forall h, \iota, k, k', \kappa \ldotp 
\{ \alpha(\iota, k), \alpha(\iota, k') \} \subseteq A(h, \mathds{P})
\implies \left( h, \mathds{P} \vDash \actlock{i}{k}{\kappa} < \actunlock{j}{k'} \right)
\end{gather*}