\section{Proof of Serializability}

\begin{align*}
\mathsf{trace} &: (\mathsf{Storage} \times \mathsf{LMan} \times \mathsf{TState} \times \mathsf{Prog}) \rightarrow [\mathsf{Act}] \\
\pred{trace}{h, \emptyset, S, \pskip} &\triangleq [] \\
\pred{trace}{h, \Phi, S, \mathds{P}} &\triangleq \alpha : \pred{trace}{h', \Phi', S', \mathds{P}'}
\\
\text{s.t. }& (h, \Phi, S, \mathds{P}) \xrightarrow{\alpha} (h', \Phi', S', \mathds{P}') \rightarrow^* (h'', \emptyset, S'', \pskip)
\end{align*}
\begin{align*}
\mathsf{idx} &: [\mathsf{Act}] \times \mathsf{Act} \rightarrow \mathds{Z} \\
\pred{idx}{\tau, \alpha} &\triangleq \pred{idx'}{\tau, \alpha, 0} \\
\mathsf{idx}' &: [\mathsf{Act}] \times \mathsf{Act} \times \mathds{Z} \rightarrow \mathds{Z} \\
\pred{idx'}{[], -, -} &\triangleq -1 \\
\pred{idx'}{\alpha:as, \alpha, i} &\triangleq i \\
\pred{idx'}{-:as, \alpha, i} &\triangleq \pred{idx}{as, \alpha, i + 1}
\end{align*}
\begin{align*}
\in &: \mathsf{Act} \times [\mathsf{Act}] \rightarrow \mathsf{Bool} \\
\alpha \in \tau &\triangleq \pred{idx}{\tau, \alpha} > -1
\end{align*}
\begin{gather*}
\begin{array}{l l}
\tau \vDash \alpha < \alpha' \overset{\text{def}}{\iff}
&
\pred{idx}{\tau, \alpha} < \pred{idx}{\tau, \alpha'}
\end{array}
\\
\alpha_\iota \triangleq \alpha \text{ s.t. } \alpha \in \{ \actalloc{\iota}{n}{l}, \actlock{\iota}{k}{\kappa}, \actunlock{\iota}{k}, \actread{\iota}{k}{v}, \\ \actwrite{\iota}{k}{v}\ |\ k, v, n, l \in \mathsf{Val}, \kappa \in \mathsf{Lock} \}
\\
\alpha_\iota(k) \triangleq \alpha \text{ s.t. } \alpha \in \{ \actread{\iota}{k}{v}, \actwrite{\iota}{k}{v}\ |\ v \in \mathsf{Val} \}
\end{gather*}
\begin{align*}
\pred{conflict}{\actwrite{i}{k}{v}, \actwrite{j}{k}{v'}} &\triangleq i \neq j
\\
\pred{conflict}{\actwrite{i}{k}{v}, \actread{j}{k}{v'}} &\triangleq i \neq j
\\
\pred{conflict}{\actread{i}{k}{v}, \actwrite{j}{k}{v'}} &\triangleq i \neq j
\\
\pred{conflict}{\alpha, \alpha'} &\triangleq \bot 
\end{align*}

\lem \label{lem:unlock} All read or write operations that were locked are later released.
\begin{gather*}
\forall \tau, \iota, k, \kappa \ldotp \\
\alpha_\iota(k) \in \tau \implies \left( \tau \vDash \alpha_\iota(k) < \actunlock{\iota}{k} \right)
\end{gather*}

\begin{proof}
Let's pick an arbitrary storage $\tau \in \mathsf{[Act]}$, such that $\tau = \pred{trace}{h, \emptyset, \emptyset, \mathds{P}}$ for some $h \in \mathsf{Storage}$ and $\mathds{P} \in \mathsf{Prog}$, transaction identifier $\iota \in \mathsf{Tid}$, storage key $k \in \mathsf{Key}$ and lock mode $\kappa \in \mathsf{Lock}$. Now we assume that there exists an action label $\alpha = \alpha_\iota(k)$ such that $\alpha \in \tau$ (\textsc{i}). So $\alpha$ labels one of the transitions which is part of the sequence that reduces $\mathds{P}$ to $\pskip$ starting with storage $h$ (reduced to $h_{end}$), empty lock manager $\Phi_0 \equiv \emptyset$ (reduced to another empty one $\Phi_{end} \equiv \emptyset$) and empty transactions' state (reduced to $S_{end}$) from the definition of $\mathsf{trace}$. There are now two cases to consider, for some storage value $v \in \mathsf{Val}$.
\begin{enumerate}
\item If $\alpha = \actread{\iota}{k}{v}$, then it must be the case that the $\alpha$ action label was produced by the following \textsc{Read} reduction rule $(h, \emptyset, \emptyset, \mathds{P}) \rightarrow^* (h', \Phi', S', \mathds{P}') \xrightarrow{\alpha} (h', \Phi'', S'', \mathds{P}'') \rightarrow^* (h_{end}, \emptyset, S_{end}, \pskip)$, which, in order to succeed, requires that $\hat{\Phi}'(k) = \hat{\Phi}''(k) = (\{ \iota \} \cup I, \kappa)$ for some set of transaction identifiers $I$ and lock mode $\kappa \geq \textsc{s}$, meaning that $\Phi'' \not\equiv \emptyset$.
\item If $\alpha = \actwrite{\iota}{k}{v}$, then it must be the case that the $\alpha$ action label was produced by the following \textsc{Write} reduction rule $(h, \emptyset, \emptyset, \mathds{P}) \rightarrow^* (h', \Phi', S', \mathds{P}') \xrightarrow{\alpha} (h', \Phi'', S'', \mathds{P}'') \rightarrow^* (h_{end}, \emptyset, S_{end}, \pskip)$, which, in order to succeed, requires that $\hat{\Phi}'(k) = (\{ \iota \}, \kappa)$ for lock mode $\kappa \geq \textsc{s}$ and $\Phi'' = \Phi'[k \mapsto (\{\iota\}, \textsc{x})]$, meaning that $\Phi'' \not\equiv \emptyset$.
\end{enumerate}

Now we assume that there is no action $\alpha'' = \actunlock{\iota}{k}$ such that $\tau \vDash \alpha < \alpha ''$. We know that for both cases $\alpha$ makes $\Phi'' \not\equiv \emptyset$ but then by assumption (\textsc{i}) we know that $\mathds{P}''$ succesfully reduces to $\pskip$ with $\Phi_{end} \equiv \emptyset$. This means that along the chain of reductions that brought $\Phi''$ to $\Phi_{end}$ there has been an update to the lock manager which removed the entry associated with $k$. This can only happen explicitly through actions labelled with \textsf{unlock} that are exclusively produced by the \textsc{Unlock} rule. This means that there is no possible way that $\mathds{P}''$ reduces to $\pskip$ with $\Phi_{end} \equiv \emptyset$, therefore by contradiction we must have an $\alpha'' = \actunlock{\iota}{k}$ such that $\tau \vDash \alpha < \alpha ''$.
\end{proof}

\lem \label{lem:read} All reads are preceded by the appropriate shared lock acquisition.
\begin{gather*}
\forall \tau, \iota, k, v, \kappa \ldotp \\
\actread{\iota}{k}{v} \in \tau \implies \left( \tau \vDash \actlock{\iota}{k}{\kappa} < \actread{\iota}{k}{v} \land \kappa \geq \textsc{s} \right)
\end{gather*}

\begin{proof}
Let's pick an arbitrary trace $\tau \in \mathsf{[Act]}$, such that $\tau = \pred{trace}{h, \emptyset, \emptyset, \mathds{P}}$ for some $h \in \mathsf{Storage}$ and $\mathds{P} \in \mathsf{Prog}$, transaction identifier $\iota \in \mathsf{Tid}$, storage key $k \in \mathsf{Key}$, storage value $v \in \mathsf{Val}$ and lock mode $\kappa \in \mathsf{Lock}$. Now we assume that there exists an action label $\alpha = \actread{\iota}{k}{v}$ such that $\alpha \in \tau$ (\textsc{i}). So $\alpha$ labels one of the transitions which is part of the sequence that reduces $\mathds{P}$ to $\pskip$ starting with storage $h$ (reduced to $h_{end}$), empty lock manager $\Phi_0 \equiv \emptyset$ (reduced to another empty one $\Phi_{end} \equiv \emptyset$) and empty transactions' state (reduced to $S_{end}$) from the definition of $\mathsf{trace}$. It must be the case that the $\alpha$ action label was produced by the following \textsc{Read} reduction rule $(h, \emptyset, \emptyset, \mathds{P}) \rightarrow^* (h', \Phi', S', \mathds{P}') \xrightarrow{\alpha} (h', \Phi', S'', \mathds{P}'') \rightarrow^* (h_{end}, \emptyset, S_{end}, \pskip)$, which, in order to succeed, requires that $\hat{\Phi}'(k) = (\{ \iota \} \cup I, \kappa)$ for some set of transaction identifiers $I$ and lock mode $\kappa \geq \textsc{s}$.

Then we assume that there is no action $\alpha' = \actlock{\iota}{k}{\kappa}$ such that $\tau \vDash \alpha' < \alpha$, and given that the lock manager is only updated for acquisition through reductions labelled with \textsf{lock} as part of the explicit \textsc{Lock} rule, then there is no possible way that the state $(h', \Phi', S', \mathds{P}')$ succesfully reduced through $\alpha$ since $\hat{\Phi}'(k) = (I'
, \kappa)$ would be such that $\iota \not\in I'$. By contradiction, this means that we must have an $\alpha' = \actlock{\iota}{k}{\kappa}$ such that $\tau \vDash \alpha' < \alpha$.
\end{proof}

\lem \label{lem:write} All writes to a cell are preceded by the appropriate exclusive lock acquisition or by a shared one, given that at the moment the write happens, the transaction writing is the only one owning the cell.
\begin{gather*}
\forall \tau, \alpha, i, k, v \ldotp
\alpha = \actwrite{i}{k}{v} \land \alpha \in \tau \implies
(\tau \vDash \actlock{i}{k}{\textsc{x}} < \alpha \lor \\
\tau \vDash \actlock{i}{k}{\textsc{s}} < \alpha \land \forall j \neq i, \kappa \ldotp \tau \vDash \actlock{j}{k}{\kappa} < \alpha \implies \tau \vDash \actunlock{j}{k} < \alpha)
\end{gather*}

\begin{proof}
Let's pick an arbitrary trace $\tau \in \mathsf{[Act]}$, such that $\tau = \pred{trace}{h, \emptyset, \emptyset, \mathds{P}}$ for some $h \in \mathsf{Storage}$ and $\mathds{P} \in \mathsf{Prog}$, transaction identifier $i \in \mathsf{Tid}$, storage key $k \in \mathsf{Key}$. Now we assume that  $\alpha \in \tau$ where $\alpha = \actwrite{i}{k}{v}$. Then, $\alpha$ must label a reduction that brings $\mathds{P}$ to $\pskip$ in $\tau$, by definition of $\mathsf{trace}$. Therefore we must have the following reduction for some $h', h'', \Phi', \Phi'', S', \mathds{P}', \mathds{P}''$.
\[
(h, \emptyset, \emptyset, \mathds{P}) \rightarrow^* (h', \Phi', S', \mathds{P}') \xrightarrow{\alpha} (h'', \Phi'', S', \mathds{P}'')
\]
Given that the $\alpha$ label can only be generated by the \textsc{Write} rule, it is required for $\Phi'$ to be such that (\textsc{i}) $(\{i\}, \kappa) = \hat{\Phi}'(k)$ for a lock mode $\kappa \in \mathsf{Lock}$. Since the lock manager starts as an empty one ($\Phi_0 = \emptyset$), condition (\textsc{i}) is only satisfied when a $\mathsf{lock}$ label is generated by the \textsc{Lock} rule before $\alpha$ and the lock mode obtained is either exclusive (\textsc{x}) or shared, but in this case, no other transaction is in the set of owners when the state is reduced by $\alpha$.

Let's now assume that $\lnot (\tau \vDash \actlock{i}{k}{\textsc{x}} < \alpha \lor
\tau \vDash \actlock{i}{k}{\textsc{s}} \land \forall j, \kappa \ldotp \tau \vDash \actlock{j}{k}{\kappa} < \alpha \implies \tau \vDash \actunlock{j}{k} < \alpha)$, which means that for the trace $\tau$ there is no action $\alpha_i^x = \actlock{i}{k}{\textsc{x}}$ that happens before $\alpha$ and also, either there is no $\alpha_i^s = \actlock{i}{k}{\textsc{s}}$ such that $\tau \vDash \alpha_i^s < \alpha$, or there is another transaction $j$ which locks cell $k$ before $\alpha$ and does not release it before $\alpha$ happens. Formally, the negation resolves to:
\begin{gather*}
\tau \not\vDash \alpha_i^x < \alpha \land \tau \not\vDash \alpha_i^s < \alpha \\
\lor \\
\left( \tau \not\vDash \alpha_i^x < \alpha \land \left( \exists j, \kappa \ldotp \tau \vDash \actlock{j}{k}{\kappa} < \alpha \land \tau \not\vDash \actunlock{j}{k} < \alpha \right) \right)
\end{gather*}
We will now proceed to show that in any case we resolve to a contradiction.
\begin{enumerate}
\item In the case where $\tau \not\vDash \alpha_i^x < \alpha \land \tau \not\vDash \alpha_i^s < \alpha$ then there is no possible way for condition (\textsc{i}) to happen and we get to a contradiction.
\item In the other case, where $\tau \not\vDash \alpha_i^x < \alpha \land \left( \exists j, \kappa \ldotp \tau \vDash \actlock{j}{k}{\kappa} < \alpha \land \tau \not\vDash \actunlock{j}{k} < \alpha \right)$ there is no exclusive lock action $\alpha_i^x$ for which $\tau \vDash \alpha_i^x < \alpha$ but there might be an $\alpha_i^s$ such that $\tau \vDash \alpha_i^s < \alpha$. Now, there also exists a transaction $j$ different from $i$ that locked cell $k$ and did not unlock it before $\alpha$. This implies that either $(\{i\} \cup I, \textsc{s}) = \hat{\Phi}_2(k)$ or $(I, \textsc{s}) = \hat{\Phi}_2(k)$ with a non-empty owners set $I$. For this reason the $\alpha$ reduction could have never happen and we get to another contradiction.
\end{enumerate}
By contradiction we therefore obtain that $\tau \vDash \actlock{i}{k}{\textsc{x}} < \alpha \lor
\tau \vDash \actlock{i}{k}{\textsc{s}} \land \forall j, \kappa \ldotp \tau \vDash \actlock{j}{k}{\kappa} < \alpha \implies \tau \vDash \actunlock{j}{k} < \alpha$ must hold.
\end{proof}

\lem \label{lem:2phase} No lock is acquired by a transaction after one gets released by the same transaction.
\begin{gather*}
\forall \tau, \iota, k, k', \kappa \ldotp 
\left( \alpha_\iota(k) \in \tau \land \alpha_\iota(k') \in \tau \right)
\implies \left( \tau \vDash \actlock{\iota}{k}{\kappa} < \actunlock{\iota}{k'} \right)
\end{gather*}

\begin{proof}
Let's pick an arbitrary trace $\tau \in \mathsf{[Act]}$, such that $\tau = \pred{trace}{h, \emptyset, \emptyset, \mathds{P}}$ for some $h \in \mathsf{Storage}$ and $\mathds{P} \in \mathsf{Prog}$, transaction identifier $\iota \in \mathsf{Tid}$, storage keys $k, k' \in \mathsf{Key}$ and lock mode $\kappa \in \mathsf{Lock}$. Now we assume that  $\alpha \in \tau$ and $\alpha' \in \tau$ (\textsc{i}), where $\alpha = \alpha_\iota(k)$ and $\alpha' = \alpha_\iota(k')$ are two read or write operations performed by the same transaction identified with $\iota$ as part of trace $\tau$.

In the case of $k = k'$ then the result is easily obtained as a consequence of Lemma \ref{lem:unlock}, Lemma \ref{lem:read} and Lemma \ref{lem:write}, and because a thread cannot acquire the same lock twice due to the premiss of rule \textsc{Lock}.

We can instead assume that $k \neq k'$. Let $\alpha_l = \actlock{\iota}{k}{\kappa}$ and $\alpha_u = \actunlock{\iota}{k'}$. Using Lemma \ref{lem:unlock}, Lemma \ref{lem:read}, Lemma \ref{lem:write} and our original assumption (\textsc{i}) we obtain that $\alpha_l \in \tau \land \alpha_u \in \tau$ (\textsc{ii}) must hold. Let's assume that $\tau \vDash \alpha_u < \alpha_l$ (\textsc{iii}). The action label \textsf{unlock} is only generated by the reduction rule \textsc{Unlock}. Therefore it must be the case that $(h, \emptyset, \emptyset, \mathds{P}) \rightarrow^* (h', \Phi', S', \mathds{P}') \xrightarrow{\alpha_u} (h', \Phi'', S'', \mathds{P}')$ (\textsc{iv}), for some $h', \Phi', \Phi'', S', S'', \mathds{P}'$, which only reduces when $(s', p', \mathds{C}) \xrightarrow{\alpha_u} (s', \pshrink, \mathds{C})$, for some command $\mathds{C}$ in $\mathds{P}'$, where $(s', p') = S'(\iota)$ and $S'' = S'[\iota \mapsto (s', \pshrink)]$.

The action label \textsf{lock} is only generated by the reduction rule \textsc{Lock}. By (\textsc{iii}) and (\textsc{iv}), it must be the case that $(h', \Phi'', S'', \mathds{P}') \rightarrow^* (h_l, \Phi_l, S_l, \mathds{P}_l) \xrightarrow{\alpha_l} (h_l, \Phi_l', S_l', \mathds{P}_l)$, for some $h_l, S_l, S_l', \Phi_l, \Phi_l', \mathds{P}_l$, that reduces only when $(s_l, \pgrow, \mathds{C}') \xrightarrow{\alpha_l} (s_l, \pgrow, \mathds{C}')$, for some $\mathds{C}'$ in $\mathds{P}_l$, where $(s_l, \pgrow) = S_l(\iota)$. The latter condition is impossible since there is no semantic rule that allows a transaction phase to go from shrinking to growing, and $(s', \pshrink) = S''(\iota)$ which is set before $S_l$. By contradiction, we obtain that $\tau \vDash \alpha_l < \alpha_u$ must hold.
\end{proof}

\lem \label{lem:conflict} If two transactions run conflicting operations on the same item, either one releases its lock before the other acquires it or vice versa.
\begin{gather*}
\forall \tau, i, j, k, \kappa, \kappa' \ldotp 
\alpha_i(k) \in \tau \land \alpha_j(k) \in \tau \land \pred{conflict}{\alpha_i(k), \alpha_j(k)} 
\\
\implies \left( \tau \vDash \actunlock{i}{k} < \actlock{j}{k}{\kappa} \right) \lor \left( \tau \vDash \actunlock{j}{k} < \actlock{i}{k}{\kappa'} \right)
\end{gather*}

\begin{proof}
Let's pick an arbitrary trace $\tau \in \mathsf{[Act]}$, such that $\tau = \pred{trace}{h, \emptyset, \emptyset, \mathds{P}}$ for some $h \in \mathsf{Storage}$ and $\mathds{P} \in \mathsf{Prog}$, transaction identifiers $i, j \in \mathsf{Tid}$, storage key $k \in \mathsf{Key}$ and lock modes $\kappa, \kappa' \in \mathsf{Lock}$. We assume that the statements $\alpha_i(k) \in \tau$, $\alpha_j(k) \in \tau$ and $\pred{conflict}{\alpha_i(k), \alpha_j(k)}$ hold, we also reasonably assume that $\kappa$ and $\kappa'$ are the needed lock modes for transactions $i$ and $j$ to perform actions $\alpha_i(k)$ and $\alpha_j(k)$ respectively. Let $\alpha_i^l = \actlock{i}{k}{\kappa}, \alpha_i^u = \actunlock{i}{k}, \alpha_j^l = \actlock{j}{k}{\kappa'}, \alpha_j^u = \actunlock{j}{k}$. From Lemma \ref{lem:unlock}, Lemma \ref{lem:read} and Lemma \ref{lem:write} it follows that $\alpha_i^l, \alpha_i^u, \alpha_j^l, \alpha_j^u \in \tau$ and that $\alpha_i^l < \alpha_i^u \land \alpha_j^l < \alpha_j^u$ (\textsc{i}).

We now assume that $\lnot \left( \tau \vDash \alpha_i^u < \alpha_j^l  \lor \tau \vDash \alpha_j^u < \alpha_i^l \right)$ holds, which is equivalent to assuming that $\tau \vDash \alpha_j^l < \alpha_i^u$ and $\tau \vDash \alpha_i^l < \alpha_j^u$ hold, given that we know that all operations belong to $\tau$ and there must be an order among them. The statement, together with (\textsc{i}), implies that either $\tau \vDash \alpha_j^l < \alpha_i^l < \alpha_j^u < \alpha_i^u$ or $\tau \vDash \alpha_j^l < \alpha_i^l < \alpha_i^u < \alpha_j^u$ or $\tau \vDash \alpha_i^l < \alpha_j^l < \alpha_j^u < \alpha_i^u$ or $\tau \vDash \alpha_i^l < \alpha_j^l < \alpha_i^u < \alpha_j^u$ holds. For the rest of the proof we will use the first scenario, since an equivalent argument with the appropriate substitutions can be made for the other three.

Therefore, the reduction chain which generated $\tau$ and that brings $\mathds{P}$ to $\pskip$ (by definition of $\mathsf{trace}$) must have the following shape, for some $h_1, \Phi_1, S_1, \mathds{P}_1, \Phi_1'$, $h_2, \Phi_2, S_2, \mathds{P}_2, \Phi_2'$, $h_3, \Phi_3, S_3, \mathds{P}_3, \Phi_3', S_3'$, $h_4, \Phi_4, S_4, \mathds{P}_4, \Phi_4', S_4'$.
\begin{gather*}
(h, \emptyset, \emptyset, \mathds{P}) \rightarrow^* (h_1, \Phi_1, S_1, \mathds{P}_1) \xrightarrow{\alpha_j^l} (h_1, \Phi_1', S_1, \mathds{P}_1) \rightarrow^* (h_2, \Phi_2, S_2, \mathds{P}_2) \xrightarrow{\alpha_i^l} (h_2, \Phi_2', S_2, \mathds{P}_2)
\\
\rightarrow^* (h_3, \Phi_3, S_3, \mathds{P}_3) \xrightarrow{\alpha_j^u} (h_3, \Phi_3', S_3', \mathds{P}_3) \rightarrow^* (h_4, \Phi_4, S_4, \mathds{P}_4) \xrightarrow{\alpha_i^u} (h_4, \Phi_4', S_4', \mathds{P}_4)
\end{gather*}
By our initial assumption, we know that the $\alpha_i(k)$ and $\alpha_j(k)$ are conflicting, meaning that one of them (or both) is a write operation on $k$. We will consider the situation where $\alpha_i(k)$ is a write action, noting that an equivalent proof can be obtained by having $\alpha_j(k)$ a write and making the appropriate substitutions. The transition labelled as $\alpha_j^l$ updates $\Phi_1$ to be (\textsc{ii}) $\Phi_1' = \Phi_1[k \mapsto (\{\iota\} \cup I, \kappa)]$ for some (potentially empty) set of transaction identifiers $I$.

Now we can establish that there cannot be any $\alpha_j^{u'} = \actunlock{j}{k}$ such that $\tau \vDash \alpha_j^l < \alpha_j^{u'} < \alpha_i^l$ (\textsc{iii}). Let's on the contrary assume that there exists such $\alpha_j^{u'}$. Then it must be the case that $\tau \vDash \alpha_j^{u'} < \alpha_j^{u}$ since $\tau \vDash \alpha_i^l < \alpha_j^u$ and $\tau \vDash \alpha_j^{u'} < \alpha_i^l$. This cannot be possible, given that by Lemma \ref{lem:2phase} there cannot be an action $\alpha_j^{l'} = \actlock{j}{k}{\kappa}$ such that $\tau \vDash \alpha_j^{u'} < \alpha_j^{l'} < \alpha_j^{u}$ and the $\mathsf{unlock}$ action label can only be generated through the \textsc{Unlock} rule which requires $j$ to be in the set of owners of $k$ in the lock manager which was removed by $\alpha_j^{u'}$ and never added back. By contradiction we obtain that no such $\alpha_j^{u'}$ exists.

From (\textsc{ii}) and (\textsc{iii}) we obtain that $(\{\iota\} \cup I, \kappa) = \hat{\Phi}_2(k)$ meaning that the set of owners of $k$ is definitely non-empty. It follows that there is no possible way of the $\alpha_i^l$ transition happening since it can only be produced by the \textsc{Lock} rule which requires $(\emptyset, \textsc{u}) = \hat{\Phi}_2(k)$. By contradiction we get that $\tau \vDash \alpha_i^u < \alpha_j^l  \lor \tau \vDash \alpha_j^u < \alpha_i^l$ must hold.
\end{proof}

\begin{align*}
\pred{SG}{\tau} &\triangleq (N, E) \\
\text{where } N &\triangleq \{ \iota\ |\ \exists \alpha_\iota \ldotp \alpha_\iota \in \tau \} \\
E &\triangleq \{ (i, j)\ |\ \pred{conflict}{\alpha_i(k), \alpha_j(k)} \land \tau \vDash \alpha_i(k) < \alpha_j(k) \}
\end{align*}
\begin{align*}
i \rightarrow j \in \pred{SG}{\tau} &\triangleq (i, j) \in \pred{SG}{\tau} \downarrow_2
\\
i \rightarrow^1 j \in \pred{SG}{\tau} &\triangleq i \rightarrow j \in \pred{SG}{\tau}
\\
i \rightarrow^n j \in \pred{SG}{\tau} &\triangleq \exists t \ldotp i \rightarrow t \in \pred{SG}{\tau} \land t \rightarrow^{n-1} \in \pred{SG}{\tau}
\\
i \rightarrow^* j \in \pred{SG}{\tau} &\triangleq \exists n \ldotp i \rightarrow^n j \in \pred{SG}{\tau}
\end{align*}

\lem \label{lem:sg1}
\begin{gather*}
\forall \tau, i, j \ldotp i \rightarrow j \in \pred{SG}{\tau} \implies \\
\exists k, \kappa \ldotp \alpha_i(k) \in \tau \land \alpha_j(k) \in \tau \land \pred{conflict}{\alpha_i(k), \alpha_j(k)} \land \tau \vDash \actunlock{i}{k} < \actlock{j}{k}{\kappa}
\end{gather*}
\begin{proof}
Let's pick an arbitrary trace $\tau \in \mathsf{[Act]}$, such that $\tau = \pred{trace}{h, \emptyset, \emptyset, \mathds{P}}$ for some $h \in \mathsf{Storage}$, $\mathds{P} \in \mathsf{Prog}$ and transaction identifiers $i, j \in \mathsf{Tid}$. Now we assume that $i \rightarrow j \in \pred{SG}{\tau}$. By definition of a serialization graph built through $\mathsf{SG}$ we directly obtain that there must be two actions $\alpha = \alpha_i(k)$ and $\alpha' = \alpha_j(k)$ in $\tau$ which are conflicting, so $\pred{conflict}{\alpha, \alpha'}$ holds and $\tau \vDash \alpha < \alpha'$ (\textsc{i}). By Lemma \ref{lem:read}, Lemma \ref{lem:write} and Lemma \ref{lem:unlock} we obtain the following, for $\alpha_i^l = \actlock{i}{k}{\kappa}, \alpha_i^u = \actunlock{i}{k}, \alpha_j^l = \actlock{j}{k}{\kappa'}, \alpha_j^u = \actunlock{j}{k}$ and $\kappa, \kappa' \in \mathsf{Lock}$.
\begin{enumerate}
\item \label{sg1.1} $\tau \vDash \alpha_i^l < \alpha < \alpha_j^u$
\item \label{sg1.2} $\tau \vDash \alpha_j^l < \alpha' < \alpha_j^u$
\end{enumerate}
By Lemma \ref{lem:conflict} we know that either $\tau \vDash \alpha_i^u < \alpha_j^l$ or $\tau \vDash \alpha_j^u < \alpha_i^l$ holds. In the case where $\tau \vDash \alpha_j^u < \alpha_i^l$ holds, by points \ref{sg1.1} and \ref{sg1.2} we would get that $\tau \vDash \alpha' < \alpha$ which contradicts (\textsc{i}). Therefore it must be the case that $\tau \vDash \alpha_i^u < \alpha_j^l$ holds.
\end{proof}

\lem \label{lem:sg2}
\begin{gather*}
\forall \tau, i, j, n > 0 \ldotp i \rightarrow^n j \in \pred{SG}{\tau} \implies \\
\exists k, k', \kappa \ldotp \alpha_i(k) \in \tau \land \alpha_j(k') \in \tau \land \tau \vDash \actunlock{i}{k} < \actlock{j}{k}{\kappa}
\end{gather*}

{\parindent0pt
\begin{proof}
Let's pick an arbitrary trace $\tau \in \mathsf{[Act]}$, such that $\tau = \pred{trace}{h, \emptyset, \emptyset, \mathds{P}}$ for some $h \in \mathsf{Storage}$, $\mathds{P} \in \mathsf{Prog}$, $n \in \mathds{Z}$ such that $n > 0$ and transaction identifiers $i, j \in \mathsf{Tid}$. We will prove the lemma by induction on $n$. \\

\textit{Base case}: $n = 1$

We assume that $i \rightarrow^1 j \in \pred{SG}{\tau}$ which, by definition, is equivalent to $i \rightarrow j \in \pred{SG}{\tau}$. By Lemma \ref{lem:sg1} we get that $\exists k, \kappa \ldotp \alpha_i(k) \in \tau \land \alpha_j(k) \in \tau \land \tau \vDash \actunlock{i}{k} < \actlock{j}{k}{\kappa}$ that concludes the proof for this case. \\

\textit{Inductive case}: $n > 1$

\textit{Inductive hypothesis}: Assume the property holds for $n$.

We now want to prove the same property for $n + 1$ so we assume that $i \rightarrow^{n+1} j \in \pred{SG}{\tau}$. By definition, we know that for $n$ and some $t \in \mathsf{Tid}$, $i \rightarrow^n t \in \pred{SG}{\tau}$ and $t \rightarrow j \in \pred{SG}{\tau}$ holds. By inductive hypothesis on $n$ we obtain that, for keys $k_1, k_2 \in \mathsf{Key}$ and lock mode $\kappa_t \in \mathsf{Lock}$, there are two actions $\alpha_i(k_1)$ and $\alpha_t(k_2)$ which are part of $\tau$ and that $\tau \vDash \actunlock{i}{k_1} < \actlock{t}{k_2}{\kappa_t}$ holds. By the fact that $t \rightarrow j \in \pred{SG}{\tau}$ holds and Lemma \ref{lem:sg1} we know that, for a storage key $k \in \mathsf{Key}$ and lock mode $\kappa \in \mathsf{Lock}$, there are two conflicting actions $\alpha_t(k)$ and $\alpha_j(k)$ inside $\tau$ such that $\tau \vDash \actunlock{t}{k} < \actlock{j}{k}{\kappa}$. By Lemma \ref{lem:2phase} we obtain that $\tau \vDash \actlock{t}{k_2}{\kappa_t} < \actunlock{t}{k}$ holds. As a consequence, it follows that $\tau \vDash \actunlock{i}{k_1} < \actlock{j}{k}{\kappa}$.
\end{proof}
}

\thm
\[
\forall \tau, i \ldotp i \in \pred{SG}{\tau} \downarrow_1 \implies \lnot i \rightarrow^* i \in \pred{SG}{\tau}
\]

\begin{proof}
Let's pick an arbitrary trace $\tau \in \mathsf{[Act]}$, such that $\tau = \pred{trace}{h, \emptyset, \emptyset, \mathds{P}}$ for some $h \in \mathsf{Storage}$, $\mathds{P} \in \mathsf{Prog}$ and transaction identifier $i \in \mathsf{Tid}$. We assume that $i$ is part of the transaction identifiers in the serialization graph, i.e. $i \in \pred{SG}{\tau} \downarrow_1$. Let's also assume that the graph contains a cycle on $i$, which means that $\exists n \ldotp i \rightarrow^n i \in \pred{SG}{\tau}$. By Lemma \ref{lem:sg2} we obtain that for some keys $k, k' \in \mathsf{Key}$ and lock mode $\kappa \in \mathsf{Lock}$, $\tau \vDash \actunlock{i}{k} < \actlock{i}{k'}{\kappa}$ which contradicts Lemma \ref{lem:2phase}. Therefore, by contradiction we get that $\lnot i \rightarrow^* i \in \pred{SG}{\tau}$ which means that there are no cycles in the graph and therefore $\tau$ is serializable.
\end{proof}