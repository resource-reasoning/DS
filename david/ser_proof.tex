\section{Proof of Serializability}

\lem All reads are only succesfully reduced when the appropriate shared lock is held by the running transaction.
\begin{gather*}
\forall \iota, h, h', \Phi, \Phi', s, s', p, p' \ldotp \\ (h, \Phi, s, p, \pderef{\pvar{x}}{\mathds{E}}) \overset{\iota}{\rightsquigarrow} (h', \Phi', s', p', \pskip) \Rightarrow \Phi(\llbracket \mathds{E} \rrbracket_s) = (\{\iota\} \cup I, \kappa) \land \kappa \geq \textsc{s}
\end{gather*}

\lem All writes are only succesfully reduced when the appropriate exclusive lock is held by the running transaction or if a shared lock is held and no other transaction is holding the same lock.
\begin{gather*}
\forall \iota, h, h', \Phi, \Phi', s, s', p, p' \ldotp \\ (h, \Phi, s, p, \pmutate{\mathds{E}_1}{\mathds{E}_2}) \overset{\iota}{\rightsquigarrow} (h', \Phi', s', p', \pskip) \Rightarrow \Phi(\llbracket \mathds{E}_1 \rrbracket_s) = (\{\iota\}, \kappa) \land \kappa \geq \textsc{s}
\end{gather*}

\lem Locks can only be acquired while the running transaction is in the growing phase.
\begin{gather*}
\forall k, I, \iota, \kappa, \kappa', h, h', \Phi, \Phi', s, s', p, p' \ldotp \\ 
k \in \pred{dom}{h} \land \iota \not\in I \land (h, \Phi[k \mapsto (I, \kappa)], s, p, \mathds{C}) \overset{\iota}{\rightsquigarrow} (h', \Phi[k \mapsto (\{\iota\} \cup I, \kappa')], s', p', \mathds{C}) \\
\Rightarrow p = \pgrow
\end{gather*}

\lem Locks can only be released while the running transaction is in the shrinking phase.
\begin{gather*}
\forall k, I, \iota, \kappa, \kappa', h, h', \Phi, \Phi', s, s', p, p' \ldotp \\ 
k \in \pred{dom}{h} \land \iota \not\in I \land (h, \Phi[k \mapsto (\{\iota\} \cup I, \kappa)], s, p, \mathds{C}) \overset{\iota}{\rightsquigarrow} (h', \Phi[k \mapsto (I, \kappa')], s', p', \mathds{C}) \\
\Rightarrow p' = \pshrink
\end{gather*}

\begin{gather*}
\forall \mathds{P} \in \mathsf{Prog}, h, h' \in \mathsf{Heap}, \Phi, \Phi' \in \mathsf{LMan}, S, S' \in \mathsf{TState} \ldotp \\ (h, \Phi, S, \mathds{P}) \rightarrowtail^* (h', \Phi', S', \pskip) \Rightarrow (h, \mathds{P}) \rightarrow^* (h', \pskip)
\end{gather*}