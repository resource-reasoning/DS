\section{Evaluation \& Comparisons}

The project was laid out as an exploration of transactional reasoning, with the objective of focusing on locking protocols, in particular the two-phase locking one. The main goal was to understand the protocol's behaviour from an abstract point of view, formally define it and later find a way to allow client reasoning around systems adopting it. These requirements were met and extended, with some limitations. A core strength of the framework that was built, is the flexibility of its \tpl\ model which is able to describe a large set of two-phase locking instantiations. Together with the operational semantics, it is also generic enough to allow its replicated usage in multiple settings, from databases to transactional applications that manage concurrency through two-phase locking. The fact that we prove serialisability on all traces produced by the semantics, and equivalence to the \textsc{Atomic} semantics, provides a great starting point for extensions or customisations to fit a particular context or need.

The primary limitation of the work is the lock manager abstraction, which appears as part of the \tpl\ model and semantics. First of all, it is used as a primitive structure and, together with the storage and the transactions' stack, it is embedded in the model. This might sound counterintuitive, since these kind of components are not usually built-in, but are rather part of user programs. We shape and use the lock manager as an \textit{oracle}, by hiding away all of the effective complexities involved in the construction and management of this structure, together with its interface to client transactions. This choice constraints situations where lock managing for cells cannot be directly abstracted by the paradigm we chose. Still, it is designed by taking inspiration from real-world use cases and from what literature suggests \cite{ccontrol}.

A substantial contribution of the project is that it served as a starting effort to build a bridge between separation logic style program reasoning, done in a concurrent setting, and database theory. Results in the latter group, are mainly conceived through the study of traces of executions and the analysis of graph that arise from their processing. We combine both approaches and use database style reasoning, in order to build a proof strategy that allows us to show the soundness of a program logic. The latter enables to build proofs of concurrent programs adopting \tpl\ for concurrency control.

The logic is a particular instantiation of mCAP, whose model is itself formalised as part of this thesis. It inherits the characteristics of standard CAP \cite{cap}, while amending its main shortcomings and constraints. The novelties introduced, as previously mentioned, are concerned with the parameterization of both the machine states and the capabilities model. These are in fact provided through any partial commutative monoid with multiple units, as defined in Section \ref{sec:pcm}. It follows that such abstraction frees the framework user from being contstrained to the standard heap model or the fractional-permission capabilities \cite{fractional} one, which cannot be modified in the original CAP work. As a consequence, the choice of the two parameters can then be taylored to the particular problem, algorithm or application that needs to be verified. This clearly eases the proof process and empowers users with more flexibility. We also vastly modified the original definitions of the \textit{rely} and \textit{guarantee} relations between worlds. They were in fact changed in order to support not just one, but multiple shared region updates done by both the environment and the running thread in one step. This results in a more realistic model that is able to express behaviours which are common in real-world scenarios. Finally, we believe that the structure and definition of the model is very accessible to people relatively new to the field, and, given that the program logic is an instantiation of the Views framework \cite{views}, its proof of soundness is clearer and shorter.

The model and operational semantics we introduced as part of this work, can be considered as one of the first attempts at formalising \tpl\ from a program logic point of view. Being able to construct concrete proofs, in the style of separation logic of programs, running under a \tpl\ concurrency control is also a novelty in many ways. Still, there has been interesting research work in the same area which is comparable to what was achieved here.

The model developed as part of the \textit{Push/Pull} framework, and presented in Section \ref{sec:serTransMod}, is more abstract than the one we describe in this thesis, as the main goal there was to cover a range of serializability protocols, not only \tpl, and find common ground among them. As a consequence, and given our focus on two-phase locking, we are able to describe much more precisely the behaviour and properties of \tpl\ in particular, while lacking the ability, for now, to reason about other serializability-preserving mechanisms.
	
	When building a proof of serialisability for the target semantics, a similar strategy is adopted between \textit{Push/Pull} and the work presented here. This is because both approaches first define an atomic operational semantics, followed by a proof of one-way equivalence to determine a simulation. This step additionally enables us to link the \tpl\ semantics to the mCAP logic judgements. On the other hand, building a program logic on top of the \textit{Push/Pull} model would require a considerable effort. Also, mapping a given program or algorithm to the set of rules in the semantics might not be straightforward. Since we give semantics on a concrete C-style language, the concurrent \textsc{While} one, proofs can be performed directly on the algorithms' implementation, provided a simulation between their way of locking cells to the lock manager we use.
	
	item Sequential verification
	
	item High-Level Small-Step
	
	item Sequential Specification of Transactional Memory Semantics