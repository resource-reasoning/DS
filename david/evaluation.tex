\section{Evaluation \& Comparisons}

The project was laid out as an exploration of transactional reasoning, with the objective of focusing on locking protocols, in particular the two-phase locking one. The main goal was to understand the protocol's behaviour from an abstract point of view, formally define it and later find a way to allow client reasoning around systems adopting it. These requirements were met and extended, with some limitations. A core strength of the framework that was built, is the flexibility of its \tpl\ model which is able to describe a large set of two-phase locking instantiations. Together with the operational semantics, it is also generic enough to allow its replicated usage in multiple settings, from databases to transactional applications that manage concurrency through two-phase locking. The fact that we prove serialisability on all traces produced by the semantics, and equivalence to the \textsc{Atomic} semantics, provides a great starting point for extensions or customisations to fit a particular context or need.

The primary limitation of the work is the lock manager abstraction, which appears as part of the \tpl\ model and semantics. First of all, it is used as a primitive structure and, together with the storage and the transactions' stack, it is embedded in the model. This might sound counterintuitive, since these kind of components are not usually built-in, but are rather part of user programs. We shape and use the lock manager as an \textit{oracle}, by hiding away all of the effective complexities involved in the construction and management of this structure, together with its interface to client transactions. This choice constraints situations where lock managing for cells cannot be directly abstracted by the paradigm we chose. Still, it is designed by taking inspiration from real-world use cases and from what literature suggests \cite{ccontrol}.

A substantial contribution of the project is that it served as a starting effort to build a bridge between separation logic style program reasoning, done in a concurrent setting, and database theory. Results in the latter group, are mainly conceived through the study of traces of executions and the analysis of graph that arise from their processing. We combine both approaches and use database style reasoning, in order to build a proof strategy that allows us to show the soundness of a program logic. The latter enables to build proofs of concurrent programs adopting \tpl\ for concurrency control.

The logic is a particular instantiation of mCAP, whose model is itself formalised as part of this thesis. It inherits the characteristics of standard CAP \cite{cap}, while amending its main shortcomings and constraints. The novelties introduced, as previously mentioned, are concerned with the parameterization of both the machine states and the capabilities model. These are in fact provided through any partial commutative monoid with multiple units, as defined in Section \ref{sec:pcm}. It follows that such abstraction frees the framework user from being contstrained to the standard heap model or the fractional-permission capabilities \cite{fractional} one, which cannot be modified in the original CAP work. As a consequence, the choice of the two parameters can then be taylored to the particular problem, algorithm or application that needs to be verified. This clearly eases the proof process and empowers users with more flexibility. We also vastly modified the original definitions of the \textit{rely} and \textit{guarantee} relations between worlds. They were in fact changed in order to support not just one, but multiple shared region updates done by both the environment and the running thread in one step. This results in a more realistic model that is able to express behaviours which are common in real-world scenarios. Finally, we believe that the structure and definition of the model is very accessible to people relatively new to the field, and, given that the program logic is an instantiation of the Views framework \cite{views}, its proof of soundness is clearer and shorter.

	During the early stages of the project, a considerable amount of time was used to investigate implementations of \tpl, together with the parallel effort of getting up to speed with modern ways to reason about concurrency inside heap-manipulating programs. The latter took longer than expected and, given the timescale of the project, could have been optimized to only focus on very relevant material. The initial thought was to start by proving a concrete implementation of the protocol through the TaDA logic \cite{tada} and potentially extend it to provide better support for transactions. A full C implementation was written and gradually proven through a \textsc{While} language equivalent version. Nevertheless, after some discoveries, it was decided to take a step back from the implementation, in order to shift the focus to more interesting and challenging ideas.

	The effort was then moved to the construction and improvement of the model and operational semantics we introduced as part of this work. The latter can be considered as one of the first attempts at formalising \tpl\ from a program logic point of view. Being able to construct concrete proofs, in the style of separation logic of programs, running under a \tpl\ concurrency control is also a novelty in many ways. Still, there has been interesting research work in the same area which is comparable to what was achieved here.

	The model developed as part of the \textit{Push/Pull} framework \cite{pushPull}, and presented in Section \ref{sec:serTransMod}, is more abstract than the one we describe in this thesis, as the main goal there was to cover a range of serializability protocols, not only \tpl, and find common ground among them. As a consequence, and given our focus on two-phase locking, we are able to describe much more precisely the behaviour and properties of \tpl\ in particular, while lacking the ability, for now, to reason about other serializability-preserving mechanisms. This is instead done by the compared model, even if mapping a given program or algorithm to the set of rules in the semantics might not be straightforward.
	
	When building a proof of serialisability for the target semantics, a similar strategy is adopted between \textit{Push/Pull} and the work presented here. This is because both approaches first define an atomic operational semantics, followed by a proof of one-way equivalence to determine a simulation. This step additionally enables us to link the \tpl\ semantics to the mCAP logic judgements and use our semantics within the context of a full-fledged concurrent program logic. On the other hand, building a program logic on top of the \textit{Push/Pull} model would require a considerable effort.
	
	On the contrary, the \textit{Push/Pull}'s framework models a variety of input languages, as it assumes a generic set of method call names, $M$, together with features also included in our model, such as the ability to spawn a new thread, make local stack updates, start a transaction and $\pskip$. $M$'s elements can be anything, and represent the operations performed by transactions and are used to populate the local and global logs. As part of our work, the operations that we happen within a transaction are instead bound to the programming language we defined in Section \ref{language}.
	
	In terms of the operational semantics for transactions we defined in this report, we find the comparison to the work in \cite{semanticsTransactions} to be very relevant. Both approaches consider the adoption of small-step semantics in order to model the interleaving between concurrent programs, and use a similar atomic baseline to show properties about the more complicated semantics by means of equivalence proofs. If on one hand, under the \tpl\ operational semantics, we allow multiple transactions to execute concurrently with effective interleaving between them, on the other, the formal languages presented in \cite{semanticsTransactions}, only permit one thread at a time to execute a transaction. Still, in the weaker isolation languages of the \textsf{AtomsFamily}, nontransactional code commands can run in parallel and therefore be interleaved with the running transaction. Each of the languages introduced comes with a type system which enforces specific behaviours and conservatively prohibits reaching error states from the a syntax misuse. As part of our work, we do not need such a construct, since our syntax does not allow erraneous programs. It follows that we can reason directly on the structure of programs. In \cite{semanticsTransactions}, properties are proven under the constraints of a particular type system: for example, the \textsf{Weak} and \textsf{StrongBasic} languages, introduced in Section \ref{sec:serTransMod}, are shown to be indistinguishable under a type system which imposes that the same heap location cannot be accessed inside and outside a transaction.