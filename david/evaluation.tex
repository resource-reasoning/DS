\section{Evaluation}

The project was laid out as an exploration of transactional reasoning, with the objective of focusing on locking protocols, in particular the two-phase locking one. During the early stages, a considerable amount of time was used to investigate commercial implementations of \tpl, together with the parallel effort of getting up to speed with modern ways to reason about concurrency inside heap-manipulating programs. The latter took longer than expected and, given the timescale of the project, could have been optimized to only focus on very relevant material. The initial thought was to start by proving a concrete implementation of the protocol through the TaDA logic \cite{tada} and potentially extend it to provide better support for transactions. A full C implementation was written and gradually proven through a \textsc{While} language equivalent version. Nevertheless, after some discoveries, it was decided to take a step back from the implementation, in order to shift the focus to more interesting and challenging ideas.

The main goal was then to understand the protocol's behaviour from an abstract point of view, formally define it and later find a way to allow client reasoning around systems adopting it. These requirements were met and extended, with some limitations. A core strength of the framework that was built, is the flexibility of its \tpl\ model which is able to describe a large set of two-phase locking instantiations. Together with the operational semantics, it is also generic enough to allow its replicated usage in multiple settings, from databases to transactional applications that manage concurrency through two-phase locking. The fact that we prove serialisability on all traces produced by the semantics, and equivalence to the \textsc{Atomic} semantics, provides a great starting point for extensions or customisations to fit a particular context or need.

One of the limitations of the work is the lock manager abstraction, which appears as part of the \tpl\ model and semantics. First of all, it is used as a primitive structure and, together with the storage and the transactions' stack, it is embedded in the model. This might sound counterintuitive, since these kind of components are not usually built-in, but are rather part of user programs. We shape and use the lock manager as an \textit{oracle}, by hiding away all of the effective complexities involved in the construction and management of this structure, together with its interface to client transactions. This choice constraints situations where lock managing for cells cannot be directly abstracted by the paradigm we chose. Still, it is designed by taking inspiration from real-world use cases and from what literature suggests \cite{ccontrol}.

A substantial contribution of the project is that it served as a starting effort to build a bridge between separation logic style program reasoning, done in a concurrent setting, and database theory. Results in the latter group, are mainly conceived through the study of traces of executions and the analysis of graph that arise from their processing. We combine both approaches and use database style reasoning, in order to build a proof strategy that allows us to show the soundness of a program logic. The latter enables to build proofs of concurrent programs adopting \tpl\ for concurrency control.

The logic is a particular instantiation of mCAP, whose model is itself formalised as part of this thesis. It inherits the characteristics of standard CAP \cite{cap}, while amending its main shortcomings and constraints. The novelties introduced, as previously mentioned, are concerned with the parameterization of both the machine states and the capabilities model. These are in fact provided through any partial commutative monoid with multiple units, as defined in Section \ref{sec:pcm}. It follows that such abstraction frees the framework user from being contstrained to the standard heap model or the fractional-permission capabilities \cite{fractional} one, which cannot be modified in the original CAP work. As a consequence, the choice of the two parameters is then taylored to the particular problem, algorithm or application that needs to be verified. This clearly eases the proof process and empowers users with more flexibility. We also vastly modified the original definitions of the \textit{rely} and \textit{guarantee} relations between worlds. They were in fact changed in order to support not just one, but multiple shared region updates done by both the environment and the running thread. This results in a more realistic model that is able to express behaviours which are common in real-world scenarios.

\subsection{Comparisons}