\section{Lock Injection}

We can now formally define a function $\textsf{inject} : \mathds{T} \rightarrow \mathds{L}$ which given a standard transaction, returns its corresponding locked version and internally uses two helper functions, namely $\textsf{injectC} : \mathds{C} \rightarrow (\mathds{K}, \{\mathds{E}\})$ and $\textsf{injectU} : \{\mathds{E}\} \rightarrow \mathds{U}$.
\begin{align*}
\textsf{inject}(\mathtt{begin}\ \mathds{C}\ \mathtt{end}) &= \mathtt{begin}\ k\ \textsf{injectU}(u)\ \mathtt{end} \\
\text{where } & (k, u) = \textsf{injectC}(\mathds{C}) \\
\\
\textsf{injectC}(\pderef{\pvar{x}}{\mathds{E}}) &= (\pfuncallnr{lock}{\mathds{E}, \textsc{s}}; \pderef{\pvar{x}}{\mathds{E}}, \{ \mathds{E} \}) \\
\\
\textsf{injectC}(\pmutate{\mathds{E}_1}{\mathds{E}_2}) &= (\pfuncallnr{lock}{\mathds{E}_1, \textsc{x}}; \pmutate{\mathds{E}_1}{\mathds{E}_2}, \{ \mathds{E}_1 \}) \\
\\
\textsf{injectC}(\mathds{C}_1; \mathds{C}_2) &= (k_1; k_2, u_1 \cup u_2) \\
\text{where } & (k_1, u_1) = \textsf{injectC}(\mathds{C}_1) \\
& (k_2, u_2) = \textsf{injectC}(\mathds{C}_2) \\
\\
\textsf{injectC}(\pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}) &= (\pif{\mathds{B}}{k_1}{k_2}, u_1 \cup u_2) \\
\text{where } & (k_1, u_1) = \textsf{injectC}(\mathds{C}_1) \\
& (k_2, u_2) = \textsf{injectC}(\mathds{C}_2) \\
\\
\textsf{injectC}(\ploop{\mathds{B}}{\mathds{C}}) &= (\ploop{\mathds{B}}{k}, u) \\
\text{where } & (k, u) = \textsf{injectC}(\mathds{C}) \\
\\
\textsf{injectC}(\mathds{C}) &= (\mathds{C}, \emptyset) \\
\\
\textsf{injectU}(\emptyset) &= \pskip \\ 
\textsf{injectU}(\{\mathds{E}\} \cup u) &= \pfuncallnr{unlock}{\mathds{E}}; \textsf{injectU}(u)
\end{align*}

\sx{ Your injection are a specific version that locks at the last moment and holds the lock till the end. 
     We should have a non-deterministic injection, therefore for given codes, there should be more than one version of injected codes.
     For instance if we have the code looks like follows:
     \[
         \pmutate{\loc_x}{1}; 
         \pmutate{\loc_y}{1}; 
     \]
     The possible injected version will be:
     \[
         \begin{array}{@{}l@{}}
         \texttt{lock}(\loc_x,write); \texttt{lock}(\loc_y,write);  \\
         \pmutate{\loc_x}{1}; \pmutate{\loc_y}{1};  \\
         \texttt{unlock}(\loc_x); \texttt{unlock}(\loc_y);  \\
        \end{array}
     \]
     OR
     \[
         \begin{array}{@{}l@{}}
         \texttt{lock}(\loc_x,write); \pmutate{\loc_x}{1}; \\
         \texttt{lock}(\loc_y,write); \pmutate{\loc_y}{1};  \\
         \texttt{unlock}(\loc_x); \texttt{unlock}(\loc_y);  \\
        \end{array}
     \]
     OR
     \[
         \begin{array}{@{}l@{}}
         \texttt{lock}(\loc_x,write); \texttt{lock}(\loc_y,write);  \\
         \pmutate{\loc_x}{1}; \texttt{unlock}(\loc_x); \\
         \pmutate{\loc_y}{1}; \texttt{unlock}(\loc_y);  \\
        \end{array}
     \]
     You can tell it is already very subtle because there are only two very loose restricts: 1) by the time you access a location, you must hold the corresponding lock, but one might lock at any moment before touching the location; 2) the injected version should have correct two-phase-locking.
     You can tell the three injected versions shown above satisfy the restricts, and when the program are arbitrary reads and writes, it becomes rather complicated.

     You can first start with writing down the semantics of the program with explicit lock and unlock, which is the easy part and then think how to define the injectC.
     
     No need to rush, think slowly and thoroughly. :)))
}  
