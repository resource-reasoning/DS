\section{Soundness}

\subsection{Model}

\defn (Separation algebra). A separation agebra $(\mathcal{M}, \bullet, I)$ is a partial, commutative monoid, with multiple units where $\mathcal{M}$ is a set equipped with a partial operator $\bullet : \mathcal{M} \times \mathcal{M} \rightharpoonup \mathcal{M}$ and a unit set $I \subseteq \mathcal{M}$ satisfying:
\begin{itemize}
\item Commutativity: $m_1 \bullet m_2 = m_2 \bullet m_1$ when either is defined.
\item Associativity: $m_1 \bullet (m_2 \bullet m_3) = (m_1 \bullet m_2) \bullet m_3$ when either is defined.
\item Existence of unit: for all $m \in \mathcal{M}$ there exists $i \in I$ such that $i \bullet m = m$.
\item Minimality of unit: for all $m \in \mathcal{M}$ and $i \in I$, if $i \bullet m$ is defined then $i \bullet m = m$.
\end{itemize}

\defn (Cross-split property) A separation agebra $(\mathcal{M}, \bullet, I)$ complies with the cross-split property if:
\begin{gather*}
	\forall a, b, c, d, z \ldotp a \bullet b = z \land c \bullet d = z \implies \\ \exists ac, ad, bc, bd \ldotp ac \bullet ad = a \land ac \bullet bc = c \land bc \bullet bd = b \land ad \bullet bd = d
\end{gather*}

\param (Machine states separation algebra). Let $(\mathbb{M}, \bullet_\mathbb{M}, \mathbf{0}_\mathbb{M})$ be any separation algebra satisfying the cross-split property, which represents machine states where elements of $\mathbb{M}$ are ranged over by $m, m_1, \ldots, m_n$. In the scenario of transactions reasoning, we instantiate the separation algebra to $(\mathsf{Storage}, \uplus, \emptyset)$, where $\uplus$ is the union of partial functions with disjoint domains.

\param (Capability separation algebra). Let $(\mathbb{K}, \bullet_\mathbb{K}, \mathbf{0}_\mathbb{K})$ be any separation algebra satisfying the cross-split property which represents capability resources where elements of $\mathbb{K}$ are ranged over by $\kappa, \kappa_1, \ldots, \kappa_n$.

\defn (Logical states). Given a separation algebra for machine states $(\mathbb{M}, \bullet_\mathbb{M}, \mathbf{0}_\mathbb{M})$, and one for capabilities $(\mathbb{K}, \bullet_\mathbb{K}, \mathbf{0}_\mathbb{K})$, a logical state is a pair $(m, \kappa)$ where $m \in \mathbb{M}$ is a machine state and $\kappa \in \mathbb{K}$ is a capability.
\[
	\mathsf{LState} \triangleq \mathbb{M} \times \mathbb{K}
\]
When referring to an arbitrary logical state or a local state we use $l, l_1, \ldots, l_n$. We define the unit logical state as $\mathbf{0}_\mathsf{L} \triangleq (\mathbf{0}_\mathbb{M}, \mathbf{0}_\mathbb{K})$ and given a logical state $l$ we use $l_\mathsf{M}$ and $l_\mathsf{K}$ to refer to its first and second projections respectively. The composition of logical states, formally $\circ : \mathsf{LState} \times \mathsf{LState} \rightharpoonup \mathsf{LState}$, is defined as:
\[
	(m, \kappa) \circ (m', \kappa') \triangleq (m \bullet_\mathbb{M} m', \kappa \bullet_\mathbb{K} \kappa')
\]
The separation algebra of logical states is thus $(\mathsf{LState}, \circ, \mathbf{0}_\mathsf{L})$.

\defn (Region identifiers). We define the set of region identifiers $\mathsf{Rid}$, ranged over by $r, r_1, \ldots, r_n$, to be equivalent to the set $\mathsf{Val}$.

\defn (Shared states). We define the set of shared states $\mathsf{GState}$, ranged over by $g, g_1, \ldots g_n$, as a finite partial function mapping region identifiers to logical states.
\[
	\mathsf{GState} \triangleq \mathsf{Rid} \overset{\text{fin}}{\rightharpoonup} \mathsf{LState}
\]

\defn (Compatibility). Given a separation algebra $(\mathcal{M}, \bullet, I)$, the compatibility property $\sharp : \mathcal{M} \times \mathcal{M}$ is defined as:
\[
	\sharp \triangleq \{ (m_1, m_2)\ |\ \exists m \ldotp m_1 \bullet m_2 = m \}
\]

\defn (Action models). The set of actions $\mathsf{Actions}$, ranged over by $a, a_1, \ldots, a_n$, is defined as:
\[
	\mathsf{Action} \triangleq \mathsf{LState} \times \mathsf{LState}
\]
The set of action models, $\mathsf{AMod}$, is defined as follows.
\[
	\mathsf{AMod} \triangleq \mathsf{Rid} \overset{\text{fin}}{\rightharpoonup} \mathcal{P}(\mathbb{K}) \overset{\text{fin}}{\rightharpoonup} \mathcal{P}(\mathsf{Action})
\]
We use $\mathcal{J}, \mathcal{J}_1, \ldots, \mathcal{J}_n$ to range over action models and we write $\emptyset$ for an action model with an empty domain.

\defn (World). The set of all worlds $\mathsf{World}$ is ranged over by $w, w_1, \ldots w_n$ and defined as the set of tuples containing a local state, a global one and an action model:
\[
	\mathsf{World} \triangleq \{ w \in \mathsf{LState} \times \mathsf{GState} \times \mathsf{AMod}\ |\ \pred{wf}{w} \}
\]
Composition on worlds, $\bullet : \mathsf{World} \rightarrow \mathsf{World} \rightharpoonup \mathsf{World}$, is defined by composing local states and requiring that shared states and action models be identical.
\[
	(l, g, \mathcal{J}) \bullet (l', g', \mathcal{J}') \triangleq
	\begin{cases}
		(l \circ l', g, \mathcal{J}), & \text{if } g = g' \text{ and } \mathcal{J} = \mathcal{J}'
		\\
		\mathsf{undef} & \text{otherwise}
	\end{cases}
\]

\subsection{Assertions}

We assume the presence of an infinite set of logical variables, $x \in \mathsf{LVar}$, logical expressions, $E \in \mathsf{LExpr}$, and logical environments, $\mathsf{LEnv}$, such that $e \in \mathsf{LEnv} : \mathcal{P}(\mathsf{LVar} \rightarrow \mathsf{Val})$. Logical environments associate logical variables with their values.

\param (Machine state assertions). We define the set of machine state assertions $\mathsf{MAssn}$, ranged over by $\mathcal{M}, \mathcal{M}_1, \ldots, \mathcal{M}_n$ as:
\[
	\mathcal{M} \in \mathsf{MAssn} ::= E_1 \mapsto E_2
\]
We also provide an associated semantics function that maps such assertions to elements of the machine state separation algebra, $\tsem{-}_-^\textsc{m} : \mathsf{MAssn} \rightarrow \mathsf{LEnv} \rightarrow \mathcal{P}(\mathbb{M})$.
\[
	\tsem{E_1 \mapsto E_2}_e^\textsc{m} \triangleq \{ h\ |\ \pred{dom}{h} = \{\tsem{E_1}_e^\textsc{e}\} \land h(\tsem{E_1}_e^\textsc{e}) = \tsem{E_2}_e^\textsc{e} \}
\]
It is assumed that the operator for logical expressions semantics, $\tsem{-}_-^\textsc{e} : \mathsf{LExpr} \rightarrow \mathsf{LEnv} \rightarrow \mathsf{Val}$, is appropriately defined.

\param (Capability assertions). Assume a set of capability assertions $\mathsf{KAssn}$ ranged over by $\mathcal{K}, \mathcal{K}_1, \ldots, \mathcal{K}_n$ and an associated semantics function that maps such assertions to elements of the capability separation algebra given as $(\mathbb{K}, \bullet_\mathbb{K}, \mathbf{0}_\mathbb{K})$:
\[
	\tsem{-}_-^\textsc{k} : \mathsf{KAssn} \rightarrow \mathsf{LEnv} \rightarrow \mathcal{P}(\mathbb{K})
\]

\defn (Assertion syntax). Assertions are elements of the $\mathsf{Assn}$ set defined by the following grammar, where $x \in \mathsf{LVar}$ and $r \in \mathsf{LExpr}$.
\begin{align*}
A &::= \mathtt{false}\ |\ \mathtt{emp}\ |\ \mathcal{M}\ |\ \mathcal{K} \\
p, q \in \mathsf{LAssn} &::= A\ |\ \lnot p\ |\ \exists x \ldotp p\ |\ p \lor q\ |\ p \sep q\ |\ p \sepimp q \\
P, Q \in \mathsf{Assn} &::= p\ |\ \exists x \ldotp P\ |\ P \lor Q\ |\ P \sep Q\ |\ \boxed{P}_I^r \\
I \in \mathsf{IAssn} &::= \emptyset\ |\ \{ \mathcal{K} : \exists \vec{y} \ldotp P \leadsto Q \} \cup I
\end{align*}

\defn (Assertion semantics). Assertion semantics are given with respect to a world $w \in \mathsf{World}$ and a logical environment $e \in \mathsf{LEnv}$.
\begingroup
\renewcommand*{\arraystretch}{1.5}
\[
\begin{array}{r c l}
	(l, g, \mathcal{J}), e \vDash p
	&
	\iff
	&
	l, e \vDash_\mathsf{SL} p
\\
	(l, g, \mathcal{J}), e \vDash \boxed{P}_I^r
	&
	\iff
	&
	l = \mathbf{0}_\mathbb{M} \text{ and } \exists l' \ldotp (l', g, \mathcal{J}) \vDash P
	\\ && \text{and } g(\tsem{r}_e^\textsc{e}) = l' \text{ and } g, \mathcal{J}(\tsem{r}_e^\textsc{e}), e \vDash_\mathcal{J} I
\\
	w, e \vDash \exists x \ldotp P
	&
	\iff
	&
	\exists v \ldotp w, e[x \mapsto v] \vDash P
\\
	w, e \vDash P \lor Q
	&
	\iff
	&
	w, e \vDash P \text{ or } w, e \vDash Q
\\
	w, e \vDash P \sep Q
	&
	\iff
	&
	\exists w_1, w_2 \ldotp w = w_1 \bullet w_2 \text{ and } \\ && w_1, e \vDash P \text{ and } w_2, e \vDash Q
\\
	g, a, e \vDash_\mathcal{J} \emptyset
	&
	\iff	
	&
	a = \emptyset
\\
	g, a, e \vDash_\textsc{i} \{ \mathcal{K} : \exists \vec{y} \ldotp P \leadsto Q \} \cup I
	&
	\iff
	&
	(l_P, l_Q) = a(\tsem{\mathcal{K}}_e^\textsc{k}) \text{ and } (l_P, g, \mathcal{J}), e \vDash \exists \vec{y} \ldotp P
	\\ && \text{and } (l_Q, g, \mathcal{J}) \vDash \exists \vec{y} \ldotp Q \text{ and } g, a, e \vDash_\mathcal{J} I
\\
	l, e \vDash_\mathsf{SL} \mathtt{false}
	&&
	\text{never}
\\
	l, e \vDash_\mathsf{SL}  \mathtt{emp}
	&
	\iff
	&
	l = \mathbf{0}_\mathsf{L}
\\
	l, e \vDash_\mathsf{SL} \mathcal{M}
	&
	\iff
	&
	\exists m \ldotp l = (m, \mathbf{0}_\mathbb{K}) \text{ and } m \in \tsem{\mathcal{M}}_e^\textsc{m}
\\
	l, e \vDash_\mathsf{SL} \mathcal{K}
	&
	\iff
	&
	\exists \kappa \ldotp l = (\mathbf{0}_\mathbb{M}, \kappa) \text{ and } \kappa \in \tsem{\mathcal{K}}_e^\textsc{k}
\\
	l, e \vDash_\mathsf{SL} \lnot p
	&
	\iff
	&
	l, e \not\vDash_\mathsf{SL} p
\\
	l, e \vDash_\mathsf{SL} p \sepimp q
	&
	\iff
	&
	\exists l' \ldotp l', e \vDash_\mathsf{SL} p \text{ and } l \sharp l' \text{ implies } \\
	&& l \circ l', e \vDash_\mathsf{SL} q
\\
	l, e \vDash_\mathsf{SL} p \sep q
	&
	\iff
	&
	\exists l_1, l_2 \ldotp l = l_1 \circ l_2 \text{ and } \\
	&& l_1, e \vDash_\mathsf{SL} p \text{ and } l_2, e \vDash_\mathsf{SL} q
\\
	 l, e \vDash_\mathsf{SL} p \lor q
	 &
	 \iff
	 &
	 l, e \vDash_\mathsf{SL} p \text{ or } l, e \vDash_\mathsf{SL} q
\\
	l, e \vDash_\mathsf{SL} \exists x \ldotp p
	&
	\iff
	&
	\exists v \ldotp l, e[x \mapsto v] \vDash_\mathsf{SL} p
\end{array}
\]
\endgroup

Given a logical environment $e \in \mathsf{LEnv}$, we write $\tsem{P}_e$ for the set of all worlds satisfying assertion P.
\[
	\tsem{P}_e \triangleq \{ w\ |\ w, e \vDash P \}
\]

\subsection{Rest}

\param (Elementary command axioms). Given the separation algebra of machine states $(\mathbb{M}, \bullet_\mathbb{M}, \mathbf{0}_\mathbb{M})$ we define the set of axioms $\textsc{Ax}_{\hat{\mathsf{C}}} : \mathcal{P}(\mathbb{M}) \times \mathsf{Cmd} \times \mathcal{P}(\mathbb{M})$ as follows.
\[
	TO\ BE\ DEFINED
\]

\param (Sequential command axioms). Given the axiomatisation of elementary commands $\textsc{Ax}_{\hat{\mathsf{C}}}$, we now define the axioms of sequential commands, formally $\textsc{Ax}_\mathsf{C} : \mathcal{P}(\mathbb{M}) \times \mathsf{Cmd} \times \mathcal{P}(\mathbb{M})$.
\begin{align*}
	\textsc{Ax}_\mathsf{C} &\triangleq \textsc{Ax}_{\hat{\mathsf{C}}} \cup \textsc{Ax}_{\textsc{skip}} \cup \textsc{Ax}_{\textsc{seq}} \cup \textsc{Ax}_{\textsc{cond}} \cup \textsc{Ax}_{\textsc{loop}}
	\\
	\textsc{Ax}_{\textsc{skip}} &\triangleq \{ (M, \pskip, M)\ |\ M \in \mathcal{P}(\mathbb{M}) \}
	\\
	\textsc{Ax}_{\textsc{seq}} &\triangleq \{ (M, \mathds{C}_1 ; \mathds{C}_2, M')\ |\ (M, \mathds{C}_1, M'') \in \textsc{Ax}_\mathsf{C} \land (M'', \mathds{C}_2, M') \in \textsc{Ax}_\mathsf{C} \}
	\\
	\textsc{Ax}_{\textsc{cond}} &\triangleq \{ (M, \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}, M')\ |\ (M, \mathds{C}_1, M') \in \textsc{Ax}_\mathsf{C} \land (M, \mathds{C}_2, M') \in \textsc{Ax}_\mathsf{C} \}
	\\
	\textsc{Ax}_{\textsc{loop}} &\triangleq \{ (M, \ploop{\mathds{B}}{\mathds{C}}, M)\ |\ (M, \mathds{C}, M) \in \textsc{Ax}_\mathsf{C}) \}
\end{align*}
Where $M, M'$ and $M''$ are used to quantify over elements of $\mathcal{P}(\mathbb{M})$.

\param (Transaction axioms). Given the axiomatisation of sequential commands $\textsc{Ax}_\mathsf{C}$ we define the set of transactions axioms, $\textsc{Ax}_\mathsf{T} : \mathcal{P}(\mathsf{World}) \times \mathsf{Trans} \times \mathcal{P}(\mathsf{World})$ as:
\[
	\textsc{Ax}_\mathsf{T} \triangleq \{ (W, \ptdef{\mathds{C}}_\iota, W')\ |\ (M_1, \mathds{C}, M_2) \in \textsc{Ax}_\mathsf{C} \land W \Rrightarrow^{\{M_1\}\{M_2\}} W' \}
\]
Where $W$ and $W'$ are used to quantify over elements of $\mathcal{P}(\mathsf{World})$.

\defn (Proof rules). All proof rules that follow carry the implicit assumption that the preconditions and postcondition of their judgements are stable.
\begin{gather*}
\begin{array}{c c}
	\infer[\textsc{Skip}]
	{
		\vdash \triple{P}{\pskip}{P}
	}
	{}
&
	\infer[\textsc{Trans}]
	{
		\vdash \triple{P}{\mathds{T}}{Q}
	}
	{
		(\tsem{P}, \mathds{T}, \tsem{Q}) \in \textsc{Ax}_\mathsf{T}
	}
\end{array}
\\ \\
\begin{array}{c c}
	\infer[\textsc{Seq}]
	{
		\vdash \triple{P}{\mathds{P}_1 ; \mathds{P}_2}{Q}
	}
	{
		\vdash \triple{P}{\mathds{P}_1}{R}
		&
		\vdash \triple{R}{\mathds{P}_2}{Q}	
	}
&
	\infer[\textsc{Par}]
	{
		\vdash \triple{P_1 \sep P_2}{\mathds{P}_1 \| \mathds{P}_2}{Q_1 \sep Q_2}	
	}
	{
		\vdash \triple{P_1}{\mathds{P}_1}{Q_1}
		&
		\vdash \triple{P_2}{\mathds{P}_2}{Q_2}	
	}
\end{array}
\\ \\
\begin{array}{c c}
	\infer[\textsc{Frame}]
	{
		\vdash \triple{P \sep R}{\mathds{P}}{Q \sep R}	
	}
	{
		\vdash \triple{P}{\mathds{P}}{Q}
	}
&
	\infer[\textsc{Conseq}]
	{
		\vdash \triple{P}{\mathds{P}}{Q}	
	}
	{
		P \Rrightarrow P'
		&
		\vdash \triple{P'}{\mathds{P}}{Q'}
		&
		Q' \Rrightarrow Q	
	}
\end{array}
\\ \\
\begin{array}{c c}
	\infer[\textsc{Choice}]
	{
		\vdash \triple{P}{\mathds{P}_1 + \mathds{P}_2}{Q}	
	}
	{
		\vdash \triple{P}{\mathds{P}_1}{Q}
		&
		\vdash \triple{P}{\mathds{P}_2}{Q}
	}
&
	\infer[\textsc{Loop}]
	{
		\vdash \triple{P}{\mathds{P}^*}{P}	
	}
	{
		\vdash \triple{P}{\mathds{P}}{P}
	}
\end{array}
\end{gather*}

\param (Concrete states). The set of concrete states $\mathcal{S}$ is defined to be equivalent to the $\mathsf{Storage}$ one. Thus we range over it using $h, h_1, \ldots, h_n$.

%\param (Elementary command interpretation). The elementary command interpretation function, formally $\tsem{-}_{\hat{\mathsf{C}}}^s : \mathsf{ECmd} \rightarrow \mathcal{S} \rightarrow \mathcal{P}(\mathcal{S})$ is defined in the following way.
%\[
%	\tsem{\hat{\mathds{C}}}_{\hat{\mathsf{C}}}^s \triangleq \{ h'\ |\ (h, s, \hat{\mathds{C}}) \rightarrow_\textsc{c} (h', s', \pskip) \}
%\]

%\defn (Sequential command interpretation). The sequential command interpretation function, formally $\tsem{-}_\mathsf{C}^s : \mathsf{Cmd} \rightarrow \mathcal{S} \rightarrow \mathcal{P}(\mathcal{S})$ is defined in the following way.

\param (Transactions interpretation). The interpretation function for transactions, formally $\tsem{-}_\mathsf{T} : \mathsf{Atom} \rightarrow \mathcal{S} \rightarrow \mathcal{P}(\mathcal{S})$, is defined as:
\[
	\tsem{\mathds{T}}_\mathsf{T}(h) \triangleq \{ h'\ |\ (h, \mathds{T}) \tred (h', \pskip) \}
\]
We also lift the interpretation function to a set of concrete state such that for $S \in \mathcal{P}(\mathcal{S})$:
\[
	\tsem{\mathds{T}}_\mathsf{T}(S) \triangleq \bigcup_{h \in S}  \tsem{\mathds{T}}_\mathsf{T}(h)
\]	

\param (Machine state reification).

\defn (Reification). The reification of worlds, $\lfloor - \rfloor_W : \mathsf{World} \rightarrow \mathcal{P}(\mathcal{S})$, is defined as follows.
\[
	\lfloor (l, g, \mathcal{J}) \rfloor_W \triangleq \lfloor (l \circ g)_\mathsf{M} \rfloor_\mathbb{M}
\]

\thm (Transaction soundness). For all $\mathds{T} \in \mathsf{Trans}, (W_1, \mathds{T}, W_2) \in \textsc{Ax}_\mathsf{T}$ and $w \in \mathsf{World}$:
\[
	\tsem{\mathds{T}}_\mathsf{T}(\lfloor W_1 \bullet \{ w \} \rfloor) \subseteq \lfloor W_2 \bullet_\mathbb{M} \mathcal{R}(\{ w \}) \rfloor_W
\]

\iffalse
\subsection{Parameter A}
\[
\mathsf{Atom} \triangleq \mathsf{Trans}
\]

\subsection{Parameter B}
\[
\mathcal{S} \triangleq \mathsf{Storage}
\]
\fi