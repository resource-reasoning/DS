\section{Introduction}

In recent times, the area of formal reasoning for concurrent and heap-manipulating programs, has seen a noticeable development towards program logics that can tackle the specification and verification of low-level concurrency in systems. This capability, together with the ubiquity of multithreading in computer programs, allows the formulation of reasoning frameworks around a variety of applications.

Modern database systems make heavy use of concurrency in order to provide a level of performance able to support large scale operations. This leads to an obvious increase in throughput but can cause a lack of consistency in data, which is instead a fundamental requirement for the majority of programs. A number of techniques has been employed in commercial databases to solve the issue and try to give the best of both worlds. Among these, \textit{Two-Phase-Locking} is a blocking approach which resides in the part of the spectrum of solutions where correctness is preferred over performance and that works at the granularity of single database entries. As a consequence, once implemented as part of a complex database system, the algorithm is prone to subtle bugs which might cause the violation of its vital guarantees.

We therefore intend to provide a complete and flexible model of the \textit{Two-Phase-Locking} concurrency control mechanism, as inspired by its real-world use case.
The aim is to derive a specification together with a sound level of abstraction that allows us not to think in terms of the low-level details enforced by the technique.
This leads us to the exploration of formal reasoning about its client usage through a custom program logic which is proven to be sound. The logic framework enables users to prove partial correctness of their programs running in a \textit{Two-Phase-Locking} setting, by only having to reason atomically about blocks of code, without the complexity of concurrent interleavings.

\subsection{Contributions}

The main contributions of this project are listed below, with references to the relevant sections where they are further discussed.
\begin{itemize}
	\item \textbf{mCAP} (Section \ref{sec:mcapModel}, \ref{sec:mcapLogic}, \ref{sec:transLogic})\ \ We reformulate and extend a program logic for concurrent programs, namely CAP \cite{cap}, in order to remove some of its constraints, which are hardcoded into the logic, and enable a more flexible reasoning. In fact, we change the underlying model to parametrize both the representation of machine states and of action capabilities. On top of this, we provide a new and cleaner structure for the action model that does not explicitly use interference assertions. We also considerably modify the way environment interference is modelled through the rely/guarantee relations. This is done with the goal of allowing both a thread, and the environment, to perform multiple shared region updates in one step. It follows that the repartitioning operator also has a new and extended behaviour. At the level of the programming language, we leave elementary atomic commands as a parameter to the user of the logic. Finally, we instantiate the mCAP framework into a logic for our particular needs of transactional reasoning.
	
	\item \textbf{\textsc{2pl} Model} (Section \ref{sec:2plMod})\ \ The details of two-phase locking are analysed and ported to a formal model that, through its constructs and structures, is able to describe a transactional software system that uses the protocol and exhibits all of the required behaviours. The main novelties introduced are related to the way we globally manage information related to locking and track the state of running transactions.
	
	\item \textbf{Operational Semantics} (Section \ref{sec:2plSemantics}, \ref{sec:ser})\ \ We use the constructs introduced in the \tpl\ model in order to shape a set of operational semantic rules that formally express the way the protocol acts at runtime. They are provided in a small-step fashion to enable the actual interleaving between concurrent transactions. Locking is implicit and does not occur as part of a language command. Instead, we take a nondeterministic approach to locking, and for this reason the semantics can model any particular pattern of lock acquisitions and releases, as long as it complies with the two-phase rule. The mentioned rules are able to reduce programs while labelling every step of the execution with the appropriate transaction or system operation. We group all such consecutive labels into a trace, which is the main structure used to construct a proof of serializability of the operational semantics as a whole. 
	
	\item \textbf{Semantics Equivalence} (Section \ref{sec:semEquiv})\ \ In order to allow mCAP style reasoning on programs running under \tpl, we are required to prove its soundness with respect to the operational semantics we introduced earlier. This effort is done in two steps, as we first prove the soundness in terms of a baseline operational semantics, which does not allow any interleaving between concurrent transactions by reducing them all at once: it effectively runs transactions atomically, in complete isolation. Then, we show that any reduction that reaches a terminal state in the \tpl\ semantics can be replicated by the atomic one. The latter proof requires a large number of intermediate results and structures which are formally defined, and whose specific properties are proven to be sound.
\end{itemize}