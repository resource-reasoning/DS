\section{Introduction}

In recent times, the area of formal reasoning for concurrent programs has seen a noticeable development towards program logics that can tackle the specification and verification of low-level concurrency in systems. This capability, together with the ubiquity of multithreading in computer programs, allows the formulation of reasoning frameworks around a variety of applications.

Modern database systems make heavy use of concurrency in order to provide a level of performance able to support large scale operations. This leads to an obvious increase in throughput but can cause a lack of consistency in data, which is instead a fundamental requirement for the majority of programs. A number of techniques has been employed in commercial databases to solve the issue and try to give the best of both worlds. Among these, \textit{Two-Phase-Locking} is a blocking approach which resides in the part of the spectrum of solutions where correctness is preferred over performance and that works at the granularity of single database entries. As a consequence, once implemented as part of a complex database system, the algorithm is prone to subtle bugs which might cause the violation of its guarantees.

We therefore intend to explore formal reasoning about clients' usage of concurrency control mechanisms, with a particular focus on \textit{Two-Phase-Locking}. The aim is to derive the serializability of operations coming from clients. We therefore provide a complete specification for the technique, and its corresponding proof, that is flexible enough to be adopted by any client in a modular fashion. This approach is then replicated and extended to cover concurrency control methods which do not use explicit locking but instead employ a multi-versioning approach.