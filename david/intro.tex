\section{Introduction}

In recent times, the area of formal reasoning for concurrent and heap-manipulating programs, has seen a noticeable development towards program logics that can tackle the specification and verification of low-level concurrency in systems. This capability, together with the ubiquity of multithreading in computer programs, allows the formulation of reasoning frameworks around a variety of applications.

Modern database systems make heavy use of concurrency in order to provide a level of performance able to support large scale operations. This leads to an obvious increase in throughput but can cause a lack of consistency in data, which is instead a fundamental requirement for the majority of programs. A number of techniques has been employed in commercial databases to solve the issue and try to give the best of both worlds. Among these, \textit{Two-Phase-Locking} is a blocking approach which resides in the part of the spectrum of solutions where correctness is preferred over performance and that works at the granularity of single database entries. As a consequence, once implemented as part of a complex database system, the algorithm is prone to subtle bugs which might cause the violation of its vital guarantees.

We therefore intend to provide a complete and flexible model of the \textit{Two-Phase-Locking} concurrency control mechanism, as inspired by its real-world use case.
The aim is to derive a specification together with a sound level of abstraction that allows us not to think in terms of the low-level details enforced by the technique.
This leads us to the exploration of formal reasoning about its client usage through a custom program logic which is proven to be sound. The logic framework enables users to prove partial correctness of their programs running in a \textit{Two-Phase-Locking} setting, by only having to reason atomically about blocks of code, without the complexity of concurrent interleavings.

\subsection{Contributions}

The main contributions of this project are listed below, with references to the relevant sections where they are further discussed.
\begin{itemize}
	\item \textbf{mCAP} (Section \ref{sec:mcapModel}, \ref{sec:mcapLogic}, \ref{sec:transLogic})\ \ We reformulate and extend a program logic for concurrent programs, namely CAP \cite{cap}, in order to remove some constraints which are hardcoded in the logic and enable a more flexible reasoning. In fact, we change the underlying model to parametrize both the representation of machine states and of action capabilities. On top of this, we provide a new and cleaner structure for the action model that does not explicitly use interference assertions. We also considerably modify the way environment interference is modelled through the rely/guarantee relations. This is done with the goal of allowing both a thread and the environment to perform multiple shared region updates in one step. It follows that the repartitioning operator also has a new and extended behaviour. At the level of programming language, we leave elementary atomic commands as a parameter to the user of the logic. Finally, we instantiate the mCAP framework into a logic for our particular needs of transactional reasoning.
	
	\item \textbf{\textsc{2pl} Model}\ \ 
	
	\item \textbf{Operational Semantics}\ \
	
	\item \textbf{Semantics Equivalence}
\end{itemize}