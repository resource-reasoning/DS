\section{Introduction}

In recent times, the area of formal reasoning for concurrent and heap-manipulating programs, has seen a noticeable development towards program logics that can tackle the specification and verification of low-level concurrency in systems. This capability, together with the ubiquity of multithreading in computer programs, allows the formulation of reasoning frameworks around a variety of applications.

Modern database systems make heavy use of concurrency in order to provide a level of performance able to support large scale operations. This leads to an obvious increase in throughput but can cause a lack of consistency in data, which is instead a fundamental requirement for the majority of programs. A number of techniques has been employed in commercial databases to solve the issue and try to give the best of both worlds. Among these, \textit{Two-Phase-Locking} is a blocking approach which resides in the part of the spectrum of solutions where correctness is preferred over performance and that works at the granularity of single database entries. As a consequence, once implemented as part of a complex database system, the algorithm is prone to subtle bugs which might cause the violation of its vital guarantees.

We therefore intend to provide a complete and flexible model of the \textit{Two-Phase-Locking} concurrency control mechanism, as inspired by its real-world use case.
The aim is to derive a specification together with a sound level of abstraction that allows us not to think in terms of the low-level details enforced by the technique.
This leads us to the exploration of formal reasoning about its client usage through a custom program logic which is proven to be sound. The logic framework enables users to prove partial correctness of their programs running in a \textit{Two-Phase-Locking} setting, by only having to reason atomically about blocks of code, without the complexity of concurrent interleavings.

\subsection{Contributions}