\chapter{Introduction}

Modern database systems use concurrency to increase performance and therefore to support large scale operations. In database systems programmers access data through transactions, which are self-contained programs describing a single unit of work. To manage the concurrent executions, database system introduce various techniques depending on the degree of consistency model\footnote{In database systems, it is usually called isolation or isolation levels}. This choice has an impact on the performance of the system too. A high-performance database system inevitably has to weaken its consistency model. However, in practice, many commercial database systems provide a relatively stronger consistency guarantee to release the developers' burden.

One of such models is shaped around the idea of serializable executions. Serializability is a strong consistency property that requires the outcome of any schedule of operations, which are grouped by transactions, to be equivalent to a serial one, i.e.\ transactions are run one after the other\ref{}. One way to implement this consistency model is through pessimistic concurrency control. \textit{Two-phase locking} is a popular concurrency control mechanism in this group, which is a blocking approach by associating database entries with various types of locks and a protocol between them, so that it can guarantee serializability without losing too much performance.

There are many works on reasoning about transactions, yet many of those methods are not composite. On the other hand, the area of reasoning about shared memory concurrency has seen a noticeable development especially programming logics that can verify fine-grained concurrency in a compositional way. In recent years, modern concurrent program logics, based on separation logic, introduces data abstraction and time abstraction, also called atomicity, so that it becomes possible to give abstract specifications by hiding implementation details, which are proven to be very useful for client reasoning.
Then, different implementations can be verified against the specifications without affecting client reasoning.
%They enable to adopt abstraction when dealing with data structures that are shared among concurrent threads. This property eases client reasoning of concurrent modules and allows the compositionality of proofs with levels of abstraction that can be layered one on top of the other. In addition to this, some of the more advanced logics are able to model the atomicity of an operation as the fiction of its effects happening at a single and discrete moment in time.

In the world of databases, and more specifically in the context of serializable models, transactions are often coupled with the idea of atomicity which is similar with the atomicity in shared memory: to the programmer's eyes, transactions are seen as units of work that gets executed in one step. Thus there is a connection between programming logics for shared memory concurrency and database transactions. This is why we formulate a program logic to reason about serializable transactions, which we believe it is the first of its kind. The focus is then shifted to an application of our logic to the setting of two-phase locking, where we prove that its semantics conform with the required atomicity. This enables users of the framework to prove partial correctness of  programs running in a system that adopts a flavour of this concurrency control protocol, by only having to reason atomically about blocks of code, without the complexity of concurrent interleavings. 

\section{Contributions}

The main technical contributions of this project are listed below, with references to the relevant sections where they are further discussed.
\begin{itemize}
	\item \textbf{mCAP} (Section \ref{sec:mcapModel}, \ref{sec:mcapLogic}, \ref{sec:transLogic})\ \ We reformulate and extend a program logic for concurrent programs, namely CAP \cite{cap}, in order to remove some of its constraints, which are hardcoded into the logic, and enable a more flexible reasoning. In fact, we change the underlying model to parametrize both the representation of machine states and of action capabilities. On top of this, we provide a new and cleaner structure for the action model that does not explicitly use interference assertions. We also considerably modify the way environment interference is modelled through the rely/guarantee relations. This is done with the goal of allowing both a thread, and the environment, to perform multiple shared region updates in one step. It follows that the repartitioning operator also has a new and extended behaviour. At the level of the programming language, we leave elementary atomic commands as a parameter to the user of the logic. Finally, we instantiate the mCAP framework into a logic for our particular needs of transactional reasoning.
	
	\item \textbf{\textsc{2pl} Model} (Section \ref{sec:2plMod})\ \ The details of two-phase locking are analysed and ported to a formal model that, through its constructs and structures, is able to describe a transactional software system that uses the protocol and exhibits all of the required behaviours. The main novelties introduced are related to the way we globally manage information related to locking and track the state of running transactions.
	
	\item \textbf{Operational Semantics} (Section \ref{sec:2plSemantics}, \ref{sec:ser})\ \ We use the constructs introduced in the \tpl\ model in order to shape a set of operational semantic rules that formally express the way the protocol acts at runtime. They are provided in a small-step fashion to enable the actual interleaving between concurrent transactions. Locking is implicit and does not occur as part of a language command. Instead, we take a nondeterministic approach to locking, and for this reason the semantics can model any particular pattern of lock acquisitions and releases, as long as it complies with the two-phase rule. The mentioned rules are able to reduce programs while labelling every step of the execution with the appropriate transaction or system operation. We group all such consecutive labels into a trace, which is the main structure used to construct a proof of serializability of the operational semantics as a whole. 
	
	\item \textbf{Semantics Equivalence} (Section \ref{sec:semEquiv})\ \ In order to allow mCAP style reasoning on programs running under \tpl, we are required to prove its soundness with respect to the operational semantics we introduced earlier. This effort is done in two steps, as we first prove the soundness in terms of a baseline operational semantics, which does not allow any interleaving between concurrent transactions by reducing them all at once: it effectively runs transactions atomically, in complete isolation. Then, we show that any reduction that reaches a terminal state in the \tpl\ semantics can be replicated by the atomic one. The latter proof requires a large number of intermediate results and structures which are formally defined, and whose specific properties are proven to be sound.
\end{itemize}
