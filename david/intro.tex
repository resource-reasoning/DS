\chapter{Introduction}

Modern database systems make heavy use of concurrency in order to provide a level of performance able to support large scale operations. Programmers access the underlying data through transactions, which are self-contained programs describing a single unit of work. In order to allow their concurrent execution, a number of techniques can be employed depending on the degree of consistency that needs to be guaranteed. This choice has an impact on the performance of the system too. In fact, enforcing a strict consistency model for data can be relatively expensive, while a weaker one can be ensured with less computational overhead.

One of such models is shaped around the idea of serializable executions. Serializability is a strong consistency property which requires the outcome of any schedule of operations, coming from concurrent transactions, to be equivalent to a serial one, where transactions are run one after the other. The typical way database systems implement this level of consistency is through mechanisms that reside in the part of the spectrum of solutions where consistency is preferred over performance. \textit{Two-phase locking} is a popular concurrency control protocol in this group, and it is a blocking approach which works at the granularity of single database entries.

When it comes to formal reasoning about the aforementioned transactions at a program logic level, we are left with no existing support. On the other hand, in recent times, the area of reasoning about concurrent and heap-manipulating programs has seen a noticeable development towards frameworks that can tackle the specification and verification of low-level and fine-grained concurrency in systems. Modern concurrent program logics, which are based on separation logic, are very powerful in the context of verifying complicated algorithms that use shared memory. They enable to adopt abstraction when dealing with data structures that are shared among concurrent threads. This property eases client reasoning of concurrent modules and allows the compositionality of proofs with levels of abstraction that can be layered one on top of the other. In addition to this, some of the more advanced logics are able to model the atomicity of an operation as the fiction of its effects happening at a single and discrete moment in time.

In the world of databases, and more specifically in the context of serializable models, transactions are often coupled with the idea of atomicity: to the programmer's eyes they are seen as units of work that gets executed in one step. Nevertheless, to the best of our knowledge, the numerous reasoning techniques explained earlier have not yet been applied to this scenario. This is why we formulate a program logic to reason about serializable transactions, the first of its kind. The focus is then shifted to an application of our logic to the setting of two-phase locking, where we prove that its semantics conform with the required atomicity. This enables users of the framework to prove partial correctness of  programs running in a system that adopts a flavour of this concurrency control protocol, by only having to reason atomically about blocks of code, without the complexity of concurrent interleavings. 

\section{Contributions}

The main technical contributions of this project are listed below, with references to the relevant sections where they are further discussed.
\begin{itemize}
	\item \textbf{mCAP} (Section \ref{sec:mcapModel}, \ref{sec:mcapLogic}, \ref{sec:transLogic})\ \ We reformulate and extend a program logic for concurrent programs, namely CAP \cite{cap}, in order to remove some of its constraints, which are hardcoded into the logic, and enable a more flexible reasoning. In fact, we change the underlying model to parametrize both the representation of machine states and of action capabilities. On top of this, we provide a new and cleaner structure for the action model that does not explicitly use interference assertions. We also considerably modify the way environment interference is modelled through the rely/guarantee relations. This is done with the goal of allowing both a thread, and the environment, to perform multiple shared region updates in one step. It follows that the repartitioning operator also has a new and extended behaviour. At the level of the programming language, we leave elementary atomic commands as a parameter to the user of the logic. Finally, we instantiate the mCAP framework into a logic for our particular needs of transactional reasoning.
	
	\item \textbf{\textsc{2pl} Model} (Section \ref{sec:2plMod})\ \ The details of two-phase locking are analysed and ported to a formal model that, through its constructs and structures, is able to describe a transactional software system that uses the protocol and exhibits all of the required behaviours. The main novelties introduced are related to the way we globally manage information related to locking and track the state of running transactions.
	
	\item \textbf{Operational Semantics} (Section \ref{sec:2plSemantics}, \ref{sec:ser})\ \ We use the constructs introduced in the \tpl\ model in order to shape a set of operational semantic rules that formally express the way the protocol acts at runtime. They are provided in a small-step fashion to enable the actual interleaving between concurrent transactions. Locking is implicit and does not occur as part of a language command. Instead, we take a nondeterministic approach to locking, and for this reason the semantics can model any particular pattern of lock acquisitions and releases, as long as it complies with the two-phase rule. The mentioned rules are able to reduce programs while labelling every step of the execution with the appropriate transaction or system operation. We group all such consecutive labels into a trace, which is the main structure used to construct a proof of serializability of the operational semantics as a whole. 
	
	\item \textbf{Semantics Equivalence} (Section \ref{sec:semEquiv})\ \ In order to allow mCAP style reasoning on programs running under \tpl, we are required to prove its soundness with respect to the operational semantics we introduced earlier. This effort is done in two steps, as we first prove the soundness in terms of a baseline operational semantics, which does not allow any interleaving between concurrent transactions by reducing them all at once: it effectively runs transactions atomically, in complete isolation. Then, we show that any reduction that reaches a terminal state in the \tpl\ semantics can be replicated by the atomic one. The latter proof requires a large number of intermediate results and structures which are formally defined, and whose specific properties are proven to be sound.
\end{itemize}