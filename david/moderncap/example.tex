\section{Motivating example}

We present an introductory example to give a taste of the work done from a high-level point of view. All of the notation and details that follow will be formally introduced and explained in later sections of this report.

Let's assume the existence of a retail bank which keeps all records of its customers' accounts in a database. The latter is a simple collection of indexed numerical items. We can reach a particular item in the database using its index key, also known as address. A bank account is implemented as a single item $a$ stored in the database, where $a$'s address is the customer's unique identifier and $a$'s content is the amount of money currently in the account.

The bank has a particular client, Bob, who pays his flat's rent of \$500 the first day of every month through direct debit. Coincidentally, the bank also pays interest to its customers on the first day of every month. In a fictional period of high interest rates, it gives \$600 per month to all of its 5 customers, including Bob. The modern bank's backend software system is setup in a way that the two described operations are scheduled to run in transactions that execute at the same time, concurrently. The executed code is displayed in Figure \ref{fig:bobCode}. We assume that Bob's unique identifier, and therefore account address, is $2$. This explains why the first transaction declaration assigns value $2$ to variable $\pvar{bob}$ to later dereference it and read the amount of money in the account. In the case where there is more than \$500 available, the same quantity is subtracted and the account's database item is updated. At the same time, as part of the other transaction, Bob's identifier is retrieved and used to increment by \$600 the amount in his account.
\begin{figure}[h]
	\begin{gather*}
		\begin{array}{c || c}
			\begin{array}{l}
				\mathtt{begin} \\
					\quad \passign{\pvar{bob}}{2}; \\
					\quad \pderef{\pvar{m}}{\pvar{bob}}; \\
					\quad \pifs{\pvar{m} \geq 500} \\
					\quad \quad \pmutate{\pvar{bob}}{\pvar{m} - 500} \\
				\mathtt{end}
			\end{array}
		&
			\begin{array}{l}
				\mathtt{begin} \\
					\quad \passign{\pvar{id}}{0}; \\
					\quad \pwhiles{\pvar{id} < 5} \\
						\quad \quad \pderef{\pvar{x}}{\pvar{id}}; \\
						\quad \quad \pmutate{\pvar{id}}{\pvar{x} + 600}; \\
						\quad \quad \passign{\pvar{id}}{\pvar{id} + 1} \\
					\quad \pwhilee \\
				\mathtt{end}
			\end{array}
		\end{array}
	\end{gather*}
	\captionof{figure}{The bank's database program ran every month in parallel to execute Bob's direct debit and credit interest to all of its customers.}
	\label{fig:bobCode}
\end{figure}

If we now were to assume the atomicity of operations at the level of single commands, we would need to consider all possible interleavings of the two blocks of code. Some of the possible executions that arise in this context are incorrect and can lead to serious issues. Table \ref{table:bankOutcome} shows every possible end state of the database, assuming that it started as $\{ 0 \mapsto n_0, 1 \mapsto n_1, 2 \mapsto 10000, 3 \mapsto n_3, 4 \mapsto n_4 \}$. The final result we would expect, and want, is the one described by option (ii) in the table, where Bob's account contains \$$10100$. Nevertheless, (i) and (iii) might still happen if the direct debit transaction reads Bob's money into $\pvar{m}$ first, but writes to it it after the other transaction has added \$$600$ to the total, or vice versa.

\bgroup
\setlength{\tabcolsep}{1em}
\def\arraystretch{1.5}
\begin{table}[h]
	\centering
	\caption{All the possible final database outcomes from the program in Figure \ref{fig:bobCode}.}
	\label{table:bankOutcome}
	\begin{tabular}{|c|c|c|c|c|c|}
	\hline
	\textbf{\#} & \textbf{0}         & \textbf{1}         & \textbf{2}         & \textbf{3}         & \textbf{4}         \\ \hline
	\textcolor{red}{i}   & $n_0 + 4$ & $n_1 + 4$ & $\textcolor{red}{10600}$     & $n_3 + 4$ & $n_4 + 4$ \\ \hline
	\textcolor{ForestGreen}{ii}  & $n_0 + 4$ & $n_1 + 4$ & $\textcolor{ForestGreen}{10100}$ & $n_3 + 4$ & $n_4 + 4$ \\ \hline
	\textcolor{red}{iii} & $n_0 + 4$ & $n_1 + 4$ & $\textcolor{red}{9500}$  & $n_3 + 4$ & $n_4 + 4$ \\ \hline
	\end{tabular}
\end{table}
\egroup

This clearly demonstrates that such a system is not safe for usage and requires a \textit{concurrency control} mechanism in place. We can for instance consider a setting where each transaction locks access to the entire database, executes, and once done, gives its priviledge to another transaction which is running in parallel. Such a primitive technique would clearly not provide good performance but would guarantee the absence of the issues we encountered previously and would be less hard to reason about. This is because, given two programs $p$ and $p'$ running concurrently, we only have to consider the case where $p$ goes first followed by $p'$ and where $p'$ runs before $p$. On the other hand, \textit{Two-Phase-Locking} works at the level of single database entries and allows concurrent transactions to only acquire locks for the items they read or write. The crucial constraint enforced by the mechanism is that, once a transaction releases a lock on an item, it cannot later lock any other one. 

In order to reason about the concurrent program in Figure \ref{fig:bobCode}, we introduce an abstraction to describe bank accounts. One of these is represented by a logic predicate of the shape $\pred{Account}{x, m}$. The latter describes an account that resides in the database at address $x$ and currently contains $m$ dollars. As the bank allows no overdraft, we add a constraint to all accounts in order to enforce $m$ to be a non-negative number. On top of this, the same predicate gives capabilities to perform the two fundamental actions:
\begin{itemize}
	\item Pay \textit{rent} by removing \$$500$ from the account when there is enough allowance.
	
	\item Credit \textit{interest} by adding \$$600$ to the total.
\end{itemize}
Formally, we represent all of this information as:
\[
	\pred{Account}{x, m}
		\equiv
	\exists r \ldotp \boxed{x \mapsto m \land m \geq 0}^r_{I(r, x)}
	\sep [\tguard{Rent}(m)]^r \sep [\tguard{Interest}(m)]^r
\]

Everything that is in the graphical rectangle, also known as a \textit{box}, represents the content of a part, or \textit{region}, of the database which is shared among multiple transactions, that can access it. The region is uniquely identified by $r$ and transactions can modify it by following a precise set of rules that is listed in the following table, which we call the region \textit{interpretation}. Intuitively, each action of the shape $a \transto b$ in the interpretation of a region, shows the required state that needs to be present in the region, $a$, followed by what that same chunk will be replaced with, $b$.
\[
	I(r, x) \triangleq \left( 
		\begin{array}{r l}
			\tguard{Rent}:
				&
			\exists m \ldotp \cell{x}{m} \land m \geq 500 \transfersto \cell{x}{m - 500} \sep [\tguard{Rent}]^r
			\\
			\tguard{Interest}:
				&
			\exists m \ldotp \cell{x}{m} \transfersto \cell{x}{m + 600} \sep [\tguard{Interest}]^r
		\end{array}
	 \right)
\]
The previously introduced capabilities are mapped to concrete mutations of the shared region's contents. For instance, if we look at the \tguard{Interest} case, we notice how a transaction is able to transform $\cell{x}{m}$ into $\cell{x}{m + 600}$ given that it holds the capability in its local state, and moves the latter back in the region. Since all region updates have to be modelled as part of its interpretation, it follows that the latter serves the crucial purpose of declaring to all transactions how might the shared state change under the effect of a concurrent program. This enables users of the program logic to write \textit{stable} assertions in their programs' specifications. If they do so, it is then ensured that a particular assertion will remain valid, no matter how concurrent transactions modify a region's content according to the interpretation's actions. Such a constraint automatically gives us the \textit{composionality} of proofs, meaning that two transactions can be proven independently and then combined in parallel.

A sketch proof of the two transactions running under \textsc{2pl} follows.
\[
	\begin{array}{l}
		\specline{
				\exists r \ldotp
					\boxed{
						\left(2 \mapsto m \lor 2 \mapsto m + 600 \right) \land m \geq 0
					}^r_{I(r, 2)}
					\sep [\tguard{Rent}]^r
		} \\
		\mathtt{begin} \\
			\quad \passign{\pvar{bob}}{2}; \\
			\quad \specline{
				\exists r \ldotp
					\boxed{\left( \pvar{bob} \mapsto m \lor \pvar{bob} \mapsto m + 600 \right) \land m \geq 0}^r_{I(r, \pvar{bob})}
					\sep [\tguard{Rent}]^r
			} \\
			\quad \pderef{\pvar{m}}{\pvar{bob}}; \\
			\quad \specline{
				\exists r \ldotp
					\boxed{\pvar{bob} \mapsto \pvar{m} \land \left(\pvar{m} = m \lor \pvar{m} = m + 600\right) \land m \geq 0}^r_{I(r, \pvar{bob})}
					\sep [\tguard{Rent}]^r
			} \\
			\quad \pifs{\pvar{m} \geq 500} \\
				\quad \quad \specline{
					\exists r \ldotp
						\boxed{\pvar{bob} \mapsto \pvar{m} \land \left(\pvar{m} = m \lor \pvar{m} = m + 600\right) \land \pvar{m} \geq 500}^r_{I(r, \pvar{bob})}
						\sep [\tguard{Rent}]^r
				} \\
				\quad \quad \pmutate{\pvar{bob}}{\pvar{m} - 500} \\
				\quad \quad \specline{\exists r \ldotp \boxed{\pvar{bob} \mapsto \pvar{m} - 500 \land \left(\pvar{m} = m \lor \pvar{m} = m + 600\right) \land \pvar{m} \geq 500 \sep [\tguard{Rent}]^r}^r} \\
		\mathtt{end} \\
		\specline{
				\left( \exists r \ldotp
					\boxed{2 \mapsto m - 500 \lor 2 \mapsto m + 100 \land m \geq 500 \sep [\tguard{Rent}]^r}^r_{I(r, 2)} \right) \\
				\lor \left( \exists r \ldotp
					\boxed{2 \mapsto m + 100 \land 0 \leq m < 500 \sep [\tguard{Rent}]^r}^r_{I(r, 2)} \right) \\
				\lor \left( \exists r \ldotp
					\boxed{
						2 \mapsto m \land 0 \leq m < 500
					}^r_{I(r, 2)}
					\sep [\tguard{Rent}]^r \right) \\
			} \\
	\end{array}
\]
\begin{gather*}
\specline{\pred{Account}{0, n_0} \sep \pred{Account}{1, n_1} \sep \pred{Account}{2, n_2} \\ \sep\ \pred{Account}{3, n_3} \sep \pred{Account}{4, n_4}} \\
\begin{array}{c || c}
	\begin{array}{l}
		\mathtt{begin} \\
			\quad \passign{\pvar{bob}}{2}; \\
			\quad \pderef{\pvar{m}}{\pvar{bob}}; \\
			\quad \pifs{\pvar{m} \geq 500} \\
			\quad \quad \pmutate{\pvar{bob}}{\pvar{m} - 500} \\
		\mathtt{end}
	\end{array}
	&
	\begin{array}{l}
		\mathtt{begin} \\
			\quad \passign{\pvar{id}}{0}; \\
			\quad \pwhiles{\pvar{id} < 5} \\
				\quad \quad \pderef{\pvar{x}}{\pvar{id}}; \\
				\quad \quad \pmutate{\pvar{x}}{\pvar{x} + 4}; \\
				\quad \quad \passign{\pvar{id}}{\pvar{id} + 1} \\
			\quad \pwhilee \\
		\mathtt{end}
	\end{array}
\end{array} \\
\specline{\pred{Account}{0, n_0 + 600} \sep \pred{Account}{1, n_1 + 600} \sep \pred{Account}{2, \textcolor{ForestGreen}{n_2 + 100}} \\ \sep\ \pred{Account}{3, n_3 + 600} \sep \pred{Account}{4, n_4 + 600}}
\end{gather*}