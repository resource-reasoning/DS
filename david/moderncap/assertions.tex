\subsection{Assertions}

Assertions in mCAP follow the ones in standard CAP with the only difference of being parametric with respect to the capability assertions that describe elements of the given capabilities in $\mathbb{K}$. Judgements in mCAP have the shape $\Delta \vdash \triple{P}{\mathds{P}}{Q}$ where $P, Q$ are \textit{assertions}, $\mathds{P}$ is a program and $\Delta$ is an \textit{axiom definition}, all defined in this section.

We assume the presence of an infinite set of logical variables, $x \in \mathsf{LVar}$ and logical environments, $\mathsf{LEnv}$, such that $e \in \mathsf{LEnv} \triangleq \mathsf{LVar} \xrightarrow{\text{fin}} \mathsf{Val}$. Logical environments associate logical variables with their values. Also, since mCAP is an extension of CAP, we provide support for abstract predicates used to express concrete properties. We assume to be given a set of predicate environments, $\mathsf{PEnv}$ that associate each predicate name (coming from the set $\mathsf{PName}$) and its arguments, to a set of worlds that satisfy them. Formally $\delta \in \mathsf{PEnv} \triangleq \mathsf{PName} \times \mathsf{Val}^* \rightarrow \mathcal{P}(\mathsf{World})$.

\begin{param}
	(Machine state assertions).
	Assume a set of \emph{machine state assertions} $\mathsf{MAssn}$, ranged over by $\mathcal{M}, \mathcal{M}_1, \ldots, \mathcal{M}_n$. Given the machine states pcm $(\mathbb{M}, \bullet_\mathbb{M}, \mathbf{0}_\mathbb{M})$, assume a semantics function, that maps machine state assertions to the elements of $\mathbb{M}$ it describes:
	\[
		\tsem{-}_-^\textsc{m} : \mathsf{MAssn} \rightarrow \mathsf{LEnv} \rightarrow \mathcal{P}(\mathbb{M})
	\]
\end{param}

\begin{param}
	(Capability assertions).
	Assume a set of \emph{capability assertions} $\mathsf{KAssn}$ ranged over by $\mathcal{K}, \mathcal{K}_1, \ldots, \mathcal{K}_n$ and an associated semantics function that maps such assertions to elements of the capability separation algebra given as $(\mathbb{K}, \bullet_\mathbb{K}, \mathbf{0}_\mathbb{K})$.
	\[
		\tsem{-}_-^\textsc{k} : \mathsf{KAssn} \rightarrow \mathsf{LEnv} \rightarrow \mathcal{P}(\mathbb{K})
	\]
\end{param}

\begin{defn}
	(Assertion syntax).
	Assertions are elements of the $\mathsf{Assn}$ set defined by the following grammar, where $x \in \mathsf{LVar}, r \in \mathsf{Rid}$ and $\alpha \in \mathsf{PName}$. 
	\begin{align*}
		A &::= \mathtt{false}\ |\ \mathtt{emp}\ |\ \mathcal{M}\ |\ [\mathcal{K}]^r \\
		p, q \in \mathsf{LAssn} &::= A\ |\ \lnot p\ |\ \exists x \ldotp p\ |\ p \lor q\ |\ p \sep q\ |\ p \sepimp q \\
		P, Q \in \mathsf{Assn} &::= p\ |\ \exists x \ldotp P\ |\ P \lor Q\ |\ P \sep Q\ |\ \boxed{P}_I^r\ |\ \alpha(\mathds{E}_1, \ldots, \mathds{E}_n) \\
		I \in \mathsf{IAssn} &::= \emptyset\ |\ \{ \mathcal{K} : \exists \vec{y} \ldotp P \leadsto Q \} \cup I \\
		\Delta \in \mathsf{Ax} &::= \emptyset\ |\ \forall \vec{x} \ldotp P \implies Q\ |\ \forall \vec{x} \ldotp \alpha(\vec{x}) \equiv P\ |\ \Delta_1, \Delta_2
	\end{align*}
\end{defn}

The structure of assertions follows from the separation logic one, with the addition of the given capability assertions $[\mathcal{K}]^r$, shared region (or \textit{boxed}) assertions $\boxed{P}^r_I$ and \textit{interference} assertions $I$. Machine state assertions, $\mathcal{M}$ are interpreted over a world's local logical state, i.e. $\mathcal{M}$ holds true when it is satisfied by $m$, as part of $(m, \rho)$, for a $\rho \in \mathbf{0}_\mathsf{RK}$. In a similar way, a capability assertion $[\mathcal{K}]^r$ is true in a logical state $(m, [r \mapsto \kappa])$ for $m \in\mathbf{0}_\mathbb{M}$, a shared region $r$ and capability $\kappa$ that satisfies $\mathcal{K}$. The assertion $\mathtt{emp}$ is only satisfied by the unit of logical states, formally any $l \in \mathbf{0}_\mathsf{L}$. The separating assertion $P \sep Q$ is true of worlds that can be split in two parts such that the first one satisfies $P$ while the second one $Q$. A predicate assertion holds in all worlds belonging to its semantic interpretation as given by the environment $\delta$. The predicate's arguments are evaluated with respect to the logical environment $e$.

An interference assertion $I$, describes actions that are enabled by a particular capability in the form of pre-condition and post-condition. $I$ is checked against the action model $\mathcal{J}$ to verify that, for the region $r$ it describes, every pre-condition $P$ and post-condition $Q$ are satisfied by $\mathcal{J}$'s actions pre- and post-state. The variables that are existentially bound as part of $I$'s action ($\vec{y}$) are set in the logical environment $e$ to be the same when checking for satisfaction of $P$ and $Q$. This is practically done by building (in Definition \ref{defn:interferenceSem}) a \textit{tiny} action model out of the assertions in $I$ and then checking that it is contained inside of $\mathcal{J}$.

Boxed assertions of the shape $\boxed{P}^r_I$ are true of worlds $(l, g, \mathcal{J})$ where the local state is empty, $l \in \mathbf{0}_\mathbb{L}$, and the logical state associated to $r$ inside of $g$ satisfies $P$. We also need to make sure that the interference assertion $I$, attached to region $r$, is satisfied by $\mathcal{J}(r)$, as described in the previous paragraph.

\begin{defn}
	\label{defn:interferenceSem}
	(Interference assertion semantics).
	The semantics of \emph{interference assertions}, $\tsem{-}^\textsc{i}_{r, e, \delta, \mathcal{J}} : \mathsf{IAssn} \times \mathsf{Rid} \times \mathsf{LEnv} \times \mathsf{PEnv} \times \mathsf{AMod} \rightarrow \mathsf{Rid} \overset{\text{fin}}{\rightharpoonup} \mathbb{K} \overset{\text{fin}}{\rightharpoonup} \mathcal{P}(\mathsf{Action})$, are defined as:
	\begin{align*}
		\tsem{\emptyset}^\textsc{i}_{r, e, \delta, \mathcal{J}}(r')(\kappa) &\triangleq \emptyset
		\\
		\tsem{\mathcal{K}: \exists \vec{y} \ldotp P \transto Q \cup I}^\textsc{i}_{r, e, \delta, \mathcal{J}}(r')(\kappa) &\triangleq
			\tsem{I}^\textsc{i}_{r, e, \delta, \mathcal{J}}(r')(\kappa)
			\cup 
			\begin{cases}
				\emptyset, & \text{if } r' \neq r
				\\
				(l_p, l_q), & \text{if } \exists g_p, g_q, e', \vec{v} \ldotp
				\kappa \in \tsem{\mathcal{K}}^\textsc{k}_e
				\\
				& \land g_p(r) = l_p \land g_q(r) = l_q
				\\
				& \land \forall r' \neq r \ldotp g_p(r') = g_q(r')
				\\
				& \land (l_p, g_p, \mathcal{J}), e', \delta \vDash P
				\\
				& \land (l_q, g_q, \mathcal{J}), e', \delta \vDash Q
				\\
				& \land e' = [\vec{y} \mapsto \vec{v}] 
			\end{cases}
	\end{align*}
\end{defn}

\begin{defn}
	(Assertion semantics).
	Assertion semantics are given with respect to a world $w \in \mathsf{World}$, a logical environment $e \in \mathsf{LEnv}$ and a predicate environment $\delta \in \mathsf{PEnv}$. They tell us whether a configuration $w, e, \delta$ satisfies a particular assertion.
	\begingroup
	\renewcommand*{\arraystretch}{1.5}
	\[
	\begin{array}{r c l}
		(l, g, \mathcal{J}), e, \delta \vDash p
		&
		\iff
		&
		l, e \vDash_\mathsf{SL} p
	\\
		(l, g, \mathcal{J}), e \vDash \boxed{P}_I^r
		&
		\iff
		&
		l \in \mathbf{0}_\mathsf{L} \text{ and } \exists l' \ldotp (l', g, \mathcal{J}), e, \delta \vDash P
		\\ && \text{and } \exists r' \ldotp r' = e(r) \land g(r') = l' \land \tsem{I}^\textsc{i}_{r, e, \delta, \mathcal{J}} \subseteq \mathcal{J}
	\\
		w, e, \delta \vDash \alpha(\mathds{E}_1, \ldots, \mathds{E}_n)
		&
		\iff
		&
		w \in \delta(\alpha, \tsem{\mathds{E}_1}_e^\textsc{e}, \ldots, \tsem{\mathds{E}_n}_e^\textsc{e})
	\\
		w, e, \delta \vDash \exists x \ldotp P
		&
		\iff
		&
		\exists v \ldotp w, e[x \mapsto v], \delta \vDash P
	\\
		w, e, \delta \vDash P \lor Q
		&
		\iff
		&
		w, e, \delta \vDash P \text{ or } w, e, \delta \vDash Q
	\\
		w, e, \delta \vDash P \sep Q
		&
		\iff
		&
		\exists w_1, w_2 \ldotp w = w_1 \bullet w_2 \text{ and } \\ && w_1, e \vDash P \text{ and } w_2, e \vDash Q
	\\
		l, e \vDash_\mathsf{SL} \mathtt{false}
		&&
		\text{never}
	\\
		l, e \vDash_\mathsf{SL}  \mathtt{emp}
		&
		\iff
		&
		l \in \mathbf{0}_\mathsf{L}
	\\
		l, e \vDash_\mathsf{SL} \mathcal{M}
		&
		\iff
		&
		\exists m, \rho \ldotp l = (m, \rho) \text{ and } m \in \tsem{\mathcal{M}}_e^\textsc{m} \text{ and } \rho \in \mathbf{0}_\mathsf{RK}
	\\
		l, e \vDash_\mathsf{SL} [\mathcal{K}]^r
		&
		\iff
		&
		\exists m, \kappa \ldotp l = (m, [r \mapsto \kappa]) \text{ and } \kappa \in \tsem{\mathcal{K}}_e^\textsc{k} \text{ and } m \in \mathbf{0}_\mathbb{M}
	\\
		l, e \vDash_\mathsf{SL} \lnot p
		&
		\iff
		&
		l, e \not\vDash_\mathsf{SL} p
	\\
		l, e \vDash_\mathsf{SL} p \sepimp q
		&
		\iff
		&
		\forall l' \ldotp l', e \vDash_\mathsf{SL} p \text{ implies } l \circ l', e \vDash_\mathsf{SL} q
	\\
		l, e \vDash_\mathsf{SL} p \sep q
		&
		\iff
		&
		\exists l_1, l_2 \ldotp l = l_1 \circ l_2 \text{ and } \\
		&& l_1, e \vDash_\mathsf{SL} p \text{ and } l_2, e \vDash_\mathsf{SL} q
	\\
		 l, e \vDash_\mathsf{SL} p \lor q
		 &
		 \iff
		 &
		 l, e \vDash_\mathsf{SL} p \text{ or } l, e \vDash_\mathsf{SL} q
	\\
		l, e \vDash_\mathsf{SL} \exists x \ldotp p
		&
		\iff
		&
		\exists v \ldotp l, e[x \mapsto v] \vDash_\mathsf{SL} p
	\end{array}
	\]
	\endgroup
\end{defn}
Now, given a logical environment $e \in \mathsf{LEnv}$ and a predicate environment $\delta \in \mathsf{PEnv}$, we write $\tsem{P}_e$ for the set of all worlds satisfying assertion $P$.
\[
	\tsem{P}_{e, \delta} \triangleq \{ w\ |\ w, e, \delta \vDash P \}
\]