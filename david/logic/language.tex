\subsection{Programming Language}
\label{language}

We present here a simple concurrent imperative programming language that supports transactions and is parametric with respect to its low-level commands. It is modelled after the \textsc{While} language and it is an instantiation of the language presented in the Views framework \cite{views}.

\begin{defn}
	(Variables).
	The set of \emph{variable} names is \textsf{Var} and it is ranged over by \texttt{x}, \texttt{y}, \texttt{a}, \texttt{b}, \ldots
\end{defn}

\begin{defn}
	(Numerical Expressions).
	The set of \emph{numerical expressions}, \textsf{Expr} is ranged over by $\mathds{E}, \mathds{E}_1, \ldots, \mathds{E}_n$. Numerical expressions are built from the following grammar, where $n \in \mathds{Z}, \mathtt{x} \in \mathsf{Var}$ and $x \in \mathsf{LVar}$.
	\[
		\mathds{E} ::=
			n\
			|\ \pvar{x}\
			|\ x\
			|\ \mathds{E}_1 + \mathds{E}_2\
			|\ \mathds{E}_1 - \mathds{E}_2\
			|\ \mathds{E}_1 \times \mathds{E}_2\
			|\ \mathds{E}_1 \div \mathds{E}_2
	\]
\end{defn}

\begin{defn}
	(Boolean Expressions).
	The set of primitive boolean values is defined as $\mathsf{Bool} \triangleq \{ \bot, \top \}$. The set of \emph{boolean expressions} is \textsf{BExpr} and it is ranged over by $\mathds{B}, \mathds{B}_1, \ldots, \mathds{B}_n$. Boolean expressions are generated from the following grammar:
	\[
		\mathds{B} ::=
			\true\
			|\ \false\
			|\ \mathds{B}_1 \land \mathds{B}_2\
			|\ \mathds{B}_1 \lor \mathds{B}_2\
			|\ \lnot \mathds{B}\
			|\ \mathds{E}_1 = \mathds{E}_2\
			|\ \mathds{E}_1 > \mathds{E}_2
	\]
\end{defn}

User instantiations of mCAP can specify the elementary commands of their language. These are the lowest-level building blocks on top of which we build sequential commands, transactions and later programs. One can see these as the standard variable assignment, memory dereference, etc in the separation logic world, but in reality, mCAP does not constraint them to be of a particular shape. It follows that a lot of flexibility is given in order to cover more context-specific language requirements.
\begin{param}
	\label{param:ecmd}
	(Elementary commands).
	Assume a set of elementary commands, \textsf{ECmd}, ranged over by $\hat{\mathds{C}}, \hat{\mathds{C}}_1, \ldots, \hat{\mathds{C}}_n$.
\end{param}

\begin{defn}
	(Sequential commands).
	\textsf{Cmd} is the set of \emph{sequential commands} which is ranged over by $\mathds{C}, \mathds{C}_1, \ldots, \mathds{C}_n$. Sequential commands are defined by the following grammar:
	\[
		\mathds{C} ::=
			\hat{\mathds{C}}\
			|\ \pskip\
			|\ \mathds{C}_1; \mathds{C}_2\
			|\ \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}\
			|\ \ploop{\mathds{B}}{\mathds{C}}
	\]
	Commands include the plain elementary commands provided by the framework user, the no-op skip action, sequential composition of commands, branching on a boolean condition and looping. Note that no paralellism is allowed as part of sequential commands. This follows from the fact that commands must appear as part of transactions and concurrent composition is only allowed at the level of programs.
\end{defn}

Every transaction that is executed as part of a program is associated with a unique identifier (e.g. a number or a timestamp).
\begin{param}
	(Transaction identifiers).
	 Assume a set of \emph{transaction identifiers}, \textsf{Tid}, ranged over by $\iota, i, j \ldots$ with an associated strict total order relation $<$, used to compare them.
\end{param}
We write a system transaction with identifier $\iota$ as $\mathds{T}_\iota$. It is now time to distinguish between client and system transactions. Given that our setup will require to identify a particular transaction in order to associate to it a variety of information, system transactions are associated to a particular identifier. This burden is not passed on to the user of the framework, since identifiers are only added at runtime and not while writing programs. For this reason, we first give a grammar for user transactions that allows clients not to explicitly specify the unique identifier associated with each of them. Next, we specify another grammar for the system ones that carry an identifier.

\begin{defn}
	(Transactions).
	The set of user transactions \textsf{UTrans} is ranged over by $\hat{\mathds{T}}$ and represents how transactions are written by clients of the language. They are defined as follows:
	\[
		\hat{\mathds{T}} ::=
			\mathtt{begin}\ \mathds{C}\ \mathtt{end}
	\]
	The set of system transactions \textsf{Trans} is ranged over by $\mathds{T}$ and defined using the following grammar, where $\iota \in \mathsf{Tid}$ is a transaction identifier.
	\[
		\mathds{T} ::=
			\hat{\mathds{T}}\
			|\ \mathtt{begin}\ \mathds{C}\ \mathtt{end}_\iota
	\]
\end{defn}
A transaction's body is defined as the command $\mathds{C}$ inside of the transaction $\ptdef{\mathds{C}}$ or $\ptdef{\mathds{C}}_\iota$.

Programs are the top-level construct of our programming language and are allowed to be instatiated as a single system transaction $\mathds{T}$, the sequential composition ($;$) of programs, their parallel composition through the use of the $\|$ operator, a non-deterministic choice $+$ between two programs and a nondeterministic loop of a program with $^*$.

\begin{defn}
	(Programs).
	Programs come from the set \textsf{Prog} which is ranged over by $\mathds{P}, \mathds{P}_1, \ldots, \mathds{P}_n$ and it is defined using the following grammar:
	\[
		\mathds{P} ::=
			\pskip\
			|\ \mathds{T}\
			|\ \mathds{P}^*\
			|\ \mathds{P}_1 + \mathds{P}_2\
			|\ \mathds{P}_1; \mathds{P}_2\
			|\ \mathds{P}_1 \| \mathds{P}_2
	\]
\end{defn}
It is assumed that the parallel composition operator, $\|$\ , is both commutative and associative. This peculiarity is justified by the way such operation is treated in the Views operational semantics for programs. The parallel composition of programs, $\mathds{P}_1 \| \mathds{P}_2$, is in fact seen as a nondeterministic one-step reduction in one of $\mathds{P}_1$ or $\mathds{P}_2$. Therefore, the nondeterministic aspect enables us to determine the commutativity and associativity properties of the operator.