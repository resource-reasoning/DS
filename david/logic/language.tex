\subsection{Programming Language}

We present here a simple concurrent imperative programming language that supports transactions. The latter is an instantiation of the language presented in the views framework \cite{views}.

\defn (Variables). Let \textsf{Var} be the set of all variable names which is ranged over by \texttt{x}, \texttt{y}, \texttt{a}, \texttt{b}, \ldots

\defn (Numerical Expressions). All numerical expressions have an integer value, come from the set \textsf{Expr} and are ranged over by $\mathds{E}, \mathds{E}_1, \ldots, \mathds{E}_n$. They are built from the following grammar where $n \in \mathds{Z}$ and $\mathtt{x} \in \mathsf{Var}$.
\[
	\mathds{E} ::=
		n\
		|\ \pvar{x}\
		|\ \mathds{E}_1 + \mathds{E}_2\
		|\ \mathds{E}_1 - \mathds{E}_2\
		|\ \mathds{E}_1 \times \mathds{E}_2\
		|\ \mathds{E}_1 \div \mathds{E}_2
\]

\defn (Boolean Expressions). We define the set of primitive boolean values as $\mathsf{Bool} \triangleq \{ \bot, \top \}$. Boolean expressions belong to the set \textsf{BExpr}, are ranged over by $\mathds{B}, \mathds{B}_1, \ldots, \mathds{B}_n$ and are generated from the following grammar.
\[
	\mathds{B} ::=
		\true\
		|\ \false\
		|\ \mathds{B}_1 \land \mathds{B}_2\
		|\ \mathds{B}_1 \lor \mathds{B}_2\
		|\ \lnot \mathds{B}\
		|\ \mathds{E}_1 = \mathds{E}_2\
		|\ \mathds{E}_1 > \mathds{E}_2
\]

\defn (Elementary commands). \textsf{ECmd} is the set of elementary commands ranged over by $\hat{\mathds{C}}, \hat{\mathds{C}}_1, \ldots, \hat{\mathds{C}}_n$ and expressed through the following grammar where $\pvar{x} \in \mathsf{Var}$.
\[
	\hat{\mathds{C}} ::=
		\passign{\pvar{x}}{\mathds{E}}\
		|\ \pderef{\pvar{x}}{\mathds{E}}\
		|\ \palloc{\pvar{x}}{\mathds{E}}\
		|\ \pmutate{\mathds{E}_1}{\mathds{E}_2}
\]
The commands allow variable assignment, memory dereference, mutation and allocation.

\defn (Sequential commands). \textsf{Cmd} is the set of sequential commands which are ranged over by $\mathds{C}, \mathds{C}_1, \ldots, \mathds{C}_n$. They are defined by the following grammar.
\[
	\mathds{C} ::=
		\hat{\mathds{C}}\
		|\ \pskip\
		|\ \mathds{C}_1; \mathds{C}_2\
		|\ \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}\
		|\ \ploop{\mathds{B}}{\mathds{C}}
\]
Commands include the no-op skip action, sequential composition, conditional branching and looping. Note that no paralellism is allowed as part of sequential commands.

\defn (Transaction identifier). Every transaction that is executed as part of a program is associated with a numerical identifier which is unique. The set of identifiers \textsf{Tid} is defined to be the set of positive integers $\mathds{Z}^+$. We denote a transaction with identifier $\iota$ as $\mathds{T}_\iota$.

\defn (Transactions). The set of user transactions \textsf{UTrans} is ranged over by $\hat{\mathds{T}}$ and represents how transactions are written by clients of the language. This allows clients not to explicitly specify the unique identifier associated with each transaction, which is instead required as part of system transactions. They are defined as follows.
\[
	\hat{\mathds{T}} ::=
		\mathtt{begin}\ \mathds{C}\ \mathtt{end}
\]
The set of system transactions \textsf{Trans} is ranged over by $\mathds{T}$ and defined using the following grammar, where $\iota \in \mathsf{Tid}$ is a transaction identifier. A transaction's body is defined as the command $\mathds{C}$ inside the grammar rules that follow.
\[
	\mathds{T} ::=
		\hat{\mathds{T}}\
		|\ \mathtt{begin}\ \mathds{C}\ \mathtt{end}_\iota
\]

\defn (Programs). Programs come from the set \textsf{Prog} which is ranged over by $\mathds{P}, \mathds{P}_1, \ldots, \mathds{P}_n$ and it is defined using the following grammar that allows the sequential composition ($;$) of transactions, their parallel composition through the use of the $\|$ operator, a non-deterministic choice $+$ between two programs and looping with $^*$.
\[
	\mathds{P} ::=
		\pskip\
		|\ \mathds{T}\
		|\ \mathds{P}^*\
		|\ \mathds{P}_1 + \mathds{P}_2\
		|\ \mathds{P}_1; \mathds{P}_2\
		|\ \mathds{P}_1 \| \mathds{P}_2
\]