\subsection{Operational Semantics}

The operational semantics of the programming language are defined in terms of concrete program states. Given the fact that we are defining an instantiation of the views framework, the operational semantics described here follow the structure defined in \cite{views} provided with the set of concrete states and the interpretation of transactions (i.e. atomic commands).

\defn (Concrete states). The set of concrete states $\mathcal{S}$ is defined to be equivalent to the $\mathsf{State}$ one. Thus we range over it using $h, h_1, \ldots, h_n$.

\defn (Elementary commands interpretation). \label{ecmdint} The interpretation function for elementary commands, formally $\tsem{-}_{\hat{\mathsf{C}}} : \mathsf{ECmd} \times \mathsf{Stack} \rightarrow \mathcal{S} \rightarrow \mathcal{P}(\mathcal{S} \times \mathsf{Stack})$, describes how elements of $\mathsf{ECmd}$ affect the concrete state and a transaction-local state. The function is defined in the following way.
\begin{align*}
	\tsem{\passign{\pvar{x}}{\mathds{E}}}_{\hat{\mathsf{C}}}(h, s) &\triangleq \{ (h, s[\pvar{x} \mapsto \tsem{\mathds{E}}_s]) \}
	\\
	\tsem{\palloc{\pvar{x}}{\mathds{E}}}_{\hat{\mathsf{C}}}(h, s) &\triangleq
		\begin{cases}
			\{ (h[\vec{a} \mapsto \vec{z}], s)
			&
			\text{if } n = \tsem{\mathds{E}}_s \text{ and } n > 0 \text{ and } l \in \mathsf{Key} \\
			|\ \forall 0 \leq i < n \ldotp \vec{z}_i = 0 \}, & \text{and } \vec{a} = (l, \ldots, l + n - 1) \text{ and } \\
			& \{ l, \ldots, l + n - 1 \} \cap \pred{dom}{h} \equiv \emptyset \\
			\{(\emptyset, s)\}, & \text{if } n = \tsem{\mathds{E}}_s \text{ and } n > 0 \text{ and } l \in \mathsf{Key} \\ & \text{and } \{ l, \ldots, l + n - 1 \} \cap \pred{dom}{h} \not\equiv \emptyset \\
			& \text{or } n > 0 \text{ and } l \not\in \mathsf{Key} \\
			\{ (\lightning, s) \}, & \text{otherwise}
		\end{cases}
	\\
	\tsem{\pderef{\pvar{x}}{\mathds{E}}}_{\hat{\mathsf{C}}}(h, s) &\triangleq
		\begin{cases}
			\{ (h, s[\pvar{x} \mapsto v]) \}, & \text{if } k = \tsem{\mathds{E}}_s \text{ and } k \in \pred{dom}{h} \text{ and } h(k) = v \\
			\{ (\emptyset, s) \}, & \text{if } k = \tsem{\mathds{E}}_s \text{ and } k \in \pred{dom}{h} \text{ and } h(k) \neq v \\
			\{ (\lightning, s) \}, & \text{otherwise}
		\end{cases}
	\\
	\tsem{\pmutate{\mathds{E}_1}{\mathds{E}_2}}_{\hat{\mathsf{C}}}(h, s) &\triangleq
	\begin{cases}
		\{ (h[k \mapsto v] \}, s) \}, & \text{if } k = \tsem{\mathds{E}_1}_s \text{ and } v = \tsem{\mathds{E}_2}_s \text{ and } k \in \pred{dom}{h} \\
		\{ (\lightning, s) \}, & \text{otherwise}
	\end{cases}
\end{align*}
A variable assignment to $\pvar{x}$ only updates the local variable stack to map variable $\pvar{x}$ to the evaluated expression $\mathds{E}$ under $s$, leaving the heap component unmodified. A memory allocation succeeds when it is possible to expand the current heap $h$ to hold a sequence of $n$ cells that are currently not in its domain. In all other cases, the command fails. A memory dereference succeeds in reading a value $v$ associated to key $k$ only when $k$ is in the heap's domain and the value mapped to it is effectively $v$. Last, we can mutate memory at location $k$ only when it is part of the domain of the heap $h$.

We also lift the interpretation function to a set of concrete state such that for $H \in \mathcal{P}(\mathcal{S})$:
\[
	\tsem{\hat{\mathds{C}}}_{\hat{\mathsf{C}}}(H, s) \triangleq \bigcup_{h \in H} \tsem{\hat{\mathds{C}}}_{\hat{\mathsf{C}}}(h, s)
\]

\defn (Commands interpretation). The interpretation function for elementary commands, formally $\tsem{-}^s_{\mathsf{C}} : \mathsf{Cmd} \times \mathsf{Stack} \rightarrow \mathcal{S} \rightarrow \mathcal{P}(\mathcal{S} \times \mathsf{Stack})$, is defined as:
\begin{align*}
	\tsem{\hat{\mathds{C}}}_{\mathsf{C}}(h, s) &\triangleq \tsem{\hat{\mathds{C}}}_{\hat{\mathsf{C}}}(h, s)
	\\
	\tsem{\pskip}_{\mathsf{C}}(h, s) &\triangleq \{(h, s)\}
	\\
	\tsem{\mathds{C}_1 ; \mathds{C}_2}_{\mathsf{C}}(h, s) &\triangleq \{ (h', s')\ |\ S = \tsem{\mathds{C}_1}_\mathsf{C}(h, s) \land (h', s') \in \tsem{\mathds{C}_2}_\mathsf{C}(S) \}
	\\
	\tsem{\pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}}^s_\mathsf{C}(h, s) &\triangleq \mathbf{if}\ \tsem{\mathds{B}}^\textsc{b}_s\ \mathbf{then}\ \tsem{\mathds{C}_1}_\mathsf{C}(h, s)\ \mathbf{else}\ \tsem{\mathds{C}_2}_\mathsf{C}(h, s)
	\\
	\tsem{\ploop{\mathds{B}}{\mathds{C}}}^s_\mathsf{C}(h, s) &\triangleq \tsem{\pif{\mathds{B}}{\left(\mathds{C};\ploop{\mathds{B}}{\mathds{C}}\right)}{\pskip}}_\mathsf{C}^s(h, s)
\end{align*}
In the case of an elementary command, we simply use Definition \ref{ecmdint} while the interpretation of $\pskip$ is the identity function on both the heap and the local stack components. The effect of a sequential composition of two commands is defined as the set of all states arising from the execution of the first command, followed by the second command applied to the resulting states. Loops are rewritten as conditionals, where the if body contains the loop body composed with the same loop. If statements are instead applied to a state by branching on the boolean condition, semantically evaluated under $s$.

We also lift the interpretation function to a set of concrete state such that for $H \in \mathcal{P}(\mathcal{S})$:
\[
	\tsem{\mathds{C}}_\mathsf{C}(H, s) \triangleq \bigcup_{h \in H}  \tsem{\mathds{C}}_\mathsf{C}(h, s)
\]	

\defn (Transactions interpretation). Finally, we can provide the interpretation function for transactions, which is formally defined as $\tsem{-}_\mathsf{T} : \mathsf{Atom} \rightarrow \mathcal{S} \rightarrow \mathcal{P}(\mathcal{S})$,
\[
	\tsem{\ptdef{\mathds{C}}_\iota}_\mathsf{T}(h) \triangleq \{ h'\ |\ \exists s' \ldotp (h', s') = \tsem{\mathds{C}}_\mathsf{C}(h, \emptyset) \}
\]
Therefore, the semantic meaning of running an atomic transaction on the concrete state $h$, is any resulting state $h'$ that results from executing the transaction's body $\mathds{C}$, starting with the same state $h$ and an empty local stack.

We also lift the interpretation function to a set of concrete state such that for $H \in \mathcal{P}(\mathcal{S})$:
\[
	\tsem{\mathds{T}}_\mathsf{T}(H) \triangleq \bigcup_{h \in H}  \tsem{\mathds{T}}_\mathsf{T}(h)
\]	