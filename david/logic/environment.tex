\subsection{Environment Semantics}

The rely relation models how the environment, i.e. other running threads, can reorganize or modify a world. All these behaviours are depicted as \textit{interference} from the environment and they can be divided into two kinds: region construction and region update. Before we move on, it is important to state what it means for a region identifier to be fresh inside of a world, as such definition will be used throughout the section.

\defn (Region freshness). A region identifier $r$ is fresh with respect to a world $w = (l, g, \mathcal{J})$, when $r$ does not appear as part of $w$'s local or global state, action model's domain or in any of the capabilities that are used inside of $g$ or $\mathcal{J}$'s actions.
\[
\begin{array}{r l}
	\pred{fresh}{r, (l, g, \mathcal{J})} \iff
	&
	r \not\in \pred{dom}{g} \cup \pred{dom}{\mathcal{J}} \cup \pred{dom}{l_\mathsf{K}} \cup \left( \bigcup_{r' \in \pred{dom}{g}} \pred{dom}{g(r')_\mathsf{K}} \right)
	\\
	& \cup \left( \bigcup_{r \in \pred{dom}{\mathcal{J}}} \bigcup_{(l_1, l_2) \in \pred{ran}{\mathcal{J}(r)}} \pred{dom}{(l_1)_\mathsf{K}} \cup \pred{dom}{(l_2)_\mathsf{K}} \right)
\end{array}	
\]

\defn (Rely region construction). The rely construction relation $R^c$ between worlds, models how the environment can create a new region out of existing resources in its own logical local state.
\[
\begin{array}{r | l}
	R^c \triangleq \bigg\{ (w, w')
	&
	\begin{array}{r}
		\exists r, l, a \ldotp \pred{fresh}{r, w} \land w'_\mathsf{L} = w_\mathsf{L} \land w'_\mathsf{S} = w_\mathsf{S}[r \mapsto l] \land
		\\
		w'_\mathsf{L} \circ w'_\mathsf{S} \text{ defined} \land w'_\mathsf{A} = w_\mathsf{A}[r \mapsto a] \land (w'_\mathsf{L})_\mathsf{K}(r) = \mathbf{0}_\mathbb{K}
	\end{array}
	\bigg\}
\end{array}
\]
The created region must have a fresh identifier $r$, used to map the new shared resources inside of the global state and the allowed actions in the action model. The updated world's local state $w'_\mathsf{L}$, as seen by a thread, will obviously be unmodified given that the environment cannot touch it. This adds the requirement of $w'_\mathsf{L} \circ w'_\mathsf{S}$ being defined. On top of this, the new local state cannot contain any capability for the region that has just been constructed.

\defn (Rely region update). The rely update relation $R^u$ between worlds, models how the environment can modify an already existing region inside the global state.
\[
	R^u \triangleq \{ \left( (l, g, \mathcal{J}), (l, g', \mathcal{J}) \right)\ |\ \exists r, \kappa \ldotp  \kappa\ \sharp\ (l \circ g)_\mathsf{K}(r) \land (g, g') \in \lceil \mathcal{J}(r) \rceil (\kappa) \}
\]
An update done by the environment is only allowed to modify the shared state $g$, while the local state $l$ and action model $\mathcal{J}$ stay the same. The actual region update is only allowed when the environment utilizes a capability $\kappa$ that is compatible with all of the capabilities in the current local and shared states. Moreover, $\kappa$ needs to enable the shared state transition as described by $\mathcal{J}(r)$. Since we allow actions to only describe a part of the region they are modifying, and not the entirety of it, we introduce and use the $\lceil - \rceil : \left( \mathbb{K} \rightarrow \mathcal{P}(\mathsf{Action}) \right) \times \mathbb{K} \rightarrow \mathcal{P}(\mathsf{Action})$ operator.
\[
	\lceil a \rceil (\kappa) \triangleq \{ (p \circ f, q \circ f)\ |\ (p, q) \in a(\kappa) \land f \in \mathsf{LState} \}
\]
This way, all of the region resources that are not affected by the update, i.e. $f$, will stay the same in the resulting world.

\defn (Rely relation). We now have all of the ingredients to define the overall rely relation between worlds, namely $R$.
\[
	R \triangleq (R^c \cup R^u)^*
\]
The transitive closure allows the environment to perform multiple updates and region constructions in one single atomic step, as seen by a thread. This definition is different from CAP's one, since the latter only allowed one single update and multiple constructions.

\defn (Stability). An assertion $P$ is said to be stable, $\pred{stable}{P}$, if, for all $e \in \mathsf{LEnv}, \delta \in \mathsf{PEnv}$ and $w, w' \in \mathsf{World}$, if $w, e, \delta \vDash P$ and $(w, w') \in R$, then $w', e, \delta \vDash P$. Intuitively, we require the stability property as we need to be sure that for any given assertion $P$ which is currently satisfiable, a rely step done by the environment is not going to invalidate it.

\defn (Predicate environment stability). A predicate environment $\delta$ is said to be stable, $\pred{pstable}{\delta}$, if, for all $W \in \pred{ran}{\delta}$, for all $w, w' \in \mathsf{World}$, if $w \in W$ and $(w, w') \in R$, then $w' \in W$.

We define the semantics of a syntactic predicate environment $\Delta \in \mathsf{Ax}$ as a set of stable predicate environments that satisfy them.
\begin{align*}
	\tsem{\emptyset}^\textsc{p} &\triangleq \{ \delta\ |\ \pred{pstable}{\delta} \} \\
	\tsem{\forall \vec{x} \ldotp P \implies Q}^\textsc{p} &\triangleq \{ \delta\ |\ \pred{pstable}{\delta} \land \forall \vec{v} \ldotp \tsem{P}_{\emptyset[\vec{x} \mapsto \vec{v}], \delta} \subseteq \tsem{Q}_{\emptyset[\vec{x} \mapsto \vec{v}], \delta} \} \\
	\tsem{\forall \vec{x} \ldotp \alpha(\vec{x}) \equiv P}^\textsc{p} &\triangleq \{ \delta\ |\ \pred{pstable}{\delta} \land \forall \vec{v} \ldotp \delta(\alpha, \vec{v}) = \tsem{P}_{\emptyset[\vec{x} \mapsto \vec{v}], \delta} \} \\
	\tsem{\Delta_1, \Delta_2}^\textsc{p} &\triangleq \tsem{\Delta_1}^\textsc{p} \cap \tsem{\Delta_2}^\textsc{p}
\end{align*}

\defn (Guarantee region construction). The guarantee construction relation $G^c$ between worlds, models how a thread can create a new region using currently owned resources in its local state. On the other hand, we leave region destruction as implicit, i.e. the user can encode it as a special action in the action model associated to the region, which gets rid of everything inside of it.
\[
\begin{array}{r | l}
	G^c \triangleq \Bigg\{ (w, w')
	&
	\begin{array}{c}
		\exists r, m, l, a, \rho, \rho' \ldotp \pred{fresh}{r, w} \land \pred{dom}{\rho'} = \{r\} \land
		\\
		w_\mathsf{L} = (m, \rho) \circ l \land w'_\mathsf{L} = l \circ (\mathbf{0}_\mathbb{M}, \rho') \land
		\\
		w'_\mathsf{S} = w_\mathsf{S}[r \mapsto (m, \rho) ] \land w'_\mathsf{A} = w_\mathsf{A}[r \mapsto a]
	\end{array}
	\Bigg\}
\end{array}
\]
As we can see from the definition, a thread is allowed to create a region as long as its identifier $r$ is entirely fresh and the new shared state includes a part of its local state that is moved out of it. In exchange, $w'_\mathsf{L}$ will include capabilities for the new region. The action model is accordingly updated to describe the actions allowed on $r$.

\defn (Guarantee region update). The guarantee update relation $G^u$ between worlds, models how a thread can modify an existing region in the shared state, for which it holds some capabilities.
\[
\begin{array}{r | l}
	G^u \triangleq \Bigg\{ ((l, g, \mathcal{J}), (l', g', \mathcal{J}))
	&
	\begin{array}{c}
		((l \circ g)_\mathsf{K})_\mathbb{K}^\bot = ((l' \circ g')_\mathsf{K})_\mathbb{K}^\bot \land \\
		(g = g' \lor \exists r, \kappa \leq l_\mathsf{K}(r) \ldotp (g, g') \in \lceil \mathcal{J}(r) \rceil(\kappa)  \\ \land ((l \circ g)_\mathsf{M})_\mathbb{M}^\bot = ((l' \circ g')_\mathsf{M})_\mathbb{M}^\bot )
	\end{array}
	\Bigg\}
\end{array}
\]
A guarantee update enables a thread to change $l$ and $g$, leaving the action model $\mathcal{J}$ unmodified. During the update, a thread cannot introduce new capabilities as part of its local state or the global shared one. This requirement is enforced by checking that the orthogonal of all capabilities stays the same as part of the transition to $l', g'$. The update can further leave the global state unmodified (thus only performing a local change) or it is entitled to modify it through an action, as long as the running thread holds an appropriate capability in its local state. As part of an update, there can be a transfer of resources from the local to the shared state together with their mutation. Since we do not want to enable \textit{fictitious} resource creation, we require the guarantee relation to preserve the orthogonal of the local and global machine state's composition.

\defn (Guarantee relation). Finally we can define the overall guarantee relation between worlds, $G$.
\[
	G \triangleq (G^c \cup G^u)^*
\]
As for the rely relation, the definition uses a transitive closure to allow multiple region creations and updates as part of a single step done by a thread. \\

\defn (Repartitioning). At this point we are enabled to explain the fundamental notion of repartitioning with respect to an update from $p$ to $q$, written $P \Rrightarrow^{\{p\}\{q\}} Q$ \cite{cap}. The latter indicates that any world $w_1$ satisfying the assertion $P$ has a machine-state component $(w_1)_\mathsf{M}$ that includes a part, $m_1$, which satisfies the separation logic assertion $p$. Moreover, when $m_1$ is replaced by $m_2$ that satisfies $q$, we are able to reconstruct a world $w_2$ that satisfies $Q$ and for which the transition from $w_1$ to $w_2$ is allowed by the guarantee $G$.

Formally $P \Rrightarrow^{\{p\}\{q\}} Q$ holds iff, for every logical environment $e \in \mathsf{LEnv}$, and world $w_1 = (l_1, g_1, \mathcal{J}_1) \in \mathsf{World}$ such that $w_1, e \vDash P$, there exist states $m_1, m' \in \mathbb{M}$, such that:
\begin{itemize}
\item $(m_1, \emptyset), e \vDash_\mathsf{SL} p$ and
\item $m_1 \bullet_\mathbb{M} m' = (l_1 \circ g_1)_\mathsf{M}$ and
\item for every $m_2 \in \mathbb{M}$ where $(m_2, \emptyset), e \vDash_\mathsf{SL} q$, there exists a world $w_2 = (l_2, g_2, \mathcal{J}_2) \in \mathsf{World}$ such that $w_2, e \vDash Q$ and
	\begin{itemize}
		\item $m_2 \bullet_\mathbb{M} m' = (l_2 \circ g_2)_\mathsf{M}$
		\item $(w_1, w_2) \in G$
	\end{itemize}
\end{itemize}

We write $P \Rrightarrow Q$ in order to express $P \Rrightarrow^{\{\mathtt{emp}\}\{\mathtt{emp}\}}Q$. The latter allows the shared state to be reorganized around but not to be mutated.
