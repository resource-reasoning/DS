\subsection{Proof System}

The proof system that we illustrate here is for the programming language described in Section \ref{language} and it is also an instantiation of the views framework \cite{views}. We start by providing axioms for elementary commands, sequential commands and later transactions.

\begin{param}
	(Elementary command axioms).
	Given the pcm for machine states $(\mathbb{M}, \bullet_\mathbb{M}, \mathbf{0}_\mathbb{M})$, assume a set of \emph{elementary command axioms}, $\textsc{Ax}_{\hat{\mathsf{C}}} : \mathcal{P}(\mathbb{M}) \times \mathsf{Cmd} \times \mathcal{P}(\mathbb{M})$.
\end{param}

\begin{param}
	\label{param:boolMachine}
	(Boolean machine state semantics).
	Given the pcm for machine states $(\mathbb{M}, \bullet_\mathbb{M}, \mathbf{0}_\mathbb{M})$, assume a \emph{boolean semantics} function for machine states:
	\[
		\tsem{-}^\textsc{b}_- : \mathds{B} \times \mathbb{M} \rightarrow \mathsf{Bool}
	\]
\end{param}

\begin{defn}
	(Sequential command axioms).
	Given the axiomatisation of elementary commands $\textsc{Ax}_{\hat{\mathsf{C}}}$, the axioms of sequential commands, $\textsc{Ax}_\mathsf{C} : \mathcal{P}(\mathbb{M}) \times \mathsf{Cmd} \times \mathcal{P}(\mathbb{M})$, are defined in the following way:
	\begin{align*}
		\textsc{Ax}_\mathsf{C} &\triangleq \textsc{Ax}_{\hat{\mathsf{C}}} \cup \textsc{Ax}_{\textsc{skip}} \cup \textsc{Ax}_{\textsc{seq}} \cup \textsc{Ax}_{\textsc{cond}} \cup \textsc{Ax}_{\textsc{loop}}
		\\
		\textsc{Ax}_{\textsc{skip}} &\triangleq \{ (M, \pskip, M)\ |\ M \in \mathcal{P}(\mathbb{M}) \}
		\\
		\textsc{Ax}_{\textsc{seq}} &\triangleq \{ (M, \mathds{C}_1 ; \mathds{C}_2, M')\ |\ (M, \mathds{C}_1, M'') \in \textsc{Ax}_\mathsf{C} \land (M'', \mathds{C}_2, M') \in \textsc{Ax}_\mathsf{C} \}
		\\
		\textsc{Ax}_{\textsc{cond}}
			&\triangleq \{ 
				(M, \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}, M')\ 
					|\
				\left( \forall m_t \in M \ldotp \tsem{\mathds{B}}^\textsc{b}_{m_t} = \top \land (M, \mathds{C}_1, M') \in \textsc{Ax}_\mathsf{C} \right) \\ &\lor \left( \forall m_f \in M \ldotp \tsem{\mathds{B}}^\textsc{b}_{m_f} = \bot \land (M, \mathds{C}_2, M') \in \textsc{Ax}_\mathsf{C} \right)
			\}
		\\
		\textsc{Ax}_{\textsc{loop}}
			&\triangleq
				\{
					(M, \ploop{\mathds{B}}{\mathds{C}}, M)\
						|\
					\forall m \in M \ldotp \tsem{\mathds{B}}^\textsc{b}_{m} = \bot
				\}
				\\ &\ \ \ \ \cup
				\{ 
					(M, \ploop{\mathds{B}}{\mathds{C}}, M)\
						|\
					\exists M' \ldotp M' \subseteq M \land \forall m \in M' \ldotp \tsem{\mathds{B}}^\textsc{b}_{m} = \top \land (M', \mathds{C}, M) \in \textsc{Ax}_\mathsf{C}
				\}
	\end{align*}
	where $M, M'$ and $M''$ are used to quantify over elements of $\mathcal{P}(\mathbb{M})$.
\end{defn}

\begin{defn}
	(Transaction axioms).
	Given the axiomatisation of sequential commands $\textsc{Ax}_\mathsf{C}$, we define the set of transactions axioms, $\textsc{Ax}_\mathsf{T} : \mathcal{P}(\mathsf{World}) \times \mathsf{Trans} \times \mathcal{P}(\mathsf{World})$ as:
	\[
		\textsc{Ax}_\mathsf{T}
			\triangleq
		\big\{ (W, \ptdef{\mathds{C}}, W')\ |\ (M_1, \mathds{C}, M_2) \in \textsc{Ax}_\mathsf{C} \land W \Rrightarrow^{\{M_1\}\{M_2\}} W' \big\}
	\]
	where $W$ and $W'$ are used to quantify over elements of $\mathcal{P}(\mathsf{World})$.
\end{defn}

\defn (Proof rules). All proof rules that follow, carry the implicit assumption that the preconditions and postconditions of their judgements are stable with respect to the environment.
\begin{gather*}
\begin{array}{c c}
	\infer[\textsc{Skip}]
	{
		\Delta \vdash \triple{P}{\pskip}{P}
	}
	{}
&
	\infer[\textsc{Trans}]
	{
		\Delta \vdash \triple{P}{\mathds{T}}{Q}
	}
	{
		\forall e, \delta \ldotp (\tsem{P}_{e, \delta}, \mathds{T}, \tsem{Q}_{e, \delta}) \in \textsc{Ax}_\mathsf{T}
	}
\end{array}
\\ \\
\begin{array}{c c}
	\infer[\textsc{Seq}]
	{
		\Delta \vdash \triple{P}{\mathds{P}_1 ; \mathds{P}_2}{Q}
	}
	{
		\Delta \vdash \triple{P}{\mathds{P}_1}{R}
		&
		\Delta \vdash \triple{R}{\mathds{P}_2}{Q}	
	}
&
	\infer[\textsc{Choice}]
	{
		\Delta \vdash \triple{P}{\mathds{P}_1 + \mathds{P}_2}{Q}	
	}
	{
		\Delta \vdash \triple{P}{\mathds{P}_1}{Q}
		&
		\Delta \vdash \triple{P}{\mathds{P}_2}{Q}
	}
\end{array}
\\ \\
\begin{array}{c c}
	\infer[\textsc{Frame}]
	{
		\Delta \vdash \triple{P \sep R}{\mathds{P}}{Q \sep R}	
	}
	{
		\Delta \vdash \triple{P}{\mathds{P}}{Q}
	}
&
	\infer[\textsc{Conseq}]
	{
		\Delta \vdash \triple{P}{\mathds{P}}{Q}	
	}
	{
		\Delta \vdash P \Rrightarrow P'
		&
		\Delta \vdash \triple{P'}{\mathds{P}}{Q'}
		&
		\Delta \vdash Q' \Rrightarrow Q	
	}
\end{array}
\\ \\
\begin{array}{c c}
	\infer[\textsc{Par}]
	{
		\Delta \vdash \triple{P_1 \sep P_2}{\mathds{P}_1 \| \mathds{P}_2}{Q_1 \sep Q_2}	
	}
	{
		\Delta \vdash \triple{P_1}{\mathds{P}_1}{Q_1}
		&
		\Delta \vdash \triple{P_2}{\mathds{P}_2}{Q_2}	
	}
&
	\infer[\textsc{Loop}]
	{
		\Delta \vdash \triple{P}{\mathds{P}^*}{P}	
	}
	{
		\Delta \vdash \triple{P}{\mathds{P}}{P}
	}
\end{array}
\\ \\
	\infer[\textsc{Pred-I}]
	{
		\Delta \vdash \triple{P}{\mathds{P}}{Q}
	}
	{
		\tsem{\Delta}^\textsc{p} \subseteq \tsem{\Delta'}^\textsc{p}
		&
		\Delta' \vdash \triple{P}{\mathds{P}}{Q}
	}
\\ \\
	\infer[\textsc{Pred-E}]
	{
		\Delta \vdash \triple{P}{\mathds{P}}{Q}
	}
	{
		\forall \delta \in \tsem{\Delta}^\textsc{p} \ldotp \mathsf{stable}_\delta(R)
		&
		\alpha \not\in \Delta, P, Q
		&
		\Delta, (\forall \vec{x} \ldotp \alpha(\vec{x}) \equiv R) \vdash \triple{P}{\mathds{P}}{Q}
	}
\end{gather*}

Most of the rules are standard from disjoint concurrent separation logic \cite{csl}, with the exception of rules \textsc{Pred-I} and \textsc{Pred-E} which are instead derived from CAP \cite{cap}. The first one is used to weaken the assumptions about the predicate definitions, since if we are able to prove a triple with assumptions $\Delta'$ then it must be the case that we can prove the same triple under stronger assumptions $\Delta$. On the other hand, the \textsc{Pred-E} proof rule allows the introduction of a new predicate definition. In order to do so, the new predicate must be stable with respect to the environment and its name must not be in the existing definitions or the triple's assertions. As part of the \textsc{Conseq} rule, we use the repartitioning operator as presented in Definition \ref{repartitioning} instead of the classic implication arrow $\implies$. Given that the proof rules related to predicates, namely \textsc{Pred-I} and \textsc{Pred-E}, are not part of the ones included in the views framework, we show that they are sound in Lemma \ref{lem:pred-i} and Lemma \ref{lem:pred-e} respectively.