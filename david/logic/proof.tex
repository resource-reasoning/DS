\subsection{Proof System}

The proof system that we illustrate here is for the programming language described in Section \ref{language} and it is also an instantiation of the views framework \cite{views}. We start by parametrizing axioms for elementary commands, and later define the ones for sequential commands and transactions.

As a consequence of leaving elementary commands as a parameter to the user, we also require the provision of axioms for them. These build a relationship between sets of machine states, once affected by a particular command.
\begin{param}
	\label{param:ecmdAx}
	(Elementary command axioms).
	Given the pcm for machine states $(\mathbb{M}, \bullet_\mathbb{M}, \mathbf{0}_\mathbb{M})$, assume a set of \emph{elementary command axioms}, $\textsc{Ax}_{\hat{\mathsf{C}}} : \mathcal{P}(\mathbb{M}) \times \mathsf{ECmd} \times \mathcal{P}(\mathbb{M})$.
\end{param}

A function for the semantic evaluation of boolean expressions under a given machine state is necessary to later build axioms for sequential commands. We must remember that the programming language defined in Section \ref{language} allows boolean conditions to appear both as part of if-statements and of while loops, and the corresponding axioms will depend on how such conditions are evaluated.
\begin{param}
	\label{param:boolMachine}
	(Boolean machine state semantics).
	Given the pcm for machine states $(\mathbb{M}, \bullet_\mathbb{M}, \mathbf{0}_\mathbb{M})$, assume a \emph{boolean semantics} function for machine states:
	\[
		\tsem{-}^\textsc{b}_- : \mathds{B} \times \mathbb{M} \rightarrow \mathsf{Bool}
	\]
\end{param}

\begin{defn}
	(Sequential command axioms).
	Given the axiomatisation of elementary commands $\textsc{Ax}_{\hat{\mathsf{C}}}$, the \emph{sequential command axioms}, $\textsc{Ax}_\mathsf{C} : \mathcal{P}(\mathbb{M}) \times \mathsf{Cmd} \times \mathcal{P}(\mathbb{M})$, are defined in the following way:
	\begin{align*}
		\textsc{Ax}_\mathsf{C} &\triangleq \textsc{Ax}_{\hat{\mathsf{C}}} \cup \textsc{Ax}_{\textsc{skip}} \cup \textsc{Ax}_{\textsc{seq}} \cup \textsc{Ax}_{\textsc{cond}} \cup \textsc{Ax}_{\textsc{loop}}
		\\[0.7em]
		\textsc{Ax}_{\textsc{skip}} &\triangleq \{ (M, \pskip, M)\ |\ M \in \mathcal{P}(\mathbb{M}) \}
		\\[0.7em]
		\textsc{Ax}_{\textsc{seq}} &\triangleq \{ (M, \mathds{C}_1 ; \mathds{C}_2, M')\ |\ (M, \mathds{C}_1, M'') \in \textsc{Ax}_\mathsf{C} \land (M'', \mathds{C}_2, M') \in \textsc{Ax}_\mathsf{C} \}
		\\[0.7em]
		\textsc{Ax}_{\textsc{cond}}
			&\triangleq \left\{ 
				\begin{array}{r | l}
					(M, \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}, M')\ 
					&
					\begin{array}{c}
						\forall m_t \in M \ldotp \tsem{\mathds{B}}^\textsc{b}_{m_t} = \top \land (M, \mathds{C}_1, M') \in \textsc{Ax}_\mathsf{C}
						\\
						\lor
						\\
						\forall m_f \in M \ldotp \tsem{\mathds{B}}^\textsc{b}_{m_f} = \bot \land (M, \mathds{C}_2, M') \in \textsc{Ax}_\mathsf{C}
					\end{array}
				\end{array}
			\right\}
		\\[0.7em]
		\textsc{Ax}_{\textsc{loop}}
			&\triangleq
				\left\{
				\begin{array}{r | l}
					(M, \ploop{\mathds{B}}{\mathds{C}}, M)
					&
					\begin{array}{c}
						\forall m \in M \ldotp \tsem{\mathds{B}}^\textsc{b}_{m} = \bot
						\\
						\lor
						\\
						\exists M' \ldotp M' \subseteq M \land \forall m \in M' \ldotp \tsem{\mathds{B}}^\textsc{b}_{m} = \top \\
						\land\ (M', \mathds{C}, M) \in \textsc{Ax}_\mathsf{C}
					\end{array}
				\end{array}	 
				\right\}
	\end{align*}
	where $M, M'$ and $M''$ are used to quantify over elements of $\mathcal{P}(\mathbb{M})$.
\end{defn}
Axioms for sequential commands relate machine states sets and are obtained by combining together axioms for every possible type of commands. In the case of an elementary command, we use the set provided as part of Parameter \ref{param:ecmdAx}, while for $\pskip$ any state in $\mathbb{M}$ is accepted and left untouched. As expected, axioms for sequential composition of two commands, $\mathds{C}_1 ; \mathds{C}_2$, are defined as the pair of sets of states $M, M'$ where $M, M''$ and $M'', M'$ are in the axioms for commands $\mathds{C}_1$ and $\mathds{C}_2$ respectively. On the other hand, in the occurrence of an if-statement with a condition $\mathds{B}$, we find the sets $M$ and $M'$ by considering the case where either all the states in $M$ evaluate $\mathds{B}$ as $\top$, i.e. true, and therefore $M'$ will be part of the axiom for $\mathds{C}_1$, or they evaluate the condition as $\bot$ and $M'$ is such that $(M, \mathds{C}_2, M') \in \textsc{Ax}_\mathsf{C}$. Finally, axioms for the while loop command are of the form $(M, \ploop{\mathds{B}}{\mathds{C}}, M)$ where either $\mathds{B}$ is semantically evaluated to false by all states in $M$, thus modelling an end of loop situation, or there is a subset of machine states $M'$ which makes $\mathds{B}$ true and the same states are in an axiom for $\mathds{C}$ of the shape $(M', \mathds{C}, M)$.

\begin{defn}
	\label{defn:transAx}
	(Transaction axioms).
	Given the axiomatisation of sequential commands $\textsc{Ax}_\mathsf{C}$, the set of \emph{transaction axioms}, $\textsc{Ax}_\mathsf{T} : \mathcal{P}(\mathsf{World}) \times \mathsf{Trans} \times \mathcal{P}(\mathsf{World})$, is defined as:
	\[
		\textsc{Ax}_\mathsf{T}
			\triangleq
		\big\{ (W, \ptdef{\mathds{C}}, W')\ |\ (M_1, \mathds{C}, M_2) \in \textsc{Ax}_\mathsf{C} \land W \Rrightarrow^{\{M_1\}\{M_2\}} W' \big\}
	\]
	where $W$ and $W'$ are used to quantify over elements of $\mathcal{P}(\mathsf{World})$.
\end{defn}
Notice how the axioms for transactions make use of the axioms for their body $\mathds{C}$ to obtain the sets of machine state satisfying $\mathds{C}$'s pre- and post-conditions. These two are then used as arguments to perform a repartitioning from worlds in $W$ to the ones in $W'$. This particular relation enables us to cover all possible axioms for transactions.

At this point, once we have succesfully defined axioms for transactions, we can list all of the proof rules that support programs.

\begin{defn}
	(Proof rules).
	All proof rules that follow, carry the implicit assumption that the preconditions and postconditions of their judgements are stable with respect to the environment.
	\begin{gather*}
	\begin{array}{c c}
		\infer[\textsc{Skip}]
		{
			\Delta \vdash \triple{P}{\pskip}{P}
		}
		{}
	&
		\infer[\textsc{Trans}]
		{
			\Delta \vdash \triple{P}{\mathds{T}}{Q}
		}
		{
			\vdash_{\mathsf{SL}} \triple{p}{\mathds{T}}{q} &
			P \Rrightarrow^{\{p\}\{q\}} Q
		}
	\end{array}
	\\ \\
	\begin{array}{@{\hspace*{-17pt}}c c}
		\infer[\textsc{Seq}]
		{
			\Delta \vdash \triple{P}{\mathds{P}_1 ; \mathds{P}_2}{Q}
		}
		{
			\Delta \vdash \triple{P}{\mathds{P}_1}{R}
			&
			\Delta \vdash \triple{R}{\mathds{P}_2}{Q}	
		}
	&
		\infer[\textsc{Choice}]
		{
			\Delta \vdash \triple{P}{\mathds{P}_1 + \mathds{P}_2}{Q}	
		}
		{
			\Delta \vdash \triple{P}{\mathds{P}_1}{Q}
			&
			\Delta \vdash \triple{P}{\mathds{P}_2}{Q}
		}
	\end{array}
	\\ \\
	\begin{array}{@{\hspace*{-15pt}}c c}
		\infer[\textsc{Frame}]
		{
			\Delta \vdash \triple{P \sep R}{\mathds{P}}{Q \sep R}	
		}
		{
			\Delta \vdash \triple{P}{\mathds{P}}{Q}
		}
	&
		\infer[\textsc{Conseq}]
		{
			\Delta \vdash \triple{P}{\mathds{P}}{Q}	
		}
		{
			\Delta \vdash P \Rrightarrow P'
			&
			\Delta \vdash \triple{P'}{\mathds{P}}{Q'}
			&
			\Delta \vdash Q' \Rrightarrow Q	
		}
	\end{array}
	\\ \\
	\begin{array}{c c}
		\infer[\textsc{Par}]
		{
			\Delta \vdash \triple{P_1 \sep P_2}{\mathds{P}_1 \| \mathds{P}_2}{Q_1 \sep Q_2}	
		}
		{
			\Delta \vdash \triple{P_1}{\mathds{P}_1}{Q_1}
			&
			\Delta \vdash \triple{P_2}{\mathds{P}_2}{Q_2}	
		}
	&
		\infer[\textsc{Loop}]
		{
			\Delta \vdash \triple{P}{\mathds{P}^*}{P}	
		}
		{
			\Delta \vdash \triple{P}{\mathds{P}}{P}
		}
	\end{array}
	\\ \\
		\infer[\textsc{Pred-I}]
		{
			\Delta \vdash \triple{P}{\mathds{P}}{Q}
		}
		{
			\tsem{\Delta}^\textsc{p} \subseteq \tsem{\Delta'}^\textsc{p}
			&
			\Delta' \vdash \triple{P}{\mathds{P}}{Q}
		}
	\\ \\
		\infer[\textsc{Pred-E}]
		{
			\Delta \vdash \triple{P}{\mathds{P}}{Q}
		}
		{
			\forall \delta \in \tsem{\Delta}^\textsc{p} \ldotp \mathsf{stable}_\delta(R)
			&
			\alpha \not\in \Delta, P, Q
			&
			\Delta, (\forall \vec{x} \ldotp \alpha(\vec{x}) \equiv R) \vdash \triple{P}{\mathds{P}}{Q}
		}
	\end{gather*}
\end{defn}

Most of the rules are standard from disjoint concurrent separation logic \cite{csl}, with the exception of rules \textsc{Pred-I} and \textsc{Pred-E} which are instead derived from CAP \cite{cap}. The first one is used to weaken the assumptions about the predicate definitions, since if we are able to prove a triple with assumptions $\Delta'$ then it must be the case that we can prove the same triple under stronger assumptions $\Delta$. On the other hand, the \textsc{Pred-E} proof rule allows the introduction of a new predicate definition. In order to do so, the new predicate must be stable with respect to the environment and its name must not be in the existing definitions or the triple's assertions.

As part of the \textsc{Conseq} rule, we use the repartitioning operator as presented in Definition \ref{repartitioning} instead of the classic implication arrow $\implies$. The \textsc{Trans} rule occurs at the level of a single transaction $\mathds{T}$, and makes sure that the semantic interpretation of its pre- and post-condition is an axiom for $\mathds{T}$. The \textsc{Frame} rule works in the standard way, by enabling to add resources to both the pre-condition and the post-condition of a program, given that the latter does not modify them. This works since we must remember that all pre- and post-conditions are stable. Finally, the elegance of the \textsc{Par} rule in disjoint CSL is preserved, in line with CAP, given that we can run programs in parallel by separating the starting state and joining it at the end. Note that the composition of worlds is only defined when their shared state is equal, meaning that the actual separation that appears in the rule is with respect to the local state.

Given that the proof rules related to predicates, namely \textsc{Pred-I} and \textsc{Pred-E}, are not part of the ones included in the views framework, we show that they are sound in Lemma \ref{lem:pred-i} and Lemma \ref{lem:pred-e} respectively.
