\section{Auxiliary Lemmata for Equivalence}

\begin{lem}
	\label{lem:lockAbsent}
	Lock and unlock operations done by a transaction on items which it does not read or write can be removed without affecting the program or the global state.
	\begin{gather*}
		\forall \tau, \tau', h, h', \Phi, S, \mathds{P}, n, n', \iota, k, \kappa, x, y \ldotp
			\\
		\pred{tgen}{\tau, h, h', \Phi, S, \mathds{P}} \land  \pred{absent}{\iota, k, \tau} \land x = (\actlock{\iota}{k}{\kappa}, n) \land y = (\actunlock{\iota}{k}, n') \\ \land x \in \tau \land y \in \tau
		\land \tau' = \tau \setminus \{ x, y \}
			\implies
		\pred{tgen}{\tau', h, h', \Phi, S, \mathds{P}}
	\end{gather*}
	\begin{proof}
	Let's pick arbitrary $\tau, \tau' \in [\mathsf{Act} \times \mathds{N}], h, h' \in \mathsf{Storage}, \Phi \in \mathsf{LMan}, S \in \mathsf{TState}, \mathds{P} \in \mathds{Prog}, n, n' \in \mathds{N}, \iota \in \mathsf{Tid}, k \in \mathsf{Key}, \kappa \in \mathsf{Lock}, x, y \in \mathsf{Act} \times \mathds{N}$. We now assume that the following holds:
	\begin{gather*}
		\pred{tgen}{\tau, h, h', \Phi, S, \mathds{P}} \land  \pred{absent}{\iota, k, \tau} \land x = (\actlock{\iota}{k}{\kappa}, n) \land y = (\actunlock{\iota}{k}, n') \\ \land x \in \tau \land y \in \tau
		\land \tau' = \tau \setminus \{ x, y \}
	\end{gather*}
	From Proposition \ref{prop:2phase} we obtain that $\tau \vDash x < y$. From the definition of $\mathsf{tgen}$ and the fact that both $x$ and $y$ are in $\tau$ it follows that $\kappa \geq \textsc{s}$ and:
	\begin{gather}
		(h, \Phi, S, \mathds{P}) \rightarrow^* (h_1, \Phi_1, S_1, \mathds{P}_1) \xrightarrow{\actlock{\iota}{k}{\kappa}} (h_1', \Phi_1', S_1', \mathds{P}_1') \\ \rightarrow^* (h_2, \Phi_2, S_2, \mathds{P}_2) \xrightarrow{\actunlock{\iota}{k}} (h_2', \Phi_2', S_2', \mathds{P}_2') \rightarrow^* (h', \emptyset, S', \pskip)
	\end{gather}
	From the semantic interpretation of $\mathsf{lock}$ and $\mathsf{unlock}$, we know that it is the case that $h_1' = h_1, S_1' = S_1, \mathds{P}_1' = \mathds{P}_1, h_2' = h_2, S_2' = S_2, \mathds{P}_2' = \mathds{P}_2$ and $\Phi_1' = \Phi_1[k \mapsto (\{\iota\} \cup I, \kappa)], \Phi_2' = \Phi_2[k \mapsto (I', \kappa')]$ for $I, I' \in \mathcal{P}(\mathsf{Tid})$ such that $\iota \not\in I'$ and $\kappa' \leq \textsc{s}$. From the assumption that $\pred{absent}{\iota, k, \tau}$ holds, we know there is no read or write action on $k$ done by $\iota$ happening in $(h_1', \Phi_1', S_1', \mathds{P}_1') \rightarrow^* (h_2, \Phi_2, S_2, \mathds{P}_2)$ meaning that actions which need a presence of $\iota$'s lock acquisition on $k$ to succeed (i.e. read and write) are not there. From Lemma \ref{lem:alman} we obtain that all actions that are part of the sequence of reductions $(h_1', \Phi_1', S_1', \mathds{P}_1') \rightarrow^* (h_2, \Phi_2, S_2, \mathds{P}_2)$ will succesfully reduce with the $\Phi_1$ lock manager not containing $\iota$ as an owner for $k$. It follows that, for $(\alpha, n+1) \in \tau$ and $(\alpha', n'+1) \in \tau$:
	\begin{gather}
		\label{lem:spur1} (h, \Phi, S, \mathds{P}) \rightarrow^* (h_1, \Phi_1, S_1, \mathds{P}_1) \xrightarrow{\alpha} (h_1'', \Phi_1'', S_1'', \mathds{P}_1'')
			\\
		\label{lem:spur2} \rightarrow^* (h_2'', \Phi_2'', S_2'',\mathds{P}_2'') \xrightarrow{\alpha'} (h_2, \Phi_2, S_2, \mathds{P}_2) \rightarrow^* (h', \emptyset, S', \pskip)
	\end{gather}
	From the initial assumption we also know that $\tau' = \tau \setminus \{ x, y \}$ meaning that $\tau'$ has all of $\tau$'s actions a part from the ones at position $n$ and $n'$. As a consequence we have that by following $\tau'$ up to (and not including) position $n$ we have $(h, \Phi, S, \mathds{P}) \rightarrow^* (h_1, \Phi_1, S_1, \mathds{P}_1)$. Skipping the operation at position $n$ which is not present in $\tau'$, we proceed with the one in position $n + 1$ all the way to (and not including) the one in position $n'$ to get by (\ref{lem:spur1}) and (\ref{lem:spur2}) that $(h_1, \Phi_1, S_1, \mathds{P}_1) \xrightarrow{\alpha} (h_1'', \Phi_1'', S_1'', \mathds{P}_1'') \rightarrow^* (h_2'', \Phi_2'', S_2'',\mathds{P}_2'')$ holds. Now we apply the action from position $n' + 1$ to the end in $\tau'$ to obtain $(h_2'', \Phi_2'', S_2'',\mathds{P}_2'') \xrightarrow{\alpha'} (h_2, \Phi_2, S_2, \mathds{P}_2) \rightarrow^* (h', \emptyset, S', \pskip)$. From the definition of $\mathsf{tgen}$ we can state that $\pred{tgen}{\tau', h, h', \Phi, S, \mathds{P}}$ holds as needed.
	\end{proof}
\end{lem}

\begin{lem}
	\label{lem:alman} A lock on an item is not needed for any reductions a part from a read, a write or an unlock action performed by the same transaction on the same item.
	\begin{gather*}
		\forall \mathds{P}, \mathds{P}', h, h', \Phi, \Phi', S, S', \alpha, i, k, v, I, \kappa \ldotp \\
		(h, \Phi, S, \mathds{P}) \xrightarrow{\alpha} (h', \Phi', S', \mathds{P}')
			\land
		(\{i\} \uplus I, \kappa) = \Phi(k)
			\land \\
		\alpha \not\in \{ \actread{i}{k}{v}, \actwrite{i}{k}{v}, \actunlock{i}{k} \}
			\implies
		\exists \Phi_m, \Phi_m', I', \kappa', \kappa'' \ldotp \\
		(h, \Phi_m, S, \mathds{P}) \xrightarrow{\alpha} (h', \Phi_m', S, \mathds{P}')
			\land
		\Phi_m = \Phi[k \mapsto (I, \kappa')]
			\land
		\Phi_m' = \Phi'[k \mapsto (I', \kappa'')]
			\land
		\kappa' \leq \textsc{s}
	\end{gather*}
	\begin{proof}
	Let's pick arbitrary $\mathds{P}, \mathds{P}' \in \mathsf{Prog}, h, h' \in \mathsf{Storage}, \Phi, \Phi' \in \mathsf{LMan}, S, S' \in \mathsf{TState}, \alpha \in \mathsf{Act}, i \in \mathsf{Tid}, k \in \mathsf{Key}, v \in \mathsf{Val}, I \in \mathcal{P}(\mathsf{Tid}), \kappa \in \mathsf{Lock}$. We now assume that the following holds:
	\begin{gather}
		\label{lem:alman1}
		(h, \Phi, S, \mathds{P}) \xrightarrow{\alpha} (h', \Phi', S', \mathds{P}')
			\land
		(\{i\} \uplus I, \kappa) = \Phi(k)
			\land
		\alpha \not\in \{ \actread{i}{k}{v}, \actwrite{i}{k}{v} \}
	\end{gather}
	From (\ref{lem:alman1}) we directly obtain that $\kappa \geq \textsc{s}$ given that $i$ is in the owners' set for item $k$. The proof proceeds with a case-by-case analysis on $\alpha$.
	\begin{itemize}
		\item If $\alpha = \actprog$, $\alpha = \actid{\iota}$ or $\alpha = \actalloc{\iota}{n}{l}$ for some $\iota \in \mathsf{Tid}, n \in \mathds{N}, l \in \mathsf{Key}$, then the result trivially follows given that in these cases $\alpha$ has no requirementes on $\Phi$ to succesfully reduce.
		
		\item If $\alpha = \actread{j}{k'}{v'}$ for $j \in \mathsf{Tid}, k' \in \mathsf{Key}, v' \in \mathsf{Val}$ then from (\ref{lem:alman1}) we know that $i \neq j$. Next we consider the following two cases:
			\begin{itemize}
				\item If $k = k'$ then from (\ref{lem:alman1}) we obtain that, given the $\alpha$ action has succesfully reduced, $\kappa = \textsc{s}$ and $j \in I$. Therefore we can find $\kappa' = \textsc{s}, \kappa'' = \textsc{s}$ and $I' = I$.
				\item If $k \neq k'$ then $\alpha$ has no requirement on $\Phi(k)$ to succesfully reduce and the result follows.
			\end{itemize}
			
		\item If $\alpha = \actwrite{j}{k'}{v'}$ for $j \in \mathsf{Tid}, k' \in \mathsf{Key}, v' \in \mathsf{Val}$ then from (\ref{lem:alman1}) we know that $i \neq j$. Next we consider the following two cases:
			\begin{itemize}
				\item If $k = k'$ then it is not possible that $\alpha$ succesfully reduced since from (\ref{lem:alman1}) we know that $i$ was in the owners set for key $k$, then it must be the case that $k \neq k'$.
				\item If $k \neq k'$ then $\alpha$ has no requirement on $\Phi(k)$ to succesfully reduce and the result follows.
			\end{itemize}
			
		\item If $\alpha = \actlock{j}{k'}{\kappa_j}$ for some $j \in \mathsf{Tid}, k' \in \mathsf{Key}, \kappa_j \in \mathsf{Lock}$.
			\begin{itemize}
				\item If $k \neq k'$ then $\alpha$ has no requirement on $\Phi(k)$ to succesfully reduce and the result follows.
				\item If $k = k'$ and $i \neq j$ then from (\ref{lem:alman1}) we know that $\alpha$ succesfully reduced, and therefore $\kappa = \textsc{s}$ and $\kappa_j = \textsc{s}$. This also implies that we can find $\kappa' = \textsc{s}, I' = I \cup \{j\}$ and $\kappa'' = \textsc{s}$.
				\item If $k = k'$ and $i = j$ then given that $\Phi(k)$ already had $i$ as part of the owners, it must be the case that $\kappa = \textsc{s}, I = \emptyset$ and $\kappa_j = \textsc{x}$ in order for $\alpha$ to reduce as imposed by (\ref{lem:alman1}). It follows that we can find $\kappa' = \textsc{u}, I' = \{i\}$ and $\kappa'' = \textsc{x}$.
			\end{itemize}
			
		\item If $\alpha = \actunlock{j}{k'}$ for $j \in \mathsf{Tid}, k' \in \mathsf{Key}$ then from (\ref{lem:alman1}) we know that $i \neq j$. Next we consider the following two cases:
			\begin{itemize}
				\item If $k \neq k'$ then $\alpha$ has no requirement on $\Phi(k)$ to succesfully reduce and the result follows.
				\item If $k = k'$ then from (\ref{lem:alman1}) we know that $\alpha$ succesfully reduced meaning that $i$ and $j$ were holding the lock at the same time, making $\kappa = \textsc{s}, \kappa' = \textsc{s}, \kappa'' = \textsc{s}$ and $I' = I \setminus \{ i, j \}$.
			\end{itemize}
	\end{itemize}
	\end{proof}
\end{lem}

\begin{lem}
	\label{lem:rr}
	The order of two consecutive reads can be swapped as long as the transactions performing them are distinct.
	\begin{gather*}
		\forall \tau, \tau', h, h', \Phi, S, \mathds{P}, i, j, k, k', v, v', \alpha, \alpha', n \ldotp \\
		i \neq j \land \alpha = \actread{i}{k}{v} \land \alpha' = \actread{j}{k'}{v'} \land (\alpha, n) \in \tau \land (\alpha', n+1) \in \tau \\ \land \pred{tgen}{\tau, h, h', \Phi, S, \mathds{P}} \land \tau' = \tau \setminus \{(\alpha, n), (\alpha', n+1)\} \cup \{ (\alpha, n+1), (\alpha', n) \}
			\\	 
		 \implies \pred{tgen}{\tau', h, h', \Phi, S, \mathds{P}}
	\end{gather*}
	\begin{proof}
	Let's pick arbitrary $\tau, \tau' \in [\mathsf{Act} \times \mathds{N}], h, h' \in \mathsf{Storage}, \Phi \in \mathsf{LMan}, S \in \mathsf{TState}, \mathds{P} \in \mathsf{Prog}, i, j \in \mathsf{Tid}, k, k' \in \mathsf{Key}, v, v' \in \mathsf{Val}, \alpha, \alpha' \in \mathsf{Act}, n \in \mathds{N}$. We assume that the following holds:
	\begin{gather*}
		i \neq j \land \alpha = \actread{i}{k}{v} \land \alpha' = \actread{j}{k'}{v'} \land (\alpha, n) \in \tau \land (\alpha', n+1) \in \tau \\ \land \pred{tgen}{\tau, h, h', \Phi, S, \mathds{P}} \land \tau' = \tau \setminus \{(\alpha, n), (\alpha', n+1)\} \cup \{ (\alpha, n+1), (\alpha', n) \}
	\end{gather*}
	The above means that the two transactions performing the consecutive read actions $\alpha$ and $\alpha'$ are distinct and in $\tau$. Also, $\tau'$ is equivalent to $\tau$ with the $\alpha$ and $\alpha'$ actions swapped. From the definition of $\mathsf{tgen}$ we know that following the actions in $\tau$ we obtain the following:
	\begin{gather}
		\label{lem:rr1} (h, \Phi, S, \mathds{P}) \rightarrow^* (h_1, \Phi_1, S_1, \mathds{P}_1) \xrightarrow{\alpha} (h_0, \Phi_0, S_0, \mathds{P}_0) \\
		\label{lem:rr2} \xrightarrow{\alpha'} (h_2, \Phi_2, S_2, \mathds{P}_2) \rightarrow^* (h', \emptyset, S, \pskip)
	\end{gather}
	It is now required to show that trace $\tau'$ is executing the following:
	\[
		(h, \Phi, S, \mathds{P}) \rightarrow^* (h_1, \Phi_1, S_1, \mathds{P}_1) \xrightarrow{\alpha'} (h_0', \Phi_0', S_0', \mathds{P}_0') \xrightarrow{\alpha} (h_2, \Phi_2, S_2, \mathds{P}_2) \rightarrow^* (h', \emptyset, S', \pskip)
	\]
	Since $i \neq j$ we know that the two action labels $\alpha$ and $\alpha'$ were produced by the two transactions running in parallel executing a single step each meaning we can write $\mathds{P}_1 = \mathds{P}_i \| \mathds{P}_j$ (or equivalently $\mathds{P}_j \| \mathds{P}_i$) for some $\mathds{P}_i, \mathds{P}_j \in \mathsf{Prog}$. It follows that $\mathds{P}_2 = \mathds{P}_i' \| \mathds{P}_j'$ for $(h_1, \Phi_1, S_1, \mathds{P}_i) \xrightarrow{\alpha} (h_0, \Phi_0, S_0, \mathds{P}_i')$ and $(h_0, \Phi_0, S_0, \mathds{P}_j) \xrightarrow{\alpha'} (h_2, \Phi_2, S_2, \mathds{P}_j')$. Given the effect of the $\mathsf{read}$ action, we know that $h_1 = h_0 = h_2, \Phi_1 = \Phi_0 = \Phi_2$. We can immediately find a $h_0' = h_1 = h_2$ and a $\Phi_0' = \Phi_1 = \Phi_2$. $\mathds{P}_0'$ will be the program $\mathds{P}_1$ that has executed a step in the program where transaction $j$ resides, formally $\mathds{P}_0' = \mathds{P}_i \| \mathds{P}_j'$ for $(h_1, \Phi_1, S_1, \mathds{P}_j) \xrightarrow{\alpha'} (h_0', \Phi_0', S_0', \mathds{P}_j')$. We know that this will always succeed since the $\mathsf{read}$ action requirements on $h_0, \Phi_0$ are all satisfied by (\ref{lem:rr2}). From this, $\mathds{P}_0'$ can always reduce to $\mathds{P}_2$ by chosing to run the program in which transaction $i$ is, i.e. $\mathds{P}_i$ as part of $(h_0', \Phi_0', S_0', \mathds{P}_i) \xrightarrow{\alpha} (h_2, \Phi_2, S_2, \mathds{P}_i')$, which is possible thanks to the assumption in (\ref{lem:rr1}). Given that by assumption $i \neq j$, it must be the case that $S(i)$ and $S(j)$ are disjoint therefore the relative ordering on the updates to the local variables does not matter.
	\end{proof}
\end{lem}

\begin{lem}
	\label{lem:rwlu}
	The order of two consecutive read, write, lock or unlock operations can be swapped as long as the transactions performing them are distinct and the keys they refer to are different.
	\begin{gather*}
		\forall \tau, \tau', h, h', \Phi, S, \mathds{P}, i, j, k, k', x, y, n \ldotp \\
			i \neq j \land x = \alpha(i, k) \land y = \alpha(j, k') \land k \neq k' \land (x, n) \in \tau \land (y, n+1) \in \tau \\ \land \pred{tgen}{\tau, h, h', \Phi, S, \mathds{P}} \land \tau' = \tau \setminus \{(x, n), (y, n+1)\} \cup \{ (x, n+1), (y, n) \}
			\\	 
		 \implies \pred{tgen}{\tau', h, h', \Phi, S, \mathds{P}}
	\end{gather*}
	\begin{proof}
	Let's pick arbitrary $\tau, \tau' \in [\mathsf{Act} \times \mathds{N}], h, h' \in \mathsf{Storage}, \Phi \in \mathsf{LMan}, S \in \mathsf{TState}, \mathds{P} \in \mathsf{Prog}, i, j \in \mathsf{Tid}, k, k' \in \mathsf{Key}, x, y \in \mathsf{Act}, n \in \mathds{N}$. We assume that the following holds:
	\begin{gather}
		i \neq j \land x = \alpha(i, k) \land y = \alpha(j, k') \land (x, n) \in \tau \land (y, n+1) \in \tau \\ \land \pred{tgen}{\tau, h, h', \Phi, S, \mathds{P}} \land \tau' = \tau \setminus \{(x, n), (y, n+1)\} \cup \{ (x, n+1), (y, n) \}
	\end{gather}
	The above means that the two transactions performing the consecutive actions $x$ and $y$ are distinct and in $\tau$. Also, $\tau'$ is equivalent to $\tau$ with the $x$ and $y$ actions swapped. From the definition of $\mathsf{tgen}$ we know that following the actions in $\tau$ we obtain the following:
	\begin{gather}
		\label{lem:xy1} (h, \Phi, S, \mathds{P}) \rightarrow^* (h_1, \Phi_1, S_1, \mathds{P}_1) \xrightarrow{x} (h_0, \Phi_0, S_0, \mathds{P}_0) \\
		\label{lem:xy2} \xrightarrow{y} (h_2, \Phi_2, S_2, \mathds{P}_2) \rightarrow^* (h', \emptyset, S, \pskip)
	\end{gather}
	It is now required to show that trace $\tau'$ is executing the following:
	\[
		(h, \Phi, S, \mathds{P}) \rightarrow^* (h_1, \Phi_1, S_1, \mathds{P}_1) \xrightarrow{y} (h_0', \Phi_0', S_0', \mathds{P}_0') \xrightarrow{x} (h_2, \Phi_2, S_2, \mathds{P}_2) \rightarrow^* (h', \emptyset, S', \pskip)
	\]
	Since $i \neq j$ we know that the two action labels $x$ and $y$ were produced by the two transactions running in parallel executing a single step each meaning we can write $\mathds{P}_1 = \mathds{P}_i \| \mathds{P}_j$ (or equivalently $\mathds{P}_j \| \mathds{P}_i$) for some $\mathds{P}_i, \mathds{P}_j \in \mathsf{Prog}$. It follows that $\mathds{P}_2 = \mathds{P}_i' \| \mathds{P}_j'$ for $(h_1, \Phi_1, S_1, \mathds{P}_i) \xrightarrow{x} (h_0, \Phi_0, S_0, \mathds{P}_i')$ and $(h_0, \Phi_0, S_0, \mathds{P}_j) \xrightarrow{y} (h_2, \Phi_2, S_2, \mathds{P}_j')$. We will proceed with a case-by-case analysis on $x$ and $y$ in order to find suitable $h_0'$ and $\Phi_0'$.
	\begin{itemize}
		\item If $x = \actread{i}{k}{v}$ and $y = \actread{j}{k'}{v'}$ for $v, v' \in \mathsf{Val}$ then the result follows directly from Lemma \ref{lem:rr}.
		
		\item If $x = \actwrite{i}{k}{v}$ and $y = \actwrite{j}{k'}{v'}$ for $v, v' \in \mathsf{Val}$ then $h_2 = h_1[k \mapsto v][k' \mapsto v']$ since $k \neq k'$ and $\Phi_2 = \Phi_1$ meaning we can find $h_0' = h_1[k \mapsto v']$ and $\Phi_0' = \Phi_1$.
		
		\item If $x = \actread{i}{k}{v}$ and $y = \actwrite{j}{k'}{v'}$ for $v, v' \in \mathsf{Val}$ then $h_2 = h_1[k' \mapsto v']$ and $\Phi_2 = \Phi_1$ meaning we can find $h_0' = h_1[k' \mapsto v']$ and $\Phi_0' = \Phi_1$.
		
		\item If $x = \actlock{i}{k}{\kappa}$ and $y = \actunlock{j}{k'}$ for $\kappa \in \mathsf{Lock}$ then $h_2 = h_1$ and $\Phi_2 = \Phi_1[k \mapsto (I, \kappa)][k' \mapsto (I' \setminus \{j\}, \kappa')]$ since $k \neq k'$ for $I, I' \in \mathcal{P}(\mathsf{Tid})$ and $\kappa' \in \mathsf{Lock}$, meaning we can find $h_0' = h_1$ and $\Phi_0' = \Phi_1[k' \mapsto (I' \setminus \{j\}, \kappa')]$.
		
		\item If $x = \actlock{i}{k}{\kappa}$ and $y = \actlock{j}{k'}{\kappa'}$ for $\kappa, \kappa' \in \mathsf{Lock}$ then $h_2 = h_1$ and $\Phi_2 = \Phi_1[k \mapsto (I, \kappa)][k' \mapsto (I', \kappa')]$ since $k \neq k'$ for $I, I' \in \mathcal{P}(\mathsf{Tid})$ meaning we can find $h_0' = h_1$ and $\Phi_0' = \Phi_1[k' \mapsto (I', \kappa')]$.
		
		\item If $x = \actunlock{i}{k}$ and $y = \actunlock{j}{k'}$ then $h_2 = h_1$ and $\Phi_2 = \Phi_1[k \mapsto (I \setminus \{i\}, \kappa)][k' \mapsto (I' \setminus \{j\}, \kappa')]$ since $k \neq k'$ for $I, I' \in \mathcal{P}(\mathsf{Tid})$ and $\kappa, \kappa' \in \mathsf{Lock}$, meaning we can find $h_0' = h_1$ and $\Phi_0' = \Phi_1[k' \mapsto (I' \setminus \{j\}, \kappa')]$.
		
		\item If $x = \actlock{i}{k}{\kappa}$ and $y = \actread{j}{k'}{v}$ for $\kappa \in \mathsf{Lock}$ and $v \in \mathsf{Val}$ then $h_2 = h_1$ and $\Phi_2 = \Phi_1[k \mapsto (I, \kappa)]$ for $I \in \mathcal{P}(\mathsf{Tid})$, meaning we can find $h_0' = h_1$ and $\Phi_0' = \Phi_1$.
		
		\item If $x = \actlock{i}{k}{\kappa}$ and $y = \actwrite{j}{k'}{v}$ for $\kappa \in \mathsf{Lock}$ and $v \in \mathsf{Val}$ then $h_2 = h_1[k' \mapsto v]$ and $\Phi_2 = \Phi_1[k \mapsto (I, \kappa)]$ for $I \in \mathcal{P}(\mathsf{Tid})$, meaning we can find $h_0' = h_1[k \mapsto v]$ and $\Phi_0' = \Phi_1$.
		
		\item If $x = \actunlock{i}{k}$ and $y = \actread{j}{k'}{v}$ for $v \in \mathsf{Val}$ then $h_2 = h_1$ and $\Phi_2 = \Phi_1[k \mapsto (I \setminus \{j\}, \kappa)]$ for $\kappa \in \{\textsc{u}, \textsc{s}\}$ and $I \in \mathcal{P}(\mathsf{Tid})$, meaning we can find $h_0' = h_1$ and $\Phi_0' = \Phi_1$.
		
		\item If $x = \actunlock{i}{k}$ and $y = \actwrite{j}{k'}{v}$ for $v \in \mathsf{Val}$ then $h_2 = h_1[k' \mapsto v]$ and $\Phi_2 = \Phi_1[k \mapsto (I \setminus \{j\}, \kappa)]$ for $\kappa \in \{\textsc{u}, \textsc{s}\}$ and $I \in \mathcal{P}(\mathsf{Tid})$, meaning we can find $h_0' = h_1[k \mapsto v]$ and $\Phi_0' = \Phi_1$.
	\end{itemize}
	The inverted cases that are not included in the list can be trivially found as a consequence of the presented ones, with the appropriate substitions.
	
	From (\ref{lem:xy1}) we obtain that $\mathds{P}_0'$ is the program $\mathds{P}_1$ that has executed a step in the program where transaction $j$ resides, formally $\mathds{P}_0' = \mathds{P}_i \| \mathds{P}_j'$ for $(h_1, \Phi_1, S_1, \mathds{P}_j) \xrightarrow{y} (h_0', \Phi_0', S_0', \mathds{P}_j')$. We know that this will always succeed since the actions act on disjoint parts of the global heap and lock manager, as showed in the case-by-case analysis above, meaning that their requirements are all satisfied by (\ref{lem:xy2}). From this, $\mathds{P}_0'$ can always reduce to $\mathds{P}_2$ by chosing to run the program in which transaction $i$ is, i.e. $\mathds{P}_i$ as part of $(h_0', \Phi_0', S_0', \mathds{P}_i) \xrightarrow{x} (h_2, \Phi_2, S_2, \mathds{P}_i')$, which is possible thanks to the assumption in (\ref{lem:xy1}). Given that by assumption $i \neq j$, it must be the case that $S(i)$ and $S(j)$ are disjoint therefore the relative ordering on the eventual updates to the local variables does not matter.
	\end{proof}
\end{lem}

\begin{lem}
	\label{lem:aa}
	The order of two consecutive allocations can be swapped as long as the transactions performing them are distinct.
	\begin{gather*}
		\forall \tau, \tau', h, h', \Phi, S, \mathds{P}, i, j, m, m', l, l', \alpha, \alpha', n \ldotp \\
			i \neq j \land \alpha = \actalloc{i}{m}{l} \land \alpha' = \actalloc{j}{m'}{l'} \land (\alpha, n) \in \tau \land (\alpha', n+1) \in \tau \\ \land \pred{tgen}{\tau, h, h', \Phi, S, \mathds{P}} \land \tau' = \tau \setminus \{(\alpha, n), (\alpha', n+1)\} \cup \{ (\alpha, n+1), (\alpha', n) \}
			\\	 
		 \implies \pred{tgen}{\tau', h, h', \Phi, S, \mathds{P}}
	\end{gather*}
	\begin{proof}
	Let's pick arbitrary $\tau, \tau' \in [\mathsf{Act} \times \mathds{N}], h, h' \in \mathsf{Storage}, \Phi \in \mathsf{LMan}, S \in \mathsf{TState}, \mathds{P} \in \mathsf{Prog}, i, j \in \mathsf{Tid}, l, l' \in \mathsf{Key}, \alpha, \alpha' \in \mathsf{Act}, n, m, m' \in \mathds{N}$. We assume that the following holds:
	\begin{gather}
		i \neq j \land \alpha = \actalloc{i}{m}{l} \land \alpha' = \actalloc{j}{m'}{l'} \land (\alpha, n) \in \tau \land (\alpha', n+1) \in \tau \\ \land \pred{tgen}{\tau, h, h', \Phi, S, \mathds{P}} \land \tau' = \tau \setminus \{(\alpha, n), (\alpha', n+1)\} \cup \{ (\alpha, n+1), (\alpha', n) \}
	\end{gather}
	The above means that the two transactions performing the consecutive allocation actions $\alpha$ and $\alpha'$ are distinct and in $\tau$. Also, $\tau'$ is equivalent to $\tau$ with the $\alpha$ and $\alpha'$ actions swapped. From the definition of $\mathsf{tgen}$ we know that following the actions in $\tau$ we obtain the following:
	\begin{gather}
		\label{lem:aa1} (h, \Phi, S, \mathds{P}) \rightarrow^* (h_1, \Phi_1, S_1, \mathds{P}_1) \xrightarrow{\alpha} (h_0, \Phi_0, S_0, \mathds{P}_0) \\
		\label{lem:aa2} \xrightarrow{\alpha'} (h_2, \Phi_2, S_2, \mathds{P}_2) \rightarrow^* (h', \emptyset, S, \pskip)
	\end{gather}
	It is now required to show that trace $\tau'$ is executing the following:
	\[
		(h, \Phi, S, \mathds{P}) \rightarrow^* (h_1, \Phi_1, S_1, \mathds{P}_1) \xrightarrow{\alpha'} (h_0', \Phi_0', S_0', \mathds{P}_0') \xrightarrow{\alpha} (h_2, \Phi_2, S_2, \mathds{P}_2) \rightarrow^* (h', \emptyset, S', \pskip)
	\]
	Since $i \neq j$ we know that the two action labels $\alpha$ and $\alpha'$ were produced by the two transactions running in parallel executing a single step each meaning we can write $\mathds{P}_1 = \mathds{P}_i \| \mathds{P}_j$ (or equivalently $\mathds{P}_j \| \mathds{P}_i$) for some $\mathds{P}_i, \mathds{P}_j \in \mathsf{Prog}$. It follows that $\mathds{P}_2 = \mathds{P}_i' \| \mathds{P}_j'$ for $(h_1, \Phi_1, S_1, \mathds{P}_i) \xrightarrow{\alpha} (h_0, \Phi_0, S_0, \mathds{P}_i')$ and $(h_0, \Phi_0, S_0, \mathds{P}_j) \xrightarrow{\alpha'} (h_2, \Phi_2, S_2, \mathds{P}_j')$. Given the effect of the $\mathsf{alloc}$ action, we know that $\Phi_2 = \Phi_1 = \Phi_0$. We can immediately find a $\Phi_0' = \Phi_1 = \Phi_2$. We also know that $\{l, \ldots, l + n - 1\} \subseteq \pred{dom}{h_0}$ and in order for $\actalloc{j}{n'}{l'}$ to suceed, which it does by (\ref{lem:aa2}), $\{l', \ldots, l' + n' - 1\} \cap \pred{dom}{h_0} \equiv \emptyset$ which means that the two ranges of memory locations are disjoint. As a consequence the order of allocation does not matter in terms of reaching the final heap $h_2$; our $h_0'$ will therefore be $h_1[l' \mapsto 0]\ldots[l' + n' - 1 \mapsto 0]$. $\mathds{P}_0'$ will be the program $\mathds{P}_1$ that has executed a step in the program where transaction $j$ resides, formally $\mathds{P}_0' = \mathds{P}_i \| \mathds{P}_j'$ for $(h_1, \Phi_1, S_1, \mathds{P}_j) \xrightarrow{\alpha'} (h_0', \Phi_0', S_0', \mathds{P}_j')$. We know that this will always succeed since the $\mathsf{alloc}$ action requirements are all satisfied by (\ref{lem:aa2}). From this, $\mathds{P}_0'$ can always reduce to $\mathds{P}_2$ by chosing to run the program in which transaction $i$ is, i.e. $\mathds{P}_i$ as part of $(h_0', \Phi_0', S_0', \mathds{P}_i) \xrightarrow{\alpha} (h_2, \Phi_2, S_2, \mathds{P}_i')$, which is possible thanks to the assumption in (\ref{lem:aa1}). Given that by assumption $i \neq j$, it must be the case that $S(i)$ and $S(j)$ are disjoint therefore the relative ordering on the updates to the local variables does not matter.
	\end{proof}
\end{lem}

\begin{lem}
	\label{lem:ax}
	The order of an allocation followed by a read, write, lock or unlock can be swapped as long as the transactions performing them are distinct and the keys accessed are not part of the ones created by the allocation.
	\begin{gather*}
		\forall \tau, \tau', h, h', \Phi, S, \mathds{P}, i, j, k, x, y, n, m, l \ldotp \\
			i \neq j \land x = \alpha(j, k) \land y = \actalloc{i}{m}{l} \land (x, n) \in \tau \land (y, n+1) \in \tau \land (k < l \lor k \geq l + n) \\ \land \pred{tgen}{\tau, h, h', \Phi, S, \mathds{P}} \land \tau' = \tau \setminus \{(x, n), (y, n+1)\} \cup \{ (x, n+1), (y, n) \}
			\\	 
		 \implies \pred{tgen}{\tau', h, h', \Phi, S, \mathds{P}}
	\end{gather*}
	\begin{proof}
	Let's pick arbitrary $\tau, \tau' \in [\mathsf{Act} \times \mathds{N}], h, h' \in \mathsf{Storage}, \Phi \in \mathsf{LMan}, S \in \mathsf{TState}, \mathds{P} \in \mathsf{Prog}, i, j \in \mathsf{Tid}, k, l \in \mathsf{Key}, x, y \in \mathsf{Act}, n, m \in \mathds{N}$. We assume that the following holds:
	\begin{gather*}
		i \neq j \land x = \alpha(j, k) \land y = \actalloc{i}{m}{l} \land (x, n) \in \tau \land (y, n+1) \in \tau \land (k < l \lor k \geq l + n) \\ \land \pred{tgen}{\tau, h, h', \Phi, S, \mathds{P}} \land \tau' = \tau \setminus \{(x, n), (y, n+1)\} \cup \{ (x, n+1), (y, n) \}
	\end{gather*}
	The above means that the two transactions performing the consecutive actions $x$ and $y$ are distinct and in $\tau$. Also, $\tau'$ is equivalent to $\tau$ with the $x$ and $y$ actions swapped. From the definition of $\mathsf{tgen}$ we know that following the actions in $\tau$ we obtain the following:
	\begin{gather}
		\label{lem:ax1} (h, \Phi, S, \mathds{P}) \rightarrow^* (h_1, \Phi_1, S_1, \mathds{P}_1) \xrightarrow{x} (h_0, \Phi_0, S_0, \mathds{P}_0) \\
		\label{lem:ax2} \xrightarrow{y} (h_2, \Phi_2, S_2, \mathds{P}_2) \rightarrow^* (h', \emptyset, S, \pskip)
	\end{gather}
	It is now required to show that trace $\tau'$ is executing the following:
	\[
		(h, \Phi, S, \mathds{P}) \rightarrow^* (h_1, \Phi_1, S_1, \mathds{P}_1) \xrightarrow{y} (h_0', \Phi_0', S_0', \mathds{P}_0') \xrightarrow{x} (h_2, \Phi_2, S_2, \mathds{P}_2) \rightarrow^* (h', \emptyset, S', \pskip)
	\]
	Since $i \neq j$ we know that the two action labels $x$ and $y$ were produced by the two transactions running in parallel executing a single step each meaning we can write $\mathds{P}_1 = \mathds{P}_i \| \mathds{P}_j$ (or equivalently $\mathds{P}_j \| \mathds{P}_i$) for some $\mathds{P}_i, \mathds{P}_j \in \mathsf{Prog}$. It follows that $\mathds{P}_2 = \mathds{P}_i' \| \mathds{P}_j'$ for $(h_1, \Phi_1, S_1, \mathds{P}_i) \xrightarrow{x} (h_0, \Phi_0, S_0, \mathds{P}_i')$ and $(h_0, \Phi_0, S_0, \mathds{P}_j) \xrightarrow{y} (h_2, \Phi_2, S_2, \mathds{P}_j')$. Given the effect of the $\mathsf{alloc}$ action, we know that $\Phi_2 = \Phi_1 = \Phi_0$. Given the effect of the $\mathsf{alloc}$ action, we know that $\Phi_2 = \Phi_1 = \Phi_0$ and $h_0 = h_1[l \mapsto 0]\ldots[l + n - 1 \mapsto 0]$. In order to find $h_0'$ and $\Phi_0'$, we now proceed with a case-by-case analysis on the kind of action $x$.
	\begin{itemize}
		\item If $x = \actread{j}{k}{v}$ for $v \in \mathsf{Val}$ then $h_2 = h_1$ and $\Phi_2 = \Phi_1$ meaning we can find $h_0' = h_1$ and $\Phi_0' = \Phi_1$.
		
		\item If $x = \actwrite{j}{k}{v}$ for $v \in \mathsf{Val}$ then $h_2 = h_1[k \mapsto v]$ and $\Phi_2 = \Phi_1$ meaning we can find $h_0' = h_1[k \mapsto v]$ and $\Phi_0' = \Phi_1$.
		
		\item If $x = \actlock{j}{k}{\kappa}$ for some $\kappa \in \mathsf{Lock}$ then $h_2 = h_1$ and $\Phi_2 = \Phi_1[k \mapsto (I, \kappa)]$ meaning we can find $h_0' = h_1$ and $\Phi_0' = \Phi_1[k \mapsto (I, \kappa)]$ for $I \in \mathcal{P}(\mathsf{Tid})$.
		
		\item If $x = \actunlock{j}{k}$ then $h_2 = h_1$ and $\Phi_2 = \Phi_1[k \mapsto (I \setminus \{j\}, \kappa)]$ for $I \in \mathcal{P}(\mathsf{Tid})$ and $\kappa \in \{\textsc{u}, \textsc{s}\}$ meaning we can find $h_0' = h_1$ and $\Phi_0' = \Phi_1[k \mapsto (I \setminus \{j\}, \kappa)]$.
	\end{itemize}
	$\mathds{P}_0'$ will be the program $\mathds{P}_1$ that has executed a step in the program where transaction $j$ resides, formally $\mathds{P}_0' = \mathds{P}_i \| \mathds{P}_j'$ for $(h_1, \Phi_1, S_1, \mathds{P}_j) \xrightarrow{y} (h_0', \Phi_0', S_0', \mathds{P}_j')$. We know that this will always succeed since the $\mathsf{alloc}$ action requirements are all satisfied by (\ref{lem:ax2}). From this, $\mathds{P}_0'$ can always reduce to $\mathds{P}_2$ by chosing to run the program in which transaction $i$ is, i.e. $\mathds{P}_i$ as part of $(h_0', \Phi_0', S_0', \mathds{P}_i) \xrightarrow{x} (h_2, \Phi_2, S_2, \mathds{P}_i')$, which is possible thanks to the assumption in (\ref{lem:ax1}). Given that by assumption $i \neq j$, it must be the case that $S(i)$ and $S(j)$ are disjoint therefore the relative ordering on the updates to the local variables does not matter.
	\end{proof}
\end{lem}

	\begin{lem}
		\label{lem:idx}
		The order of an $\mathsf{id}$ operation followed by any other action performed by a different transaction can be swapped.
	\begin{gather*}
		\forall \tau, \tau', h, h', \Phi, S, \mathds{P}, i, j, x, y, n \ldotp \\
			i \neq j \land x = \actid{i} \land y = \alpha(j) \land (x, n) \in \tau \land (y, n+1) \in \tau \\ \land \pred{tgen}{\tau, h, h', \Phi, S, \mathds{P}} \land \tau' = \tau \setminus \{(x, n), (y, n+1)\} \cup \{ (x, n+1), (y, n) \}
			\\	 
		 \implies \pred{tgen}{\tau', h, h', \Phi, S, \mathds{P}}
	\end{gather*}
	\begin{proof}
	Let's pick arbitrary $\tau, \tau' \in [\mathsf{Act} \times \mathds{N}], h, h' \in \mathsf{Storage}, \Phi \in \mathsf{LMan}, S \in \mathsf{TState}, \mathds{P} \in \mathsf{Prog}, i, j \in \mathsf{Tid}, x, y \in \mathsf{Act}, n \in \mathds{N}$. We assume that the following holds:
	\begin{gather*}
		i \neq j \land x = \actid{i} \land y = \alpha(j) \land (x, n) \in \tau \land (y, n+1) \in \tau \land (k < l \lor k \geq l + n) \\ \land \pred{tgen}{\tau, h, h', \Phi, S, \mathds{P}} \land \tau' = \tau \setminus \{(x, n), (y, n+1)\} \cup \{ (x, n+1), (y, n) \}
	\end{gather*}
	The above means that the two transactions performing the consecutive actions $x$ and $y$ are performed by distinct transactions and in $\tau$. Also, $\tau'$ is equivalent to $\tau$ with the $x$ and $y$ actions swapped. From the definition of $\mathsf{tgen}$ we know that following the actions in $\tau$ we obtain the following:
	\begin{gather}
		\label{lem:idx1} (h, \Phi, S, \mathds{P}) \rightarrow^* (h_1, \Phi_1, S_1, \mathds{P}_1) \xrightarrow{x} (h_0, \Phi_0, S_0, \mathds{P}_0) \\
		\label{lem:idx2} \xrightarrow{y} (h_2, \Phi_2, S_2, \mathds{P}_2) \rightarrow^* (h', \emptyset, S, \pskip)
	\end{gather}
	It is now required to show that trace $\tau'$ is executing the following:
	\[
		(h, \Phi, S, \mathds{P}) \rightarrow^* (h_1, \Phi_1, S_1, \mathds{P}_1) \xrightarrow{y} (h_0', \Phi_0', S_0', \mathds{P}_0') \xrightarrow{x} (h_2, \Phi_2, S_2, \mathds{P}_2) \rightarrow^* (h', \emptyset, S', \pskip)
	\]
	Since $i \neq j$ we know that the two action labels $x$ and $y$ were produced by the two transactions running in parallel executing a single step each meaning we can write $\mathds{P}_1 = \mathds{P}_i \| \mathds{P}_j$ (or equivalently $\mathds{P}_j \| \mathds{P}_i$) for some $\mathds{P}_i, \mathds{P}_j \in \mathsf{Prog}$. It follows that $\mathds{P}_2 = \mathds{P}_i' \| \mathds{P}_j'$ for $(h_1, \Phi_1, S_1, \mathds{P}_i) \xrightarrow{x} (h_0, \Phi_0, S_0, \mathds{P}_i')$ and $(h_0, \Phi_0, S_0, \mathds{P}_j) \xrightarrow{y} (h_2, \Phi_2, S_2, \mathds{P}_j')$. Given the effect of the $\mathsf{id}$ action, we know that $h_1 = h_0, \Phi_1 = \Phi_0, S_1 = S_0$ meaning that $y$ reduced succesfully as per (\ref{lem:idx2}), with a configuration equivalent to the one after $x$ reduced. It follows that we can find $h_0' = h_1, \Phi_0' = \Phi_1, S_0' = S_1$.
	
	$\mathds{P}_0'$ will be the program $\mathds{P}_1$ that has executed a step in the program where transaction $j$ resides, formally $\mathds{P}_0' = \mathds{P}_i \| \mathds{P}_j'$ for $(h_1, \Phi_1, S_1, \mathds{P}_j) \xrightarrow{y} (h_0', \Phi_0', S_0', \mathds{P}_j')$. We know that this will always succeed since the $\mathsf{alloc}$ action requirements are all satisfied by (\ref{lem:idx2}). From this, $\mathds{P}_0'$ can always reduce to $\mathds{P}_2$ by chosing to run the program in which transaction $i$ is, i.e. $\mathds{P}_i$ as part of $(h_0', \Phi_0', S_0', \mathds{P}_i) \xrightarrow{x} (h_2, \Phi_2, S_2, \mathds{P}_i')$, which is possible thanks to the assumption in (\ref{lem:idx1}).
	\end{proof}
\end{lem}

\begin{lem}
	\label{lem:catom}
	\[
	\begin{array}{r l}
		\pred{cAtom}{\mathds{C}} \triangleq&
		\begin{array}{l}
		\forall \iota, s, s', p, p', \Phi, h, h', \mathds{C}', \alpha \ldotp \\
		(s, p, \mathds{C}) \xrightarrow{\alpha}_\iota (s', p', \mathds{C}') \land h' \in \left( \llbracket \alpha \rrbracket(h, \Phi) \downarrow_1 \right) \\
		\implies
		(h, s, \mathds{C}) \tred (h', s', \mathds{C}')
		\end{array}
	\end{array}
	\]
	
	{\parindent0pt
	\begin{proof}
	$\forall \mathds{C} \in \mathsf{Cmd} \ldotp \pred{cAtom}{\mathds{C}}$ by induction on the structure of commands $\mathsf{Cmd}$. \\
	
	\textit{Base case 1}: $\pskip \in \mathsf{Cmd}$
	
	\textit{To show}: $\pred{cAtom}{\pskip}$
	
	For arbitrary $\iota, s, s', p, p', \Phi, h, h', \mathds{C}', \alpha$ we assume that $(s, p, \pskip) \xrightarrow{\alpha}_\iota (s', p', \mathds{C}') \land h' \in \left( \llbracket \alpha \rrbracket(h, \Phi) \downarrow_1 \right)$ holds. Given that $\pskip$ has no possible one-step reductions, it must be a zero-step reduction such that $s = s', \mathds{C}' = \pskip, \alpha = \actid{\iota}, h = h'$. Now, we can reduce $(h, s, \pskip) \tred (h', s', \pskip)$ through a zero step reduction, again where $s = s', h = h'$. \\
	
	\textit{Base case 2}: $\passign{\pvar{x}}{\mathds{E}} \in \mathsf{Cmd}$
	
	\textit{To show}: $\pred{cAtom}{\passign{\pvar{x}}{\mathds{E}}}$
	
	For arbitrary $\iota, s, s', p, p', \Phi, h, h', \mathds{C}', \alpha$ we assume that $(s, p, \passign{\pvar{x}}{\mathds{E}}) \xrightarrow{\alpha}_\iota (s', p', \mathds{C}') \land h' \in \left( \llbracket \alpha \rrbracket(h, \Phi) \downarrow_1 \right)$ holds. The only way to reduce $\passign{\pvar{x}}{\mathds{E}}$ is through the \textsc{Assign} rule which makes $\alpha = \actid{\iota}, \mathds{C}' = \pskip, s' = s[\pvar{x} \mapsto v], p' = p, h' = h$ where $v = \llbracket \mathds{E} \rrbracket_s$. In a similar way we can reduce $(h, s, \passign{\pvar{x}}{\mathds{E}}) \tred (h, s[\pvar{x} \mapsto v], \pskip)$ through the \textsc{AtAssign} rule. \\
	
	\textit{Base case 3}: $\pderef{\pvar{x}}{\mathds{E}} \in \mathsf{Cmd}$
	
	\textit{To show}: $\pred{cAtom}{\pderef{\pvar{x}}{\mathds{E}}}$
	
	For arbitrary $\iota, s, s', p, p', \Phi, h, h', \mathds{C}', \alpha$ we assume that $(s, p, \pderef{\pvar{x}}{\mathds{E}}) \xrightarrow{\alpha} (s', p', \mathds{C}') \land h' \in \left( \llbracket \alpha \rrbracket(h, \Phi) \downarrow_1 \right)$ holds. The only way to reduce $\pderef{\pvar{x}}{\mathds{E}}$ is through the \textsc{Read} rule which makes $\mathds{C}' = \pskip, h' = h, s' = s[\pvar{x} \mapsto v], \alpha = \actread{\iota}{k}{v}$ where $k = \llbracket \mathds{E} \rrbracket_s$ and $v = h(k)$. In a similar way we can reduce $(h, s, \pderef{\pvar{x}}{\mathds{E}}) \tred (h, s[\pvar{x} \mapsto v], \pskip)$ through the \textsc{AtRead} rule. \\
	
	\textit{Base case 4}: $\palloc{\pvar{x}}{\mathds{E}} \in \mathsf{Cmd}$
	
	\textit{To show}: $\pred{cAtom}{\palloc{\pvar{x}}{\mathds{E}}}$
	
	For arbitrary $\iota, s, s', p, p', \Phi, h, h', \mathds{C}', \alpha$ we assume that $(s, p, \palloc{\pvar{x}}{\mathds{E}}) \xrightarrow{\alpha} (s', p', \mathds{C}') \land h' \in \left( \llbracket \alpha \rrbracket(h, \Phi) \downarrow_1 \right)$ holds. The only way to reduce $\palloc{\pvar{x}}{\mathds{E}}$ is through the \textsc{Alloc} rule which makes $\mathds{C}' = \pskip, h' = h[l \mapsto 0]\ldots[l + n - 1 \mapsto 0], s' = s[\pvar{x} \mapsto l], \alpha = \actalloc{\iota}{n}{l}$ where $n = \llbracket \mathds{E} \rrbracket_s$. In a similar way we can reduce $(h, s, \palloc{\pvar{x}}{\mathds{E}}) \tred (h[l \mapsto 0]\ldots[l + n - 1 \mapsto 0], s[\pvar{x} \mapsto l], \pskip)$ through the \textsc{AtAlloc} rule. \\
	
	\textit{Base case 5}: $\pmutate{\mathds{E}_1}{\mathds{E}_2} \in \mathsf{Cmd}$
	
	\textit{To show}: $\pred{cAtom}{\pmutate{\mathds{E}_1}{\mathds{E}_2}}$
	
	For arbitrary $\iota, s, s', p, p', \Phi, h, h', \mathds{C}', \alpha$ we assume that $(s, p, \pmutate{\mathds{E}_1}{\mathds{E}_2}) \xrightarrow{\alpha} (s', p', \mathds{C}') \land h' \in \left( \llbracket \alpha \rrbracket(h, \Phi) \downarrow_1 \right)$ holds. The only way to reduce $\pmutate{\mathds{E}_1}{\mathds{E}_2}$ is through the \textsc{Write} rule which makes $\mathds{C}' = \pskip, h' = h[k \mapsto v], s' = s, \alpha = \actwrite{\iota}{k}{v}$ where $k = \llbracket \mathds{E}_1 \rrbracket_s, v = \llbracket \mathds{E}_2 \rrbracket_s$.  In a similar way we can reduce $(h, s, \pmutate{\mathds{E}_1}{\mathds{E}_2}) \tred (h[k \mapsto v], s, \pskip)$ through the \textsc{AtWrite} rule. \\
	
	\textit{Inductive case 1}: $\mathds{C}_1 ; \mathds{C}_2 \in \mathsf{Cmd}$
	
	\textit{Inductive hypothesis}: $\pred{cAtom}{\mathds{C}_1} \land \pred{cAtom}{\mathds{C}_2}$
	
	\textit{To show}: $\pred{cAtom}{\mathds{C}_1 ; \mathds{C}_2}$
	
	For arbitrary $\iota, s, s', p, p', \Phi, h, h', \mathds{C}', \alpha$ we assume that $(s, p, \mathds{C}_1 ; \mathds{C}_2) \xrightarrow{\alpha} (s', p', \mathds{C}') \land h' \in \left( \llbracket \alpha \rrbracket(h, \Phi) \downarrow_1 \right)$ holds. There are two possible ways to reduce $\mathds{C}_1 ; \mathds{C}_2$.
	\begin{enumerate}
	\item When $\mathds{C}_1 = \pskip$, we can reduce $(s, p, \pskip ; \mathds{C}_2) \xrightarrow{\actid{\iota}} (s, p, \mathds{C}_2)$ through the \textsc{SeqSkip} rule, therefore $\mathds{C}' = \mathds{C}_2$. We can do the same using the \textsc{AtSeqSkip} rule by reducing $(h, s, \pskip ; \mathds{C}_2) \tred (h, s, \mathds{C}_2)$.
	\item When $\mathds{C}_1 \neq \pskip$, we can reduce $(s, p, \mathds{C}_1 ; \mathds{C}_2) \xrightarrow{\alpha} (s', p', \mathds{C}_1' ; \mathds{C}_2)$ through the \textsc{SeqSkip} rule, making $\mathds{C}' = \mathds{C}_1'; \mathds{C}_2$, by running $(s, p, \mathds{C}_1) \xrightarrow{\alpha} (s', p', \mathds{C}_1')$. By induction hypothesis on $\mathds{C}_1$ we obtain that $(h, s, \mathds{C}_1) \tred (h', s', \mathds{C}_1')$ which we can combine with rule \textsc{AtSeq} to obtain $(h, s, \mathds{C}_1 ; \mathds{C}_2) \tred (h', s', \mathds{C}_1' ; \mathds{C}_2)$. \\
	\end{enumerate}
	
	\textit{Inductive case 2}: $\pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2} \in \mathsf{Cmd}$
	
	\textit{Inductive hypothesis}: $\pred{cAtom}{\mathds{C}_1} \land \pred{cAtom}{\mathds{C}_2}$
	
	\textit{To show}: $\pred{cAtom}{\pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}}$
	
	For arbitrary $\iota, s, s', p, p', \Phi, h, h', \mathds{C}', \alpha$ we assume that $(s, p, \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}) \xrightarrow{\alpha} (s', p', \mathds{C}') \land h' \in \left( \llbracket \alpha \rrbracket(h, \Phi) \downarrow_1 \right)$ holds. There are two possible ways to reduce $\pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}$ for $b = \llbracket \mathds{B} \rrbracket_{s}^{\textsc{b}}$.
	\begin{enumerate}
	\item When $b = \top$, we can reduce $(s, p, \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}) \xrightarrow{\actid{\iota}} (s, p, \mathds{C}_1)$ through the \textsc{CondT} rule. It is possible to do the same using the \textsc{AtCondT} rule to get $(h, s, \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}) \tred (h, s, \mathds{C}_1)$.
	\item When $b = \bot$, we can reduce $(s, p, \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}) \xrightarrow{\actid{\iota}} (s, p, \mathds{C}_2)$ through the \textsc{CondF} rule. It is possible to do the same using the \textsc{AtCondF} rule to get $(h, s, \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}) \tred (h, s, \mathds{C}_2)$.
	\end{enumerate}
	
	\textit{Inductive case 3}: $\ploop{\mathds{B}}{\mathds{C}} \in \mathsf{Cmd}$
	
	\textit{Inductive hypothesis}: $\pred{cAtom}{\mathds{C}}$
	
	\textit{To show}: $\pred{cAtom}{\ploop{\mathds{B}}{\mathds{C}}}$
	
	For arbitrary $\iota, s, s', p, p', \Phi, h, h', \mathds{C}', \alpha$ we assume that $(s, p, \ploop{\mathds{B}}{\mathds{C}}) \xrightarrow{\alpha} (s', p', \mathds{C}') \land h' \in \left( \llbracket \alpha \rrbracket(h, \Phi) \downarrow_1 \right)$ holds. There are two possible ways to reduce $\ploop{\mathds{B}}{\mathds{C}}$ for $b = \llbracket \mathds{B} \rrbracket_{s}^{\textsc{b}}$.
	\begin{enumerate}
	\item When $b = \top$, we can reduce $(s, p, \ploop{\mathds{B}}{\mathds{C}}) \xrightarrow{\actid{\iota}} (s, p, \mathds{C} ; \ploop{\mathds{B}}{\mathds{C}})$ through the \textsc{LoopT}. In a similar way we can reduce $(h, s, \ploop{\mathds{B}}{\mathds{C}}) \tred (h, s, \mathds{C} ; \ploop{\mathds{B}}{\mathds{C}})$ via the \textsc{AtLoopT} rule.
	\item When $b = \bot$, we can reduce $(s, p, \ploop{\mathds{B}}{\mathds{C}}) \xrightarrow{\actid{\iota}} (s, p, \pskip)$ through the \textsc{LoopF}. In a similar way we can reduce $(h, s, \ploop{\mathds{B}}{\mathds{C}}) \tred (h, s, \pskip)$ via the \textsc{AtLoopF} rule.
	\end{enumerate}
	\end{proof}
	}
\end{lem}

\begin{lem}
	\label{ref:aseq}
	\[
		\forall h, h', \mathds{P}_1, \mathds{P}_2 \ldotp
		(h, \mathds{P}_1) \tred^* (h', \pskip) \implies 
		(h, \mathds{P}_1; \mathds{P}_2) \tred^* (h', \pskip; \mathds{P}_2)
	\]
	
	{\parindent0pt
	\begin{proof}
	We proceed by induction on $n$, i.e. the number of reduction steps in $\tred^*$.
	
	\textit{Base case}: $n = 0$
	
	\textit{To show}: 
	\[
		\forall h, h', \mathds{P}_1, \mathds{P}_2 \ldotp
		(h, \mathds{P}_1) \tred^0 (h', \pskip) \implies 
		(h, \mathds{P}_1; \mathds{P}_2) \tred^* (h', \pskip; \mathds{P}_2)
	\]
	We assume $(h, \mathds{P}_1) \tred^0 (h', \pskip)$ holds and given it is a zero-step reduction, the only possible case is for $\mathds{P}_1 = \pskip$. Therefore $(h, \pskip) \tred^0 (h', \pskip)$ where $h = h'$. Now for $m = 0$ we have $(h, \pskip; \mathds{P}_2) \tred^0 (h', \pskip; \mathds{P}_2)$ given that $\tred^*$ is a reflexive relation, again for $h = h'$. \\
	
	\textit{Inductive case}: For some arbitrary $n > 0$
	
	\textit{Inductive hypothesis}: Assume the property holds for all programs $\mathds{P}$ that terminate in $n$ steps.
	\[
		\forall h, h', \mathds{P}, \mathds{P}_2 \ldotp
		(h, \mathds{P}) \tred^n (h', \pskip) \implies 
		(h, \mathds{P}; \mathds{P}_2) \tred^* (h', \pskip; \mathds{P}_2)
	\]
	\textit{To show}:
	\[
		\forall h, h', \mathds{P}_1, \mathds{P}_2 \ldotp
		(h, \mathds{P}_1) \tred^{n+1} (h', \pskip) \implies 
		(h, \mathds{P}_1; \mathds{P}_2) \tred^* (h', \pskip; \mathds{P}_2)
	\]
	We assume $(h, \mathds{P}_1) \tred^{n+1} (h', \pskip)$ holds which implies that there exists some program $\mathds{P}_n$ and storage $h_n$ such that $(h, \mathds{P}_1) \tred (h_n, \mathds{P}_n)$ and $(h_n, \mathds{P}_n) \tred^n (h', \pskip)$. The former is the premiss of rule \textsc{PSeq} for the conclusion $(h, \mathds{P}_1; \mathds{P}_2) \tred (h_n, \mathds{P}_n; \mathds{P}_2)$ in one step of reduction, while the latter gives us $(h_n, \mathds{P}_n; \mathds{P}_2) \tred^* (h', \pskip ; \mathds{P}_2)$ by inductive hypothesis. From the two combined we conclude that the property holds for $n + 1$ steps.
	\end{proof}
	}
\end{lem}

\begin{lem}
	\label{ref:2seq}
	\begin{gather*}
		\forall h, h', S, S', \Phi, \mathds{P}_1, \mathds{P}_2 \ldotp \\
		(h, \Phi, S, \mathds{P}_1; \mathds{P}_2) \rightarrow^* (h', \emptyset, S', \pskip; \mathds{P}_2)
		\implies
		(h, \Phi, S, \mathds{P}_1) \rightarrow^* (h', \emptyset, S', \pskip)
	\end{gather*}
	
	{\parindent0pt
	\begin{proof}
	The proof is done by induction on $n$, i.e. the number of reduction steps in $\rightarrow^*$.
	
	\textit{Base case}: $n = 0$
	
	\textit{To show}:
	\begin{gather*}
		\forall h, h', S, S', \Phi, \mathds{P}_1, \mathds{P}_2 \ldotp \\
		(h, \Phi, S, \mathds{P}_1; \mathds{P}_2) \rightarrow^0 (h', \emptyset, S', \pskip; \mathds{P}_2)
		\implies
		(h, \Phi, S, \mathds{P}_1) \rightarrow^* (h', \emptyset, S', \pskip)
	\end{gather*}
	We assume that $(h, \Phi, S, \mathds{P}_1; \mathds{P}_2) \rightarrow^0 (h', \emptyset, S', \pskip; \mathds{P}_2)$ holds. A zero-step reduction means that it must be the case that $\mathds{P}_1 = \pskip$. Therefore $(h, \Phi, S, \pskip; \mathds{P}_2) \rightarrow^0 (h', \emptyset, S', \pskip; \mathds{P}_2)$ for $h = h', \Phi = \emptyset, S = S'$. \\
	
	\textit{Inductive case}: For some arbitrary $n > 0$
	
	\textit{Inductive hypothesis}: Assume the property holds for all programs $\mathds{P}; \mathds{P}_2$ that reduce to $\pskip$ in $n$ steps.
	\begin{gather*}
		\forall h, h', S, S', \Phi, \mathds{P}, \mathds{P}_2 \ldotp \\ 
		(h, \Phi, S, \mathds{P}; \mathds{P}_2) \rightarrow^n (h', \emptyset, S', \pskip; \mathds{P}_2)
		\implies
		(h, \Phi, S, \mathds{P}) \rightarrow^* (h', \emptyset, S', \pskip)
	\end{gather*}
	
	\textit{To show}:
	\begin{gather*}
		\forall h, h', S, S', \Phi, \mathds{P}_1, \mathds{P}_2 \ldotp \\
		(h, \Phi, S, \mathds{P}_1; \mathds{P}_2) \rightarrow^{n+1} (h', \emptyset, S', \pskip; \mathds{P}_2)
		\implies
		(h, \Phi, S, \mathds{P}_1) \rightarrow^* (h', \emptyset, S', \pskip)
	\end{gather*}
	
	We assume that $(h, \Phi, S, \mathds{P}_1; \mathds{P}_2) \rightarrow^{n+1} (h', \emptyset, S', \pskip; \mathds{P}_2)$ holds which means there must be a program $\mathds{P}_n$ and state $h_n, \Phi_n, S_n$ such that $(h, \Phi, S, \mathds{P}_1; \mathds{P}_2) \xrightarrow{\alpha} (h_n, \Phi_n, S_n, \mathds{P}_n; \mathds{P}_2)$ and $(h_n, \Phi_n, S_n, \mathds{P}_n; \mathds{P}_2) \rightarrow^{n} (h', \emptyset, S', \pskip ; \mathds{P}_2)$. From the former and rule \textsc{PSeq} we obtain that $(h, \Phi, S, \mathds{P}_1) \xrightarrow{\alpha} (h_n, \Phi_n, S_n, \mathds{P}_n)$ and from the latter we get that $(h_n, \Phi_n, S_n, \mathds{P}_n) \rightarrow^* (h', \emptyset, S', \pskip)$ by inductive hypothesis. From the two combined we conclude that the property holds for $n + 1$ steps.
	\end{proof}
	}
\end{lem}

\begin{lem}
	\label{ref:phiemp}
	\[
	\forall h, h', S, S', \Phi, \Phi', \mathds{P} \ldotp
	(h, \Phi, S, \mathds{P}) \rightarrow^* (h', \Phi', S', \pskip) \implies \Phi' \equiv \emptyset
	\]
\end{lem}

\begin{lem}
	\label{lem:sameSys}
	\begin{gather*}
		\forall h, \Phi, S, \mathds{P}, \mathds{P}' \ldotp
		(h, \Phi, S, \mathds{P}) \xrightarrow{\actprog} (h', \Phi', S', \mathds{P}')
			\implies \\
		(h, \mathds{P}) \tred (h', \mathds{P}') \land h' = h \land \Phi' = \Phi \land S' = S
	\end{gather*}
	\begin{proof}
	Let's pick arbitrary $h \in \mathsf{Storage}, \Phi \in \mathsf{LMan}, S \in \mathsf{TState}, \mathds{P}, \mathds{P}' \in \mathsf{Prog}$. We now assume that the following holds:
	\begin{gather}
		\label{lem:sameSys1} (h, \Phi, S, \mathds{P}) \xrightarrow{\actprog} (h, \Phi, S, \mathds{P}')
	\end{gather}
	Given that from (\ref{lem:sameSys1}) we know that $\mathds{P}$ reduced to $\mathds{P'}$ through $\actprog$ we will proceed with a case-by-case analysis on the structure of $\mathds{P}$.
	\begin{itemize}
		\item If $\mathds{P} = \pskip ; \mathds{P}''$ for some $\mathds{P}'' \in \mathsf{Prog}$, then from the \textsc{PSeqSkip} rule we get that $\mathds{P}' = \mathds{P}'', h' = h, \Phi' = \Phi, S' = S$. From the \textsc{AtPSeqSkip} rule we know that as part of the atomic semantics, $(h, \mathds{P})$ will also reduce to $(h, \mathds{P}'')$.
		
		\item If $\mathds{P} = \pskip \| \pskip$ then from the \textsc{ParEnd} rule we get that $\mathds{P}' = \pskip, h' = h, \Phi' = \Phi, S' = S$. From the \textsc{AtParEnd} rule we know that as part of the atomic semantics, $(h, \mathds{P})$ will also reduce to $(h, \pskip)$.
		
		\item If $\mathds{P} = \mathds{P}_0^*$ for some $\mathds{P}_0 \in \mathsf{Prog}$, then from the \textsc{Loop} rule we get that $\mathds{P}' = \pskip + (\mathds{P}_0;\mathds{P}_0^*), h' = h, \Phi' = \Phi, S' = S$. From the \textsc{AtLoop} rule we know that as part of the atomic semantics, $(h, \mathds{P})$ will also reduce to $(h, \pskip + (\mathds{P}_0;\mathds{P}_0^*))$.
		
		\item $\mathds{P} = \mathds{P}_1 + \mathds{P}_2$ for some $\mathds{P}_1, \mathds{P}_2 \in \mathsf{Prog}$, then we can apply one of two reduction rules:
			\begin{itemize}
				\item If $\mathsf{sys}$ was generated by the \textsc{ChoiceL} rule then $\mathds{P}' = \mathds{P}_1, h' = h, \Phi' = \Phi, S' = S$ and through the \textsc{AtChoiceL} rule $(h, \mathds{P})$ will also reduce to $(h, \mathds{P}_1)$.
				\item If $\mathsf{sys}$ was generated by the \textsc{ChoiceR} rule then $\mathds{P}' = \mathds{P}_2, h' = h, \Phi' = \Phi, S' = S$ and through the \textsc{AtChoiceR} rule $(h, \mathds{P})$ will also reduce to $(h, \mathds{P}_2)$.
			\end{itemize}
	\end{itemize}
	\end{proof}
\end{lem}