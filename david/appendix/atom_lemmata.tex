\section{Auxiliary Lemmata for Equivalence}

\begin{lem}
	\label{lem:lockAbsent}
	Lock and unlock operations done by a transaction on items which it does not read or write can be removed without affecting the program or the global state.
	\begin{gather*}
		\forall \tau, \tau', h, h', \Phi, S, \mathds{P}, n, n', \iota, k, \kappa, x, y \ldotp
			\\
		\pred{tgen}{\tau, h, h', \Phi, S, \mathds{P}} \land  \pred{absent}{\iota, k, \tau} \land x = (\actlock{\iota}{k}{\kappa}, n) \land y = (\actunlock{\iota}{k}, n') \\ \land\ x \in \tau \land y \in \tau
		\land \tau' = \tau \setminus \{ x, y \}
			\implies
		\pred{tgen}{\tau', h, h', \Phi, S, \mathds{P}}
	\end{gather*}
	\begin{proof}
	Let's pick arbitrary $\tau, \tau' \in [\mathsf{Act} \times \mathds{N}], h, h' \in \mathsf{Storage}, \Phi \in \mathsf{LMan}, S \in \mathsf{TState}, \mathds{P} \in \mathds{Prog}, n, n' \in \mathds{N}, \iota \in \mathsf{Tid}, k \in \mathsf{Key}, \kappa \in \mathsf{Lock}, x, y \in \mathsf{Act} \times \mathds{N}$. We now assume that the following holds:
	\begin{gather*}
		\pred{tgen}{\tau, h, h', \Phi, S, \mathds{P}} \land  \pred{absent}{\iota, k, \tau} \land x = (\actlock{\iota}{k}{\kappa}, n) \land y = (\actunlock{\iota}{k}, n') \\ \land\ x \in \tau \land y \in \tau
		\land \tau' = \tau \setminus \{ x, y \}
	\end{gather*}
	From Proposition \ref{prop:2phase} we obtain that $\tau \vDash x < y$. From the definition of $\mathsf{tgen}$ and the fact that both $x$ and $y$ are in $\tau$ it follows that $\kappa \geq \textsc{s}$ and:
	\begin{gather}
		(h, \Phi, S, \mathds{P}) \rightarrow^* (h_1, \Phi_1, S_1, \mathds{P}_1) \xrightarrow{\actlock{\iota}{k}{\kappa}} (h_1', \Phi_1', S_1', \mathds{P}_1') \\ \rightarrow^* (h_2, \Phi_2, S_2, \mathds{P}_2) \xrightarrow{\actunlock{\iota}{k}} (h_2', \Phi_2', S_2', \mathds{P}_2') \rightarrow^* (h', \emptyset, S', \pskip)
	\end{gather}
	From the semantic interpretation of $\mathsf{lock}$ and $\mathsf{unlock}$, we know that it is the case that $h_1' = h_1, S_1' = S_1, \mathds{P}_1' = \mathds{P}_1, h_2' = h_2, S_2' = S_2, \mathds{P}_2' = \mathds{P}_2$ and $\Phi_1' = \Phi_1[k \mapsto (\{\iota\} \cup I, \kappa)], \Phi_2' = \Phi_2[k \mapsto (I', \kappa')]$ for $I, I' \in \mathcal{P}(\mathsf{Tid})$ such that $\iota \not\in I'$ and $\kappa' \leq \textsc{s}$. From the assumption that $\pred{absent}{\iota, k, \tau}$ holds, we know there is no read or write action on $k$ done by $\iota$ happening in $(h_1', \Phi_1', S_1', \mathds{P}_1') \rightarrow^* (h_2, \Phi_2, S_2, \mathds{P}_2)$ meaning that actions which need a presence of $\iota$'s lock acquisition on $k$ to succeed (i.e. read and write) are not there. From Lemma \ref{lem:alman} we obtain that all actions that are part of the sequence of reductions $(h_1', \Phi_1', S_1', \mathds{P}_1') \rightarrow^* (h_2, \Phi_2, S_2, \mathds{P}_2)$ will succesfully reduce with the $\Phi_1$ lock manager not containing $\iota$ as an owner for $k$. It follows that, for $(\alpha, n+1) \in \tau$ and $(\alpha', n'+1) \in \tau$:
	\begin{gather}
		\label{lem:spur1} (h, \Phi, S, \mathds{P}) \rightarrow^* (h_1, \Phi_1, S_1, \mathds{P}_1) \xrightarrow{\alpha} (h_1'', \Phi_1'', S_1'', \mathds{P}_1'')
			\\
		\label{lem:spur2} \rightarrow^* (h_2'', \Phi_2'', S_2'',\mathds{P}_2'') \xrightarrow{\alpha'} (h_2, \Phi_2, S_2, \mathds{P}_2) \rightarrow^* (h', \emptyset, S', \pskip)
	\end{gather}
	From the initial assumption we also know that $\tau' = \tau \setminus \{ x, y \}$ meaning that $\tau'$ has all of $\tau$'s actions a part from the ones at position $n$ and $n'$. As a consequence we have that by following $\tau'$ up to (and not including) position $n$ we have $(h, \Phi, S, \mathds{P}) \rightarrow^* (h_1, \Phi_1, S_1, \mathds{P}_1)$. Skipping the operation at position $n$ which is not present in $\tau'$, we proceed with the one in position $n + 1$ all the way to (and not including) the one in position $n'$ to get by (\ref{lem:spur1}) and (\ref{lem:spur2}) that $(h_1, \Phi_1, S_1, \mathds{P}_1) \xrightarrow{\alpha} (h_1'', \Phi_1'', S_1'', \mathds{P}_1'') \rightarrow^* (h_2'', \Phi_2'', S_2'',\mathds{P}_2'')$ holds. Now we apply the action from position $n' + 1$ to the end in $\tau'$ to obtain $(h_2'', \Phi_2'', S_2'',\mathds{P}_2'') \xrightarrow{\alpha'} (h_2, \Phi_2, S_2, \mathds{P}_2) \rightarrow^* (h', \emptyset, S', \pskip)$. From the definition of $\mathsf{tgen}$ we can state that $\pred{tgen}{\tau', h, h', \Phi, S, \mathds{P}}$ holds as needed.
	\end{proof}
\end{lem}

\begin{lem}
	\label{lem:lockRedundant}
	Redundant exclusive lock operations present in a trace, can be converted to the corresponding shared equivalent without affecting the end storage.
	\begin{gather*}
		\forall \tau, \tau', h, h', \Phi, S, \mathds{P}, n, \iota, k, x \ldotp
			\\
		\pred{tgen}{\tau, h, h', \Phi, S, \mathds{P}} \land \pred{redundant}{\iota, k, \textsc{x}, \tau} \land x = (\actlock{\iota}{k}{\textsc{x}}, n)
		\\ \land x \in \tau
		\land \tau' = \pred{swap}{\tau, x, (\actlock{\iota}{k}{\textsc{s}}, n)}
			\implies
		\pred{tgen}{\tau', h, h', \Phi, S, \mathds{P}}
	\end{gather*}
	\begin{proof}
	Let's pick arbitrary $\tau, \tau' \in [\mathsf{Act} \times \mathds{N}], h, h' \in \mathsf{Storage}, \Phi \in \mathsf{LMan}, S \in \mathsf{TState}, \mathds{P} \in \mathds{Prog}, n \in \mathds{N}, \iota \in \mathsf{Tid}, k \in \mathsf{Key}, x \in \mathsf{Act} \times \mathds{N}$. We now assume that the following holds:
	\begin{gather}
		\label{lem:lockRedundant1}
		\pred{tgen}{\tau, h, h', \Phi, S, \mathds{P}}
		\land x = (\actlock{\iota}{k}{\textsc{x}}, n)
		\land x \in \tau \\
		\label{lem:lockRedundant2}
		\land\ \pred{redundant}{\iota, k, \textsc{x}, \tau}
		\land \tau' = \pred{swap}{\tau, x, (\actlock{\iota}{k}{\textsc{s}}, n)}
	\end{gather}
	The above means that by following the actions in $\tau$ we can generate the storage $h'$ starting from the $h, \Phi, S, \mathds{P}$ state and that the same $\tau$ includes an exclusive lock operation $x = \actlock{\iota}{k}{\textsc{x}}$ done by transaction $\iota$ on storage key $k$ which is redundant. This means that $\iota$ never writes to $k$ as part of $\tau$. The statement also expresses that there is a trace $\tau'$ which is equivalent to $\tau$ with operation $x$ converted into $\actlock{\iota}{k}{\textsc{s}}$.
	
	From (\ref{lem:lockRedundant1}) we know that there must be a reduction of the following shape, for $S' \in \mathsf{TState}, \alpha = x \downarrow_1$ and $\alpha' = \actunlock{\iota}{k}$:
	\begin{gather}
		\label{lem:lockRedundant3}
		\begin{array}{c}
			(h, \Phi, S, \mathds{P})
				\rightarrow^*
			(h_l, \Phi_l, S_l, \mathds{P}_l)
				\xrightarrow{\alpha}
			(h_l', \Phi_l', S_l', \mathds{P}_l')
				\rightarrow^* \\
			(h_a, \Phi_a, S_a, \mathds{P}_a)
				\xrightarrow{\dot{\alpha}}
			(h_a', \Phi_a', S_a', \mathds{P}_a')
				\rightarrow^* \\
			(h_u, \Phi_u, S_u, \mathds{P}_u)
				\xrightarrow{\alpha'}
			(h_u', \Phi_u', S_u', \mathds{P}_u')
				\rightarrow^*
			(h', \emptyset, S', \pskip)
		\end{array}
	\end{gather}
	Given the fact that $x$ acquires an exclusive lock on $k$, it must be the case that $\Phi_l'(k) = (\{\iota\}, \textsc{x})$. From (\ref{lem:lockRedundant3}) we obtain that all actions that accesses $k$ done by transaction $\iota$, i.e. $\dot{\alpha}$, must occur in the reduction sequence:
	\begin{gather}
		\label{lem:lockRedundant4}
		(h_l', \Phi_l', S_l', \mathds{P}_l') \rightarrow^* (h_u, \Phi_u, S_u, \mathds{P}_u)
	\end{gather}
	Let's now convert action $\alpha$ into $\actlock{\iota}{k}{\textsc{s}}$, making $\Phi_l'(k) = (\{\iota\}, \textsc{s})$. From Lemma \ref{lem:alman} we know that the only actions in the reductions (\ref{lem:lockRedundant4}) that need the presence of a lock introduced on $k$ are $\dot{\alpha} \in \{ \actread{\iota}{k}{v}, \actwrite{\iota}{k}{v}, \actunlock{\iota}{k} \}$. Given that $\alpha' = \actunlock{\iota}{k}$ and form Lemma \ref{lem:noTwoUnlock} a single transaction can only unlock a particular cell once, there cannot be an unlock operation on $k$ which happens as part of the sequence of reductions in (\ref{lem:lockRedundant4}). It follows that $\dot{\alpha} \neq \actunlock{\iota}{k}$ and $\Phi_a(k) = \Phi_l' = (\{\iota\}, \textsc{s})$.
	\begin{enumerate}
		\item From (\ref{lem:lockRedundant2}) and the definition of $\mathsf{redundant}$ we know that $\dot{\alpha}$ cannot be $\actwrite{\iota}{k}{v}$.
		
		\item If $\dot{\alpha} = \actread{\iota}{k}{v}$ then all it is required for this transition to succeed is for $k \in \pred{dom}{h}$ which must hold from the fact that $\dot{\alpha}$ suceeded in $\tau$ and $\iota \in I$ for $(I, \kappa) = \Phi_a(k)$ which we know holds since $\Phi_a(k) = (\{\iota\}, \textsc{s}$.
	\end{enumerate}
	We have proven that we can reach program state $(h_u, \Phi_u, S_u, \mathds{P}_u)$ even by replacing the original $\alpha$ with $\actlock{\iota}{k}{\textsc{s}}$, i.e. by following the actions in $\tau'$. Now $\alpha'$ can always reduce since it needs $\iota \in I$ for $\Phi_u(k) = (I, \textsc{s})$ which will be the case since the new $\alpha$ added a lock on $k$ and no unlock operation removed it since. From program state $(h_u', \Phi_u', S_u', \mathds{P}_u')$ we can follow the rest of the actions in $\tau'$ which in this part will be equivalent to the ones in $\tau$ to reach the final state $(h', \emptyset, S', \pskip)$. From the definition of $\mathsf{tgen}$ the following must hold:
	\[
		\pred{tgen}{\tau', h, h', \Phi, S, \mathds{P}}
	\]
	\end{proof}
\end{lem}

\begin{lem}
	\label{lem:alman}
	A lock on an item is not needed for any reductions a part from a read, a write or an unlock action performed by the same transaction on the same item.
	\begin{gather*}
		\forall \mathds{P}, \mathds{P}', h, h', \Phi, \Phi', S, S', \alpha, i, k, v, I, \kappa \ldotp \\
		(h, \Phi, S, \mathds{P}) \xrightarrow{\alpha} (h', \Phi', S', \mathds{P}')
			\land
		(\{i\} \uplus I, \kappa) = \Phi(k)
			\land \\
		\alpha \not\in \{ \actread{i}{k}{v}, \actwrite{i}{k}{v}, \actunlock{i}{k} \}
			\implies
		\exists \Phi_m, \Phi_m', I', \kappa', \kappa'' \ldotp \\
		(h, \Phi_m, S, \mathds{P}) \xrightarrow{\alpha} (h', \Phi_m', S, \mathds{P}')
			\land
		\Phi_m = \Phi[k \mapsto (I, \kappa')]
			\land
		\Phi_m' = \Phi'[k \mapsto (I', \kappa'')]
			\land
		\kappa' \leq \textsc{s}
	\end{gather*}
	\begin{proof}
	Let's pick arbitrary $\mathds{P}, \mathds{P}' \in \mathsf{Prog}, h, h' \in \mathsf{Storage}, \Phi, \Phi' \in \mathsf{LMan}, S, S' \in \mathsf{TState}, \alpha \in \mathsf{Act}, i \in \mathsf{Tid}, k \in \mathsf{Key}, v \in \mathsf{Val}, I \in \mathcal{P}(\mathsf{Tid}), \kappa \in \mathsf{Lock}$. We now assume that the following holds:
	\begin{gather}
		\label{lem:alman1}
		(h, \Phi, S, \mathds{P}) \xrightarrow{\alpha} (h', \Phi', S', \mathds{P}')
			\land
		(\{i\} \uplus I, \kappa) = \Phi(k)
			\land
		\alpha \not\in \{ \actread{i}{k}{v}, \actwrite{i}{k}{v} \}
	\end{gather}
	From (\ref{lem:alman1}) we directly obtain that $\kappa \geq \textsc{s}$ given that $i$ is in the owners' set for item $k$. The proof proceeds with a case-by-case analysis on $\alpha$.
	\begin{itemize}
		\item If $\alpha = \actprog$, $\alpha = \actid{\iota}$ or $\alpha = \actalloc{\iota}{n}{l}$ for some $\iota \in \mathsf{Tid}, n \in \mathds{N}, l \in \mathsf{Key}$, then the result trivially follows given that in these cases $\alpha$ has no requirementes on $\Phi$ to succesfully reduce.
		
		\item If $\alpha = \actread{j}{k'}{v'}$ for $j \in \mathsf{Tid}, k' \in \mathsf{Key}, v' \in \mathsf{Val}$ then from (\ref{lem:alman1}) we know that $i \neq j$. Next we consider the following two cases:
			\begin{itemize}
				\item If $k = k'$ then from (\ref{lem:alman1}) we obtain that, given the $\alpha$ action has succesfully reduced, $\kappa = \textsc{s}$ and $j \in I$. Therefore we can find $\kappa' = \textsc{s}, \kappa'' = \textsc{s}$ and $I' = I$.
				\item If $k \neq k'$ then $\alpha$ has no requirement on $\Phi(k)$ to succesfully reduce and the result follows.
			\end{itemize}
			
		\item If $\alpha = \actwrite{j}{k'}{v'}$ for $j \in \mathsf{Tid}, k' \in \mathsf{Key}, v' \in \mathsf{Val}$ then from (\ref{lem:alman1}) we know that $i \neq j$. Next we consider the following two cases:
			\begin{itemize}
				\item If $k = k'$ then it is not possible that $\alpha$ succesfully reduced since from (\ref{lem:alman1}) we know that $i$ was in the owners set for key $k$, then it must be the case that $k \neq k'$.
				\item If $k \neq k'$ then $\alpha$ has no requirement on $\Phi(k)$ to succesfully reduce and the result follows.
			\end{itemize}
			
		\item If $\alpha = \actlock{j}{k'}{\kappa_j}$ for some $j \in \mathsf{Tid}, k' \in \mathsf{Key}, \kappa_j \in \mathsf{Lock}$.
			\begin{itemize}
				\item If $k \neq k'$ then $\alpha$ has no requirement on $\Phi(k)$ to succesfully reduce and the result follows.
				\item If $k = k'$ and $i \neq j$ then from (\ref{lem:alman1}) we know that $\alpha$ succesfully reduced, and therefore $\kappa = \textsc{s}$ and $\kappa_j = \textsc{s}$. This also implies that we can find $\kappa' = \textsc{s}, I' = I \cup \{j\}$ and $\kappa'' = \textsc{s}$.
				\item If $k = k'$ and $i = j$ then given that $\Phi(k)$ already had $i$ as part of the owners, it must be the case that $\kappa = \textsc{s}, I = \emptyset$ and $\kappa_j = \textsc{x}$ in order for $\alpha$ to reduce as imposed by (\ref{lem:alman1}). It follows that we can find $\kappa' = \textsc{u}, I' = \{i\}$ and $\kappa'' = \textsc{x}$.
			\end{itemize}
			
		\item If $\alpha = \actunlock{j}{k'}$ for $j \in \mathsf{Tid}, k' \in \mathsf{Key}$ then from (\ref{lem:alman1}) we know that $i \neq j$. Next we consider the following two cases:
			\begin{itemize}
				\item If $k \neq k'$ then $\alpha$ has no requirement on $\Phi(k)$ to succesfully reduce and the result follows.
				\item If $k = k'$ then from (\ref{lem:alman1}) we know that $\alpha$ succesfully reduced meaning that $i$ and $j$ were holding the lock at the same time, making $\kappa = \textsc{s}, \kappa' = \textsc{s}, \kappa'' = \textsc{s}$ and $I' = I \setminus \{ i, j \}$.
			\end{itemize}
	\end{itemize}
	\end{proof}
\end{lem}

\begin{lem}
	\label{lem:noTwoUnlock}
	A transaction cannot unlock a particular item twice.
	\begin{gather*}
		\forall h, h', h'', \Phi, \Phi'', S, S', S'', \mathds{P}, \mathds{P}'' \ldotp \\
		(h, \Phi, S, \mathds{P})
			\xrightarrow{\actunlock{\iota}{k}}
		(h'', \Phi'', S'', \mathds{P}'')
			\rightarrow^*
		(h', \emptyset, S', \pskip) \\
			\implies
		\lnot \exists h_u, h_u', \Phi_u, \Phi_u', S_u, S_u', \mathds{P}_u, \mathds{P}_u'
			\ldotp \\
		(h'', \Phi'', S'', \mathds{P}'')
			\rightarrow^*
		(h_u, \Phi_u, S_u, \mathds{P}_u)
			\xrightarrow{\actunlock{\iota}{k}}
		(h_u', \Phi_u', S_u', \mathds{P}_u')
	\end{gather*}
	Let's pick arbitrary $h, h', h'' \in \mathsf{Storage}, \Phi, \Phi'' \in \mathsf{LMan}, S, S', S'' \in \mathsf{TState}, \mathds{P}, \mathds{P}'' \in \mathsf{Prog}$ and assume that the following holds:
	\begin{gather}
		\label{lem:noTwoUnlock1}
		(h, \Phi, S, \mathds{P})
			\xrightarrow{\actunlock{\iota}{k}}
		(h'', \Phi'', S'', \mathds{P}'')
			\rightarrow^*
		(h', \emptyset, S', \pskip)
	\end{gather}
	From (\ref{lem:noTwoUnlock1}) we know that for $\iota \not\in I, \kappa \leq \textsc{s}$ and $(s, p) = S(\iota)$ we have:
	\begin{gather}
		\label{lem:noTwoUnlock2}
		\Phi''(k) = (I, \kappa) \\
		\label{lem:noTwoUnlock3}
		S''(\iota) = (s, \pshrink)
	\end{gather}
	Now let's also assume that the following holds:
	\begin{gather}
		\label{lem:noTwoUnlock4}
		\begin{array}{c}
			\exists h_u, h_u', \Phi_u, \Phi_u', S_u, S_u', \mathds{P}_u, \mathds{P}_u'
				\ldotp \\
			(h'', \Phi'', S'', \mathds{P}'')
				\rightarrow^*
			(h_u, \Phi_u, S_u, \mathds{P}_u)
				\xrightarrow{\actunlock{\iota}{k}}
			(h_u', \Phi_u', S_u', \mathds{P}_u')
		\end{array}
	\end{gather}
	From (\ref{lem:noTwoUnlock4}) we know that it must be the case that $\Phi_u(k) = (\{\iota\} \uplus I', \kappa')$ for some $I' \in \mathcal{P}(\mathsf{Tid})$ and $\kappa' \geq \textsc{s}$. Then, from (\ref{lem:noTwoUnlock2}) we obtain that there must be an action $\alpha = \actlock{\iota}{k}{\kappa'}$ in the following sequence of reductions:
	\begin{gather}
		\label{lem:noTwoUnlock5}
		(h'', \Phi'', S'', \mathds{P}'') \rightarrow^* (h_u, \Phi_u, S_u, \mathds{P}_u)
	\end{gather}
	From (\ref{lem:noTwoUnlock3}) we know that at the start of the reductions in (\ref{lem:noTwoUnlock5}), $\iota$ is in the shrinking phase and cannot acquire any lock. This means that no such $\alpha$ exists and the reduction in (\ref{lem:noTwoUnlock4}) is impossible. By contradiction we obtain that the following must hold:
	\[
		\begin{array}{c}
			\lnot \exists h_u, h_u', \Phi_u, \Phi_u', S_u, S_u', \mathds{P}_u, \mathds{P}_u'
				\ldotp \\
			(h'', \Phi'', S'', \mathds{P}'')
				\rightarrow^*
			(h_u, \Phi_u, S_u, \mathds{P}_u)
				\xrightarrow{\actunlock{\iota}{k}}
			(h_u', \Phi_u', S_u', \mathds{P}_u')
		\end{array}
	\]
\end{lem}

\begin{lem}
	\label{lem:catom}
	\[
	\begin{array}{r l}
		\pred{cAtom}{\mathds{C}} \triangleq&
		\begin{array}{l}
		\forall \iota, s, s', p, p', \Phi, h, h', \mathds{C}', \alpha \ldotp \\
		(s, p, \mathds{C}) \xrightarrow{\alpha}_\iota (s', p', \mathds{C}') \land h' = \left( \llbracket \alpha \rrbracket(h, \Phi) \downarrow_1 \right) \\
		\implies
		(h, s, \mathds{C}) \tred (h', s', \mathds{C}')
		\end{array}
	\end{array}
	\]
	
	{\parindent0pt
	\begin{proof}
	$\forall \mathds{C} \in \mathsf{Cmd} \ldotp \pred{cAtom}{\mathds{C}}$ by induction on the structure of commands $\mathsf{Cmd}$. \\
	
	\textit{Base case 1}: $\pskip \in \mathsf{Cmd}$
	
	\textit{To show}: $\pred{cAtom}{\pskip}$
	
	The $\pskip$ case follows trivially since there is no possible one-step $\alpha$ reduction that involves it. \\
	
	\textit{Base case 2}: $\passign{\pvar{x}}{\mathds{E}} \in \mathsf{Cmd}$
	
	\textit{To show}: $\pred{cAtom}{\passign{\pvar{x}}{\mathds{E}}}$
	
	For arbitrary $\iota, s, s', p, p', \Phi, h, h', \mathds{C}', \alpha$ we assume that $(s, p, \passign{\pvar{x}}{\mathds{E}}) \xrightarrow{\alpha}_\iota (s', p', \mathds{C}') \land h' = \left( \llbracket \alpha \rrbracket(h, \Phi) \downarrow_1 \right)$ holds. The only way to reduce $\passign{\pvar{x}}{\mathds{E}}$ is through the \textsc{Assign} rule which makes $\alpha = \actid{\iota}, \mathds{C}' = \pskip, s' = s[\pvar{x} \mapsto v], p' = p, h' = h$ where $v = \tsem{\mathds{E}}_s^\textsc{e}$. It follows that we have all the requisites to reduce $(h, s, \passign{\pvar{x}}{\mathds{E}}) \tred (h, s[\pvar{x} \mapsto v], \pskip)$ through the \textsc{AtAssign} rule. \\
	
	\textit{Base case 3}: $\pderef{\pvar{x}}{\mathds{E}} \in \mathsf{Cmd}$
	
	\textit{To show}: $\pred{cAtom}{\pderef{\pvar{x}}{\mathds{E}}}$
	
	For arbitrary $\iota, s, s', p, p', \Phi, h, h', \mathds{C}', \alpha$ we assume that $(s, p, \pderef{\pvar{x}}{\mathds{E}}) \xrightarrow{\alpha} (s', p', \mathds{C}') \land h' = \left( \llbracket \alpha \rrbracket(h, \Phi) \downarrow_1 \right)$ holds. The only way to reduce $\pderef{\pvar{x}}{\mathds{E}}$ is through the \textsc{Read} rule which makes $\mathds{C}' = \pskip, h' = h, s' = s[\pvar{x} \mapsto v], \alpha = \actread{\iota}{k}{v}$ where $k = \tsem{\mathds{E}}_s^\textsc{e}$ and $v = h(k)$. It follows that we have all the requisites to reduce $(h, s, \pderef{\pvar{x}}{\mathds{E}}) \tred (h, s[\pvar{x} \mapsto v], \pskip)$ through the \textsc{AtRead} rule. \\
	
	\textit{Base case 4}: $\palloc{\pvar{x}}{\mathds{E}} \in \mathsf{Cmd}$
	
	\textit{To show}: $\pred{cAtom}{\palloc{\pvar{x}}{\mathds{E}}}$
	
	For arbitrary $\iota, s, s', p, p', \Phi, h, h', \mathds{C}', \alpha$ we assume that $(s, p, \palloc{\pvar{x}}{\mathds{E}}) \xrightarrow{\alpha} (s', p', \mathds{C}') \land h' = \left( \llbracket \alpha \rrbracket(h, \Phi) \downarrow_1 \right)$ holds. The only way to reduce $\palloc{\pvar{x}}{\mathds{E}}$ is through the \textsc{Alloc} rule which makes $\mathds{C}' = \pskip, h' = h[l \mapsto 0]\ldots[l + n - 1 \mapsto 0], s' = s[\pvar{x} \mapsto l], \alpha = \actalloc{\iota}{n}{l}$ where $n = \tsem{\mathds{E}}_s^\textsc{e}, n > 0$ and $\{ l, \ldots, l + n - 1\} \cap \pred{dom}{h} \equiv \emptyset$. It follows that we have all the requisites to reduce $(h, s, \palloc{\pvar{x}}{\mathds{E}}) \tred (h[l \mapsto 0]\ldots[l + n - 1 \mapsto 0], s[\pvar{x} \mapsto l], \pskip)$ through the \textsc{AtAlloc} rule. \\
	
	\textit{Base case 5}: $\pmutate{\mathds{E}_1}{\mathds{E}_2} \in \mathsf{Cmd}$
	
	\textit{To show}: $\pred{cAtom}{\pmutate{\mathds{E}_1}{\mathds{E}_2}}$
	
	For arbitrary $\iota, s, s', p, p', \Phi, h, h', \mathds{C}', \alpha$ we assume that $(s, p, \pmutate{\mathds{E}_1}{\mathds{E}_2}) \xrightarrow{\alpha} (s', p', \mathds{C}') \land h' = \left( \llbracket \alpha \rrbracket(h, \Phi) \downarrow_1 \right)$ holds. The only way to reduce $\pmutate{\mathds{E}_1}{\mathds{E}_2}$ is through the \textsc{Write} rule which makes $\mathds{C}' = \pskip, h' = h[k \mapsto v], s' = s, \alpha = \actwrite{\iota}{k}{v}$ where $k = \tsem{\mathds{E}_1}_s^\textsc{e}, v = \tsem{\mathds{E}_2}_s^\textsc{e}$ and $k \in \pred{dom}{h}$. It follows that we have all the requisites to reduce $(h, s, \pmutate{\mathds{E}_1}{\mathds{E}_2}) \tred (h[k \mapsto v], s, \pskip)$ through the \textsc{AtWrite} rule. \\
	
	\textit{Inductive case 1}: $\mathds{C}_1 ; \mathds{C}_2 \in \mathsf{Cmd}$
	
	\textit{Inductive hypothesis}: $\pred{cAtom}{\mathds{C}_1} \land \pred{cAtom}{\mathds{C}_2}$
	
	\textit{To show}: $\pred{cAtom}{\mathds{C}_1 ; \mathds{C}_2}$
	
	For arbitrary $\iota, s, s', p, p', \Phi, h, h', \mathds{C}', \alpha$ we assume that $(s, p, \mathds{C}_1 ; \mathds{C}_2) \xrightarrow{\alpha} (s', p', \mathds{C}') \land h' = \left( \llbracket \alpha \rrbracket(h, \Phi) \downarrow_1 \right)$ holds. There are two possible ways to reduce $\mathds{C}_1 ; \mathds{C}_2$.
	\begin{enumerate}
	\item When $\mathds{C}_1 = \pskip$, we can reduce $(s, p, \pskip ; \mathds{C}_2) \xrightarrow{\actid{\iota}} (s, p, \mathds{C}_2)$ through the \textsc{SeqSkip} rule, therefore $\mathds{C}' = \mathds{C}_2$. We can do the same using the \textsc{AtSeqSkip} rule by reducing $(h, s, \pskip ; \mathds{C}_2) \tred (h, s, \mathds{C}_2)$.
	\item When $\mathds{C}_1 \neq \pskip$, we can reduce $(s, p, \mathds{C}_1 ; \mathds{C}_2) \xrightarrow{\alpha} (s', p', \mathds{C}_1' ; \mathds{C}_2)$ through the \textsc{SeqSkip} rule, making $\mathds{C}' = \mathds{C}_1'; \mathds{C}_2$, by running $(s, p, \mathds{C}_1) \xrightarrow{\alpha} (s', p', \mathds{C}_1')$. From inductive hypothesis on $\mathds{C}_1$ we obtain that $(h, s, \mathds{C}_1) \tred (h', s', \mathds{C}_1')$ which is the premiss of the \textsc{AtSeq} rule to reduce $(h, s, \mathds{C}_1 ; \mathds{C}_2) \tred (h', s', \mathds{C}_1' ; \mathds{C}_2)$. \\
	\end{enumerate}
	
	\textit{Inductive case 2}: $\pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2} \in \mathsf{Cmd}$
	
	\textit{Inductive hypothesis}: $\pred{cAtom}{\mathds{C}_1} \land \pred{cAtom}{\mathds{C}_2}$
	
	\textit{To show}: $\pred{cAtom}{\pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}}$
	
	For arbitrary $\iota, s, s', p, p', \Phi, h, h', \mathds{C}', \alpha$ we assume that $(s, p, \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}) \xrightarrow{\alpha} (s', p', \mathds{C}') \land h' = \left( \llbracket \alpha \rrbracket(h, \Phi) \downarrow_1 \right)$ holds. There are two possible ways to reduce $\pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}$ for $b = \llbracket \mathds{B} \rrbracket_{s}^{\textsc{b}}$.
	\begin{enumerate}
	\item When $b = \top$, we can reduce $(s, p, \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}) \xrightarrow{\actid{\iota}} (s, p, \mathds{C}_1)$ through the \textsc{CondT} rule. It is possible to do the same using the \textsc{AtCondT} rule to get $(h, s, \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}) \tred (h, s, \mathds{C}_1)$.
	\item When $b = \bot$, we can reduce $(s, p, \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}) \xrightarrow{\actid{\iota}} (s, p, \mathds{C}_2)$ through the \textsc{CondF} rule. It is possible to do the same using the \textsc{AtCondF} rule to get $(h, s, \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}) \tred (h, s, \mathds{C}_2)$.
	\end{enumerate}
	
	\textit{Inductive case 3}: $\ploop{\mathds{B}}{\mathds{C}} \in \mathsf{Cmd}$
	
	\textit{Inductive hypothesis}: $\pred{cAtom}{\mathds{C}}$
	
	\textit{To show}: $\pred{cAtom}{\ploop{\mathds{B}}{\mathds{C}}}$
	
	For arbitrary $\iota, s, s', p, p', \Phi, h, h', \mathds{C}', \alpha$ we assume that $(s, p, \ploop{\mathds{B}}{\mathds{C}}) \xrightarrow{\alpha} (s', p', \mathds{C}') \land h' = \left( \llbracket \alpha \rrbracket(h, \Phi) \downarrow_1 \right)$ holds. There are two possible ways to reduce $\ploop{\mathds{B}}{\mathds{C}}$ for $b = \llbracket \mathds{B} \rrbracket_{s}^{\textsc{b}}$.
	\begin{enumerate}
	\item When $b = \top$, we can reduce $(s, p, \ploop{\mathds{B}}{\mathds{C}}) \xrightarrow{\actid{\iota}} (s, p, \mathds{C} ; \ploop{\mathds{B}}{\mathds{C}})$ through the \textsc{LoopT}. In a similar way we can reduce $(h, s, \ploop{\mathds{B}}{\mathds{C}}) \tred (h, s, \mathds{C} ; \ploop{\mathds{B}}{\mathds{C}})$ via the \textsc{AtLoopT} rule.
	\item When $b = \bot$, we can reduce $(s, p, \ploop{\mathds{B}}{\mathds{C}}) \xrightarrow{\actid{\iota}} (s, p, \pskip)$ through the \textsc{LoopF}. In a similar way we can reduce $(h, s, \ploop{\mathds{B}}{\mathds{C}}) \tred (h, s, \pskip)$ via the \textsc{AtLoopF} rule.
	\end{enumerate}
	\end{proof}
	}
\end{lem}

\begin{lem}
	\label{ref:aseq}
	\[
		\forall h, h', \mathds{P}_1, \mathds{P}_2 \ldotp
		(h, \mathds{P}_1) \tred^* (h', \pskip) \implies 
		(h, \mathds{P}_1; \mathds{P}_2) \tred^* (h', \pskip; \mathds{P}_2)
	\]
	
	{\parindent0pt
	\begin{proof}
	We proceed by induction on $n$, i.e. the number of reduction steps in $\tred^*$.
	
	\textit{Base case}: $n = 0$
	
	\textit{To show}: 
	\[
		\forall h, h', \mathds{P}_1, \mathds{P}_2 \ldotp
		(h, \mathds{P}_1) \tred^0 (h', \pskip) \implies 
		(h, \mathds{P}_1; \mathds{P}_2) \tred^* (h', \pskip; \mathds{P}_2)
	\]
	We assume $(h, \mathds{P}_1) \tred^0 (h', \pskip)$ holds and given it is a zero-step reduction, the only possible case is for $\mathds{P}_1 = \pskip$. Therefore $(h, \pskip) \tred^0 (h', \pskip)$ where $h = h'$. Now for $m = 0$ we have $(h, \pskip; \mathds{P}_2) \tred^0 (h', \pskip; \mathds{P}_2)$ given that $\tred^*$ is a reflexive relation, again for $h = h'$. \\
	
	\textit{Inductive case}: For some arbitrary $n > 0$
	
	\textit{Inductive hypothesis}: Assume the property holds for all programs $\mathds{P}$ that terminate in $n$ steps.
	\[
		\forall h, h', \mathds{P}, \mathds{P}_2 \ldotp
		(h, \mathds{P}) \tred^n (h', \pskip) \implies 
		(h, \mathds{P}; \mathds{P}_2) \tred^* (h', \pskip; \mathds{P}_2)
	\]
	\textit{To show}:
	\[
		\forall h, h', \mathds{P}_1, \mathds{P}_2 \ldotp
		(h, \mathds{P}_1) \tred^{n+1} (h', \pskip) \implies 
		(h, \mathds{P}_1; \mathds{P}_2) \tred^* (h', \pskip; \mathds{P}_2)
	\]
	We assume $(h, \mathds{P}_1) \tred^{n+1} (h', \pskip)$ holds which implies that there exists some program $\mathds{P}_n$ and storage $h_n$ such that $(h, \mathds{P}_1) \tred (h_n, \mathds{P}_n)$ and $(h_n, \mathds{P}_n) \tred^n (h', \pskip)$. The former is the premiss of rule \textsc{PSeq} for the conclusion $(h, \mathds{P}_1; \mathds{P}_2) \tred (h_n, \mathds{P}_n; \mathds{P}_2)$ in one step of reduction, while the latter gives us $(h_n, \mathds{P}_n; \mathds{P}_2) \tred^* (h', \pskip ; \mathds{P}_2)$ by inductive hypothesis. From the two combined we conclude that the property holds for $n + 1$ steps.
	\end{proof}
	}
\end{lem}

\begin{lem}
	\label{ref:2seq}
	\begin{gather*}
		\forall h, h', S, S', \Phi, \mathds{P}_1, \mathds{P}_2 \ldotp \\
		(h, \Phi, S, \mathds{P}_1; \mathds{P}_2) \rightarrow^* (h', \emptyset, S', \pskip; \mathds{P}_2)
		\implies
		(h, \Phi, S, \mathds{P}_1) \rightarrow^* (h', \emptyset, S', \pskip)
	\end{gather*}
	
	{\parindent0pt
	\begin{proof}
	The proof is done by induction on $n$, i.e. the number of reduction steps in $\rightarrow^*$.
	
	\textit{Base case}: $n = 0$
	
	\textit{To show}:
	\begin{gather*}
		\forall h, h', S, S', \Phi, \mathds{P}_1, \mathds{P}_2 \ldotp \\
		(h, \Phi, S, \mathds{P}_1; \mathds{P}_2) \rightarrow^0 (h', \emptyset, S', \pskip; \mathds{P}_2)
		\implies
		(h, \Phi, S, \mathds{P}_1) \rightarrow^* (h', \emptyset, S', \pskip)
	\end{gather*}
	We assume that $(h, \Phi, S, \mathds{P}_1; \mathds{P}_2) \rightarrow^0 (h', \emptyset, S', \pskip; \mathds{P}_2)$ holds. A zero-step reduction means that it must be the case that $\mathds{P}_1 = \pskip$. Therefore $(h, \Phi, S, \pskip; \mathds{P}_2) \rightarrow^0 (h', \emptyset, S', \pskip; \mathds{P}_2)$ for $h = h', \Phi = \emptyset, S = S'$. \\
	
	\textit{Inductive case}: For some arbitrary $n > 0$
	
	\textit{Inductive hypothesis}: Assume the property holds for all programs $\mathds{P}; \mathds{P}_2$ that reduce to $\pskip$ in $n$ steps.
	\begin{gather*}
		\forall h, h', S, S', \Phi, \mathds{P}, \mathds{P}_2 \ldotp \\ 
		(h, \Phi, S, \mathds{P}; \mathds{P}_2) \rightarrow^n (h', \emptyset, S', \pskip; \mathds{P}_2)
		\implies
		(h, \Phi, S, \mathds{P}) \rightarrow^* (h', \emptyset, S', \pskip)
	\end{gather*}
	
	\textit{To show}:
	\begin{gather*}
		\forall h, h', S, S', \Phi, \mathds{P}_1, \mathds{P}_2 \ldotp \\
		(h, \Phi, S, \mathds{P}_1; \mathds{P}_2) \rightarrow^{n+1} (h', \emptyset, S', \pskip; \mathds{P}_2)
		\implies
		(h, \Phi, S, \mathds{P}_1) \rightarrow^* (h', \emptyset, S', \pskip)
	\end{gather*}
	
	We assume that $(h, \Phi, S, \mathds{P}_1; \mathds{P}_2) \rightarrow^{n+1} (h', \emptyset, S', \pskip; \mathds{P}_2)$ holds which means there must be a program $\mathds{P}_n$ and state $h_n, \Phi_n, S_n$ such that $(h, \Phi, S, \mathds{P}_1; \mathds{P}_2) \xrightarrow{\alpha} (h_n, \Phi_n, S_n, \mathds{P}_n; \mathds{P}_2)$ and $(h_n, \Phi_n, S_n, \mathds{P}_n; \mathds{P}_2) \rightarrow^{n} (h', \emptyset, S', \pskip ; \mathds{P}_2)$. From the former and rule \textsc{PSeq} we obtain that $(h, \Phi, S, \mathds{P}_1) \xrightarrow{\alpha} (h_n, \Phi_n, S_n, \mathds{P}_n)$ and from the latter we get that $(h_n, \Phi_n, S_n, \mathds{P}_n) \rightarrow^* (h', \emptyset, S', \pskip)$ by inductive hypothesis. From the two combined we conclude that the property holds for $n + 1$ steps.
	\end{proof}
	}
\end{lem}

\begin{lem}
	\label{ref:phiemp}
	\[
		\forall h, h', S, S', \Phi', \mathds{P} \ldotp
		(h, \emptyset, S, \mathds{P})	
			\rightarrow^*
		(h', \Phi', S', \pskip)
			\implies
		\Phi' = \emptyset
	\]
	{\parindent0pt
	\begin{proof}
		Let's pick arbitrary $h, h' \in \mathsf{Storage}, S, S' \in \mathsf{TState}, \Phi' \in \mathsf{LMan}, \mathds{P} \in \mathsf{Prog}$ and assume that the following holds:
		\begin{gather}
			\label{ref:phiemp1}
			(h, \emptyset, S,  \mathds{P}) \rightarrow^* (h', \Phi', S', \pskip)
		\end{gather}
		We now also assume that the final lock manager, $\Phi'$, is empty, meaning that it all of keys in its domain are associated to locks in the unlocked mode.
		\begin{gather}
			\label{ref:phiemp2}
			\Phi' \neq \emptyset
		\end{gather}
		From (\ref{ref:phiemp1}) and (\ref{ref:phiemp2}) we know that in the full reduction that happens as described in (\ref{ref:phiemp1}) there must be at least an action $\alpha$ which modifies the lock manager and gives lock ownership to a particular transaction:
		\begin{gather}
			\label{ref:phiemp3}
			(h, \emptyset, S,  \mathds{P}) \rightarrow^* (h_l, \Phi_l, S_l, \mathds{P}_l) \xrightarrow{\alpha} (h_l', \Phi_l', S_l', \mathds{P}_l') \rightarrow^* (h', \Phi', S', \pskip)
		\end{gather}
		\begin{itemize}
			\item If $\alpha = \actlock{\iota}{k}{\kappa}$ then from (\ref{ref:phiemp3}) and the semantic interpretation of $\alpha$ it must be the case that $\Phi_l'(k) = (\{\iota\} \uplus I, \kappa)$ for $(I, \kappa') = \Phi_l(k), \kappa' \leq \textsc{s}$.
			\item If $\alpha = \actalloc{\iota}{n}{l}$ then (\ref{ref:phiemp3}) and the semantic interpretation of $\alpha$ it must be the case that $\Phi_l(l) = \ldots = \Phi(l  + n - 1) = (\{\iota\}, \textsc{x})$.
		\end{itemize}
		In both cases $\Phi_l' \neq \emptyset$. From (\ref{ref:phiemp2}) we obtain that there must be at least one cell in the domain of $\Phi'$ such that its associated lock is not unlocked and therefore owned by a transaction. It follows that for one of the $\alpha$ in (\ref{ref:phiemp3}), there is no matching $\actunlock{\iota}{k}$ (where in the case of $\alpha = \actalloc{\iota}{n}{l}$ we have $l \leq k < l + n$) operation done by the same transaction to release the lock it holds. Formally this means that:
		\begin{gather}
			\label{ref:phiemp4}
			k \in \pred{dom}{\Phi'} \land \iota \in \left( \Phi'(k) \downarrow_1 \right)
		\end{gather}
		From (\ref{ref:phiemp1}) we know that the whole program $\mathds{P}$ reduced to $\pskip$ meaning that the transaction $\mathds{T}_\iota$ must have also reduced to $\pskip$ in the same reduction. The only way for a transaction to do so, is through the \textsc{PSkip} in a reduction of the following shape:
		\begin{gather}
			\label{ref:phiemp5}
			(h_l', \Phi_l', S_l', \mathds{P}_l')
				\rightarrow^*
			(h_e, \Phi_e, S_e, \mathds{P}_e)
				\xrightarrow{\actid{\iota}}
			(h_e, \Phi_e, S_e, \mathds{P}_e')
				\rightarrow^*
			(h', \Phi', S', \pskip)
		\end{gather}		
		 From (\ref{ref:phiemp4}) we know that $\iota \in \Phi_e(k) \downarrow_1$ since there is no unlock action to release $\iota$'s lock on $k$. The \textsc{PSkip} rule's premiss instead requires that:
		\begin{gather}
			\label{ref:phiemp6}
			\forall k \ldotp k \in \pred{dom}{\Phi_e} \land \iota \not\in \left( \Phi_e(k) \downarrow_1 \right)
		\end{gather}
		From (\ref{ref:phiemp5}) and (\ref{ref:phiemp6}) we obtain a contradiction, therefore we can conclude that $\Phi' = \emptyset$ as needed.
	\end{proof}
	}
\end{lem}

\begin{lem}
	\label{lem:sameSys}
	\begin{gather*}
		\forall h, \Phi, S, \mathds{P}, \mathds{P}' \ldotp
		(h, \Phi, S, \mathds{P}) \xrightarrow{\actprog} (h', \Phi', S', \mathds{P}')
			\implies \\
		(h, \mathds{P}) \tred (h', \mathds{P}') \land h' = h \land \Phi' = \Phi \land S' = S
	\end{gather*}
	\begin{proof}
	Let's pick arbitrary $h \in \mathsf{Storage}, \Phi \in \mathsf{LMan}, S \in \mathsf{TState}, \mathds{P}, \mathds{P}' \in \mathsf{Prog}$. We now assume that the following holds:
	\begin{gather}
		\label{lem:sameSys1} (h, \Phi, S, \mathds{P}) \xrightarrow{\actprog} (h, \Phi, S, \mathds{P}')
	\end{gather}
	Given that from (\ref{lem:sameSys1}) we know that $\mathds{P}$ reduced to $\mathds{P'}$ through $\actprog$ we will proceed with a case-by-case analysis on the structure of $\mathds{P}$.
	\begin{itemize}
		\item If $\mathds{P} = \pskip ; \mathds{P}''$ for some $\mathds{P}'' \in \mathsf{Prog}$, then from the \textsc{PSeqSkip} rule we get that $\mathds{P}' = \mathds{P}'', h' = h, \Phi' = \Phi, S' = S$. From the \textsc{AtPSeqSkip} rule we know that as part of the atomic semantics, $(h, \mathds{P})$ will also reduce to $(h, \mathds{P}'')$.
		
		\item If $\mathds{P} = \pskip \| \pskip$ then from the \textsc{ParEnd} rule we get that $\mathds{P}' = \pskip, h' = h, \Phi' = \Phi, S' = S$. From the \textsc{AtParEnd} rule we know that as part of the atomic semantics, $(h, \mathds{P})$ will also reduce to $(h, \pskip)$.
		
		\item If $\mathds{P} = \mathds{P}_0^*$ for some $\mathds{P}_0 \in \mathsf{Prog}$, then from the \textsc{Loop} rule we get that $\mathds{P}' = \pskip + (\mathds{P}_0;\mathds{P}_0^*), h' = h, \Phi' = \Phi, S' = S$. From the \textsc{AtLoop} rule we know that as part of the atomic semantics, $(h, \mathds{P})$ will also reduce to $(h, \pskip + (\mathds{P}_0;\mathds{P}_0^*))$.
		
		\item $\mathds{P} = \mathds{P}_1 + \mathds{P}_2$ for some $\mathds{P}_1, \mathds{P}_2 \in \mathsf{Prog}$, then we can apply one of two reduction rules:
			\begin{itemize}
				\item If $\mathsf{sys}$ was generated by the \textsc{ChoiceL} rule then $\mathds{P}' = \mathds{P}_1, h' = h, \Phi' = \Phi, S' = S$ and through the \textsc{AtChoiceL} rule $(h, \mathds{P})$ will also reduce to $(h, \mathds{P}_1)$.
				\item If $\mathsf{sys}$ was generated by the \textsc{ChoiceR} rule then $\mathds{P}' = \mathds{P}_2, h' = h, \Phi' = \Phi, S' = S$ and through the \textsc{AtChoiceR} rule $(h, \mathds{P})$ will also reduce to $(h, \mathds{P}_2)$.
			\end{itemize}
	\end{itemize}
	\end{proof}
\end{lem}

\begin{lem}
	\label{lem:sysSwap}
	Any system action label followed by a transaction label, $\alpha(\iota)$, can be swapped as long as $\alpha$ does not come from $\mathds{T}_\iota$'s first reduction.
	\begin{gather}
		\forall h, \underline{h}, \Phi, S, \mathds{P}, x, y, n, \tau, \tau', \alpha, \iota \ldotp \\
		\pred{tgen}{\tau, h, \underline{h}, \Phi, S, \mathds{P}} \land \alpha = \alpha(\iota) \land x = (\actprog, n) \land y = (\alpha, n + 1) \land x \in \tau \land y \in \tau \land \\
		\exists \alpha' = \alpha(\iota) \ldotp \tau \vDash \alpha' < x \land \tau' = \pred{swap}{\tau, x, y} 
		\implies
		\pred{tgen}{\tau', h, \underline{h}, \Phi, S, \mathds{P}}
	\end{gather}
	
	\begin{proof}
	Let's pick arbitrary $h, \underline{h} \in \mathsf{Storage}, \Phi \in \mathsf{LMan}, S \in \mathsf{TState}, \mathds{P} \in \mathsf{Prog}, x, y \in \mathsf{Act} \times \mathds{N}, n \in \mathds{N}, \tau, \tau' \in [\mathsf{Act} \times \mathds{P}], \iota \in \mathsf{Tid}$ and assume that the following holds:
	\begin{gather}
		\pred{tgen}{\tau, h, \underline{h}, \Phi, S, \mathds{P}} \land \alpha = \alpha(\iota) \land x = (\actprog, n) \land y = (\alpha, n + 1) \land x \in \tau \land y \in \tau \land \\
		\exists \alpha' = \alpha(\iota) \ldotp \tau \vDash \alpha' < x \land \tau' = \pred{swap}{\tau, x, y}
	\end{gather}
	The above means that $\tau$ generates $\underline{h}$ starting from $h, \Phi, S, \mathds{P}$ and as part of its operations, it contains a system transition, $x = (\actprog, n)$, immediately followed by an operation, $y = (\alpha, n+1)$, performed by transaction $\iota$. Also, $\alpha$ is not the first reduction of $\mathds{T}_\iota$ since by assumption there exists another action $\alpha' = \alpha(\iota)$ which happens before $x$ in $\tau$, i.e. $\tau \vDash \alpha' < x$ holds. We now assume the existence of another transaction, $\tau'$, which is equivalent to $\tau$ with $x$ and $y$ swapped. We are now required to show that $\pred{tgen}{\tau', h, \underline{h}, \Phi, S, \mathds{P}}$ holds.
	
	From the definition $\mathsf{tgen}$ and the semantic interpretation of $\actprog$ we know that the following must hold:
	\begin{gather}
		\label{lem:sysSwap1}
		\begin{array}{c}
			(h, \Phi, S, \mathds{P}) \rightarrow^* (h_1, \Phi_1, S_1, \mathds{P}_1) \xrightarrow{\actprog} (h_1, \Phi_1, S_1, \mathds{P}_1') \xrightarrow{\alpha} (h_2, \Phi_2, S_2, \mathds{P}_2) \\ \rightarrow^* (\underline{h}, \emptyset, S', \pskip)
		\end{array}
	\end{gather}
	Given that from our assumption, $\alpha$ is not $\iota$'s starting action then from (\ref{lem:sysSwap1}) without loss of generality we can assume that $\mathds{P}_1$ is of the following shape:
	\begin{gather}
		\label{lem:sysSwap2}
		\left( \mathds{T}_\iota ; \mathds{P}_a \right) \|\ \mathds{P}_b
	\end{gather}
	meaning that the $\actprog$ transition happened as part of $\mathds{P}_b$. From (\ref{lem:sysSwap1}) and (\ref{lem:sysSwap2}) we know that we can always find a program $\mathds{P}_1''$ such that:
	\begin{gather}
		\label{lem:sysSwap3}
		\begin{array}{c}
			(h, \Phi, S, \mathds{P}) \rightarrow^* (h_1, \Phi_1, S_1, \mathds{P}_1) \xrightarrow{\alpha} (h_2, \Phi_2, S_2, \mathds{P}_1'') \xrightarrow{\actprog} (h_2, \Phi_2, S_2, \mathds{P}_2) \\ \rightarrow^* (\underline{h}, \emptyset, S', \pskip)
		\end{array}
	\end{gather}
	From (\ref{lem:sysSwap3}) and the definition of $\mathsf{tgen}$ we can conclude that $\pred{tgen}{h, \underline{h}, \Phi, S, \mathds{P}}$ holds.
	\end{proof}
\end{lem}

\begin{lem}
	\begin{gather*}
		\forall h, h', \mathds{T} \ldotp
		(h, \mathds{T}) \tred^* (h', \pskip)
		\implies \\
		\left(		
			\exists \sigma, \sigma' \ldotp
			\mathds{T}, \sigma \rightarrow^*_{\mathsf{Views}} \pskip, \sigma'
			\land h = \sigma \downarrow_1 \land h' = \sigma' \downarrow_1
		\right)
	\end{gather*}
	{\parindent0pt
	\begin{proof}
	We prove the statement by induction on the structure of $\mathds{T} \in \mathsf{Trans}$. \\
	
	\textit{Case 1}: $\ptdef{\mathds{C}} \in \mathsf{Trans}$
	
	\textit{To show}:
	\begin{gather*}
		\forall h, h', \mathds{C} \ldotp
		(h, \ptdef{\mathds{C}}) \tred^* (h', \pskip)
		\implies \\
		\left(		
			\exists \sigma, \sigma' \ldotp
			\ptdef{\mathds{C}}, \sigma \xrightarrow{\ptdef{\mathds{C}}}^*_{\mathsf{Views}} \pskip, \sigma'
			\land h = \sigma \downarrow_1 \land h' = \sigma' \downarrow_1
		\right)
	\end{gather*}
	For arbitrary $h, h', \mathds{C}$ let's assume that $(h, \ptdef{\mathds{C}}) \tred^* (h', \pskip)$ holds. From rule \textsc{AtTrans} we obtain that the following holds:
	\begin{gather}
		\label{lem:atomViews1}
		\exists s' \ldotp
		(h, \emptyset, \mathds{C}) \tred^* (h', s', \pskip)
	\end{gather}
	From (\ref{lem:atomViews1}) and Lemma \ref{lem:atomViewsCmd} we get that:
	\begin{gather}
		\label{lem:atomViews2}
		(h', s') \in \tsem{\mathds{C}}_\mathsf{C}(h, \emptyset)
	\end{gather}
	The statement in (\ref{lem:atomViews2}) is the premiss from which we can conclude that:
	\[
		\ptdef{\mathds{C}}, (h, \emptyset) \xrightarrow{\ptdef{\mathds{C}}}^*_{\mathsf{Views}} \pskip, (h', s')
	\]
	must hold. It follows that we found $\sigma = (h, \emptyset)$ and $\sigma' = (h', s')$, which concludes our proof.
	\\	
	
	\textit{Case 2}: $\ptdef{\mathds{C}}_\iota \in \mathsf{Trans}$
	
	System transactions are not reduced by the \textsc{Atom} semantics given that there is no rule capable of doing so. It follows that we can skip this case since $(h, \ptdef{\mathds{C}}) \tred^* (h', \pskip)$ will never hold.
	\end{proof}
	}
\end{lem}

\begin{lem}
	\begin{gather*}
		\forall h, h', s, s', \mathds{C} \ldotp
		(h, s, \mathds{C}) \tred^* (h', s', \pskip)
		\implies
		(h', s') \in \tsem{\mathds{C}}_\mathsf{C}(h, s)
	\end{gather*}
	{\parindent0pt
	\begin{proof}
	We prove the statement by induction on the structure of $\mathds{C} \in \mathsf{Cmd}$. \\
	
	\textit{Base Case 1}: $\pskip \in \mathsf{Cmd}$
	
	\textit{Base Case 2}: $\hat{\mathds{C}} \in \mathsf{Cmd}$
	
	\textit{Inductive Case 1}: $\mathds{C}_1 ; \mathds{C}_2 \in \mathsf{Cmd}$
	
	\textit{Inductive Case 2}: $\pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2} \in \mathsf{Cmd}$
	
	\textit{Inductive Case 3}: $\ploop{\mathds{B}}{\mathds{C}} \in \mathsf{Cmd}$
	\end{proof}
	}
\end{lem}