\section{Auxiliary Lemmata}

\thm \label{thm:eSound} (Elementary command soundness). For all $\hat{\mathds{C}} \in \mathsf{ECmd}$, their corresponding axiom $(M_1, \hat{\mathds{C}}, M_2) \in \mathsf{Ax}_{\hat{\mathsf{C}}}$ and any given machine state $m = (h, s) \in \mathsf{Storage} \times \mathsf{Stack}$, the following must hold.
\[
	\tsem{\hat{\mathds{C}}}_{\hat{\mathsf{C}}} \left( \lfloor M_1 \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M} \right) \subseteq \lfloor M_2 \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M}
\]
{\parindent0pt
\begin{proof}
By induction on the structure of $\hat{\mathds{C}}$. \\

\textit{Case}: $\passign{\pvar{x}}{\mathds{E}}$

\textit{To show}: $\tsem{\passign{\pvar{x}}{\mathds{E}}}_{\hat{\mathsf{C}}} \left( \lfloor M_1 \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M} \right) \subseteq \lfloor M_2 \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M}$

Let's pick an arbitrary $m_1 \in M_1$, now by definition of $\lfloor - \rfloor_\mathbb{M}$, it is now sufficient to show that the following holds for some $m_2 \in M_2$:
\begin{gather}
	\label{thm:CH1} \tsem{\passign{\pvar{x}}{\mathds{E}}}_{\hat{\mathsf{C}}} \left(m_1 \bullet_\mathbb{M} m \right) = \{ m_2 \bullet_\mathbb{M} m \}
\end{gather}

From the definition of the \textsc{Assign} axiom, we know that $m_1 = (h_1, s_1)$ can be any machine state and $m_2 = (h_1, s_1[\pvar{x} \mapsto v])$ where $v = \tsem{\mathds{E}}^\textsc{e}_{s_1}$. Then by definition of $\tsem{\passign{\pvar{x}}{\mathds{E}}}_{\hat{\mathsf{C}}}$, the first projection of the return value is $m_1 \bullet_\mathbb{M} m$. We can conclude that (\ref{thm:CH1}) holds.  \\

\textit{Case}: $\palloc{\pvar{x}}{\mathds{E}}$

\textit{To show}: $\tsem{\palloc{\pvar{x}}{\mathds{E}}}_{\hat{\mathsf{C}}} \left( \lfloor M_1 \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M} \right) \subseteq \lfloor M_2 \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M}$

Let's pick an arbitrary $m_1 \in M_1$, now by definition of $\lfloor - \rfloor_\mathbb{M}$, it is now sufficient to show that the following holds for some $m_2 \in M_2$:
\begin{gather}
	\label{thm:CH3} \tsem{\palloc{\pvar{x}}{\mathds{E}}}_{\hat{\mathsf{C}}} \left(m_1 \bullet_\mathbb{M} m, s \right) = \{ m_2 \bullet_\mathbb{M} m \}
\end{gather}

From the definition of the \textsc{Alloc} axiom, we know that $m_1 \in \{ (\emptyset, \emptyset) \}$ meaning that $m_1 = (\emptyset, \emptyset)$ and $m_2 = \left([l \mapsto 0]\ldots[l + n - 1 \mapsto 0], [\pvar{x} \mapsto l] \right)$ for $n = \tsem{\mathds{E}}_s^\textsc{e}$, $n > 0$ and some arbitrary $l \in \mathsf{Key}$. Then by definition of $\tsem{\palloc{\pvar{x}}{\mathds{E}}}_{\hat{\mathsf{C}}}$, the return value is:
\begin{align*}
	m' &= ((h \uplus \emptyset)[l \mapsto 0]\ldots[l + n - 1 \mapsto 0], (s \uplus \emptyset)[\pvar{x} \mapsto l]) \\
	&= (h[l \mapsto 0]\ldots[l + n - 1 \mapsto 0], s[\pvar{x} \mapsto l])
\end{align*}
We can pick $l$ such that $\{ l, \ldots, l + n -1 \} \cap \pred{dom}{h} \equiv \emptyset$ and as a consequence express $m' = m_2 \bullet_\mathbb{M} m$. We can conclude that (\ref{thm:CH3}) holds. \\

\textit{Case}: $\pderef{\pvar{x}}{\mathds{E}}$

\textit{To show}: $\tsem{\pderef{\pvar{x}}{\mathds{E}}}_{\hat{\mathsf{C}}} \left( \lfloor M_1 \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M} \right) \subseteq \lfloor M_2 \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M}$

Let's pick an arbitrary $m_1 \in M_1$, it is now sufficient to show that the following holds for some $m_2 \in M_2$:
\begin{gather}
	\label{thm:CH4} \tsem{\pderef{\pvar{x}}{\mathds{E}}}_{\hat{\mathsf{C}}} \left( m_1 \bullet_\mathbb{M} m\right) = \{m_2 \bullet_\mathbb{M} m\}
\end{gather}

From the definition of the \textsc{Read} axiom, we know that for $k = \tsem{\mathds{E}}_s^\textsc{e}$ and some $v \in \mathsf{Val}$:
\begin{gather}
	\label{thm:CH7}
	m_1 = (h_1, s_1) = ([k \mapsto v], [\pvar{x} \mapsto -]) \land m_2 = ([k \mapsto v], [\pvar{x} \mapsto v])
\end{gather}
therefore we know that $k \in \pred{dom}{h_1} \land \pvar{x} \in \pred{dom}{m_1 \downarrow_2}$ and it follows that $k \not\in \pred{dom}{h} \land \pvar{x} \not\in \pred{dom}{s}$ since $m_1 \bullet_\mathbb{M} m$ is defined. Then from the definition of $\tsem{\pderef{\pvar{x}}{\mathds{E}}}_{\hat{\mathsf{C}}}$ and \ref{thm:CH7} we have:
\begin{align*}
	\tsem{\pderef{\pvar{x}}{\mathds{E}}}_{\hat{\mathsf{C}}}
		&=
	\{ (h_1 \uplus h, (s_1 \uplus s)[\pvar{x} \mapsto v]) \} \\
		&=
	\{ ([k \mapsto v] \uplus h, ([\pvar{x} \mapsto -] \uplus s)[\pvar{x} \mapsto v]) \} \\
		&=
	\{ ([k \mapsto v] \uplus h, [\pvar{x} \mapsto v] \uplus s) \} \\
		&=
	\{ ([k \mapsto v], [\pvar{x} \mapsto v]) \uplus_2 (h, s) \} \\
		&=
	\{ m_2 \uplus m \} = \{ m_2 \bullet_\mathbb{M} m \}
\end{align*}

\textit{Case}: $\pmutate{\mathds{E}_1}{\mathds{E}_2}$

\textit{To show}: $\tsem{\pmutate{\mathds{E}_1}{\mathds{E}_2}}_{\hat{\mathsf{C}}} \left( \lfloor M_1 \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M} \right) \subseteq \lfloor M_2 \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M}$

Let's pick an arbitrary $m_1 \in M_1$, now by definition of $\lfloor - \rfloor_\mathbb{M}$, it is sufficient to show that the following holds for some $m_2 \in M_2$:
\begin{gather}
	\label{thm:CH5} \tsem{\pmutate{\mathds{E}_1}{\mathds{E}_2}}_{\hat{\mathsf{C}}} \left( m_1 \bullet_\mathbb{M} m \right) = \{ m_2 \bullet_\mathbb{M} m \}
\end{gather}

From the definition of the \textsc{Write} axiom, we know that for $k = \tsem{\mathds{E}_1}_s^\textsc{e}$ and $v = \tsem{\mathds{E}_2}_s^\textsc{e}$,
\begin{gather}
	\label{thm:CH6}
	m_1 = (h_1, s_1) = ([k \mapsto -], s_1) \land m_2 = ([k \mapsto v], s_1)
\end{gather}
This implies that $k \in \pred{dom}{h_1}$ which requires that $k \not\in \pred{dom}{h}$ given that $m_1 \bullet_\mathbb{M} m$ is defined by assumption. Then, from the definition of $\tsem{\pmutate{\mathds{E}_1}{\mathds{E}_2}}_{\hat{\mathsf{C}}}$ and (\ref{thm:CH6}), we have:
\begin{align*}
	\tsem{\pmutate{\mathds{E}_1}{\mathds{E}_2}}_{\hat{\mathsf{C}}} \left( m_1 \bullet_\mathbb{M} m \right)
		&=
	\{((h_1 \uplus h)[k \mapsto v], s_1 \uplus s)\} \\
		&=
	\{(([k \mapsto -] \uplus h)[k \mapsto v], s_1 \uplus s)\} \\
		&=
	\{([k \mapsto v] \uplus h, s_1 \uplus s)\} \\
		&=
	\{ ([k \mapsto v], s_1) \uplus_2 (h, s) \} \\
		&=
	\{ m_2 \uplus_2 m \} = \{ m_2 \bullet_\mathbb{M} m \}
\end{align*}
\end{proof}
}

\thm \label{thm:cSound} (Command soundness). For all $\mathds{C} \in \mathsf{Cmd}$, their corresponding axiom $(M_1, \mathds{C}, M_2) \in \mathsf{Ax}_\mathsf{C}$ and any given machine state $m \in \mathbb{M}$ the following must hold.
\[
	\tsem{\mathds{C}}_\mathsf{C} \left( \lfloor M_1 \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M} \right) \subseteq \lfloor M_2 \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M}
\]

{\parindent0pt
\begin{proof}
By induction on the structure of $\mathds{C}$. \\

\textit{Base case}: $\mathds{\hat{C}}$

\textit{To show}: $\tsem{\hat{\mathds{C}}}_\mathsf{C} \left( \lfloor M_1 \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M} \right) \subseteq \lfloor M_2 \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M}$

The result follows directly from Parameter \ref{param:ecmdSound}. \\

\textit{Base case}: $\pskip$

\textit{To show}: $\tsem{\pskip}_\mathsf{C} \left( \lfloor M \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M}\right) \subseteq \lfloor M \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M}$

By definition of $\tsem{\pskip}_\mathsf{C}$ we have the following.
\begin{align*}
	\tsem{\pskip}_\mathsf{C} \left( \lfloor M \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M} \right)
	&=
	\lfloor M \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M}
	\\
	&\subseteq \lfloor M \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M}
\end{align*} 

\textit{Inductive case}: $\mathds{C}_1 ; \mathds{C}_2$

\textit{To show}:
\begin{gather*}
	\tsem{\mathds{C}_1 ; \mathds{C}_2}_\mathsf{C} \left( \lfloor M \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M} \right) \subseteq \lfloor M' \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M}
	\\
	\text{where } (M, \mathds{C}_1, M''), (M'', \mathds{C}_2, M') \in \textsc{Ax}_\mathsf{C}
\end{gather*}

\textit{Inductive hypothesis}: Assume the property holds for $\mathds{C}_1$ and for $\mathds{C}_2$.

By definition of $\tsem{\mathds{C}_1 ; \mathds{C}_2}_\mathsf{C}$ we have the following.
\begin{align*}
	\tsem{\mathds{C}_1 ; \mathds{C}_2}_\mathsf{C} \left( \lfloor M \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M} \right)
	&=
	\tsem{\mathds{C}_2}\left( \tsem{\mathds{C}_1}_\mathsf{C} \left( \lfloor M \bullet_\mathbb{M} \{m\}\rfloor_\mathbb{M}\right) \right) \\
	\text{by I.H. on } \mathds{C}_1 &\subseteq
	\tsem{\mathds{C}_1}_\mathsf{C} \left( \lfloor M'' \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M} \right) \\
	\text{by I.H. on } \mathds{C}_2 &\subseteq
	\lfloor M' \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M}
\end{align*}

\textit{Inductive case}: $\pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}$

\textit{To show}:
\begin{gather*}
	\tsem{\pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}}_\mathsf{C} \left( \lfloor M \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M} \right) \subseteq \lfloor M' \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M}
	\\
	\text{where } (M, \mathds{C}_1, M_1), (M, \mathds{C}_2, M_2) \in \textsc{Ax}_\mathsf{C} \text{ and } M' \equiv M_1 \cup M_2
\end{gather*}

\textit{Inductive hypothesis}: Assume the property holds for $\mathds{C}_1$ and for $\mathds{C}_2$.

Let $S_{in} = \lfloor M \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M}$ and $S_{out} = \lfloor M' \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M}$. Let's pick an arbitrary $\sigma \in S_{in}$. It is now sufficient to show that the following holds:
\begin{gather*}
	\tsem{\pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}}_\mathsf{C} \left( \sigma \right) \subseteq S_{out}
\end{gather*}

From the definition of $\tsem{\pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}}_\mathsf{C}$ we have the following.
\[
	\tsem{\pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}}_\mathsf{C} \left( \sigma \right)
		= 
	\mathbf{if}\ \tsem{\mathds{B}}_\sigma^\textsc{b}\ \mathbf{then}\ \tsem{\mathds{C}_1}_\mathsf{C}\left( \sigma \right) \mathbf{else}\ \tsem{\mathds{C}_2}_\mathsf{C}\left( \sigma \right)
\]

We now have two scenarios to consider, based on how $\tsem{\mathds{B}}_\sigma^\textsc{b}$ evaluates.
\begin{itemize}
	\item If $\tsem{\mathds{B}}_\sigma^\textsc{b} = \top$, then we can proceed as follows.
		\begin{align*}			
			& \mathbf{if}\ \top\ \mathbf{then}\ \tsem{\mathds{C}_1}_\mathsf{C}\left( \sigma \right) \mathbf{else}\ \tsem{\mathds{C}_2}_\mathsf{C}\left( \sigma \right) \\
				&=
			\tsem{\mathds{C}_1}_\mathsf{C} \left( \sigma \right) \\
				&
			\subseteq \lfloor M_1 \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M} \text{ by I.H. on } \mathds{C}_1 \\
				&
			\subseteq \lfloor M' \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M} \text{ as } M_1 \subseteq M'
		\end{align*}
	\item If $\tsem{\mathds{B}}_\sigma^\textsc{b} = \bot$, then we can proceed as follows.
		\begin{align*}			
			& \mathbf{if}\ \bot\ \mathbf{then}\ \tsem{\mathds{C}_1}_\mathsf{C}\left( \sigma \right) \mathbf{else}\ \tsem{\mathds{C}_2}_\mathsf{C}\left( \sigma \right) \\
			&=
			\tsem{\mathds{C}_2}_\mathsf{C} \left( \sigma \right) \\
			&
			\subseteq \lfloor M_2 \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M} \text{ by I.H. on } \mathds{C}_2 \\
			&
			\subseteq \lfloor M' \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M} \text{ as } M_2 \subseteq M'
		\end{align*}
\end{itemize}

\textit{Inductive case}: $\ploop{\mathds{B}}{\mathds{C}}$

\textit{To show}:
\begin{gather*}
	\tsem{\ploop{\mathds{B}}{\mathds{C}}}_\mathsf{C} \left( \lfloor M \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M} \right) \subseteq \lfloor M' \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M}
	\\
	\text{where } (M, \mathds{C}, M'') \in \textsc{Ax}_\mathsf{C} \text{ and } M' \equiv M \cup M''
\end{gather*}

\textit{Inductive hypothesis}: Assume the property holds for $\mathds{C}$.

Let $S_{in} = \lfloor M \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M}$ and $S_{out} = \lfloor M' \bullet_\mathbb{M} \{m\} \rfloor_\mathbb{M}$. Let's pick an arbitrary $\sigma \in S_{in}$. It is now sufficient to show that the following holds:
\begin{gather}
	\tsem{\ploop{\mathds{B}}{\mathds{C}}}_\mathsf{C} \left( \sigma \right) \subseteq S_{out}
\end{gather}
By definition of $\tsem{\ploop{\mathds{B}}{\mathds{C}}}_\mathsf{C}$ we have the following.
\begin{align*}
	\tsem{\ploop{\mathds{B}}{\mathds{C}}}_\mathsf{C} \left( \sigma \right)
	&=
	\tsem{\pif{\mathds{B}}{\left(\mathds{C};\ploop{\mathds{B}}{\mathds{C}}\right)}{\pskip}}_\mathsf{C} \left( \sigma \right) \\
	&=
	\mathbf{if}\ \tsem{\mathds{B}}^\textsc{b}_\sigma\ \mathbf{then}\ \tsem{\mathds{C};\ploop{\mathds{B}}{\mathds{C}}}_\mathsf{C}\left( \sigma \right)\ \mathbf{else}\ \tsem{\pskip}_\mathsf{C}\left( \sigma \right)
\end{align*}

As before, we have two cases to consider, based on how $\tsem{\mathds{B}}_\sigma^\textsc{b}$ evaluates.
\begin{itemize}
	\item If $\tsem{\mathds{B}}_\sigma^\textsc{b} = \top$, then we can proceed as follows.
		\begin{align*}
			&\mathbf{if}\ \top\ \mathbf{then}\ \tsem{\mathds{C};\ploop{\mathds{B}}{\mathds{C}}}_\mathsf{C}\left( \sigma \right)\ \mathbf{else}\ \tsem{\pskip}_\mathsf{C}\left( \sigma \right)
			\\
			&= \tsem{\mathds{C};\ploop{\mathds{B}}{\mathds{C}}}_\mathsf{C}\left( \sigma \right)
			\\
			&= \tsem{\ploop{\mathds{B}}{\mathds{C}}}_\mathsf{C} \left( \tsem{\mathds{C}}_\mathsf{C}\left( \sigma \right) \right)
			\\
			& ??
		\end{align*}
	\item If $\tsem{\mathds{B}}_\sigma^\textsc{b} = \bot$, then we can proceed as follows.
		\begin{align*}
			&\mathbf{if}\ \bot\ \mathbf{then}\ \tsem{\mathds{C};\ploop{\mathds{B}}{\mathds{C}}}_\mathsf{C}\left( \sigma \right)\ \mathbf{else}\ \tsem{\pskip}_\mathsf{C}\left( \sigma \right)
			\\
			&= \tsem{\pskip}_\mathsf{C}\left( \sigma \right)
			\\
			&\subseteq S_{in} \text{ by original assumption}
			\\
			&\subseteq S_{out} \text{ as } M \subseteq M'.
		\end{align*}
\end{itemize}
\end{proof}
}

\lem \label{lem:R} For all $w_1, w_2, w, w' = (l', g', \mathcal{J}') \in \mathsf{World}$,
\[
	w_1 \bullet w_2 = w \land (l', g', \mathcal{J}') \in G(w_1) \implies ((w_2)_\mathsf{L}, g', \mathcal{J}') \in R(w_2)
\]

{\parindent0pt
\begin{proof}
Let's pick arbitrary $w_1, w_2, w, w' = (l', g', \mathcal{J}') \in \mathsf{World}$ such that:
\begin{gather}
	\label{lem:R1} w_1 \bullet w_2 = w \land
	\\
	\label{lem:R2} (l', g', \mathcal{J}') \in G(w_1)
\end{gather}

\textit{To show}: $((w_2)_\mathsf{L}, g', \mathcal{J}') \in R(w_2)$

From (\ref{lem:R2}) and the definition of $G$ we know that:
\begin{gather}
	\label{lem:R3} (l', g', \mathcal{J}') \in (G^c \cup G^u)^*(w_1)
\end{gather}

From (\ref{lem:R1}), (\ref{lem:R3}) and by Lemma \ref{lem:Ru}, Lemma \ref{lem:Rc} we get:
\[
	((w_2)_\mathsf{L}, g', \mathcal{J}') \in (R^c \cup R^u)^*(w_2)
\]
Therefore we can conclude the following.
\[
	((w_2)_\mathsf{L}, g', \mathcal{J}') \in R(w_2)
\]
\end{proof}
}

\lem \label{lem:Ru} For all $w_1, w_2, w, w' = (l', g', \mathcal{J}') \in \mathsf{World}$,
\[
	w_1 \bullet w_2 = w \land (l', g', \mathcal{J}') \in G^u(w_1) \implies ((w_2)_\mathsf{L}, g', \mathcal{J}') \in R^u(w_2)
\]

{\parindent0pt
\begin{proof}
Let's pick arbitrary $w_1 = (l_1, g_1, \mathcal{J}_1), w_2 = (l_2, g_2, \mathcal{J}_2), w$ and $(l', g', \mathcal{J}') \in \mathsf{World}$, such that:
\begin{gather}
	\label{lem:Ru1} w_1 \bullet w_2 = w \land \\
	\label{lem:Ru2} (l', g', \mathcal{J}') \in G^u(w_1)
\end{gather}

\textit{To show}: $((w_2)_\mathsf{L}, g', \mathcal{J}') \in R^u(w_2)$

From (\ref{lem:Ru1}) we know that
\begin{gather}
	\label{lem:Ru3} g_1 = g_2 \\
	\label{lem:Ru4} \mathcal{J}_1 = \mathcal{J}_2
\end{gather}

From the definition of $G^u$ and from (\ref{lem:Ru2}) and (\ref{lem:Ru4}) we know that:
\begin{gather}
	\label{lem:Ru5} \mathcal{J}' = \mathcal{J}_1 = \mathcal{J}_2 \land \\
	\label{lem:Ru6} ((l_1 \oplus g_1)_\mathsf{K})_\mathbb{K}^\bot = ((l' \oplus g')_\mathsf{K})_\mathbb{K}^\bot \land \\
		\label{lem:Ru7} (g_1 = g' \lor (\exists r, \kappa \leq (l_1)_\mathsf{K}(r) \ldotp (g_1, g') \in \lceil \mathcal{J}_1(r) \rceil(\kappa)
		\\ \land ((l_1 \oplus g_1)_\mathsf{M})_\mathbb{M}^\bot = ((l' \oplus g')_\mathsf{M})_\mathbb{M}^\bot )
\end{gather}

Given the disjunction in (\ref{lem:Ru7}), we need to consider two cases. \\

\textit{Case 1}: $g_1 = g'$

From (\ref{lem:Ru3}) and our assumption, we get that $g_2 = g'$. Now, from (\ref{lem:Ru5}), it follows that:
\begin{gather}
	\label{lem:Ru8} ((w_2)_\mathsf{L}, g', \mathcal{J}') = ((l_2, g_2, \mathcal{J}_2))
\end{gather}

From (\ref{lem:Ru8}) and the definition of $R^u$ we can conclude that:
\[
	((w_2)_\mathsf{L}, g', \mathcal{J}') \in R^u((l_2, g_2, \mathcal{J}_2))
\]

\textit{Case 2}:
\begin{gather}
	\label{lem:Ru9} \exists r, \kappa \leq (l_1)_\mathsf{K}(r) \ldotp (g_1, g') \in \lceil \mathcal{J}_1(r) \rceil(\kappa)
	\\
	\label{lem:Ru10} \land ((l_1 \oplus g_1)_\mathsf{M})_\mathbb{M}^\bot = ((l' \oplus g')_\mathsf{M})_\mathbb{M}^\bot
\end{gather}

From (\ref{lem:Ru1}), (\ref{lem:Ru3}) and (\ref{lem:Ru4}) we know that:
\begin{gather}
	\label{lem:Ru11} w = (l_1 \circ l_2, g_2, \mathcal{J}_2)
\end{gather}

From the definition of $\mathsf{World}$ we know that $\pred{wf}{w}$ holds, and together with (\ref{lem:Ru3}) we have:
\begin{gather}
	\label{lem:Ru12} ((l_1 \circ l_2) \oplus g_2)_\mathsf{K} = (l_1)_\mathsf{K} \bullet_\mathbb{K} (l_2)_\mathsf{K} \bullet_\mathbb{K} \llfloor g_2 \rrfloor_\mathsf{K} = (l_1 \oplus g_1)_\mathsf{K} \bullet_\mathbb{K} (l_2)_\mathsf{K} \text{ defined}
	\\
	\label{lem:Ru13} \text{and } ((l_1 \circ l_2) \oplus g_1)_\mathsf{M} = (l_1 \oplus g_1)_\mathsf{M} \bullet_\mathbb{M} (l_2)_\mathsf{M} \text{ defined}
\end{gather}

From (\ref{lem:Ru9}) we obtain $\kappa \leq (l_1)_\mathsf{K}(r)$, from (\ref{lem:Ru12}) and Lemma \ref{lem:SepF}, we know:
\begin{gather}
	\label{lem:Ru14} \kappa\ \sharp \left( (l_2)_\mathsf{K} \bullet_\mathbb{K} \llfloor g_2 \rrfloor_\mathsf{K} \right)
\end{gather}

From (\ref{lem:Ru3}), (\ref{lem:Ru10}) and (\ref{lem:Ru13}) we know:
\begin{gather}
	\label{lem:Ru15} (l' \oplus g')_\mathsf{M} \bullet_\mathbb{M} (l_2)_\mathsf{M} = ((l' \circ l_2) \oplus g')_\mathsf{M} \text{ defined}
\end{gather}

From (\ref{lem:Ru6}) and (\ref{lem:Ru12}) we know:
\begin{gather}
	\label{lem:Ru16} (l' \oplus g')_\mathsf{K} \bullet_\mathbb{K} (l_2)_\mathsf{K} = ((l' \circ l_2) \oplus g')_\mathsf{K} \text{ defined}
\end{gather}

From (\ref{lem:Ru15}), (\ref{lem:Ru16}) we get that $(l_1' \circ l_2) \oplus g'$ is defined and as a consequence we obtain:
\begin{gather}
	\label{lem:Ru17} l_2 \oplus g' \text{ defined}
\end{gather}

From (\ref{lem:Ru5}), (\ref{lem:Ru9}), (\ref{lem:Ru14}), (\ref{lem:Ru17}) and the definition of $R^u$ we can conclude that:
\[
	((w_2)_\mathsf{L}, g', \mathcal{J}') \in R^u((l_2, g_2, \mathcal{J}_2))
\]
\end{proof}
}

\lem \label{lem:Rc}  For all $w_1, w_2, w, w' = (l', g', \mathcal{J}') \in \mathsf{World}$,
\[
	w_1 \bullet w_2 = w \land (l', g', \mathcal{J}') \in G^c(w_1) \implies ((w_2)_\mathsf{L}, g', \mathcal{J}') \in R^c(w_2)
\]

{\parindent0pt
\begin{proof}
Let's pick arbitrary $w_1 = (l_1, g_1, \mathcal{J}_1), w_2 = (l_2, g_2, \mathcal{J}_2), w$ and $w' = (l', g', \mathcal{J}') \in \mathsf{World}$, such that:
\begin{gather}
	\label{lem:Rc1} w_1 \bullet w_2 = w \land \\
	\label{lem:Rc2} (l', g', \mathcal{J}') \in G^c(w_1)
\end{gather}

\textit{To show}: $((w_2)_\mathsf{L}, g', \mathcal{J}') \in R^c(w_2)$

From (\ref{lem:Ru1}) we know that
\begin{gather}
	\label{lem:Rc3} g_1 = g_2 \\
	\label{lem:Rc4} \mathcal{J}_1 = \mathcal{J}_2
\end{gather}

From the definition of $G^c$ and from (\ref{lem:Rc2}), (\ref{lem:Rc3}) and (\ref{lem:Rc4}) we know that:
\begin{gather}
	\label{lem:Rc5} \exists r, m, l, l_r, a, \rho \ldotp \pred{fresh}{r, w} \land \pred{dom}{\rho} = \{r\} \land
	\\
	\label{lem:Rc6} l_1 = l \circ l_r \land l' = l \circ (m, \rho) \land m \in \mathbf{0}_\mathbb{M} \land
	\\
	\label{lem:Rc10} g' = g_2[r \mapsto l_r] \land \mathcal{J}' = \mathcal{J}_2[r \mapsto a]
\end{gather}

From (\ref{lem:Rc1}) and (\ref{lem:Rc6}) we know that $(l_1 \circ l_2) \oplus g$ and that $l_1 = l \circ l_r$ are defined which implies that:
\begin{gather}
	\label{lem:Rc7} l_r \circ l_2 \text{ defined}
	\\
	\label{lem:Rc8} l_2 \oplus g_2 \text{ defined}
\end{gather}

Now, from (\ref{lem:Rc10}) we know that $g' = g_2[r \mapsto l_r]$ and together with (\ref{lem:Rc7}) and (\ref{lem:Rc8}) we obtain that:
\begin{gather}
	\label{lem:Rc9} l_2 \oplus g' \text{ defined}
\end{gather}

From (\ref{lem:Rc1}) and (\ref{lem:Rc5}) we obtain that:
\begin{gather}
	\label{lem:Rc11} \pred{fresh}{r, w_2}
\end{gather}

From (\ref{lem:Rc10}), (\ref{lem:Rc9}) and (\ref{lem:Rc11}) we can conclude that:
\[
	((w_2)_\mathsf{L}, g', \mathcal{J}') \in R^c(w_2)
\]
\end{proof}
}

\lem \label{lem:SepF} Given any separation algebra $(\mathcal{M}, \bullet_\mathcal{M}, \mathbf{0}_\mathcal{M})$
\[
	\forall a, b, c, d \in \mathcal{M} \ldotp a \bullet_\mathcal{M} b = d \land c \leq b \implies \exists f \ldotp a \bullet_\mathcal{M} c = f
\]

{\parindent0pt
\begin{proof}
Let's pick arbitrary $a, b, c, d \in \mathcal{M}$ such that:
\begin{gather}
	\label{lem:SepF1} a \bullet_\mathcal{M} b = d
	\\
	\label{lem:SepF2} c \leq b
\end{gather}

From (\ref{lem:SepF2}) we obtain:
\begin{gather}
	\label{lem:SepF3} \exists e \in \mathcal{M} \ldotp c \bullet_\mathcal{M} e = b
\end{gather}

Now, as a consequence, from (\ref{lem:SepF1}) we have:
\begin{gather}
	\label{lem:SepF4} a \bullet_\mathcal{M} c \bullet_\mathcal{M} e = d
\end{gather}

Since $e \leq d$ from (\ref{lem:SepF4}) we have:
\begin{gather}
	\label{lem:SepF5} \exists f \in \mathcal{M} \ldotp e \bullet_\mathcal{M} f = d
\end{gather}

From (\ref{lem:SepF4}), (\ref{lem:SepF5}) and cancellativity of separation algebras we have $a \bullet_\mathcal{M} c = f$ and therefore $\exists f \in \mathcal{M} \ldotp a \bullet_\mathcal{M} c = f$ holds.
\end{proof}
}

\begin{lem}
	\label{lem:pred-i}
	(Predicate introduction).
	If $\tsem{\Delta}^\textsc{p} \subseteq \tsem{\Delta'}^\textsc{p}$ and $\Delta' \vDash \triple{P}{\mathds{P}}{Q}$ then $\Delta \vDash \triple{P}{\mathds{P}}{Q}$.
	\begin{proof}
		Let's pick arbitrary $\Delta, \Delta' \in \mathsf{Ax}, \mathds{P} \in \mathsf{Prog}, P, Q \in \mathsf{Assn}$ and assume that the following holds:
		\begin{gather}
			\label{lem:pred-i1} \tsem{\Delta}^\textsc{p} \subseteq \tsem{\Delta'}^\textsc{p} \\
			\label{lem:pred-i2} \land\ \Delta' \vDash \triple{P}{\mathds{P}}{Q}
		\end{gather}
		From (\ref{lem:pred-i1}) we obtain that:
		\begin{gather}
			\label{lem:pred-i3} \forall \delta \in \tsem{\Delta'}^\textsc{p} \ldotp \delta \in \tsem{\Delta}^\textsc{p}
		\end{gather}
		While from (\ref{lem:pred-i2}) and from the definition of $\vDash$ we know that:
		\begin{gather}
			\label{lem:pred-i4} \forall e, \delta \in \tsem{\Delta'}^\textsc{p} \ldotp \tsem{\mathds{P}}(\lfloor \tsem{P}_{e, \delta} \rfloor_W) \subseteq \lfloor \tsem{Q}_{e, \delta} \rfloor_W
		\end{gather}
		From (\ref{lem:pred-i3}) and (\ref{lem:pred-i4}) we conclude that:
		\[
			\forall e, \delta \in \tsem{\Delta}^\textsc{p} \ldotp \tsem{\mathds{P}}(\lfloor \tsem{P}_{e, \delta} \rfloor_W) \subseteq \lfloor \tsem{Q}_{e, \delta} \rfloor_W
		\]
		which from the definition of $\vDash$ means that $\Delta \vDash \triple{P}{\mathds{P}}{Q}$ as needed.
	\end{proof}
\end{lem}

\begin{lem}
	\label{lem:simSat}
	(Similarity satisfaction).
	\[
		\forall e, \delta, \delta', \alpha, P \ldotp \delta \approx^\alpha \delta' \land \alpha \not\in P \implies \tsem{P}_{e, \delta} = \tsem{P}_{e, \delta'}
	\]
	\begin{proof}
		Let's pick arbitrary $e \in \mathsf{LEnv}, \delta, \delta' \in \mathsf{PEnv}, \alpha \in \mathsf{PName}, P \in \mathsf{Assn}$ and assume that $\delta \approx^\alpha \delta' \land \alpha \not\in P$ holds. Given that $\alpha$ does not occur anywhere in $P$ we can build a $\delta'' = \delta[\forall \vec{v} \ldotp (\alpha, \vec{v}) \mapsto \bot]$ such that $\tsem{P}_{e, \delta} = \tsem{P}_{e, \delta''}$. From definition of $\approx^\alpha$ we can also obtain the same $\delta'' = \delta'[\forall \vec{v} \ldotp (\alpha, \vec{v}) \mapsto \bot]$. It follows that $\tsem{P}_{e, \delta} = \tsem{P}_{e, \delta'}$.
	\end{proof}
\end{lem}

\begin{lem}
	\label{lem:pred-e}
	(Predicate elimination).
	If $\forall \delta \in \tsem{\Delta}^\textsc{p} \ldotp \mathsf{stable}_\delta(R)$ and $\alpha \not\in \Delta, P, Q$ and $\Delta, (\forall \vec{x} \ldotp \alpha(\vec{x}) \equiv R) \vDash \triple{P}{\mathds{P}}{Q}$ then $\Delta \vDash \triple{P}{\mathds{P}}{Q}$.
	\begin{proof}
		Let's pick arbitrary $\Delta \in \mathsf{Ax}, \mathds{P} \in \mathsf{Prog}, \alpha \in \mathsf{PName}, P, Q, R \in \mathsf{Assn}$ and assume that the following holds:
		\begin{gather}
			\label{lem:pred-e1} \forall \delta \in \tsem{\Delta}^\textsc{p} \ldotp \mathsf{stable}_\delta(R) \\
			\label{lem:pred-e2} \land\ \alpha \not\in \Delta, P, Q \\
			\label{lem:pred-e4} \land\ \Delta, (\forall \vec{x} \ldotp \alpha(\vec{x}) \equiv R) \vDash \triple{P}{\mathds{P}}{Q}
		\end{gather}
		We now pick arbitrary $\delta \in \tsem{\Delta}^\textsc{p}$ and $\delta' \in \tsem{\Delta, (\forall \vec{x} \ldotp \alpha(\vec{x}) \equiv R)}^\textsc{p}$. From (\ref{lem:pred-e1}), (\ref{lem:pred-e2}) and the definition of $\tsem{-}^\textsc{e}$ we obtain that:
		\begin{gather}
			\label{lem:pred-e3} \delta \approx^\alpha \delta'
		\end{gather}
		From (\ref{lem:pred-e2}), (\ref{lem:pred-e4}), (\ref{lem:pred-e3}) and Lemma \ref{lem:simSat} we conclude that $\Delta \vDash \triple{P}{\mathds{P}}{Q}$.
	\end{proof}
\end{lem}

\lem \label{lem:unlock} All read, write or alloc operations are followed by an unlock action on the same key done by the same transaction.
\[
	\forall \tau, \iota, k, \kappa, x \ldotp
	x = op(\iota, k) \land x \in \tau \implies \left( \tau \vDash x < \actunlock{\iota}{k} \right)
\]

\begin{proof}
Let's pick an arbitrary trace $\tau \in \mathsf{[(Act, \mathds{N})]}$, such that $\tau = \pred{trace}{h, \emptyset, \emptyset, \mathds{P}}$ for some $h \in \mathsf{Storage}$ and $\mathds{P} \in \mathsf{Prog}$, transaction identifier $\iota \in \mathsf{Tid}$, storage key $k \in \mathsf{Key}$ and lock mode $\kappa \in \mathsf{Lock}$. Now we assume that there exists an operation $x = op(\iota, k) = (\alpha, n)$ such that $x \in \tau$ (\textsc{i}). So $\alpha$ labels one of the transitions which is part of the sequence that reduces $\mathds{P}$ to $\pskip$ starting with storage $h$ (reduced to $h_{end}$), empty lock manager $\Phi_0 \equiv \emptyset$ (reduced to another empty one $\Phi_{end} \equiv \emptyset$) and empty transactions' state (reduced to $S_{end}$) from the definition of $\mathsf{trace}$. There are now three cases to consider, for some storage value $v \in \mathsf{Val}, m \in \mathds{N}$ and $l \in \mathsf{Key}$ such that $l \leq k < l + n$.
\begin{enumerate}
	\item If $\alpha = \actread{\iota}{k}{v}$, then it must be the case that the $\alpha$ action label was produced by the following \textsc{Read} reduction rule $(h, \emptyset, \emptyset, \mathds{P}) \rightarrow^* (h', \Phi', S', \mathds{P}') \xrightarrow{\alpha} (h', \Phi'', S'', \mathds{P}'') \rightarrow^* (h_{end}, \emptyset, S_{end}, \pskip)$, which, in order to succeed, requires that $\hat{\Phi}'(k) = \hat{\Phi}''(k) = (\{ \iota \} \cup I, \kappa)$ for some set of transaction identifiers $I$ and lock mode $\kappa \geq \textsc{s}$, meaning that $\Phi'' \not\equiv \emptyset$.
	
	\item If $\alpha = \actwrite{\iota}{k}{v}$, then it must be the case that the $\alpha$ action label was produced by the following \textsc{Write} reduction rule $(h, \emptyset, \emptyset, \mathds{P}) \rightarrow^* (h', \Phi', S', \mathds{P}') \xrightarrow{\alpha} (h', \Phi'', S'', \mathds{P}'') \rightarrow^* (h_{end}, \emptyset, S_{end}, \pskip)$, which, in order to succeed, requires that $\hat{\Phi}'(k) = \hat{\Phi}''(k) = (\{ \iota \}, \textsc{x})$, meaning that $\Phi'' \not\equiv \emptyset$.
	
	\item If $\alpha = \actalloc{\iota}{m}{l}$, then it must be the case that the $\alpha$ action label was produced by the following \textsc{Alloc} reduction rule $(h, \emptyset, \emptyset, \mathds{P}) \rightarrow^* (h', \Phi', S', \mathds{P}') \xrightarrow{\alpha} (h', \Phi'', S'', \mathds{P}'') \rightarrow^* (h_{end}, \emptyset, S_{end}, \pskip)$, which makes $\Phi'' = \Phi'[\vec{l} \mapsto (\{\iota\}, \textsc{x})]$. Given that $l \leq k < l + n$, then $\Phi''(k) = (\{\iota\}, \textsc{x})$ which implies that $\Phi'' \not\equiv \emptyset$.
\end{enumerate}

Now we assume that there is no action $\alpha'' = \actunlock{\iota}{k}$ such that $\tau \vDash x < \alpha''$. We know that for all cases $\alpha$ makes $\Phi'' \not\equiv \emptyset$ but then by assumption (\textsc{i}) we know that $\mathds{P}''$ succesfully reduces to $\pskip$ with $\Phi_{end} \equiv \emptyset$. This means that along the chain of reductions that brought $\Phi''$ to $\Phi_{end}$ there has been an update to the lock manager which removed the entry associated with $k$. This can only happen explicitly through actions labelled with \textsf{unlock} that are exclusively produced by the \textsc{Unlock} rule. This means that there is no possible way that $\mathds{P}''$ reduces to $\pskip$ with $\Phi_{end} \equiv \emptyset$, therefore by contradiction we must have an $\alpha'' = \actunlock{\iota}{k}$ such that $\tau \vDash x < \alpha''$.
\end{proof}

\lem \label{lem:read} All reads are preceded by the appropriate shared lock acquisition.
\begin{gather*}
\forall \tau, \iota, k, v, \kappa, x, n \ldotp \\
x = (\actread{\iota}{k}{v}, n) \land x \in \tau \implies \left( \tau \vDash \actlock{\iota}{k}{\kappa} < x \land \kappa \geq \textsc{s} \right)
\end{gather*}

\begin{proof}
Let's pick an arbitrary trace $\tau \in [\mathsf{Act} \times \mathds{N}]$, such that $\tau = \pred{trace}{h, \emptyset, \emptyset, \mathds{P}}$ for some $h \in \mathsf{Storage}$ and $\mathds{P} \in \mathsf{Prog}$, transaction identifier $\iota \in \mathsf{Tid}$, storage key $k \in \mathsf{Key}$, storage value $v \in \mathsf{Val}$ and lock mode $\kappa \in \mathsf{Lock}$. Now we assume that there exists an operation $x = (\alpha, n) = (\actread{\iota}{k}{v}, n)$ such that $x \in \tau$ (\textsc{i}). So $\alpha$ labels one of the transitions which is part of the sequence that reduces $\mathds{P}$ to $\pskip$ starting with storage $h$ (reduced to $h_{end}$), empty lock manager $\Phi_0 \equiv \emptyset$ (reduced to another empty one $\Phi_{end} \equiv \emptyset$) and empty transactions' state (reduced to $S_{end}$) from the definition of $\mathsf{trace}$. It must be the case that the $\alpha$ action label was produced by the following \textsc{Read} reduction rule $(h, \emptyset, \emptyset, \mathds{P}) \rightarrow^* (h', \Phi', S', \mathds{P}') \xrightarrow{\alpha} (h', \Phi', S'', \mathds{P}'') \rightarrow^* (h_{end}, \emptyset, S_{end}, \pskip)$, which, in order to succeed, requires that $\hat{\Phi}'(k) = (\{ \iota \} \cup I, \kappa)$ for some set of transaction identifiers $I$ and lock mode $\kappa \geq \textsc{s}$.

Then we assume that there is no action $\alpha' = \actlock{\iota}{k}{\kappa}$ such that $\tau \vDash \alpha' < x$, and given that the lock manager is only updated for acquisition through reductions labelled with \textsf{lock} as part of the explicit \textsc{Lock} rule, then there is no possible way that the state $(h', \Phi', S', \mathds{P}')$ succesfully reduced through $\alpha$ since $\hat{\Phi}'(k) = (I'
, \kappa)$ would be such that $\iota \not\in I'$. By contradiction, this means that we must have an $\alpha' = \actlock{\iota}{k}{\kappa}$ such that $\tau \vDash \alpha' < x$.
\end{proof}

\lem \label{lem:write} All writes to a cell are preceded by the appropriate exclusive lock acquisition.
\begin{gather*}
\forall \tau, x, i, k, v, n \ldotp
x = (\actwrite{i}{k}{v}, n) \land x \in \tau \implies
\tau \vDash \actlock{i}{k}{\textsc{x}} < x
\end{gather*}

\begin{proof}
Let's pick an arbitrary trace $\tau \in [\mathsf{Act} \times \mathds{N}]$, such that $\tau = \pred{trace}{h, \emptyset, \emptyset, \mathds{P}}$ for some $h \in \mathsf{Storage}$ and $\mathds{P} \in \mathsf{Prog}$, transaction identifier $i \in \mathsf{Tid}$, storage key $k \in \mathsf{Key}$. Now we assume that  $x \in \tau$ where $x = (\actwrite{i}{k}{v}, n) = (\alpha, n)$ for some $n \in \mathds{N}$. Then, $\alpha$ must label a reduction that brings $\mathds{P}$ to $\pskip$ in $\tau$, by definition of $\mathsf{trace}$. Therefore we must have the following reduction for some $h', h'', \Phi', \Phi'', S', \mathds{P}', \mathds{P}''$.
\[
(h, \emptyset, \emptyset, \mathds{P}) \rightarrow^* (h', \Phi', S', \mathds{P}') \xrightarrow{\alpha} (h'', \Phi'', S', \mathds{P}'')
\]
Then we assume that there is no action $\alpha' = \actlock{\iota}{k}{\textsc{x}}$ such that $\tau \vDash \alpha' < x$. Given that the $\alpha$ label can only be generated by the \textsc{Write} rule, it is required for $\Phi'$ to be such that (\textsc{i}) $(\{i\}, \textsc{x}) = \hat{\Phi}'(k)$. Since the lock manager starts as an empty one ($\Phi_0 = \emptyset$), condition (\textsc{i}) is only satisfied when a $\mathsf{lock}$ label is generated by the \textsc{Lock} rule before $\alpha$ and the lock mode obtained is exclusive (\textsc{x}). By contradiction we therefore obtain that $\tau \vDash \alpha' < x$ must hold.
\end{proof}

\lem \label{lem:allocBefore} A read or write operation accessing a cell allocated as part of the trace, must appear after the corresponding alloc action.
\begin{gather*}
	\forall \tau, i, j, x, x', n, n', l, m, k, v, \kappa \ldotp \\
	x = (\actalloc{i}{m}{l}, n) \land x' \in \{ (\actread{j}{k}{v}, n'), (\actwrite{j}{k}{v}, n') \} \land l \leq k < l + m
	\\
	\land x \in \tau \land x' \in \tau
	\implies
	\left( \tau \vDash x < x'  \land \tau \vDash \actunlock{i}{k} < \actlock{j}{k}{\kappa} \right)
\end{gather*}
\begin{proof}
Let's pick an arbitrary trace $\tau \in [\mathsf{Act} \times \mathds{N}]$, such that $\tau = \pred{trace}{h, \emptyset, \emptyset, \mathds{P}}$ for some $h \in \mathsf{Storage}$ and $\mathds{P} \in \mathsf{Prog}$, transaction identifiers $i, j \in \mathsf{Tid}$, storage keys $k, l \in \mathsf{Key}, m, n, n' \in \mathds{N}$, value $v \in \mathsf{Val}$, lock mode $\kappa \in \mathsf{Lock}$ and operations $x, x' \in \mathsf{Act} \times \mathds{N}$. We now assume that the following holds, for $\alpha = x \downarrow_1$:
\begin{gather}
	\label{lem:allocBefore1}
	\begin{array}{c}
		x = (\actalloc{i}{m}{l}, n) \land x' \in \{ (\actread{j}{k}{v}, n'), (\actwrite{j}{k}{v}, n') \} \land l \leq k < l + m
		\\
		\land x \in \tau \land x' \in \tau
	\end{array}
\end{gather}
From the definition of $\mathsf{trace}$ and (\ref{lem:allocBefore1}) we obtain that such reduction occurred as part of $\tau$:
\begin{gather}
	\label{lem:allocBefore2}	
	(h, \Phi, S, \mathds{P}) \rightarrow^* (h', \Phi', S', \mathds{P}') \xrightarrow{\alpha} (h'', \Phi'', S'', \mathds{P}'')
\end{gather}
In both cases where $\alpha$ is a $\mathsf{read}$ or a $\mathsf{write}$ on $k$, it is required for $k \in \pred{dom}{h'}$ to hold. From (\ref{lem:allocBefore1}) we know that $k$ is part of the keys allocated by $x$, therefore by (\ref{lem:allocBefore2}), $\alpha$ must appear in one of the reductions from $(h, \Phi, S, \mathds{P})$ to $(h', \Phi', S', \mathds{P}')$ which by definition means that $\tau \vDash x < x'$.

Now, from Lemma \ref{lem:unlock} we know that there must be an action $u_i = (\actunlock{i}{k}, n_u)$ for $n_u \in \mathds{N}$, such that $\tau \vDash x < u_i$.
We also know from Lemma \ref{lem:write} that there exists an action $l_j = (\alpha_l, n_l) = (\actlock{j}{k}{\kappa_j}, n_l)$ for $\kappa_j \geq \textsc{s}$ and $n_l \in \mathds{N}$, such that $\tau \vDash l_j < x'$. As $\alpha$ sets an exclusive lock on $k$ for transaction $i$, it follows that, in order for $\alpha_l$ to succesfully reduce, there must be an unlock operation that happens before $\alpha_l$. This implies that $\tau \vDash u_i < l_j$ as needed.
\end{proof}

\lem \label{lem:2phase} No lock is acquired by a transaction after one gets released by the same transaction.
\begin{gather*}
	\forall \tau, \iota, k, k', n, n', x, x', \kappa \ldotp \\
	\left( x = (\actlock{\iota}{k}{\kappa}, n) \land x' = (\actunlock{\iota}{k'}, n') \land x \in \tau \land x' 	\in \tau \right) \\
	\implies \left( \tau \vDash x < x' \right)
\end{gather*}

\begin{proof}
Let's pick an arbitrary trace $\tau \in [\mathsf{Act} \times \mathds{N}]$, such that $\tau = \pred{trace}{h, \emptyset, \emptyset, \mathds{P}}$ for some $h \in \mathsf{Storage}$ and $\mathds{P} \in \mathsf{Prog}$, transaction identifier $\iota \in \mathsf{Tid}$, storage keys $k, k' \in \mathsf{Key}$ and lock mode $\kappa \in \mathsf{Lock}$, $n, n' \in \mathds{N}$. Now we assume that  $x \in \tau$ and $x' \in \tau$ (\textsc{i}), where $x = (\alpha_l, n) = (\actlock{\iota}{k}{\kappa}, n)$ and $x' = (\alpha_u, n') = (\actunlock{\iota}{k}, n)$, therefore $\alpha_l$ and $\alpha_u$ are two lock and unlock operations, respectively, performed by the same transaction identified with $\iota$ as part of trace $\tau$.

Let's assume that $\tau \vDash x' < x$ (\textsc{i}). The action label \textsf{unlock} is only generated by the reduction rule \textsc{Unlock}. Therefore it must be the case that $(h, \emptyset, \emptyset, \mathds{P}) \rightarrow^* (h', \Phi', S', \mathds{P}') \xrightarrow{\alpha_u} (h', \Phi'', S'', \mathds{P}')$ (\textsc{ii}), for some $h', \Phi', \Phi'', S', S'', \mathds{P}'$, which only reduces when $(s', p', \mathds{C}) \xrightarrow{\alpha_u} (s', \pshrink, \mathds{C})$, for some command $\mathds{C}$ in $\mathds{P}'$, where $(s', p') = S'(\iota)$ and $S'' = S'[\iota \mapsto (s', \pshrink)]$.

The action label \textsf{lock} is only generated by the reduction rule \textsc{Lock}. By (\textsc{i}) and (\textsc{ii}), it must be the case that $(h', \Phi'', S'', \mathds{P}') \rightarrow^* (h_l, \Phi_l, S_l, \mathds{P}_l) \xrightarrow{\alpha_l} (h_l, \Phi_l', S_l', \mathds{P}_l)$, for some $h_l, S_l, S_l', \Phi_l, \Phi_l', \mathds{P}_l$, that reduces only when $(s_l, \pgrow, \mathds{C}') \xrightarrow{\alpha_l} (s_l, \pgrow, \mathds{C}')$, for some $\mathds{C}'$ in $\mathds{P}_l$, where $(s_l, \pgrow) = S_l(\iota)$. The latter condition is impossible since there is no semantic rule that allows a transaction phase to go from shrinking to growing, and $(s', \pshrink) = S''(\iota)$ which is set before $S_l$. By contradiction, we obtain that $\tau \vDash x < x'$ must hold.
\end{proof}

\lem \label{lem:conflict} If two transactions run conflicting operations on the same item, either one releases its lock before the other acquires it or vice versa.
\begin{gather*}
\forall \tau, i, j, k, \kappa, \kappa', x, x' \ldotp \\
x = op(i, k) \in \tau \land x' = op(j, k) \in \tau \land \pred{conflict}{x, x'} \\
\implies \left( \tau \vDash \actunlock{i}{k} < \actlock{j}{k}{\kappa} \right) \lor \left( \tau \vDash \actunlock{j}{k} < \actlock{i}{k}{\kappa'} \right)
\end{gather*}

\begin{proof}
Let's pick an arbitrary trace $\tau \in [\mathsf{Act} \times \mathds{N}]$, such that $\tau = \pred{trace}{h, \emptyset, \emptyset, \mathds{P}}$ for some $h \in \mathsf{Storage}$ and $\mathds{P} \in \mathsf{Prog}$, transaction identifiers $i, j \in \mathsf{Tid}$, storage key $k \in \mathsf{Key}$, operations $x, x' \in (\mathsf{Act}, \mathds{N})$ and lock modes $\kappa, \kappa' \in \mathsf{Lock}$. We assume that the statements $x = op(i, k) \in \tau, x' = op(j, k) \in \tau$ and $\pred{conflict}{x, x'}$ hold.

Let's consider the case where one of $x$ or $x'$ is an $\mathsf{alloc}$ operation. Without loss of generality we say that $x = (\actalloc{i}{m}{l}, n)$ for $n, m \in \mathds{N}, l \in \mathsf{Key}$. Given that $x$ and $x'$ are in conflict, it follows that $x' = (\alpha', n')$ is either a read or a write on $k$ done by a transaction $j$ such that $i \neq j$ and $l \leq k < l + m$. We can now directly apply Lemma \ref{lem:allocBefore} and obtain the required result.

The focus now shifts to the scenario where both $x$ and $x'$ are read or write operations on $k$. We  reasonably assume that $\kappa$ and $\kappa'$ are the needed lock modes for transactions $i$ and $j$ to perform actions $\alpha$ and $\alpha'$ respectively. Let $\alpha_i^l = \actlock{i}{k}{\kappa}, \alpha_i^u = \actunlock{i}{k}, \alpha_j^l = \actlock{j}{k}{\kappa'}, \alpha_j^u = \actunlock{j}{k}$. From Lemma \ref{lem:unlock}, Lemma \ref{lem:read} and Lemma \ref{lem:write} it follows that $\alpha_i^l, \alpha_i^u, \alpha_j^l, \alpha_j^u \in \tau$ and that $\alpha_i^l < \alpha_i^u \land \alpha_j^l < \alpha_j^u$ (\textsc{i}).

In the case that $i = j$, the result follows directly from Lemma \ref{lem:2phase} while we now proceed the proof considering $i \neq j$.

We now assume that $\lnot \left( \tau \vDash \alpha_i^u < \alpha_j^l  \lor \tau \vDash \alpha_j^u < \alpha_i^l \right)$ holds, which is equivalent to assuming that $\tau \vDash \alpha_j^l < \alpha_i^u$ and $\tau \vDash \alpha_i^l < \alpha_j^u$ hold, given that we know that all operations belong to $\tau$ and there must be an order among them. The statement, together with (\textsc{i}), implies that either $\tau \vDash \alpha_j^l < \alpha_i^l < \alpha_j^u < \alpha_i^u$ or $\tau \vDash \alpha_j^l < \alpha_i^l < \alpha_i^u < \alpha_j^u$ or $\tau \vDash \alpha_i^l < \alpha_j^l < \alpha_j^u < \alpha_i^u$ or $\tau \vDash \alpha_i^l < \alpha_j^l < \alpha_i^u < \alpha_j^u$ holds. For the rest of the proof we will use the first scenario, since an equivalent argument with the appropriate substitutions can be made for the other three.

Therefore, the reduction chain which generated $\tau$ and that brings $\mathds{P}$ to $\pskip$ (by definition of $\mathsf{trace}$) must have the following shape, for some $h_1, \Phi_1, S_1, \mathds{P}_1, \Phi_1'$, $h_2, \Phi_2, S_2, \mathds{P}_2, \Phi_2'$, $h_3, \Phi_3, S_3, \mathds{P}_3, \Phi_3', S_3'$, $h_4, \Phi_4, S_4, \mathds{P}_4, \Phi_4', S_4'$.
\begin{gather*}
(h, \emptyset, \emptyset, \mathds{P}) \rightarrow^* (h_1, \Phi_1, S_1, \mathds{P}_1) \xrightarrow{\alpha_j^l} (h_1, \Phi_1', S_1, \mathds{P}_1) \rightarrow^* (h_2, \Phi_2, S_2, \mathds{P}_2) \xrightarrow{\alpha_i^l} (h_2, \Phi_2', S_2, \mathds{P}_2)
\\
\rightarrow^* (h_3, \Phi_3, S_3, \mathds{P}_3) \xrightarrow{\alpha_j^u} (h_3, \Phi_3', S_3', \mathds{P}_3) \rightarrow^* (h_4, \Phi_4, S_4, \mathds{P}_4) \xrightarrow{\alpha_i^u} (h_4, \Phi_4', S_4', \mathds{P}_4)
\end{gather*}
By our initial assumption, we know that the $\alpha$ and $\alpha'$ actions are conflicting, meaning that one of them (or both) is a write operation on $k$. We will consider the situation where $\alpha$ is a write action, noting that an equivalent proof can be obtained by having $\alpha'$ a write and making the appropriate substitutions. The transition labelled as $\alpha_j^l$ updates $\Phi_1$ to be (\textsc{ii}) $\Phi_1' = \Phi_1[k \mapsto (\{\iota\} \cup I, \kappa)]$ for some (potentially empty) set of transaction identifiers $I$.

Now we can establish that there cannot be any $\alpha_j^{u'} = \actunlock{j}{k}$ such that $\tau \vDash \alpha_j^l < \alpha_j^{u'} < \alpha_i^l$ (\textsc{iii}). Let's on the contrary assume that there exists such $\alpha_j^{u'}$. Then it must be the case that $\tau \vDash \alpha_j^{u'} < \alpha_j^{u}$ since $\tau \vDash \alpha_i^l < \alpha_j^u$ and $\tau \vDash \alpha_j^{u'} < \alpha_i^l$. This cannot be possible, given that by Lemma \ref{lem:2phase} there cannot be an action $\alpha_j^{l'} = \actlock{j}{k}{\kappa}$ such that $\tau \vDash \alpha_j^{u'} < \alpha_j^{l'} < \alpha_j^{u}$ and the $\mathsf{unlock}$ action label can only be generated through the \textsc{Unlock} rule which requires $j$ to be in the set of owners of $k$ in the lock manager which was removed by $\alpha_j^{u'}$ and never added back. By contradiction we obtain that no such $\alpha_j^{u'}$ exists.

From (\textsc{ii}) and (\textsc{iii}) we obtain that $(\{j\} \uplus I, \kappa) = \hat{\Phi}_2(k)$ meaning that the set of owners of $k$ is definitely non-empty and moreover it definitely contains $j$. It follows that there is no possible way of the $\alpha_i^l$ transition happening since it can only be produced by the \textsc{Lock} rule which requires $(\emptyset, \textsc{u}) = \hat{\Phi}_2(k)$ or $(\{ i \}, \textsc{s}) = \hat{\Phi}_2(k)$. By contradiction we get that $\tau \vDash \alpha_i^u < \alpha_j^l  \lor \tau \vDash \alpha_j^u < \alpha_i^l$ must hold.
\end{proof}