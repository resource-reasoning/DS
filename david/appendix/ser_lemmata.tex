\section{Auxiliary Lemmata for Serializability}

\begin{lem}
	\label{lem:unlock}
	All read, write or alloc operations are followed by an unlock action on the same key done by the same transaction.
	\[
		\forall \tau, \iota, k, \kappa, x \ldotp
		x = op(\iota, k) \land x \in \tau \implies \left( \tau \vDash x < \actunlock{\iota}{k} \right)
	\]
	
	\begin{proof}
	Let's pick an arbitrary trace $\tau \in \mathsf{[(Act, \mathds{N})]}$, such that $\tau = \pred{trace}{h, \emptyset, S, \mathds{P}}$ for some $h \in \mathsf{Storage}, S \in \mathsf{TState}$ and $\mathds{P} \in \mathsf{Prog}$, transaction identifier $\iota \in \mathsf{Tid}$, storage key $k \in \mathsf{Key}$ and lock mode $\kappa \in \mathsf{Lock}$. Now we assume that there exists an operation $x = op(\iota, k) = (\alpha, n)$ such that $x \in \tau$ (\textsc{i}). So $\alpha$ labels one of the transitions which is part of the sequence that reduces $\mathds{P}$ to $\pskip$ starting with storage $h$ (reduced to $h_{end}$), empty lock manager $\Phi_0 = \emptyset$ (reduced to another empty one $\Phi_{end} = \emptyset$) and empty transactions' state (reduced to $S_{end}$) from the definition of $\mathsf{trace}$. There are now three cases to consider, for some storage value $v \in \mathsf{Val}, m \in \mathds{N}$ and $l \in \mathsf{Key}$ such that $l \leq k < l + n$.
	\begin{enumerate}
		\item If $\alpha = \actread{\iota}{k}{v}$, then it must be the case that the $\alpha$ action label was produced by the following \textsc{Read} reduction rule $(h, \emptyset, S, \mathds{P}) \rightarrow^* (h', \Phi', S', \mathds{P}') \xrightarrow{\alpha} (h', \Phi'', S'', \mathds{P}'') \rightarrow^* (h_{end}, \emptyset, S_{end}, \pskip)$, which, in order to succeed, requires that $\hat{\Phi}'(k) = \hat{\Phi}''(k) = (\{ \iota \} \cup I, \kappa)$ for some set of transaction identifiers $I$ and lock mode $\kappa \geq \textsc{s}$, meaning that $\Phi'' \neq \emptyset$.
		
		\item If $\alpha = \actwrite{\iota}{k}{v}$, then it must be the case that the $\alpha$ action label was produced by the following \textsc{Write} reduction rule $(h, \emptyset, S, \mathds{P}) \rightarrow^* (h', \Phi', S', \mathds{P}') \xrightarrow{\alpha} (h', \Phi'', S'', \mathds{P}'') \rightarrow^* (h_{end}, \emptyset, S_{end}, \pskip)$, which, in order to succeed, requires that $\hat{\Phi}'(k) = \hat{\Phi}''(k) = (\{ \iota \}, \textsc{x})$, meaning that $\Phi'' \neq \emptyset$.
		
		\item If $\alpha = \actalloc{\iota}{m}{l}$, then it must be the case that the $\alpha$ action label was produced by the following \textsc{Alloc} reduction rule $(h, \emptyset, S, \mathds{P}) \rightarrow^* (h', \Phi', S', \mathds{P}') \xrightarrow{\alpha} (h', \Phi'', S'', \mathds{P}'') \rightarrow^* (h_{end}, \emptyset, S_{end}, \pskip)$, which makes $\Phi'' = \Phi'[\vec{l} \mapsto (\{\iota\}, \textsc{x})]$. Given that $l \leq k < l + n$, then $\Phi''(k) = (\{\iota\}, \textsc{x})$ which implies that $\Phi'' \neq \emptyset$.
	\end{enumerate}
	
	Now we assume that there is no action $\alpha'' = \actunlock{\iota}{k}$ such that $\tau \vDash x < \alpha''$. We know that for all cases $\alpha$ makes $\Phi'' \neq \emptyset$ but then by assumption (\textsc{i}) we know that $\mathds{P}''$ succesfully reduces to $\pskip$ with $\Phi_{end} = \emptyset$. This means that along the chain of reductions that brought $\Phi''$ to $\Phi_{end}$ there has been an update to the lock manager which removed the entry associated with $k$. This can only happen explicitly through actions labelled with \textsf{unlock} that are exclusively produced by the \textsc{Unlock} rule. It follows that there is no possible way that $\mathds{P}''$ reduces to $\pskip$ with $\Phi_{end} = \emptyset$, therefore by contradiction we must have an $\alpha'' = \actunlock{\iota}{k}$ such that $\tau \vDash x < \alpha''$.
	\end{proof}
\end{lem}

\begin{lem}
	\label{lem:read}
	All reads are preceded by the appropriate shared lock acquisition.
	\begin{gather*}
	\forall \tau, \iota, k, v, \kappa, x, n \ldotp \\
	x = (\actread{\iota}{k}{v}, n) \land x \in \tau \implies \left( \tau \vDash \actlock{\iota}{k}{\kappa} < x \land \kappa \geq \textsc{s} \right)
	\end{gather*}
	
	\begin{proof}
	Let's pick an arbitrary trace $\tau \in [\mathsf{Act} \times \mathds{N}]$, such that $\tau = \pred{trace}{h, \emptyset, S, \mathds{P}}$ for some $h \in \mathsf{Storage}, S \in \mathsf{TState}$ and $\mathds{P} \in \mathsf{Prog}$, transaction identifier $\iota \in \mathsf{Tid}$, storage key $k \in \mathsf{Key}$, storage value $v \in \mathsf{Val}$ and lock mode $\kappa \in \mathsf{Lock}$. Now we assume that there exists an operation $x = (\alpha, n) = (\actread{\iota}{k}{v}, n)$ such that $x \in \tau$ (\textsc{i}). So $\alpha$ labels one of the transitions which is part of the sequence that reduces $\mathds{P}$ to $\pskip$ starting with storage $h$ (reduced to $h_{end}$), empty lock manager $\Phi_0 = \emptyset$ (reduced to another empty one $\Phi_{end} = \emptyset$) and empty transactions' state (reduced to $S_{end}$) from the definition of $\mathsf{trace}$. It must be the case that the $\alpha$ action label was produced by the following \textsc{Read} reduction rule $(h, \emptyset, S, \mathds{P}) \rightarrow^* (h', \Phi', S', \mathds{P}') \xrightarrow{\alpha} (h', \Phi', S'', \mathds{P}'') \rightarrow^* (h_{end}, \emptyset, S_{end}, \pskip)$, which, in order to succeed, requires that $\hat{\Phi}'(k) = (\{ \iota \} \cup I, \kappa)$ for some set of transaction identifiers $I$ and lock mode $\kappa \geq \textsc{s}$.
	
	Then we assume that there is no action $\alpha' = \actlock{\iota}{k}{\kappa}$ such that $\tau \vDash \alpha' < x$, and given that the lock manager is only updated for acquisition through reductions labelled with \textsf{lock} as part of the explicit \textsc{Lock} rule, then there is no possible way that the state $(h', \Phi', S', \mathds{P}')$ succesfully reduced through $\alpha$ since $\hat{\Phi}'(k) = (I'
	, \kappa)$ would be such that $\iota \not\in I'$. By contradiction, this means that we must have an $\alpha' = \actlock{\iota}{k}{\kappa}$ such that $\tau \vDash \alpha' < x$.
	\end{proof}
\end{lem}

\begin{lem}
	\label{lem:write}
	All writes to a cell are preceded by the appropriate exclusive lock acquisition.
	\begin{gather*}
	\forall \tau, x, i, k, v, n \ldotp
	x = (\actwrite{i}{k}{v}, n) \land x \in \tau \implies
	\tau \vDash \actlock{i}{k}{\textsc{x}} < x
	\end{gather*}
	
	\begin{proof}
	Let's pick an arbitrary trace $\tau \in [\mathsf{Act} \times \mathds{N}]$, such that $\tau = \pred{trace}{h, \emptyset, S, \mathds{P}}$ for some $h \in \mathsf{Storage}, S \in \mathsf{TState}$ and $\mathds{P} \in \mathsf{Prog}$, transaction identifier $i \in \mathsf{Tid}$, storage key $k \in \mathsf{Key}$. Now we assume that  $x \in \tau$ where $x = (\actwrite{i}{k}{v}, n) = (\alpha, n)$ for some $n \in \mathds{N}$. Then, $\alpha$ must label a reduction that brings $\mathds{P}$ to $\pskip$ in $\tau$, by definition of $\mathsf{trace}$. Therefore we must have the following reduction for some $h', h'', \Phi', \Phi'', S', \mathds{P}', \mathds{P}''$:
	\[
		(h, \emptyset, S, \mathds{P}) \rightarrow^* (h', \Phi', S', \mathds{P}') \xrightarrow{\alpha} (h'', \Phi'', S', \mathds{P}'')
	\]
	Then we assume that there is no action $\alpha' = \actlock{\iota}{k}{\textsc{x}}$ such that $\tau \vDash \alpha' < x$. Given that the $\alpha$ label can only be generated by the \textsc{Write} rule, it is required for $\Phi'$ to be such that (\textsc{i}) $(\{i\}, \textsc{x}) = \hat{\Phi}'(k)$. Since the lock manager starts as an empty one ($\Phi_0 = \emptyset$), condition (\textsc{i}) is only satisfied when a $\mathsf{lock}$ label is generated by the \textsc{Lock} rule before $\alpha$ and the lock mode obtained is exclusive (\textsc{x}). By contradiction we therefore obtain that $\tau \vDash \alpha' < x$ must hold.
	\end{proof}
\end{lem}

\begin{lem}
	\label{lem:allocBefore}
	A read or write operation accessing a cell allocated as part of the trace, must appear after the corresponding alloc action.
	\begin{gather*}
		\forall \tau, i, j, x, x', n, n', l, m, k, v, \kappa \ldotp \\
		x = (\actalloc{i}{m}{l}, n) \land x' \in \{ (\actread{j}{k}{v}, n'), (\actwrite{j}{k}{v}, n') \} \land l \leq k < l + m
		\\
		\land x \in \tau \land x' \in \tau
		\implies
		\left( \tau \vDash x < x'  \land \tau \vDash \actunlock{i}{k} < \actlock{j}{k}{\kappa} \right)
	\end{gather*}
	\begin{proof}
	Let's pick an arbitrary trace $\tau \in [\mathsf{Act} \times \mathds{N}]$, such that $\tau = \pred{trace}{h, \emptyset, S, \mathds{P}}$ for some $h \in \mathsf{Storage}, S \in \mathsf{TState}$ and $\mathds{P} \in \mathsf{Prog}$, transaction identifiers $i, j \in \mathsf{Tid}$, storage keys $k, l \in \mathsf{Key}, m, n, n' \in \mathds{N}$, value $v \in \mathsf{Val}$, lock mode $\kappa \in \mathsf{Lock}$ and operations $x, x' \in \mathsf{Act} \times \mathds{N}$. We now assume that the following holds:
	\begin{gather}
		\label{lem:allocBefore1}
		\begin{array}{c}
			x = (\actalloc{i}{m}{l}, n) \land x' \in \{ (\actread{j}{k}{v}, n'), (\actwrite{j}{k}{v}, n') \}
			\\
			\land\ l \leq k < l + m
			\land x \in \tau \land x' \in \tau
		\end{array}
	\end{gather}
	From the definition of $\mathsf{trace}$ and (\ref{lem:allocBefore1}) we obtain that the following reduction occurred as part of $\tau$, for $\alpha' = x' \downarrow_1$:
	\begin{gather}
		\label{lem:allocBefore2}	
		(h, \emptyset, S, \mathds{P}) \rightarrow^* (h', \Phi', S', \mathds{P}') \xrightarrow{\alpha'} (h'', \Phi'', S'', \mathds{P}'')
	\end{gather}
	In both cases where $\alpha'$ is a $\mathsf{read}$ or a $\mathsf{write}$ on $k$, it is required for $k \in \pred{dom}{h'}$ to hold, from their label semantic interpretation. From (\ref{lem:allocBefore1}) we know that $k$ is part of the keys allocated by $x$, therefore by (\ref{lem:allocBefore2}), $\alpha = x \downarrow_1$ must appear in one of the reductions from $(h, \Phi, S, \mathds{P})$ to $(h', \Phi', S', \mathds{P}')$ which by definition means that $\tau \vDash x < x'$.
	
	Now, from Lemma \ref{lem:unlock} we know that there must be an action $u_i = (\actunlock{i}{k}, n_u)$ for $n_u \in \mathds{N}$, such that $\tau \vDash x < u_i$.
	We also know from Lemma \ref{lem:write} that there exists an action $l_j = (\alpha_l, n_l) = (\actlock{j}{k}{\kappa_j}, n_l)$ for $\kappa_j \geq \textsc{s}$ and $n_l \in \mathds{N}$, such that $\tau \vDash l_j < x'$. As $\alpha$ sets an exclusive lock on $k$ for transaction $i$, it follows that, in order for $\alpha_l$ to succesfully reduce, there must be an unlock operation that happens before $\alpha_l$. This implies that $\tau \vDash u_i < l_j$ as needed.
	\end{proof}
\end{lem}

\lem \label{lem:2phase} No lock is acquired by a transaction after one gets released by the same transaction.
\begin{gather*}
	\forall \tau, \iota, k, k', n, n', x, x', \kappa \ldotp \\
	\left( x = (\actlock{\iota}{k}{\kappa}, n) \land x' = (\actunlock{\iota}{k'}, n') \land x \in \tau \land x' 	\in \tau \right) \\
	\implies \left( \tau \vDash x < x' \right)
\end{gather*}

\begin{proof}
Let's pick an arbitrary trace $\tau \in [\mathsf{Act} \times \mathds{N}]$, such that $\tau = \pred{trace}{h, \emptyset, S, \mathds{P}}$ for some $h \in \mathsf{Storage}, S \in \mathsf{TState}$ and $\mathds{P} \in \mathsf{Prog}$, transaction identifier $\iota \in \mathsf{Tid}$, storage keys $k, k' \in \mathsf{Key}$ and lock mode $\kappa \in \mathsf{Lock}$, $n, n' \in \mathds{N}$. Now we assume that  $x \in \tau$ and $x' \in \tau$, where $x = (\alpha_l, n) = (\actlock{\iota}{k}{\kappa}, n)$ and $x' = (\alpha_u, n') = (\actunlock{\iota}{k}, n)$, therefore $\alpha_l$ and $\alpha_u$ are two lock and unlock actions, respectively, performed by the same transaction identified with $\iota$ as part of trace $\tau$.

Let's start by assuming that the unlock operation happens before the lock one, in $\tau$:
\begin{gather}
	\label{2phase1}
	\tau \vDash x' < x
\end{gather}
The action label \textsf{unlock} is only generated by the reduction rule \textsc{Unlock}. Therefore it must be the case that, for some $h', \Phi', \Phi'', S', S'', \mathds{P}'$:
\begin{gather}
	\label{2phase2}
	(h, \emptyset, S, \mathds{P}) \rightarrow^* (h', \Phi', S', \mathds{P}') \xrightarrow{\alpha_u} (h', \Phi'', S'', \mathds{P}')
\end{gather}
We know that the reduction in (\ref{2phase2}) can only happen when $(s', p', \mathds{C}) \xrightarrow{\alpha_u} (s', \pshrink, \mathds{C})$, for some command $\mathds{C}$ in $\mathds{P}'$, where $(s', p') = S'(\iota)$ and $S'' = S'[\iota \mapsto (s', \pshrink)]$.

The action label \textsf{lock} is only generated by the reduction rule \textsc{Lock}. From (\ref{2phase1}) and (\ref{2phase2}), it must be the case that, for some $h_l, S_l, S_l', \Phi_l, \Phi_l', \mathds{P}_l$:
\[
	(h', \Phi'', S'', \mathds{P}') \rightarrow^* (h_l, \Phi_l, S_l, \mathds{P}_l) \xrightarrow{\alpha_l} (h_l, \Phi_l', S_l', \mathds{P}_l)
\]
that only reduces when $(s_l, \pgrow, \mathds{C}') \xrightarrow{\alpha_l} (s_l, \pgrow, \mathds{C}')$, for some $\mathds{C}'$ in $\mathds{P}_l$, where $(s_l, \pgrow) = S_l(\iota)$. The latter condition is impossible since there is no semantic rule that allows a transaction phase to go from shrinking to growing, and $(s', \pshrink) = S''(\iota)$ which is set before $S_l$. By contradiction, we obtain that $\tau \vDash x < x'$ must hold.
\end{proof}

\lem \label{lem:conflict} If two transactions run conflicting operations on the same item, either one releases its lock before the other acquires it or vice versa.
\begin{gather*}
\forall \tau, i, j, k, \kappa, \kappa', x, x' \ldotp \\
x = op(i, k) \in \tau \land x' = op(j, k) \in \tau \land \pred{conflict}{x, x'} \\
\implies \left( \tau \vDash \actunlock{i}{k} < \actlock{j}{k}{\kappa} \right) \lor \left( \tau \vDash \actunlock{j}{k} < \actlock{i}{k}{\kappa'} \right)
\end{gather*}

\begin{proof}
Let's pick an arbitrary trace $\tau \in [\mathsf{Act} \times \mathds{N}]$, such that $\tau = \pred{trace}{h, \emptyset, S, \mathds{P}}$ for some $h \in \mathsf{Storage}, S \in \mathsf{TState}$ and $\mathds{P} \in \mathsf{Prog}$, transaction identifiers $i, j \in \mathsf{Tid}$, storage key $k \in \mathsf{Key}$, operations $x, x' \in (\mathsf{Act}, \mathds{N})$ and lock modes $\kappa, \kappa' \in \mathsf{Lock}$. We assume that the statements $x = op(i, k) \in \tau, x' = op(j, k) \in \tau$ and $\pred{conflict}{x, x'}$ hold.

Let's consider the case where one of $x$ or $x'$ is an $\mathsf{alloc}$ operation. Without loss of generality we say that $x = (\actalloc{i}{m}{l}, n)$ for $n, m \in \mathds{N}, l \in \mathsf{Key}$. Given that $x$ and $x'$ are in conflict, it follows that $x' = (\alpha', n')$ is either a read or a write on $k$ done by a transaction $j$ such that $i \neq j$ and $l \leq k < l + m$. We can now directly apply Lemma \ref{lem:allocBefore} and obtain the required result.

The focus now shifts to the scenario where both $x$ and $x'$ are read or write operations on $k$. We  reasonably assume that $\kappa$ and $\kappa'$ are the needed lock modes for transactions $i$ and $j$ to perform actions $\alpha$ and $\alpha'$ respectively. Let $\alpha_i^l = \actlock{i}{k}{\kappa}, \alpha_i^u = \actunlock{i}{k}, \alpha_j^l = \actlock{j}{k}{\kappa'}, \alpha_j^u = \actunlock{j}{k}$. From Lemma \ref{lem:unlock}, Lemma \ref{lem:read} and Lemma \ref{lem:write} it follows that:
\begin{gather}
	\label{lem:conflict1}
	\begin{array}{c @{\hspace{40pt}} c}
		\alpha_i^l, \alpha_i^u, \alpha_j^l, \alpha_j^u \in \tau
		&
		\tau \vDash \alpha_i^l < \alpha_i^u \land \tau \vDash \alpha_j^l < \alpha_j^u
	\end{array}
\end{gather}

In the case that $i = j$, meaning that the two operations are being done by the same transaction, the result follows directly from Lemma \ref{lem:2phase} by the two-phase constraint, while we now proceed the proof considering $i \neq j$.

We now assume that $\lnot \left( \tau \vDash \alpha_i^u < \alpha_j^l  \lor \tau \vDash \alpha_j^u < \alpha_i^l \right)$ holds, which is equivalent to assuming that $\tau \vDash \alpha_j^l < \alpha_i^u$ and $\tau \vDash \alpha_i^l < \alpha_j^u$ hold, given that we know that all operations belong to $\tau$ and there must be an order among them. The statement, together with (\ref{lem:conflict1}), implies that the one of the following statements must hold:
\[
\begin{array}{c @{\hspace{30pt}} c}
	\tau \vDash \alpha_j^l < \alpha_i^l < \alpha_j^u < \alpha_i^u
	&
	\tau \vDash \alpha_j^l < \alpha_i^l < \alpha_i^u < \alpha_j^u
	\\[1em]
	\tau \vDash \alpha_i^l < \alpha_j^l < \alpha_j^u < \alpha_i^u
	&
	\tau \vDash \alpha_i^l < \alpha_j^l < \alpha_i^u < \alpha_j^u
\end{array}
\]
Without loss of generality, for the rest of the proof we will use the first scenario, since an equivalent argument with the appropriate substitutions can be made for the other three.

Therefore, the reduction chain which generated $\tau$ and that brings $\mathds{P}$ to $\pskip$ (by definition of $\mathsf{trace}$) must have the following shape, for some $h_1, \Phi_1, S_1, \mathds{P}_1, \Phi_1'$, $h_2, \Phi_2, S_2, \mathds{P}_2, \Phi_2'$, $h_3, \Phi_3, S_3, \mathds{P}_3, \Phi_3', S_3'$, $h_4, \Phi_4, S_4, \mathds{P}_4, \Phi_4', S_4'$.
\begin{gather*}
(h, \emptyset, S, \mathds{P}) \rightarrow^* (h_1, \Phi_1, S_1, \mathds{P}_1) \xrightarrow{\alpha_j^l} (h_1, \Phi_1', S_1, \mathds{P}_1) \rightarrow^* (h_2, \Phi_2, S_2, \mathds{P}_2) \xrightarrow{\alpha_i^l} (h_2, \Phi_2', S_2, \mathds{P}_2)
\\
\rightarrow^* (h_3, \Phi_3, S_3, \mathds{P}_3) \xrightarrow{\alpha_j^u} (h_3, \Phi_3', S_3', \mathds{P}_3) \rightarrow^* (h_4, \Phi_4, S_4, \mathds{P}_4) \xrightarrow{\alpha_i^u} (h_4, \Phi_4', S_4', \mathds{P}_4)
\end{gather*}
By our initial assumption, we know that the $\alpha$ and $\alpha'$ actions are conflicting, meaning that one of them (or both) is a write operation on $k$. Without loss of generality, we will consider the situation where $\alpha$ is a write action, noting that an equivalent proof can be obtained by having $\alpha'$ a write and making the appropriate substitutions. The transition labelled as $\alpha_j^l$ updates the lock manager $\Phi_1$ to be:
\begin{gather}
	\label{lem:conflict2}
	\Phi_1' = \Phi_1[k \mapsto (\{j\} \uplus I, \kappa)]
\end{gather}
for some (potentially empty) set of transaction identifiers $I$.

Now we can establish that there cannot be any $\alpha_j^{u'} = \actunlock{j}{k}$ such that:
\begin{gather}
	\label{lem:conflict3}
	\tau \vDash \alpha_j^l < \alpha_j^{u'} < \alpha_i^l
\end{gather}
Let's on the contrary assume that there exists such $\alpha_j^{u'}$. Then it must be the case that $\tau \vDash \alpha_j^{u'} < \alpha_j^{u}$ since $\tau \vDash \alpha_i^l < \alpha_j^u$ and $\tau \vDash \alpha_j^{u'} < \alpha_i^l$. This cannot be possible, given that from Lemma \ref{lem:noTwoUnlock} we know that a single transaction cannot unlock a particular item twice. By contradiction we obtain that no such $\alpha_j^{u'}$ exists.

From (\ref{lem:conflict2}) and (\ref{lem:conflict3}) we obtain that $(\{j\} \uplus I, \kappa) = \hat{\Phi}_2(k)$ meaning that the set of owners of $k$ is non-empty and moreover it definitely contains $j$. It follows that there is no possible way of the $\alpha_i^l$ transition happening since it must acquire an exclusive lock on $k$ and and the transition can only be produced by the \textsc{Lock} rule which, in this situation, requires $(\emptyset, \textsc{u}) = \hat{\Phi}_2(k)$ or $(\{ i \}, \textsc{s}) = \hat{\Phi}_2(k)$. By contradiction we get that $\tau \vDash \alpha_i^u < \alpha_j^l  \lor \tau \vDash \alpha_j^u < \alpha_i^l$ must hold.
\end{proof}