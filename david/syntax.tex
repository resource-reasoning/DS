\section{Syntax}

\subsection{Variables}

Variables have a name that comes from the set \textsf{Var} and is ranged over by \texttt{x}, \texttt{a}, \texttt{b}, \texttt{y}, \ldots

\subsection{Numerical Expressions}

All numerical expressions have an integer value, come frome the set \textsf{Expr} and are ranged over by $\mathds{E}, \mathds{E}_1, \mathds{E}_2, \ldots$ They can be built from the following grammar where $n \in \mathds{Z}$ and $\mathtt{x} \in \mathsf{Var}$.
\begin{align*}
\mathds{E} ::=&
\ n \\
|&\ \pvar{x} \\
|&\ \mathds{E}_1 + \mathds{E}_2 \\
|&\ \mathds{E}_1 - \mathds{E}_2 \\
|&\ \mathds{E}_1 \times \mathds{E}_2 \\
|&\ \mathds{E}_1 \div \mathds{E}_2 \\
\end{align*}

\subsection{Boolean Expressions}

Boolean expressions come from the set \textsf{BExpr} and are ranged over by $\mathds{B}, \mathds{B}_1, \ldots$

\begin{align*}
\mathds{B} ::=&
\ \true \\
|&\ \false \\
|&\ \mathds{B}_1 \land \mathds{B}_2 \\
|&\ \mathds{B}_1 \lor \mathds{B}_2 \\
|&\ \mathds{E}_1 > \mathds{E}_2 \\
|&\ \mathds{E}_1 < \mathds{E}_2 \\
|&\ \mathds{E}_1 \geq \mathds{E}_2 \\
|&\ \mathds{E}_1 \leq \mathds{E}_2 \\
\end{align*}

\subsection{Commands}

\textsf{Cmd} is the set of commands which is ranged over by $\mathds{C}, \mathds{C}_1, \mathds{C}_2, \ldots$ and is defined by the following grammar where $\pvar{x} \in \mathsf{Var}$.
\begin{align*}
\mathds{C} ::=&
\ \pskip \\
|&\ \passign{\pvar{x}}{\mathds{E}} \\
|&\ \pderef{\pvar{x}}{\mathds{E}} \\
|&\ \pmutate{\mathds{E}_1}{\mathds{E}_2} \\
|&\ \mathds{C}_1; \mathds{C}_2 \\
|&\ \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2} \\
|&\ \ploop{\mathds{B}}{\mathds{C}}
\end{align*}

\subsection{Transactions}

The set of transactions \textsf{Trans} is ranged over by $\mathds{T}, \mathds{T}_1, \mathds{T}_2, \ldots$ and defined using the following grammar. A transaction's body is defined as the command $\mathds{C}$ inside the grammar rules that follow.
\begin{align*}
\mathds{T} ::=&
\ \mathtt{begin}\ \mathds{C}\ \mathtt{end}
\end{align*}

\subsection{Locking}

Under the \textsc{2pl} protocol, all accesses to shared memory cells must be protected by a corresponding lock. The latter can be in one of three modes that come from the set $\mathsf{Lock} \triangleq \{ \textsc{u}, \textsc{s}, \textsc{x} \}$ and it is ranged over by $\kappa, \kappa_1, \kappa_2, \ldots$ We define a total order relation between the modes as $>\ \triangleq \{ (\textsc{x}, \textsc{u}), (\textsc{x}, \textsc{s}), (\textsc{s}, \textsc{u}) \}$. It is possible to informally name each of the set entries as \textit{unlocked}, \textit{shared} and \textit{exclusive} respectively which reflect that either no transaction is accessing a cell, one or more transactions are reading the cell's content or a single transaction is writing to the cell.

Transactions' code coming from clients does not explicitly include lock related code which is instead injected at runtime in order to comply to the protocol's rules. This gives rise to the set of locked transactions $\textsf{LTrans}$ and locked commands $\textsf{LCmd}$ ranged over by $\mathds{L}$ and $\mathds{K}$ respectively.
\begin{align*}
\mathds{L} ::=&
\ \mathtt{begin}\ \mathds{K}\ \mathtt{end} \\
\mathds{K} ::=&
\ \pskip \\
|&\ \passign{\pvar{x}}{\mathds{E}} \\
|&\ \pderef{\pvar{x}}{\mathds{E}} \\
|&\ \pmutate{\mathds{E}_1}{\mathds{E}_2} \\
|&\ \mathds{K}_1; \mathds{K}_2 \\
|&\ \pif{\mathds{B}}{\mathds{K}_1}{\mathds{K}_2} \\
|&\ \ploop{\mathds{B}}{\mathds{K}} \\
|&\ \pfuncallnr{lock}{\mathds{E}, \kappa} \\
|&\ \pfuncallnr{unlock}{\mathds{E}}
\end{align*}

\subsection{Programs}

Programs come from the set \textsf{Prog} which is ranged over by $\mathds{P}, \mathds{P}_1, \mathds{P}_2, \ldots$ and it is defined using the following grammar.
\begin{align*}
\mathds{P} ::=&
\ \mathds{L} \\
|&\ \mathds{L}\ ; \mathds{P}
\end{align*}

\subsection{Executions}

Executions are from the set \textsf{Exec} ranged over by $\mathds{X}, \mathds{X}_1, \mathds{X}_2, \ldots$
\begin{align*}
\mathds{X} ::=&
\ \mathds{P} \\
|&\ \mathds{X}_1\ ||\ \mathds{X}_2 \\
\end{align*}