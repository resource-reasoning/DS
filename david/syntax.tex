\section{Syntax}

\subsection{Variables}

Variables have a name that comes from the set \textsf{Var} and is ranged over by \texttt{x}, \texttt{a}, \texttt{b}, \texttt{y}, \ldots

\subsection{Numerical Expressions}

All numerical expressions have an integer value, come frome the set \textsf{Expr} and are ranged over by $\mathds{E}, \mathds{E}_1, \mathds{E}_2, \ldots$ They can be built from the following grammar where $n \in \mathds{Z}$ and $\mathtt{x} \in \mathsf{Var}$.
\begin{align*}
\mathds{E} ::=&
\ n \\
|&\ \pvar{x} \\
|&\ \mathds{E}_1 + \mathds{E}_2 \\
|&\ \mathds{E}_1 - \mathds{E}_2 \\
|&\ \mathds{E}_1 \times \mathds{E}_2 \\
|&\ \mathds{E}_1 \div \mathds{E}_2 \\
\end{align*}

\subsection{Boolean Expressions}

We define the set $\mathsf{Bool} \triangleq \{ \bot, \top \}$ and boolean expressions to be derived from the set \textsf{BExpr} and are ranged over by $\mathds{B}, \mathds{B}_1, \mathds{B}_2, \ldots$

\begin{align*}
\mathds{B} ::=&
\ \true \\
|&\ \false \\
|&\ \mathds{B}_1 \land \mathds{B}_2 \\
|&\ \mathds{B}_1 \lor \mathds{B}_2 \\
|&\ \mathds{E}_1 > \mathds{E}_2 \\
|&\ \mathds{E}_1 < \mathds{E}_2 \\
|&\ \mathds{E}_1 \geq \mathds{E}_2 \\
|&\ \mathds{E}_1 \leq \mathds{E}_2 \\
\end{align*}

\subsection{Commands}

\textsf{Cmd} is the set of commands which is ranged over by $\mathds{C}, \mathds{C}_1, \mathds{C}_2, \ldots$ and is defined by the following grammar where $\pvar{x} \in \mathsf{Var}$.
\begin{align*}
\mathds{C} ::=&
\ \pskip \\
|&\ \passign{\pvar{x}}{\mathds{E}} \\
|&\ \pderef{\pvar{x}}{\mathds{E}} \\
|&\ \palloc{\pvar{x}}{\mathds{E}} \\
|&\ \pmutate{\mathds{E}_1}{\mathds{E}_2} \\
|&\ \mathds{C}_1; \mathds{C}_2 \\
|&\ \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2} \\
|&\ \ploop{\mathds{B}}{\mathds{C}}
\end{align*}

\subsection{Transactions}

The set of transactions \textsf{Trans} is ranged over by $\mathds{T}$ and defined using the following grammar. A transaction's body is defined as the command $\mathds{C}$ inside the grammar rules that follow.
\begin{align*}
\mathds{T} ::=&
\ \mathtt{begin}\ \mathds{C}\ \mathtt{end}
\end{align*}

\subsection{Locking}

Under the \textsc{2pl} protocol, all accesses to shared memory cells must be protected by a corresponding lock. The latter can be in one of three modes that come from the set $\mathsf{Lock} \triangleq \{ \textsc{u}, \textsc{s}, \textsc{x} \}$ and it is ranged over by $\kappa, \kappa_1, \kappa_2, \ldots$ We define a total order relation between the modes as $>\ \triangleq \{ (\textsc{x}, \textsc{u}), (\textsc{x}, \textsc{s}), (\textsc{s}, \textsc{u}) \}$, while $\geq$ is equivalent to $>$ with the addition of all reflexive pairs. It is possible to informally name each of the set entries as \textit{unlocked}, \textit{shared} and \textit{exclusive} respectively which reflect that either no transaction is accessing a cell, one or more transactions are reading the cell's content or a single transaction is writing to the cell.

Transactions' code coming from clients does not explicitly include lock related code which is instead injected at runtime in order to comply to the protocol's rules. In fact, at any point in the execution of code, a transaction has the nondeterministic option of acquiring a lock for a particular cell in the storage or of proceeding with the current command.

\subsection{Programs}

Programs come from the set \textsf{Prog} which is ranged over by $\mathds{P}$ and it is defined using the following grammar that allows the sequential composition ($;$) of transactions.
\begin{align*}
\mathds{P} ::=&
\ \mathds{T} \\
|&\ \mathds{T}; \mathds{P}
\end{align*}

\subsection{Executions}

Program executions are members of the set \textsf{Exec} which is ranged over by $\mathds{X}$. Executions allow the parallel composition ($\|$) of programs.
\begin{align*}
\mathds{X} ::=&
\ \mathds{P} \\
|&\ \mathds{X}\ \|\ \mathds{P} \\
\end{align*}