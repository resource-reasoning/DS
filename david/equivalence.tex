\iffalse
\section{Trace equivalence}

\begin{gather*}
	\pred{clean}{\tau, \tau'} \iff \\
	(\forall i, k, x, n, n', l \ldotp x \in \{op(i, k), (\actalloc{i}{n}{l}, n')\} \implies (x \in \tau \iff x \in \tau')) \\
	\land \\
	(\forall i, k, x, n, \kappa \ldotp x \in \{ (\actlock{i}{k}{\kappa}, n), (\actunlock{i}{k}, n) \} \land x \in \tau \land op(i, k) \not\in \tau \implies x \not\in \tau')
\end{gather*}

\[
	\alpha(\iota, k) \triangleq \alpha \text{ s. t. }
	\alpha \in 
		\{
			\actread{\iota}{k}{v},
			\actwrite{\iota}{k}{v},
			\actlock{\iota}{k}{\kappa},
			\actunlock{\iota}{k}\
			|\ v \in \mathsf{Val}, \kappa \in \mathsf{Lock}
		\}
\]

\lem \label{lem:rr} The order of two consecutive reads can be swapped as long as the transactions performing them are distinct.
\begin{gather*}
	\forall h, h', \Phi, \Phi', S, S', \mathds{P}, \mathds{P}', i, j, k, k', v, v' \ldotp \\
	 i \neq j \implies
	 \\
	(\exists h_0, \Phi_0, S_0, \mathds{P}_0 \ldotp 
	(h, \Phi, S, \mathds{P}) \xrightarrow{\actread{i}{k}{v}} (h_0, \Phi_0, S_0, \mathds{P}_0)  \xrightarrow{\actread{j}{k'}{v'}} (h', \Phi', S', \mathds{P}') \\
	\iff \\
	\exists h_1, \Phi_1, S_1, \mathds{P}_1 \ldotp
	(h, \Phi, S, \mathds{P}) \xrightarrow{\actread{j}{k'}{v'}} (h_1, \Phi_1, S_1, \mathds{P}_1) \xrightarrow{\actread{i}{k}{v}} (h', \Phi', S', \mathds{P}'))
\end{gather*}
\begin{proof}
Let's pick arbitrary $h, h' \in \mathsf{Storage}, \Phi, \Phi' \in \mathsf{LMan}, S, S' \in \mathsf{TState}, \mathds{P}, \mathds{P}' \in \mathsf{Prog}, i, j \in \mathsf{Tid}, k, k' \in \mathsf{Key}, v, v' \in \mathsf{Val}$. Now we assume that the two transaction identifiers are distinct, i.e. $i \neq j$. (If case) Let's assume that:
\begin{gather} \label{lem:rr1}
	\exists h_0, \Phi_0, S_0, \mathds{P}_0 \ldotp (h, \Phi, S, \mathds{P}) \xrightarrow{\actread{i}{k}{v}} (h_0, \Phi_0, S_0, \mathds{P}_0)  \xrightarrow{\actread{j}{k'}{v'}} (h', \Phi', S', \mathds{P}')
\end{gather}
It follows that the two action labels were produced by two transactions running in parallel executing a single step each. Given the effect of the $\mathsf{read}$ action, we know that $h = h_0 = h_1, \Phi = \Phi_0 = \Phi'$. We can immediately find a $h_1 = h = h'$ and a $\Phi_1 = \Phi = \Phi'$. $\mathds{P}_1$ will be the program $\mathds{P}$ that has executed a step in the program where transaction $j$ resides. We know that this will always succeed since the $\mathsf{read}$ action requirements are all satisfied by (\ref{lem:rr1}). From this, $\mathds{P}_1$ can always reduce to $\mathds{P}'$ by chosing to run the program in which transaction $i$ is which is possible thanks to the assumption in (\ref{lem:rr1}). Given that by assumption $i \neq j$, it must be the case that $S(i)$ and $S(j)$ are disjoint therefore the relative ordering on the updates to the local variables does not matter. (Only if) This case can be built and proven in the same way as the previous one, with the appropriate substitutions.
\end{proof}

\lem The order of two consecutive read, write, lock or unlock operations can be swapped as long as the transactions performing them are distinct and the keys they refer to are different.
\begin{gather*}
	\forall h, h', \Phi, \Phi', S, S', \mathds{P}, \mathds{P}', i, j, k, k', x, y \ldotp \\
	x = \alpha(i, k) \land y = \alpha(j, k') \land i \neq j \land k \neq k' \implies \\
	(\exists h_0, \Phi_0, S_0, \mathds{P}_0 \ldotp
	(h, \Phi, S, \mathds{P}) \xrightarrow{x} (h_0, \Phi_0, S_0, \mathds{P}_0)  \xrightarrow{y} (h', \Phi', S', \mathds{P}') \\
	\iff \\
	\exists h_1, \Phi_1, S_1, \mathds{P}_1 \ldotp
	(h, \Phi, S, \mathds{P}) \xrightarrow{y} (h_1, \Phi_1, S_1, \mathds{P}_1) \xrightarrow{x} (h', \Phi', S', \mathds{P}'))
\end{gather*}
\begin{proof}
Let's pick arbitrary $h, h' \in \mathsf{Storage}, \Phi, \Phi' \in \mathsf{LMan}, S, S' \in \mathsf{TState}, \mathds{P}, \mathds{P}' \in \mathsf{Prog}, i, j \in \mathsf{Tid}, k, k' \in \mathsf{Key}, x, y \in \mathsf{Act}$. Now we assume that the two transaction identifiers are distinct, i.e. $i \neq j$, as well as the storage keys $k \neq k'$. We also assume the two operations $x = \alpha(i, k)$ and $y = \alpha(j, k)$ are read, write, lock or unlock operations on $k$ and $k'$ performed by transactions $i$ and $j$ respectively. (If case) Let's assume that:
\begin{gather} \label{lem:xy1}
	\exists h_0, \Phi_0, S_0, \mathds{P}_0 \ldotp
	(h, \Phi, S, \mathds{P}) \xrightarrow{x} (h_0, \Phi_0, S_0, \mathds{P}_0)  \xrightarrow{y} (h', \Phi', S', \mathds{P}')
\end{gather}
It follows that the two action labels were produced by two transactions running in parallel executing a single step each. We will proceed with a case-by-case analysis on $x$ and $y$ in order to find suitable $h_1$ and $\Phi_1$.
\begin{itemize}
	\item If $x = \actread{i}{k}{v}$ and $y = \actread{j}{k'}{v'}$ for $v, v' \in \mathsf{Val}$ then the result follows directly from Lemma \ref{lem:rr}.
	\item If $x = \actwrite{i}{k}{v}$ and $y = \actwrite{j}{k'}{v'}$ for $v, v' \in \mathsf{Val}$ then $h' = h[k \mapsto v][k \mapsto v']$ and $\Phi' = \Phi$ meaning we can find $h_1 = h[k \mapsto v']$ and $\Phi_1 = \Phi$.
	\item If $x = \actread{i}{k}{v}$ and $y = \actwrite{j}{k'}{v'}$ for $v, v' \in \mathsf{Val}$ then $h' = h[k' \mapsto v']$ and $\Phi' = \Phi$ meaning we can find $h_1 = h[k' \mapsto v']$ and $\Phi_1 = \Phi$.
	\item If $x = \actlock{i}{k}{\kappa}$ and $y = \actunlock{j}{k'}$ for $\kappa \in \mathsf{Lock}$ then $h' = h$ and $\Phi' = \Phi[k \mapsto (I, \kappa)][k' \mapsto (I' \setminus \{j\}, \kappa')]$ for $I, I' \in \mathcal{P}(\mathsf{Tid})$ and $\kappa' \in \mathsf{Lock}$, meaning we can find $h_1 = h$ and $\Phi_1 = \Phi[k' \mapsto (I' \setminus \{j\}, \kappa')]$.
	\item If $x = \actlock{i}{k}{\kappa}$ and $y = \actread{j}{k}{v}$ for $\kappa \in \mathsf{Lock}$ and $v \in \mathsf{Val}$ then $h' = h$ and $\Phi' = \Phi[k \mapsto (I, \kappa)]$ for $I \in \mathcal{P}(\mathsf{Tid})$, meaning we can find $h_1 = h$ and $\Phi_1 = \Phi$.
	\item If $x = \actlock{i}{k}{\kappa}$ and $y = \actwrite{j}{k}{v}$ for $\kappa \in \mathsf{Lock}$ and $v \in \mathsf{Val}$ then $h' = h[k \mapsto v]$ and $\Phi' = \Phi[k \mapsto (I, \kappa)]$ for $I \in \mathcal{P}(\mathsf{Tid})$, meaning we can find $h_1 = h[k \mapsto v]$ and $\Phi_1 = \Phi$.
	\item If $x = \actunlock{i}{k}$ and $y = \actread{j}{k}{v}$ for $v \in \mathsf{Val}$ then $h' = h$ and $\Phi' = \Phi[k \mapsto (I \setminus \{j\}, \kappa)]$ for $\kappa \in \{\textsc{u}, \textsc{s}\}$ and $I \in \mathcal{P}(\mathsf{Tid})$, meaning we can find $h_1 = h$ and $\Phi_1 = \Phi$.
	\item If $x = \actunlock{i}{k}$ and $y = \actwrite{j}{k}{v}$ for $v \in \mathsf{Val}$ then $h' = h[k \mapsto v]$ and $\Phi' = \Phi[k \mapsto (I \setminus \{j\}, \kappa)]$ for $\kappa \in \{\textsc{u}, \textsc{s}\}$ and $I \in \mathcal{P}(\mathsf{Tid})$, meaning we can find $h_1 = h[k \mapsto v]$ and $\Phi_1 = \Phi$.
\end{itemize}
The inverted cases that are not included in the list can be trivially found as a consequence of the presented ones, with the appropriate substitions.

$\mathds{P}_1$ will be the program $\mathds{P}$ that has executed a step in the program where transaction $j$ resides. We know that this will always succeed since the actions act on disjoint parts of the global heap and lock manager, meaning that their requirements are all satisfied by (\ref{lem:xy1}). From this, $\mathds{P}_1$ can always reduce to $\mathds{P}'$ by chosing to run the program in which transaction $i$ is which is possible thanks to the assumption in (\ref{lem:xy1}). Given that by assumption $i \neq j$, it must be the case that $S(i)$ and $S(j)$ are disjoint therefore the relative ordering on the eventual updates to the local variables does not matter. (Only if) This case can be built and proven in the same way as the previous one, with the appropriate substitutions.
\end{proof}

\lem The order of two consecutive allocations can be swapped as long as the transactions performing them are distinct.
\begin{gather*}
	\forall h, h', \Phi, \Phi', S, S', \mathds{P}, \mathds{P}', i, j, n, n', l, l' \ldotp \\
	i \neq j \implies \\
	(\exists h_0, \Phi_0, S_0, \mathds{P}_0 \ldotp 
	(h, \Phi, S, \mathds{P}) \xrightarrow{\actalloc{i}{n}{l}} (h_0, \Phi_0, S_0, \mathds{P}_0)  \xrightarrow{\actalloc{j}{n'}{l'}} (h', \Phi', S', \mathds{P}') \\
	\iff \\
	\exists h_1, \Phi_1, S_1, \mathds{P}_1 \ldotp
	(h, \Phi, S, \mathds{P}) \xrightarrow{\actalloc{j}{n'}{l'}} (h_1, \Phi_1, S_1, \mathds{P}_1) \xrightarrow{\actalloc{i}{n}{l}} (h', \Phi', S', \mathds{P}'))
\end{gather*}
\begin{proof}
Let's pick arbitrary $h, h' \in \mathsf{Storage}, \Phi, \Phi' \in \mathsf{LMan}, S, S' \in \mathsf{TState}, \mathds{P}, \mathds{P}' \in \mathsf{Prog}, i, j \in \mathsf{Tid}, l, l' \in \mathsf{Key}, n, n' \in \mathsf{Val}$. Now we assume that the two transaction identifiers are distinct, i.e. $i \neq j$. (If case) Let's assume that:
\begin{gather} \label{lem:aa1}
	\exists h_0, \Phi_0, S_0, \mathds{P}_0 \ldotp 
	(h, \Phi, S, \mathds{P}) \xrightarrow{\actalloc{i}{n}{l}} (h_0, \Phi_0, S_0, \mathds{P}_0)  \xrightarrow{\actalloc{j}{n'}{l'}} (h', \Phi', S', \mathds{P}')
\end{gather}
It follows that the two action labels were produced by two transactions running in parallel executing a single step each. Given the effect of the $\mathsf{alloc}$ action, we know that $\Phi = \Phi_0 = \Phi'$. We can immediately find a $\Phi_1 = \Phi = \Phi'$. We also know that $\{l, \ldots, l + n - 1\} \subseteq \pred{dom}{h_0}$ and in order for $\actalloc{j}{n'}{l'}$ to suceed, which it does by (\ref{lem:aa1}), $\{l', \ldots, l' + n' - 1\} \cap \pred{dom}{h_0} \equiv \emptyset$ which means that the two ranges of memory locations are disjoint. As a consequence the order of allocation does not matter in terms of reaching the final heap $h'$; our $h_1$ will therefore be $h[l' \mapsto 0]\ldots[l' + n' - 1 \mapsto 0]$. $\mathds{P}_1$ will be the program $\mathds{P}$ that has executed a step in the program where transaction $j$ resides. We know that this will always succeed since the $\mathsf{alloc}$ action requirements are all satisfied by (\ref{lem:aa1}). From this, $\mathds{P}_1$ can always reduce to $\mathds{P}'$ by chosing to run the program in which transaction $i$ is which is possible thanks to the assumption in (\ref{lem:aa1}). Given that by assumption $i \neq j$, it must be the case that $S(i)$ and $S(j)$ are disjoint therefore the relative ordering on the updates to the local variables does not matter. (Only if) This case can be built and proven in the same way as the previous one, with the appropriate substitutions.
\end{proof}

\lem The order of an allocation followed by a read, write, lock or unlock can be swapped as long as the transactions performing them are distinct and the keys accessed are not part of the ones created by the allocation.
\begin{gather*}
	\forall h, h', \Phi, \Phi', S, S', \mathds{P}, \mathds{P}', i, j, n, l, k, x \ldotp \\
	x = \alpha(j, k) \land i \neq j \land (k < l \lor k \geq l + n) \implies \\
	(\exists h_0, \Phi_0, S_0, \mathds{P}_0 \ldotp 
	(h, \Phi, S, \mathds{P}) \xrightarrow{\actalloc{i}{n}{l}} (h_0, \Phi_0, S_0, \mathds{P}_0)  \xrightarrow{x} (h', \Phi', S', \mathds{P}') \\
	\iff \\
	\exists h_1, \Phi_1, S_1, \mathds{P}_1 \ldotp
	(h, \Phi, S, \mathds{P}) \xrightarrow{x} (h_1, \Phi_1, S_1, \mathds{P}_1) \xrightarrow{\actalloc{i}{n}{l}} (h', \Phi', S', \mathds{P}'))
\end{gather*}
\begin{proof}
Let's pick arbitrary $h, h' \in \mathsf{Storage}, \Phi, \Phi' \in \mathsf{LMan}, S, S' \in \mathsf{TState}, \mathds{P}, \mathds{P}' \in \mathsf{Prog}, i, j \in \mathsf{Tid}, l, k \in \mathsf{Key}, n \in \mathsf{Val}, x, y \in \mathsf{Act}$. Now we assume that the two transaction identifiers are distinct, i.e. $i \neq j$, that $x = \alpha(j, k)$ is a read, write, lock or unlock action performed by transaction $j$ on item with key $k$ and that $k < l \lor k \geq l + n$ meaning that $k$ is not part of the keys created by the $\mathsf{alloc}$ operation. (If case) Let's assume that:
\begin{gather} \label{lem:ax1}
	\exists h_0, \Phi_0, S_0, \mathds{P}_0 \ldotp 
	(h, \Phi, S, \mathds{P}) \xrightarrow{\actalloc{i}{n}{l}} (h_0, \Phi_0, S_0, \mathds{P}_0)  \xrightarrow{x} (h', \Phi', S', \mathds{P}')
\end{gather}
It follows that the two action labels were produced by two transactions running in parallel executing a single step each. Given the effect of the $\mathsf{alloc}$ action, we know that $\Phi = \Phi_0 = \Phi'$ and $h_0 = h[l \mapsto 0]\ldots[l + n - 1 \mapsto 0]$. In order to find $h_1$ and $\Phi_1$, we now proceed with a case-by-case analysis on the kind of action $x$.
\begin{itemize}
	\item If $x = \actread{j}{k}{v}$ for $v \in \mathsf{Val}$ then $h' = h_0$ and $\Phi' = \Phi$ meaning we can find $h_1 = h$ and $\Phi_1 = \Phi$.
	\item If $x = \actwrite{j}{k}{v}$ for $v \in \mathsf{Val}$ then $h' = h_0[k \mapsto v]$ and $\Phi' = \Phi$ meaning we can find $h_1 = h[k \mapsto v]$ and $\Phi_1 = \Phi$.
	\item If $x = \actlock{j}{k}{\kappa}$ for some $\kappa \in \mathsf{Lock}$ then $h' = h_0$ and $\Phi' = \Phi[k \mapsto (I, \kappa)]$ meaning we can find $h_1 = h$ and $\Phi_1 = \Phi[k \mapsto (I, \kappa)]$ for $I \in \mathcal{P}(\mathsf{Tid})$.
	\item If $x = \actunlock{j}{k}$ then $h' = h_0$ and $\Phi' = \Phi[k \mapsto (I \setminus \{j\}, \kappa)]$ for $I \in \mathcal{P}(\mathsf{Tid})$ and $\kappa \in \{\textsc{u}, \textsc{s}\}$ meaning we can find $h_1 = h$ and $\Phi_1 = \Phi[k \mapsto (I \setminus \{j\}, \kappa)]$.
\end{itemize}
$\mathds{P}_1$ will be the program $\mathds{P}$ that has executed a step in the program where transaction $j$ resides. We know that this will always succeed since the $\mathsf{alloc}$ action requirements are all satisfied by (\ref{lem:ax1}). From this, $\mathds{P}_1$ can always reduce to $\mathds{P}'$ by chosing to run the program in which transaction $i$ is which is possible thanks to the assumption in (\ref{lem:ax1}). Given that by assumption $i \neq j$, it must be the case that $S(i)$ and $S(j)$ are disjoint therefore the relative ordering on the updates to the local variables does not matter.
\end{proof}
\fi

\subsection{Strict total order}

\defn (Reflexive image). The reflexive image of a set $X$, written $\pred{Id}{X}$ is defined as:
\[
	\pred{Id}{X} = \{ (x, x)\ |\ x \in X \}
\]

\defn (Reflexive closure). The reflexive closure of a given relation $R$ on a set $X$, written $R^\mathsf{id}$, is defined as:
\[
	R^\mathsf{id} = R \cup \pred{Id}{X}
\]

\defn
\begin{align*}
	\text{let } (N, E) = \pred{SG}{\tau} \text{ in }
	\sqsubset_0 &= E^* \\
	\sqsubset_{n + 1} &=\ \sqsubset_n \cup \left( \sqsubset_n^\mathsf{id} ; \{ (i, j) \} ; \sqsubset_n^\mathsf{id} \right) \\
	&\text{where } i, j \in N \text{ and } i < j \\
	&\text{and } i \not\sqsubset_n j \text{ and } j \not\sqsubset_n i
\end{align*}

\thm The $\sqsubset$ relation is a strict total order on $N$ for $(N, E) = \pred{SG}{\tau}, \tau = \pred{trace}{h, \emptyset, \emptyset, \mathds{P}}, \mathds{P} \in \mathsf{Prog}, h \in \mathsf{Storage}$.

\begin{proof}
In order to show the theorem, we are required to prove that for all $a, b, c \in N$:
\begin{itemize}
	\item (Irreflexivity). $a \not\sqsubset a$
	\item (Asymmetry). If $a \sqsubset b$ then $b \not\sqsubset a$
	\item (Transitivity). If $a \sqsubset b$ and $b \sqsubset c$ then $a \sqsubset c$
	\item (Totality). $a \sqsubset b$ or $b \sqsubset a$ or $a = b$
\end{itemize}

Let's pick an arbitrary program $\mathds{P} \in \mathsf{Prog}$, initial storage $h \in \mathsf{Storage}$ and get a trace out of it $\tau = \pred{trace}{h, \emptyset, \emptyset, \mathds{P}}$. We now consider the incrementally built $\sqsubset$ relation on $N$, where $(N, E) = \pred{SG}{\tau}$. \\

(Irreflexivity). The proof follows by induction on the number of $\sqsubset$ relation construction steps, $n$. Let's pick an arbitrary transaction identifier $a \in N$.

{\parindent0pt
\textit{Base case}: $n = 0$

\textit{To show}: $a \not\sqsubset_0 a$

By definition we know that $\sqsubset_0 = E^*$, i.e. the transitive closure on the edges of the serialization graph $\pred{SG}{\tau}$. We directly obtain that $a \not\sqsubset_0 a$ from Theorem \ref{thm:sgAcyclic}. \\

\textit{Inductive case}: $n > 0$

\textit{Inductive hypothesis}: $a \not\sqsubset_n a$

\textit{To show}: $a \not\sqsubset_{n+1} a$

Let's assume that $a \sqsubset_{n+1} a$ and by definition we know it means that, for some $i, j \in N$ such that $i < j, i \not\sqsubset_n j, j \not\sqsubset_n i$ we have:
\[
	(a, a) \in \sqsubset_n \cup \left( \sqsubset_n^\mathsf{id} ; \{ (i, j) \} ; \sqsubset_n ^\mathsf{id} \right)
\]
and by I.H. we can rewrite it as $(a, a) \in \left( \sqsubset_n^\mathsf{id} ; \{ (i, j) \} ; \sqsubset_n ^\mathsf{id} \right)$ given we assumed that $\sqsubset_n$ is irreflexive. It follows that it must be the case that $(a, i)$ and $(j, a)$ are in $\sqsubset_n^\mathsf{id}$ and moreover they must be in $\sqsubset_n$ given that $i < j$ and therefore $i \neq j$. By transitivity of $\sqsubset_n$, there must be a $(j, i) \in \sqsubset_n$. By contradiction we state that $a \not\sqsubset_{n+1} a$. \\
}

(Asymmetry). The proof follows by induction on the number of $\sqsubset$ relation construction steps, $n$. Let's pick arbitrary transaction identifiers $a, b \in N$.

{\parindent0pt
\textit{Base case}: $n = 0$

\textit{To show}: $a \sqsubset_0 b \implies b \not\sqsubset_0 a$

By definition we know that $\sqsubset_0 = E^*$, i.e. the transitive closure on the edges of the serialization graph $\pred{SG}{\tau}$. Let's assume that $a \sqsubset_0 b$ meaning that $a \rightarrow^* b \in E$. We directly obtain that $b \not\sqsubset_0 a$ from Theorem \ref{thm:sgAcyclic}. \\

\textit{Inductive case}: $n > 0$

\textit{Inductive hypothesis}: $a \sqsubset_n b \implies b \not\sqsubset_n a$

\textit{To show}: $a \sqsubset_{n + 1} b \implies b \not\sqsubset_{n + 1} a$

Let's assume that $a \sqsubset_{n + 1} b$ and by definition we know it means that, for some $i, j \in N$ such that $i < j, i \not\sqsubset_n j, j \not\sqsubset_n i$ we have:
\[
	(a, b) \in \sqsubset_n \cup \left( \sqsubset_n^\mathsf{id} ; \{ (i, j) \} ; \sqsubset_n ^\mathsf{id} \right)
\]
\begin{itemize}
	\item If $a \sqsubset_n b$ we know by I.H. that $b \not\sqsubset_n a$. Let's instead assume that $(b, a) \in \left( \sqsubset_n^\mathsf{id} ; \{ (i, j) \} ; \sqsubset_n ^\mathsf{id} \right)$ from which it follows that there is a $(b, i) \in \sqsubset_n^\mathsf{id}$ and $(j, a) \in \sqsubset_n^\mathsf{id}$. By transitivity of $\sqsubset_n$ we obtain that $(j, i) \in \sqsubset_n^\mathsf{id}$ and moreover that $j \sqsubset_n i$ since $i \neq j$ as $i < j$. By contradiction we obtain that $(b, a) \not\in \left( \sqsubset_n^\mathsf{id} ; \{ (i, j) \} ; \sqsubset_n ^\mathsf{id} \right)$. We conclude that $b \not\sqsubset_{n + 1} a$.
	\item If $(a, b) \in \left( \sqsubset_n^\mathsf{id} ; \{ (i, j) \} ; \sqsubset_n ^\mathsf{id} \right)$ which means there is a $(a, i) \in \sqsubset_n^\mathsf{id}$ and $(j, b) \in \sqsubset_n^\mathsf{id}$. Let's now assume that $(b, a) \in \left( \sqsubset_n^\mathsf{id} ; \{ (i, j) \} ; \sqsubset_n ^\mathsf{id} \right)$ meaning that there is a $(b, i) \in \sqsubset_n^\mathsf{id}$ and $(j, a) \in \sqsubset_n^\mathsf{id}$. By transitivity of $\sqsubset_n$ we obtain that $(j, i) \in \sqsubset_n^\mathsf{id}$ and moreover that $j \sqsubset_n i$ since $i \neq j$ as $i < j$. By contradiction we obtain that $(b, a) \not\in \left( \sqsubset_n^\mathsf{id} ; \{ (i, j) \} ; \sqsubset_n ^\mathsf{id} \right)$. We now assume that $b \sqsubset_n a$ which implies that $(b, a) \in \sqsubset_n^\mathsf{id}$. By transitivity of $\sqsubset_n$ we obtain that $(j, i) \in \sqsubset_n^\mathsf{id}$ and moreover that $j \sqsubset_n i$ since $i \neq j$ as $i < j$. By contradiction we obtain that $(b, a) \not\in \sqsubset_n$. We conclude that $b \not\sqsubset_{n + 1} a$.
\end{itemize}
}

(Transitivity). We are required to show that $\forall m \geq 1 \ldotp \sqsubset^m\ \subseteq\ \sqsubset$ The proof follows by induction on the number of self-composition steps, $m$.

{\parindent0pt
\textit{Base case}: $m = 1$

\textit{To show}: $\sqsubset^1\ \subseteq\ \sqsubset$ \\

The result follows directly by definition $\sqsubset^1\ =\ \sqsubset\ \subseteq\ \sqsubset$. \\

\textit{Inductive case}: $m > 1$

\textit{Inductive hypothesis}: $\sqsubset^m\ \subseteq\ \sqsubset$

\textit{To show}: $\sqsubset^{m + 1}\ \subseteq\ \sqsubset$
\begin{align*}
	\sqsubset^{m + 1}
	&=\ \sqsubset^m ; \sqsubset \text{ by associativity} \\
	&\subseteq\ \sqsubset ; \sqsubset \text{ by I.H.} \\
	&=\ \sqsubset^2 \text{by definition} \\
	&\subseteq\ \sqsubset \text{ by Lemma \ref{lem:total2}}
\end{align*}
}

(Totality). Let's pick arbitrary transaction identifiers $a, b \in N$ (\textsc{i}) for a finite $N$ and build the $\sqsubset$ relation on it until convergence, i.e. in a finite number of steps. If $(a, b) \in E^*$ or $(b, a) \in E*$ then we know that either $a \sqsubset b$ or $b \sqsubset a$ holds. On the other hand if there is no edge connecting $a$ to $b$ or $b$ to $a$ in $E^*$ (\textsc{ii}) then:
\begin{itemize}
	\item If $a = b$ then by irreflexivity of $\sqsubset$ we are done as totality is met.
	\item Without loss of generality, we say that $a < b$ (\textsc{iii}). Given that the construction of $\sqsubset$ terminated in some $m > 0$ steps (being $N$ a finite set), by (\textsc{i}), (\textsc{ii}) and (\textsc{iii}) we know that there must exist a construction step $n$ such that $0 < n < m$ where the tuple $(a, b)$ was inserted in the relation given that $\sqsubset_{n-1} \cup \left( \sqsubset_{n-1}^\mathsf{id} ; \{(a,b)\} ; \sqsubset_{n-1}^\mathsf{id} \right) \implies a \sqsubset_n b \implies a \sqsubset b$. 
\end{itemize}
\end{proof}

\newpage

\lem \label{lem:total2} Given a serialization graph $(N, E) = \pred{SG}{\tau}$ for $\tau = \pred{trace}{h, \emptyset, \emptyset, \mathds{P}}, \mathds{P} \in \mathsf{Prog}, h \in \mathsf{Storage}$, and the $\sqsubset$ relation on the set $N$ we say that $\sqsubset^2\ \subseteq\ \sqsubset$.

{\parindent0pt
\begin{proof}
We proceed by induction on the number of $\sqsubset$ construction steps, $n$. \\

\textit{Base case}: $n = 0$

\textit{To show}: $\sqsubset_0^2\ \subseteq\ \sqsubset_0$

By definition we know that $\sqsubset_0 = E^*$, i.e. the transitive closure on the edges of the serialization graph $\pred{SG}{\tau}$. It follows that by definition of transitive closure, $\sqsubset_0^2\ = E^* ; E^* = E^*$ meaning that $\sqsubset_0^2\ \subseteq\ \sqsubset_0$. \\

\textit{Inductive case}: $n > 0$

\textit{Inductive hypothesis}: $\sqsubset_n^2\ \subseteq\ \sqsubset_n$

\textit{To show}: $\sqsubset_{n + 1}^2\ \subseteq\ \sqsubset_{n + 1}$

We can rewrite the formula to be proven as the following, for some $i, j \in N$ such that $i < j, i \not\sqsubset_n j, j \not\sqsubset_n i$:
\begin{align}
	\left( \sqsubset_n \cup \underbrace{\left( \sqsubset_n^\mathsf{id} ; \{ (i, j) \} ; \sqsubset_n^\mathsf{id} \right)}_{R} \right) ; \left( \sqsubset_n \cup \left( \sqsubset_n^\mathsf{id} ; \{ (i, j) \} ; \sqsubset_n^\mathsf{id} \right) \right) &\subseteq \sqsubset_{n + 1} \\
	\label{thm:total1} \sqsubset_n ; \sqsubset_n \cup \sqsubset_n ; R \cup R ; \sqsubset_n \cup R ; R &\subseteq\ \sqsubset_{n + 1} \text{ by distributivity}
\end{align}
It now suffices to show that each unioned set in the L.H.S. of (\ref{thm:total1}) is a subset of $\sqsubset_{n + 1}$ itself.
\begin{itemize}
	\item \textit{To show}: $\sqsubset_n ; \sqsubset_n\ \subseteq\ \sqsubset_{n + 1}$
		\begin{align}
			\sqsubset_n ; \sqsubset_n\ &=\ \sqsubset_n^2 \\
			\text{by I.H.}&\subseteq\ \sqsubset_n\ \subseteq\ \sqsubset_{n + 1}
		\end{align}
	\item \textit{To show}: $\sqsubset_n ; \left( \sqsubset_n^\mathsf{id} ; \{ (i, j) \} ; \sqsubset_n^\mathsf{id} \right) \subseteq\ \sqsubset_{n + 1}$
		\begin{align}
			S  &=\ \sqsubset_n ; \sqsubset_n^\mathsf{id} \\
				&=\ \sqsubset_n ; \left( \sqsubset_n \cup\ \pred{Id}{N} \right) \text{by definition} \\
				&=\ \sqsubset_n ; \sqsubset_n \cup \sqsubset_n ; \pred{Id}{N} \\
				&=\ \sqsubset_n^2 \cup \sqsubset_n \\
				&\subseteq\ \sqsubset_n \text{by I.H.} \\
				\label{thm:total2} &\subseteq\ \sqsubset_n^\mathsf{id} \text{by definition} \\
			\sqsubset_n ; \left( \sqsubset_n^\mathsf{id} ; \{ (i, j) \} ; \sqsubset_n^\mathsf{id} \right) &= \left( \sqsubset_n ; \sqsubset_n^\mathsf{id} ; \{ (i, j) \} \right) ; \sqsubset_n^\mathsf{id} \text{ by associativity} \\
			&= \left( S ; \{ (i, j) \} \right) ; \sqsubset_n^\mathsf{id} \text{ by associativity} \\
			&\subseteq\ \sqsubset_n^\mathsf{id} ; \{ (i, j) \} ; \sqsubset_n^\mathsf{id} \text{by (\ref{thm:total2})} \\
			&\subseteq\ \sqsubset_{n + 1}
		\end{align}
	\item \textit{To show}: $\left( \sqsubset_n^\mathsf{id} ; \{ (i, j) \} ; \sqsubset_n^\mathsf{id} \right) ; \sqsubset_n \subseteq\ \sqsubset_{n + 1}$
		\begin{align}
			S' &=\ \sqsubset_n^\mathsf{id} ; \sqsubset_n \\
				&= \left( \sqsubset_n \cup\ \pred{Id}{N} \right) ; \sqsubset_n \text{by definition} \\
				&=\ \sqsubset_n ; \sqsubset_n \cup\ \pred{Id}{N} ; \sqsubset_n \\
				&=\ \sqsubset_n^2 \cup \sqsubset_n \\
				&\subseteq\ \sqsubset_n \text{by I.H.} \\
				\label{thm:total3} &\subseteq\ \sqsubset_n^\mathsf{id} \text{by definition} \\
			\left( \sqsubset_n^\mathsf{id} ; \{ (i, j) \} ; \sqsubset_n^\mathsf{id} \right) ; \sqsubset_n &=\ \sqsubset_n^\mathsf{id} ; \left( \{ (i, j) \} ; \sqsubset_n^\mathsf{id} ; \sqsubset_n \right) \text{ by associativity} \\
			&=\ \sqsubset_n^\mathsf{id} ; \left( \{ (i, j) \} ; S' \right) \text{ by associativity} \\
			&\subseteq\ \sqsubset_n^\mathsf{id} ; \{ (i, j) \} ; \sqsubset_n^\mathsf{id} \text{by (\ref{thm:total3})} \\
			&\subseteq\ \sqsubset_{n + 1}
		\end{align}
	\item \textit{To show}: $\left( \sqsubset_n^\mathsf{id} ; \{ (i, j) \} ; \sqsubset_n^\mathsf{id} \right) ; \left( \sqsubset_n^\mathsf{id} ; \{ (i, j) \} ; \sqsubset_n^\mathsf{id} \right) \subseteq\ \sqsubset_{n + 1}$
	
		Let's assume that $\left( \sqsubset_n^\mathsf{id} ; \{ (i, j) \} ; \sqsubset_n^\mathsf{id} \right) ; \left( \sqsubset_n^\mathsf{id} ; \{ (i, j) \} ; \sqsubset_n^\mathsf{id} \right) \neq \emptyset$ meaning that the set at least contains a tuple $(a, b)$, for $a, b \in N$. 
		\begin{align}
			(a, b) \in \left( \sqsubset_n^\mathsf{id} ; \{ (i, j) \} ; \sqsubset_n^\mathsf{id} \right) ; \left( \sqsubset_n^\mathsf{id} ; \{ (i, j) \} ; \sqsubset_n^\mathsf{id} \right)
				&\iff \\
			\exists c \ldotp (a, c) \in \left( \sqsubset_n^\mathsf{id} ; \{ (i, j) \} ; \sqsubset_n^\mathsf{id} \right) \land (c, b) \in \left( \sqsubset_n^\mathsf{id} ; \{ (i, j) \} ; \sqsubset_n^\mathsf{id} \right)
				&\iff \\
			\exists c \ldotp (a, i) \in\ \sqsubset_n^\mathsf{id} \land (i, j) \in  \{(i, j)\} \land (j, c) \in\ \sqsubset_n^\mathsf{id} \\ \land (c, i) \in\ \sqsubset_n^\mathsf{id} \land (i, j) \in  \{(i, j)\} \land (j, b) \in\ \sqsubset_n^\mathsf{id}
				&\implies \\
			\label{thm:total4} \exists c \ldotp (j, c) \in\ \sqsubset_n^\mathsf{id} \land (c, i) \in\ \sqsubset_n^\mathsf{id}
		\end{align}
		We know that $i \neq j$ since $i < j$ so the proof proceeds with a case-by-case analysis on $c$.
		\begin{itemize}
			\item If $c = i$ then we know that $c \neq j$ and by (\ref{thm:total4}) we have that $(j, i) \in\ \sqsubset_n^\mathsf{id} \land (i, i) \in\ \sqsubset_n^\mathsf{id}$ from which it follows that $(j, i) \in\ \sqsubset_n$, a contradiction.
			\item If $c = j$ then we know that $c \neq i$ and by (\ref{thm:total4}) we have that $(j, j) \in\ \sqsubset_n^\mathsf{id} \land (j, i) \in\ \sqsubset_n^\mathsf{id}$ from which it follows that $(j, i) \in\ \sqsubset_n$, a contradiction.
			\item If $c \neq i$ and $c \neq j$ then (\ref{thm:total4}) it follows that $(j, c) \in\ \sqsubset_n \land (c, i) \in\ \sqsubset_n$. By I.H. we know that $\sqsubset_n^2\ \subseteq\ \sqsubset_n$. By definition we know that if $(j, c) \in\ \sqsubset_n$ and $(c, i) \in\ \sqsubset_n$ then $(j, i) \in\ \sqsubset_n^2$. By I.H. this means that $(j, i) \in\ \sqsubset_n$ which is again a contradiction.
		\end{itemize}
		By contradiction we conclude that $\left( \sqsubset_n^\mathsf{id} ; \{ (i, j) \} ; \sqsubset_n^\mathsf{id} \right) ; \left( \sqsubset_n^\mathsf{id} ; \{ (i, j) \} ; \sqsubset_n^\mathsf{id} \right) = \emptyset$ meaning that $\left( \sqsubset_n^\mathsf{id} ; \{ (i, j) \} ; \sqsubset_n^\mathsf{id} \right) ; \left( \sqsubset_n^\mathsf{id} ; \{ (i, j) \} ; \sqsubset_n^\mathsf{id} \right) \subseteq\ \sqsubset_{n + 1}$.
\end{itemize}
\end{proof}
}
