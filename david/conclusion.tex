\chapter{Conclusions}

In this project we succesfully introduced a program logic for serializable transactions and a concrete application to \tpl. As part of the process, we provided a formalisation of software systems adopting the two-phase locking protocol for concurrency control of transactions. This is given in terms of a model and corresponding operational semantics, which enables us to construct a framework where interesting properties can be proven: first of all the \textit{serializability} of traces, followed by the equivalence between our operational semantics and the ones where transactions are really treated as atomic blocks of code, that run in full isolation with no interleaving.

The last result was key in linking the effort to the part of the work related to the program logic, namely the one of upgrading CAP, a program logic for concurrency, to mCAP, by freeing it from specific constraints. In fact, the mCAP model was reformulated from scratch, together with parts of its assertion language and programming language, by adding support for transactions. The program logic introduced, was then proven to be sound with respect to the atomic semantics we already mentioned. This result, together with the semantics equivalence one, enabled us to complete the picture, by establishing mCAP's soundness in terms of the \tpl\ operational semantics.

In conclusion, we empower client reasoning around serializability in general and in the specific case of two-phase locking. In this case a sound abstraction is established, one that frees users from the burden of considering the intricate details of the locking protocol, while shifting the focus to the more natural approach of treating transactions' executions as serial.

Within the vast world of transactions, seen as programming blocks in databases, we took a first step in the approach of reasoning about serializable ones through a program logic, and intend to take this effort ahead in the future.

\section{Future Work}

The results obtained as part of this project, together with the approach taken in building an overall framework to reason about concurrency in a \tpl\ setting, open up the possibility of both tayloring its use to a particular application or extending the work to wider scenarios. We explore the latter by looking at how this work can be expanded or improved.
\begin{itemize}
	\item Extend the focus of the framework to non-serializable or weak models of transactional concurrency. Nowadays, specially in the context of distributed systems, full serializability appears to be too expensive in terms of performance as the explicit synchronization of single items is a bottleneck. This is the reason why weaker consistency and isolation properties, usually enforced by optimistic concurrency control protocols, are preferred. It would therefore be extremely interesting to investigate how the work done here can be modified and ported to these different levels of consistency. One part of the research effort in the Program Specification and Verification Group is to look at this scenario. The focus is on the analysis of the snapshot isolation guarantee, as opposed to serializability, and the goal is to take a similar path as compared to the one in this thesis, and define a formal model, operational semantics and a program logic on top of it.
	
	\item Model other applications in addition to \tpl. These will be concurrency control protocols which are used in real-world database systems to guarantee the serializability of transactions' executions. Moreover, during the process of expanding the applications to other lock-based approaches, we could generalize the effort and keep the parts of our model that do not directly refer to \tpl, while parameterizing all the rest. Instantiations could then be built by providing the required well formed constructs that are able to express the behaviour of the particular protocol. In terms of operational semantics, we would need to find a set of rules that, while abstracting large parts of the particular scenario, still allow to prove serializability and atomic equivalence of instantiations.
	
	\item If the timescale of the project was larger, the next step would have been to prove the simulation between a concrete implementation of a system and our operational semantics. The mentioned system would be required to adopt a particular flavour of two-phase locking to manage concurrent access to data items. An implementation has already been written in the C language and, given the premature effort to prove its equivalence, is not included in this report.
	
	\item Take inspiration from the work done in TaDA \cite{tada} in terms of abstract atomicity, in order to investigate the formal meaning of combining multiple atomic transactions in a larger and \textit{fictionally-atomic} one. In relation to this, it would also be interesting to further explore the inverse situation, where we divide an existing transaction into multiple ones, without affecting the overall result of executions. The latter technique is referred to in research as \textit{transaction chopping} and understanding how it applies to our model and semantics would give us the possibility of establishing more powerful properties.
\end{itemize}