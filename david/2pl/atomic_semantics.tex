\subsubsection{Atomic semantics}

\label{sec:atomicSem}

The atomic operational semantics shown here are behaviourally equivalent to the ones presented in Section \ref{sec:mcapOpSem}. They are converted to a transition relation for clarity and in order to ease the general proof, since the \tpl\ semantics are also expressed with a comparable structure.

The rules that follow determine a relation between storages under the effect of a program. At the level of programs, they are very similar to the \tpl\ ones, a part from the absence of a lock manager or a transactions stack. These two structures are not needed here, since there is no interleaving which happens as a result of running transactions concurrently. For this reason, there is no need to globally track information about a transaction's internal execution. Note how such behaviour is obtained through the \textsc{AtExec} rule, which reduces a transaction's body at once, by running a multi-step reduction on command $\mathds{C}$ until it hits $\pskip$. Parallelism is again obtained by nondeterministically reducing one of the two programs that are composed together.

\[
(-, -) \rightarrow (-, -) : (\mathsf{Storage} \times \mathsf{Prog})^2
\]
\[\footnotesize\def\arraystretch{3.5}
	\begin{array}{c c}
		\infer[\textsc{AtTrans}]
		{
			(h, \mathds{T}) \tred (h', \pskip)
		}
		{
			(h, \mathds{T}) \tred (h', \ptdef{\pskip})
		}
		&
		\infer[\textsc{AtPSkip}]
		{
			(h, \pskip ; \mathds{P}) \tred (h, \mathds{P})
		}
		{}
		\\
		\infer[\textsc{AtPSeq}]
		{
			(h, \mathds{P}_1 ; \mathds{P}_2) \tred (h', \mathds{P}_1' ; \mathds{P}_2)
		}
		{
			(h, \mathds{P}_1) \tred (h', \mathds{P}_1')
		}
		&
		\infer[\textsc{AtPar}]
		{
			(h, \pskip \| \pskip) \tred (h, \pskip)
		}
		{}
		\\
		\infer[\textsc{AtParL}]
		{
			(h, \mathds{P}_1 \| \mathds{P}_2) \tred (h', \mathds{P}_1' \| \mathds{P}_2)
		}
		{
			(h, \mathds{P}_1) \tred (h', \mathds{P}_1')
		}
		&
		\infer[\textsc{AtParR}]
		{
			(h, \mathds{P}_1 \| \mathds{P}_2) \tred (h', \mathds{P}_1 \| \mathds{P}_2')
		}
		{
			(h, \mathds{P}_2) \tred (h', \mathds{P}_2')
		}
		\\
		\infer[\textsc{AtChoiceL}]
		{
			(h, \mathds{P}_1 + \mathds{P}_2)
			\tred
			(h, \mathds{P}_1)
		}
		{}
		&
		\infer[\textsc{AtChoiceR}]
		{
			(h, \mathds{P}_1 + \mathds{P}_2)
			\tred
			(h, \mathds{P}_2)
		}
		{}
		\\
		\infer[\textsc{AtLoop}]
		{
			(h, \mathds{P}^*)
			\tred
			(h, \pskip + (\mathds{P} ; \mathds{P}^*))
		}
		{}
		&
		\infer[\textsc{AtExec}]
		{
			(h, \ptdef{\mathds{C}})
			\tred
			(h', \ptdef{\pskip})
		}
		{
			(h, \emptyset, \mathds{C})
			\tred^*
			(h', -, \pskip)
		}
	\end{array}
\]

The atomic operational semantics of commands are defined through the rules that follow. They show the reduction of a command when executed on a storage $h$ and variable stack $s$. The rules are equivalent to the \tpl\ ones but, given the atomic setting, there is no need for a state component that determines the phase of a transaction. There are no rules concerned with locking and unlocking either, since under the atomic semantics, transactions run in concrete and real isolation without the need to be managed when accessing storage cells.

\[
(-, -, -) \tred (-, -, -) : (\mathsf{Storage} \times \mathsf{Stack} \times \mathsf{Cmd})^2
\]
\[\footnotesize\def\arraystretch{3.5}
	\begin{array}{@{\hspace*{-20pt}}c @{\hspace{5pt}} c @{}}
		\infer[\textsc{AtSkip}]
		{
			(h, s, \pskip ; \mathds{C})
			\tred
			(h, s, \mathds{C})
		}
		{}
		&
		\infer[\textsc{AtCondT}]
		{
			(h, s, \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2})
			\tred
			(h, s, \mathds{C}_1)
		}
		{
			\llbracket \mathds{B} \rrbracket_s^B = \top
		}
		\\
		\infer[\textsc{AtSeq}]
		{
			(h, s, \mathds{C}_1 ; \mathds{C}_2)
			\tred
			(h', s', \mathds{C}_1' ; \mathds{C}_2)
		}
		{
			(h, s, \mathds{C}_1)
			\tred
			(h', s',\mathds{C}_1')
		}
		&
		\infer[\textsc{AtWrite}]
		{
			(h, s, \pmutate{\mathds{E}_1}{\mathds{E}_2})
			\tred
			(h[k \mapsto v], s, \pskip)
		}
		{
			k = \llbracket \mathds{E}_1 \rrbracket_s\ \
			k \in \pred{dom}{h}\ \
			v = \llbracket \mathds{E}_2 \rrbracket_s
		}
		\\
		\infer[\textsc{AtAssign}]
		{
			(h, s, \passign{\pvar{x}}{\mathds{E}})
			\tred
			(h, s[\pvar{x} \mapsto v], \pskip)
		}
		{
			v = \llbracket \mathds{E} \rrbracket_s
		}
		&
		\infer[\textsc{AtLoopF}]
		{
			(h, s, \ploop{\mathds{B}}{\mathds{C}})
			\tred
			(h, s, \pskip)
		}
		{
			\llbracket \mathds{B} \rrbracket_s^B = \bot
		}
		\\
		\infer[\textsc{AtCondF}]
		{
			(h, s, \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2})
			\tred
			(h, s, \mathds{C}_2)
		}
		{
			\llbracket \mathds{B} \rrbracket_s^B = \bot
		}
		&
		\infer[\textsc{AtRead}]
		{
			(h, s, \pderef{\pvar{x}}{\mathds{E}})
			\tred
			(h, s[\pvar{x} \mapsto v], \pskip)
		}
		{
			k = \llbracket \mathds{E} \rrbracket_s\ \
			k \in \pred{dom}{h}\ \
			v = h(k)
		}
		\\
		\infer[\textsc{AtLoopT}]
		{
			(h, s, \ploop{\mathds{B}}{\mathds{C}})
			\tred
			(h, s, \mathds{C}; \ploop{\mathds{B}}{\mathds{C}})
		}
		{
			\llbracket \mathds{B} \rrbracket_s^B = \top
		}
	\end{array}
\]
\[\footnotesize
\infer[\textsc{AtAlloc}]
{
	(h, s, \palloc{\pvar{x}}{\mathds{E}})
	\tred
	(h[l \mapsto 0] \ldots [l + n - 1 \mapsto 0], s[\pvar{x} \mapsto l], \pskip)
}
{
	n = \llbracket \mathds{E} \rrbracket_s\ \
	l, \ldots, l + n - 1 \not\in \pred{dom}{h}
}
\]