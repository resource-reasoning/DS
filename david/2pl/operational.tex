\subsection{Operational Semantics}

\label{sec:2plSemantics}

The formal behaviour of transactional programs' executions that are controlled by the \tpl\ protocol, is expressed through operational semantics.

\begin{defn}
	(Action labels).
	Atomic actions performed by transactions are represented using transition \emph{action labels} from the set \textsf{Act}, ranged over by $\alpha, \alpha_1, \ldots, \alpha_n$ and defined with the following grammar:
	\begin{align*}
		\alpha \in \mathsf{Act} ::=
		\ &\actprog\
		|\ \actid{\iota}\
		|\ \actalloc{\iota}{n}{l}\
		|\ \actread{\iota}{k}{v}\
		|\ \actwrite{\iota}{k}{v}\\
		|\ &\actlock{\iota}{k}{\kappa}\
		|\ \actunlock{\iota}{k}
	\end{align*}
	where $k, l \in \mathsf{Key}, n \in \mathds{N}, v \in \mathsf{Val}, \kappa \in \mathsf{Lock}, \iota \in \mathsf{Tid}$.
\end{defn}

System transitions are labelled with $\actprog$ and describe program-level execution. For this reason they are not part of any transaction. Control flow commands, that happen at the level of transactions (e.g. conditionals, loops) are labelled through $\actid{\iota}$, where $\iota$ is the identifier of the transaction performing the action. A transaction $\iota$ reads a particular value $v$ from cell indexed with $k$ via a transition whose label is $\actread{\iota}{k}{v}$ while similarly it can write a value $v$ to $k$ through $\actwrite{\iota}{k}{v}$. Cells are allocated with transitions labelled with $\actalloc{\iota}{n}{l}$ where $l$ is the storage address from which a sequence of $n$ fresh consecutive cells starts. Last, lock and unlock actions do not arise explicitly from syntactic commands as per Definition \ref{defn:ecmd}, but instead have their respective labels: $\actlock{\iota}{k}{\kappa}$ for transaction $\iota$ to lock cell $k$ under mode $\kappa$ and $\actunlock{\iota}{k}$ for the same transaction to release any locks held on $k$.

\begin{defn}
	\label{defn:actLabels}
	(Labels interpretation).
	Formal semantics for action labels are provided through an \emph{interpretation function} that, given an action, returns a global state transformer function that maps a storage and a lock manager to an updated version resulting from the label execution.
	\[
		\llbracket - \rrbracket
			:
		\mathsf{Act} \rightarrow
		\mathsf{Storage} \times \mathsf{LMan} \rightarrow
		\mathsf{State} \times \mathsf{LMan}
	\]
	\begin{align*}\\
		\llbracket \actprog \rrbracket &\triangleq \lambda h, \Phi \ldotp (h,\Phi) \\
		\llbracket \actid{\iota} \rrbracket &\triangleq \lambda h, \Phi \ldotp (h,\Phi) \\
		\llbracket \actalloc{\iota}{n}{l} \rrbracket &\triangleq \lambda h, \Phi \ldotp
			\begin{cases}
				(h[\vec{a} \mapsto 0], \Phi[\vec{a} \mapsto (\{ \iota \}, \textsc{x})]),
				&
				\text{if } n > 0 \text{ and } l \in \mathsf{Key} \text{ and } \\
				& \vec{a} = (l, \ldots, l + n - 1) \text{ and } \\
				& \{ l, \ldots, l + n - 1 \} \cap \pred{dom}{h} \equiv \emptyset \\
				(\lightning, \emptyset), & \text{otherwise}
			\end{cases}
	\\
	\llbracket \actread{\iota}{k}{v} \rrbracket &\triangleq \lambda h, \Phi \ldotp
	\begin{cases}
	(h, \Phi), & \text{if } k \in \pred{dom}{h} \text{ and } h(k) = v \text{ and } (I, \kappa) = \hat{\Phi}(k) \\ & \text{and } \iota \in I \text{ and } \kappa \geq \textsc{s} \\
	(\lightning, \emptyset), & \text{otherwise}
	\end{cases} \\
	\llbracket \actwrite{\iota}{k}{v} \rrbracket &\triangleq \lambda h, \Phi \ldotp
	\begin{cases}
	(h[k \mapsto v], \Phi), & \text{if } k \in \pred{dom}{h} \text{ and } (\{\iota\}, \textsc{x}) = \hat{\Phi}(k) \\
	(\lightning, \emptyset), & \text{otherwise}
	\end{cases} \\
	\llbracket \actlock{\iota}{k}{\kappa} \rrbracket &\triangleq \lambda h, \Phi \ldotp
	\begin{cases}
	(h, \Phi[k \mapsto (\{\iota\}, \kappa)]) & \text{if } k \in \pred{dom}{h} \text{ and} \\ & ( \kappa \geq \textsc{s} \text{ and } (\emptyset, \textsc{u}) = \hat{\Phi}(k) \\
	& \text{or } \kappa = \textsc{x} \text{ and } (\{\iota\}, \textsc{s}) = \hat{\Phi}(k) ) \\
	(h, \Phi[k \mapsto (\{\iota\} \cup I, \textsc{s})]) & \text{if } k \in \pred{dom}{h} \text{ and } \kappa = \textsc{s} \text{ and} \\ & (I, \textsc{s}) = \hat{\Phi}(k)
	\text{ and } I \not\equiv \emptyset \\
	(\lightning, \emptyset), & \text{otherwise}
	\end{cases} \\
	\llbracket \actunlock{\iota}{k} \rrbracket &\triangleq \lambda h, \Phi \ldotp
	\begin{cases}
	(h, \Phi[k \mapsto (\emptyset, \textsc{u})]) & \text{if } k \in \pred{dom}{h} \text{ and } (\{\iota\}, \kappa) = \hat{\Phi}(k) \\
	(h, \Phi[k \mapsto (I, \textsc{s})]) & \text{if } k \in \pred{dom}{h} \text{ and } (\{\iota\} \cup I, \textsc{s}) = \hat{\Phi}(k) \\ & \text{and } I \not\equiv \emptyset \\
	(\lightning, \emptyset), & \text{otherwise}
	\end{cases}
	\end{align*}
\end{defn}
Both the $\actprog$ and $\actid{\iota}$ actions have no effect on the global storage and on the lock manager structures, therefore the state transformer associated to them will simply be identity. The $\actalloc{\iota}{n}{l}$ label will instead give a transformer that succeeds in creating new cells at addresses $l$ to $l + n - 1$ (as we precisely want $n$ consecutive cells) only when all of such addresses are not currently in the heap domain and $n$ is a positive number. The initial value for those storage cells is set to be $0$. In all other cases, the operation will fail, bringing the resulting state to $\lightning$, i.e. the faulting state. The keys which have been allocated will also be set in the output lock manager, by locking them in exclusive mode and giving their sole ownership to transaction $\iota$.

The intepretation of a read action label, $\actread{\iota}{k}{v}$ is identity in the case where $v$ is the value associated to address $k$ as part of the input storage $h$ and $\iota$ is an owner of $k$'s lock, currently under a mode which is either shared or exclusive (expressed through the total order $\geq$). In all other scenarios the execution fails, resulting in the $\lightning$ state. The state transformer for write operations, namely $\actwrite{\iota}{k}{v}$, works in a similar way, by requiring transaction $\iota$ to be the unique owner of cell $k$ locked in exclusive mode. On top of this, $k$ must obviously be part of the input storage $h$. If these requirements are met, then $\iota$ can update $k$'s numerical value to the given $v$, otherwise the system fails and again we reach $\lightning$.

A $\actlock{\iota}{k}{\kappa}$ action label transforms the input lock manager according to a set of requirements. First, cell $k$ must be a valid key in the input storage $h$. Next, we have three cases to consider. Either the lock action is requesting a shared lock on $k$, i.e. $\kappa = \textsc{s}$, and the current lock mode on $k$ is already \textsc{s}, in which case $\iota$ is simply added to the set of lock owners. Otherwise, if the lock mode associated to $k$ inside of $\Phi$ is unlocked, and there are no owners, then $\iota$ is free to lock it in any mode out of \textsc{s} or \textsc{x}. The last scenario is referred to as \textit{lock upgrade}, since, if $\iota$ is currently the sole owner of $k$ under shared mode, it can issue an exclusive lock request and be granted access. All other cases are covered with the faulting state. The final label to consider is the unlock one, namely $\actunlock{\iota}{k}$, which releases a lock currently owned by $\iota$. In the case where $\iota$ was the only transaction holding the lock, then the lock manager is transformed so that $k$'s lock turns into unlocked mode with an empty owner set. If instead there are other threads holding the same lock in shared mode, then the latter is preserved and $\iota$ is removed from the corresponding owners set.

\subsubsection{Commands}

\label{sec:opSemCmd2pl}
	
The operational semantics of commands are defined as a labelled transition relation through the following rules, where $\iota \in \mathsf{Tid}$ is the identifier of the transaction as part of which the command is executed and labels are the actions illustrated in Definition \ref{defn:actLabels}. The effect of transaction commands is reflected locally on $\mathds{T}_\iota$'s variable stack and locking phase and globally through the interpretation of the action label.
\begin{gather*}
	(-, -, -) \xrightarrow{-}_- (-, -, -) : \\
	\mathsf{Stack} \times \mathsf{Phase} \times \mathsf{Cmd}
	\times \mathsf{Act} \times \mathsf{Tid} \times
	\mathsf{Stack} \times \mathsf{Phase} \times \mathsf{Cmd}
\end{gather*}

The \textsc{Assign} rule works in a standard way, by updating the value associated to a variable in the transaction's stack with the assigned expression evaluated under the same stack $s$. It then resolves into a $\pskip$ command without modifying the transaction's locking phase.
\[
\infer[\textsc{Assign}]
{
	(s, p, \passign{\pvar{x}}{\mathds{E}})
	\xrightarrow{\actid{\iota}}_\iota
	(s[\pvar{x} \mapsto v], p, \pskip)
}
{
	v = \tsem{\mathds{E}}^\textsc{e}_s
}
\]

The conditional statement is coped with two rules, \textsc{CondT} and \textsc{CondF}, that cover the cases where the boolean condition $\mathds{B}$, evaluated under the current stack $s$, resolves to $\top$ or to $\bot$. In the first case, the execution will proceed to the $\mathds{C}_1$ body while in the second one to the $\mathds{C}_2$ command. Given that such control flow operations have no concrete effect on the global state of the program, conditional transitions are labelled with $\actid{\iota}$.

\[
\infer[\textsc{CondT}]
{
	(s, p, \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2})
	\xrightarrow{\actid{\iota}}_\iota
	(s, p, \mathds{C}_1)
}
{
	\llbracket \mathds{B} \rrbracket_s^\textsc{b} = \top
}
\]

\[
\infer[\textsc{CondF}]
{
	(s, p, \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2})
	\xrightarrow{\actid{\iota}}_\iota
	(s, p, \mathds{C}_2)
}
{
	\llbracket \mathds{B} \rrbracket_s^\textsc{b} = \bot
}
\]

Loops are supported in the operational semantics in a similar way to the if statement, with two rules: \textsc{LoopT} and \textsc{LoopF}. In the first case, the condition $\mathds{B}$ must be evaluated to $\top$ and the loop is unrolled for one iteration at a time. In the second case, when $\mathds{B}$ is semantically evaluated to $\bot$ under the stack $s$, the program execution exits the loop, resolving in a $\pskip$ command. Again, $\actid{\iota}$ is used to label such transitions since there is no action involving the global state (i.e. storage and lock manager).

\[
\infer[\textsc{LoopT}]
{
	(s, p, \ploop{\mathds{B}}{\mathds{C}})
	\xrightarrow{\actid{\iota}}_\iota
	(s, p, \mathds{C}; \ploop{\mathds{B}}{\mathds{C}})
}
{
	\llbracket \mathds{B} \rrbracket_s^\textsc{B} = \top
}
\]

\[
\infer[\textsc{LoopF}]
{
	(s, p, \ploop{\mathds{B}}{\mathds{C}})
	\xrightarrow{\actid{\iota}}_\iota
	(s, p, \pskip)
}
{
	\llbracket \mathds{B} \rrbracket_s^\textsc{B} = \bot
}
\]

The \textsc{SeqSkip} and \textsc{Seq} rules, cope with the sequential composition of commands inside of a transaction's body. The first command in a composition is ran one step at a time through rule \textsc{Seq}, until it is eventually resolved to $\pskip$ and at that point, the execution proceeds to the next command $\mathds{C}$ via the \textsc{SeqSkip} rule. Any action label $\alpha$, which is executed by $\mathds{C}_1$, is then replicated in the reduction of $\mathds{C}_1 ; \mathds{C}_2$.

\[
	\begin{array}{c c}
		\infer[\textsc{Seq}]
		{
			(s, p, \mathds{C}_1 ; \mathds{C}_2)
			\xrightarrow{\alpha}_\iota
			(s', p', \mathds{C}_1' ; \mathds{C}_2)
		}
		{
			(s, p, \mathds{C}_1)
			\xrightarrow{\alpha}_\iota
			(s', p', \mathds{C}_1')
		}
		&
		\infer[\textsc{SeqSkip}]
		{
			(s, p, \pskip ; \mathds{C})
			\xrightarrow{\actid{\iota}}_\iota
			(s, p, \mathds{C})
		}
		{}
	\end{array}
\]

A transaction can allocate fresh storage cells through the use of the $\palloc{\mathds{E}}$ command by specifying the amount of necessary space needed through the numerical expression $\mathds{E}$. The \textsc{Alloc} rule's premiss requires $n$ to be the result of the semantic evaluation of $\mathds{E}$ under the stack $s$. The rest of the requirements are imposed by the interpretation of the $\actalloc{\iota}{n}{l}$ label. The \textsc{Alloc} rule reduces the command to $\pskip$ and updates the transaction stack so that variable $\pvar{x}$ points to the start address of the newly allocated storage cells sequence, $l$.
\[
\infer[\textsc{Alloc}]
{
	(s, p, \palloc{\pvar{x}}{\mathds{E}})
	\xrightarrow{\actalloc{\iota}{n}{l}}_\iota
	(s[\pvar{x} \mapsto l], p, \pskip)
}
{
	n = \tsem{\mathds{E}}_s^\textsc{e}
}
\]

The \textsc{Read} rule enables the reduction of transactions reading items in the shared storage. Transitions generated this way are labelled through $\actread{\iota}{k}{v}$ and carry all of the requirements imposed by the semantic interpretation of actions. The accessed key $k$ is the result of semantically evaluating expression $\mathds{E}$ under the current stack $s$. Finally, the rule reduces the command into $\pskip$ and updates the value associated to variable $\pvar{x}$ in $s$ to the read value $v$.

\[
\infer[\textsc{Read}]
{
	(s, p, \pderef{\pvar{x}}{\mathds{E}})
	\xrightarrow{\actread{\iota}{k}{v}}_\iota
	(s[\pvar{x} \mapsto v], p, \pskip)
}
{
	k = \tsem{\mathds{E}}_s^\textsc{e}
}
\]

In order to reduce a write command issued by a transaction, the \textsc{Write} rule is used. The target storage key $k$ and the value $v$ written to it are the results of semantically evaluating expressions $\mathds{E}_1$ and $\mathds{E}_2$ respectively, both under the transaction's stack $s$. The transition is labelled with the $\actwrite{\iota}{k}{v}$ action which adds the set of requirements on the current storage and lock manager. The rule also reduces the command to $\pskip$.

\[
\infer[\textsc{Write}]
{
	(s, p, \pmutate{\mathds{E}_1}{\mathds{E}_2})
	\xrightarrow{\actwrite{\iota}{k}{v}}_\iota
	(s, p, \pskip)
}
{
	k = \llbracket \mathds{E}_1 \rrbracket_s &
	v = \llbracket \mathds{E}_2 \rrbracket_s
}
\]

At any point during the execution of a command as part of a transaction $\mathds{T}_\iota$, the latter can acquire a lock  on a cell in the storage in a nondeterministic fashion through the \textsc{Lock} rule, as long as $\mathds{T}_\iota$ is strictly in the growing phase. The current transaction's stack, locking phase and command $\mathds{C}$ will not be modified as part of this transition. We model locking and unlocking of cells this way, in order to cover all possible flavours of \tpl. In fact, any particular pattern of lock acquisition and release that complies with Two-Phase-Locking will be a subset of this operational semantics.

\[
\infer[\textsc{Lock}]
{
	(s, \curlywedge, \mathds{C})
	\xrightarrow{\actlock{\iota}{k}{\kappa}}_\iota
	(s, \curlywedge, \mathds{C})
}
{}
\]

Opposite to the \textsc{Lock} rule we present the \textsc{Unlock} one, which copes with transactions nondeterministically releasing locks on cells they own. No constraint is set on which locking phase $\mathds{T}_\iota$ is currently in, but the successful reduction labelled via $\actunlock{\iota}{k}$ sets the transaction's phase to shrinking. This way, the same rule covers the case where the current unlock is the first one determining the start of the shrinking phase or the case where $\iota$ has already started releasing locks. As part of the reduction described by \textsc{Unlock}, the transaction's stack and command are unmodified.

\[
\infer[\textsc{Unlock}]
{
	(s, p, \mathds{C})
	\xrightarrow{\actunlock{\iota}{k}}_\iota
	(s, \curlyvee, \mathds{C})
}
{}
\]

\subsubsection{Transactions}

The operational semantics of transactions are defined as a labelled transition relation through the following rule, where $\iota \in \mathsf{Tid}$ is the identifier of the transaction which is being executed and the labels are the actions performed as part of commands in the transaction's body.
\begin{gather*}
	(-, -, -) \xrightarrow{-} (-, -, -) : \\
	\mathsf{Stack} \times \mathsf{Phase} \times \mathsf{Trans}
	\times \mathsf{Act} \times
	\mathsf{Stack} \times \mathsf{Phase} \times \mathsf{Trans}
\end{gather*}

The only rule which allows the reduction of a transaction's body is \textsc{Step}. The latter indicates that as long as we can run a single reduction step on the body of $\mathds{T}_\iota$, namely $\mathds{C}$, to bring the transaction's state to $s', p', \mathds{C}'$, then we can replicate that same step on the level of the transaction to bring it to the same $s', p', \ptdef{\mathds{C}'}$. Note how the transaction identifier $\iota$ is used to annotate the command reduction on $\mathds{C}$.
\[
\infer[\textsc{Step}]
{
	(s, p, \ptdef{\mathds{C}}_\iota)
	\xrightarrow{\alpha}
	(s', p', \ptdef{\mathds{C}'}_\iota)
}
{
	(s, p, \mathds{C})
	\xrightarrow{\alpha}_\iota
	(s', p', \mathds{C}')
}
\]

\subsubsection{Programs}

The operational semantics of programs are defined as a labelled transition relation through the following rules. Labels either come from system transitions or from the execution of transactions and moreover of the commands within their bodies. They are propagated all the way to the level of programs.
\begin{gather*}
(-, -, -, -) \xrightarrow{-} (-, -, -, -) \\
: \mathsf{Storage} \times \mathsf{LMan} \times \mathsf{TState} \times \mathsf{Prog} \times \mathsf{Act} \times \mathsf{State} \times \mathsf{LMan} \times \mathsf{TState} \times \mathsf{Prog}
\end{gather*}

Whenever program execution encounters a new user transaction definition that does not carry a transaction identifier, it will associate a fresh one to it, $\iota$, and turn it into a system transaction. The identifier $\iota$ must be distinct from all others currently running in the system (and traceable via the transactions state $S$). Moreover $\iota$ needs to be the maximum element with regards to all other present identifiers. For this purpose, we leverage the given strict total order $<$, defined on $\mathsf{Tid}$.
\[
	\infer[\textsc{Start}]
	{
		(h, \Phi, S, \ptdef{\mathds{C}})
		\xrightarrow{\actid{\iota}}
		(h, \Phi, S[\iota \mapsto (\emptyset, \pgrow)], \ptdef{\mathds{C}}_\iota)
	}
	{
		\iota \in \{ i\ |\ \forall j \in \pred{dom}{S} \ldotp j < i \}
	}
\]

On the opposite end, when a transaction's body is the $\pskip$ command, the program reduces to $\pskip$ through the \textsc{PSkip} rule which determines the end of the transaction. This can only happen as long as $\mathds{T}_\iota$ (i.e. the terminating transaction) is not holding any locks as part of the lock manager. This is concretely checked by making sure the identifier $\iota$ is not part of any owners' set in $\Phi$.

\[
\infer[\textsc{PSkip}]
{
	 (h, \Phi, S, \mathtt{begin}\ \pskip\ \mathtt{end}_\iota)
	\xrightarrow{\actid{\iota}}
	(h, \Phi, S, \pskip)
}
{
	\forall k \ldotp k \in \pred{dom}{\Phi} \implies \iota \not\in \left( \Phi(k) \downarrow_1 \right)
}
\]

The main rule that deals with the reduction of an active transaction is \textsc{Exec}. This applies to a system transaction identified with $\iota$: as long as such transaction can be reduced for one single step labelled with action $\alpha$ we can reduce the program in which $\mathds{T}_\iota$ resides in the same way. The state of $\mathds{T}_\iota$ is retrieved from the overall transactions state $S$, which gives both the local stack and locking phase for $\iota$ itself. As part of the reduction, the updated storage component $h'$ and lock manager one $\Phi'$, will be the output of the state trasformer function obtained from the interpretation of $\alpha$ and applied to the current global structures $h, \Phi$. The new local state of $\mathds{T}_\iota$, i.e. $s'$ and $p'$, is recorded by updating the mapping for $\iota$ as part of $S$.

\[
\infer[\textsc{Exec}]
{
	 (h, \Phi, S, \mathtt{begin}\ \mathds{C}\ \mathtt{end}_\iota)
	\xrightarrow{\alpha}
	(h', \Phi', S[\iota \mapsto (s', p')], \mathtt{begin}\ \mathds{C}'\ \mathtt{end}_\iota)
}
{
	(s, p) = \hat{S}(\iota) &
	(s, p, \mathtt{begin}\ \mathds{C}\ \mathtt{end}_\iota)
	\xrightarrow{\alpha}
	(s', p', \mathtt{begin}\ \mathds{C}'\ \mathtt{end}_\iota) &
	(h', \Phi') = \llbracket \alpha \rrbracket (h, \Phi)
}
\]

Sequential composition of programs is reduced through the \textsc{PSeq} and \textsc{PSeqSkip} operational semantics rules. Similarly to the commands one, $\mathds{P}_1 ; \mathds{P}_2$ is overall reduced by first taking steps in $\mathds{P}_1$ until the program execution hits $\pskip$, at which point the reduction follows with $\mathds{P}_2$ using a system transition labelled with $\actprog$.

\[
\infer[\textsc{PSeq}]
{
	 (h, \Phi, S, \mathds{P}_1; \mathds{P}_2)
	\xrightarrow{\alpha}
	(h', \Phi', S', \mathds{P}_1'; \mathds{P}_2)
}
{
	 (h, \Phi, S, \mathds{P}_1)
	\xrightarrow{\alpha}
	(h', \Phi', S', \mathds{P}_1')
}
\]

\[
\infer[\textsc{PSeqSkip}]
{
	 (h, \Phi, S, \pskip; \mathds{P})
	\xrightarrow{\actprog}
	(h, \Phi, S, \mathds{P})
}
{}
\]

On the other hand, the parallel composition of two programs is carried over by choosing one of the programs to reduce for one single step in a nondeterministic way. It follows that the interleaving of reductions coming from different programs happens as part of this process. Also, for this reason, we have two rules to cope with the parallel composition $\mathds{P}_1 \| \mathds{P}_2$: \textsc{ParL} and \textsc{ParR}, which, as the names suggest, take one step on the program which is syntactically on the left ($\mathds{P}_1$) or on the right ($\mathds{P}_2$).

\[
\infer[\textsc{ParL}]
{
	 (h, \Phi, S, \mathds{P}_1 \| \mathds{P}_2)
	\xrightarrow{\alpha}
	(h', \Phi', S', \mathds{P}_1' \| \mathds{P}_2)
}
{
	 (h, \Phi, S, \mathds{P}_1)
	\xrightarrow{\alpha}
	(h', \Phi', S', \mathds{P}_1')
}
\]

\[
\infer[\textsc{ParR}]
{
	 (h, \Phi, S, \mathds{P}_1 \| \mathds{P}_2)
	\xrightarrow{\alpha}
	(h', \Phi', S', \mathds{P}_1 \| \mathds{P}_2')
}
{
	 (h, \Phi, S, \mathds{P}_2)
	\xrightarrow{\alpha}
	(h', \Phi', S', \mathds{P}_2')
}
\]

When both programs that are being composed in parallel reach $\pskip$ we can use the \textsc{ParEnd} rule to reduce the composition itself to $\pskip$ through a system transition $\actprog$.

\[
\infer[\textsc{ParEnd}]
{
	 (h, \Phi, S, \pskip \| \pskip)
	\xrightarrow{\actprog}
	(h, \Phi, S, \pskip)
}
{}
\]

Looping is supported by the operational semantics through the \textsc{Loop} rule which converts $\mathds{P}^*$ into $\pskip + (\mathds{P} ; \mathds{P}^*)$ via a system transition labelled with $\actprog$. The syntactic transformation turns the loop into a nondeterministic choice between terminating the program or executing the loop body ($\mathds{P}$) and repeating the same loop choice.

\[
\infer[\textsc{Loop}]
{
	 (h, \Phi, S, \mathds{P}^*)
	\xrightarrow{\actprog}
	(h, \Phi, S, \pskip + (\mathds{P} ; \mathds{P}^*))
}
{}
\]

The \textsc{ChoiceL} and \textsc{ChoiceR} rules cover the reduction of nondeterministic choice between two programs, $\mathds{P}_1 + \mathds{P}_2$. The choice happens as part of a system transition labelled with $\actprog$ which does not modify the global structures $h, \Phi, S$ but only reduces the program.

\[
\infer[\textsc{ChoiceL}]
{
	 (h, \Phi, S, \mathds{P}_1 + \mathds{P}_2)
	\xrightarrow{\actprog}
	(h, \Phi, S, \mathds{P}_1)
}
{}
\]

\[
\infer[\textsc{ChoiceR}]
{
	 (h, \Phi, S, \mathds{P}_1 + \mathds{P}_2)
	\xrightarrow{\actprog}
	(h, \Phi, S, \mathds{P}_2)
}
{}
\]