\subsubsection{Proof}

\begin{thm}

\label{thm:atom}

\[
	\forall h, h', S, S' \ldotp
	(h, \emptyset, S, \mathds{P}) \rightarrow^* (h', \emptyset, S', \pskip) \implies 
	(h, \mathds{P}) \tred^* (h', \pskip)
\]

{\parindent0pt
\begin{proof}
The proof is done by induction on the structure of programs $\mathsf{Prog}$. \\

\textit{Base case 1}: $\pskip \in \mathsf{Prog}$

\textit{To show}:
\[
	\forall h, h', S, S' \ldotp
	(h, \emptyset, S, \pskip) \rightarrow^* (h', \emptyset, S', \pskip) \implies 
	(h, \pskip) \tred^* (h', \pskip)
\]

For arbitrary $h, h', S, S'$ we assume that $(h, \emptyset, S, \pskip) \rightarrow^* (h', \emptyset, S', \pskip)$ holds, and given that $\pskip$ has no possible one-step reductions, it must be the case that it is a zero-step reduction. Therefore we have $h = h'$ and $S = S'$. Starting from $(h, \pskip)$ through the $\tred$ relation, we can always reach $(h, \pskip)$ via a zero-step reduction $(h, \pskip) \tred^0 (h, \pskip)$. We can conclude that $(h, \emptyset, S, \pskip) \rightarrow^* (h', \emptyset, S', \pskip) \implies (h, \pskip) \tred^* (h', \pskip)$ where $h = h'$. \\

\textit{Base case 2}: $\mathds{T} \in \mathsf{Prog}$

\textit{To show}:
\[
	\forall h, h', S, S' \ldotp
	(h, \emptyset, S, \mathds{T}) \rightarrow^* (h', \emptyset, S', \pskip) \implies 
	(h, \mathds{T}) \tred^* (h', \pskip)
\]

We will proceed with the proof by induction on the structure of transactions $\mathsf{Trans}$. Given that the \textsc{Atom} semantics only support user transactions, all that is required to show is:
\begin{gather*}
	\forall h, h', S, S' \ldotp \\
	(h, \emptyset, S, \ptdef{\mathds{C}}) \rightarrow^* (h', \emptyset, S', \pskip) \implies 
	(h, \ptdef{\mathds{C}}) \tred^* (h', \pskip)
\end{gather*}

For arbitrary $h, h', S, S'$ we assume that $(h, \emptyset, S, \ptdef{\mathds{C}}) \rightarrow^* (h', \emptyset, S', \pskip)$ holds. Given the overall reduction from $\ptdef{\mathds{C}}$ to $\pskip$ it must be the case that the following holds.
\begin{gather*}
	(h, \emptyset, S, \ptdef{\mathds{C}})
	\xrightarrow{\actid{\iota}} (h, \emptyset, S[\iota \mapsto (\emptyset, \pgrow)], \ptdef{\mathds{C}}_\iota) \\
	\rightarrow^* (h', \emptyset, S', \ptdef{\pskip}_\iota)
	\xrightarrow{\actprog} (h', \emptyset, S', \pskip)
\end{gather*}
Which implies that $\mathds{C}$ reduces to $\pskip$ through the repeated use of the \textsc{Exec} rule. From the transitive closure of the $\rightarrow$ relation and Lemma \ref{lem:catom} we obtain the result that $(h, \ptdef{\mathds{C}}) \tred^* (h', \pskip)$. \\

\textit{Inductive case 1}: $\mathds{P}_1 + \mathds{P}_2 \in \mathsf{Prog}$

\textit{To show}:
\[
	\forall h, h', S, S' \ldotp
	(h, \emptyset, S, \mathds{P}_1 + \mathds{P}_2) \rightarrow^* (h', \emptyset, S', \pskip) \implies 
	(h, \mathds{P}_1 + \mathds{P}_2 ) \tred^* (h', \pskip)
\]

\textit{Inductive hypothesis}:
\begin{gather*}
	\forall h, h', S, S' \ldotp
	(h, \emptyset, S, \mathds{P}_1) \rightarrow^* (h', \emptyset, S', \pskip) \implies 
	(h, \mathds{P}_1) \tred^* (h', \pskip)
	\\ \land \\
	\forall h, h', S, S' \ldotp
	(h, \emptyset, S, \mathds{P}_2) \rightarrow^* (h', \emptyset, S', \pskip) \implies 
	(h, \mathds{P}_2) \tred^* (h', \pskip)
\end{gather*}

For arbitrary $h, h', S, S'$ we assume that $(h, \emptyset, S, \mathds{P}_1 + \mathds{P}_2) \rightarrow^* (h', \emptyset, S', \pskip)$ holds. Now we are presented with two cases:
\begin{enumerate}
	\item We can reduce $(h, \emptyset, S, \mathds{P}_1 + \mathds{P}_2) \xrightarrow{\actprog} (h, \emptyset, S, \mathds{P}_1)$ with one step through the \textsc{ChoiceL} rule, which we can always apply since it has an empty premiss. We can also always reduce $(h, \mathds{P}_1 + \mathds{P}_2) \tred (h, \mathds{P}_1)$ through the rule \textsc{AtChoiceL} given it has an empty premiss. By inductive hypothesis on $\mathds{P}_1$ we obtain that $(h, \emptyset, S, \mathds{P}_1) \rightarrow^* (h', \emptyset, S', \pskip) \implies (h, \mathds{P}_1) \tred^* (h', \pskip)$. Therefore we can conclude that $(h, \emptyset, S, \mathds{P}_1 + \mathds{P}_2) \rightarrow^* (h', \emptyset, S', \pskip) \implies  (h, \mathds{P}_1 + \mathds{P}_2) \tred^* (h', \pskip)$.
	
	\item We can reduce $(h, \emptyset, S, \mathds{P}_1 + \mathds{P}_2) \xrightarrow{\actprog} (h, \emptyset, S, \mathds{P}_2)$ with one step through the \textsc{ChoiceR} rule, which we can always apply since it has an empty premiss. We can also always reduce $(h, \mathds{P}_1 + \mathds{P}_2) \tred (h, \mathds{P}_2)$ through the rule \textsc{AtChoiceR} given it has an empty premiss. By inductive hypothesis on $\mathds{P}_2$ we obtain that $(h, \emptyset, S, \mathds{P}_2) \rightarrow^* (h', \emptyset, S', \pskip) \implies (h, \mathds{P}_2) \tred^* (h', \pskip)$. Therefore we can conclude that $(h, \emptyset, S, \mathds{P}_1 + \mathds{P}_2) \rightarrow^* (h', \emptyset, S', \pskip) \implies  (h, \mathds{P}_1 + \mathds{P}_2) \tred^* (h', \pskip)$. \\
\end{enumerate}

\textit{Inductive case 2}: $\mathds{P}_1 ; \mathds{P}_2 \in \mathsf{Prog}$

\textit{To show}:
\[
	\forall h, h', S, S' \ldotp
	(h, \emptyset, S, \mathds{P}_1 ; \mathds{P}_2) \rightarrow^* (h', \emptyset, S', \pskip) \implies 
	(h, \mathds{P}_1 ; \mathds{P}_2 ) \tred^* (h', \pskip)
\]

\textit{Inductive hypothesis}:
\begin{gather*}
	\forall h, h', S, S' \ldotp
	(h, \emptyset, S, \mathds{P}_1) \rightarrow^* (h', \emptyset, S', \pskip) \implies 
	(h, \mathds{P}_1) \tred^* (h', \pskip)
	\\ \land \\
	\forall h, h', S, S' \ldotp
	(h, \emptyset, S, \mathds{P}_2) \rightarrow^* (h', \emptyset, S', \pskip) \implies 
	(h, \mathds{P}_2) \tred^* (h', \pskip)
\end{gather*}

For arbitrary $h, h', S, S'$ we assume that $(h, \emptyset, S, \mathds{P}_1 ; \mathds{P}_2) \rightarrow^* (h', \emptyset, S', \pskip)$ holds. Given the overall reduction from $\mathds{P}_1 ; \mathds{P}_2$ to $\pskip$ we must have a chain of reductions of the following shape, for some $h'', S''$: \iffalse where $\Phi'' = \emptyset$ by Lemma \ref{ref:phiemp}. \fi
\[
	\underbrace{(h, \emptyset, S, \mathds{P}_1 ; \mathds{P}_2) \rightarrow^* (h'', \emptyset, S'', \pskip; \mathds{P}_2)}_{(\textsc{i})}
	\xrightarrow{\actprog} (h'', \emptyset, S'', \mathds{P}_2) \rightarrow^* (h', \emptyset, S', \pskip)
\]
\begin{enumerate}
	\item \label{seq:1} By (\textsc{i}) and Lemma \ref{ref:2seq} we get that $(h, \emptyset, S, \mathds{P}_1) \rightarrow^* (h'', \emptyset, S'', \pskip)$ holds.
	
	\item \label{seq:2} By \ref{seq:1}. and the inductive hypothesis on $\mathds{P}_1$ we obtain that $(h, \mathds{P}_1) \tred^* (h'', \pskip)$.
	
	\item By \ref{seq:2}. and Lemma \ref{ref:aseq} we get that $(h, \mathds{P}_1 ; \mathds{P}_2) \tred^* (h'', \pskip ; \mathds{P}_2)$.
\end{enumerate}

At this point we can apply the \textsc{PSeqSkip} rule to reduce $(h'', \emptyset, S'', \pskip ; \mathds{P}_2) \xrightarrow{\actprog} (h'', \emptyset, S'', \mathds{P}_2)$ and rule \textsc{AtPSeqSkip} to reduce $(h'', \pskip ; \mathds{P}_2) \tred^* (h'', \mathds{P}_2)$. By inductive hypothesis on $\mathds{P}_2$ we can conclude that $(h, \emptyset, S, \mathds{P}_1 ; \mathds{P}_2) \rightarrow^* (h', \emptyset, S', \pskip) \implies (h, \mathds{P}_1 ; \mathds{P}_2) \tred^* (h', \pskip)$. \\

\textit{Inductive case 3}: $\mathds{P}^* \in \mathsf{Prog}$

\textit{To show}:
\[
	\forall h, h', S, S' \ldotp
	(h, \emptyset, S, \mathds{P}^*) \rightarrow^* (h', \emptyset, S', \pskip) \implies 
	(h, \mathds{P}^* ) \tred^* (h', \pskip)
\]

\textit{Inductive hypothesis}:
\[
	\forall h, h', S, S' \ldotp
	(h, \emptyset, S, \mathds{P}) \rightarrow^* (h', \emptyset, S', \pskip) \implies 
	(h, \mathds{P}) \tred^* (h', \pskip)
\]

For arbitrary $h, h', S, S'$ we assume that $(h, \emptyset, S, \mathds{P}^*) \rightarrow^* (h', \emptyset, S', \pskip)$ holds (\textsc{i}). Given the overall reduction from $\mathds{P}^*$ to $\pskip$ we must have a chain of reductions of the following shape, for some $h'', \Phi'', S''$:
\[
(h, \emptyset, S, \mathds{P}^*) \rightarrow^* (h'', \Phi'', S'', \pskip + (\mathds{P} ; \mathds{P}^*)) \rightarrow^*  (h', \emptyset, S', \pskip + (\mathds{P} ; \mathds{P}^*)) \xrightarrow{\actprog} (h', \emptyset, S', \pskip)
\]
Through the \textsc{Loop} rule (\textsc{ii}), we can always reduce $(h, \emptyset, S, \mathds{P}^*) \xrightarrow{\actprog} (h, \emptyset, S, \pskip + (\mathds{P} ; \mathds{P}^*))$ given that it has an empty premiss. Similarly, we can always reduce any $(h'', \mathds{P}^*) \tred (h'', \pskip + (\mathds{P} ; \mathds{P}^*))$ via the \textsc{AtLoop} rule as it also has an empty premiss. We now consider two possible cases:
\begin{enumerate}
	\item \label{loop:1} We reduce $(h, \emptyset, S, \pskip + (\mathds{P} ; \mathds{P}^*)) \xrightarrow{\actprog} (h, \emptyset, S, \pskip)$ through the \textsc{ChoiceL} rule which we can always do, together with \textsc{AtChoiceL} that reduces $(h, \pskip + (\mathds{P} ; \mathds{P}^*)) \tred (h, \pskip)$. In this scenario we directly obtain the result.
	
	\item We reduce $(h, \emptyset, S, \pskip + (\mathds{P} ; \mathds{P}^*)) \xrightarrow{\actprog} (h, \emptyset, S, \mathds{P} ; \mathds{P}^*)$ through the \textsc{ChoiceR} rule which we can always do, together with \textsc{AtChoiceR} that reduces $(h, \pskip + (\mathds{P} ; \mathds{P}^*)) \tred (h, \mathds{P} ; \mathds{P}^*)$. By Lemma \ref{ref:2seq}, Lemma \ref{ref:aseq} and the inductive hypothesis on $\mathds{P}$ we get that $(h, \emptyset, S, \mathds{P} ; \mathds{P}^*) \rightarrow^* (h'', \emptyset, S'', \pskip ; \mathds{P}^*) \implies (h, \mathds{P} ; \mathds{P}^*) \tred^* (h'', \pskip ; \mathds{P}^*)$. It is now possible to further reduce $(h'', \emptyset, S'', \pskip ; \mathds{P}^*) \xrightarrow{\actprog} (h'', \emptyset, S'', \mathds{P}^*)$ via \textsc{PSeqSkip} and $(h'', \pskip ; \mathds{P}^*) \tred (h'', \mathds{P}^*)$ through \textsc{AtPSeqSkip}. We are now in the position to repeat the process from point (\textsc{ii}) until case \ref{loop:1} is encountered at which point we have a reduction to $\pskip$. This will eventually happen given our initial assumption (\textsc{i}). \\
\end{enumerate}

\textit{Inductive case 4}: $\mathds{P}_1 \| \mathds{P}_2 \in \mathsf{Prog}$

\textit{To show}:
\[
	\forall h, h', S, S' \ldotp
	(h, \emptyset, S, \mathds{P}_1 \| \mathds{P}_2) \rightarrow^* (h', \emptyset, S', \pskip) \implies 
	(h, \mathds{P}_1 \| \mathds{P}_2 ) \tred^* (h', \pskip)
\]

We will prove the parallel composition case by mathematical induction on the number of reduction steps $n$.

\textit{Base case}: $n = 0$

\textit{To show}:
\begin{gather*}
	\forall h, h', S, S' \ldotp \\
	(h, \emptyset, S, \mathds{P}_1 \| \mathds{P}_2) \rightarrow^0 (h', \emptyset, S', \pskip)
	\implies
	(h, \mathds{P}_1 \| \mathds{P}_2) \tred^* (h', \pskip)
\end{gather*}

For arbitrary $h, h', S, S'$ we assume that $(h, \emptyset, S, \mathds{P}_1 \| \mathds{P}_2) \rightarrow^0 (h', \emptyset, S', \pskip)$ holds. Since a zero-step reduction happened, it must be the case that $\mathds{P}_1 = \mathds{P}_2 = \pskip$, $h' = h$ and $\pskip \| \pskip$ reduced to $\pskip$ through the \textsc{ParEnd} rule. Now, we immediately obtain that $(h, \pskip \| \pskip) \tred (h, \pskip)$ from rule \textsc{AtParEnd}. \\

\textit{Inductive case 4.1}: $n > 0$

\textit{Inductive hypothesis}:
\begin{gather*}
	\forall m \leq n, h, h', S, S', \mathds{P}_1, \mathds{P}_2 \ldotp \\
	(h, \emptyset, S, \mathds{P}_1 \| \mathds{P}_2) \rightarrow^m (h', \emptyset, S', \pskip)
	\implies
	(h, \mathds{P}_1 \| \mathds{P}_2) \tred^* (h', \pskip)
\end{gather*}

\textit{To show}:
\begin{gather*}
	\forall h, h', \Phi, S, S' \ldotp \\
	(h, \emptyset, S, \mathds{P}_1 \| \mathds{P}_2) \rightarrow^{n+1} (h', \emptyset, S', \pskip)
	\implies
	(h, \mathds{P}_1 \| \mathds{P}_2) \tred^* (h', \pskip)
\end{gather*}

\newpage 
For arbitrary $h, h', S, S'$ we assume that $(h, \emptyset, S, \mathds{P}_1 \| \mathds{P}_2) \rightarrow^{n+1} (h', \emptyset, S', \pskip)$ holds. As a consequence, from the definition of $\mathsf{trace}$ and $\mathsf{tgen}$ we can state there is a trace $\tau \in [\mathsf{Act} \times \mathds{N}]$ of length $n + 1$ such that:
\begin{gather}
	\label{thm:atom1}
	\tau = \pred{trace}{h, \emptyset, S, \mathds{P}_1 \| \mathds{P}_2} \land \pred{tgen}{\tau, h, h', \emptyset, S, \mathds{P}_1 \| \mathds{P}_2}
\end{gather}
By repeatedly applying Lemma \ref{lem:lockAbsent} until convergence, we obtain a trace $\tau_c \in [\mathsf{Act} \times \mathds{N}]$ such that $\tau_c$ does not contain spurious lock and unlock operations, i.e. $\pred{clean}{\tau_c}$ holds, and for which the following is true, from (\ref{thm:atom1}).
\begin{gather}
	\label{thm:atom2} \pred{tgen}{\tau_c, h, h', \emptyset, S, \mathds{P}_1 \| \mathds{P}_2}
\end{gather}

From Theorem \ref{thm:totOrder} we are always able to build the strict total order $\sqsubset$ on the set of transactions $N$ that appear in $\tau_c$, for which $(N, E) = \pred{SG}{\tau}$.

From the definition of strict total order, we know we can find the minimal (or first) element $\iota$ of $\sqsubset$ such that:
\begin{gather}
	\label{thm:atom3} \forall j \in N \ldotp \iota \neq j \implies \iota \sqsubset j
\end{gather}
At this point we repeatedly apply Lemma \ref{lem:rr}, Lemma \ref{lem:rwlu}, Lemma \ref{lem:aa}, Lemma \ref{lem:ax} until convergence in order to swap and move to the left all operations performed by transaction $\iota$ inside $\tau_c$. Once no more swap is possible, i.e. no aforementioned lemmata can be applied, we obtain a trace $\tau_{seq}$ for which, from (\ref{thm:atom2}) and the fact that $\tau_c$ is clean, we state the following:
\begin{gather}
	\label{thm:atom4} \pred{tgen}{\tau_{seq}, h, h', \emptyset, S, \mathds{P}_1 \| \mathds{P}_2} \\
		\land\
	\label{thm:atom7} \pred{clean}{\tau_{seq}}
\end{gather}
We now claim that all of $\iota$'s operations appear in $\tau_{seq}$ before the actions performed by any other transaction $j$ in $N$, formally:
\begin{gather}
	\label{thm:atom6}
	\begin{array}{c}
		\forall x, y, n, n', j \ldotp
	x = (\alpha(\iota), n) \land y = (\alpha(j), n') \land \iota \neq j \land x \in \tau_{seq} \land y \in \tau_{seq} \\
	\implies \tau_{seq} \vDash x < y
	\end{array}
\end{gather}
We justify the statement in (\ref{thm:atom6}) by looking at one particular consecutive sequence (that follows from (\ref{thm:atom4}) and the definition of $\mathsf{tgen}$) of labelled reductions as part of $\tau_{seq}$, for $\alpha' = \alpha(\iota)$ being the first action performed by $\iota$ in $\tau$ such that $\tau \not\vDash \alpha(\iota) < \alpha'$.
\begin{gather*}
	(h, \emptyset, S, \mathds{P}_1 \| \mathds{P}_2)
		\rightarrow^*
	(h_a, \Phi_a, S_a, \mathds{P}_a)
		\xrightarrow{\alpha}
	(h_b, \Phi_b, S_b, \mathds{P}_b)
		\xrightarrow{\alpha'}
	(h_c, \Phi_c, S_c, \mathds{P}_c)
		\rightarrow^*
	(h', \emptyset, S', \pskip)
\end{gather*}
Let's assume $\alpha = \alpha(j)$ for $j \in \mathsf{Tid}$. In the case where $\iota = j$, (\ref{thm:atom6}) holds trivially given that the implication condition is false; let's instead focus on the case where $\iota \neq j$ and establish that such situation cannot occur. More specifically, we analyse the cases not covered by the lemmata that allow swapping of actions: we therefore start by considering $\alpha = \alpha(j, k)$ and $\alpha' = \alpha(\iota, k)$ for a key $k \in \mathsf{Key}$.
\begin{enumerate}[label=({\roman*})]
	\item \label{thm:atom8} If at least one of $\alpha$ and $\alpha'$ is a $\mathsf{write}$ operation on $k$ and the other is a $\mathsf{read}$ or $\mathsf{write}$ also on $k$, then from the definition of $\mathsf{conflict}$ it follows that the two must be conflicting. From the definition of $\mathsf{SG(\tau_{seq})}$ and the fact that the strict total order $\sqsubset$ keeps the serialization graph's edges, it must be the case that $j \sqsubset \iota$ which is not possible due to the fact that $\iota$ is the minimal element of the $\sqsubset$ relation from (\ref{thm:atom3}).
	
	\item If $\alpha = \actlock{j}{k}{\kappa}$ and $\alpha' = \actlock{\iota}{k}{\kappa'}$ for some $\kappa \in \mathsf{Lock}$ and $\kappa' = \textsc{x}$, then there is no possible way that $\alpha'$ reduced succesfully from $(h_b, \Phi_b, S_b, \mathds{P}_b)$, since the exclusive mode acquisition requires the set of $k$'s owners, i.e. $I$ in $(I, \textsc{u}) = \Phi_b(k)$, to be empty or to only contain $\iota$ but the action $\alpha$ succesfully reduced, making $\Phi_b = \Phi_a[k \mapsto (I, \kappa)]$ with $j \in I$ and $\iota \neq j$ by assumption.
	
	\item If $\alpha = \actunlock{j}{k}$ and $\alpha' = \actunlock{\iota}{k}$ and $(\{j\}, \textsc{x}) = \Phi_a(k)$, then there is no way action $\alpha'$ could have reduced from $(h_b, \Phi_b, S_b, \mathds{P}_b)$ since from the semantic interpretation of $\mathsf{unlock}$ we obtain $\Phi_b = \Phi_a[k \mapsto (\emptyset, \textsc{u})]$.
	
	\item If $\alpha = \actlock{j}{k}{\kappa}$ and $\alpha' = \actunlock{\iota}{k}$ for $\kappa = \textsc{x}$, then there is no possible way for action $\alpha'$ to succesfully reduce from $(h_b, \Phi_b, S_b, \mathds{P}_b)$, since $j$ acquires the lock on $\kappa$ through $\alpha$ before $\iota$ unlocks it making $(\{j\}, \textsc{x}) = \Phi_b(k)$ and $\iota \neq j$ by assumption.
	
	\item If $\alpha = \actunlock{j}{k}$ and $\alpha' = \actlock{\iota}{k}{\kappa}$ for $\kappa = \textsc{x}$, then from (\ref{thm:atom7}) we know that $\tau_{seq}$ does not contain any spurious locks which implies that $\iota$ is obtaining the exclusive lock on $k$ in order to later write to it. Given that $j$ is releasing a lock on $k$, it means that it either read or wrote to it beforehand (since again $\pred{clean}{\tau_{seq}}$ holds from (\ref{thm:atom7})). This situation is impossible as it leads us back to case \ref{thm:atom8} since there is a conflict between $j$ and $\iota$ on item $k$ which must be accounted for by $\pred{SG}{\tau_{seq}}$.
	
	\item If $\alpha = \actlock{j}{k}{\kappa}$ and $\alpha' = \alpha(\iota, k)$ and $\kappa = \textsc{x}$ then in no way $\alpha'$ could have reduced with $\Phi_b = \Phi_a[k \mapsto (\{j\}, \textsc{x})]$ and $\iota \neq j$. In the case where $\kappa = \textsc{s}$ and $\alpha'$ is a $\mathsf{write}$ we have a similar problem, as $\Phi_b = \Phi_a[k \mapsto (\{j\} \uplus I, \textsc{s})]$ for an $I \in \mathcal{P}(\mathsf{Tid})$.
	
	\item If $\alpha = \actunlock{j}{k}$ and $\alpha' = \alpha(\iota, k)$ and $\alpha'$ is a $\mathsf{write}$, then from (\ref{thm:atom7}) we know that there must be a read or write operation $\alpha_c$ performed by transaction $j$ before $\alpha$. It follows that $\alpha_c$ is conflicting with $\alpha'$ and this leads back to case \ref{thm:atom8}.
	
	\item If $\alpha = \alpha(j, k)$ and $\alpha' = \actlock{\iota}{k}{\kappa}$ and ($\kappa = \textsc{x}$ or $\kappa = \textsc{s}$ and $\alpha$ is a $\mathsf{write}$ action), then from (\ref{thm:atom7}) there must be an action $\alpha_c$ done by transaction $\iota$ happening after $\alpha'$ which is conflicting with $\alpha$. This scenario leads back to \ref{thm:atom8}.
	
	\item If $\alpha = \alpha(j, k)$ and $\alpha' = \actunlock{\iota}{k}$ and $\alpha$ is a $\mathsf{write}$ action then it must be the case that $(\emptyset, \textsc{u}) = \Phi_b(k)$ and $\alpha'$ could have never succesfully reduced from $(h_b, \Phi_b, S_b, \mathds{P}_b)$.
\end{enumerate}

The last cases to be considered, are the ones involving $\mathsf{alloc}$ actions together with read, write, lock and unlock operations performed on keys in the range of the ones allocated. Let $\alpha = \actalloc{j}{n}{l}$ what follows.
\begin{enumerate}[label=({\roman*})]
	\setcounter{enumi}{9}
	\item \label{thm:atom9} If $\alpha' \in \{ \actread{\iota}{k}{v}, \actwrite{\iota}{k}{v} \}$ and $l \leq k < l + n$ then from the definition of $\mathsf{conflict}$ we have that $\alpha$ and $\alpha'$ are conflicting. From the definition of $\mathsf{SG(\tau_{seq})}$ and the fact that the strict total order $\sqsubset$ keeps the serialization graph's edges, it must be the case that $j \sqsubset \iota$ which is not possible due to the fact that $\iota$ is the minimal element of the $\sqsubset$ relation from (\ref{thm:atom3}).
	
	\item If $\alpha' = \actunlock{j}{k}$ and $l \leq k < l + n$ then from (\ref{thm:atom7}) we know there must be a \textsf{read} or \textsf{write} action performed by $\iota$ on $k$ before $\alpha'$. This leads back to case \ref{thm:atom9}.
	
	\item If $\alpha' = \actlock{\iota}{k}{\kappa}$ and $l \leq k < l + n$ then there is no possible wat for $\alpha'$ to reduce from $(h_b, \Phi_b, S_b, \mathds{P}_b)$ since $(\{j\}, \kappa_l) = \Phi_b(k)$ for $\kappa_l = \textsc{x}$ while from the semantic interpretation of $\mathsf{alloc}$, $\alpha'$ requires $\kappa_l$ to be either $\textsc{u}$ or $\textsc{s}$.
\end{enumerate}

We have now established (\ref{thm:atom6}), i.e. that the minimal transaction $\iota$'s operations appear in $\tau_{seq}$ before the ones of any other transaction. Let's now analyse the structure of the reduction described by $\tau_{seq}$, for some fresh $\alpha \in \mathsf{Act}$.
\[
	(h, \emptyset, S, \mathds{P}_1 \| \mathds{P}_2) \xrightarrow{\alpha}
	\underbrace{(h'', \Phi'', S'', \mathds{P}'') \rightarrow^* (h', \emptyset, S', \pskip)}_{n \text{ steps}}
\]
\begin{itemize}
	\item If $\alpha = \actprog$ then by Lemma \ref{lem:sameSys} we obtain that $(h, \mathds{P}_1 \| \mathds{P}_2) \tred (h'', \mathds{P}'')$ and the final result follows by I.H.
	
	\item If $\alpha \neq \actprog$ then from (\ref{thm:atom6}) we know that the action was performed by transaction $\iota$, the minimal one according to $\sqsubset$. Without loss of generality, we can assume that the program $\mathds{P}_1 \| \mathds{P}_2$ is of the following shape:
	\begin{gather}
		\left( \mathds{T}_\iota ; \mathds{P}_1' \right) \| \mathds{P}_2
	\end{gather}
	From the assumption that $\alpha \neq \actprog$ and Lemma \ref{lem:sysSwap} we know that all of labels generated from the reduction $\iota$ will appear before any system transition. This means that under $\tau_{seq}$ we are able to reduce the initial state and program as follows, for some $m < n + 1$:
	\begin{gather}
		\label{thm:atom10}
		(h, \emptyset, S, \left( \mathds{T}_\iota ; \mathds{P}_1' \right) \| \mathds{P}_2) \rightarrow^{m} (h_{fin}, \Phi_{fin}, S_{fin}, \left( \pskip ; \mathds{P}_1' \right) \| \mathds{P}_2)
	\end{gather}
	From (\ref{thm:atom10}), \textit{Base case 2} of this proof and the fact that by rule \textsc{AtTrans} a transaction can always run without conditions on the global storage (i.e. empty premiss), we obtain that:
	\begin{gather}
		\label{thm:atom11}
		(h, \left( \mathds{T}_\iota ; \mathds{P}_1' \right) \| \mathds{P}_2) \tred (h_{fin}, \left( \pskip ; \mathds{P}_1' \right) \| \mathds{P}_2)
	\end{gather}
	From (\ref{thm:atom10}), (\ref{thm:atom11}) and I.H given that we have reduced the starting program for $m$ steps, we know that:
	\begin{gather}
		(h_{fin}, \Phi_{fin}, S_{fin}, \left( \pskip ; \mathds{P}_1' \right) \| \mathds{P}_2) \rightarrow^* (h', \emptyset, S', \pskip) \\
		\implies (h_{fin}, \left( \pskip ; \mathds{P}_1' \right) \| \mathds{P}_2) \tred^* (h', \pskip)
	\end{gather}
	which concludes our proof.
\end{itemize}
\end{proof}
}
\end{thm}

\begin{lem}
	\label{lem:sysSwap}
	Any system action label followed by a transaction label, $\alpha(\iota)$, can be swapped as long as $\alpha$ does not come from $\iota$'s first reduction.
	\begin{gather}
		\forall h, \underline{h}, \Phi, S, \mathds{P}, x, y, n, \tau, \tau', \alpha, \iota \ldotp \\
		\pred{tgen}{\tau, h, \underline{h}, \Phi, S, \mathds{P}} \land \alpha = \alpha(\iota) \land x = (\actprog, n) \land y = (\alpha, n + 1) \land x \in \tau \land y \in \tau \land \\
		\tau \vDash \alpha(\iota) < x \land \tau' = \tau \setminus \{ x, y \} \cup \{ (\alpha, n), (\actprog, n+1) \} \\
		\implies
		\pred{tgen}{\tau', h, \underline{h}, \Phi, S, \mathds{P}}
	\end{gather}
	
	\begin{proof}
	Let's pick arbitrary $h, \underline{h} \in \mathsf{Storage}, \Phi \in \mathsf{LMan}, S \in \mathsf{TState}, \mathds{P} \in \mathsf{Prog}, x, y \in \mathsf{Act} \times \mathds{N}, n \in \mathds{N}, \tau, \tau' \in [\mathsf{Act} \times \mathds{P}], \iota \in \mathsf{Tid}$ and assume that the following holds:
	\begin{gather}
		\pred{tgen}{\tau, h, \underline{h}, \Phi, S, \mathds{P}} \land \alpha = \alpha(\iota) \land x = (\actprog, n) \land y = (\alpha, n + 1) \land x \in \tau \land y \in \tau \land \\
		\tau \vDash \alpha(\iota) < x \land \tau' = \tau \setminus \{ x, y \} \cup \{ (\alpha, n), (\actprog, n+1) \}
	\end{gather}
	The above means that $\tau$ generates $\underline{h}$ starting from $h, \Phi, S, \mathds{P}$ and as part of its operations, it contains a system transition, $x = (\actprog, n)$, immediately followed by an operation, $y = (\alpha, n+1)$, performed by transaction $\iota$. Also, $\alpha$ is not the first reduction of $\mathds{T}_\iota$ since by assumption there exists another action $\alpha(\iota)$ which happens before $x$ in $\tau$, i.e. $\tau \vDash \alpha(\iota) < x$ holds. We now assume another transaction, $\tau'$, which is equivalent to $\tau$ with $x$ and $y$ swapped. We are now required to show that $\pred{tgen}{\tau', h, \underline{h}, \Phi, S, \mathds{P}}$ holds.
	
	From the definition $\mathsf{tgen}$ and the semantic interpretation of $\actprog$ we know that the following must hold:
	\begin{gather}
		\label{lem:sysSwap1}
		\begin{array}{c}
			(h, \Phi, S, \mathds{P}) \rightarrow^* (h_1, \Phi_1, S_1, \mathds{P}_1) \xrightarrow{\actprog} (h_1, \Phi_1, S_1, \mathds{P}_1') \xrightarrow{\alpha} (h_2, \Phi_2, S_2, \mathds{P}_2) \\ \rightarrow^* (\underline{h}, \emptyset, S', \pskip)
		\end{array}
	\end{gather}
	Given that from our assumption, $\alpha$ is not $\iota$'s starting action then from (\ref{lem:sysSwap1}) without loss of generality we can assume that $\mathds{P}_1$ is of the following shape:
	\begin{gather}
		\label{lem:sysSwap2}
		\left( \mathds{T}_\iota ; \mathds{P}_a \right) \|\ \mathds{P}_b
	\end{gather}
	From (\ref{lem:sysSwap1}) and (\ref{lem:sysSwap2}) we know that we can always find a program $\mathds{P}_1''$ such that:
	\begin{gather}
		\label{lem:sysSwap3}
		\begin{array}{c}
			(h, \Phi, S, \mathds{P}) \rightarrow^* (h_1, \Phi_1, S_1, \mathds{P}_1) \xrightarrow{\alpha} (h_2, \Phi_2, S_2, \mathds{P}_1'') \xrightarrow{\actprog} (h_2, \Phi_2, S_2, \mathds{P}_2) \\ \rightarrow^* (\underline{h}, \emptyset, S', \pskip)
		\end{array}
	\end{gather}
	From (\ref{lem:sysSwap3}) and the definition of $\mathsf{tgen}$ we can conclude that $\pred{tgen}{h, \underline{h}, \Phi, S, \mathds{P}}$ holds.
	\end{proof}
\end{lem}