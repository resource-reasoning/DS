\subsubsection{Proof}

\[
\begin{array}{r l}
	\pred{atom}{\mathds{P}} \triangleq&
	\begin{array}{l}
	\forall h, h', S, S', \Phi \ldotp \\
	(h, \Phi, S, \mathds{P}) \rightarrow^* (h', \emptyset, S', \pskip) \implies 
	(h, \mathds{P}) \tred^* (h', \pskip)
	\end{array}
\end{array}
\]

{\parindent0pt
\begin{proof}
$\forall \mathds{P} \in \mathsf{Prog} \ldotp \pred{atom}{\mathds{P}}$ by induction on the structure of programs $\mathsf{Prog}$. \\

\textit{Base case 1}: $\pskip \in \mathsf{Prog}$

\textit{To show}: $\pred{atom}{\pskip}$

For arbitrary $h, h', S, S', \Phi$ we assume that $(h, \Phi, S, \pskip) \rightarrow^* (h', \emptyset, S', \pskip)$ holds, and given that $\pskip$ has no possible one-step reductions, it must be the case that it is a zero-step reduction. Therefore we have $h = h', \Phi = \emptyset, S = S'$. Starting from $(h, \pskip)$ through the $\tred$ relation, we can always reach $(h, \pskip)$ via a zero-step reduction $(h, \pskip) \tred^0 (h, \pskip)$. We can conclude that $(h, \Phi, S, \pskip) \rightarrow^* (h', \emptyset, S', \pskip) \implies (h, \pskip) \tred^* (h', \pskip)$ where $h = h'$. \\

\textit{Base case 2}: $\mathds{T} \in \mathsf{Prog}$

\textit{To show}: $\pred{atom}{\mathds{T}}$ by induction on the structure of transactions $\mathsf{Trans}$. This leaves us to prove that $\pred{atom}{\mathtt{begin}\ \mathds{C}\ \mathtt{end}_\iota}$ holds, given that $\mathtt{begin}\ \mathds{C}\ \mathtt{end} \in \mathsf{UTrans}$ will always be reduced to the previous case by the \textsc{Start} rule in the \textsc{2pl} semantics and by \textsc{AtStart} in the \textsc{Atom} one.

For arbitrary $h, h', S, S', \Phi$ we assume that $(h, \Phi, S, \ptdef{\mathds{C}}_\iota) \rightarrow^* (h', \emptyset, S', \pskip)$ holds. Given the overall reduction from $\ptdef{\mathds{C}}_\iota$ to $\pskip$ it must be the case that the following holds.
\[
(h, \Phi, S, \ptdef{\mathds{C}}_\iota) \rightarrow^* (h', \emptyset, S', \ptdef{\pskip}_\iota) \xrightarrow{\actprog} (h', \emptyset, S', \pskip)
\]
Which implies that $\mathds{C}$ reduces to $\pskip$ through the repeated use of the \textsc{Exec} rule. From the transitive closure of the $\rightarrow$ relation and Lemma \ref{lem:catom} we obtain the result that $(h, \ptdef{\mathds{C}}) \tred^* (h', \pskip)$. \\

\textit{Inductive case 1}: $\mathds{P}_1 + \mathds{P}_2 \in \mathsf{Prog}$

\textit{To show}: $\pred{atom}{\mathds{P}_1 + \mathds{P}_2}$

\textit{Inductive hypothesis}: $\pred{atom}{\mathds{P}_1} \land \pred{atom}{\mathds{P}_2}.$

For arbitrary $h, h', S, S', \Phi$ we assume that $(h, \Phi, S, \mathds{P}_1 + \mathds{P}_2) \rightarrow^* (h', \emptyset, S', \pskip)$ holds. Now we are presented with two cases:
\begin{enumerate}
\item We can reduce $(h, \Phi, S, \mathds{P}_1 + \mathds{P}_2) \xrightarrow{\actprog} (h, \Phi, S, \mathds{P}_1)$ with one step through the rule \textsc{ChoiceL}, which we can always apply since it has an empty premiss. We can also always reduce $(h, \mathds{P}_1 + \mathds{P}_2) \tred (h, \mathds{P}_1)$ through the rule \textsc{AtChoiceL} given it has an empty premiss. By inductive hypothesis on $\mathds{P}_1$ we obtain that $(h, \Phi, S, \mathds{P}_1) \rightarrow^* (h', \emptyset, S', \pskip) \implies (h, \mathds{P}_1) \tred^* (h', \pskip)$. Therefore we can conclude that $(h, \Phi, S, \mathds{P}_1 + \mathds{P}_2) \rightarrow^* (h', \emptyset, S', \pskip) \implies  (h, \mathds{P}_1 + \mathds{P}_2) \tred^* (h', \pskip)$.
\item We can reduce $(h, \Phi, S, \mathds{P}_1 + \mathds{P}_2) \xrightarrow{\actprog} (h, \Phi, S, \mathds{P}_2)$ with one step through the rule \textsc{ChoiceR}, which we can always apply since it has an empty premiss. We can also always reduce $(h, \mathds{P}_1 + \mathds{P}_2) \tred (h, \mathds{P}_2)$ through the rule \textsc{AtChoiceR} given it has an empty premiss. By inductive hypothesis on $\mathds{P}_2$ we obtain that $(h, \Phi, S, \mathds{P}_2) \rightarrow^* (h', \emptyset, S', \pskip) \implies (h, \mathds{P}_2) \tred^* (h', \pskip)$. Therefore we can conclude that $(h, \Phi, S, \mathds{P}_1 + \mathds{P}_2) \rightarrow^* (h', \emptyset, S', \pskip) \implies  (h, \mathds{P}_1 + \mathds{P}_2) \tred^* (h', \pskip)$. \\
\end{enumerate}

\textit{Inductive case 2}: $\mathds{P}_1 ; \mathds{P}_2 \in \mathsf{Prog}$

\textit{To show}: $\pred{atom}{\mathds{P}_1 ; \mathds{P}_2}$

\textit{Inductive hypothesis}: $\pred{atom}{\mathds{P}_1} \land \pred{atom}{\mathds{P}_2}$

For arbitrary $h, h', S, S', \Phi$ we assume that $(h, \Phi, S, \mathds{P}_1 ; \mathds{P}_2) \rightarrow^* (h', \emptyset, S', \pskip)$ holds. Given the overall reduction from $\mathds{P}_1 ; \mathds{P}_2$ to $\pskip$ we must have a chain of reductions of the following shape, for some $h'', \Phi'', S''$ where $\Phi'' = \emptyset$ by Lemma \ref{ref:phiemp}.
\[
\underbrace{(h, \Phi, S, \mathds{P}_1 ; \mathds{P}_2) \rightarrow^* (h'', \Phi'', S'', \pskip; \mathds{P}_2)}_{(\textsc{i})}
\rightarrow (h'', \Phi'', S'', \mathds{P}_2) \rightarrow^* (h', \emptyset, S', \pskip)
\]
\begin{enumerate}
\item \label{seq:1} By (\textsc{i}) and Lemma \ref{ref:2seq} we get that $(h, \Phi, S, \mathds{P}_1) \rightarrow^* (h'', \Phi'', S'', \pskip)$ holds.
\item \label{seq:2} By \ref{seq:1} and the inductive hypothesis on $\mathds{P}_1$ we obtain that $(h, \mathds{P}_1) \tred^* (h'', \pskip)$.
\item By \ref{seq:2} and Lemma \ref{ref:aseq} we get that $(h, \mathds{P}_1 ; \mathds{P}_2) \tred^* (h'', \pskip ; \mathds{P}_2)$
\end{enumerate}

At this point we can apply the \textsc{PSeqSkip} rule to reduce $(h'', \Phi'', S'', \pskip ; \mathds{P}_2) \rightarrow^* (h'', \Phi'', S'', \mathds{P}_2)$ and rule \textsc{AtPSeqSkip} to reduce $(h'', \pskip ; \mathds{P}_2) \tred^* (h'', \mathds{P}_2)$. By inductive hypothesis on $\mathds{P}_2$ we can conclude that $(h, \Phi, S, \mathds{P}_1 ; \mathds{P}_2) \rightarrow^* (h', \emptyset, S', \pskip) \implies (h, \mathds{P}_1 ; \mathds{P}_2) \tred^* (h', \pskip)$. \\

\textit{Inductive case 3}: $\mathds{P}^* \in \mathsf{Prog}$

\textit{To show}: $\pred{atom}{\mathds{P}^*}$

\textit{Inductive hypothesis}: $\pred{atom}{\mathds{P}}$

For arbitrary $h, h', S, S', \Phi$ we assume that $(h, \Phi, S, \mathds{P}^*) \rightarrow^* (h', \emptyset, S', \pskip)$ holds (\textsc{i}). Given the overall reduction from $\mathds{P}^*$ to $\pskip$ we must have a chain of reductions of the following shape, for some $h'', \Phi'', S''$.
\[
(h, \Phi, S, \mathds{P}^*) \rightarrow^* (h'', \Phi'', S'', \pskip + (\mathds{P} ; \mathds{P}^*)) \rightarrow^*  (h', \emptyset, S', \pskip + (\mathds{P} ; \mathds{P}^*)) \xrightarrow{\actprog} (h', \emptyset, S', \pskip)
\]
Through the \textsc{Loop} rule (\textsc{ii}), we can always reduce $(h, \Phi, S, \mathds{P}^*) \xrightarrow{\actprog} (h, \Phi, S, \pskip + (\mathds{P} ; \mathds{P}^*))$ given that it has an empty premiss. Similarly, we can always reduce any $(h'', \mathds{P}^*) \tred (h'', \pskip + (\mathds{P} ; \mathds{P}^*))$ via the \textsc{AtLoop} rule as it also has an empty premiss. We now consider two possible cases:
\begin{enumerate}
\item \label{loop:1} We reduce $(h, \Phi, S, \pskip + (\mathds{P} ; \mathds{P}^*)) \xrightarrow{\actprog} (h, \Phi, S, \pskip)$ through the \textsc{ChoiceL} rule which we can always do, together with \textsc{AtChoiceL} that reduces $(h, \pskip + (\mathds{P} ; \mathds{P}^*)) \tred (h, \pskip)$ where $\Phi = \emptyset$ by Lemma \ref{ref:phiemp}. In this scenario we directly obtain the result.
\item We reduce $(h, \Phi, S, \pskip + (\mathds{P} ; \mathds{P}^*)) \xrightarrow{\actprog} (h, \Phi, S, \mathds{P} ; \mathds{P}^*)$ through the \textsc{ChoiceL} rule which we can always do, together with \textsc{AtChoiceL} that reduces $(h, \pskip + (\mathds{P} ; \mathds{P}^*)) \tred (h, \mathds{P} ; \mathds{P}^*)$. By Lemma \ref{ref:2seq}, Lemma \ref{ref:aseq} and the inductive hypothesis on $\mathds{P}$ we get that $(h, \Phi, S, \mathds{P} ; \mathds{P}^*) \rightarrow^* (h'', \Phi'', S'', \pskip ; \mathds{P}^*) \implies (h, \mathds{P} ; \mathds{P}^*) \tred^* (h'', \pskip ; \mathds{P}^*)$. It is now possible to further reduce $(h'', \Phi'', S'', \pskip ; \mathds{P}^*) \xrightarrow{\actprog} (h'', \Phi'', S'', \mathds{P}^*)$ via \textsc{PSeqSkip} and $(h'', \pskip ; \mathds{P}^*) \tred (h'', \mathds{P}^*)$ through \textsc{AtPSeqSkip}. We are now in the position to repeat the process from point (\textsc{ii}) until case \ref{loop:1} is encountered at which point we have a reduction to $\pskip$. This will eventually happen given our initial assumption (\textsc{i}). \\
\end{enumerate}

\textit{Inductive case 4}: $\mathds{P}_1 \| \mathds{P}_2 \in \mathsf{Prog}$

\textit{To show}: $\pred{atom}{\mathds{P}_1 \| \mathds{P}_2}$

%\textit{Inductive hypothesis}: $\pred{atom}{\mathds{P}_1} \land \pred{atom}{\mathds{P}_2}$

We will prove the parallel composition case by mathematical induction on the number of reduction steps $n$.

\textit{Base case}: $n = 0$

\textit{To show}:
\begin{gather*}
	\forall h, h', \Phi, S, S', \mathds{P}_1, \mathds{P}_2 \ldotp \\
	(h, \Phi, S, \mathds{P}_1 \| \mathds{P}_2) \rightarrow^0 (h', \emptyset, S', \pskip)
	\implies
	(h, \mathds{P}_1 \| \mathds{P}_2) \tred^* (h', \pskip)
\end{gather*}

For arbitrary $h, h', S, S', \Phi$ we assume that $(h, \Phi, S, \mathds{P}_1 \| \mathds{P}_2) \rightarrow^0 (h', \emptyset, S', \pskip)$ holds. Since a zero-step reduction happened, it must be the case that $\mathds{P}_1 = \mathds{P}_2 = \pskip$, $h' = h$ and $\pskip \| \pskip$ reduced to $\pskip$ through the \textsc{ParEnd} rule. Now, we immediately obtain that $(h, \pskip \| \pskip) \tred (h, \pskip)$ from rule \textsc{AtParEnd}. \\

\textit{Inductive case 4.1}: $n > 0$

\textit{Inductive hypothesis}:
\begin{gather*}
	\forall m \leq n, h, h', \Phi, S, S', \mathds{P}_1, \mathds{P}_2 \ldotp \\
	(h, \Phi, S, \mathds{P}_1 \| \mathds{P}_2) \rightarrow^m (h', \emptyset, S', \pskip)
	\implies
	(h, \mathds{P}_1 \| \mathds{P}_2) \tred^* (h', \pskip)
\end{gather*}

\textit{To show}:
\begin{gather*}
	\forall h, h', \Phi, S, S', \mathds{P}_1, \mathds{P}_2 \ldotp \\
	(h, \Phi, S, \mathds{P}_1 \| \mathds{P}_2) \rightarrow^{n+1} (h', \emptyset, S', \pskip)
	\implies
	(h, \mathds{P}_1 \| \mathds{P}_2) \tred^* (h', \pskip)
\end{gather*}

\newpage 
For arbitrary $h, h', S, S', \Phi$ we assume that $(h, \Phi, S, \mathds{P}_1 \| \mathds{P}_2) \rightarrow^{n+1} (h', \emptyset, S', \pskip)$ holds. As a consequence, from the definition of $\mathsf{trace}$ and $\mathsf{tgen}$ we can state there is a trace $\tau \in [\mathsf{Act} \times \mathds{N}]$ of length $n + 1$ such that:
\begin{gather}
	\label{thm:atom1}
	\tau = \pred{trace}{h, \Phi, S, \mathds{P}_1 \| \mathds{P}_2} \land \pred{tgen}{\tau, h, h', \Phi, S, \mathds{P}_1 \| \mathds{P}_2}
\end{gather}
By repeatedly applying Lemma \ref{lem:lockAbsent} until convergence, we obtain a trace $\tau_c \in [\mathsf{Act} \times \mathds{N}]$ such that $\tau_c$ does not contain spurious lock and unlock operations, i.e. $\pred{clean}{\tau_c}$ holds, and for which the following is true, from (\ref{thm:atom1}).
\begin{gather}
	\label{thm:atom2} \pred{tgen}{\tau_c, h, h', \Phi, S, \mathds{P}_1 \| \mathds{P}_2}
\end{gather}

From Theorem \ref{thm:totOrder} we are always able to build the strict total order $\sqsubset$ on the set of transactions $N$ that appear in $\tau_c$, for which $(N, E) = \pred{SG}{\tau}$.

From the definition of strict total order, we know we can find the minimal (or first) element $\iota$ of $\sqsubset$ such that:
\begin{gather}
	\label{thm:atom3} \forall j \in N \ldotp \iota \neq j \implies \iota \sqsubset j
\end{gather}
At this point we repeatedly apply Lemma \ref{lem:rr}, Lemma \ref{lem:rwlu}, Lemma \ref{lem:aa}, Lemma \ref{lem:ax} until convergence in order to swap and move to the left all operations performed by transaction $\iota$ inside $\tau_c$. Once no more swap is possible, i.e. no aforementioned lemmata can be applied, we obtain a trace $\tau_{seq}$ for which, from (\ref{thm:atom2}) and the fact that $\tau_c$ is clean, we state the following:
\begin{gather}
	\label{thm:atom4} \pred{tgen}{\tau_{seq}, h, h', \Phi, S, \mathds{P}_1 \| \mathds{P}_2} \\
		\land\
	\label{thm:atom7} \pred{clean}{\tau_{seq}}
\end{gather}
We now claim that all of $\iota$'s operations appear in $\tau_{seq}$ before the actions performed by any other transaction $j$ in $N$, formally:
\begin{gather}
	\label{thm:atom6}
	\begin{array}{c}
		\forall x, y, n, n', j \ldotp
	x = (\alpha(\iota), n) \land y = (\alpha(j), n') \land \iota \neq j \land x \in \tau_{seq} \land y \in \tau_{seq} \\
	\implies \tau_{seq} \vDash x < y
	\end{array}
\end{gather}
We justify the statement in (\ref{thm:atom6}) by looking at one particular consecutive sequence (that follows from (\ref{thm:atom4}) and the definition of $\mathsf{tgen}$) of labelled reductions as part of $\tau_{seq}$, for $\alpha' = \alpha(\iota)$ being the first action performed by $\iota$ in $\tau$ such that $\tau \not\vDash \alpha(\iota) < \alpha'$.
\begin{gather*}
	(h, \Phi, S, \mathds{P}_1 \| \mathds{P}_2)
		\rightarrow^*
	(h_a, \Phi_a, S_a, \mathds{P}_a)
		\xrightarrow{\alpha}
	(h_b, \Phi_b, S_b, \mathds{P}_b)
		\xrightarrow{\alpha'}
	(h_c, \Phi_c, S_c, \mathds{P}_c)
		\rightarrow^*
	(h', \emptyset, S', \pskip)
\end{gather*}
Let's assume $\alpha = \alpha(j)$ for $j \in \mathsf{Tid}$. In the case where $\iota = j$, (\ref{thm:atom6}) holds trivially given that the implication condition is false; let's instead focus on the case where $\iota \neq j$ and establish that such situation cannot occur. More specifically, we analyse the cases not covered by the lemmata that allow swapping of actions: we therefore start by considering $\alpha = \alpha(j, k)$ and $\alpha' = \alpha(\iota, k)$ for a key $k \in \mathsf{Key}$.
\begin{enumerate}[label=({\roman*})]
	\item \label{thm:atom8} If at least one of $\alpha$ and $\alpha'$ is a $\mathsf{write}$ operation on $k$ and the other is a $\mathsf{read}$ or $\mathsf{write}$ also on $k$, then from the definition of $\mathsf{conflict}$ it follows that the two must be conflicting. From the definition of $\mathsf{SG(\tau_{seq})}$ and the fact that the strict total order $\sqsubset$ keeps the serialization graph's edges, it must be the case that $j \sqsubset \iota$ which is not possible due to the fact that $\iota$ is the minimal element of the $\sqsubset$ relation from (\ref{thm:atom3}).
	
	\item If $\alpha = \actlock{j}{k}{\kappa}$ and $\alpha' = \actlock{\iota}{k}{\kappa'}$ for some $\kappa \in \mathsf{Lock}$ and $\kappa' = \textsc{x}$, then there is no possible way that $\alpha'$ reduced succesfully from $(h_b, \Phi_b, S_b, \mathds{P}_b)$, since the exclusive mode acquisition requires the set of $k$'s owners, i.e. $I$ in $(I, \textsc{u}) = \Phi_b(k)$, to be empty or to only contain $\iota$ but the action $\alpha$ succesfully reduced, making $\Phi_b = \Phi_a[k \mapsto (I, \kappa)]$ with $j \in I$ and $\iota \neq j$ by assumption.
	
	\item If $\alpha = \actunlock{j}{k}$ and $\alpha' = \actunlock{\iota}{k}$ and $(\{j\}, \textsc{x}) = \Phi_a(k)$, then there is no way action $\alpha'$ could have reduced from $(h_b, \Phi_b, S_b, \mathds{P}_b)$ since from the semantic interpretation of $\mathsf{unlock}$ we obtain $\Phi_b = \Phi_a[k \mapsto (\emptyset, \textsc{u})]$.
	
	\item If $\alpha = \actlock{j}{k}{\kappa}$ and $\alpha' = \actunlock{\iota}{k}$ for $\kappa = \textsc{x}$, then there is no possible way for action $\alpha'$ to succesfully reduce from $(h_b, \Phi_b, S_b, \mathds{P}_b)$, since $j$ acquires the lock on $\kappa$ through $\alpha$ before $\iota$ unlocks it making $(\{j\}, \textsc{x}) = \Phi_b(k)$ and $\iota \neq j$ by assumption.
	
	\item If $\alpha = \actunlock{j}{k}$ and $\alpha' = \actlock{\iota}{k}{\kappa}$ for $\kappa = \textsc{x}$, then from (\ref{thm:atom7}) we know that $\tau_{seq}$ does not contain any spurious locks which implies that $\iota$ is obtaining the exclusive lock on $k$ in order to later write to it. Given that $j$ is releasing a lock on $k$, it means that it either read or wrote to it beforehand (since again $\pred{clean}{\tau_{seq}}$ holds from (\ref{thm:atom7})). This situation is impossible as it leads us back to case \ref{thm:atom8} since there is a conflict between $j$ and $\iota$ on item $k$ which must be accounted for by $\pred{SG}{\tau_{seq}}$.
	
	\item If $\alpha = \actlock{j}{k}{\kappa}$ and $\alpha' = \alpha(\iota, k)$ and $\kappa = \textsc{x}$ then in no way $\alpha'$ could have reduced with $\Phi_b = \Phi_a[k \mapsto (\{j\}, \textsc{x})]$ and $\iota \neq j$. In the case where $\kappa = \textsc{s}$ and $\alpha'$ is a $\mathsf{write}$ we have a similar problem, as $\Phi_b = \Phi_a[k \mapsto (\{j\} \uplus I, \textsc{s})]$ for an $I \in \mathcal{P}(\mathsf{Tid})$.
	
	\item If $\alpha = \actunlock{j}{k}$ and $\alpha' = \alpha(\iota, k)$ and $\alpha'$ is a $\mathsf{write}$, then from (\ref{thm:atom7}) we know that there must be a read or write operation $\alpha_c$ performed by transaction $j$ before $\alpha$. It follows that $\alpha_c$ is conflicting with $\alpha'$ and this leads back to case \ref{thm:atom8}.
	
	\item If $\alpha = \alpha(j, k)$ and $\alpha' = \actlock{\iota}{k}{\kappa}$ and ($\kappa = \textsc{x}$ or $\kappa = \textsc{s}$ and $\alpha$ is a $\mathsf{write}$ action), then from (\ref{thm:atom7}) there must be an action $\alpha_c$ done by transaction $\iota$ happening after $\alpha'$ which is conflicting with $\alpha$. This scenario leads back to \ref{thm:atom8}.
	
	\item If $\alpha = \alpha(j, k)$ and $\alpha' = \actunlock{\iota}{k}$ and $\alpha$ is a $\mathsf{write}$ action then it must be the case that $(\emptyset, \textsc{u}) = \Phi_b(k)$ and $\alpha'$ could have never succesfully reduced from $(h_b, \Phi_b, S_b, \mathds{P}_b)$.
\end{enumerate}

The last cases to be considered, are the ones involving $\mathsf{alloc}$ actions together with read, write, lock and unlock operations performed on keys in the range of the ones allocated. Let $\alpha = \actalloc{j}{n}{l}$ what follows.
\begin{enumerate}[label=({\roman*})]
	\setcounter{enumi}{9}
	\item \label{thm:atom9} If $\alpha' \in \{ \actread{\iota}{k}{v}, \actwrite{\iota}{k}{v} \}$ and $l \leq k < l + n$ then from the definition of $\mathsf{conflict}$ we have that $\alpha$ and $\alpha'$ are conflicting. From the definition of $\mathsf{SG(\tau_{seq})}$ and the fact that the strict total order $\sqsubset$ keeps the serialization graph's edges, it must be the case that $j \sqsubset \iota$ which is not possible due to the fact that $\iota$ is the minimal element of the $\sqsubset$ relation from (\ref{thm:atom3}).
	
	\item If $\alpha' = \actunlock{j}{k}$ and $l \leq k < l + n$ then from (\ref{thm:atom7}) we know there must be a \textsf{read} or \textsf{write} action performed by $\iota$ on $k$ before $\alpha'$. This leads back to case \ref{thm:atom9}.
	
	\item If $\alpha' = \actlock{\iota}{k}{\kappa}$ and $l \leq k < l + n$ then there is no possible wat for $\alpha'$ to reduce from $(h_b, \Phi_b, S_b, \mathds{P}_b)$ since $(\{j\}, \kappa_l) = \Phi_b(k)$ for $\kappa_l = \textsc{x}$ while from the semantic interpretation of $\mathsf{alloc}$, $\alpha'$ requires $\kappa_l$ to be either $\textsc{u}$ or $\textsc{s}$.
\end{enumerate}

We have now established (\ref{thm:atom6}), i.e. that the minimal transaction $\iota$'s operations appear in $\tau_{seq}$ before the ones of any other transaction. Let's now analyse the structure of the reduction described by $\tau_{seq}$, for some fresh $\alpha \in \mathsf{Act}$.
\[
	(h, \Phi, S, \mathds{P}_1 \| \mathds{P}_2) \xrightarrow{\alpha}
	\underbrace{(h'', \Phi'', S'', \mathds{P}'') \rightarrow^* (h', \emptyset, S', \pskip)}_{n \text{ steps}}
\]
\begin{itemize}
	\item If $\alpha = \actprog$ then by Lemma \ref{lem:sameSys} we obtain that $(h, \mathds{P}_1 \| \mathds{P}_2) \tred (h'', \Phi'', S'', \mathds{P}'')$ and the final result follows by I.H.
	
	\item If $\alpha \neq \actprog$ then from (\ref{thm:atom6}) we know that the action was performed by transaction $\iota$, the minimal one according to $\sqsubset$. Without loss of generality, we can assume that the program $\mathds{P}_1 \| \mathds{P}_2$ is of the following shape:
	\begin{gather}
		\left( \mathds{T}_\iota ; \mathds{P}_1' \right) \| \mathds{P}_2
	\end{gather}
	From the assumption that $\alpha \neq \actprog$ and Lemma \ref{lem:sysSwap} we know that all of labels generated from the reduction $\iota$ will appear before any system transaction. This means that under $\tau_{seq}$ we are able to reduce the initial state and program as follows, for some $n' \leq n$:
	\begin{gather}
		\label{thm:atom10}
		(h, \Phi, S, \left( \mathds{T}_\iota ; \mathds{P}_1' \right) \| \mathds{P}_2) \rightarrow^{n'} (h_{fin}, \Phi_{fin}, S_{fin}, \left( \pskip ; \mathds{P}_1' \right) \| \mathds{P}_2)
	\end{gather}
	From (\ref{thm:atom10}) and \textit{Base case 2} of this proof we obtain that:
	\begin{gather}
		\label{thm:atom11}
		(h, \left( \mathds{T}_\iota ; \mathds{P}_1' \right) \| \mathds{P}_2) \tred (h', \left( \pskip ; \mathds{P}_1' \right) \| \mathds{P}_2)
	\end{gather}
	From (\ref{thm:atom10}) and (\ref{thm:atom11}) and I.H we know that:
	\begin{gather}
		(h_{fin}, \Phi_{fin}, S_{fin}, \left( \pskip ; \mathds{P}_1' \right) \| \mathds{P}_2) \rightarrow^* (h', \emptyset, S', \pskip) \\
		\implies (h', \left( \pskip ; \mathds{P}_1' \right) \| \mathds{P}_2) \tred^* (h', \pskip)
	\end{gather}
	Which concludes our proof.
\end{itemize}

\newpage

we are left to cover the case where $\alpha$ is a system transition at the level of programs (e.g. a non-deterministic choice), meaning $\alpha = \actprog$. From Lemma \ref{lem:sameSys} we obtain that all such transitions which can be reduced in the \tpl\ semantics, can be replicated by the \textsc{Atom} ones. We therefore get that:
\[
	(h, \Phi, S, \mathds{P}_1 \| \mathds{P}_2) \rightarrow^* (h, \Phi, S, \mathds{P}_b)
		\implies
	(h, \mathds{P}_1 \| \mathds{P}_2) \tred^* (h, \mathds{P}_b)
\]
\end{proof}
}

\begin{lem}
	\label{lem:sysSwap}
	Any system action label followed by a transaction label, $\alpha(\iota)$, can be swapped as long as $\alpha$ does not come from $\iota$'s first reduction.
	\begin{gather}
		\forall h, \underline{h}, \Phi, S, \mathds{P}, x, y, n, \tau, \tau', \alpha, \iota \ldotp \\
		\pred{tgen}{\tau, h, \underline{h}, \Phi, S, \mathds{P}} \land \alpha = \alpha(\iota) \land x = (\actprog, n) \land y = (\alpha, n + 1) \land x \in \tau \land y \in \tau \land \\
		\tau \vDash \alpha(\iota) < x \land \tau' = \tau \setminus \{ x, y \} \cup \{ (\alpha, n), (\actprog, n+1) \} \\
		\implies
		\pred{tgen}{\tau', h, \underline{h}, \Phi, S, \mathds{P}}
	\end{gather}
	
	\begin{proof}
	Let's pick arbitrary $h, \underline{h} \in \mathsf{Storage}, \Phi \in \mathsf{LMan}, S \in \mathsf{TState}, \mathds{P} \in \mathsf{Prog}, x, y \in \mathsf{Act} \times \mathds{N}, n \in \mathds{N}, \tau, \tau' \in [\mathsf{Act} \times \mathds{P}], \iota \in \mathsf{Tid}$ and assume that the following holds:
	\begin{gather}
		\pred{tgen}{\tau, h, \underline{h}, \Phi, S, \mathds{P}} \land \alpha = \alpha(\iota) \land x = (\actprog, n) \land y = (\alpha, n + 1) \land x \in \tau \land y \in \tau \land \\
		\tau \vDash \alpha(\iota) < x \land \tau' = \tau \setminus \{ x, y \} \cup \{ (\alpha, n), (\actprog, n+1) \}
	\end{gather}
	The above means that $\tau$ generates $\underline{h}$ starting from $h, \Phi, S, \mathds{P}$ and as part of its operations, it contains a system transition, $x = (\actprog, n)$, immediately followed by an operation, $y = (\alpha, n+1)$, performed by transaction $\iota$. Also, $\alpha$ is not the first reduction of $\mathds{T}_\iota$ since by assumption there exists another action $\alpha(\iota)$ which happens before $x$ in $\tau$, i.e. $\tau \vDash \alpha(\iota) < x$ holds. We now assume another transaction, $\tau'$, which is equivalent to $\tau$ with $x$ and $y$ swapped. We are now required to show that $\pred{tgen}{\tau', h, \underline{h}, \Phi, S, \mathds{P}}$ holds.
	
	From the definition $\mathsf{tgen}$ and the semantic interpretation of $\actprog$ we know that the following must hold:
	\begin{gather}
		\label{lem:sysSwap1}
		\begin{array}{c}
			(h, \Phi, S, \mathds{P}) \rightarrow^* (h_1, \Phi_1, S_1, \mathds{P}_1) \xrightarrow{\actprog} (h_1, \Phi_1, S_1, \mathds{P}_1') \xrightarrow{\alpha} (h_2, \Phi_2, S_2, \mathds{P}_2) \\ \rightarrow^* (\underline{h}, \emptyset, S', \pskip)
		\end{array}
	\end{gather}
	Given that from our assumption, $\alpha$ is not $\iota$'s starting action then from (\ref{lem:sysSwap1}) without loss of generality we can assume that $\mathds{P}_1$ is of the following shape:
	\begin{gather}
		\label{lem:sysSwap2}
		\left( \mathds{T}_\iota ; \mathds{P}_a \right) \|\ \mathds{P}_b
	\end{gather}
	From (\ref{lem:sysSwap1}) and (\ref{lem:sysSwap2}) we know that we can always find a program $\mathds{P}_1''$ such that:
	\begin{gather}
		\label{lem:sysSwap3}
		\begin{array}{c}
			(h, \Phi, S, \mathds{P}) \rightarrow^* (h_1, \Phi_1, S_1, \mathds{P}_1) \xrightarrow{\alpha} (h_2, \Phi_2, S_2, \mathds{P}_1'') \xrightarrow{\actprog} (h_2, \Phi_2, S_2, \mathds{P}_2) \\ \rightarrow^* (\underline{h}, \emptyset, S', \pskip)
		\end{array}
	\end{gather}
	From (\ref{lem:sysSwap3}) and the definition of $\mathsf{tgen}$ we can conclude that $\pred{tgen}{h, \underline{h}, \Phi, S, \mathds{P}}$ holds.
	\end{proof}
\end{lem}

\subsection{Lemmas}

\lem \label{lem:catom}
\[
\begin{array}{r l}
	\pred{cAtom}{\mathds{C}} \triangleq&
	\begin{array}{l}
	\forall \iota, s, s', p, p', \Phi, h, h', \mathds{C}', \alpha \ldotp \\
	(s, p, \mathds{C}) \xrightarrow{\alpha}_\iota (s', p', \mathds{C}') \land h' \in \left( \llbracket \alpha \rrbracket(h, \Phi) \downarrow_1 \right) \\
	\implies
	(h, s, \mathds{C}) \tred (h', s', \mathds{C}')
	\end{array}
\end{array}
\]

{\parindent0pt
\begin{proof}
$\forall \mathds{C} \in \mathsf{Cmd} \ldotp \pred{cAtom}{\mathds{C}}$ by induction on the structure of commands $\mathsf{Cmd}$. \\

\textit{Base case 1}: $\pskip \in \mathsf{Cmd}$

\textit{To show}: $\pred{cAtom}{\pskip}$

For arbitrary $\iota, s, s', p, p', \Phi, h, h', \mathds{C}', \alpha$ we assume that $(s, p, \pskip) \xrightarrow{\alpha}_\iota (s', p', \mathds{C}') \land h' \in \left( \llbracket \alpha \rrbracket(h, \Phi) \downarrow_1 \right)$ holds. Given that $\pskip$ has no possible one-step reductions, it must be a zero-step reduction such that $s = s', \mathds{C}' = \pskip, \alpha = \actid{\iota}, h = h'$. Now, we can reduce $(h, s, \pskip) \tred (h', s', \pskip)$ through a zero step reduction, again where $s = s', h = h'$. \\

\textit{Base case 2}: $\passign{\pvar{x}}{\mathds{E}} \in \mathsf{Cmd}$

\textit{To show}: $\pred{cAtom}{\passign{\pvar{x}}{\mathds{E}}}$

For arbitrary $\iota, s, s', p, p', \Phi, h, h', \mathds{C}', \alpha$ we assume that $(s, p, \passign{\pvar{x}}{\mathds{E}}) \xrightarrow{\alpha}_\iota (s', p', \mathds{C}') \land h' \in \left( \llbracket \alpha \rrbracket(h, \Phi) \downarrow_1 \right)$ holds. The only way to reduce $\passign{\pvar{x}}{\mathds{E}}$ is through the \textsc{Assign} rule which makes $\alpha = \actid{\iota}, \mathds{C}' = \pskip, s' = s[\pvar{x} \mapsto v], p' = p, h' = h$ where $v = \llbracket \mathds{E} \rrbracket_s$. In a similar way we can reduce $(h, s, \passign{\pvar{x}}{\mathds{E}}) \tred (h, s[\pvar{x} \mapsto v], \pskip)$ through the \textsc{AtAssign} rule. \\

\textit{Base case 3}: $\pderef{\pvar{x}}{\mathds{E}} \in \mathsf{Cmd}$

\textit{To show}: $\pred{cAtom}{\pderef{\pvar{x}}{\mathds{E}}}$

For arbitrary $\iota, s, s', p, p', \Phi, h, h', \mathds{C}', \alpha$ we assume that $(s, p, \pderef{\pvar{x}}{\mathds{E}}) \xrightarrow{\alpha} (s', p', \mathds{C}') \land h' \in \left( \llbracket \alpha \rrbracket(h, \Phi) \downarrow_1 \right)$ holds. The only way to reduce $\pderef{\pvar{x}}{\mathds{E}}$ is through the \textsc{Read} rule which makes $\mathds{C}' = \pskip, h' = h, s' = s[\pvar{x} \mapsto v], \alpha = \actread{\iota}{k}{v}$ where $k = \llbracket \mathds{E} \rrbracket_s$ and $v = h(k)$. In a similar way we can reduce $(h, s, \pderef{\pvar{x}}{\mathds{E}}) \tred (h, s[\pvar{x} \mapsto v], \pskip)$ through the \textsc{AtRead} rule. \\

\textit{Base case 4}: $\palloc{\pvar{x}}{\mathds{E}} \in \mathsf{Cmd}$

\textit{To show}: $\pred{cAtom}{\palloc{\pvar{x}}{\mathds{E}}}$

For arbitrary $\iota, s, s', p, p', \Phi, h, h', \mathds{C}', \alpha$ we assume that $(s, p, \palloc{\pvar{x}}{\mathds{E}}) \xrightarrow{\alpha} (s', p', \mathds{C}') \land h' \in \left( \llbracket \alpha \rrbracket(h, \Phi) \downarrow_1 \right)$ holds. The only way to reduce $\palloc{\pvar{x}}{\mathds{E}}$ is through the \textsc{Alloc} rule which makes $\mathds{C}' = \pskip, h' = h[l \mapsto 0]\ldots[l + n - 1 \mapsto 0], s' = s[\pvar{x} \mapsto l], \alpha = \actalloc{\iota}{n}{l}$ where $n = \llbracket \mathds{E} \rrbracket_s$. In a similar way we can reduce $(h, s, \palloc{\pvar{x}}{\mathds{E}}) \tred (h[l \mapsto 0]\ldots[l + n - 1 \mapsto 0], s[\pvar{x} \mapsto l], \pskip)$ through the \textsc{AtAlloc} rule. \\

\textit{Base case 5}: $\pmutate{\mathds{E}_1}{\mathds{E}_2} \in \mathsf{Cmd}$

\textit{To show}: $\pred{cAtom}{\pmutate{\mathds{E}_1}{\mathds{E}_2}}$

For arbitrary $\iota, s, s', p, p', \Phi, h, h', \mathds{C}', \alpha$ we assume that $(s, p, \pmutate{\mathds{E}_1}{\mathds{E}_2}) \xrightarrow{\alpha} (s', p', \mathds{C}') \land h' \in \left( \llbracket \alpha \rrbracket(h, \Phi) \downarrow_1 \right)$ holds. The only way to reduce $\pmutate{\mathds{E}_1}{\mathds{E}_2}$ is through the \textsc{Write} rule which makes $\mathds{C}' = \pskip, h' = h[k \mapsto v], s' = s, \alpha = \actwrite{\iota}{k}{v}$ where $k = \llbracket \mathds{E}_1 \rrbracket_s, v = \llbracket \mathds{E}_2 \rrbracket_s$.  In a similar way we can reduce $(h, s, \pmutate{\mathds{E}_1}{\mathds{E}_2}) \tred (h[k \mapsto v], s, \pskip)$ through the \textsc{AtWrite} rule. \\

\textit{Inductive case 1}: $\mathds{C}_1 ; \mathds{C}_2 \in \mathsf{Cmd}$

\textit{Inductive hypothesis}: $\pred{cAtom}{\mathds{C}_1}$

\textit{To show}: $\pred{cAtom}{\mathds{C}_1 ; \mathds{C}_2}$

For arbitrary $\iota, s, s', p, p', \Phi, h, h', \mathds{C}', \alpha$ we assume that $(s, p, \mathds{C}_1 ; \mathds{C}_2) \xrightarrow{\alpha} (s', p', \mathds{C}') \land h' \in \left( \llbracket \alpha \rrbracket(h, \Phi) \downarrow_1 \right)$ holds. There are two possible ways to reduce $\mathds{C}_1 ; \mathds{C}_2$.
\begin{enumerate}
\item When $\mathds{C}_1 = \pskip$, we can reduce $(s, p, \pskip ; \mathds{C}_2) \xrightarrow{\actid{\iota}} (s, p, \mathds{C}_2)$ through the \textsc{SeqSkip} rule, therefore $\mathds{C}' = \mathds{C}_2$. We can do the same using the \textsc{AtSeqSkip} rule by reducing $(h, s, \pskip ; \mathds{C}_2) \tred (h, s, \mathds{C}_2)$.
\item When $\mathds{C}_1 \neq \pskip$, we can reduce $(s, p, \mathds{C}_1 ; \mathds{C}_2) \xrightarrow{\alpha} (s', p', \mathds{C}_1' ; \mathds{C}_2)$ through the \textsc{SeqSkip} rule, making $\mathds{C}' = \mathds{C}_1'; \mathds{C}_2$, by running $(s, p, \mathds{C}_1) \xrightarrow{\alpha} (s', p', \mathds{C}_1')$. By induction hypothesis on $\mathds{C}_1$ we obtain that $(h, s, \mathds{C}_1) \tred (h', s', \mathds{C}_1')$ which we can combine with rule \textsc{AtSeq} to obtain $(h, s, \mathds{C}_1 ; \mathds{C}_2) \tred (h', s', \mathds{C}_1' ; \mathds{C}_2)$. \\
\end{enumerate}

\textit{Inductive case 2}: $\pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2} \in \mathsf{Cmd}$

\textit{Inductive hypothesis}: $\pred{cAtom}{\mathds{C}_1} \land \pred{cAtom}{\mathds{C}_2}$

\textit{To show}: $\pred{cAtom}{\pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}}$

For arbitrary $\iota, s, s', p, p', \Phi, h, h', \mathds{C}', \alpha$ we assume that $(s, p, \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}) \xrightarrow{\alpha} (s', p', \mathds{C}') \land h' \in \left( \llbracket \alpha \rrbracket(h, \Phi) \downarrow_1 \right)$ holds. There are two possible ways to reduce $\pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}$ for $b = \llbracket \mathds{B} \rrbracket_{s}^{\textsc{b}}$.
\begin{enumerate}
\item When $b = \top$, we can reduce $(s, p, \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}) \xrightarrow{\actid{\iota}} (s, p, \mathds{C}_1)$ through the \textsc{CondT} rule. It is possible to do the same using the \textsc{AtCondT} rule to get $(h, s, \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}) \tred (h, s, \mathds{C}_1)$.
\item When $b = \bot$, we can reduce $(s, p, \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}) \xrightarrow{\actid{\iota}} (s, p, \mathds{C}_2)$ through the \textsc{CondF} rule. It is possible to do the same using the \textsc{AtCondF} rule to get $(h, s, \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}) \tred (h, s, \mathds{C}_2)$.
\end{enumerate}

\textit{Inductive case 3}: $\ploop{\mathds{B}}{\mathds{C}} \in \mathsf{Cmd}$

\textit{Inductive hypothesis}: $\pred{cAtom}{\mathds{C}}$

\textit{To show}: $\pred{cAtom}{\ploop{\mathds{B}}{\mathds{C}}}$

For arbitrary $\iota, s, s', p, p', \Phi, h, h', \mathds{C}', \alpha$ we assume that $(s, p, \ploop{\mathds{B}}{\mathds{C}}) \xrightarrow{\alpha} (s', p', \mathds{C}') \land h' \in \left( \llbracket \alpha \rrbracket(h, \Phi) \downarrow_1 \right)$ holds. There are two possible ways to reduce $\ploop{\mathds{B}}{\mathds{C}}$ for $b = \llbracket \mathds{B} \rrbracket_{s}^{\textsc{b}}$.
\begin{enumerate}
\item When $b = \top$, we can reduce $(s, p, \ploop{\mathds{B}}{\mathds{C}}) \xrightarrow{\actid{\iota}} (s, p, \mathds{C} ; \ploop{\mathds{B}}{\mathds{C}})$ through the \textsc{LoopT}. In a similar way we can reduce $(h, s, \ploop{\mathds{B}}{\mathds{C}}) \tred (h, s, \mathds{C} ; \ploop{\mathds{B}}{\mathds{C}})$ via the \textsc{AtLoopT} rule.
\item When $b = \bot$, we can reduce $(s, p, \ploop{\mathds{B}}{\mathds{C}}) \xrightarrow{\actid{\iota}} (s, p, \pskip)$ through the \textsc{LoopF}. In a similar way we can reduce $(h, s, \ploop{\mathds{B}}{\mathds{C}}) \tred (h, s, \pskip)$ via the \textsc{AtLoopF} rule.
\end{enumerate}
\end{proof}
}

\lem \label{ref:aseq}
\[
\begin{array}{r l}
	\pred{aseq}{\mathds{P}_1} \triangleq
	&
	\begin{array}{l}
	\forall h, h', \mathds{P}_2 \ldotp \\
	(h, \mathds{P}_1) \tred^* (h', \pskip) \Rightarrow 
	(h, \mathds{P}_1; \mathds{P}_2) \tred^* (h', \pskip; \mathds{P}_2)
	\end{array}
\end{array}
\]

{\parindent0pt
\begin{proof}
$\forall \mathds{P}_1 \ldotp \pred{aseq}{\mathds{P}_1}$ by induction on $n$, i.e. the number of reduction steps in $\tred^*$. \\

\textit{Base case}: $n = 0$

\textit{To show}: 
\[
\begin{array}{l}
\forall h, h', \mathds{P}_2 \ldotp \\
(h, \mathds{P}_1) \tred^0 (h', \pskip) \implies 
(h, \mathds{P}_1; \mathds{P}_2) \tred^* (h', \pskip; \mathds{P}_2)
\end{array}
\]
We assume $(h, \mathds{P}_1) \tred^0 (h', \pskip)$ holds and given it is a zero-step reduction, the only possible case is for $\mathds{P}_1 = \pskip$. Therefore $(h, \pskip) \tred^0 (h', \pskip)$ where $h = h'$. Now for $m = 0$ we have $(h, \pskip; \mathds{P}_2) \tred^0 (h', \pskip; \mathds{P}_2)$ given that $\tred^*$ is a reflexive relation, again for $h = h'$. \\

\textit{Inductive case}: For some arbitrary $n > 0$

\textit{Inductive hypothesis}: Assume the property holds for all programs $\mathds{P}_1'$ and $n$ steps, such that $(h, \mathds{P}_1) \tred (h'', \mathds{P}_1')$ for some $h''$.
\[
\begin{array}{l}
\forall h, h', \mathds{P}_2 \ldotp \\
(h, \mathds{P}_1') \tred^n (h', \pskip) \implies 
(h, \mathds{P}_1'; \mathds{P}_2) \tred^* (h', \pskip; \mathds{P}_2)
\end{array}
\]
\textit{To show}:
\[
\begin{array}{l}
\forall h, h', \mathds{P}_2 \ldotp \\
(h, \mathds{P}_1) \tred^{n+1} (h', \pskip) \implies 
(h, \mathds{P}_1; \mathds{P}_2) \tred^* (h', \pskip; \mathds{P}_2)
\end{array}
\]
We assume $(h, \mathds{P}_1) \tred^{n+1} (h', \pskip)$ holds and we also know that $(h, \mathds{P}_1) \tred (h'', \mathds{P}_1')$. The latter is the premiss of rule \textsc{PSeq} for the conclusion $(h, \mathds{P}_1; \mathds{P}_2) \tred (h'', \mathds{P}_1'; \mathds{P}_2)$ in one step of reduction. Therefore by this fact and the inductive hypothesis we obtain that $\pred{aseq}{\mathds{P}_1}$ holds for $n + 1$ steps.

\end{proof}
}

\lem \label{ref:2seq}
\[
\begin{array}{r l}
	\pred{2seq}{\mathds{P}_1} \triangleq
	&
	\begin{array}{l}
	\forall h, h', S, S', \Phi, \mathds{P}_2 \ldotp \\ 
	(h, \Phi, S, \mathds{P}_1; \mathds{P}_2) \rightarrow^* (h', \emptyset, S', \pskip; \mathds{P}_2)
	\Rightarrow
	(h, \Phi, S, \mathds{P}_1) \rightarrow^* (h', \emptyset, S', \pskip)
	\end{array}
\end{array}
\]

{\parindent0pt
\begin{proof}
$\forall \mathds{P}_1 \ldotp \pred{2seq}{\mathds{P}_1}$ by induction on $n$, i.e. the number of reduction steps in $\rightarrow^*$. \\

\textit{Base case}: $n = 0$

\textit{To show}:
\[
\begin{array}{l}
\forall h, h', S, S', \Phi, \mathds{P}_2 \ldotp \\ 
	(h, \Phi, S, \mathds{P}_1; \mathds{P}_2) \rightarrow^0 (h', \emptyset, S', \pskip; \mathds{P}_2)
	\Rightarrow
	(h, \Phi, S, \mathds{P}_1) \rightarrow^* (h', \emptyset, S', \pskip)
\end{array}
\]
We assume that $(h, \Phi, S, \mathds{P}_1; \mathds{P}_2) \rightarrow^0 (h', \emptyset, S', \pskip; \mathds{P}_2)$ holds. A zero-step reduction means that it must be the case that $\mathds{P}_1 = \pskip$. Therefore $(h, \Phi, S, \pskip; \mathds{P}_2) \rightarrow^0 (h', \emptyset, S', \pskip; \mathds{P}_2)$ for $h = h', \Phi = \emptyset, S = S'$. \\

\textit{Inductive case}: For some arbitrary $n > 0$

\textit{Inductive hypothesis}: Assume the property holds for all programs $\mathds{P}_1'; \mathds{P}_2$ and $n$ steps, such that $(h, \Phi, S, \mathds{P}_1; \mathds{P}_2) \xrightarrow{\alpha} (h'', \Phi'', S'', \mathds{P}_1'; \mathds{P}_2)$ for some $\alpha, h'', \Phi'', S''$.
\[
\begin{array}{l}
\forall h, h', S, S', \Phi, \mathds{P}_2 \ldotp \\ 
	(h, \Phi, S, \mathds{P}_1'; \mathds{P}_2) \rightarrow^n (h', \emptyset, S', \pskip; \mathds{P}_2)
	\Rightarrow
	(h, \Phi, S, \mathds{P}_1') \rightarrow^* (h', \emptyset, S', \pskip)
\end{array}
\]

\textit{To show}:
\[
\begin{array}{l}
\forall h, h', S, S', \Phi, \mathds{P}_2 \ldotp \\ 
	(h, \Phi, S, \mathds{P}_1; \mathds{P}_2) \rightarrow^{n+1} (h', \emptyset, S', \pskip; \mathds{P}_2)
	\Rightarrow
	(h, \Phi, S, \mathds{P}_1) \rightarrow^* (h', \emptyset, S', \pskip)
\end{array}
\]

We assume that $(h, \Phi, S, \mathds{P}_1; \mathds{P}_2) \rightarrow^{n+1} (h', \emptyset, S', \pskip; \mathds{P}_2)$ holds and we also know that in one step of reduction we get $(h, \Phi, S, \mathds{P}_1; \mathds{P}_2) \xrightarrow{\alpha} (h'', \Phi'', S'', \mathds{P}_1'; \mathds{P}_2)$. The latter is the conclusion of rule \textsc{PSeq}, so we know that if it happened then it must be the case that $(h, \Phi, S, \mathds{P}_1) \xrightarrow{\alpha} (h'', \Phi'', S'', \mathds{P}_1')$ holds in the premiss. Now, by inductive hypothesis we can conclude that the property holds for $n + 1$ steps.

\end{proof}
}

\lem \label{ref:phiemp}
\[
\forall h, h', S, S', \Phi, \Phi', \mathds{P} \ldotp
(h, \Phi, S, \mathds{P}) \rightarrow^* (h', \Phi', S', \pskip) \implies \Phi' \equiv \emptyset
\]

\lem \label{lem:sameSys}
\begin{gather*}
	\forall h, \Phi, S, \mathds{P}, \mathds{P}' \ldotp
	(h, \Phi, S, \mathds{P}) \xrightarrow{\actprog} (h', \Phi', S', \mathds{P}')
		\implies \\
	(h, \mathds{P}) \tred (h', \mathds{P}') \land h' = h \land \Phi' = \Phi \land S' = S
\end{gather*}
\begin{proof}
Let's pick arbitrary $h \in \mathsf{Storage}, \Phi \in \mathsf{LMan}, S \in \mathsf{TState}, \mathds{P}, \mathds{P}' \in \mathsf{Prog}$. We now assume that the following holds:
\begin{gather}
	\label{lem:sameSys1} (h, \Phi, S, \mathds{P}) \xrightarrow{\actprog} (h, \Phi, S, \mathds{P}')
\end{gather}
Given that from (\ref{lem:sameSys1}) we know that $\mathds{P}$ reduced to $\mathds{P'}$ through $\actprog$ we will proceed with a case-by-case analysis on the structure of $\mathds{P}$.
\begin{itemize}
	\item If $\mathds{P} = \pskip ; \mathds{P}''$ for some $\mathds{P}'' \in \mathsf{Prog}$, then from the \textsc{PSeqSkip} rule we get that $\mathds{P}' = \mathds{P}'', h' = h, \Phi' = \Phi, S' = S$. From the \textsc{AtPSeqSkip} rule we know that as part of the atomic semantics, $(h, \mathds{P})$ will also reduce to $(h, \mathds{P}'')$.
	
	\item If $\mathds{P} = \pskip \| \pskip$ then from the \textsc{ParEnd} rule we get that $\mathds{P}' = \pskip, h' = h, \Phi' = \Phi, S' = S$. From the \textsc{AtParEnd} rule we know that as part of the atomic semantics, $(h, \mathds{P})$ will also reduce to $(h, \pskip)$.
	
	\item If $\mathds{P} = \mathds{P}_0^*$ for some $\mathds{P}_0 \in \mathsf{Prog}$, then from the \textsc{Loop} rule we get that $\mathds{P}' = \pskip + (\mathds{P}_0;\mathds{P}_0^*), h' = h, \Phi' = \Phi, S' = S$. From the \textsc{AtLoop} rule we know that as part of the atomic semantics, $(h, \mathds{P})$ will also reduce to $(h, \pskip + (\mathds{P}_0;\mathds{P}_0^*))$.
	
	\item $\mathds{P} = \mathds{P}_1 + \mathds{P}_2$ for some $\mathds{P}_1, \mathds{P}_2 \in \mathsf{Prog}$, then we can apply one of two reduction rules:
		\begin{itemize}
			\item If $\mathsf{sys}$ was generated by the \textsc{ChoiceL} rule then $\mathds{P}' = \mathds{P}_1, h' = h, \Phi' = \Phi, S' = S$ and through the \textsc{AtChoiceL} rule $(h, \mathds{P})$ will also reduce to $(h, \mathds{P}_1)$.
			\item If $\mathsf{sys}$ was generated by the \textsc{ChoiceR} rule then $\mathds{P}' = \mathds{P}_2, h' = h, \Phi' = \Phi, S' = S$ and through the \textsc{AtChoiceR} rule $(h, \mathds{P})$ will also reduce to $(h, \mathds{P}_2)$.
		\end{itemize}
\end{itemize}
\end{proof}