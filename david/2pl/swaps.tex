\subsubsection{Trace equivalence}

The final proof of equivalence will need a number of preliminary lemmata in order to succeed. Most of them describe a series of concrete transformations applied to traces that preserve the semantic meaning of the trace in terms of the effects on the global storage. We start by giving some helpful definitions that will be later used as part of the lemmata.

The first one allows to express that a trace $\tau$ is able to generate a particular storage starting from a given initial state with a storage, lock manager, transactions' stack and program components. It serves the purpose of comparing different traces by establishing a type of trace equivalence. In fact, we obtain important information knowing that two distinct traces $\tau$ and $\tau'$ can generate the same heap under specific circumstances.

\begin{defn}
	(Trace generated).
	A trace $\tau$ \emph{generates} a storage $\underline{h}$ starting from the state $h, \Phi, S, \mathds{P}$ if and only if every action in $\tau$ labels one of consecutive reductions that bring $\mathds{P}$ to $\pskip$ under the \tpl\ operational semantics.
	\begin{align*}
		\pred{tgen}{[], h, \underline{h}, \Phi, S, \mathds{P}}
			\iff&
		h = \underline{h} \land \mathds{P} = \pskip \land \Phi = \emptyset
			\\
		\pred{tgen}{(\alpha, n) : \tau, h, \underline{h}, \Phi, S, \mathds{P}}
			\iff&
		\exists h', \Phi', S', \mathds{P}' \ldotp (h, \Phi, S, \mathds{P}) \xrightarrow{\alpha} (h', \Phi', S', \mathds{P}') \\ &\land \pred{tgen}{\tau, h', \underline{h}, \Phi', S', \mathds{P}'}
	\end{align*}
\end{defn}

In order for the \tpl\ operational semantics to model any kind of two phase locking pattern, we utilize nondeterministic locking of storage cells, as described in Section \ref{sec:opSemCmd2pl}. This comes with the downside of allowing a transaction to lock (and later unlock) any cell it wants. Such phenomenon can happen even if later in the execution the same transaction does not use the locks to access the respective storage cells to read from or write to them. Lock operations performed by a transaction as part of a trace, which are never used to later access the corresponding cell are often and informally referred to as \textit{spurious}. The next two definitions formally describe this behaviour.

\begin{defn}
	(Absent access).
	A cell which is neither read or written to by a given transaction as part of a trace is \emph{absent} and the corresponding predicate is defined as follows:
	\[
		\pred{absent}{\iota, k, \tau}
			\iff
		\lnot \exists v, n \ldotp (\actread{\iota}{k}{v}, n) \in \tau \lor (\actwrite{\iota}{k}{v}, n) \in \tau
	\]
\end{defn}

\begin{defn}
	(Clean trace).
	A trace is \emph{clean} if and only if its transactions do not lock or unlock any absent cell.
	\[
		\pred{clean}{\tau} \iff \forall \iota, k, \kappa, n \ldotp
		\left( (\actlock{\iota}{k}{\kappa}, n) \in \tau \lor (\actunlock{\iota}{k}, n) \in \tau \right)
			\implies
		\lnot \pred{absent}{\iota, k, \tau}
	\]
\end{defn}

\begin{center}
	\begin{tikzpicture}[->, semithick]
		\tikzset{
		    tleft/.style= {rectangle, draw=blue, color=blue, minimum width=2.5cm},
		    tright/.style= {rectangle, draw=red, color=red, minimum width=2.5cm},
		    pleft/.style= {above, black!5!blue, thick},
		    pright/.style= {above, black!5!magenta, thick},
		}
		
		\node[tleft] (s1) at (0, 0) {$\actlock{i}{1}{\textsc{x}}$};
		\node[tright] (s2) at (2.75, 0) {$\actlock{j}{3}{\textsc{x}}$};
		\node[tleft] (s3) at (5.5, 0) {$\actid{j}$};
		\node[tright] (s4) at (8.25, 0) {$\actunlock{j}{3}$};
		\node[tleft] (s5) at (11, 0) {$\actwrite{i}{1}{1}$};
		\node[tleft] (s6) at (13.75, 0) {$\actunlock{i}{1}$};
		
		\node[tleft] (s7) at (2.75,-2.1) {$\actlock{i}{1}{\textsc{x}}$};
		\node[tleft] (s8) at (5.5,-2.1) {$\actid{j}$};
		\node[tleft] (s9) at (8.25,-2.1) {$\actwrite{i}{1}{1}$};
		\node[tleft] (s10) at (11,-2.1) {$\actunlock{i}{1}$};
		
		\draw[dashed]
		(s1) edge[pleft] (s7)
		(s3) edge[pleft] (s8)
		(s5) edge[pleft] (s9)
		(s6) edge[pleft] (s10);
	\end{tikzpicture}
	\captionof{figure}{A trace containing spurious locks and its clean equivalent.}
\end{center}

We are able to modify the structure of a trace through the union or the difference with a set of operations, which we formally define as follows.
\begin{defn}
	(Trace difference).
	\[
		\tau' = \tau \setminus S \iff \left( \forall x \ldotp x \not\in S \implies (x \in \tau \iff x \in \tau') \right)
	\]
\end{defn}

\begin{defn}
	(Trace union).
	\begin{gather*}
		\tau' = \tau \cup S \iff \\
		(\forall \alpha, n \ldotp
		(\alpha, n) \in S \implies \left( \lnot \exists \alpha' \ldotp (\alpha', n) \in \tau \right) \\
		\land\ \forall x \ldotp (x \in \tau \lor x \in S) \iff x \in \tau')
	\end{gather*}
\end{defn}

It is now possible to show that any trace $\tau$ that contains a spurious lock (followed by an unlock on the same item) and is able to generate a particular storage $h'$, has a corresponding trace $\tau'$ which contains all of $\tau$'s operations a part from the spurious ones, and $\tau'$ can generate $h'$ starting with the same initial state and program.

\begin{lem}
	(Proof in \ref{lem:lockAbsent}).
	Lock and unlock operations done by a transaction on items which it does not read or write can be removed without affecting the program or the global state.
	\begin{gather*}
		\forall \tau, \tau', h, h', \Phi, S, \mathds{P}, n, n', \iota, k, \kappa, x, y \ldotp
			\\
		\pred{tgen}{\tau, h, h', \Phi, S, \mathds{P}} \land  \pred{absent}{\iota, k, \tau} \land x = (\actlock{\iota}{k}{\kappa}, n) \land y = (\actunlock{\iota}{k}, n') \\ \land x \in \tau \land y \in \tau
		\land \tau' = \tau \setminus \{ x, y \}
			\implies
		\pred{tgen}{\tau', h, h', \Phi, S, \mathds{P}}
	\end{gather*}
\end{lem}

The proof uses another important property of operations inside a trace which is the fact that a lock on an item is not needed for any reductions a part from a read, a write or an unlock action performed by the same transaction on the same item. As we will see later, we leverage this proof in order to \textit{clean} traces from any spurious locks they contain.

\begin{lem}
	(Proof in \ref{lem:alman}).
	\begin{gather*}
		\forall \mathds{P}, \mathds{P}', h, h', \Phi, \Phi', S, S', \alpha, i, k, v, I, \kappa \ldotp \\
		(h, \Phi, S, \mathds{P}) \xrightarrow{\alpha} (h', \Phi', S', \mathds{P}')
			\land
		(\{i\} \uplus I, \kappa) = \Phi(k)
			\land \\
		\alpha \not\in \{ \actread{i}{k}{v}, \actwrite{i}{k}{v}, \actunlock{i}{k} \}
			\implies
		\exists \Phi_m, \Phi_m', I', \kappa', \kappa'' \ldotp \\
		(h, \Phi_m, S, \mathds{P}) \xrightarrow{\alpha} (h', \Phi_m', S, \mathds{P}')
			\land
		\Phi_m = \Phi[k \mapsto (I, \kappa')]
			\land
		\Phi_m' = \Phi'[k \mapsto (I', \kappa'')]
			\land
		\kappa' \leq \textsc{s}
	\end{gather*}
\end{lem}

Once a trace is clean, we can proceed to manipulate it and, under certain cases, swap the order of its operations. Repeating this process, will give us a new trace, syntactically different but semantically equivalent, as observed by its effects on the global heap. This is what we are interested in, given our requirement of simulating a serial trace. Whenever in the following definitions we encounter a term of the shape $\alpha(\iota)$ or $\alpha(\iota, k)$ we actually mean the first projection of their operation-level equivalent, i.e. $op(\iota) \downarrow_1$ and $op(\iota, k) \downarrow_1$ respectively.

\begin{defn}
	(Swapped trace).
	A trace $\tau'$ is the \emph{swapped} version of $\tau$ for some operations $x$ and $y$ if and only if $\tau'$ contains all of $\tau$'s operations in the same exact order a part from the one of $x$ and $y$, which is swapped.
	\begin{gather*}
		\tau' = \pred{swap}{\tau, x, y}
		\iff \\
		\exists \alpha_x, n_x, \alpha_y, n_y \ldotp x = (\alpha_x, n_x) \land y = (\alpha_y, n_y)\ \land \\
		\tau' = \tau \setminus \{(\alpha_x, n_x), (\alpha_y, n_y)\} \cup \{ (\alpha_x, n_y), (\alpha_y, n_x) \}
	\end{gather*}
\end{defn}

We start by showing that the order of two consecutive reads can be swapped as long as the transactions performing them are distinct. Since reads do not alter the storage and they only require at least a shared lock on the target cell, we always succeed in the swap. It is fundamental for the transactions to be different otherwise we would be potentially altering the control flow inside the body of a transaction.
\begin{lem}
	(Proof in \ref{lem:rr}).
	\begin{gather*}
		\forall \tau, \tau', h, h', \Phi, S, \mathds{P}, i, j, k, k', v, v', \alpha, \alpha', n \ldotp \\
		i \neq j \land \alpha = \actread{i}{k}{v} \land \alpha' = \actread{j}{k'}{v'} \land (\alpha, n) \in \tau \land (\alpha', n+1) \in \tau \\ \land\ \pred{tgen}{\tau, h, h', \Phi, S, \mathds{P}} \land \tau' = \pred{swap}{\tau, (\alpha, n), (\alpha', n+1)}
			\\	 
		 \implies \pred{tgen}{\tau', h, h', \Phi, S, \mathds{P}}
	\end{gather*}
\end{lem}

The order of two consecutive read, write, lock or unlock operations can be swapped as long as the transactions performing them are distinct and the keys they refer to are different.
\begin{lem}
	(Proof in \ref{lem:rwlu}).
	\begin{gather*}
		\forall \tau, \tau', h, h', \Phi, S, \mathds{P}, i, j, k, k', x, y, n \ldotp \\
			i \neq j \land x = \alpha(i, k) \land y = \alpha(j, k') \land k \neq k' \land (x, n) \in \tau \land (y, n+1) \in \tau \\ \land\ \pred{tgen}{\tau, h, h', \Phi, S, \mathds{P}} \land \tau' = \pred{swap}{\tau, (x, n), (y, n+1)}
			\\	 
		 \implies \pred{tgen}{\tau', h, h', \Phi, S, \mathds{P}}
	\end{gather*}
\end{lem}

In the case of two consecutive alloc operations inside a trace, we only require for the transactions performing them to be distinct. There is no constraint on the keys generated since we already know they must be two disjoint sets, otherwise the original reduction would have not been allowed.
\begin{lem}
	(Proof in \ref{lem:aa}).
	\begin{gather*}
		\forall \tau, \tau', h, h', \Phi, S, \mathds{P}, i, j, m, m', l, l', \alpha, \alpha', n \ldotp \\
			i \neq j \land \alpha = \actalloc{i}{m}{l} \land \alpha' = \actalloc{j}{m'}{l'} \land (\alpha, n) \in \tau \land (\alpha', n+1) \in \tau \\ \land\ \pred{tgen}{\tau, h, h', \Phi, S, \mathds{P}} \land \tau' = \pred{swap}{\tau, (\alpha, n), (\alpha', n+1)}
			\\	 
		 \implies \pred{tgen}{\tau', h, h', \Phi, S, \mathds{P}}
	\end{gather*}
\end{lem}

We are always able to swap the order of a storage allocation operation followed by a read, write, lock or unlock as long as the transactions performing them are distinct and the keys accessed are not part of the ones created by the allocation. If the latter was not considered as a requirement, then we would allow to access a storage cell which is absent from the heap: an impossible case.
\begin{lem}
	(Proof in \ref{lem:ax}).
	\begin{gather*}
		\forall \tau, \tau', h, h', \Phi, S, \mathds{P}, i, j, k, x, y, n, m, l \ldotp \\
			i \neq j \land x = \alpha(j, k) \land y = \actalloc{i}{m}{l} \land (x, n) \in \tau \land (y, n+1) \in \tau \land (k < l \lor k \geq l + n) \\ \land\ \pred{tgen}{\tau, h, h', \Phi, S, \mathds{P}} \land \tau' = \pred{swap}{\tau, (x, n), (y, n+1)}
			\\	 
		 \implies \pred{tgen}{\tau', h, h', \Phi, S, \mathds{P}}
	\end{gather*}
\end{lem}

The final and simpler case is the one regarding one $\mathsf{id}$ transition. Given that by definition, $\actid{\iota}$ does not affect the global state but it is limited to label control flow reductions within transaction $\mathds{T}_\iota$, the relative order with respect to any other action performed by a different transaction does not matter.
\begin{lem}
	(Proof in \ref{lem:idx}).
	\begin{gather*}
		\forall \tau, \tau', h, h', \Phi, S, \mathds{P}, i, j, x, y, n \ldotp \\
			i \neq j \land x = \actid{i} \land y = \alpha(j) \land (x, n) \in \tau \land (y, n+1) \in \tau \\ \land\ \pred{tgen}{\tau, h, h', \Phi, S, \mathds{P}} \land \tau' = \pred{swap}{\tau, (x, n), (y, n+1)}
			\\	 
		 \implies \pred{tgen}{\tau', h, h', \Phi, S, \mathds{P}}
	\end{gather*}
\end{lem}

The semantically valid swap operations allowed on traces are summarized in the following table, where $\alpha$ and $\alpha'$ label two consecutive operations inside a program trace and the \textit{condition} is the sufficient requirement needed to perform the swap.

\begin{lem}
	(Swap rules).
	\begin{gather*}
		\forall
			\alpha, \alpha',
			i, j, k, \kappa,
			h, h', h_a,
			\Phi, \Phi', \Phi_a,
			S, S', S_a,
			\mathds{P}, \mathds{P}', \mathds{P}_a
		\ldotp \\
		(h, \Phi, S, \mathds{P})
			\xrightarrow{\alpha}
		(h_a, \Phi_a, S_a, \mathds{P}_a)
			\xrightarrow{\alpha'}
		(h', \Phi', S', \mathds{P}')
			\land
			i \neq j \\
			\land
		\lnot \left( \alpha = \actunlock{i}{k}
			\land
		\alpha' = \actlock{j}{k}{\kappa} \right)
			\land
		\alpha = \alpha(i)
			\land
		\alpha' = \alpha(j) \\
			\implies
		\exists h_b, \Phi_b, S_b, \mathds{P}_b \ldotp
		(h, \Phi, S, \mathds{P})
			\xrightarrow{\alpha'}
		(h_b, \Phi_b, S_b, \mathds{P}_b)
			\xrightarrow{\alpha}
		(h', \Phi', S', \mathds{P}')
	\end{gather*}
	\begin{proof}
	Let's pick arbitrary $\alpha, \alpha' \in \mathsf{Act}, i, j \in \mathsf{Tid}, k \in \mathsf{Key}, \kappa \in \mathsf{Lock}, h, h', h_a \in \mathsf{Storage}, \Phi, \Phi', \Phi_a \in \mathsf{LMan}, S, S', S_a \in \mathsf{TState}, \mathds{P}, \mathds{P}', \mathds{P}_a \in \mathsf{Prog}$ and assume that the following holds:
	\begin{gather}
		\label{lem:swapT1}
		(h, \Phi, S, \mathds{P})
			\xrightarrow{\alpha}
		(h_a, \Phi_a, S_a, \mathds{P}_a)
			\xrightarrow{\alpha'}
		(h', \Phi', S', \mathds{P}')
			\land
			i \neq j \\
			\land
		\label{lem:swapT2}
		\lnot \left( \alpha = \actunlock{i}{k}
			\land
		\alpha' = \actlock{j}{k}{\kappa} \right)
			\land
		\alpha = \alpha(i)
			\land
		\alpha' = \alpha(j)
	\end{gather}
	We now proceed in finding $h_b, \Phi_b, S_b, \mathds{P}_b$ by doing a case-by-case analysis on $\alpha$ and $\alpha'$ based on the feasible, i.e. the ones allowed by the \tpl\ operational semantics, reductions they can be part of according to (\ref{lem:swapT1}). From (\ref{lem:swapT2}) we know that neither $\alpha$ nor $\alpha'$ are system transitions $\actprog$. Similarly, we can't have a situation where $\alpha'$ is a lock on a key that was just unlocked by $\alpha$. Also, since from (\ref{lem:swapT1}) we know that $i \neq j$ which implies that, without loss of generality, programs $\mathds{P}, \mathds{P}_a, \mathds{P}'$ have the following shape:
	\[
		\begin{array}{c @{\hspace{15pt}} c @{\hspace{15pt}} c}
			\mathds{P}
				=
			\left( \mathds{T}_i ; \mathds{P}_1 \right)
				\|
			\left( \mathds{T}_j ; \mathds{P}_2 \right)
				\|
			\mathds{P}_3
			&
			\mathds{P}_a
				=
			\left( \mathds{T}_i' ; \mathds{P}_1 \right)
				\|
			\left( \mathds{T}_j ; \mathds{P}_2 \right)
				\|
			\mathds{P}_3
			&
			\mathds{P}'
				=
			\left( \mathds{T}_i' ; \mathds{P}_1 \right)
				\|
			\left( \mathds{T}_j' ; \mathds{P}_2 \right)
				\|
			\mathds{P}_3
		\end{array}
	\]
	Let us also define the new intermediate program, $\dot{\mathds{P}}$, for all the cases we will consider:
	\[
		\dot{\mathds{P}}
			=
		\left( \mathds{T}_i ; \mathds{P}_1 \right)
			\|
		\left( \mathds{T}_j' ; \mathds{P}_2 \right)
			\|
		\mathds{P}_3
	\]
	\begin{enumerate}[label=({\roman*})]
		\item If $\alpha = \actid{i}$ then from the semantic interpretation of $\mathsf{i}$, we obtain that $h_a = h, \Phi_a = \Phi, S_a = S$. It follows that for any action $\alpha'$ performed by $j$ we have the following reduction, from (\ref{lem:swapT1}):
		\[
			(h, \Phi, S, \mathds{P})
				\xrightarrow{\alpha'}
			(h', \Phi', S', \dot{\mathds{P}})
				\xrightarrow{\alpha}
			(h', \Phi', S', \mathds{P}')
		\]
		We can therefore pick $h_b = h', \Phi_b = \Phi', S_b = S'$ and $\mathds{P}_b = \dot{\mathds{P}}$. The same occurs when picking $\alpha' = \actid{j}$ and an arbitrary $\alpha = \alpha(i)$.
		
		\item If $\alpha = \actread{i}{k}{v}$ and $\alpha' = \actread{j}{k'}{v}$ then from the semantic interpretation of $\mathsf{read}$ we know that $h' = h_a = h, \Phi' = \Phi_a = \Phi$. Also, the two $\mathsf{read}$ actions will update transaction-local variables to the values read from the storage so we select $S_b$ to be $S[j \mapsto (s[\pvar{x} \mapsto v], p)]$ where $(s, p) = S(j)$. This implies that we can always reduce in the following way:
		\[
			(h, \Phi, S, \mathds{P})
				\xrightarrow{\alpha'}
			(h, \Phi, S_b, \dot{\mathds{P}})
				\xrightarrow{\alpha}
			(h, \Phi, S', \mathds{P}')
		\]
		We can therefore pick $h_b = h', \Phi_b = \Phi'$ and $\mathds{P}_b = \dot{\mathds{P}}$.
		
		\item If $\alpha = \actread{i}{k}{v}$ and $\alpha' = \actwrite{j}{k'}{v'}$ then from (\ref{lem:swapT1}) it must be the case that $k \neq k'$. This means that given the disjointness of keys, we can always find $h_b = h', \Phi_b = \Phi, S_b = S, \mathds{P}_b = \dot{\mathds{P}}$.
		
		\item If $\alpha = \actwrite{i}{k}{v}$ and $\alpha' = \actwrite{j}{k'}{v'}$ then from (\ref{lem:swapT1}) it must be the case that $k \neq k'$. Now we can always find $h_b = h[k' \mapsto v'], \Phi_b = \Phi, S_b = S, \mathds{P}_b = \dot{\mathds{P}}$.
		
		\item If $\alpha = \actread{i}{k}{v}$ and $\alpha' = \actlock{j}{k'}{\kappa}$ then from (\ref{lem:swapT1}) it must be the case that either $k \neq k'$ or $k = k'$ and $\Phi(k) = (\{i\} \uplus I, \textsc{s})$ and $\kappa = \textsc{s}$. In both cases we can find $h_b = h, \Phi_b = \Phi', S_b = S, \mathds{P}_b = \dot{\mathds{P}}$.
		
		\item If $\alpha = \actwrite{i}{k}{v}$ and $\alpha' = \actlock{j}{k'}{\kappa}$ then from (\ref{lem:swapT1}) it must be the case that $k \neq k'$. Now we can always find $h_b = h, \Phi_b = \Phi', S_b = S, \mathds{P}_b = \dot{\mathds{P}}$.
		
		\item If $\alpha = \actread{i}{k}{v}$ and $\alpha' = \actunlock{j}{k'}$ then from (\ref{lem:swapT1}) it must be the case that either $k \neq k'$ or $k = k'$ and $\Phi(k) = (\{i,j\} \uplus I, \textsc{s})$. In both cases we can find $h_b = h, \Phi_b = \Phi', S_b = S[j \mapsto (s, \pshrink)], \mathds{P}_b = \dot{\mathds{P}}$ for $s = S(j) \downarrow_1$.
		
		\item If $\alpha = \actwrite{i}{k}{v}$ and $\alpha' = \actunlock{j}{k'}$ then from (\ref{lem:swapT1}) it must be the case that $k \neq k'$. Now we can always find $h_b = h, \Phi_b = \Phi', S_b = S', \mathds{P}_b = \dot{\mathds{P}}$.
		
		\item If $\alpha = \actread{i}{k}{v}$ and $\alpha' = \actalloc{j}{n}{l}$ then from (\ref{lem:swapT1}) it must be the case that $k < l \lor l \geq l + n$. Now we can always find $h_b = h', \Phi_b = \Phi', S_b = S[j \mapsto (s[\pvar{x} \mapsto l], p)], \mathds{P}_b = \dot{\mathds{P}}$. Where $\pvar{x}$ is the variable recording the newly allocated address $l$ in transaction $j$ and $(s, p) = S(j)$.
		
		\item If $\alpha = \actwrite{i}{k}{v}$ and $\alpha' = \actalloc{j}{n}{l}$ then from (\ref{lem:swapT1}) it must be the case that $k < l \lor l \geq l + n$. Now we can always find $h_b = h[l \mapsto 0]\ldots[l + n - 1 \mapsto 0], \Phi_b = \Phi', S_b = S[j \mapsto (s[\pvar{x} \mapsto l], p)], \mathds{P}_b = \dot{\mathds{P}}$. Where $\pvar{x}$ is the variable recording the newly allocated address $l$ in transaction $j$ and $(s, p) = S(j)$.
		
		\item If $\alpha = \actlock{i}{k}{\kappa}$ and $\alpha' = \actlock{j}{k'}{\kappa'}$ then from (\ref{lem:swapT1}) it must be the case that either $k \neq k'$ or $k = k'$ and $\kappa = \kappa' = \textsc{s}$. In the first scenario we can find $\Phi_b = \Phi[k' \mapsto (\{j\} \uplus I', \kappa')]$ while in the second one $\Phi_b = \Phi[k \mapsto (\{j\} \uplus I, \textsc{s})]$ with $i \not\in I$. In both cases we pick $h_b = h, S_b = S, \mathds{P}_b = \dot{\mathds{P}}$.
		
		\item If $\alpha = \actunlock{i}{k}$ and $\alpha' = \actunlock{j}{k'}$ then from (\ref{lem:swapT1}) it must be the case that either $k \neq k'$ or $k = k'$ and $\Phi(k) = (\{i, j\} \uplus I, \textsc{s})$. In the first scenario we can find $\Phi_b = \Phi[k' \mapsto (I', \kappa'')]$ for $(\{j\} \uplus I', \kappa') = \Phi(k')$, while in the second one $\Phi_b = \Phi[k \mapsto (\{i\} \uplus I, \textsc{s})]$ with $j \not\in I$. In both cases we pick $h_b = h, S_b = S[j \mapsto (s, \pshrink)], \mathds{P}_b = \dot{\mathds{P}}$. for $s = S(j) \downarrow_1$.
		
		\item If $\alpha = \actlock{i}{k}{\kappa}$ and $\alpha' = \actunlock{j}{k'}$ then from (\ref{lem:swapT1}) it must be the case that either $k \neq k'$ and we find $\Phi_b = \Phi[k' \mapsto (I', \kappa'')]$ for $(\{j\} \uplus I', \kappa') = \Phi(k')$ or $k = k'$ and $\Phi(k) = (\{j\} \uplus I, \textsc{s})$ and $\kappa = \textsc{s}$. In the latter case we can find $\Phi_b = \Phi[k \mapsto (I, \textsc{s})]$. In both cases we pick $h_b = h, S_b = S', \mathds{P}_b = \dot{\mathds{P}}$.
		
		\item If $\alpha = \actunlock{i}{k}$ and $\alpha' = \actlock{j}{k'}{\kappa}$ then from (\ref{lem:swapT2}) it must be the case that $k \neq k'$. Now we can always find $h_b = h, \Phi_b = \Phi[k' \mapsto (\{j\} \uplus I, \kappa)], S_b = S, \mathds{P}_b = \dot{\mathds{P}}$.
		
		\item If $\alpha = \actalloc{i}{n}{l}$ and $\alpha' = \actlock{j}{k}{\kappa}$ then from (\ref{lem:swapT1}) it must be the case that $k < l \lor k \geq l + n$. Now we can always find $h_b = h, \Phi_b = \Phi[k \mapsto (\{j\} \uplus I, \kappa)], S_b = S, \mathds{P}_b = \dot{\mathds{P}}$.
		
		\item If $\alpha = \actalloc{i}{n}{l}$ and $\alpha' = \actunlock{j}{k}$ then from (\ref{lem:swapT1}) it must be the case that $k < l \lor k \geq l + n$. Now we can always find $h_b = h, \Phi_b = \Phi[k \mapsto (I, \kappa')], S_b = S[j \mapsto (s, \pshrink)], \mathds{P}_b = \dot{\mathds{P}}$, for $(\{j\} \uplus I, \kappa) = \Phi(k), \kappa' \leq \textsc{s}$ and $s = S(j) \downarrow_1$.
		
		\item If $\alpha = \actalloc{i}{n}{l}$ and $\alpha' = \actalloc{j}{n'}{l'}$ then from (\ref{lem:swapT1}) it must be the case that $\{l, \ldots, l + n - 1\} \cap \{l', \ldots, l' + n' -1 \} \equiv \emptyset$. Now we can always find $h_b = h[l' \mapsto 0]\ldots[l' + n' - 1 \mapsto 0], \Phi_b = \Phi[l' \mapsto (\{j\}, \textsc{x})]\ldots[l' + n' - 1 \mapsto (\{j\}, \textsc{x})], S_b = S[j \mapsto (s[\pvar{x} \mapsto l'], p)], \mathds{P}_b = \dot{\mathds{P}}$ for $(s, p) = S(j)$.
	\end{enumerate}
	\end{proof}
\end{lem}

\newcolumntype{C}{>{$}c<{$}}
\[\def\arraystretch{1.5}
	\begin{tabular}{|C|C|C|C|}
		\hline
			\alpha
			&
			\alpha'
			&
			\text{Condition} \implies
			&
			\text{Condition} \Longleftarrow
			\\
		\hline
			\actid{i}
			&
			\actid{j}
			&
			\top
			&
			\top
			\\
		\hline
			\actid{i}
			&
			\actalloc{j}{n}{l}
			&
			\top
			&
			\top
			\\
		\hline
			\actid{i}
			&
			\actread{j}{k}{v}
			&
			\top
			&
			\top
			\\
		\hline
			\actid{i}
			&
			\actwrite{j}{k}{v}
			&
			\top
			&
			\top
			\\
		\hline
			\actid{i}
			&
			\actlock{j}{k}{\kappa}
			&
			\top
			&
			\top
			\\
		\hline
			\actid{i}
			&
			\actunlock{j}{k}
			&
			\top
			&
			\top
			\\
		\hline
			\actread{i}{k}{v}
			&
			\actread{j}{k'}{v'}
			&
			\top
			&
			\top
			\\
		\hline
			\actread{i}{k}{v}
			&
			\actwrite{j}{k'}{v'}
			&
			\top
			&
			\top
			\\
		\hline
			\actread{i}{k}{v}
			&
			\actlock{j}{k'}{\kappa}
			&
			\top
			&
			\top
			\\
		\hline
			\actread{i}{k}{v}
			&
			\actunlock{j}{k'}
			&
			\top
			&
			\top
			\\
		\hline
			\actread{i}{k}{v}
			&
			\actalloc{j}{n}{l}
			&
			\top
			&
			k < l \lor k \geq l + n
			\\
		\hline
			\actwrite{i}{k}{v}
			&
			\actwrite{j}{k'}{v'}
			&
			\top
			&
			\top
			\\
		\hline
			\actwrite{i}{k}{v}
			&
			\actlock{j}{k'}{\kappa}
			&
			\top
			&
			\top
			\\
		\hline
			\actwrite{i}{k}{v}
			&
			\actunlock{j}{k'}
			&
			\top
			&
			\top
			\\
		\hline
			\actwrite{i}{k}{v}
			&
			\actalloc{j}{n}{l}
			&
			k < l \lor k \geq l + n
			\\
		\hline
			\actalloc{i}{n}{l}
			&
			\actalloc{j}{n'}{l'}
			&
			\top
			&
			\top
			\\
		\hline
			\actalloc{i}{n}{l}
			&
			\actlock{j}{k}{\kappa}
			&
			k < l \lor k \geq l + n
			&
			\top
			\\
		\hline
			\actalloc{i}{n}{l}
			&
			\actunlock{j}{k}
			&
			k < l \lor k \geq l + n
			&
			\top
			\\
		\hline
			\actlock{i}{k}{\kappa}
			&
			\actlock{j}{k'}{\kappa'}
			&
			\top
			&
			\top
			\\
		\hline
			\actlock{i}{k}{\kappa}
			&
			\actunlock{j}{k'}
			&
			\top
			&
			k \neq k' \lor \kappa = \Phi(k) = \textsc{s}
			\\
		\hline
			\actunlock{i}{k}
			&
			\actunlock{j}{k'}
			&
			\top
			&
			\top
			\\
		\hline
	\end{tabular}
\]