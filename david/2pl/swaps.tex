\subsubsection{Trace equivalence}

The final proof of equivalence will need a number of preliminary lemmata in order to succeed. Most of them describe a series of concrete transformations applied to traces that preserve the semantic meaning of the trace in terms of the effects on the global storage. We start by giving some helpful definitions that will be later used as part of the lemmata.

The first one allows to express that a trace $\tau$ is able to generate a particular storage starting from a given initial state with a storage, lock manager, transactions' stack and program components. It serves the purpose of comparing different traces by establishing a type of trace equivalence. In fact, we obtain important information knowing that two distinct traces $\tau$ and $\tau'$ can generate the same heap under specific circumstances.

\begin{defn}
	(Trace generated).
	A trace $\tau$ \emph{generates} a storage $\underline{h}$ starting from the state $h, \Phi, S, \mathds{P}$ if and only if every action in $\tau$ labels one of consecutive reductions that bring $\mathds{P}$ to $\pskip$ under the \tpl\ operational semantics.
	\begin{align*}
		\pred{tgen}{[], h, \underline{h}, \Phi, S, \mathds{P}}
			\iff&
		h = \underline{h} \land \mathds{P} = \pskip \land \Phi = \emptyset
			\\
		\pred{tgen}{(\alpha, n) : \tau, h, \underline{h}, \Phi, S, \mathds{P}}
			\iff&
		\exists h', \Phi', S', \mathds{P}' \ldotp (h, \Phi, S, \mathds{P}) \xrightarrow{\alpha} (h', \Phi', S', \mathds{P}') \\ &\land \pred{tgen}{\tau, h', \underline{h}, \Phi', S', \mathds{P}'}
	\end{align*}
\end{defn}

In order for the \tpl\ operational semantics to model any kind of two phase locking pattern, we utilize nondeterministic locking of storage cells, as described in Section \ref{sec:opSemCmd2pl}. This comes with the downside of allowing a transaction to lock (and later unlock) any cell it wants. Such phenomenon can happen even if later in the execution the same transaction does not use the locks to access the respective storage cells to read from or write to them. Lock operations performed by a transaction as part of a trace, which are never used to later access the corresponding cell are often and informally referred to as \textit{spurious}. The next two definitions formally describe this behaviour.

\begin{defn}
	(Absent access).
	A cell which is neither read or written to by a given transaction as part of a trace is \emph{absent} and the corresponding predicate is defined as follows:
	\[
		\pred{absent}{\iota, k, \tau}
			\iff
		\lnot \exists v, n \ldotp (\actread{\iota}{k}{v}, n) \in \tau \lor (\actwrite{\iota}{k}{v}, n) \in \tau
	\]
\end{defn}

\begin{defn}
	(Clean trace).
	A trace is \emph{clean} if and only if its transactions do not lock or unlock any absent cell.
	\[
		\pred{clean}{\tau} \iff \forall \iota, k, \kappa, n \ldotp
		\left( (\actlock{\iota}{k}{\kappa}, n) \in \tau \lor (\actunlock{\iota}{k}, n) \in \tau \right)
			\implies
		\lnot \pred{absent}{\iota, k, \tau}
	\]
\end{defn}

\begin{center}
	\begin{tikzpicture}[->, semithick]
		\tikzset{
		    tleft/.style= {rectangle, draw=blue, color=blue, minimum width=2.5cm},
		    tright/.style= {rectangle, draw=red, color=red, minimum width=2.5cm},
		    pleft/.style= {above, black!5!blue, thick},
		    pright/.style= {above, black!5!magenta, thick},
		}
		
		\node[tleft] (s1) at (0, 0) {$\actlock{i}{1}{\textsc{x}}$};
		\node[tright] (s2) at (2.75, 0) {$\actlock{j}{3}{\textsc{x}}$};
		\node[tleft] (s3) at (5.5, 0) {$\actid{j}$};
		\node[tright] (s4) at (8.25, 0) {$\actunlock{j}{3}$};
		\node[tleft] (s5) at (11, 0) {$\actwrite{i}{1}{1}$};
		\node[tleft] (s6) at (13.75, 0) {$\actunlock{i}{1}$};
		
		\node[tleft] (s7) at (2.75,-2.1) {$\actlock{i}{1}{\textsc{x}}$};
		\node[tleft] (s8) at (5.5,-2.1) {$\actid{j}$};
		\node[tleft] (s9) at (8.25,-2.1) {$\actwrite{i}{1}{1}$};
		\node[tleft] (s10) at (11,-2.1) {$\actunlock{i}{1}$};
		
		\draw[dashed]
		(s1) edge[pleft] (s7)
		(s3) edge[pleft] (s8)
		(s5) edge[pleft] (s9)
		(s6) edge[pleft] (s10);
	\end{tikzpicture}
	\captionof{figure}{A trace containing spurious locks and its clean equivalent.}
\end{center}

We are able to modify the structure of a trace through the union or the difference with a set of operations, which we formally define as follows.
\begin{defn}
	(Trace difference).
	\[
		\tau' = \tau \setminus S \iff \left( \forall x \ldotp x \not\in S \implies (x \in \tau \iff x \in \tau') \right)
	\]
\end{defn}

\begin{defn}
	(Trace union).
	\begin{gather*}
		\tau' = \tau \cup S \iff \\
		(\forall \alpha, n \ldotp
		(\alpha, n) \in S \implies \left( \lnot \exists \alpha' \ldotp (\alpha', n) \in \tau \right) \\
		\land\ \forall x \ldotp (x \in \tau \lor x \in S) \iff x \in \tau')
	\end{gather*}
\end{defn}

It is now possible to show that any trace $\tau$ that contains a spurious lock (followed by an unlock on the same item) and is able to generate a particular storage $h'$, has a corresponding trace $\tau'$ which contains all of $\tau$'s operations a part from the spurious ones, and $\tau'$ can generate $h'$ starting with the same initial state and program.

\begin{lem}
	(Proof in \ref{lem:lockAbsent}).
	Lock and unlock operations done by a transaction on items which it does not read or write can be removed without affecting the program or the global state.
	\begin{gather*}
		\forall \tau, \tau', h, h', \Phi, S, \mathds{P}, n, n', \iota, k, \kappa, x, y \ldotp
			\\
		\pred{tgen}{\tau, h, h', \Phi, S, \mathds{P}} \land  \pred{absent}{\iota, k, \tau} \land x = (\actlock{\iota}{k}{\kappa}, n) \land y = (\actunlock{\iota}{k}, n') \\ \land x \in \tau \land y \in \tau
		\land \tau' = \tau \setminus \{ x, y \}
			\implies
		\pred{tgen}{\tau', h, h', \Phi, S, \mathds{P}}
	\end{gather*}
\end{lem}

The proof uses another important property of operations inside a trace which is the fact that a lock on an item is not needed for any reductions a part from a read, a write or an unlock action performed by the same transaction on the same item. As we will see later, we leverage this proof in order to \textit{clean} traces from any spurious locks they contain.

\begin{lem}
	(Proof in \ref{lem:alman}).
	\begin{gather*}
		\forall \mathds{P}, \mathds{P}', h, h', \Phi, \Phi', S, S', \alpha, i, k, v, I, \kappa \ldotp \\
		(h, \Phi, S, \mathds{P}) \xrightarrow{\alpha} (h', \Phi', S', \mathds{P}')
			\land
		(\{i\} \uplus I, \kappa) = \Phi(k)
			\land \\
		\alpha \not\in \{ \actread{i}{k}{v}, \actwrite{i}{k}{v}, \actunlock{i}{k} \}
			\implies
		\exists \Phi_m, \Phi_m', I', \kappa', \kappa'' \ldotp \\
		(h, \Phi_m, S, \mathds{P}) \xrightarrow{\alpha} (h', \Phi_m', S, \mathds{P}')
			\land
		\Phi_m = \Phi[k \mapsto (I, \kappa')]
			\land
		\Phi_m' = \Phi'[k \mapsto (I', \kappa'')]
			\land
		\kappa' \leq \textsc{s}
	\end{gather*}
\end{lem}

Once a trace is clean, we can proceed to manipulate it and, under certain cases, swap the order of its operations. Repeating this process, will give us a new trace, syntactically different but semantically equivalent, as observed by its effects on the global heap. This is what we are interested in, given our requirement of simulating a serial trace. Whenever in the following definitions we encounter a term of the shape $\alpha(\iota)$ or $\alpha(\iota, k)$ we actually mean the first projection of their operation-level equivalent, i.e. $op(\iota) \downarrow_1$ and $op(\iota, k) \downarrow_1$ respectively.

\begin{defn}
	(Swapped trace).
	A trace $\tau'$ is the \emph{swapped} version of $\tau$ for some operations $x$ and $y$ if and only if $\tau'$ contains all of $\tau$'s operations in the same exact order a part from the one of $x$ and $y$, which is swapped.
	\begin{gather*}
		\tau' = \pred{swap}{\tau, x, y}
		\iff \\
		\exists \alpha_x, n_x, \alpha_y, n_y \ldotp x = (\alpha_x, n_x) \land y = (\alpha_y, n_y)\ \land \\
		\tau' = \tau \setminus \{(\alpha_x, n_x), (\alpha_y, n_y)\} \cup \{ (\alpha_x, n_y), (\alpha_y, n_x) \}
	\end{gather*}
\end{defn}

We start by showing that the order of two consecutive reads can be swapped as long as the transactions performing them are distinct. Since reads do not alter the storage and they only require at least a shared lock on the target cell, we always succeed in the swap. It is fundamental for the transactions to be different otherwise we would be potentially altering the control flow inside the body of a transaction.
\begin{lem}
	(Proof in \ref{lem:rr}).
	\begin{gather*}
		\forall \tau, \tau', h, h', \Phi, S, \mathds{P}, i, j, k, k', v, v', \alpha, \alpha', n \ldotp \\
		i \neq j \land \alpha = \actread{i}{k}{v} \land \alpha' = \actread{j}{k'}{v'} \land (\alpha, n) \in \tau \land (\alpha', n+1) \in \tau \\ \land\ \pred{tgen}{\tau, h, h', \Phi, S, \mathds{P}} \land \tau' = \pred{swap}{\tau, (\alpha, n), (\alpha', n+1)}
			\\	 
		 \implies \pred{tgen}{\tau', h, h', \Phi, S, \mathds{P}}
	\end{gather*}
\end{lem}

The order of two consecutive read, write, lock or unlock operations can be swapped as long as the transactions performing them are distinct and the keys they refer to are different.
\begin{lem}
	(Proof in \ref{lem:rwlu}).
	\begin{gather*}
		\forall \tau, \tau', h, h', \Phi, S, \mathds{P}, i, j, k, k', x, y, n \ldotp \\
			i \neq j \land x = \alpha(i, k) \land y = \alpha(j, k') \land k \neq k' \land (x, n) \in \tau \land (y, n+1) \in \tau \\ \land\ \pred{tgen}{\tau, h, h', \Phi, S, \mathds{P}} \land \tau' = \pred{swap}{\tau, (x, n), (y, n+1)}
			\\	 
		 \implies \pred{tgen}{\tau', h, h', \Phi, S, \mathds{P}}
	\end{gather*}
\end{lem}

In the case of two consecutive alloc operations inside a trace, we only require for the transactions performing them to be distinct. There is no constraint on the keys generated since we already know they must be two disjoint sets, otherwise the original reduction would have not been allowed.
\begin{lem}
	(Proof in \ref{lem:aa}).
	\begin{gather*}
		\forall \tau, \tau', h, h', \Phi, S, \mathds{P}, i, j, m, m', l, l', \alpha, \alpha', n \ldotp \\
			i \neq j \land \alpha = \actalloc{i}{m}{l} \land \alpha' = \actalloc{j}{m'}{l'} \land (\alpha, n) \in \tau \land (\alpha', n+1) \in \tau \\ \land\ \pred{tgen}{\tau, h, h', \Phi, S, \mathds{P}} \land \tau' = \pred{swap}{\tau, (\alpha, n), (\alpha', n+1)}
			\\	 
		 \implies \pred{tgen}{\tau', h, h', \Phi, S, \mathds{P}}
	\end{gather*}
\end{lem}

We are always able to swap the order of a storage allocation operation followed by a read, write, lock or unlock as long as the transactions performing them are distinct and the keys accessed are not part of the ones created by the allocation. If the latter was not considered as a requirement, then we would allow to access a storage cell which is absent from the heap: an impossible case.
\begin{lem}
	(Proof in \ref{lem:ax}).
	\begin{gather*}
		\forall \tau, \tau', h, h', \Phi, S, \mathds{P}, i, j, k, x, y, n, m, l \ldotp \\
			i \neq j \land x = \alpha(j, k) \land y = \actalloc{i}{m}{l} \land (x, n) \in \tau \land (y, n+1) \in \tau \land (k < l \lor k \geq l + n) \\ \land\ \pred{tgen}{\tau, h, h', \Phi, S, \mathds{P}} \land \tau' = \pred{swap}{\tau, (x, n), (y, n+1)}
			\\	 
		 \implies \pred{tgen}{\tau', h, h', \Phi, S, \mathds{P}}
	\end{gather*}
\end{lem}

The final and simpler case is the one regarding one $\mathsf{id}$ transition. Given that by definition, $\actid{\iota}$ does not affect the global state but it is limited to label control flow reductions within transaction $\mathds{T}_\iota$, the relative order with respect to any other action performed by a different transaction does not matter.
\begin{lem}
	(Proof in \ref{lem:idx}).
	\begin{gather*}
		\forall \tau, \tau', h, h', \Phi, S, \mathds{P}, i, j, x, y, n \ldotp \\
			i \neq j \land x = \actid{i} \land y = \alpha(j) \land (x, n) \in \tau \land (y, n+1) \in \tau \\ \land\ \pred{tgen}{\tau, h, h', \Phi, S, \mathds{P}} \land \tau' = \pred{swap}{\tau, (x, n), (y, n+1)}
			\\	 
		 \implies \pred{tgen}{\tau', h, h', \Phi, S, \mathds{P}}
	\end{gather*}
\end{lem}

The semantically valid swap operations allowed on traces are summarized in the following table, where $\alpha$ and $\alpha'$ label two consecutive operations inside a program trace and the \textit{condition} is the sufficient requirement needed to perform the swap. 
\newcolumntype{C}{>{$}c<{$}}
\[\def\arraystretch{1.5}
	\begin{tabular}{|C|C|C|}
		\hline
			\alpha
			&
			\alpha'
			&
			\text{Condition}
			\\
		\hline
			\actid{i}
			&
			\actid{j}
			&
			\top
			\\
		\hline
			\actid{i}
			&
			\actalloc{j}{n}{l}
			&
			\top
			\\
		\hline
			\actid{i}
			&
			\actread{j}{k}{v}
			&
			\top
			\\
		\hline
			\actid{i}
			&
			\actwrite{j}{k}{v}
			&
			\top
			\\
		\hline
			\actid{i}
			&
			\actlock{j}{k}{\kappa}
			&
			\top
			\\
		\hline
			\actid{i}
			&
			\actunlock{j}{k}
			&
			\top
			\\
		\hline
			\actread{i}{k}{v}
			&
			\actread{j}{k'}{v'}
			&
			\top
			\\
		\hline
			\actread{i}{k}{v}
			&
			\actwrite{j}{k'}{v'}
			&
			k \neq k'
			\\
		\hline
			\actread{i}{k}{v}
			&
			\actlock{j}{k'}{\kappa}
			&
			k \neq k' \lor \kappa = \textsc{s}
			\\
		\hline
			\actread{i}{k}{v}
			&
			\actunlock{j}{k'}
			&
			k \neq k' \lor \Phi(k) = (\{i, j\} \uplus I, \textsc{s})
			\\
		\hline
			\actread{i}{k}{v}
			&
			\actalloc{j}{n}{l}
			&
			k < l \lor k \geq l + n
			\\
		\hline
			\actwrite{i}{k}{v}
			&
			\actwrite{j}{k'}{v'}
			&
			k \neq k'
			\\
		\hline
			\actwrite{i}{k}{v}
			&
			\actlock{j}{k'}{\kappa}
			&
			k \neq k'
			\\
		\hline
			\actwrite{i}{k}{v}
			&
			\actunlock{j}{k'}
			&
			k \neq k'
			\\
		\hline
			\actwrite{i}{k}{v}
			&
			\actalloc{j}{n}{l}
			&
			k < l \lor k \geq l + n
			\\
		\hline
			\actalloc{i}{n}{l}
			&
			\actalloc{j}{n'}{l'}
			&
			\top
			\\
		\hline
			\actalloc{i}{n}{l}
			&
			\actlock{j}{k}{\kappa}
			&
			k < l \lor k \geq l + n
			\\
		\hline
			\actalloc{i}{n}{l}
			&
			\actunlock{j}{k}
			&
			k < l \lor k \geq l + n
			\\
		\hline
			\actlock{i}{k}{\kappa}
			&
			\actlock{j}{k'}{\kappa'}
			&
			k \neq k' \lor \kappa = \kappa' = \textsc{s}
			\\
		\hline
			\actlock{i}{k}{\kappa}
			&
			\actunlock{j}{k'}
			&
			k \neq k' \lor \kappa = \textsc{s}
			\\
		\hline
			\actunlock{i}{k}
			&
			\actunlock{j}{k'}
			&
			k \neq k' \lor \Phi(k) = (\{i, j\} \uplus I, \textsc{s})
			\\
		\hline
	\end{tabular}
\]