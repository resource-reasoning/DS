\section{Assertions}

We assume the presence of logical variables, $x \in \mathsf{LVar}$, logical values, $l \in \mathsf{LVal}$ and logical expressions, $E \in \mathsf{LExpr}$. We define a logical environment, $e \in \mathsf{LEnv}$, as a function $\mathsf{LVar} \rightarrow \mathsf{LVal}$.

\subsection{Syntax}

\begin{align*}
P, P' \in \mathsf{Ass} ::=&
\ \mathtt{false} \\
|&\ \mathtt{true} \\
|&\ \mathtt{emp} \\
|&\ E_1 = E_2 \\
|&\ E_1 \mapsto E_2 \\
|&\ \boxed{E_1 \mapsto E_2}^r \\
|&\ P \land P' \\
|&\ P \lor P' \\
|&\ P \sep P' \\
|&\ P \Rightarrow P' \\
|&\ \exists x \ldotp P
\end{align*}

\subsection{Semantics}

\begin{align*}
\llbracket - \rrbracket_{-, -}^E &: (\mathsf{LExpr} \times \mathsf{Stack} \times \mathsf{LEnv}) \rightarrow \mathsf{LVal} \\
\llbracket l \rrbracket_{e, s}^E &\triangleq l \\
\llbracket \pvar{x} \rrbracket_{e, s}^E &\triangleq s(\pvar{x}) \\
\llbracket x \rrbracket_{e, s}^E &\triangleq e(x) \\
\llbracket E_1 + E_2 \rrbracket_{e, s}^E &\triangleq \llbracket E_1 \rrbracket_{e, s} + \llbracket E_2 \rrbracket_{e, s} \\
&\vdots
\end{align*}
\begin{align*}
\llbracket \mathtt{false} \rrbracket_{e, s} &\triangleq \emptyset \\
\llbracket \mathtt{true} \rrbracket_{e, s} &\triangleq \mathcal{P}(\mathsf{Storage}) \\
\llbracket \mathtt{emp} \rrbracket_{e, s} &\triangleq \{ (\emptyset, \emptyset) \} \\
\llbracket E_1 = E_2 \rrbracket_{e, s} &\triangleq \bigg\{ \begin{array}{l l}
\mathcal{P}(\mathsf{Storage}) & \text{if } \llbracket E_1 \rrbracket_{e, s} = \llbracket E_2 \rrbracket_{e, s} \\
\emptyset & \text{otherwise}
\end{array} \\
\llbracket E_1 \mapsto E_2 \rrbracket_{e, s} &\triangleq \{ (h, \emptyset)\ |\ \pred{dom}{h} \equiv \{ \llbracket E_1 \rrbracket_{e, s} \} \land h(\llbracket E_1 \rrbracket_{e, s}) = \llbracket E_2 \rrbracket_{e, s} \} \\
\llbracket \boxed{E_1 \mapsto E_2}^r \rrbracket_{e, s} &\triangleq \{ (\emptyset, h)\ |\ \pred{dom}{h} \equiv \{ \llbracket E_1 \rrbracket_{e, s} \} \land h(\llbracket E_1 \rrbracket_{e, s}) = \llbracket E_2 \rrbracket_{e, s} \} \\
\llbracket P \land P' \rrbracket_{e, s} &\triangleq \{ h\ |\ h \in \llbracket P \rrbracket_{e, s} \land h \in \llbracket P' \rrbracket_{e, s} \} \\
\llbracket P \lor P' \rrbracket_{e, s} &\triangleq \{ h\ |\ h \in \llbracket P \rrbracket_{e, s} \lor h \in \llbracket P' \rrbracket_{e, s} \} \\
\llbracket P \sep P' \rrbracket_{e, s} &\triangleq \{ h\ |\ h = h_1 \uplus h_2 \land h_1 \in \llbracket P \rrbracket_{e, s} \land h_2 \in \llbracket P' \rrbracket_{e, s} \} \\
\llbracket P \Rightarrow P' \rrbracket_{e, s} &\triangleq \{ h\ |\ h \in \llbracket P \rrbracket_{e, s} \Rightarrow h \in \llbracket P' \rrbracket_{e, s} \} \\
\llbracket \exists x \ldotp P \rrbracket_{e, s} &\triangleq \llbracket P \rrbracket_{e[x \mapsto v], s}
\end{align*}

\subsection{Proof System}

\[
\infer[\textsc{Assign}]
{
	\vdash \triple
	{P}
	{\passign{\pvar{x}}{E}}
	{\exists x\ldotp P[x/\pvar{x}] \land \pvar{x} = E[x/\pvar{x}]}
}
{}
\]

\[
\infer[\textsc{Read}]
{
	\vdash \triple
	{\cell{E}{n}}
	{\pderef{\pvar{x}}{E}}
	{\pvar{x} = n \land \cell{E}{n}}
}
{}
\]

\[
\infer[\textsc{ReadS}]
{
	\vdash \triple
	{\boxed{\cell{E}{E_r}}^r}
	{\pderef{\pvar{x}}{E}}
	{\pvar{x} = E_r \land \boxed{\cell{E}{E_r}}^r}
}
{}
\]

\[
\infer[\textsc{Write}]
{
	\vdash \triple
	{\cell{E_1}{-}}
	{\pmutate{E_1}{E_2}}
	{\cell{E_1}{E_2}}
}
{}
\]

\[
\infer[\textsc{WriteS}]
{
	\vdash \triple
	{\boxed{\cell{E_1}{-}}^r}
	{\pmutate{E_1}{E_2}}
	{\boxed{\cell{E_1}{E_2}}^r}
}
{}
\]

\[
\infer[\textsc{Alloc}]
{
	\vdash \triple
	{\mathtt{emp}}
	{\palloc{\pvar{x}}{E}}
	{\circledast_{0 \leq i < E}\cell{(\pvar{x} + i)}{0}}
}
{}
\]

\[
\infer[\textsc{AllocS}]
{
	\vdash \triple
	{\mathtt{emp}}
	{\palloc{\pvar{x}}{\mathds{1}}}
	{\exists r \ldotp \boxed{\cell{\pvar{x}}{0}}^r}
}
{}
\]

\[
\infer[\textsc{CmdSeq}]
{
	\vdash \triple
	{P}
	{\mathds{C}_1; \mathds{C}_2}
	{Q}
}
{
	\vdash \triple
	{P}
	{\mathds{C}_1}
	{R}\ \
	\vdash \triple
	{R}
	{\mathds{C}_2}
	{Q}
}
\]

\[
\infer[\textsc{Cond}]
{
	\vdash \triple
	{P}
	{\pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}}
	{Q}
}
{
	\vdash \triple
	{P \land \mathds{B}}
	{\mathds{C}_1}
	{Q}\ \
	\vdash \triple
	{P \land \lnot \mathds{B}}
	{\mathds{C}_2}
	{Q}
}
\]

\[
\infer[\textsc{Loop}]
{
	\vdash \triple
	{P}
	{\ploop{\mathds{B}}{\mathds{C}}}
	{Q \land \lnot \mathds{B}}
}
{
	\vdash \triple
	{P \land \mathds{B}}
	{\mathds{C}}
	{Q}
}
\]

\[
\infer[\textsc{Trans}]
{
	\vdash \triple
	{P}
	{\mathtt{begin}\ \mathds{C}\ \mathtt{end}}
	{Q}
}
{
	\vdash \triple
	{P}
	{\mathds{C}}
	{Q}
}
\]

\[
\infer[\textsc{Par}]
{
	\vdash \triple
	{P_1 \sep \ldots \sep P_n}
	{\mathds{T}_1 \| \ldots \| \mathds{T}_n}
	{Q}
}
{
	\vdash \triple
	{P_1}
	{\mathds{T}_1}
	{Q_1}\ \
	\ldots\ \
	\vdash \triple
	{P_n}
	{\mathds{T}_n}
	{Q_n}\
	Q = \pred{join}{[Q_1, \ldots, Q_n]}
}
\]

\[
\infer[\textsc{Seq}]
{
	\vdash \triple
	{P}
	{\mathds{P}_1; \mathds{P}_2}
	{Q}
}
{
	\vdash \triple
	{P}
	{\mathds{P}_1}
	{P'}\ \
	\vdash \triple
	{P'}
	{\mathds{P}_2}
	{Q}
}
\]

\[
\infer[\textsc{Lift}]
{
	\vdash \triple
	{p}
	{\mathds{P}}
	{q}
}
{
	(P, t) = \pred{lift}{p}\
	\vdash \triple
	{P}
	{\mathds{P}}
	{Q}\
	q = \pred{apply}{Q, t}
}
\]



\iffalse
\begin{gather*}
\color{blue} \left\lbrace \boxed{\pvar{a} \mapsto 0}^r \right\rbrace \\
\color{blue} \left\lbrace \boxed{\pvar{a} \mapsto v_r}^r \right\rbrace \\
\begin{array}{c || c}
\begin{array}{l}
\color{blue} \left\lbrace \boxed{\pvar{a} \mapsto v_r}^r \right\rbrace \\
\pderef{\pvar{x}}{\pvar{a}}; \\
\pmutate{\pvar{a}}{\pvar{x} + 1} \\
\color{blue} \left\lbrace \boxed{\pvar{a} \mapsto v_r + 1}^r \right\rbrace
\end{array}
&
\begin{array}{l}
\color{blue} \left\lbrace \boxed{\pvar{a} \mapsto v_r}^r \right\rbrace \\
\pmutate{\pvar{a}}{2} \\
\color{blue} \left\lbrace \boxed{\pvar{a} \mapsto 2}^r \right\rbrace
\end{array}
\end{array} \\
\color{blue} \left\lbrace \boxed{\pvar{a} \mapsto 2 \lor \pvar{a} \mapsto 3}^r \right\rbrace
\end{gather*}

\begin{gather*}
\color{blue} \left\lbrace \boxed{\pvar{a} \mapsto 0}^r \right\rbrace \\
\begin{array}{c || c || c}
\begin{array}{l}
\color{blue} \left\lbrace \pvar{a} \mapsto n_r \right\rbrace \\
\pderef{\pvar{x}}{\pvar{a}}; \\
\pmutate{\pvar{a}}{\pvar{x} + 1} \\
\color{blue} \left\lbrace \pvar{a} \mapsto n_r + 1 \right\rbrace
\end{array}
&
\begin{array}{l}
\color{blue} \left\lbrace \pvar{a} \mapsto n_r \right\rbrace \\
\pmutate{\pvar{a}}{2} \\
\color{blue} \left\lbrace \pvar{a} \mapsto 2 \right\rbrace
\end{array}
&
\begin{array}{l}
\color{blue} \left\lbrace \pvar{a} \mapsto n_r \right\rbrace \\
\pmutate{\pvar{a}}{5} \\
\color{blue} \left\lbrace \pvar{a} \mapsto 5 \right\rbrace
\end{array}
\end{array} \\
\color{blue} \left\lbrace \boxed{\pvar{a} \mapsto 2 \lor \pvar{a} \mapsto 3 \lor \pvar{a} \mapsto 5 \lor \pvar{a} \mapsto 6}^r \right\rbrace
\end{gather*}
\fi