\section{Assertions}

\subsection{Example}

Let's assume a bank database that holds accounts for customers. We abstract the latter as predicates of the shape $\pred{Account}{x, m}$ signifying a storage location at $x$ with dollar amount $m$. As the bank allows no overdraft, we enforce $m$ to be a non-negative number.
\[
\pred{Account}{x, m} \equiv \exists r \ldotp \boxed{x \mapsto m \land m \geq 0}^r_{I(r, x)}
\]

We now consider the scenario where a customer Bob owns an account at $\pvar{b}$ containing some $n$ dollars. At the same time, he has to pay rent which takes \$10 out of his balance (only if available) and receives his salary of \$15, therefore two transactions ($T_1$ and $T_2$) run concurrently to perform the tasks. The actions on the storage allowed and performed by each of the transactions is described in $I(r, x, m)$.
\[
I(r, x) \triangleq \left( 
\begin{array}{r l}
T_1(m): & \cell{x}{m} \sep m \geq 10 \transfersto \cell{x}{m - 10} \sep m \geq 0 \\
T_2(m): & \cell{x}{m} \transfersto \cell{x}{m + 15}
\end{array}
 \right)
\]

A sketch proof of the two transactions running under \textsc{2pl} follows.
\begin{gather*}
\specline{\pred{Account}{\pvar{b}, n}} \\
\specline{\exists r \ldotp \boxed{\cell{\pvar{b}}{n} \sep n \geq 0}^r_{I} \sep [T_1(n)]^r \sep [T_2(n)]^r} \\
\begin{array}{c || c}\
\begin{array}{l}
\mathtt{begin} \\
	\quad \specline{n \geq 0 \sep \left( \cell{\pvar{b}}{n} \lor \cell{\pvar{b}}{n + 15} \right)} \\
	\quad \pderef{\pvar{x}}{\pvar{b}}; \\
	\quad \pifs{\pvar{x} \geq 10} \\
	\quad \quad \pmutate{\pvar{b}}{\pvar{x} - 10} \\
	\quad \specline{\left( n \geq 10 \sep \cell{\pvar{b}}{n - 10} \right) \lor \\ \left( n \geq 0 \sep \cell{\pvar{b}}{n + 5} \right) \lor \\ \left( 0 \leq n < 10 \sep \cell{\pvar{b}}{n} \right)} \\
\mathtt{end}
\end{array}
&
\begin{array}{l}
\mathtt{begin} \\
	\quad \specline{\left( n \geq 0 \sep \cell{\pvar{b}}{n} \right) \lor \\ (n \geq 10 \sep \cell{\pvar{b}}{n - 10})} \\
	\quad \pderef{\pvar{y}}{\pvar{b}}; \\
	\quad \pmutate{\pvar{b}}{\pvar{y} + 15} \\
	\quad \specline{\left( n \geq 0 \sep \cell{\pvar{b}}{n + 15} \right) \lor \\ (n \geq 10 \land \cell{\pvar{b}}{n + 5})} \\
\mathtt{end}
\end{array}
\end{array} \\
\specline{\left( 0 \leq n < 10 \sep \cell{\pvar{b}}{n + 15} \right) \lor \left( n \geq 0 \sep \cell{\pvar{b}}{n + 5} \right)} \\
\vdots \\
\specline{\pred{Account}{\pvar{b}, n + 15} \lor \pred{Account}{\pvar{b}, n + 5}}
\end{gather*}

\subsection{Syntax}

We assume the presence of logical variables, $x \in \mathsf{LVar}$, logical values, $l \in \mathsf{LVal}$ and logical expressions, $E \in \mathsf{LExpr}$. We define a logical environment, $e \in \mathsf{LEnv}$, as a function $\mathsf{LVar} \rightarrow \mathsf{LVal}$.

\begin{align*}
P, P' \in \mathsf{Ass} ::=&
\ \mathtt{false}\
|\ \mathtt{true}\
|\ \mathtt{emp}\
|\ E_1 = E_2\
|\ E_1 \mapsto E_2\
|\ P \land P' \\
|&\ P \lor P'\
|\ P \sep P'\
|\ P \sepimp P'\
|\ P \Rightarrow P'\
|\ \exists x \ldotp P\
|\ \circledast x \ldotp P \\
|&\ \boxed{P}^r_I\
|\ \left[ \gamma(E_1, \ldots, E_n) \right]^r
|\ \alpha(E_1, \ldots, E_n) \\
p, p' \in \mathsf{BAss} ::=&
\ \mathtt{false}\
|\ \mathtt{true}\
|\ \mathtt{emp}\
|\ E_1 = E_2\
|\ E_1 \mapsto E_2\
|\ p \land p' \\
|&\ p \lor p'\
|\ p \sep p'\
|\ p \sepimp p'\
|\ p \Rightarrow p'\
|\ \exists x \ldotp p\
|\ \circledast x \ldotp p \\
I \in \mathsf{IAss} ::=&
\ \gamma(\vec{x}): \exists \vec{y} \ldotp (P \transfersto P')\ |\ I_1, I_2 \\
\end{align*}

\iffalse
\subsection{Semantics}

\begin{align*}
\llbracket - \rrbracket_{-, -}^E &: (\mathsf{LExpr} \times \mathsf{Stack} \times \mathsf{LEnv}) \rightarrow \mathsf{LVal} \\
\llbracket l \rrbracket_{e, s}^E &\triangleq l \\
\llbracket \pvar{x} \rrbracket_{e, s}^E &\triangleq s(\pvar{x}) \\
\llbracket x \rrbracket_{e, s}^E &\triangleq e(x) \\
\llbracket E_1 + E_2 \rrbracket_{e, s}^E &\triangleq \llbracket E_1 \rrbracket_{e, s} + \llbracket E_2 \rrbracket_{e, s} \\
&\vdots
\end{align*}
\begin{align*}
\llbracket \mathtt{false} \rrbracket_{e, s} &\triangleq \emptyset \\
\llbracket \mathtt{true} \rrbracket_{e, s} &\triangleq \mathcal{P}(\mathsf{Storage}) \\
\llbracket \mathtt{emp} \rrbracket_{e, s} &\triangleq \{ (\emptyset, \emptyset) \} \\
\llbracket E_1 = E_2 \rrbracket_{e, s} &\triangleq \bigg\{ \begin{array}{l l}
\mathcal{P}(\mathsf{Storage}) & \text{if } \llbracket E_1 \rrbracket_{e, s} = \llbracket E_2 \rrbracket_{e, s} \\
\emptyset & \text{otherwise}
\end{array} \\
\llbracket E_1 \mapsto E_2 \rrbracket_{e, s} &\triangleq \{ (h, \emptyset)\ |\ \pred{dom}{h} \equiv \{ \llbracket E_1 \rrbracket_{e, s} \} \land h(\llbracket E_1 \rrbracket_{e, s}) = \llbracket E_2 \rrbracket_{e, s} \} \\
\llbracket \boxed{E_1 \mapsto E_2}^r \rrbracket_{e, s} &\triangleq \{ (\emptyset, h)\ |\ \pred{dom}{h} \equiv \{ \llbracket E_1 \rrbracket_{e, s} \} \land h(\llbracket E_1 \rrbracket_{e, s}) = \llbracket E_2 \rrbracket_{e, s} \} \\
\llbracket P \land P' \rrbracket_{e, s} &\triangleq \{ h\ |\ h \in \llbracket P \rrbracket_{e, s} \land h \in \llbracket P' \rrbracket_{e, s} \} \\
\llbracket P \lor P' \rrbracket_{e, s} &\triangleq \{ h\ |\ h \in \llbracket P \rrbracket_{e, s} \lor h \in \llbracket P' \rrbracket_{e, s} \} \\
\llbracket P \sep P' \rrbracket_{e, s} &\triangleq \{ h\ |\ h = h_1 \uplus h_2 \land h_1 \in \llbracket P \rrbracket_{e, s} \land h_2 \in \llbracket P' \rrbracket_{e, s} \} \\
\llbracket P \Rightarrow P' \rrbracket_{e, s} &\triangleq \{ h\ |\ h \in \llbracket P \rrbracket_{e, s} \Rightarrow h \in \llbracket P' \rrbracket_{e, s} \} \\
\llbracket \exists x \ldotp P \rrbracket_{e, s} &\triangleq \llbracket P \rrbracket_{e[x \mapsto v], s}
\end{align*}
\fi

\subsection{Proof System}

\[
\infer[\textsc{CmdSeq}]
{
	\vdash \triple
	{P}
	{\mathds{C}_1; \mathds{C}_2}
	{Q}
}
{
	\vdash \triple
	{P}
	{\mathds{C}_1}
	{R}\ \
	\vdash \triple
	{R}
	{\mathds{C}_2}
	{Q}
}
\]

\[
\infer[\textsc{Cond}]
{
	\vdash \triple
	{P}
	{\pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}}
	{Q}
}
{
	\vdash \triple
	{P \land \mathds{B}}
	{\mathds{C}_1}
	{Q}\ \
	\vdash \triple
	{P \land \lnot \mathds{B}}
	{\mathds{C}_2}
	{Q}
}
\]

\[
\infer[\textsc{Loop}]
{
	\vdash \triple
	{P}
	{\ploop{\mathds{B}}{\mathds{C}}}
	{Q \land \lnot \mathds{B}}
}
{
	\vdash \triple
	{P \land \mathds{B}}
	{\mathds{C}}
	{Q}
}
\]

\[
\infer[\textsc{Trans}]
{
	\vdash \triple
	{P}
	{\mathtt{begin}\ \mathds{C}\ \mathtt{end}}
	{Q}
}
{
	\vdash_{\textsc{SL}} \triple
	{p}
	{\mathds{C}}
	{q}
}
\]

\[
\infer[\textsc{Par}]
{
	\vdash \triple
	{P_1 \sep P_2}
	{\mathds{P}_1 \| \mathds{P}_2}
	{Q}
}
{
	\vdash \triple
	{P_1}
	{\mathds{P}_1}
	{Q_1}\ \
	\vdash \triple
	{P_2}
	{\mathds{P}_2}
	{Q_2}
}
\]

\[
\infer[\textsc{Seq}]
{
	\vdash \triple
	{P}
	{\mathds{P}_1; \mathds{P}_2}
	{Q}
}
{
	\vdash \triple
	{P}
	{\mathds{P}_1}
	{P'}\ \
	\vdash \triple
	{P'}
	{\mathds{P}_2}
	{Q}
}
\]

\[
\infer[\textsc{Lift}]
{
	\vdash \triple
	{p}
	{\mathds{P}}
	{q}
}
{
	(P, t) = \pred{lift}{p}\
	\vdash \triple
	{P}
	{\mathds{P}}
	{Q}\
	q = \pred{apply}{Q, t}
}
\]

\iffalse

\begin{gather*}
\color{blue} \left\lbrace \boxed{\pvar{a} \mapsto 0}^r \right\rbrace \\
\color{blue} \left\lbrace \boxed{\pvar{a} \mapsto v_r}^r \right\rbrace \\
\begin{array}{c || c}
\begin{array}{l}
\color{blue} \left\lbrace \boxed{\pvar{a} \mapsto v_r}^r \right\rbrace \\
\pderef{\pvar{x}}{\pvar{a}}; \\
\pmutate{\pvar{a}}{\pvar{x} + 1} \\
\color{blue} \left\lbrace \boxed{\pvar{a} \mapsto v_r + 1}^r \right\rbrace
\end{array}
&
\begin{array}{l}
\color{blue} \left\lbrace \boxed{\pvar{a} \mapsto v_r}^r \right\rbrace \\
\pmutate{\pvar{a}}{2} \\
\color{blue} \left\lbrace \boxed{\pvar{a} \mapsto 2}^r \right\rbrace
\end{array}
\end{array} \\
\color{blue} \left\lbrace \boxed{\pvar{a} \mapsto 2 \lor \pvar{a} \mapsto 3}^r \right\rbrace
\end{gather*}

\begin{gather*}
\color{blue} \left\lbrace \boxed{\pvar{a} \mapsto 0}^r \right\rbrace \\
\begin{array}{c || c || c}
\begin{array}{l}
\color{blue} \left\lbrace \pvar{a} \mapsto n_r \right\rbrace \\
\pderef{\pvar{x}}{\pvar{a}}; \\
\pmutate{\pvar{a}}{\pvar{x} + 1} \\
\color{blue} \left\lbrace \pvar{a} \mapsto n_r + 1 \right\rbrace
\end{array}
&
\begin{array}{l}
\color{blue} \left\lbrace \pvar{a} \mapsto n_r \right\rbrace \\
\pmutate{\pvar{a}}{2} \\
\color{blue} \left\lbrace \pvar{a} \mapsto 2 \right\rbrace
\end{array}
&
\begin{array}{l}
\color{blue} \left\lbrace \pvar{a} \mapsto n_r \right\rbrace \\
\pmutate{\pvar{a}}{5} \\
\color{blue} \left\lbrace \pvar{a} \mapsto 5 \right\rbrace
\end{array}
\end{array} \\
\color{blue} \left\lbrace \boxed{\pvar{a} \mapsto 2 \lor \pvar{a} \mapsto 3 \lor \pvar{a} \mapsto 5 \lor \pvar{a} \mapsto 6}^r \right\rbrace
\end{gather*}
\fi