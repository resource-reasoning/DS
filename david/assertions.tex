\section{Assertions}

We assume the presence of logical variables, $x \in \mathsf{LVar}$, logical values, $l \in \mathsf{LVal}$ and logical expressions, $E \in \mathsf{LExpr}$. We define a logical environment, $e \in \mathsf{LEnv}$, as a function $\mathsf{LVar} \rightarrow \mathsf{LVal}$.

\subsection{Syntax}

\begin{align*}
P, P' \in \mathsf{Ass} ::=&
\ \mathtt{false} \\
|&\ \mathtt{true} \\
|&\ \mathtt{emp} \\
|&\ E_1 = E_2 \\
|&\ E_1 \mapsto E_2 \\
|&\ \boxed{E_1 \mapsto E_2}^r \\
|&\ P \land P' \\
|&\ P \lor P' \\
|&\ P \sep P' \\
|&\ P \Rightarrow P' \\
|&\ \exists x \ldotp P
\end{align*}

\subsection{Semantics}

\begin{align*}
\llbracket - \rrbracket_{-, -}^E &: (\mathsf{LExpr} \times \mathsf{Stack} \times \mathsf{LEnv}) \rightarrow \mathsf{LVal} \\
\llbracket l \rrbracket_{e, s}^E &\triangleq l \\
\llbracket \pvar{x} \rrbracket_{e, s}^E &\triangleq s(\pvar{x}) \\
\llbracket x \rrbracket_{e, s}^E &\triangleq e(x) \\
\llbracket E_1 + E_2 \rrbracket_{e, s}^E &\triangleq \llbracket E_1 \rrbracket_{e, s} + \llbracket E_2 \rrbracket_{e, s} \\
&\vdots
\end{align*}
\begin{align*}
\llbracket \mathtt{false} \rrbracket_{e, s} &\triangleq \emptyset \\
\llbracket \mathtt{true} \rrbracket_{e, s} &\triangleq \mathcal{P}(\mathsf{Storage}) \\
\llbracket \mathtt{emp} \rrbracket_{e, s} &\triangleq \{ (\emptyset, \emptyset) \} \\
\llbracket E_1 = E_2 \rrbracket_{e, s} &\triangleq \bigg\{ \begin{array}{l l}
\mathcal{P}(\mathsf{Storage}) & \text{if } \llbracket E_1 \rrbracket_{e, s} = \llbracket E_2 \rrbracket_{e, s} \\
\emptyset & \text{otherwise}
\end{array} \\
\llbracket E_1 \mapsto E_2 \rrbracket_{e, s} &\triangleq \{ (h, \emptyset)\ |\ \pred{dom}{h} \equiv \{ \llbracket E_1 \rrbracket_{e, s} \} \land h(\llbracket E_1 \rrbracket_{e, s}) = \llbracket E_2 \rrbracket_{e, s} \} \\
\llbracket \boxed{E_1 \mapsto E_2}^r \rrbracket_{e, s} &\triangleq \{ (\emptyset, h)\ |\ \pred{dom}{h} \equiv \{ \llbracket E_1 \rrbracket_{e, s} \} \land h(\llbracket E_1 \rrbracket_{e, s}) = \llbracket E_2 \rrbracket_{e, s} \} \\
\llbracket P \land P' \rrbracket_{e, s} &\triangleq \{ h\ |\ h \in \llbracket P \rrbracket_{e, s} \land h \in \llbracket P' \rrbracket_{e, s} \} \\
\llbracket P \lor P' \rrbracket_{e, s} &\triangleq \{ h\ |\ h \in \llbracket P \rrbracket_{e, s} \lor h \in \llbracket P' \rrbracket_{e, s} \} \\
\llbracket P \sep P' \rrbracket_{e, s} &\triangleq \{ h\ |\ h = h_1 \uplus h_2 \land h_1 \in \llbracket P \rrbracket_{e, s} \land h_2 \in \llbracket P' \rrbracket_{e, s} \} \\
\llbracket P \Rightarrow P' \rrbracket_{e, s} &\triangleq \{ h\ |\ h \in \llbracket P \rrbracket_{e, s} \Rightarrow h \in \llbracket P' \rrbracket_{e, s} \} \\
\llbracket \exists x \ldotp P \rrbracket_{e, s} &\triangleq \llbracket P \rrbracket_{e[x \mapsto v], s}
\end{align*}

\subsection{Proof System}

\[
\infer[\textsc{Assign}]
{
	\vdash \triple
	{P}
	{\passign{\pvar{x}}{E}}
	{\exists x\ldotp P[x/\pvar{x}] \land \pvar{x} = E[x/\pvar{x}]}
}
{}
\]

\[
\infer[\textsc{Read}]
{
	\vdash \triple
	{\cell{E}{n}}
	{\pderef{\pvar{x}}{E}}
	{\pvar{x} = n \land \cell{E}{n}}
}
{}
\]

\[
\infer[\textsc{ReadS}]
{
	\vdash \triple
	{\boxed{\cell{E}{E_r}}^r}
	{\pderef{\pvar{x}}{E}}
	{\pvar{x} = E_r \land \boxed{\cell{E}{E_r}}^r}
}
{}
\]

\[
\infer[\textsc{Write}]
{
	\vdash \triple
	{\cell{E_1}{-}}
	{\pmutate{E_1}{E_2}}
	{\cell{E_1}{E_2}}
}
{}
\]

\[
\infer[\textsc{WriteS}]
{
	\vdash \triple
	{\boxed{\cell{E_1}{-}}^r}
	{\pmutate{E_1}{E_2}}
	{\boxed{\cell{E_1}{E_2}}^r}
}
{}
\]

\[
\infer[\textsc{Alloc}]
{
	\vdash \triple
	{\mathtt{emp}}
	{\palloc{\pvar{x}}{E}}
	{\circledast_{0 \leq i < E}\cell{(\pvar{x} + i)}{0}}
}
{}
\]

\[
\infer[\textsc{AllocS}]
{
	\vdash \triple
	{\mathtt{emp}}
	{\palloc{\pvar{x}}{\mathds{1}}}
	{\exists r \ldotp \boxed{\cell{\pvar{x}}{0}}^r}
}
{}
\]

\[
\infer[\textsc{CmdSeq}]
{
	\vdash \triple
	{P}
	{\mathds{C}_1; \mathds{C}_2}
	{Q}
}
{
	\vdash \triple
	{P}
	{\mathds{C}_1}
	{R}\ \
	\vdash \triple
	{R}
	{\mathds{C}_2}
	{Q}
}
\]

\[
\infer[\textsc{Cond}]
{
	\vdash \triple
	{P}
	{\pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2}}
	{Q}
}
{
	\vdash \triple
	{P \land \mathds{B}}
	{\mathds{C}_1}
	{Q}\ \
	\vdash \triple
	{P \land \lnot \mathds{B}}
	{\mathds{C}_2}
	{Q}
}
\]

\[
\infer[\textsc{Loop}]
{
	\vdash \triple
	{P}
	{\ploop{\mathds{B}}{\mathds{C}}}
	{Q \land \lnot \mathds{B}}
}
{
	\vdash \triple
	{P \land \mathds{B}}
	{\mathds{C}}
	{Q}
}
\]

\[
\infer[\textsc{Trans}]
{
	\vdash \triple
	{P}
	{\mathtt{begin}\ \mathds{C}\ \mathtt{end}}
	{Q}
}
{
	\vdash \triple
	{P}
	{\mathds{C}}
	{Q}
}
\]

\[
\infer[\textsc{Par}]
{
	\vdash \triple
	{P_1 \sep \ldots \sep P_n}
	{\mathds{T}_1 \| \ldots \| \mathds{T}_n}
	{Q}
}
{
	\vdash \triple
	{P_1}
	{\mathds{T}_1}
	{Q_1}\ \
	\ldots\ \
	\vdash \triple
	{P_n}
	{\mathds{T}_n}
	{Q_n}\
	Q = \pred{join}{[Q_1, \ldots, Q_n]}
}
\]

\[
\infer[\textsc{Seq}]
{
	\vdash \triple
	{P}
	{\mathds{P}_1; \mathds{P}_2}
	{Q}
}
{
	\vdash \triple
	{P}
	{\mathds{P}_1}
	{P'}\ \
	\vdash \triple
	{P'}
	{\mathds{P}_2}
	{Q}
}
\]

\[
\infer[\textsc{Lift}]
{
	\vdash \triple
	{p}
	{\mathds{P}}
	{q}
}
{
	(P, t) = \pred{lift}{p}\
	\vdash \triple
	{P}
	{\mathds{P}}
	{Q}\
	q = \pred{apply}{Q, t}
}
\]

\begin{align*}
\mathsf{lift} :&\ \mathsf{Ass} \rightarrow \mathsf{Ass} \times (\mathsf{Key} \rightarrow \mathsf{Expr}) \\
\pred{lift}{\boxed{\mathds{E}_1 \mapsto \mathds{E}_2}^r} \triangleq&\ \left( \boxed{\mathds{E}_1 \mapsto v_r}^r, \emptyset[r \mapsto \mathds{E}_2] \right) \\
\pred{lift}{P \lor P'} \triangleq&\ (p \lor p', t \uplus t') \\
	\text{where }& (p, t) = \pred{lift}{P} \\
		& (p', t') = \pred{lift}{P'} \\
\pred{lift}{P \land P'} \triangleq&\ (p \land p', t \uplus t') \\
	\text{where }& (p, t) = \pred{lift}{P} \\
		& (p', t') = \pred{lift}{P'} \\
\pred{lift}{P \sep P'} \triangleq&\ (p \sep p', t \uplus t') \\
	\text{where }& (p, t) = \pred{lift}{P} \\
		& (p', t') = \pred{lift}{P'} \\
\pred{lift}{P \Rightarrow P'} \triangleq&\ (p \Rightarrow p', t \uplus t') \\
	\text{where }& (p, t) = \pred{lift}{P} \\
		& (p', t') = \pred{lift}{P'} \\
\pred{lift}{\exists x \ldotp P} \triangleq&\ \exists x \ldotp \pred{lift}{P} \\
\pred{lift}{\circledast x \ldotp P} \triangleq&\ \circledast x \ldotp \pred{lift}{P} \\
\pred{lift}{P} \triangleq&\ P
\end{align*}

\begin{align*}
\mathsf{apply} :&\ \mathsf{Ass} \times (\mathsf{Key} \rightarrow \mathsf{Expr}) \rightarrow \mathsf{Ass} \\
\pred{apply}{\boxed{\mathds{E}_1 \mapsto \mathds{E}_2}^r, t} \triangleq&\ \boxed{\mathds{E}_1[\mathds{E}/v_r] \mapsto \mathds{E}_2[\mathds{E}/v_r]}^r \\
\text{where }& \mathds{E} = t(r) \\
\pred{apply}{\pvar{x} = \mathds{E}, t} \triangleq&\ \pvar{x} = \pred{suball}{\mathds{E}, t} \\
\pred{apply}{\mathds{E}_1 \mapsto \mathds{E}_2, t} \triangleq&\ \pred{suball}{\mathds{E}_1, t} \mapsto \pred{suball}{\mathds{E}_2, t} \\
\pred{apply}{Q \lor Q', t} \triangleq&\ \pred{apply}{Q, t} \lor \pred{apply}{Q', t} \\
\pred{apply}{Q \land Q', t} \triangleq&\ \pred{apply}{Q, t} \land \pred{apply}{Q', t} \\
\pred{apply}{Q \sep Q', t} \triangleq&\ \pred{apply}{Q, t} \sep \pred{apply}{Q', t} \\
\pred{apply}{Q \Rightarrow Q', t} \triangleq&\ \pred{apply}{Q, t} \Rightarrow \pred{apply}{Q', t} \\
\pred{apply}{\exists x \ldotp Q, t} \triangleq&\ \exists x \ldotp \pred{apply}{Q, t} \\
\pred{apply}{\circledast x \ldotp Q, t} \triangleq&\ \circledast x \ldotp \pred{apply}{Q, t} \\
\pred{apply}{Q, t} \triangleq&\ Q
\end{align*}

\begin{align*}
\mathsf{suball} :&\ \mathsf{Expr} \times (\mathsf{Key} \rightarrow \mathsf{Expr}) \rightarrow \mathsf{Expr} \\
\pred{suball}{\mathds{E}, \emptyset} \triangleq&\ \mathds{E} \\
\pred{suball}{\mathds{E}, t[r \mapsto \mathds{E}_r]} \triangleq&\ \pred{suball}{\mathds{E}, t}[\mathds{E}_r / v_r]
\end{align*}

\begin{align*}
\mathsf{join} :&\ [\mathsf{Ass}] \rightarrow \mathsf{Ass} \\
\pred{join}{Qs} \triangleq&\ \pred{fold}{\lor, qs} \\
	\text{where }& ts = \pred{map}{\lambda q \ldotp (q, \pred{fingerprint}{q}), Qs} \\
		& perms = \pred{permutations}{ts} \\
		& qs = \pred{map}{\mathsf{combine}, perms} \\
\end{align*}

\begin{align*}
\mathsf{combine} :&\ [\mathsf{Ass}] \rightarrow \mathsf{Ass} \\
\pred{combine}{[]} \triangleq&\ \mathtt{false} \\
\pred{combine}{[q]} \triangleq&\ \mathtt{false} \\
\pred{combine}{p : ps} \triangleq&\ \pred{update}{p, ps}
\end{align*}

\begin{align*}
\mathsf{fingerprint} :&\ \mathsf{Ass} \rightarrow (\mathsf{Key} \rightarrow \mathsf{Expr}) \\
\pred{fingerprint}{\boxed{\mathds{E}_1 \mapsto \mathds{E}_2}^r} \triangleq&\ \emptyset[r \mapsto \mathds{E}_2] \\
\pred{fingerprint}{Q \lor Q'} \triangleq&\ \pred{fingerprint}{Q} \uplus \pred{fingerprint}{Q'} \\
\pred{fingerprint}{Q \land Q'} \triangleq&\ \pred{fingerprint}{Q} \uplus \pred{fingerprint}{Q'} \\
\pred{fingerprint}{Q \sep Q'} \triangleq&\ \pred{fingerprint}{Q} \uplus \pred{fingerprint}{Q'} \\
\pred{fingerprint}{Q \Rightarrow Q'} \triangleq&\ \pred{fingerprint}{Q} \uplus \pred{fingerprint}{Q'} \\
\pred{fingerprint}{\exists x \ldotp Q} \triangleq&\ \exists x \ldotp \pred{fingerprint}{Q} \\
\pred{fingerprint}{\circledast x \ldotp Q} \triangleq&\ \circledast x \ldotp \pred{fingerprint}{Q} \\
\pred{fingerprint}{Q} \triangleq&\ \emptyset
\end{align*}

\iffalse
\begin{gather*}
\color{blue} \left\lbrace \boxed{\pvar{a} \mapsto 0}^r \right\rbrace \\
\color{blue} \left\lbrace \boxed{\pvar{a} \mapsto v_r}^r \right\rbrace \\
\begin{array}{c || c}
\begin{array}{l}
\color{blue} \left\lbrace \boxed{\pvar{a} \mapsto v_r}^r \right\rbrace \\
\pderef{\pvar{x}}{\pvar{a}}; \\
\pmutate{\pvar{a}}{\pvar{x} + 1} \\
\color{blue} \left\lbrace \boxed{\pvar{a} \mapsto v_r + 1}^r \right\rbrace
\end{array}
&
\begin{array}{l}
\color{blue} \left\lbrace \boxed{\pvar{a} \mapsto v_r}^r \right\rbrace \\
\pmutate{\pvar{a}}{2} \\
\color{blue} \left\lbrace \boxed{\pvar{a} \mapsto 2}^r \right\rbrace
\end{array}
\end{array} \\
\color{blue} \left\lbrace \boxed{\pvar{a} \mapsto 2 \lor \pvar{a} \mapsto 3}^r \right\rbrace
\end{gather*}

\begin{gather*}
\color{blue} \left\lbrace \boxed{\pvar{a} \mapsto 0}^r \right\rbrace \\
\begin{array}{c || c || c}
\begin{array}{l}
\color{blue} \left\lbrace \pvar{a} \mapsto n_r \right\rbrace \\
\pderef{\pvar{x}}{\pvar{a}}; \\
\pmutate{\pvar{a}}{\pvar{x} + 1} \\
\color{blue} \left\lbrace \pvar{a} \mapsto n_r + 1 \right\rbrace
\end{array}
&
\begin{array}{l}
\color{blue} \left\lbrace \pvar{a} \mapsto n_r \right\rbrace \\
\pmutate{\pvar{a}}{2} \\
\color{blue} \left\lbrace \pvar{a} \mapsto 2 \right\rbrace
\end{array}
&
\begin{array}{l}
\color{blue} \left\lbrace \pvar{a} \mapsto n_r \right\rbrace \\
\pmutate{\pvar{a}}{5} \\
\color{blue} \left\lbrace \pvar{a} \mapsto 5 \right\rbrace
\end{array}
\end{array} \\
\color{blue} \left\lbrace \boxed{\pvar{a} \mapsto 2 \lor \pvar{a} \mapsto 3 \lor \pvar{a} \mapsto 5 \lor \pvar{a} \mapsto 6}^r \right\rbrace
\end{gather*}
\fi