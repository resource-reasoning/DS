\section{Serializable Semantics}

\[
(-, -) \rightarrow (-, -) : (\mathsf{Storage} \times \mathsf{Prog})^2
\]

\[
\infer[\textsc{SerTrans}]
{
	(h, \mathds{T}_\iota) \rightarrow (h', \pskip)
}
{
	(h, \mathds{T}_\iota) \overset{\textsc{t}}{\rightarrow} (h', \mathtt{begin}\ \pskip\ \mathtt{end}_\iota)
}
\]

\[
\infer[\textsc{SerPSkip}]
{
	(h, \pskip ; \mathds{P}) \rightarrow (h, \mathds{P})
}
{}
\]

\[
\infer[\textsc{SerPSeq}]
{
	(h, \mathds{P}_1 ; \mathds{P}_2) \rightarrow (h', \mathds{P}_1' ; \mathds{P}_2)
}
{
	(h, \mathds{P}_1) \rightarrow (h', \mathds{P}_1')
}
\]

\[
\infer[\textsc{SerPar}]
{
	(h, \pskip \| \pskip) \rightarrow (h, \pskip)
}
{}
\]

\[
\infer[\textsc{SerParL}]
{
	(h, \mathds{P}_1 \| \mathds{P}_2) \rightarrow (h', \mathds{P}_1' \| \mathds{P}_2)
}
{
	(h, \mathds{P}_1) \rightarrow (h', \mathds{P}_1')
}
\]

\[
\infer[\textsc{SerParR}]
{
	(h, \mathds{P}_1 \| \mathds{P}_2) \rightarrow (h', \mathds{P}_1 \| \mathds{P}_2')
}
{
	(h, \mathds{P}_2) \rightarrow (h', \mathds{P}_2')
}
\]

\[
\infer[\textsc{SerLoop}]
{
	(h, \mathds{P}^*)
	\rightarrow
	(h, \pskip + (\mathds{P} ; \mathds{P}^*))
}
{}
\]

\[
\infer[\textsc{SerChoiceL}]
{
	(h, \mathds{P}_1 + \mathds{P}_2)
	\rightarrow
	(h, \mathds{P}_1)
}
{}
\]

\[
\infer[\textsc{SerChoiceR}]
{
	(h, \mathds{P}_1 + \mathds{P}_2)
	\rightarrow
	(h, \mathds{P}_2)
}
{}
\]

\[
(-, -) \overset{\textsc{t}}{\rightarrow} (-, -) : (\mathsf{Storage} \times \mathsf{Trans})^2
\]

\[
\infer[\textsc{SerExec}]
{
	(h, \mathtt{begin}\ \mathds{C}\ \mathtt{end}_\iota) \overset{\textsc{t}}{\rightarrow} (h', \mathtt{begin}\ \pskip\ \mathtt{end}_\iota)
}
{
	(h, \emptyset, \mathds{C}) \overset{\textsc{c}}{\rightarrow}^* (h', -, \pskip)
}
\]

\[
(-, -, -) \overset{\textsc{c}}{\rightarrow} (-, -, -) : (\mathsf{Storage} \times \mathsf{Stack} \times \mathsf{Cmd})^2
\]

\[
\infer[\textsc{SerAssign}]
{
	(h, s, \passign{\pvar{x}}{\mathds{E}})
	\overset{\textsc{c}}{\rightarrow}
	(h, s[\pvar{x} \mapsto v], \pskip)
}
{
	v = \llbracket \mathds{E} \rrbracket_s
}
\]

\[
\infer[\textsc{SerCondT}]
{
	(h, s, \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2})
	\overset{\textsc{c}}{\rightarrow}
	(h, s, \mathds{C}_1)
}
{
	\llbracket \mathds{B} \rrbracket_s^B = \top
}
\]

\[
\infer[\textsc{SerCondF}]
{
	(h, s, \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2})
	\overset{\textsc{c}}{\rightarrow}
	(h, s, \mathds{C}_2)
}
{
	\llbracket \mathds{B} \rrbracket_s^B = \bot
}
\]

\[
\infer[\textsc{SerLoopT}]
{
	(h, s, \ploop{\mathds{B}}{\mathds{C}})
	\overset{\textsc{c}}{\rightarrow}
	(h, s, \mathds{C}; \ploop{\mathds{B}}{\mathds{C}})
}
{
	\llbracket \mathds{B} \rrbracket_s^B = \top
}
\]

\[
\infer[\textsc{SerLoopF}]
{
	(h, s, \ploop{\mathds{B}}{\mathds{C}})
	\overset{\textsc{c}}{\rightarrow}
	(h, s, \pskip)
}
{
	\llbracket \mathds{B} \rrbracket_s^B = \bot
}
\]

\[
\infer[\textsc{SerSkip}]
{
	(h, s, \pskip ; \mathds{C})
	\overset{\textsc{c}}{\rightarrow}
	(h, s, \mathds{C})
}
{}
\]

\[
\infer[\textsc{SerSeq}]
{
	(h, s, \mathds{C}_1 ; \mathds{C}_2)
	\overset{\textsc{c}}{\rightarrow}
	(h', s', \mathds{C}_1' ; \mathds{C}_2)
}
{
	(h, s, \mathds{C}_1)
	\overset{\textsc{c}}{\rightarrow}
	(h', s',\mathds{C}_1')
}
\]

\[
\infer[\textsc{SerAlloc}]
{
	(h, s, \palloc{\pvar{x}}{\mathds{E}})
	\overset{\textsc{c}}{\rightarrow}
	(h[l \mapsto 0] \ldots [l + n - 1 \mapsto 0], s[\pvar{x} \mapsto l], \pskip)
}
{
	n = \llbracket \mathds{E} \rrbracket_s\ \
	l, \ldots, l + n - 1 \not\in \pred{dom}{h}
}
\]

\[
\infer[\textsc{SerRead}]
{
	(h, s, \pderef{\pvar{x}}{\mathds{E}})
	\overset{\textsc{c}}{\rightarrow}
	(h, s[\pvar{x} \mapsto v], \pskip)
}
{
	k = \llbracket \mathds{E} \rrbracket_s\ \
	k \in \pred{dom}{h}\ \
	v = h(k)
}
\]

\[
\infer[\textsc{SerWrite}]
{
	(h, s, \pmutate{\mathds{E}_1}{\mathds{E}_2})
	\overset{\textsc{c}}{\rightarrow}
	(h[k \mapsto v], s, \pskip)
}
{
	k = \llbracket \mathds{E}_1 \rrbracket_s\ \
	k \in \pred{dom}{h}\ \
	v = \llbracket \mathds{E}_2 \rrbracket_s
}
\]
