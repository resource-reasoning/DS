\section{Atomic Semantics}

\[
(-, -) \rightarrow (-, -) : (\mathsf{Storage} \times \mathsf{Prog})^2
\]

\[
\infer[\textsc{AtTrans}]
{
	(h, \mathds{T}) \rightarrow (h', \pskip)
}
{
	(h, \mathds{T}) \rightarrow_\textsc{t} (h', \mathtt{begin}\ \pskip\ \mathtt{end}_\iota)
}
\]

\[
\infer[\textsc{AtPSkip}]
{
	(h, \pskip ; \mathds{P}) \rightarrow (h, \mathds{P})
}
{}
\]

\[
\infer[\textsc{AtPSeq}]
{
	(h, \mathds{P}_1 ; \mathds{P}_2) \rightarrow (h', \mathds{P}_1' ; \mathds{P}_2)
}
{
	(h, \mathds{P}_1) \rightarrow (h', \mathds{P}_1')
}
\]

\[
\infer[\textsc{AtPar}]
{
	(h, \pskip \| \pskip) \rightarrow (h, \pskip)
}
{}
\]

\[
\infer[\textsc{AtParL}]
{
	(h, \mathds{P}_1 \| \mathds{P}_2) \rightarrow (h', \mathds{P}_1' \| \mathds{P}_2)
}
{
	(h, \mathds{P}_1) \rightarrow (h', \mathds{P}_1')
}
\]

\[
\infer[\textsc{AtParR}]
{
	(h, \mathds{P}_1 \| \mathds{P}_2) \rightarrow (h', \mathds{P}_1 \| \mathds{P}_2')
}
{
	(h, \mathds{P}_2) \rightarrow (h', \mathds{P}_2')
}
\]

\[
\infer[\textsc{AtLoop}]
{
	(h, \mathds{P}^*)
	\rightarrow
	(h, \pskip + (\mathds{P} ; \mathds{P}^*))
}
{}
\]

\[
\infer[\textsc{AtChoiceL}]
{
	(h, \mathds{P}_1 + \mathds{P}_2)
	\rightarrow
	(h, \mathds{P}_1)
}
{}
\]

\[
\infer[\textsc{AtChoiceR}]
{
	(h, \mathds{P}_1 + \mathds{P}_2)
	\rightarrow
	(h, \mathds{P}_2)
}
{}
\]

\[
(-, -) \rightarrow_\textsc{t} (-, -) : (\mathsf{Storage} \times \mathsf{Trans})^2
\]

\[
\infer[\textsc{AtStart}]
{
	(h, \mathtt{begin}\ \mathds{C}\ \mathtt{end})
	\rightarrow_\textsc{t}
	(h', \mathtt{begin}\ \pskip\ \mathtt{end})
}
{
	\iota = \pred{freshId}{} &
	(h, \mathtt{begin}\ \mathds{C}\ \mathtt{end}_\iota)
	\rightarrow_\textsc{t}
	(h', \mathtt{begin}\ \pskip\ \mathtt{end}_\iota)
}
\]

\[
\infer[\textsc{AtExec}]
{
	(h, \mathtt{begin}\ \mathds{C}\ \mathtt{end}_\iota)
	\rightarrow_\textsc{t}
	(h', \mathtt{begin}\ \pskip\ \mathtt{end}_\iota)
}
{
	(h, \emptyset, \mathds{C})
	\rightarrow_\textsc{c}^*
	(h', -, \pskip)
}
\]

\[
(-, -, -) \rightarrow_\textsc{c} (-, -, -) : (\mathsf{Storage} \times \mathsf{Stack} \times \mathsf{Cmd})^2
\]

\[
\infer[\textsc{AtAssign}]
{
	(h, s, \passign{\pvar{x}}{\mathds{E}})
	\rightarrow_\textsc{c}
	(h, s[\pvar{x} \mapsto v], \pskip)
}
{
	v = \llbracket \mathds{E} \rrbracket_s
}
\]

\[
\infer[\textsc{AtCondT}]
{
	(h, s, \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2})
	\rightarrow_\textsc{c}
	(h, s, \mathds{C}_1)
}
{
	\llbracket \mathds{B} \rrbracket_s^B = \top
}
\]

\[
\infer[\textsc{AtCondF}]
{
	(h, s, \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2})
	\rightarrow_\textsc{c}
	(h, s, \mathds{C}_2)
}
{
	\llbracket \mathds{B} \rrbracket_s^B = \bot
}
\]

\[
\infer[\textsc{AtLoopT}]
{
	(h, s, \ploop{\mathds{B}}{\mathds{C}})
	\rightarrow_\textsc{c}
	(h, s, \mathds{C}; \ploop{\mathds{B}}{\mathds{C}})
}
{
	\llbracket \mathds{B} \rrbracket_s^B = \top
}
\]

\[
\infer[\textsc{AtLoopF}]
{
	(h, s, \ploop{\mathds{B}}{\mathds{C}})
	\rightarrow_\textsc{c}
	(h, s, \pskip)
}
{
	\llbracket \mathds{B} \rrbracket_s^B = \bot
}
\]

\[
\infer[\textsc{AtSkip}]
{
	(h, s, \pskip ; \mathds{C})
	\rightarrow_\textsc{c}
	(h, s, \mathds{C})
}
{}
\]

\[
\infer[\textsc{AtSeq}]
{
	(h, s, \mathds{C}_1 ; \mathds{C}_2)
	\rightarrow_\textsc{c}
	(h', s', \mathds{C}_1' ; \mathds{C}_2)
}
{
	(h, s, \mathds{C}_1)
	\rightarrow_\textsc{c}
	(h', s',\mathds{C}_1')
}
\]

\[
\infer[\textsc{AtAlloc}]
{
	(h, s, \palloc{\pvar{x}}{\mathds{E}})
	\rightarrow_\textsc{c}
	(h[l \mapsto 0] \ldots [l + n - 1 \mapsto 0], s[\pvar{x} \mapsto l], \pskip)
}
{
	n = \llbracket \mathds{E} \rrbracket_s\ \
	l, \ldots, l + n - 1 \not\in \pred{dom}{h}
}
\]

\[
\infer[\textsc{AtRead}]
{
	(h, s, \pderef{\pvar{x}}{\mathds{E}})
	\rightarrow_\textsc{c}
	(h, s[\pvar{x} \mapsto v], \pskip)
}
{
	k = \llbracket \mathds{E} \rrbracket_s\ \
	k \in \pred{dom}{h}\ \
	v = h(k)
}
\]

\[
\infer[\textsc{AtWrite}]
{
	(h, s, \pmutate{\mathds{E}_1}{\mathds{E}_2})
	\rightarrow_{\textsc{c}}
	(h[k \mapsto v], s, \pskip)
}
{
	k = \llbracket \mathds{E}_1 \rrbracket_s\ \
	k \in \pred{dom}{h}\ \
	v = \llbracket \mathds{E}_2 \rrbracket_s
}
\]