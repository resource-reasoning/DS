\chapter{Introduction}

Modern database systems make heavy use of concurrency to increase performance and therefore to support large scale operations. Programmers access the underlying data through transactions, which are self-contained programs describing a single unit of work. To manage their concurrent executions, database systems employ various techniques depending on the degree of consistency\footnote{Isolation level is usually the terminology adopted for consistency in database systems.} that needs to be guaranteed. This choice has an impact on the performance of the system too. A high-performance database system has to inevitably weaken its consistency model at the cost of allowing the occurrence of anomalous effects. For this reason, in practice, many commercial databases provide a relatively stronger consistency guarantee to release the developers' burden when writing applications that cannot afford such behvaiours.


One of such models is shaped around the idea of serializable executions. Serializability is a strong consistency property that requires the outcome of any schedule of operations, which are grouped by transactions, to be equivalent to a serial one, where transactions are run one after the other. A typical way to implement this consistency model is through pessimistic concurrency control. \textit{Two-phase locking} is a popular concurrency control protocol in this group. It is a blocking approach that works at the granularity of single database entries by assigning a synchronization structure to each of them, so that it can guarantee serializability without losing too much performance.

Out of the many works on reasoning about transactions and the way they are managed, few of them are compositional and work at a program logic level. On the other hand, the area of formal reasoning about shared memory concurrency has seen a noticeable development towards logic frameworks that can verify fine-grained concurrency in a compositional way. In recent years, modern concurrent program logics, based on separation logic, have introduced two fundamental notions of abstraction. The first one, namely data abstraction, makes it possible to give abstract specifications by hiding implementation details, something that is proven to be very useful for compositional reasoning in a client-module setting. Furthermore, time abstraction, also called atomicity, is a property of operations by which they appear to happen at a single and discrete moment in time.

In the world of databases, and more specifically in the context of serializable models, transactions are often coupled with the idea of atomicity, which is very similar to the atomicity in shared memory: to the programmer's eyes, transactions are seen as units of work that get executed in one step. Thus, there is a clear connection between program logics for shared memory concurrency and database transactions. This is why we formulate a program logic to reason about serializable transactions, which we believe it is the first of its kind. The focus is then shifted to an application of our logic to the setting of two-phase locking, where we prove that its semantics conform with the required atomicity. This enables users of the framework to prove the correctness of  programs running in a system that adopts a flavour of this concurrency control protocol, by only having to reason atomically about blocks of code, without the complexity of concurrent interleavings.

\section{Contributions}

The main technical contributions of this project are listed below, with references to the relevant sections where they are further discussed.
\begin{itemize}
	\item \textbf{mCAP} (Section \ref{sec:mcapModel}, \ref{sec:transLogic})\ \ We reformulate and extend a program logic for concurrent programs, namely CAP \cite{cap}, in order to remove some of its constraints, which are hardcoded into the logic, and enable a more flexible reasoning. In fact, we change the underlying model to parametrize both the representation of machine states and of action capabilities. On top of this, we provide a new and cleaner structure for the action model that does not explicitly use interference assertions. We also considerably modify the way environment interference is modelled through the rely/guarantee relations. This is done with the goal of allowing both a thread, and the environment, to perform multiple shared region updates in one step. It follows that the repartitioning operator also has a new and extended behaviour. At the level of the programming language, we leave elementary atomic commands as a parameter to the user of the logic. Finally, we instantiate the mCAP framework into a logic for our particular needs of transactional reasoning.
	
	\item \textbf{\textsc{2pl} Model} (Section \ref{sec:2plMod})\ \ The details of two-phase locking are analysed and ported to a formal model that, through its constructs and structures, is able to describe a transactional software system that uses the protocol and exhibits all of the required behaviours. The main novelties introduced are related to the way we globally manage information related to locking and track the state of running transactions.
	
	\item \textbf{Operational Semantics} (Section \ref{sec:2plSemantics}, \ref{sec:ser})\ \ We use the constructs introduced in the \tpl\ model in order to shape a set of operational semantic rules that formally express the way the protocol acts at runtime. They are provided in a small-step fashion to enable the actual interleaving between concurrent transactions. Locking is implicit and does not occur as part of a language command. Instead, we take a nondeterministic approach to locking, and for this reason the semantics can model any particular pattern of lock acquisitions and releases, as long as it complies with the two-phase rule. The mentioned rules are able to reduce programs while labelling every step of the execution with the appropriate transaction or system operation. We group all such consecutive labels into a trace, which is the main structure used to construct a proof of serializability of the operational semantics as a whole. 
	
	\item \textbf{Semantics Equivalence} (Section \ref{sec:semEquiv})\ \ In order to allow mCAP style reasoning on programs running under \tpl, we are required to prove its soundness with respect to the operational semantics we introduced earlier. This effort is done in two steps, as we first prove the soundness in terms of a baseline operational semantics, which does not allow any interleaving between concurrent transactions by reducing them all at once: it effectively runs transactions atomically, in complete isolation. Then, we show that any reduction that reaches a terminal state in the \tpl\ semantics can be replicated by the atomic one. The latter proof requires a large number of intermediate results and structures which are formally defined, and whose specific properties are proven to be sound.
\end{itemize}
