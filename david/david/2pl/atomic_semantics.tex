\tocless\subsection{Atomic semantics}

\label{sec:atomicSem}

The atomic operational semantics shown here are behaviourally equivalent to the ones presented in Section \ref{sec:mcapOpSem}. They are converted to a transition relation for clarity and in order to ease the general proof, since the \tpl\ semantics are also expressed with a comparable structure.

The rules that follow determine a relation between storages under the effect of a program. At the level of programs, they are very similar to the \tpl\ ones, a part from the absence of a lock manager or a global transactions stack. These two structures are not needed here, since there is no interleaving which happens as a result of running transactions concurrently. For this reason, there is no need to globally track information about a transaction's internal execution. Note how such behaviour is obtained through the \textsc{AtExec} rule, which reduces a transaction's body at once, by running a multi-step reduction on command $\mathds{C}$ until it hits $\pskip$. Parallelism is again obtained by nondeterministically reducing one of the two programs that are composed together.

\[
(-, -) \rightarrow (-, -) : (\mathsf{Storage} \times \mathsf{Prog})^2
\]
\[\footnotesize\def\arraystretch{3.5}
	\begin{array}{c c}
		\infer[\textsc{AtTrans}]
		{
			(h, \mathds{T}) \tred (h', \pskip)
		}
		{
			(h, \mathds{T}) \tred (h', \ptdef{\pskip})
		}
		&
		\infer[\textsc{AtPSkip}]
		{
			(h, \pskip ; \mathds{P}) \tred (h, \mathds{P})
		}
		{}
		\\
		\infer[\textsc{AtPSeq}]
		{
			(h, \mathds{P}_1 ; \mathds{P}_2) \tred (h', \mathds{P}_1' ; \mathds{P}_2)
		}
		{
			(h, \mathds{P}_1) \tred (h', \mathds{P}_1')
		}
		&
		\infer[\textsc{AtPar}]
		{
			(h, \pskip \| \pskip) \tred (h, \pskip)
		}
		{}
		\\
		\infer[\textsc{AtParL}]
		{
			(h, \mathds{P}_1 \| \mathds{P}_2) \tred (h', \mathds{P}_1' \| \mathds{P}_2)
		}
		{
			(h, \mathds{P}_1) \tred (h', \mathds{P}_1')
		}
		&
		\infer[\textsc{AtParR}]
		{
			(h, \mathds{P}_1 \| \mathds{P}_2) \tred (h', \mathds{P}_1 \| \mathds{P}_2')
		}
		{
			(h, \mathds{P}_2) \tred (h', \mathds{P}_2')
		}
		\\
		\infer[\textsc{AtChoiceL}]
		{
			(h, \mathds{P}_1 + \mathds{P}_2)
			\tred
			(h, \mathds{P}_1)
		}
		{}
		&
		\infer[\textsc{AtChoiceR}]
		{
			(h, \mathds{P}_1 + \mathds{P}_2)
			\tred
			(h, \mathds{P}_2)
		}
		{}
		\\
		\infer[\textsc{AtLoop}]
		{
			(h, \mathds{P}^*)
			\tred
			(h, \pskip + (\mathds{P} ; \mathds{P}^*))
		}
		{}
		&
		\infer[\textsc{AtExec}]
		{
			(h, \ptdef{\mathds{C}})
			\tred
			(h', \ptdef{\pskip})
		}
		{
			(h, \emptyset, \mathds{C})
			\tred^*
			(h', -, \pskip)
		}
	\end{array}
\]

The atomic operational semantics of commands are defined through the rules that follow. They show the reduction of a command when executed on a storage $h$ and variable stack $s$. The rules are equivalent to the \tpl\ ones but, given the atomic setting, there is no need for a state component that determines the phase of a transaction as the process of locking is entirely absent. From this, it follows that there are no rules concerned with locking and unlocking either, since under the atomic semantics, transactions run in concrete and real isolation without the need to be managed when accessing storage cells.

\[
(-, -, -) \tred (-, -, -) : (\mathsf{Storage} \times \mathsf{Stack} \times \mathsf{Cmd})^2
\]
\[\footnotesize\def\arraystretch{3.5}
	\begin{array}{@{\hspace*{-4pt}} c @{\hspace{2pt}} c @{}}
		\infer[\textsc{AtSkip}]
		{
			(h, s, \pskip ; \mathds{C})
			\tred
			(h, s, \mathds{C})
		}
		{}
		&
		\infer[\textsc{AtCondT}]
		{
			(h, s, \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2})
			\tred
			(h, s, \mathds{C}_1)
		}
		{
			\tsem{\mathds{B}}^\textsc{b}_s = \top
		}
		\\
		\infer[\textsc{AtSeq}]
		{
			(h, s, \mathds{C}_1 ; \mathds{C}_2)
			\tred
			(h', s', \mathds{C}_1' ; \mathds{C}_2)
		}
		{
			(h, s, \mathds{C}_1)
			\tred
			(h', s',\mathds{C}_1')
		}
		&
		\infer[\textsc{AtWrite}]
		{
			(h, s, \pmutate{\mathds{E}_1}{\mathds{E}_2})
			\tred
			(h[k \mapsto v], s, \pskip)
		}
		{
			k = \tsem{\mathds{E}_1}_s^\textsc{e} &
			k \in \pred{dom}{h} &
			v = \tsem{\mathds{E}_2}_s^\textsc{e}
		}
		\\
		\infer[\textsc{AtAssign}]
		{
			(h, s, \passign{\pvar{x}}{\mathds{E}})
			\tred
			(h, s[\pvar{x} \mapsto v], \pskip)
		}
		{
			v = \tsem{\mathds{E}}_s^\textsc{e}
		}
		&
		\infer[\textsc{AtLoopF}]
		{
			(h, s, \ploop{\mathds{B}}{\mathds{C}})
			\tred
			(h, s, \pskip)
		}
		{
			\tsem{\mathds{B}}^\textsc{b}_s = \bot
		}
		\\
		\infer[\textsc{AtCondF}]
		{
			(h, s, \pif{\mathds{B}}{\mathds{C}_1}{\mathds{C}_2})
			\tred
			(h, s, \mathds{C}_2)
		}
		{
			\tsem{\mathds{B}}^\textsc{b}_s = \bot
		}
		&
		\infer[\textsc{AtRead}]
		{
			(h, s, \pderef{\pvar{x}}{\mathds{E}})
			\tred
			(h, s[\pvar{x} \mapsto v], \pskip)
		}
		{
			k = \tsem{\mathds{E}}_s^\textsc{e} &
			k \in \pred{dom}{h} &
			v = h(k)
		}
		\\
		\infer[\textsc{AtLoopT}]
		{
			(h, s, \ploop{\mathds{B}}{\mathds{C}})
			\tred
			(h, s, \mathds{C}; \ploop{\mathds{B}}{\mathds{C}})
		}
		{
			\tsem{\mathds{B}}^\textsc{b}_s = \top
		}
	\end{array}
\]
\[\footnotesize
\infer[\textsc{AtAlloc}]
{
	(h, s, \palloc{\pvar{x}}{\mathds{E}})
	\tred
	(h[l \mapsto 0] \ldots [l + n - 1 \mapsto 0], s[\pvar{x} \mapsto l], \pskip)
}
{
	n = \tsem{\mathds{E}}_s^\textsc{e} &
	n > 0 &
	\{ l, \ldots, l + n - 1 \} \cap \pred{dom}{h} \equiv \emptyset
}
\]

Rules for \textsc{Atom} commands differ from the semantics given in Section \ref{sec:transLogicSem}, since they model reaching a faulting state by getting \textit{stuck} and not being able to reduce further, instead of setting the state component to $\lightning$. This is done in a similar way by the \tpl\ operational semantics as well. The overall needed result of equivalence is that any terminating execution of running a program under the \textsc{Atom} semantics can be replicated by the Views' ones. \\

\begin{thm}
	\label{thm:atomViewsProg}
	(\textsc{Atom} to Views).
	\begin{gather*}
		\forall h, h', \mathds{P} \ldotp
		(h, \mathds{P}) \tred^* (h', \pskip)
		\implies \\
		\left(		
			\exists \sigma, \sigma' \ldotp
			\mathds{P}, \sigma \rightarrow^*_{\mathsf{Views}} \pskip, \sigma'
			\land h = \sigma \downarrow_1 \land h' = \sigma' \downarrow_1
		\right)
	\end{gather*}
\end{thm}

We only prove the above in the case of $\mathds{T} \in \mathsf{Prog}$, and therefore for $\mathds{C} \in \mathsf{Cmd}$ and $\hat{\mathds{C}} \in \mathsf{ECmd}$, since the rules for programs $\mathds{P} \neq \mathds{T}$ have the same exact structure as the labelled transition system for the operational semantics presented in Views and therefore inherited by mCAP and our transactional instantiation. The formal proof appears in Lemma \ref{lem:atomViews}.