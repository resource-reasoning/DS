\section{Model}

\label{sec:2plMod}

In fact, under the \textsc{2pl} protocol, all accesses to the shared storage cells must be protected by a corresponding lock. This means that any transaction that needs to read or write a particular cell must be granted an appropriate lock for that same cell. The abstract locks we use, behave in a standard way: depending on the mode, they can have zero, one or more \textit{owners}, i.e. threads that have been granted access to the protected cells.

\begin{defn}
	(Lock modes).
	The set of \emph{lock modes}, $\mathsf{Lock}$, is ranged over by $\kappa, \kappa_1, \ldots, \kappa_n$ and defined as:
	\[
		\mathsf{Lock} \triangleq \{ \textsc{u}, \textsc{s}, \textsc{x} \}
	\]
	The associated strict total order, $>$, is defined in the following way:
	\[
		>\ \triangleq \{ (\textsc{x}, \textsc{u}), (\textsc{x}, \textsc{s}), (\textsc{s}, \textsc{u}) \}
	\]
	The total order $\geq$ on the set $\mathsf{Lock}$ is equivalent to $>$ unioned with all of the reflexive pairs.
\end{defn}
We informally refer to each of the lock mode entries as \textit{unlocked}, \textit{shared} and \textit{exclusive} respectively. This reflects the fact that either no transaction is accessing a cell, one or more transactions are allowed to read the cell's content or a single transaction has been given the permission to write to the cell.

The \textsc{2pl} protocol sets a precise constraint on the pattern of acquisition and release of locks. A transaction $\mathds{T}$'s lifecycle is clearly distinguished between two phases. It initially starts executing in the \textit{growing} phase ($\curlywedge$), where it is free to sequentially acquire locks  for any cell it needs. Once it releases one of the locks it is holding, the transaction enters the \textit{shrinking} phase ($\curlyvee$). Here $\mathds{T}$ is denied any new lock acquisitions while it is allowed to gradually release the locks that are still being held.
\begin{defn}
	(Locking phase).
	 The set of \emph{locking phases}, ranged over by $p$, is defined as:
	 \[
	 	\mathsf{Phase} \triangleq \{ \curlywedge, \curlyvee \}
	 \]
\end{defn}
We sometimes refer to the growing and shirinking phase using \textit{acquiring} and \textit{releasing} phase respectively.

At this point we have all of the ingredients to introduce the other main component of our model, the lock manager. This global structure records the status of all locks on storage cells.

\begin{defn}
	(Lock manager).
	A \emph{lock manager} is defined as a total function with a finite domain from storage keys to pairs of transaction identifiers and lock modes.
	\[
		\mathsf{LMan} \triangleq \mathsf{Key} \xrightarrow{\text{fin}} \mathcal{P}(\mathsf{Tid}) \times \mathsf{Lock}
	\]
	The $\mathsf{LMan}$ set is ranged over by $\Phi, \Phi_1, \ldots, \Phi_n$. In order to cope with the default state of locks associated to keys initially absent from the domain of a lock manager, a total function, $\hat{-}(-) : \mathsf{LMan} \times \mathsf{Key} \rightarrow \mathcal{P}(\mathsf{Tid}) \times \mathsf{Lock}$, is defined as:
	\[
		\hat{\Phi}(k)
			\triangleq
		\begin{cases}
			\Phi(k), & \text{if } k \in \pred{dom}{\Phi} \\
			(\emptyset, \textsc{u}), & \text{otherwise}
		\end{cases}
	\]	
\end{defn}
In fact, every cell starts in the unlocked state with no transaction owning it. We say that a lock manager is \textit{empty} and write it as $\Phi = \emptyset$, if and only if all of the keys in its domain are mapped to locks with no owners. Formally:
	\[
		\Phi = \emptyset \iff \forall k \in \pred{dom}{\Phi} \ldotp (\emptyset, \textsc{u}) = \Phi(k)
	\]

We keep track of each transaction's stack and locking phase inside of another global structure which we call the transactions state.
\begin{defn}
	(Transactions state).
	The \emph{state} of all transactions running as part of a program is defined as a total function with a finite domain:
	\[
		\mathsf{TState} \triangleq \mathsf{Tid} \rightharpoonup \mathsf{Stack} \times \mathsf{Phase}
	\]
	Elements of $\mathsf{TState}$ are ranged over by $S, S_1, \ldots, S_n$. Another total function is also defined, $\hat{-}(-) : \mathsf{TState} \times \mathsf{Tid} \rightarrow \mathsf{Stack} \times \mathsf{Phase}$. Such function overrides the original function lookup in order to cope with newly created transactions with an empty stack starting in the growing phase.
	\[
		\hat{S}(\iota)
			\triangleq
		\begin{cases}
			S(\iota), & \text{if } \iota \in \pred{dom}{S} \\
			(\emptyset, \curlywedge), & \text{otherwise}
		\end{cases}
	\]	
\end{defn}