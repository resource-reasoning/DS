\section{Task}

Basically we just write down some random ideas here.

\subsection{Logic}

\subsubsection{CAP}
We can adopt most of the rules from CAP, if you decide to use CAP, but change the atomic rule in CAP to one that deals with a transaction.
The follow is a sketch proof what we might have:
\[
    \begin{session}
        \specline{ \boxass{ \vx \pointsto 0 \sep \vy \pointsto 0 }{r}{I} \sep \perm{xyTo1} \sep \perm{xyTo2} } \\
        \begin{parl}
            \begin{session}
                \specline{ \boxass{ \vx \pointsto 0 \sep \vy \pointsto 0 \lor {} \\ \vx \pointsto 2 \sep \vy \pointsto 2 }{r}{I} \sep \perm{xyTo1} } \\
                \begin{transaction}
                    \specline{ \vx \pointsto 0 \sep \vy \pointsto 0 \lor {} \\ \vx \pointsto 2 \sep \vy \pointsto 2 } \\
                    \pmutate{\vx}{1} ; \\
                    \pmutate{\vy}{1} ; \\
                    \specline{ \vx \pointsto 1 \sep \vy \pointsto 1 } \\
                \end{transaction} \\
                \specline{ \boxass{ \vx \pointsto 1 \sep \vy \pointsto 1 \lor {} \\ \vx \pointsto 2 \sep \vy \pointsto 2 }{r}{I} \sep \perm{xyTo1} } \\
            \end{session} &
            \begin{session}
                \specline{ \boxass{ \vx \pointsto 0 \sep \vy \pointsto 0 \lor {} \\ \vx \pointsto 1 \sep \vy \pointsto 1 }{r}{I} \sep \perm{xyTo2} } \\
                \begin{transaction}
                    \specline{ \vx \pointsto 0 \sep \vy \pointsto 0 \lor {} \\ \vx \pointsto 1 \sep \vy \pointsto 1 } \\
                    \pmutate{\vx}{2} ; \\
                    \pmutate{\vy}{2} ; \\
                    \specline{ \vx \pointsto 2 \sep \vy \pointsto 2 } \\
                \end{transaction} \\
                \specline{ \boxass{ \vx \pointsto 1 \sep \vy \pointsto 1 \lor {} \\ \vx \pointsto 2 \sep \vy \pointsto 2 }{r}{I} \sep \perm{xyTo2} } \\
            \end{session} \\
        \end{parl} \\
        \specline{ \boxass{ \vx \pointsto 1 \sep \vy \pointsto 1 \lor \vx \pointsto 2 \sep \vy \pointsto 2 }{r}{I} \sep \perm{xyTo1} \sep \perm{xyTo2} } \\
    \end{session}
\]
Note that there is no concurrency inside transactions, due to the fact that under any version of two-phase-locking, the observable behaviour of transactions should satisfies serialisability, therefore in the logic level, one are able to think that a transaction locks everything in beginning and unlock in the end.

\subsubsection{CoLoSL}
Another option is extend CoLoSL, which has slightly different reasoning technique, but not very different from CAP in term of logic side.
The difference is how to prove the logic is sound.

\subsection{Model}
Here, we need a general model for 2PL by extending your model, and prove the model is serialisable.
The general idea is to have a non-deterministic lock and unlock.

\subsubsection{Non-deterministic Lock in Semantics\label{sec:non-deter-lock}}
We can generalise the model by adding non-deterministic locking.
For instance, assume the lock environment \( \Phi \), which is a partial function from locations to locks informations, we can have non-deterministic locking rule:
\[
    \infer{%
        \hp, \stk, \Phi, \cmd \leadsto \hp, \stk, \Phi', \cmd
    }{%
        (\loc, \texttt{typeOfLock}) \in \func{needTolock}(\cmd) \quad \Phi' = lock \ the \ \loc \ in \  \Phi
    }
\]
You need to define the function \( \func{needTolock} \) to extract all the locks needed, which is similar to how the function \( \func{freeVariable} \) is defined.
Also you can reuse the lock environment you had, i.e.\ \( \Phi \) (I forget the detail so only put words in the rule).

Then for the read and write, the rules are straightforward:
\[
    \infer{%
        \hp, \stk, \Phi, \pmutate{\var}{\expr} \leadsto \hp\remapsto{\loc}{\val}, \stk, \Phi, \pskip
    }{%
        \var \in \dom(\hp) \quad
        \eval{\expr}_{\stk} = \val \quad
        \eval{\var}_{\stk} = \loc \quad
        \Phi(\loc) \ has \ the \ lock \ needed
    }
\]
Note that in the premiss of the mutation, the rule requires that one should hold the lock.

The idea of this semantics is non-deterministic locking and unlocking.
So if the code of a transaction, says \( \cmd \), is successfully reduced to \( \pskip \), every possible trace is a valid 2PL trace.
Given this semantics, we still need to prove serialisability.
This means every trace produced by the semantics, if we ignore the locking part, is a serialisable trace.

\subsubsection{Inject Lock}
Another options suggested by Azalea is for a code \( \cmd \), we inject arbitrary explicit lock commands and only give the semantics to the injected version.
For instance, assume we have the follows:
\[
    C \equiv \pmutate{\vx}{2} ;\  \pmutate{\vy}{2} ;\  \pderef{\vtmp}{\vz}
\]
We can define a function, says \( \func{injectLock} \), and this function produces all possible programs with correct injected locks, for example:
\[
    \begin{array}{@{}l@{}}
        C_1 \equiv lk(\vx, w);\ lk(\vy,w);\ lk(\vz,r);\ \pmutate{\vx}{2};\ \pmutate{\vy}{2};\ \pderef{\vtmp}{\vz};\ ulk(\vx, w);\ ulk(\vy,w);\ ulk(\vz,r); \\
        C_2 \equiv lk(\vx, w);\ \pmutate{\vx}{2};\ lk(\vy,w);\ lk(\vz,r);\ \pmutate{\vy}{2};\ \pderef{\vtmp}{\vz};\ ulk(\vx, w);\ ulk(\vy,w);\ ulk(\vz,r); \\
        C_3 \equiv lk(\vx, w);\ lk(\vy,w);\ lk(\vz,r);\ \pmutate{\vx}{2};\ ulk(\vx, w);\ \pmutate{\vy}{2};\ ulk(\vy,w);\ \pderef{\vtmp}{\vz};\ ulk(\vz,r); \\
        ... \\
    \end{array} 
\]

The semantics for lock is straightforward:
\[
    \infer{%
        \hp, \stk, \Phi, lk(\vx,\texttt{typeOfLock}) \leadsto \hp, \stk, \Phi', \cmd
    }{%
        \Phi' = lock \ the \ \vx \ in \  \Phi
    }
\]
The read and write rules are similar as in Sect.\ \ref{sec:non-deter-lock}.

Now what we need to proof is for all injected version \( C_i \in \func{injectLock}(C) \), the inject version can be reduced to \( \pskip \) and similarly the trace is serialisable.

\subsection{Soundness}
This is also a challenging part, but we can discuss later.
It will depends on what type of logic and models you want to work with.

\subsection{Few comments}
\begin{itemize}
    \item Please email us if you find something difficult. :)
    \item Put all your files inside the dir David, so we can easily trace down. You can use my macro if you like to, you can find `macro.tex' and `env.tex' in the root dir of the DS repo.
    \item Define notations you like as long as they are consistent.
    \item If you want to, give some explanation when you do formalisation. This might help you.
    \item We try to give some initial ideas, but you are totally free to pick other similar things.
\end{itemize}
