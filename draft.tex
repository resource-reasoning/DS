\documentclass[runningheads]{llncs}


\newif\ifNonESOPMode
\NonESOPModefalse

\input{env.tex}
\usepackage{hhmacros}
\input{tikzsetting.tex}
\PassOptionsToPackage{svgnames}{xcolor}
\definecolor{DarkGreen}{rgb}{0, 0.5, 0}

\usepackage{amsmath}
\usepackage{mathrsfs}  
\usepackage{marvosym}
\usepackage{wrapfig}
\usepackage{enumerate}


%\newcommand*{\newextarrow}[3] {%
%\newcommand*{#1}[2][]{\ext@arrow #2{\arrowfill@#3}{##1}{##2}} }
%
\newextarrow{\xrightarrowtriangle}{{20}{20}{20}{20}}
   {{\relbar}{\relbar}{\rightarrowtriangle}}
   
%\newextarrow{\xleadsto}{{20}{20}{20}{20}}
%   {{}{\sim}{\rangle}}
%\def\leadstofill@{\arrowfill@\relbar\relbar\leadsto}
%\newcommand{\xleadsto}[2][]{\ext@arrow 0359\leadstofill@{#1}{#2}}
 
\newextarrow{\xleadsto}{{20}{20}{20}{20}}
   {{}{\sim}{\succ}} 
   
\renewcommand{\toLTS}[1]{\ensuremath{\xleadsto{\hspace{-10pt}#1}}}

%\newextarrow{\xrightharpoonup}{{20}{20}{20}{20}}
%   {{\relbar}{\relbar}{\rightharpoonup}}
   
\renewcommand{\parfinfun}{\ensuremath{\xrightharpoonup{\halfMath{fin}}}}

%%%%%%%%%%%%%%%%%%%%%% edit mode
\newif\ifCommentEdits
%\CommentEditstrue
\CommentEditsfalse
\input{comment-box.tex}
%%%%%%%%%%%%%%%%%%%%%% end edit mode



\begin{document}



%% Title information
\title{
	Towards a Formal Theory for Clients of Distributed Key-value Stores
    %Operational Semantics and Logic for Weak Consistency in Transactional Systems%
    %: a Multi-version Based Operational Approach
    } 


\author{Shale Xiong\inst{1}\orcidID{0000-1111-2222-3333} \and
Andrea Cerone\inst{1}\orcidID{1111-2222-3333-4444} \and
Azalea Raad\inst{2}\orcidID{2222--3333-4444-5555} \and
Philippa Gardner\inst{1}\orcidID{1111-2222-3333-4444} }
%
\authorrunning{F. Author et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{Imperial College London  \\
\email{\{shale.xiong14, a.cerone, p.gardner\}@imperial.ac.uk} \and
Max Planck institutes \\
\email{a.raad@mpi-sws.org}   
}


\maketitle

\begin{abstract}
Modern NoSQL databases (e.g. key-value stores) achieve scalability and improve 
latency by weakening the guarantees of distributed transaction 
processing. While the problem of giving a formal specification to 
the consistency models used by such databases has been widely 
studied, formalising the semantics of clients interacting with 
such systems has been largely neglected$^\ast$. 
This paper aims to be a 
first step towards filling this gap. We present a framework 
for capturing the semantics of programs interacting with a 
weakly consistent key-value store whose transactions enjoy atomic visibility. 
Our semantics enjoys 
atomic transaction processing, interleaving concurrency, 
and parameterisation with respect to the consistency model.  
%The latter is captured using the notion of execution tests, which 
%determine when a transaction is allowed  to execute. 
As a main contribution, we prove that our semantics is adequate: 
for each program and consistency model, the semantics captures 
precisely the behaviour that the program exhibits under said consistency model; 
and that specifications of consistency models in our framework 
coincide with previously proposed, axiomatic ones.
%via execution 
%tests are equivalent to the axiomatic specifications which have already 
%been proved to be correct.
As another contribution, we develop a variant of the \emph{Concurrent 
Abstract Predicates} separation logic
%development 
%of a separation logic for clients of key-value stores. We propose 
%a variant of the \emph{Concurrent Abstract Predicates} 
that is tailored to clients of weakly-consistent key-value stores, 
and that is parametric in the specification of consistency models.
%and a multi-version 
%representation of the key-value store to allow concurrent clients to 
%observe different states of the system.  
%We abstract from implementation details of the key-value store, which 
%is represented as a centralised, multi-version system. This allows 
%for concurrent clients to observe different version of the same key, 
%which makes it possible to capture non-serialisable behaviours of 
%programs while still retaining the atomic execution of transactions and 
%interleaving concurrency. 
%Furthermore, our semantics is parameterised by execution tests, which determine 
%when a transaction is allowed to execute.  By changing the execution 
%test of transactions, we capture different consistency models.

\textbf{$^\ast$ Suresh is going to be pissed off a lot by this sentence, but 
let's be honest, his semantics is light years behind ours.}
\ac{The abstract is wayyyy too long. But at least we have a guideline for the paper.}

%We present a a uniform semantics 
%Contents of this set of notes: 
%History heaps. Semantics of Programs 
%running under weak consistency models using history heaps as states. 
%Simulation technique for comparing weak consistency models defined using 
%history heaps. Verification of implementations.
%\textbf{Points following Dagstuhl: Viktor seemed positive about the 
%history heap work. His question was whether the framework is generic 
%enough to capture the protocols that they are developing with Azalea. 
%Alexey's opinion is that the framework may have some use if we 
%manage to prove implementations of protocols correct. 
%I would also like to have Azalea's opinion on a semantics based 
%on history heaps.}
\end{abstract}

\azalea{I have imported the cleveref package! This means that all reference will be printed consistently and we DO NOT need custom names such as \textbackslash fig etc.
Every time you need to refer to something, please write\textbackslash cref\{label\}, \eg \cref{def:mkvs}, and the label (\eg Def.) will be printed correctly. 
These labels can be customised. I have introduced the necessary ones in the macros file. 
}
\newcommand{\RootPath}{.}
\input{intro.tex}
\input{semantics.tex}
\input{logic.tex}
%\input{example.tex}

\bibliographystyle{splncs04}
\bibliography{bibliography,bibliography2}

%\newpage
\appendix
\input{\RootPath/appendix/dependency-graphs.tex}
\input{\RootPath/appendix/et-comm-updatekv.tex}
\input{\RootPath/appendix/et-comm.tex}
\input{\RootPath/appendix/aexec2kv.tex}
\input{\RootPath/appendix/semantics.tex}
\input{\RootPath/appendix/semanticsresult.tex}
\input{\RootPath/semantics/sound-complete-specs-proof.tex}
\input{\RootPath/appendix/sound-logic.tex}
\end{document}
