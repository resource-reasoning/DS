\section{Formal Model}
\label{sec:model}
\label{sec:semantics}
\ac{I am going to split this section into two, for the sake of clarity. 
As of now, the structure that I have in mind for the paper is as follows: 
Section 2 (i.e. this section) contains the notion of key-value store, view, snapshot, 
execution tests, and consistency model  -i.e. sets of key-value stores- 
induced by an execution test). Then Section 3 discusses 
the semantics of programs, and possibly we state the result 
of adequateness. In Section 4 we discuss the equivalence of consistency 
models specifications with respect to axiomatic ones. In Section 5 
we present the logic and litmus tests examples.}

\begin{wrapfigure}[7]{r}{0.33\textwidth}
\vspace{-10pt}
\begin{verbatim}
interface Transaction {
    Start(); 
    Read(Key k);
    Write(Key k, Value v); 
    Commit();    }
\end{verbatim}
\vspace{-10pt}
\caption{Example of Transaction API.}
\label{fig:api}
\end{wrapfigure}
We focus on an abstract computational model where multiple client programs can access and update keys in a key-value store using atomic transactions. 
In general, clients are provided with a simple \textit{API} such as the one depicted in \cref{fig:api} \cite{gdur,physicsnmsi,clockSI}\footnote{It is 
often the case that key-value stores provide a mechanism to wrap more transactions inside a session, and give 
provide appropriate APIs to handle sessions. For the sake of simplicity, in this paper we assume that each client executes transactions 
within a single session.}, while both the implementation details and the system architecture are hidden from clients. 
Because (distributed) key-value stores only give weak consistency guarantees of the data to their clients, the latter are 
not ensured to read the most up-to-date version of a key.
%In an ideal world, when executing a transaction clients would read the most up-to-date version of a key. In a distributed setting 
%this approach, known as (strict) serialisability, would require a continuous synchronisation between the different components of 
%the system, which impacts performance and limits scalability. To this end, the database only provides weak consistency model
%\ac{This sentence should probably be in the introduction.}

Following these intuitions, we model a key-value stores, or \emph{kv-store}, as a centralised unit where multiple versions 
are stored for each key (\cref{sec:mkvs-view}). Versions consist of a value and the meta-data of the transactions that wrote and 
read such a version. In practical, distributed systems, the meta-data is usually encoded using either timestamps 
\cite{physicsnmsi,clockSI} or vector clocks \cite{gdur}. We focus on key-value stores whose transactions 
enjoy \emph{atomic visibility}, meaning that \textbf{(i)} transactions read their data from an atomic 
snapshot of the key-value store, and \textbf{(ii)} a transaction can observe either none or all 
of the updates performed by another transaction. In other words, a transaction only reads (writes) at most 
one version for each key.
Because clients may observe potentially out-of-date versions of the system, we introduce the notion of \emph{views}. 
Intuitively, a view records the version of each key that a client observes at a given time. We use views 
to determine the snapshot taken by transactions executed by clients.

A consistency model is a contract between the key-value store and its clients. We distinguish 
between \emph{client-centric} consistency models \cite{terry1994session}, 
which impose constraints on the observations and updates made by a single client, 
and \emph{data-centric} consistency models \cite{framework-concur}, which impose constraints 
on the structure of the key value store.
To specify weak consistency models, 
we introduce the notion of \emph{execution tests} (\cref{sec:execution.tests}). An execution test
 specifies when a client is allowed to execute a transaction carrying a given 
set of read and write operations, or \emph{fingerprint}. Therefore, an execution 
test constrains how the state of the key-value store may evolve;
by considering all the possible evolutions of the key-value store under said execution test, 
we determine a consistency model. For example, an execution test for (strict) serialisability 
requires that a transaction can be executed by a client only if it observes the most up-to-date 
version for each key. 
We give several examples of execution tests that capture both client-centric and 
data-centric consistency models. 

The idea of specifying consistency models using execution tests has been 
already proposed in \cite{seebelieve}; however, their notion of execution 
test is intrinsically more complex than ours: to determine 
whether a transaction can commit, the total order in which all past transactions 
have committed must be known. This knowledge is not needed in our setting.
\ac{Some line about how for this reason, our notion of execution test is closer 
to the implementation of commit tests in real database implementations.}
