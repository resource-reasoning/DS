\subsection{Rules for Local}

The proof rules are standard except \rl{TRLookup} and \rl{TRMutate}.
The \rl{TRDeref} rule add read fingerprint in finger-tracking set, only if there is no write finger-print.
This is because once a location has been re-written, the rest read are considered as local operations, while the finger-print only records those operations might have effect on global state.

\begin{figure}[!t]
\hrule\vspace{5pt}
\[
    \infer[\rl{TRSkip}]{%
        \tripleL{\assemp }{ \pskip }{\assemp }
    }{}
\]

\[
    \infer[\rl{TRAss}]{%
        \tripleL{\var \dot= \lexpr }{ \pass{\var}{\expr} }{\var \dot= \expr\sub{\var}{\lexpr} }
    }{
        \var \notin \func{fv}{\lexpr}
    }
\]

\[
    \infer[\rl{TRLookup}]{%
        \tripleL{ \lpre }{ \plookup{\var}{\expr} }{\var \dot= \lexpr \sep \lpost\sub{\var}{\lexpr} }
    }{%
        \var \notin \func{fv}{\lexpr}  
        && \lpre \toFP{\otR(\expr, \lexpr)} \lpost
    }
\]

\[
    \infer[\rl{TRMutate}]{%
        \tripleL{ \lpre }{ \pmutate{\expr_1}{\expr_2} }{ \lpost } 
    }{
        \lpre \toFP{\otW(\expr_{1},\expr_{2})} \lpost
    }
\]

\[
    \infer[\rl{TRAssume}]{%
        \tripleL{ \expr \doteq 0 }{ \passume{\expr} }{ \expr \doteq 0 } 
    }{}
\]

\[
    \infer[\rl{TRReturn}]{%
        \tripleL{ \assemp }{ \preturn{\expr} }{ \ret \doteq \expr } 
    }{}
\]

\[
    \infer[\rl{TRChoice}]{%
        \tripleL{ \lpre }{ \trans_{1} \pchoice \trans_{2} }{ \lpost }
    }{%
        \tripleL{ \lpre }{ \trans_{1} }{ \lpost } && 
        \tripleL{ \lpre }{ \trans_{2} }{ \lpost } 
    }
\]

\[
    \infer[\rl{TRSeq}]{%
        \tripleL{ \lpre }{ \trans_{1} \pseq \trans_{2} }{ \lpost }
    }{%
        \tripleL{ \lpre }{ \trans_{1} }{ \lframe }  && 
        \tripleL{ \lframe }{ \trans_{2} }{ \lpost }
    }
\]


\[
    \infer[\rl{TRLoop}]{%
        \tripleL{ \lpre }{ \trans\prepeat }{ \lpre }
    }{%
        \tripleL{ \lpre }{ \trans }{ \lpre } 
    }
\]
 
\[
   \infer[\rl{TRFrame}]{%
       \tripleL{ \lpre \sep \lframe }{ \trans }{ \lpost \sep \lframe }
   }{%
       \tripleL{ \lpre }{ \trans }{ \lpost } 
        && \func{fv}{\lpre} \cap \func{fv}{\lframe} = \emptyset
        && \func{fv}{\lpost} \cap \func{fv}{\lframe} = \emptyset
   }
\]
\hrule\vspace{5pt}
\sx{The font is a bit overwhelming}
\[
\begin{rclarray}
    \expr \fpI \lexpr& \toFP{\otR(\expr,\lexpr)} & \expr \fpR \lexpr \\
    \expr \fpR \lexpr & \toFP{\otR(\expr,\lexpr)} & \expr \fpR \lexpr \\
    \expr \fpW \lexpr & \toFP{\otR(\expr,\lexpr)} & \expr \fpW \lexpr \\
    \expr \fpRW (\lexpr', \lexpr) & \toFP{\otR(\expr,\lexpr)} & \expr \fpRW (\lexpr', \lexpr) \\
    \expr \fpI \lexpr & \toFP{\otW(\expr,\lexpr')} & \expr \fpW \lexpr' \\
    \expr \fpR \lexpr & \toFP{\otW(\expr,\lexpr')} & \expr \fpRW (\lexpr,\lexpr') \\
    \expr \fpW \lexpr & \toFP{\otW(\expr,\lexpr')} & \expr \fpW \lexpr' \\
    \expr \fpRW (\lexpr'', \lexpr) & \toFP{\otW(\expr,\lexpr')} & \expr \fpRW (\lexpr'', \lexpr') \\
\end{rclarray}
\]
\hrule\vspace{5pt}
\caption{The rules for transactions}
\label{fig:rule-trans}
 \end{figure}

\subsection{Rely and Guarantee}

\sx{To allow a transaction update multiple regions but a region multiple times. Make sure the definition is confluent.}

Regions in a world have disjointed history heaps and views, so we can lift the invariants of regions to a invariant of the entire world.

\begin{defn}[Invariant of the world]
The \emph{invariant of a world} \( \func{inv}{\w}\) is the compositions of all the invariants of regions included.
Given two regions \( \rid, \rid' \) with disjointed history heaps and views, the composition of their invariants \( \func{inv}{\rid,\intf} \compose \func{inv}{\rid', \intf'} \) are defined by the following two rules.
If it is between pairs, for example \( ( m, n ) \compose ( m', n' ) \), the compositions is defined as the follows,
\[
\begin{rclarray}
    ( m, n ) \compose ( m', n' ) & \defeq & ( m \compose  m',  n  \compose n' )
\end{rclarray}
\]
where \( m\) and \( m' \) is from a domains that composition is defined and similar to \( n\) and \( n' \).
This can be generalised for tuples with arbitrary numbers of elements.
If it is between two sets, it is defined as the compositions between all elements,
\[
\begin{rclarray}
\sort{M} \compose \sort{M}' & \defeq & \Setcon{m \compose m'}{m \in \sort{M} \land m' \in \sort{M}'} \\
\end{rclarray}
\]
where \( \sort{M}, \sort{M}'\) are subsets of a domain that composition is defined.
\end{defn}

Given the invariants of worlds, the guarantee is world transformation that is allowed by the local capabilities and are included in the invariants.
The rely only changes the history heaps against the residual of the local capabilities.
This corresponds a thread from the environment that change the history heap and only its own view.
The rely also includes the view shift

\begin{defn}[Rely and guarantee]
\label{def:rely-guarantee}
%The \( \predn{updWorlds} \) predicate asserts that the world transfers from \( \w \) to \( \w' \) which is allowed by the capabilities \(\ca\).
%\[
%\begin{rclarray}
    %\pred{updWorlds}{\ca, \w, \w'} & \defeq & \w = \w' \\
    %\pred{updWorlds}{\ca, (\ca',\gs) ,(\ca'',\gs')} & \defeq & 
    %\begin{array}[t]{@{}l}
    %\exsts{\kap, \hh, \hh', \vi, \vi', \ca''', \ca''''}
    %\kap \sqsubseteq \ca(\rid) 
    %\land \pred{updW}{\kap, (\ca',\gs),(\ca'',\gs'')} \\
    %\quad {} \land \pred{updWorlds}{\ca, (\ca''',\gs),(\ca'',\gs'')}

    %\end{array} \\
    %\pred{updW}{\kap, (\ca, \gs), (\ca' ,\gs')} & \defeq &  
    %\begin{array}[t]{@{}l}
        %\exsts{\rid, \hh, \hh', \vi, \vi', \ca'', \ca''', \intf } \\
        %\quad \gs = \Set{\rid \mapsto (\hh, \vi, \ca'', \intf)} 
        %\land \gs' = \Set{\rid \mapsto (\hh', \vi', \ca''', \intf)}  \\
        %\quad {} \land (\hh, \vi, \ca'') \toLTS{\kap} (\hh', \vi', \ca''') \in \func{inv}{\rid, \intf} 
        %\land \ca \composeC \ca'' = \ca' \composeC \ca'''
    %\end{array}
%\end{rclarray}
%\]
Given the set of worlds $\World$ (\defref{def:world}), the \emph{update rely} relation, $\relyU \subseteq \World \times \World$, is defined as follows,
\[	
    \begin{rclarray}
	\relyU & \eqdef &
	\Setcon{
		((\ca,\gs), \w')	
	}{
        \exsts{\ca', \hh, \hh', \vi, \ca'', \ca''',\viset, \viset'}  
        (\ca' \composeC \ca)\isdef
        \land \vi \in \viset 
        \land \vi \in \viset' \\
        \quad {} \land (\hh, \vi, \ca'') \in \clpsW{(\ca,\gs)}
        \land (\hh', \vi, \ca''') \in \clpsW{\w'} \\
        \quad {} \land (\hh, \viset, \ca'') \toLTS{\ca'}  (\hh', \viset', \ca''') \in \func{inv}{(\ca,\gs)}
	} \\
    \end{rclarray}
\]
The \emph{shift rely} relation \( \relyV \subseteq \World \times \World\) allows to shift the vie as long as the new view is within the range of history heap.
\[
    \begin{rclarray}
	\relyV & \eqdef &
	\Setcon{
		(\w, \w')	
	}{
        \exsts{\ca', \hh, \vi, \ca, \ca'}  
        (\hh, \vi, \ca) \in \clpsW{\w}
        \land (\hh, \vi, \ca') \in \clpsW{\w'} \\
        \quad {} \land \vi \orderVI \vi'
        \land \pred{wfView}{\vi',\hh} 
	} \\
    \end{rclarray}
\]
Thus the \emph{rely} relation is the union of updates and shifts \( \Rely = \relyU \cup \relyV \).
%The invariant of a shared state is a lift of the invariants of interferences of regions.
%The \emph{rely} relation, $\RelyI \eqdef \World \times \World$, is defined as follows:
%\[
    %\begin{rclarray}
         %\RelyI &\eqdef & \closure{\left(\relyU\right)} \\
    %\end{rclarray}
%\]
The \emph{update guarantee} relation, $\guarU: \World \times \World$, is defined as follows:
\[	
    \begin{rclarray}
	\Guar & \eqdef &
	\Setcon{
		((\ca,\gs), \w')	
	}{
        \exsts{\ca', \hh, \hh', \vi, \ca'', \ca''',\viset, \viset'}  
        (\ca' \composeC \ca)\isdef \\
        \quad {} \land (\hh, \vi, \ca'') \in \clpsW{(\ca,\gs)}
        \land (\hh', \vi', \ca''') \in \clpsW{\w'} \\
        \quad {} \land (\hh, \vi, \ca'') \toLTS{\ca}  (\hh', \vi', \ca''') \in \func{inv}{(\ca,\gs)}
	} \\
    \end{rclarray}
\]
%The \emph{guarantee} relation, $\GuarI \subseteq \World \times \World$, is defined as follows:
%\sx{take away of the closure}
%\[
	%\GuarI \eqdef \guarU
%\]
\end{defn}


\sx{Assume the consistency model relation is reflexive.}

\begin{defn}[Stable]
A set of worlds $\setworld \subseteq \World$ is \emph{stable}, written $\stable{\setworld, \como}$, if and only if it is closed under the rely relation: 
\[
    \begin{rclarray}
        \stable{\setworld, \como} & \eqdef & 
        \begin{array}[t]{@{}l}
            \for{\w, \w', \hh, \hh', \vi, \vi'} \\
            \begin{B}
            \w \in \setworld 
            \land (\w, \w') \in \Rely 
            \land (\hh, \vi, \stub) \in \clpsW{\w}  \\
            {} \land (\hh', \vi', \stub) \in \clpsW{\w'} 
            \land (\hh, \Set{\vi}) \toCO{\como} (\hh', \Set{\vi'})
            \end{B}
            \implies \w' \in \setworld
        \end{array}
    \end{rclarray}
\]
\end{defn}

\subsection{Rules for Global}

The \rl{PRCommit} rule lifts the local effect of transaction \( \trans \) to global level by first converting global state to (local) observable state and then propagating the local fingerprint to the global state.
The \( \predn{down} \) predicate asserts that the local predicate \( \lpre \) is a over-approximation of the valid observation that is given by the interference.
The \( \predn{up} \) predicate says the post-condition \( \gpost \) is the result by lifting the local fingerprints \( \fp \) to pre-condition \( \gpre \).



\begin{figure}[t!]
\hrule\vspace{5pt}

%\[
    %\infer[\rl{PRCommit}]{%
        %\tripleG{\gpre}{ \ptrans{\trans} }{\gpost}
    %}{%
        %\begin{array}{c}
        %\gpre \snap \lpre
        %\quad \tripleL{\lpre \sep \fpE}{\trans}{\lpost \sep \fp} \\
        %\pred{noFingerprint}{\lpre} 
        %\quad \pred{noFingerprint}{\lpost} \\
        %\rpt{\gpre}{\gpost}{\fp}
        %\quad \stable{\gpre} 
        %\quad \stable{\gpost} 
        %\end{array}
    %}
%\]

\[
    \infer[\rl{PRCommit}]{%
        \tripleG{\gpre}{ \ptrans{\trans} }{\gpost}
    }{%
        \begin{array}{c}
        %\gpre \snap \lpre
        \tripleL{\lpre}{\trans}{\lpost} 
        \quad \repartition{\gpre}{\gpost}{\lpre}{\lpost} \\
        %\pred{noFingerprint}{\lpre} 
        %\quad \pred{noFingerprint}{\lpost} \\
        \stable{\gpre, \como} 
        \quad \stable{\gpost, \como} 
        \end{array}
    }
\]


\[
    \infer[\rl{PRAss}]{%
        \tripleG{\thvar \dot= \lexpr }{ \pass{\thvar}{\expr} }{\thvar \dot= \expr\sub{\thvar}{\lexpr} }
    }{%
        \thvar \notin \func{fv}{\lexpr} 
        && \thvar \in \ThdVars  
    }
\]

\[
    \infer[\rl{PRAssume}]{%
        \tripleG{ \expr \doteq 0 }{ \passume{\expr} }{ \expr \doteq 0 } 
    }{}
\]

\[
    \infer[\rl{PRChoice}]{%
        \tripleG{ \gpre }{ \cmd_{1} \pchoice \cmd_{2} }{ \gpost }
    }{%
        \tripleG{ \gpre }{ \cmd_{1} }{ \gpost } && 
        \tripleG{ \gpre }{ \cmd_{2} }{ \gpost } 
    }
\]

\[
    \infer[\rl{TRSeq}]{%
        \tripleG{ \gpre }{ \cmd_{1} \pseq \cmd_{2} }{ \gpost }
    }{%
        \tripleG{ \gpre }{ \cmd_{1} }{ \gframe }  && 
        \tripleG{ \gframe }{ \cmd_{2} }{ \gpost }
    }
\]

\[
    \infer[\rl{TRLoop}]{%
        \tripleG{ \gpre }{ \cmd\prepeat }{ \gpre }
    }{%
        \tripleG{ \gpre }{ \cmd }{ \gpre } 
    }
\]
 
\[
   \infer[\rl{TRFrame}]{%
       \tripleG{ \gpre \sep \gframe }{ \cmd }{ \gpost \sep \gframe }
   }{%
       \tripleG{ \gpre }{ \cmd }{ \gpost } 
   }
\]
 
\[
   \infer[\rl{TRPar}]{%
       \tripleG{ \gpre_{1} \sep \gpre_{2} }{ \cmd_{1} \ppar \cmd_{2} }{ \gpost_{1} \sep \gpost_{2} }
   }{%
       \tripleG{ \gpre_{1} }{ \cmd_{1} }{ \gpost_{1} }
       && \tripleG{ \gpre_{2} }{ \cmd_{2} }{ \gpost_{2} }
   }
\]

\sx{type mismatch for interpretation of fingerprint in  repartition.}
\[
\begin{rclarray}
    \pred{unbox}{\gpre,\lpre} & \defeq & 
    \begin{array}[t]{@{}l}
        \for{ \w, \h, \hh, \cu, \lenv, \stk }
        \w \in \evalW{\gpre} 
        \land (\hh, \cu, \stub) \in \eraseW{\w}
        \land \h = \func{clps}{\hh, \cu} 
        \implies (\h, \unitO) \in \evalLS{\lpre}\\
    \end{array} \\
    \como \repartition{\gpre}{\gpost}{\lpre}{\lpost} & \defeq & 
    \begin{array}[t]{@{}l@{}}
        \pred{unbox}{\gpre, \lpre} \land \for{\w, \hh, \vi, \ca, \lenv, \stk, \txid} 
        \exsts{\w', \hh', \vi', \ca',\extopset} \\
        \begin{B}
            \w \in \evalW{\gpre}
            \land (\hh, \vi, \ca) \in \eraseW{\w}  \\
            \quad {} \land \txid \in \func{fresh}{\hh} 
            \land \opset \in \evalF{\lpost} \\
            \quad {} \land \hh' = \func{updHisHp}{\hh, \vi, \txid, \opset} \\
            \quad {} \land \cu' = \func{updView}{\hh, \vi, \opset} \\
            \quad {} \land (\w, \w') \in \Guar  
            \land (\w, \w') \in \como
        \end{B}
        \implies (\hh',\vi', \ca) \in \eraseW{\w'} \land \w' \in \evalW{\gpost}
    \end{array} \\
\end{rclarray}                          
\]

\hrule\vspace{5pt}
\caption{The rules for programs}
\label{fig:rule-prog}
\end{figure}

The \( \funcn{updHisHp}\) and \( \funcn{updView} \) in the repartition can be replaced by syntactic rules.

\begin{figure}
\hrule\vspace{5pt}

\[
   \infer[\rl{FInit}]{%
       \tripleF{ \lexpr \pt \lexpr }{ \lexpr \fpI \lexpr }{ \lexpr \pt \lexpr }
   }{}
\]

\[
   \infer[\rl{FRead}]{%
       \tripleF{ \lexpr \pt \lexpr }{ \lexpr \fpR \lexpr }{ \lexpr \pt \lexpr }
   }{}
\]

\[
   \infer[\rl{FWrite}]{%
       \tripleF{ \lexpr \pt \lexpr  }{  \lexpr \fpW \lexpr' }{ \lexpr \pt \lexpr' }
   }{}
\]

\[
   \infer[\rl{FReWrt}]{%
       \tripleF{ \lexpr \pt \lexpr  }{  \lexpr \fpRW (\lexpr,\lexpr') }{ \lexpr \pt \lexpr' }
   }{}
\]

\[
   \infer[\rl{FFrame}]{%
       \tripleF{ \bar{\lpre}_{1} \sep \bar{\lpre}_{2}  }{  \bar{\fp}_{1} \sep \bar{\fp}_{2} }{ \bar{\lpost}_{1} \sep \bar{\lpost}_{2} }
   }{
       \tripleF{ \bar{\lpre}_{1} }{ \bar{\fp}_{1} }{ \bar{\lpost}_{1} }
       && \tripleF{ \bar{\lpre}_{2}  }{ \bar{\fp}_{2} }{ \bar{\lpost}_{2} }
    }
\]

%\[
   %\infer[\rl{FFrame}]{%
       %\tripleF{ \lpre \sep \lframe  \mid \lpre' \sep \lframe' }{ \fp }{ \lpost \sep \lframe \mid \lpost' \sep \lframe' }
   %}{%
       %\tripleF{ \lpre \mid \lpre' }{ \fp }{ \lpost \mid \lpost' }
   %}
%\]

%\[
   %\infer[\rl{FContinue}]{%
       %\tripleF{ \lpre \sep \lframe  \mid \lpre' \sep \lframe' }{ \fp  \uplus \fp' }{ \lpost \sep \lframe \mid \lpost' \sep \lframe' }
   %}{%
       %\tripleF{ \lpre \sep \lframe  \mid \lpre' \sep \lframe' }{ \fp }{ \lpost \sep \lframe \mid \lpost' \sep \lframe' }
   %}
%\]

%\[
%\begin{rclarray}
    %\rpt{\gpre}{\gpost}{\fp} & \defeq & 
    %\begin{array}[t]{@{}l}
    %\for{\w, \w', \lpre, \lpre', \lpost, \lpost', \lenv, \stk} \\
    %\quad 
    %\begin{B}
        %\w \in \evalW{\gpre}
        %\land \pred{unboxleft}{\w, \lpre}
        %\land \gpre \snap \lpre' 
        %\land {} \tripleF{ \lpre \mid \lpre' }{ \fp }{ \lpost \mid \lpost'} \\
        %{} \land (\w, \w') \in \Guar
        %\land \pred{unboxleft}{\w',\lpost}
        %\land \gpost \snap \lpost'
    %\end{B}
    %\implies \w' \in \evalW{\gpost}
    %\end{array} \\
    %\pred{unboxleft}{\w, \lpre} & \defeq & \for{\hh} (\hh, \stub) \in \eraseW{\w} \implies \func{clps}{\hh} \in \evalLS{\lpre}
%\end{rclarray}
%\]

\hrule\vspace{5pt}
\caption{Syntactic rule for \funcn{updHisHp} and \funcn{updView}}
\label{fig:rule-prog}
\end{figure}

