\subsection{Rules for Local}

The proof rules are standard except \rl{TRDeref} and \rl{TRMutate}.
The \rl{TRDeref} rule add read fingerprint in finger-tracking set, only if there is no write finger-print.
This is because once a location has been re-written, the rest read are considered as local operations, while the finger-print only records those operations might have effect on global state.
%
\[
    \infer[\rl{TRDeref}]{%
        \judgeL{\expr \fpt{\fp} \lexpr}{ \pderef{\var}{\expr} }{\var \dot= \lexpr \sep \expr \fpt{\addFPR{\fp}} \lexpr }
    }{%
        \var \notin \func{fv}{\expr} &&
        \var \notin \func{fv}{\lexpr}  
    }
\]
 
\[
    \infer[\rl{TRMutate}]{%
        \judgeL{\expr_1 \fpt{\fp} \stub }{ \pmutate{\expr_1}{\expr_2} }{ \expr_1 \fpt{\addFPW{\fp}} \expr_2} 
    }{}
\]

\subsection{Merge}

\begin{defn}[Fingerprint heaps merge]
\label{def:merge-finger-heap}
The \emph{merge of fingerprint heaps}, \( \mergeFP{.}{.} \), is defined as follows:
\[
    \begin{rclarray}
        \mergeFP{\fph_{l}}{\fph_{r}}  & \defeq & \lambda \addr \ldotp 
            \begin{cases}
                \fph_{l}(\addr) & a \in \dom(\fph_{l}) \setminus \dom(\fph_{r})  \\
                \fph_{r}(\addr) & a \in \dom(\fph_{r}) \setminus \dom(\fph_{l}) \\
                \mergeVAL{\fph_{l}(\addr)}{\fph_{r}(\addr)}  & a \in \dom(\fph_{l}) \cap \dom(\fph_{r}) \\
            \end{cases}
    \end{rclarray}
\]
where the \emph{merge of fingerprint heap values} is defined:
\[ \begin{rclarray}
        \mergeVAL{(\val_{l}, \fp_{l})}{(\val_{r}, \fp_{r})} & \defeq &
            \begin{cases}
                (\val_{l}, \fp_{l} \cup \fp_{r} ) & \val_{l} = \val_{r} \land \fpW \notin \fp_{l} \cup \fp_{r} \\
                (\val_{l}, \fp_{l} \cup \fp_{r} ) & \fpW \in \fp_{l} \land \fpW \notin \fp_{r} \\
                (\val_{r}, \fp_{l} \cup \fp_{r} ) & \fpW \notin \fp_{l} \land \fpW \in \fp_{r} \\
            \end{cases}
    \end{rclarray}
\]
\end{defn}

%\sx{
    %Andrea gives a better idea to do this by defining merging fingerprint heaps first.
    %Big thanks. :)))
%}
%\azalea{This is a bit strong! For instance, according to this definition the heaps $\pv x \pt_{\emptyset} 1$ and $\pv x \pt_{\{\fpR\}} 1$ do not agree! Is that what you want?

%Perhaps you can define this as:
%\[
%\begin{rclarray}
	%\agree{\fph_l}{\fph_r} & \defeq  & \ws{\fph_l} \cap \ws{\fph_r} = \emptyset \\
        %&& \land\ \exsts{\h_1, \h_2, \h} \heapOnly{\readOnly{\fph_l}} = \h_1 \composeH \h \land \heapOnly{\readOnly{\fph_r}} = \h \composeFP \h_2 
        %\land \h_1 \composeH \h \composeH \h_2 \isdef
%\end{rclarray}        
%\]
%where
%\[
%\begin{rclarray}
	%\func{ws}{\fph} & \defeq & \myset{\loc}{ \exsts{\fp} \fph(\loc) = (\stub, \fp) \land \fpW \in \fp} \\\\
%%
	%\readOnly{.} & : & \FPHeaps \rightarrow \FPHeaps\\	
	%\readOnly{\fph}(\loc) & \defeq & 
	%\begin{cases}
		%\fph(\loc) & \text{if } \loc \not\in \ws{\fph} \\
		%\text{undefined} & \text{otherwise}
	%\end{cases}\\\\
%%	
	%\heapOnly{.} & : & \FPHeaps \rightarrow \Heaps\\	
	%\heapOnly{\fph}(\loc) & \defeq & 
	%\begin{cases}
		%\val  & \text{if } \exsts{\val} \fph(\loc) = (\val, -) \\
		%\text{undefined} & \text{otherwise}
	%\end{cases}
%\end{rclarray}
%\]
%}

\begin{defn}[Local state merge]
The \emph{merge of local states} is defined as follows, which merges two local states \( \ls_{l} \) and \( \ls_{r} \) with respect to a common initial local state \( \ls \).
\[
    \begin{rclarray}
	\mergeLS{\ls}{\ls_{l}}{\ls_{r}} & \eqdef &
	\myset{
		\left(\fph, \ca_{l}' \composeC \ca_{f} \composeC \ca_{r}' \right) 
	}{
        \fph = \mergeFP{\lsFPH{(\ls_{l})} }{ \lsFPH{(\ls_{r})} } \land \exsts{\ca_{l}, \ca_{r}}\\
		\quad \land\; \lsCAP{\ls} = \ca_{l} \composeC \ca_{f} \composeC \ca_{r}
        \land \lsCAP{(\ls_{l})} = \ca_{l}' \composeC \ca_{f} \composeC \ca_{r}
        \land \lsCAP{(\ls_{r})} = \ca_{l} \composeC \ca_{f} \composeC \ca_{r}'
	}
    \end{rclarray}
\]
where, to recall, the notation \( \lsFPH{(.)} \), and \( \lsCAP{(.)} \) refer to the fingerprint heap and capabilities respectively in a local state.
Then, the \emph{conflict} between two local states is defined as follows:
\[
    \begin{rclarray}
        \conflict{\ls}{\ls_{l}}{\ls_{r}} & \defeq & \mergeLS{\ls}{\ls_{l}}{\ls_{r}} = \emptyset
    \end{rclarray}
\]
\end{defn}

\begin{definition}[Fingerprint worlds]\label{def:fingerprint_worlds}
Given the set of local states $\LStates$ (\defin\ref{def:local_state}) and the set of region identifiers $\RegionID$ (\defin\ref{def:capabilities}), the set of \emph{fingerprint worlds}, $\fpw \in \FPWorlds$, is defined as follows:
%
\[
\begin{rclarray}
	\FPWorlds  & \eqdef  
	& \myset{
		(\ls, \fpgs)
	}{
		(\ls, \fpgs) \in \LStates \times (\RegionID \parfinfun \LStates) \land \wfFW{\ls, \fpgs}
	}
\end{rclarray}
\]
%
with the definitions of the flattening function and the well-formedness predicate lifted as follows:
%
\[
\begin{rclarray}
	\flattenFW{(\ls, \fpgs)}  & \eqdef & \ls \composeLS \prod\limits_{\rid \in \dom(\fpgs)}^{\composeLS} \fpgs(\rid)
\end{rclarray}
\]
%
\[
\begin{rclarray}
	\wfFW{\ls, \fpgs} & \defeq & \exsts{\fph, \ca}\flattenFW{(\ls, \fpgs)} {=} (\fph, \ca) \land\ \dom(\ca) \subseteq \dom(\fpgs) \\
\end{rclarray}
\]
%
The \emph{lift function}, $\liftW{.}: \World \rightarrow \FPWorlds$, is defined as follows:
%
\[
	\liftW{(\lgs, \gs)} \eqdef (\liftLGS{\lgs}, \liftGS{\gs})
\]
%
where
%
\[
\begin{rclarray}
	\liftLGS{(\h, \ca)} = (\fph, \ca)
	& \iffdef 
	& \for{\loc, \val} \h(\loc) = \val \iff \fph(\loc) = (\val, \emptyset) \\
%
	\liftGS{\gs} = \fpgs 
	& \iffdef
	& \for{\rid, \lgs, \inter} \gs(\rid) = (\lgs, \inter) \iff \fpgs(\rid) = (\liftLGS{\lgs'}, \inter) 
\end{rclarray}
\]
%
The \emph{erase function}, $\eraseFW{.}: \FPWorlds \rightarrow \World$, is defined as follows:
%
\[
	\eraseFW{(\ls, \fpgs)} \eqdef (\eraseLS{\ls}, \eraseFGS{\fpgs})
\]
%
where
\[
\begin{rclarray}
	\eraseLS{(\fph, \ca)} = (\h, \ca)
	& \iffdef 
	& \for{\loc, \val} \h(\loc) = \val \iff \fph(\loc) = (\val, \emptyset) \\
%
	\eraseFGS{\fpgs} = \gs 
	& \iffdef
	& \for{\rid, \ls, \inter} \fpgs(\rid) = (\ls, \inter) \Rightarrow \gs(\rid) = (\eraseLS{\ls}, \inter) 
\end{rclarray}
\]
\end{definition}

\begin{definition}[Fingerprint worlds merge]
Given the set of fingerprint worlds $\FPWorlds$ (\defin\ref{def:fingerprint_worlds}), the \emph{merge} function, $\mergeName[\fpw]: \FPWorlds \times \FPWorlds \times \FPWorlds \rightarrow \powerset{\FPWorlds}$, is defined as follows, for all $\fpw,\fpw_{l},\fpw_{r} \in \FPWorlds$:

%
\[
    \begin{rclarray}
	\mergeFW{(\stub, \fpgs)}{(\ls_{l}, \fpgs_{l})}{(\stub, \fpgs_{r})} & \eqdef &
		\Setcon{%
            (\ls_{l}, \fpgs_{p}) 
        }{%
            \fpgs_{p} \in \mergeFGS{\fpgs}{\fpgs_{l}}{\fpgs_{r}}
        } 
    \end{rclarray}
\]
%
where the \( \mergeName[\fpgs] \) is defined as follows:
\[
    \begin{rclarray}
        \mergeFGS{\fpgs}{\fpgs_{l}}{\fpgs_{r}} & \eqdef &
        \begin{cases}
            \emptyset & \text{if} \ \exsts{\rid} \conflict{\fpgs(\rid)}{\fpgs_{l}(\rid)}{\fpgs_{r}(\rid)} \lor \rid \in  \dom(\fpgs_{l}) \cap \dom(\fpgs_{r}) \setminus \dom(\fpgs)  \\
            S & \text{otherwise}
        \end{cases}
    \end{rclarray}
\]
with,
\[
    \begin{rclarray}
	S & = & \myset{\fpgs_{p}}{
		\dom(\fpgs_{p})= \dom(\fpgs_{l}) \cup \dom(\fpgs_{r}) \land \for{\rid}\\
		\quad \rid \in \dom(\fpgs_{l}) \cap \dom(\fpgs_{r}) \implies \fpgs_{p}(\rid) \in \mergeLS{\fpgs(\rid)}{\fpgs_{l}(\rid)}{\fpgs_{r}(\rid)} \\
		\quad \land\ \rid \in \dom(\fpgs_{l}) \setminus \dom(\fpgs_{r}) \implies 	\fpgs_{p}(\rid) = \fpgs_{l}(\rid) \\
		\quad \land\ \rid \in \dom(\fpgs_{r}) \setminus \dom(\fpgs_{l}) \implies 	\fpgs_{p}(\rid) = \fpgs_{r}(\rid)
	}
    \end{rclarray}
\]
\end{definition}

Note that the \( \mergeName[\fpw] \) is not commutative, i.e.\ swapping \( \fpw_{l}\) and \( \fpw_{r}\) might yield different result.

\subsection{Rely and Guarantee}

\begin{definition}[Rely and guarantee]
\label{def:rely-guarantee}
Given the set of fingerprint worlds $\FPWorlds$ (\defin\ref{def:fingerprint_worlds}), the \emph{update rely} relation, $\relyU: \FPWorlds \times \FPWorlds$, is defined as follows:
%
\[	
    \begin{rclarray}
	\relyU & \eqdef &
	\myset{
		((\ls, \fpgs_{p}), (\ls, \fpgs_{q}))	
	}{
		\exsts{\rid, \ca, \intf, \kap, \ls_{p}, \ls_{q}, \ls_{f}}\\
		\quad \for{\rid'} \rid \ne \rid' \implies \fpgs_{p}(\rid') = \fpgs_{q}(\rid') \\
		\quad \land\ \fpgs_{p}(\rid) = (\ls_{p} \composeLS \ls_{f}, \inter) \land \fpgs_{q}(\rid) = (\ls_{q} \composeLS \ls_{f}, \inter)		 \\
		\quad \land\ ( (\unitFP, \ca) \composeLS \flattenFW{(\ls, \fpgs_{p})} ) \isdef 
		\land \kap \leq \ca(\rid)
		\land (\ls_{p}, \ls_{q}) \in \inter(\kap)
	}
    \end{rclarray}
\]
The \emph{extension rely} relation, $\relyE: \FPWorlds \times \FPWorlds$, is defined as follows:
%
\[	
    \begin{rclarray}
        \relyE \eqdef
        \myset{
            \big((\ls, \fpgs_{p}), (\ls, \fpgs_{q})\big)	
        }{
            \exsts{\rid}
            \dom(\fpgs_{q}) \setminus \dom(\fpgs_{p}) = \{\rid\} \\
            \qquad \land\ \for{\rid'} \rid \ne \rid' \implies \fpgs_{p}(\rid') = \fpgs_{q}(\rid') \\
        }
    \end{rclarray}
\]
The \emph{rely} relation, $\myrely: \FPWorlds \times \FPWorlds$, is defined as follows:
%
\[
    \begin{rclarray}
         \myrely  &\eqdef & \bigcup\limits_{n \in \Nat} R_n \\
    \end{rclarray}
\]
where,
\[
    \begin{rclarray}
        \rely_0 & \eqdef & \closure{(\relyU \cup \relyE)} \\
        R_{n {+} 1} & \eqdef & (R_n \cup \pred{merge\_close}{R_n})^{*} \\
        \pred{merge\_close}{\rely} & \eqdef 
        & \myset{(\fpw, \fpw_{q})}{
            \exsts{\fpw_{l}, \fpw_{r}} (\fpw, \fpw_{l}), (\fpw, \fpw_{r}) \in \rely \land \fpw_{q} \in \mergeFW{\fpw}{\fpw_{l}}{\fpw_{r}}}
    \end{rclarray}
\]
%
The $\closure{(.)}$ denotes the reflexive transitive closure of the relation.
A set of fingerprint worlds $\setworld \subseteq \World$ is \emph{stable}, written $\stable{\setworld}$, if and only if it is closed under the rely relation: 
%
\[
    \begin{rclarray}
        \stable{W} & \eqdef & \for{\world \in \setworld, \fpw'} (\liftW{\world}, \fpw') \in \myrely \implies \eraseFW{\fpw'} \in \setworld
    \end{rclarray}
\]
%
The \emph{update guarantee} relation, $\guarU: \FPWorlds \times \FPWorlds$, is defined as follows:
%
\[	
    \begin{rclarray}
        \guarU & \eqdef &
        \myset{
            ((\ls_{p}, \fpgs_{p}), (\ls_{q}, \fpgs_{q}))	
        }{
            \exsts{\ls_{p}' = \flattenFW{(\ls_{p}, \fpgs_{p})}, \ls_{p}' = \flattenFW{(\ls_{q}, \fpgs_{q})} } \orth{(\lsCAP{(\ls_{p}')})} = \orth{(\lsCAP{(\ls_{q}')})}  \\
            \land 
            \begin{formulea}
                \for{\rid} \fpgs_{p}(\rid) = \fpgs_{q}(\rid) \\
                \lor 
                \begin{formulea}
                    \orth{(\lsFPH{(\ls_{p}')})} = \orth{(\lsFPH{(\ls_{q}')})} 
                    \land \exsts{\rid, \ca, \kap, \intf, \ls_{p}'', \ls_{q}'', \ls_f}\\
                        \quad \for{\rid'} \rid \ne \rid' \implies \fpgs_{p}(\rid') = \fpgs_{q}(\rid') \\
                        \quad \land \fpgs_{p}(\rid) = (\ls_{p}'' \composeLS \ls_f, \inter) \land \fpgs_{q}(\rid) = (\ls_{q}'' \composeLS \ls_f, \inter)		 \\
                        \quad \land (\unitFP, \ca) \leq \ls_{p}
                        \land \kap \leq \ca(\rid)
                        \land (\ls_{p}'', \ls_{q}'') \in \inter(\kap)
                \end{formulea}
            \end{formulea}
        }
    \end{rclarray}
\]
% 
The \emph{extension guarantee} relation, $\guarE: \FPWorlds \times \FPWorlds$, is defined as follows:
%
\[	
    \begin{rclarray}
	\guarE & \eqdef &
	\myset{
		((\ls_{f} \composeLS \ls, \fpgs_{p}), (\ls_{f} \composeLS (\unitFP, \ca), \fpgs_{q}))	
	}{
		\exsts{\rid, \ca'}
		\dom(\fpgs_{q}) = \dom(\fpgs_{p}) \uplus \Set{\rid} \\
		\qquad \land\ \for{\rid'} \rid \ne \rid' \implies \fpgs_{p}(\rid') = \fpgs_{q}(\rid') \\
		\qquad \land\ \fpgs_{q}(\rid) = \ls \composeLS (\unitFP, \ca')
		\land \dom(\ca) = \dom(\ca') = \Set{\rid}
	}
    \end{rclarray}
\]
% 
The \emph{guarantee} relation, $\myguar: \FPWorlds \times \FPWorlds$, is defined as follows:
%
\[
	\myguar \eqdef (\guarU \cup \guarE)^{\scalebox{1.1}{*}}
\]
%
\end{definition}

\subsection{Rules for Global}

The \rl{PRCommit} rule lifts the local effect of transaction \( \trans \) to global level by repartition \( \repartition{\gpre}{\gpost}{\lpre}{\lpost} \).
The repartition stripes off the fingerprints but uses the fingerprints to merge the local effect and the interference.
This is, the environment is allowed to write to locations that are different from the ones by transaction \( \trans \).
%
\[
    \infer[\rl{PRCommit}]{%
        \judgeG{\gpre}{ \ptrans{\trans} }{\gpost}
    }{%
        \judgeL{\lpre}{\trans}{\lpost} &&
        \repartition{\gpre}{\gpost}{\lpre}{\lpost}
    }
\]

\begin{definition}[Repartitioning]
\label{def:repartitioning}
The \emph{repartitioning} is defined as follows:
\[
    \begin{rclarray}
        \mrepartition{\setworld_{p}}{\setworld_{q}}{\setfph_{p}}{\setfph_{q}} & \iffdef &
        \begin{array}[t]{@{} l @{}}
            \for{\world_{p} \in \setworld_{p}} \exsts{\fpw_{p}, \fph_{p}, \fph_{f}}\\
            \quad \fpw_{p} = \liftW{\world_{p}} \land \flattenFW{\fpw_{p}} = (\fph_{p} \composeFP \fph_{f}, \unitC) \land \fph_{p} \in \setfph_{p} \\
            \quad \land\ \for{\fph_{q} \in \setfph_{q}} \exsts{ \fpw_{i}} \\
            \qquad \flattenFW{\fpw_{i}} = (\fph_{q} \composeFP \fph_{f}, \unitC) \land (\fpw_{p}, \fpw_{i}) \in \myguar \\
            \qquad \land\ \for{\fpw_{q} \in \mergeR{\fpw_{p}}{\fpw_{i}}{\myrely}} \eraseFW{\fpw_{q}} \in \setworld_{q}
        \end{array}
    \end{rclarray}
\]
with, $\mergeName[\scalebox{.5}{\(\myrely\)}]: \FPWorlds \times \FPWorlds \times \powerset{\FPWorlds \times \FPWorlds} \to \powerset{\FPWorlds}$, defined as follows, for all $\fpw_{p}, \fpw_{q} \in \FPWorlds$:
%
\[
	\mergeR{\fpw_{p}}{\fpw_{q}}{\myrely} \eqdef \bigcup\limits_{\fpw \in \myrely(\fpw_{p})} \mergeFW{\fpw_{p}}{\fpw_{q}}{\fpw}
\]
%
\end{definition}
