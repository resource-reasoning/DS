\subsection{Rules for Local}

The proof rules are standard except \rl{TRDeref} and \rl{TRMutate}.
The \rl{TRDeref} rule add read fingerprint in finger-tracking set, only if there is no write finger-print.
This is because once a location has been re-written, the rest read are considered as local operations, while the finger-print only records those operations might have effect on global state.

\begin{figure}[t]
\hrule\vspace{5pt}
\[
    \infer[\rl{TRSkip}]{%
        \tripleL{\assemp }{ \pskip }{\assemp }
    }{}
\]

\[
    \infer[\rl{TRAss}]{%
        \tripleL{\txvar \dot= \lexpr }{ \pass{\txvar}{\expr} }{\txvar \dot= \expr\sub{\txvar}{\lexpr} }
    }{%
        \txvar \notin \func{fv}{\lexpr} 
        && \txvar \in \TxVars  
    }
\]

\[
    \infer[\rl{TRDeref}]{%
        \tripleL{\expr \pt \lexpr \sep \fp }{ \pderef{\txvar}{\expr} }{\txvar \dot= \lexpr \sep \expr \pt \lexpr \sep \fp' }
    }{%
        \var \notin \func{fv}{\expr}
        && \var \notin \func{fv}{\lexpr}  
        && \txvar \in \TxVars  
        && \fp' = \fp \flushR (\etR, \expr, \lexpr)
    }
\]

\[
    \infer[\rl{TRMutate}]{%
        \tripleL{\expr_1 \pt \stub \sep \fp }{ \pmutate{\expr_1}{\expr_2} }{ \expr_1 \pt \expr_2 \sep \fp' } 
    }{
        \fp' = \fp \flushW (\etW, \expr_{1}, \expr_{2})
    }
\]

\[
    \infer[\rl{TRChoice}]{%
        \tripleL{ \lpre }{ \trans_{1} \pchoice \trans_{2} }{ \lpost }
    }{%
        \tripleL{ \lpre }{ \trans_{1} }{ \lpost } && 
        \tripleL{ \lpre }{ \trans_{2} }{ \lpost } 
    }
\]

\[
    \infer[\rl{TRSeq}]{%
        \tripleL{ \lpre }{ \trans_{1} \pseq \trans_{2} }{ \lpost }
    }{%
        \tripleL{ \lpre }{ \trans_{1} }{ \lframe }  && 
        \tripleL{ \lframe }{ \trans_{1} }{ \lpost }
    }
\]

\[
    \infer[\rl{TRLoop}]{%
        \tripleL{ \lpre }{ \trans\prepeat }{ \lpre }
    }{%
        \tripleL{ \lpre }{ \trans }{ \lpre } 
    }
\]
 
\[
   \infer[\rl{TRFrame}]{%
       \tripleL{ \lpre \sep \lframe }{ \trans }{ \lpost \sep \lframe }
   }{%
       \tripleL{ \lpre }{ \trans }{ \lpost } 
   }
\]
\hrule\vspace{5pt}
\caption{The rules for transactions}
\label{fig:rule-trans}
 \end{figure}


\subsection{Rely and Guarantee}

\begin{definition}[Rely and guarantee]
\label{def:rely-guarantee}
Given the set of worlds $\World$ (\defref{def:world}), the \emph{update rely} relation, $\relyU \subseteq \World \times \World$, is defined as follows:
%
\[	
    \begin{rclarray}
	\relyU & \eqdef &
	\myset{
		((\ca, \ \Set{\rid \mapsto (\h, \intf)} \composeFPH  \gs_{f}), (\ca, \Set{\rid \mapsto (\h', \intf)} \composeFPH \gs_{f}))	
	}{
        \dagger
	} \\
    \dagger & \equiv & 
    \begin{array}[t]{l}
        \exsts{\h_{p}, \h_{q}, \kap, \kap', \evset} 
        \kap' \leq \kap
        \land \kap \composeK \ca(\rid)\isdef
        \land ((\h_{p},\emptyset)(\h_{q},\evset)) \in \intf(\kap') \\
        {} \land \exsts{\aexec, \aexec',\evset}  \\
        \quad \aexec \in \func{s2e}{\rid,\h, \intf, \como} 
        \land \aexec' \in \func{s2e}{\rid, \h', \intf, \como} 
        \land \aexec' \in \func{apply}{\aexec, \evset, \como}
    \end{array}
    \end{rclarray}
\]
The \emph{rely} relation, $\RelyI \eqdef \ConsisModels \to \World \times \World$, is defined as follows:
\[
    \begin{rclarray}
         \RelyI &\eqdef & \closure{\left(\relyU\right)} \\
    \end{rclarray}
\]
%
A set of fingerprint worlds $\setworld \subseteq \World$ is \emph{stable}, written $\stable{\setworld}$, if and only if it is closed under the rely relation: 
%
\[
    \begin{rclarray}
        \stable{\setworld} & \eqdef & \for{\w_{p}, \w_{q}}  \w_{p} \in \setworld \land (\w_{p}, \w_{q}) \in \RelyI \implies \w_{q} \in \setworld
    \end{rclarray}
\]
%
The \emph{update guarantee} relation, $\guarU: \ConsisModels \to \World \times \World$, is defined as follows:
%
\[	
    \begin{rclarray}
	\guarU & \eqdef &
	\myset{
		((\ca, \ \Set{\rid \mapsto (\h, \intf)} \composeFPH  \gs_{f}), (\ca, \Set{\rid \mapsto (\h', \intf)} \composeFPH \gs_{f}))	
	}{
        \dagger
	} \\
    \dagger & \equiv & 
    \begin{array}[t]{l}
        \exsts{\h_{p}, \h_{q}, \kap, \evset} 
        \kap \leq \ca(\rid)
        \land ((\h_{p},\emptyset)(\h_{q},\evset)) \in \intf(\kap) \\
        {} \land \exsts{\aexec, \aexec'}  \\
        \quad \aexec \in \func{s2e}{\rid,\h, \intf, \como} 
        \land \aexec' \in \func{s2e}{\rid, \h', \intf, \como} 
        \land \aexec' \in \func{apply}{\aexec, \evset, \como}
    \end{array}
    \end{rclarray}
\]
The \emph{guarantee} relation, $\GuarI: \ConsisModels \to \World \times \World$, is defined as follows:
\[
	\GuarI \eqdef \closure{\left(\guarU\right)}
\]
\end{definition}

\subsection{Rules for Global}

\sx{Given the new idea that each interference is attached with function from global assertions to local assertions, the commit rule can be simplify by cutting some unnecessary  semantics checks.}
The \rl{PRCommit} rule lifts the local effect of transaction \( \trans \) to global level by first converting global state to (local) observable state and then propagating the local fingerprint to the global state.
\[
    \infer[\rl{PRCommit}]{%
        \tripleG{\gpre}{ \ptrans{\trans} }{\gpost}
    }{%
        \pred{down}{\gpre, \lpre } 
        && \tripleL{\lpre}{\trans}{\lpost \sep \fp}
        && \quad \pred{up}{\gpre,\fp,\gpost} 
    }
\]
The \( \predn{down} \) predicate asserts that the local predicate \( \lpre \) is a over-approximation of the valid observation of the current states \( \gpre \).
The \( \predn{up} \) predicate says the post-condition \( \gpost \) is the result by lifting the local fingerprints \( \fp \) to pre-condition \( \gpre \), if the local fingerprints can be lifted.
\[
\begin{rclarray}
    \pred{down}{\gpre, \lpre} & \eqdef &             
    \begin{array}[t]{@{}l}
        \for{ \h, \ca, \gs } (\ca, \gs) \in \evalW{\gpre} \land \pred{observe}{\h, \gs } \implies ( \h, \emptyset ) \in \evalLS{\lpre} 
    \end{array} \\
    \pred{observe}{\h, \gs} & \defeq & \h = \emptyset \land \gs = \emptyset \\
    \pred{observe}{\h \composeH \h', \gs \uplus \gs'} & \defeq & 
    \begin{array}[t]{@{}l}
        \exsts{\h'', \intf, \txidset, \aexec} 
        \gs = \Set{\rid \mapsto (\h'', \intf)}
        \land \aexec \in \func{s2e}{\rid, \h'', \intf, \como} \\
        \h \in \obsstate{\aexec,\txidset, \respo}
        \land \pred{observe}{\h' ,\gs'} \\
    \end{array} \\
    \pred{up}{\gpre,\fp,\gpost} & \eqdef &
    \begin{array}[t]{@{}l}
        \for{\w, \w', \evset'} \\
        \quad \w \in \evalW{\gpre}
        \land \evset = \evalF{\fp}                              
        \land \pred{propagate}{\w\projection{2}, \w'\projection{2}, \evset}
        \land (\w, \w') \in \Guar \\
        \qquad {} \implies \w' \in \evalW{\gpost}
    \end{array} \\
    \pred{propagate}{\gs, \gs', \evset} & \eqdef & \gs = \gs = \emptyset \land \evset = \emptyset \\
    \pred{propagate}{\gs, \gs', \evset} & \eqdef & 
    \begin{array}[t]{@{}l}
        \exsts{ \rid, \h, \h', \intf, \gs'', \gs''', \evset', \evset''} \\
        \gs = \Set{\rid \mapsto (\h, \intf)} \uplus \gs''
        \land \gs' = \Set{\rid \mapsto (\h, \intf)} \uplus \gs'''
        \land \evset = \evset' \uplus \evset'' \\
        {} \land \for{ \aexec, \aexec' } \\
        \qquad \aexec \in \func{s2e}{\rid,\h, \intf, \como} 
        \land \aexec' \in \func{s2e}{\rid, \h', \intf, \como}  \\
        \qquad {} \land \aexec' \in \func{apply}{\aexec, \evset', \como} 
        \land \pred{propagate}{\gs'',\gs''',\evset''}
    \end{array} \\
\end{rclarray}                          
\]

