\subsection{Rules for Local}

The proof rules are standard except \rl{TRDeref} and \rl{TRMutate}.
The \rl{TRDeref} rule add read fingerprint in finger-tracking set, only if there is no write finger-print.
This is because once a location has been re-written, the rest read are considered as local operations, while the finger-print only records those operations might have effect on global state.

\begin{figure}[!t]
\hrule\vspace{5pt}
\[
    \infer[\rl{TRSkip}]{%
        \tripleL{\assemp }{ \pskip }{\assemp }
    }{}
\]

\[
    \infer[\rl{TRAss}]{%
        \tripleL{\var \dot= \lexpr }{ \pass{\var}{\expr} }{\var \dot= \expr\sub{\var}{\lexpr} }
    }{}
\]

\[
    \infer[\rl{TRDeref}]{%
        \tripleL{\expr \pt \lexpr \sep \fp }{ \pderef{\var}{\expr} }{\var \dot= \lexpr \sep \expr \pt \lexpr \sep \fp' }
    }{%
        \var \notin \func{fv}{\expr}
        && \var \notin \func{fv}{\lexpr}  
        && \fp \toFP{\otR(\lexpr)} \fp'
    }
\]

\[
    \infer[\rl{TRMutate}]{%
        \tripleL{\expr_1 \pt \stub \sep \fp }{ \pmutate{\expr_1}{\expr_2} }{ \expr_{1} \pt \expr_{2} \sep \fp' } 
    }{
        \fp \toFP{\otW(\expr_{2})} \fp'
    }
\]

\[
    \infer[\rl{TRAssume}]{%
        \tripleL{ \expr \doteq 0 }{ \passume{\expr} }{ \expr \doteq 0 } 
    }{}
\]

\[
    \infer[\rl{TRChoice}]{%
        \tripleL{ \lpre }{ \trans_{1} \pchoice \trans_{2} }{ \lpost }
    }{%
        \tripleL{ \lpre }{ \trans_{1} }{ \lpost } && 
        \tripleL{ \lpre }{ \trans_{2} }{ \lpost } 
    }
\]

\[
    \infer[\rl{TRSeq}]{%
        \tripleL{ \lpre }{ \trans_{1} \pseq \trans_{2} }{ \lpost }
    }{%
        \tripleL{ \lpre }{ \trans_{1} }{ \lframe }  && 
        \tripleL{ \lframe }{ \trans_{2} }{ \lpost }
    }
\]


\[
    \infer[\rl{TRLoop}]{%
        \tripleL{ \lpre }{ \trans\prepeat }{ \lpre }
    }{%
        \tripleL{ \lpre }{ \trans }{ \lpre } 
    }
\]
 
\sx{Side condition for fingerprint for sure, but need to see how to do it in a better way.
The potential problem here is the mutation rule, as if the precondition is read and write, one can frame off the write, produce a new write, and frame back the write. 
One way is when frame back, need to update the write fingerprint from the post condition.
Or we say fingerprint for a single address cannot be split and then we add 2 more primitive fingerprint transitions.
}

\[
   \infer[\rl{TRFrame}]{%
       \tripleL{ \lpre \sep \lframe }{ \trans }{ \lpost \sep \lframe }
   }{%
       \tripleL{ \lpre }{ \trans }{ \lpost } 
   }
\]
\hrule\vspace{5pt}
\[
\begin{rclarray}
    \expr \fpI & \toFP{\otR(\lexpr)} & \expr \fpR \lexpr \\
    \expr \fpR \expr' & \toFP{\otR(\lexpr)} & \expr \fpR \lexpr' \\
    \expr \fpW \expr' & \toFP{\otR(\lexpr)} & \expr \fpW \lexpr' \\
    \expr \fpI & \toFP{\otW(\lexpr)} & \expr \fpW \lexpr \\
    \expr \fpR \expr' & \toFP{\otW(\lexpr)} & \expr \fpR \lexpr' \sep \expr \fpW \lexpr \\
    \expr \fpW \expr' & \toFP{\otW(\lexpr)} & \expr \fpW \lexpr \\
\end{rclarray}
\]
\hrule\vspace{5pt}
\caption{The rules for transactions}
\label{fig:rule-trans}
 \end{figure}

\subsection{Rely and Guarantee}

\sx{To allow a transaction update multiple regions but a region multiple times}

\begin{defn}[Rely and guarantee]
\label{def:rely-guarantee}
The \( \predn{to} \) predicate asserts that operations \( \opset\) are allowed by the capabilities \(\ca\) and the state is transferred from \( \gs \) to \( \gs' \).
\[
\begin{rclarray}
    \func{to}{\opset, \ca, \gs, \gs'} & \defeq & \opset = \unitE \land \gs = \gs' \\
    \func{to}{\opset \uplus \opset', \ca, \gs ,\gs'} & \defeq & 
    \begin{array}[t]{@{}l}
    \exsts{\rid, \hh, \hh', \cu, \cu', \kap, \intf, \gs'',\gs''' }  \\
    \quad \gs = \gs'' \uplus \Set{\rid \mapsto (\hh, \cu, \intf)} 
    \land \gs' = \gs''' \uplus \Set{\rid \mapsto (\hh', \cu', \intf)}  \\
    \quad {} \land \kap \sqsubseteq \ca(\rid)
    \land (\hh,\opset) \in \intf(\kap)
    \land (\hh,\cu) \toLTS{\opset} (\hh',\cu') \in \func{inv}{\rid, \intf }
    \land \pred{to}{\opset', \ca, \gs'',\gs'''}
    \end{array}
\end{rclarray}
\]
Given the set of worlds $\World$ (\defref{def:world}), the \emph{update rely} relation, $\relyU \subseteq \World \times \World$, is defined as follows,
\[	
    \begin{rclarray}
	\Rely & \eqdef &
	\Setcon{
		((\ca, \gs), (\ca, \gs'))	
	}{
        \exsts{\opset, \ca'}  
        (\ca' \composeC \ca)\isdef
        \land \pred{to}{\opset, \ca', \gs, \gs'}
	} \\
    \end{rclarray}
\]
%The invariant of a shared state is a lift of the invariants of interferences of regions.
%The \emph{rely} relation, $\RelyI \eqdef \World \times \World$, is defined as follows:
%\[
    %\begin{rclarray}
         %\RelyI &\eqdef & \closure{\left(\relyU\right)} \\
    %\end{rclarray}
%\]
The \emph{update guarantee} relation, $\guarU: \World \times \World$, is defined as follows:
\[	
    \begin{rclarray}
	\Guar & \eqdef &
	\Setcon{
		((\ca, \gs), (\ca, \gs'))	
	}{
        \exsts{\opset} 
        \pred{to}{\opset, \ca, \gs, \gs'}
	} \\
    \end{rclarray}
\]
%The \emph{guarantee} relation, $\GuarI \subseteq \World \times \World$, is defined as follows:
%\sx{take away of the closure}
%\[
	%\GuarI \eqdef \guarU
%\]
\end{defn}

\begin{defn}[Stable]
A set of worlds $\setworld \subseteq \World$ is \emph{stable}, written $\stable{\setworld}$, if and only if it is closed under the rely relation: 
\[
    \begin{rclarray}
        \stable{\setworld} & \eqdef & \for{\w, \w'}  \w \in \setworld \land (\w, \w') \in \Rely \implies \w' \in \setworld
    \end{rclarray}
\]
\end{defn}

\subsection{Rules for Global}

The \rl{PRCommit} rule lifts the local effect of transaction \( \trans \) to global level by first converting global state to (local) observable state and then propagating the local fingerprint to the global state.
The \( \predn{down} \) predicate asserts that the local predicate \( \lpre \) is a over-approximation of the valid observation that is given by the interference.
The \( \predn{up} \) predicate says the post-condition \( \gpost \) is the result by lifting the local fingerprints \( \fp \) to pre-condition \( \gpre \).



\begin{figure}[t!]
\hrule\vspace{5pt}

%\[
    %\infer[\rl{PRCommit}]{%
        %\tripleG{\gpre}{ \ptrans{\trans} }{\gpost}
    %}{%
        %\begin{array}{c}
        %\gpre \snap \lpre
        %\quad \tripleL{\lpre \sep \fpE}{\trans}{\lpost \sep \fp} \\
        %\pred{noFingerprint}{\lpre} 
        %\quad \pred{noFingerprint}{\lpost} \\
        %\rpt{\gpre}{\gpost}{\fp}
        %\quad \stable{\gpre} 
        %\quad \stable{\gpost} 
        %\end{array}
    %}
%\]

\[
    \infer[\rl{PRCommit}]{%
        \tripleG{\gpre}{ \ptrans{\trans} }{\gpost}
    }{%
        \begin{array}{c}
        \gpre \snap \lpre
        \quad \tripleL{\lpre \sep \fpE}{\trans}{\lpost \sep \fp} \\
        \pred{noFingerprint}{\lpre} 
        \quad \pred{noFingerprint}{\lpost} \\
        \como \rpt{\gpre}{\gpost}{\fp}
        \quad \stable{\gpre} 
        \quad \stable{\gpost} 
        \end{array}
    }
\]


\[
    \infer[\rl{PRAss}]{%
        \tripleG{\thvar \dot= \lexpr }{ \pass{\thvar}{\expr} }{\thvar \dot= \expr\sub{\thvar}{\lexpr} }
    }{%
        \thvar \notin \func{fv}{\lexpr} 
        && \thvar \in \ThdVars  
    }
\]

\[
    \infer[\rl{PRAssume}]{%
        \tripleG{ \expr \doteq 0 }{ \passume{\expr} }{ \expr \doteq 0 } 
    }{}
\]

\[
    \infer[\rl{PRChoice}]{%
        \tripleG{ \gpre }{ \prog_{1} \pchoice \prog_{2} }{ \gpost }
    }{%
        \tripleG{ \gpre }{ \prog_{1} }{ \gpost } && 
        \tripleG{ \gpre }{ \prog_{2} }{ \gpost } 
    }
\]

\[
    \infer[\rl{TRSeq}]{%
        \tripleG{ \gpre }{ \prog_{1} \pseq \prog_{2} }{ \gpost }
    }{%
        \tripleG{ \gpre }{ \prog_{1} }{ \gframe }  && 
        \tripleG{ \gframe }{ \prog_{2} }{ \gpost }
    }
\]

\[
    \infer[\rl{TRLoop}]{%
        \tripleG{ \gpre }{ \prog\prepeat }{ \gpre }
    }{%
        \tripleG{ \gpre }{ \prog }{ \gpre } 
    }
\]
 
\[
   \infer[\rl{TRFrame}]{%
       \tripleG{ \gpre \sep \gframe }{ \prog }{ \gpost \sep \gframe }
   }{%
       \tripleG{ \gpre }{ \prog }{ \gpost } 
   }
\]
 
\[
   \infer[\rl{TRPar}]{%
       \tripleG{ \gpre_{1} \sep \gpre_{2} }{ \prog_{1} \ppar \prog_{2} }{ \gpost_{1} \sep \gpost_{2} }
   }{%
       \tripleG{ \gpre_{1} }{ \prog_{1} }{ \gpost_{1} }
       && \tripleG{ \gpre_{2} }{ \prog_{2} }{ \gpost_{2} }
   }
\]

\[
\begin{rclarray}
    \gpre \snap \lpre & \defeq & 
    \begin{array}[t]{@{}l}
        \for{ \w, \h, \hh, \cu, \lenv, \stk }
        \w \in \evalW{\gpre} 
        \land (\hh, \cu, \stub) \in \eraseW{\w}
        \land \h = \func{clps}{\hh, \cu} 
        \implies (\h, \unitO) \in \evalLS{\lpre}\\
    \end{array} \\
    \como \rpt{\gpre}{\gpost}{\fp} & \defeq & 
    \begin{array}[t]{@{}l@{}}
        \for{\w, \hh, \vi, \ca, \lenv, \stk, \txid} 
        \exsts{\w', \hh', \vi', \ca'} \\
        \begin{B}
            \w \in \evalW{\gpre}
            \land (\hh, \vi, \ca) \in \eraseW{\w} 
            \land \txid \in \func{fresh}{\hh}  \\
            \quad {} \land \hh' = \func{commit}{\hh, \vi, \txid, \evalF{\fp}} \\
            \quad {} \land \cu' = \func{update}{\hh, \vi, \evalF{\fp}} \\
            \quad {} \land (\w, \w') \in \Guar  
            \land (\hh, \Set{\vi}) \toCO{\como} (\hh', \Set{\vi'})
        \end{B}
        \implies (\hh',\vi', \ca) \in \eraseW{\w'} \land \w' \in \evalW{\gpost}
    \end{array} \\
\end{rclarray}                          
\]

\hrule\vspace{5pt}
\caption{The rules for programs}
\label{fig:rule-prog}
\end{figure}

Many consistency model use last write win resolution policy, such as snapshot isolation, therefore the repartition \( \rpt{\gpre}{\gpost}{\fp} \) can be simplified by checking the guarantee and then syntactically propagating the write fingerprints.
Also in practice, many implementation of consistency model assume strong session constraint.

\begin{figure}
\hrule\vspace{5pt}

\[
   \infer[\rl{FRead}]{%
       \tripleF{ \lexpr \pt \lexpr' \mid \lexpr \pt \lexpr'' }{ \Set{(\etR, \lexpr, \lexpr'')} }{ \lexpr \pt \lexpr' \mid \lexpr \pt \lexpr''}
   }{}
\]

\[
   \infer[\rl{FWrite}]{%
       \tripleF{ \lexpr \pt \lexpr' \mid \lexpr \pt \lexpr'' }{ \Set{(\etW, \lexpr, \lexpr''')} }{ \lexpr \pt \lexpr''' \mid \lexpr \pt \lexpr'''}
   }{}
\]

\[
   \infer[\rl{FFrame}]{%
       \tripleF{ \lpre \sep \lframe  \mid \lpre' \sep \lframe' }{ \fp }{ \lpost \sep \lframe \mid \lpost' \sep \lframe' }
   }{%
       \tripleF{ \lpre \mid \lpre' }{ \fp }{ \lpost \mid \lpost' }
   }
\]

\[
   \infer[\rl{FContinue}]{%
       \tripleF{ \lpre \sep \lframe  \mid \lpre' \sep \lframe' }{ \fp  \uplus \fp' }{ \lpost \sep \lframe \mid \lpost' \sep \lframe' }
   }{%
       \tripleF{ \lpre \sep \lframe  \mid \lpre' \sep \lframe' }{ \fp }{ \lpost \sep \lframe \mid \lpost' \sep \lframe' }
   }
\]

\[
\begin{rclarray}
    \rpt{\gpre}{\gpost}{\fp} & \defeq & 
    \begin{array}[t]{@{}l}
    \for{\w, \w', \lpre, \lpre', \lpost, \lpost', \lenv, \stk} \\
    \quad 
    \begin{B}
        \w \in \evalW{\gpre}
        \land \pred{unboxleft}{\w, \lpre}
        \land \gpre \snap \lpre' 
        \land {} \tripleF{ \lpre \mid \lpre' }{ \fp }{ \lpost \mid \lpost'} \\
        {} \land (\w, \w') \in \Guar
        \land \pred{unboxleft}{\w',\lpost}
        \land \gpost \snap \lpost'
    \end{B}
    \implies \w' \in \evalW{\gpost}
    \end{array} \\
    \pred{unboxleft}{\w, \lpre} & \defeq & \for{\hh} (\hh, \stub) \in \eraseW{\w} \implies \func{clps}{\hh} \in \evalLS{\lpre}
\end{rclarray}
\]

\hrule\vspace{5pt}
\caption{Syntactic repartition for SI, SER and Causal under strong sessions}
\label{fig:rule-prog}
\end{figure}

