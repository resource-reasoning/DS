\subsection{Local/Transaction}

\begin{definition}[Logical Expressions]
\label{def:logical-expr}
Assume a countably infinite set of \emph{logical variables} $\V x \in \LVar$.
The set of \emph{logical expressions}, $ \lexpr \in \LExpr$ is defined by the following inductive grammar, where \(\val \in \Val\) (\defref{def:program_values}), \(\txvar \in \TxVars\) and \( \thvar \in \ThdVars \) (\defref{def:stacks}),
\[
\begin{rclarray}
   \lexpr & ::= & \val \mid \txvar \mid \thvar \mid \lvar \mid \lexpr + \lexpr \mid \lexpr \times \lexpr \mid \dots 
\end{rclarray}
\]
Assume a set of \emph{logical environments} \(\lenv \in \LEnv: \LVar \parfun \Val\) which associates logical variables with values.
Given a stack $\stk \in \Stacks$ (\defin\ref{def:stacks}) and a logical environment $\lenv \in \LEnv$, the \emph{logical expression evaluation} function, $\evalLE[(., .)]{.}:\LExpr \times \Stacks \times \LEnv\rightharpoonup \Val$, is defined inductively over the structure of logical expressions as follows,
%
\[
    \begin{rclarray}
        \evalLE{\val} & \defeq & \val \\
        \evalLE[\lenv, \thstk \uplus \txstk]{\thvar} & \defeq & \thstk(\thvar) \\
        \evalLE[\lenv, \thstk \uplus \txstk]{\txvar} & \defeq & \txstk(\txvar) \\
        \evalLE{\lvar} & \defeq & \lenv(\lvar) \\
        \evalLE{\lexpr_1 + \lexpr_2} & \defeq & \evalLE{\lexpr_1} + \evalLE{\lexpr_2} \\
        \evalLE{\lexpr_1 \times \lexpr_2} & \defeq & \evalLE{\lexpr_1} \times \evalLE{\lexpr_2} \\
        \dots & \defeq & \dots \\
    \end{rclarray}
\]
Note that the stack \( \stk \) includes transaction variables and thread variables.
\end{definition}

\emph{Fingerprint assertion} or \emph{fingerprint} is a set of tuples in the form of \( (\otag, \lexpr_{1}, \lexpr_{2}) \) where \( \otag \) is either read tag \( \etR \) or write \( \etW \) and the second and third elements are logical assertions representing the address and value respectively.
This assertion is interpreted to a set of transaction events as expected.

\begin{defn}[Fingerprint Assertions]
\label{def:fingerprint}
The \emph{fingerprint assertion} also \emph{fingerprint}, \( \fp \in \FAst \), is defined as the follows, 
\[
\begin{rclarray}
    \fp & \subseteq & \Setcon{ (\otag,\lexpr_{1},\lexpr_{2}) }{ \otag \in \OTags \land \lexpr_{1}, \lexpr_{2} \in \LExpr } \\
\end{rclarray}
\] 
Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stacks$, the \emph{fingerprint interpretation} function, $\evalF[(., .)]{.}: \FAst \times \LEnv \times \Stacks \parfun \Opsets$, is defined as follows,
\[
\begin{rclarray}
    \evalF{\emptyset} & \defeq & \unitO  \\
    \evalF{\fp \addF (\otag, \lexpr_{1}, \lexpr_{2})} & \defeq & \evalF{\fp} \addO (\otag, \evalLE{\lexpr_{1}}, \evalLE{\lexpr_{2}})
\end{rclarray}
\]
\end{defn}

The local assertions includes normal separation logic assertions and extra fingerprint assertions, which are interpreted as sets of heaps and a set of events respectively.
Notice that the fingerprint assertion cannot be split.

\begin{definition}[Local assertions]
\label{def:local_assertions}
Given the set of logical expressions \( \LExpr \), logical variables \( \LVar \) and fingerprint assertion \( \FAst \), the set of \emph{local assertions}, $\lpre,  \lpost \in \LAst$, is defined inductively by the following grammar, 
\[
\begin{rclarray}
	\lpre, \lpost  & ::= & \False \mid \True \mid \lpre \land \lpost \mid \lpre \lor \lpost \mid \exsts{\lvar} \lpre \mid \lpre \implies \lpost \mid \Emp \mid \lexpr \pt \lexpr \mid \fpF \mid \lpre \sep \lpost  \\
\end{rclarray}	 
\]
Given a logical environment $\lenv \in \LEnv$, the \emph{local interpretation function}, $\evalLS[(.,.)]{.}: \LAst \times \LEnv \times \LAst \parfun \powerset{\Heaps \times \Opsets} $, is defined over the structure of local assertions as follows,
\[
\begin{rclarray}
	\evalLS{\assfalse} & \eqdef & \emptyset \\
	\evalLS{\asstrue} & \defeq & \Heaps \times \Opsets \\
	\evalLS{\lpre \land \lpost} & \defeq & \evalLS{\lpre} \cap \evalLS{\lpost} \\
	\evalLS{\lpre \lor \lpost} & \defeq & \evalLS{\lpre} \cup \evalLS{\lpost} \\
	\evalLS{\exsts{\lvar} \lpre} & \defeq & \bigcup\limits_{\val \in \textnormal{\Val}}\evalLS[\lenv\remapsto{\lvar}{\val}, \stk]{\lpre}  \\
	\evalLS{\lpre \implies \lpost} & \defeq & \Setcon{(\h, \opset)}{(\h , \opset) \in \evalLS{\lpre} \implies (\h , \opset) \in \evalLS{\lpost}}\\
	\evalLS{\assemp} & \defeq & \Set{ ( \unitH, \unitE) }  \\
	\evalLS{\lexpr_{1} \pt \lexpr_2 } & \defeq & \Set{ (\evalLE{\lexpr_1} \pt \evalLE{\lexpr_2}, \unitE) } \\
	\evalLS{ \fpF } & \defeq & \Set{ (\unitH, \evalF{\fp}) } \\
	\evalLS{\lpre \sep \lpost} & \defeq & 
    \Setcon{
        (\h_1 \composeH \h_2, \opset_{1} \composeE \opset_{2})
    }{ 
        (\h_{1},\opset_{1}) \in \evalLS{\lpre} 
        \land (\h_{2}, \opset_{2} ) \in \evalLS{\lpost} 
    } 
\end{rclarray}
\]
\end{definition}

Observe that program expressions $\Expr$  (\defin\ref{def:language}) are contained in logical expressions $\LExpr$ (\defin\ref{def:local_assertions} above), \ie $\Expr \subset \LExpr$. 
For readability, we will write angle brackets, \eg \( \fpass{(\etR, \vx, 0)} \) instead of curly brackets \( \fpto{\Set{(\etR, \vx, 0)}} \) for fingerprint assertions.

\subsection{Global/Program}

\begin{definition}[Capabilities]
\label{def:capabilities}
Assume a \emph{partial commutative monoid (PCM)} of \emph{client-specified capabilities} \( (\Kaps, \composeK, \unitK) \) with \( \kap \in \Kaps \), the composition \( \composeK \) the units set \( \unitK \).
Then given a set of \emph{region identifiers} \( \rid \in \RegionID \), the \emph{capability composition function} or \emph{capabilities} \( \ca \in \Caps \defeq \RegionID \parfun \Kaps \), where the composition \( \composeC \) is defined as the follows,
\[
    \begin{rclarray}
        (\ca_{l} \composeC \ca_{r})(\rid) & \defeq  &
        \begin{cases}
            \ca_{l}(\rid) \composeK \ca_{r}(\rid) & \rid \in \dom(\ca_{l}) \cap \dom(\ca_{l}) \\
            \ca_{l}(\rid)  & \rid \in \dom(\ca_{l}) \setminus \dom(\ca_{l}) \\
            \ca_{r}(\rid) & \rid \in \dom(\ca_{r}) \setminus \dom(\ca_{l}) \\
            \text{undefined} & \text{otherwise} \\
        \end{cases}
    \end{rclarray}
\]
, and the units set \( \unitC \defeq \Setcon{\ca}{\for{\rid} \ca(\rid) \in \unitK } \) .
\end{definition}

The interference \( \perm{\kap} :  \exsts{\vec{\lvar}} \bar{\lpre} \mat \fp \) says if a thread holds the capability \( \cass{\kap}{}\) and \emph{the current state of database} satisfies the assertions \( \bar{\lpre} \), the thread is allowed to commit a transaction that has the fingerprint \( \fp \).
The current state of database refers to the state that all the committed transactions are visible.

\begin{defn}[Interference]
\label{def:intf}
Assume standard separation logic assertion \( \bar{\lpre}\) (the local assertion \( \LAst \) without fingerprint).
Given the fingerprint assertion \( \fp \in \Fingerprint \) (\defref{def:fingerprint}), the grammar of \emph{interference assertions}, \( \intass \in \IAst \), is defined as the follows,
\[
\begin{rclarray}
	\intass & ::=  &
	\emptyset \mid \Set{ \perm{\kap} :  \exsts{\vec{\lvar}} \bar{\lpre} \mat \fp } \cup \intass 
\end{rclarray}
\]
The interference assertions are interpreted to a set of \emph{interference environments} that is a function from client-specified capabilities to pairs of history heaps and operations,
\[
\begin{rclarray}
    \inter \in \Interference & \defeq & \Kaps \parfun \powerset{\powerset{\HisHeaps} \times \Opsets}
\end{rclarray}
\]
Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stacks$, the \emph{interference interpretation} function, $\evalI[(., .)]{.}: \IAst \times \LEnv \times \Stacks \to \Interference$, is defined as follows,
%
\[
\begin{rclarray}
	\evalI{\emptyset}(\kap) & \eqdef & \text{undefined} \\
	\evalI{\Set{ \perm{\kap} : \exsts{\vec{\lvar}} \bar{\lpre} \mat \fp } \cup \intass }(\kap') & \eqdef &
    \begin{cases}
    \left(\Setcon{\hh}{\exsts{\h, \cu_{max}}\h \in \evalLS[\lenv',\stk]{\bar{\lpre}} \land {} \\ \h = \func{clps}{\hh,\cu_{max}} \land {} \\ \for{\addr} \cu_{max}(\addr) = \left| \hh(\addr) \right|}, \evalF[\lenv',\stk]{\fp}\right) \cup \evalI{\intass}(\kap')  & \kap = \kap' \\
    \evalI{\intass}(\kap') & \text{ otherwise} \\
    \end{cases} \\
    & & \text{where there exists a vector of values \( \vec{\val}\) such that } \lenv' = \lenv\rmto{\vec{\lvar}}{\vec{\val}} \\
\end{rclarray}
\] 
\end{defn}

We will write \( \intfH(\kap) \)  and \( \intfO(\kap) \) for the first and second projections of all the elements.

\sx{define \( \hh \in \como \) }

\begin{defn}[Labelled transition system]
The labelled transition system is a tuple \( (\hhset, \opsetset,\toLTS{}, \hhset_{0}, \como) \) consisting of a set of history heaps \( \hhset \subseteq \HisHeaps \), a set of sets of operations \( \opsetset \subseteq \Opsets \), a relation \( \toLTS{} : \HisHeaps \times \Opsets \times \HisHeaps \), a set of initial history heaps \( \hhset_{0}\) and the consistency model associated with the transition system \( \como \).
Assume all the initial abstract executions satisfies the consistency model.
The relation \( \toLTS{}\) is defined as the follows,
\[
\begin{rclarray}
    \hh \toLTS{\opset} \hh' & \defeq &
    \begin{array}[t]{@{}l}
        \exsts{\cu, \txid} \txid \in \func{fresh}{\hh} \land \hh' = \func{commit}{\hh, \cu, \txid, \opset} \land \hh \in \como
    \end{array}
\end{rclarray}
\]
\end{defn}
 
\begin{defn}[Invariant a region]
\label{def:invariant-region}
\label{def:world2aexec}
\label{def:state2aexec}
Assume two global functions, \( \funcn{init} : \RegionID \to \powerset{\HisHeaps} \) that returns initial history heaps for regions, and \( \funcn{como} : \RegionID \to \ConsisModels \) that returns the consistency models associated to regions.
Also assume all the initial states for a region satisfy the consistency model, \ie
\[
\for{\rid, \hh_{0}} \hh_{0} \in \func{init}{\rid} \implies \hh_{0} \in \func{como}{\rid}
\]
The invariant of a region, namely \( \func{inv}{\rid, \intf} \), is the labelled transition system where the initial state is \( \func{init}{\rid}\) and all the operations are included in the interference.
\[
\begin{rclarray}
    \func{inv}{\rid, \intf} & \defeq & (\hhset,\opsetset, \toLTS{}, \func{init}{\rid}, \func{como}{\rid}) \\
    & & \text{where } \for{\opset} \opset \in \opsetset \implies \exsts{\kap} \opset \in \intfO(\kap)
\end{rclarray}
\]
\end{defn}

For brevity, \( \hh \in \func{inv}{\rid, \intf} \) denotes \( \hh \in \hhset \), and similarly \( \hh \toLTS{\opset} \hh' \in \func{inv}{\rid, \intf} \).

\begin{defn}[Well-form of a region]
\label{def:well-form-region}
The well-form condition of the interference, namely \( \pred{wfintf}{\rid, \intf} \) predicate, assertions for any concrete events \( \opset \), the state before the events must be included in the interference.
\[
\begin{rclarray}
    \pred{wfintf}{\rid, \intf} & \defeq & 
    \begin{array}[t]{@{}l}
        \for{\hh, \hh', \opset} 
        \hh \toLTS{\opset} \hh' \in \func{inv}{\rid, \intf} 
        \implies \exsts{ \kap, \hhset }
        \hh \in \hhset \land (\hhset, \opset ) \in \intf( \kap )
    \end{array} \\
\end{rclarray}
\]
A cut \( \cu \) is a valid observation for a history heap \( \hh \) of a region \( \rid \), namely \( \pred{validOb}{\rid, \intf, \cu, \hh} \), when the history heap can reach a new state by committing operations \( \opset \), and the heap by collapsing the history heap with the cut is compatible with the new operations,
\[
\begin{rclarray}
    \pred{validOb}{\rid, \intf, \hh, \cu} & \eqdef & 
    \begin{array}[t]{@{}l}
        \exsts{ \hh', \opset, \h } 
        \hh \toLTS{\opset} \hh' \in \func{inv}{\rid, \intf} 
        \land \h = \func{clps}{\hh,\cu} \\
        \quad {} \land \for{\addr,\val} (\otR, \addr, \val)  \in \opset \implies \h(\addr) = \val
    \end{array}
\end{rclarray}
\]
\end{defn}

\begin{definition}[Worlds]
\label{def:world}
Given the set of heaps $\Heaps$ (\defref{def:heaps}) and a set of \emph{region identifiers} \( \rid \in \RegionID \), the set of \emph{shared states} is \( \SStates \eqdef \RegionID \to \Heaps \times \powerset{\Heaps} \times \Interference \).
Each region has its current state, a set of possible initial states for transitions and the interference.
The \emph{shared state composition function}, $\composeS: \SStates \times \SStates \parfun \SStates$, is defined as $\composeS \eqdef \composeEq$, where for all domains $\sort M$ and all $m, m' \in \sort M$,
%
\[
\begin{rclarray}
	m \composeEq m' &  \eqdef  &
	\begin{cases}
		m & \text{if } m = m'\\
		\text{undefined} & \text{otherwise}
	\end{cases}
\end{rclarray}
\]
A \emph{world} \( \w \in \World \) is a pair of a shared state \( \gs \) and capabilities \( \ca \) (\defref{def:capabilities}), where regions are associated with the same consistency model and the collapse of the pair exists, \ie regions are well-form and compatible.
\[
\begin{rclarray}
	\world \in \World  & \eqdef & 
    \Setcon{
        (\ca, \gs) 
    }{ 
        \ca \in \Caps 
        \land \gs \in \SStates
        \land \clpsW{\gs} \neq \emptyset
        \land \dom(\ca) \subseteq \dom(\gs) \\
        \quad {} \land \for{\rid, \rid'}
        \func{como}{\rid} = \func{como}{\rid'} \\
        \quad {} \land \for{\h, \h' }
        \h \in \Set{\gs(\rid)\projection{1}} \cup \gs(\rid)\projection{2}
        \land \h' \in \Set{\gs(\rid')\projection{1}} \cup \gs(\rid')\projection{2} 
        \land ( \h \composeH \h' )\isdef
    }
\end{rclarray}
\]
The function, \( \clpsW{.} : \SStates \parfun \powerset{\Aexecs} \), collapses shared states to sets of abstract executions as the follows,
\[
\begin{rclarray}
    \clpsW{\emptyset} & \defeq & \unitAEX \\
    \clpsW{\Set{\rid \mapsto (\h, \hset, \intf)} \uplus \gs } & \defeq & 
        \Setcon{ \aexec \composeAEX \aexec' }{ \aexec \in \func{r2e}{\rid, \h, \intf} \land \pred{approx}{\rid, \aexec, \hset, \intf} \land \pred{wfintf}{\rid, \intf} \land \aexec' \in \clpsW{\gs} }\\
\end{rclarray}
\] 
% 
The \emph{world composition function}, $\composeW: \World \times \World \parfun \World$, is defined component-wise as: $\composeW \eqdef (\composeC, \composeS)$.
The \emph{world unit set} is $\unitW \eqdef \Setcon{(\ca, \gs)}{(\ca, \gs) \in \World \land \ca \in \unitC}$.
The \emph{partial commutative monoid of worlds} is $(\World, \composeW, \unitW)$.
\end{definition}

\sx{point-wise composition}
\begin{defn}[Invariant of worlds]
Because regions in a well-defined world must disjointed with each other and have the same consistency model, it is easy to lift the invariant of a region to a shared state,
\[
\begin{rclarray}
    \func{inv}{\emptyset} & \defeq & (\aexecset, ... ) \\
    \func{inv}{\Set{\rid \mapsto (\stub, \stub, \intf)} \uplus \gs} & \defeq & \Setcon{\aexec \composeAEX \aexec' }{\aexec \in \func{inv}{\rid, \intf} \land \aexec' \in \func{inv}{\gs}} \\
    \func{transinv}{\emptyset} & = & \Setcon{ ( \aexec , \unitE, \aexec' ) }{\aexec, \aexec' \in \unitAEX } \\
    \func{transinv}{\Set{\rid \mapsto (\stub, \stub, \intf)} \uplus \gs} & = & 
    \Setcon{
        ( \aexec \composeAEX \aexec_{f}, \opset \composeE \opset_{f}, \aexec' \composeAEX \aexec_{f}' ) 
    }{
        (\aexec, \opset, \aexec') \in \func{transinv}{\rid, \intf} \\
        \quad \land (\aexec_{f}, \opset_{f}, \aexec_{f}') \in \func{transinv}{\gs}
    }
\end{rclarray}
\]
\end{defn}

\begin{definition}[Assertions]
\label{def:assertion}
Assume standard separation logic assertion \( \bar{\lpre}, \bar{\lpost }\) (the local assertion \( \LAst \) without fingerprint) and the interpretation function, The set of \emph{assertions}, $\gpre, \gpost \in \Ast$, are defined by the following inductive grammar:
\[
\begin{rclarray}
	\gpre , \gpost & \defeq & \False \mid \True \mid \gpre \land \gpost \mid \gpre \lor \gpost \mid \exsts{\lvar}\gpre \mid \gpre \implies \gpost \mid \assemp \mid \cass{\kap}{\lrid} \mid \gpre \sep \gpost \mid \sptboxass{\bar{\lpre}}{\bar{\lpost}}{\lrid}{\intass}\\
\end{rclarray}
\]
%
where $\lvar, \lrid \in \LVar$, $\lexpr_1, \lexpr_2 \in \LExpr$ (\defin\ref{def:local_assertions}), $\kap \in \Kaps$ (\defin\ref{def:capabilities}) and $\intass \in \IAst$ (\defin\ref{def:intf}).
Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stacks$, the \emph{assertion interpretation} function, $\evalW[(., .)]{.}: \Ast \times \LEnv \times \Stacks \to \powerset{\World}$, is defined as follows:
%
\[
\begin{rclarray}
	\evalW{\False} & \defeq & \emptyset \\
	\evalW{\True} & \defeq & \World \\
	\evalW{\emp} & \defeq & \unitW \\
	\evalW{\gpre \land \gpost} & \defeq & 
    \Setcon{
        (\ca, \gs)
    }{
        \exsts{\gs_{p}, \gs_{q}} 
        (\ca, \gs_{p}) \in \evalW{\gpre} 
        \land (\ca, \gs_{q}) \in \evalW{\gpost} \\
        \quad {} \land \for{\rid} 
        \exsts{\h, \hset_{p}, \hset_{q}, \intf} 
        \gs(\rid) = (\h, \hset_{p} \cap \hset_{q}, \intf) \\
        \qquad {} \land \gs_{p}(\rid) = (\h, \hset_{p}, \intf)
        \land \gs_{q}(\rid) = (\h, \hset_{q}, \intf)
    } \\
	\evalW{\gpre \lor \gpost} & \defeq & 
    \Setcon{
        (\ca, \gs)
    }{
        \exsts{\gs_{p}, \gs_{q}} 
        (\ca, \gs_{p}) \in \evalW{\gpre} 
        \land (\ca, \gs_{q}) \in \evalW{\gpost} \\
        \quad {} \land \for{\rid} 
        \exsts{\h, \hset_{p}, \hset_{q}, \intf} 
        \gs(\rid) = (\h, \hset_{p} \cup \hset_{q}, \intf) \\
        \qquad {} \land \gs_{p}(\rid) = (\h, \hset_{p}, \intf)
        \land \gs_{q}(\rid) = (\h, \hset_{q}, \intf)
    } \\
	\evalW{\exsts{\lvar}  \gpre} & \defeq & \bigcup\limits_{\val \in \textnormal{\Val}} \evalW[\lenv\remapsto{\lvar}{\val}, \stk]{\gpre} \\
	\evalW{\gpre \implies \gpost} & \defeq & \Setcon{\w}{\w \in \evalW{\gpre} \implies \w \in \evalW{\gpost}} \\
	\evalW{\cass{\kap}{\lrid}} & \defeq & \Setcon{ (\Set{\lrid \mapsto \kap}, \gs) }{\gs \in \SStates} \\
	\evalW{ \gpre \sep \gpost } & \defeq & 
	\Setcon{
	   (\world_1 \composeW \world_2) 
    }{
       \world_1 \in \evalW{\gpre} \land \world_2 \in \evalW{\gpost}
	} \\
	\evalW{ \sptboxass{\bar{\lpre}}{\bar{\lpost}}{\lrid}{\intass} } & \defeq & 
    \Setcon{
        (\ca,\Set{\lrid \mapsto (\h, \hset, \intf)} \uplus \gs)
    }{
        \ca \in \unitC 
        \land \h \in \evalLS{\bar{\lpre}}
        \land \hset = \evalLS{\bar{\lpost}}
        \land \intf  = \evalI{\intass}
    } \\
\end{rclarray}
\]
\end{definition}

We will write \( \boxass{\bar{\lpre}}{\lrid}{\intass} \) as a short-hand for \( \sptboxass{\bar{\lpre}}{\bar{\lpre}}{\lrid}{\intass} \) and \(\expr \pt N\) for \( \exsts{\nat \in N} \expr \pt \nat\) where \( N \subseteq \Val\).

