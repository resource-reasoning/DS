\subsection{Local/Transaction}

\begin{defn}[Logical Expressions]
\label{def:logical-expr}
Assume a countably infinite set of \emph{logical variables} $\lvar \in \LVar$.
The set of \emph{logical expressions}, $ \lexpr \in \LExpr$ is defined by the following inductive grammar, where \(\val \in \Val\) (\defref{def:program_values}) and \(\var \in \Vars\)(\defref{def:stacks}),
\[
\begin{rclarray}
   \lexpr & ::= & \val \mid \lvar \mid \var \mid \lexpr + \lexpr \mid \lexpr \times \lexpr \mid \dots 
\end{rclarray}
\]
Assume a set of \emph{logical environments} \(\lenv \in \LEnv: \LVar \parfun \Val\) which associates logical variables with values.
Given a stack $\stk \in \Stacks$ (\defin\ref{def:stacks}) and a logical environment $\lenv \in \LEnv$, the \emph{logical expression evaluation} function, $\evalLE[(., .)]{.}:\LExpr \times \Stacks \times \LEnv\rightharpoonup \Val$, is defined inductively over the structure of logical expressions as follows,
%
\[
    \begin{rclarray}
        \evalLE{\val} & \defeq & \val \\
        \evalLE{\lvar} & \defeq & \lenv(\lvar) \\
        \evalLE{\var} & \defeq & \txstk(\var) \\
        \evalLE{\lexpr_1 + \lexpr_2} & \defeq & \evalLE{\lexpr_1} + \evalLE{\lexpr_2} \\
        \evalLE{\lexpr_1 \times \lexpr_2} & \defeq & \evalLE{\lexpr_1} \times \evalLE{\lexpr_2} \\
        \dots & \defeq & \dots \\
    \end{rclarray}
\]
Note that the stack \( \stk \) includes transaction variables and thread variables.
\end{defn}

\sx{The variable \( \kap \) is a bit confused, since it is used in the model and syntax in assertion}

\begin{defn}[Capabilities]
\label{def:capabilities}
Assume a \emph{partial commutative monoid (PCM)} of \emph{client-specified capabilities} \( (\Kaps, \composeK, \unitK) \) with \( \kap \in \Kaps \), the composition \( \composeK \) the units set \( \unitK \).
Then given a set of \emph{region identifiers} \( \rid \in \RegionID \), the \emph{capability composition function} or \emph{capabilities} \( \ca \in \Caps \defeq \RegionID \parfun \Kaps \), where the composition \( \composeC \) is defined as the follows,
\[
    \begin{rclarray}
        (\ca_{l} \composeC \ca_{r})(\rid) & \defeq  &
        \begin{cases}
            \ca_{l}(\rid) \composeK \ca_{r}(\rid) & \rid \in \dom(\ca_{l}) \cap \dom(\ca_{l}) \\
            \ca_{l}(\rid)  & \rid \in \dom(\ca_{l}) \setminus \dom(\ca_{l}) \\
            \ca_{r}(\rid) & \rid \in \dom(\ca_{r}) \setminus \dom(\ca_{l}) \\
            \text{undefined} & \text{otherwise} \\
        \end{cases}
    \end{rclarray}
\]
and the units set \( \unitC \defeq \Setcon{\ca}{\fora{\rid} \ca(\rid) \in \unitK } \) .
A capability assertion is in the form of \( \cass{\kap(\vec{\lvar})}{\lrid} \in \CAst \), where \( \kap(\vec{\lvar}) \) is a token parametrised by logical variables and \( \lrid \) is the region identifiers.
The capability assertion is interpreted to a capability in the model by interpreting all the logical expressions,
\[
\begin{rclarray}
    \evalC{\cass{\kap(\vec{\lvar})}{\lrid}} & \defeq & \Set{\lrid \mapsto \kap(\evalLE{\vec{\lvar}})} \\
\end{rclarray}
\]
\end{defn}

The capability are used, first, as a token that grants some abilities to access to access the database if a thread holds the token.
Second, it is ghost resources to help the reasoning.
%For brevity, when we write \( \cass{\kap}{\lrid} \), and this means there are implicit parameters.

A \emph{fingerprint assertion} describes the possible global effect from a transaction.
It includes the first read \( \lexpr_{1} \fpR \lexpr_{2} \), last write \( \lexpr_{1} \fpW \lexpr_{2} \) for the address \( \lexpr_{1} \) and the combination of them \( \lexpr_{1} \fpRW \lexpr_{2} \).
\azalea{
I have changed it from $\stackrel{\perp}{\hookrightarrow}$ to $\fpI$, as $\perp$ has weird connotations. 
Default is no fingerprint so far and thus empty tag. 
I have also dropped the $\backslash$ from $\fpA$ and $\fpD$ as it looks a little strange. 
}
The \( \lexpr_{1} \fpI \lexpr_{2} \) means the address \( \lexpr_{1} \) has no associated fingerprint and the initial value is \( \lexpr_{2} \).
The \( \lexpr_{1} \fpR \lexpr_{2} \) means the address has been read before any other write and the current value is \( \lexpr_{2} \).
The \( \lexpr_{1} \fpW \lexpr_{2} \) means the address has been written at least once, and the last written value is \( \lexpr_{2} \).
Last, The \( \lexpr_{1} \fpRW (\lexpr_{2}, \lexpr_{3}) \) means the address has been read and then written, the first read value is \( \lexpr_{2} \) and the last written  value is \( \lexpr_{3} \).

%For better presentation, we introduce \( \fpE \) which means ``untouched for the rest addresses''.
We will use fingerprint assertions to specify interference (shown later), therefore we also have special fingerprint for transferring of capabilities, \ie adding to the shared state \( \fpA \cass{\kap}{\lrid} \), deleting from the shared state \( \fpD \cass{\kap}{\lrid} \) and updating the capabilities \( \cass{\kap(\vec{\lvar})}{\lrid} \fpU \cass{\kap(\vec{\lvar})}{\lrid} \).
The shared state, intuitively, is the state aware by all threads and we will explain the details later.

\sx{ ALREADY: We might be able to eliminate all the heap assertions by combining them to fingerprints. }

\begin{defn}[Fingerprint Assertions]
\label{def:fingerprint}
The \emph{fingerprint assertion}, \( \fp \in \FAst \), is defined as the follows, 
\[
\begin{rclarray}    
    \fp, \fp' & ::= & 
    \lexpr \fpI \lexpr 
    \mid \lexpr \fpR \lexpr 
    \mid \lexpr \fpW \lexpr 
    \mid \lexpr \fpRW (\lexpr, \lexpr) 
    \mid \null \fpA \cass{\kap(\vec{\lvar})}{\lrid}  
    \mid \null \fpD \cass{\kap(\vec{\lvar})}{\lrid} 
    \mid \cass{\kap(\vec{\lvar})}{\lrid} \fpU \cass{\kap(\vec{\lvar})}{\lrid} 
    \mid \fp \sep \fp'
\end{rclarray}
\] 
%The fingerprint assertions is interpreted to a triple \( (\ops, \ca, \ca) \)  containing operations, capabilities added in and capabilities moved out.
Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stacks$, the \emph{fingerprint} is interpreted through function, $\evalF[(., .)]{.}: \FAst \times \LEnv \times \Stacks \parfun \Heaps \times \Opsets \times \Caps \times \Caps$.

%It is extended from \( \Ops \) by including tuples for adding capability \( (\otA, \ca) \) and removing capability \( (\otD, \ca) \).
%The well-form condition is also extended so that capabilities can transfer only one way. 
%\[
%\begin{rclarray}
    %\wfO{\extopset} & \defeq & 
    %\begin{array}[t]{@{}l}
        %\fora{ \otag, \otag', \addr, \addr', \ca, \ca'}  \\
        %\quad (\otag, \addr, \stub),(\otag', \addr', \stub) \in \extopset  \implies \otag \neq \otag' \lor \addr \neq \addr' \\
        %\quad {} \land (\otag, \ca),(\otag', \ca') \in \extopset  \implies \ca \neq \ca' \\
    %\end{array}
%\end{rclarray}
%\] 
%The composition \(\extopset_{1} \composeO \extopset_{2} \) is disjointed set union if the result is well-formed.

\sx{Capabilities updates should be able to encode as add and remove.}
\azalea{
    \sx{Keep the set but separate the capabilities from the set.}
First, see my comment on page \pageref{comm:operations}.\\
The above definition is wrong; for instance, you can have $(\otA, c \composeC c'), \in (\otA, c) \in \extopset$, even though $c \composeC c' \ne c$. \\
Given my definition on \pageref{comm:operations}, we can then define 
$\extopset: (\Addr \fm \Val \times \pset{\Set{\otR, \otW}}) \times \Caps \times \Caps$, where the first part of the triple is as before, the second part tracks the capabilities added, the third part tracks the capabilities removed.\\
Again, you won't need the well-formedness. \\
You can define composition component-wise as $(\uplus, \composeC, \composeC)$.\\
You will need to adjust the interpretation below. 
}

\[
\begin{rclarray}
    \evalF{\lexpr_{1} \fpI \lexpr_{2} } & \defeq &
        \Setcon{(\h, \unitO, \ca, \ca')}{
            \exsts{\addr, \val} \addr = \evalLE{\lexpr_{1}} \land \val = \evalLE{\lexpr_{2}} \\ \quad {} \land \h = \Set{\addr \mapsto \val} \land \ca, \ca' \in \unitC
        } \\
    \evalF{\lexpr_{1} \fpR \lexpr_{2}} & \defeq & 
        \Setcon{(\h, \opset, \ca, \ca')}{
            \exsts{\addr, \val} \addr = \evalLE{\lexpr_{1}} \land \val = \evalLE{\lexpr_{2}} \\ \quad {} \land \h = \Set{\addr \mapsto \val} \land \opset = \Set{(\otR, \addr, \val)} \land \ca, \ca' \in \unitC
        } \\
    \evalF{\lexpr_{1} \fpW \lexpr_{2}} & \defeq & 
        \Setcon{(\h, \opset, \ca, \ca')}{
            \exsts{\addr, \val} \addr = \evalLE{\lexpr_{1}} \land \val = \evalLE{\lexpr_{2}} \\ \quad {} \land \h = \Set{\addr \mapsto \val} \land \opset = \Set{(\otW, \addr, \val)} \land \ca, \ca' \in \unitC
        } \\
    \evalF{\lexpr_{1} \fpRW (\lexpr_{2}, \lexpr_{3}) } & \defeq & 
        \Setcon{(\h, \opset, \ca, \ca')}{
            \exsts{\addr, \val, \val'} \addr = \evalLE{\lexpr_{1}} \land \val = \evalLE{\lexpr_{2}} \land \val' = \evalLE{\lexpr_{3}} \\ \quad {} \land \h = \Set{\addr \mapsto \val'} \land \opset = \Set{(\otR, \addr, \val), (\otW, \addr, \val')} \land \ca, \ca' \in \unitC
        } \\
    \evalF{\null \fpA \cass{\kap(\vec{\lvar})}{\lrid} } & \defeq & 
        \Setcon{(\unitH, \unitO, \ca, \ca')}{
            \ca = \evalC{\cass{\kap(\vec{\lvar})}{\lrid}} \land \ca' \in \unitC
        } \\
    \evalF{\null \fpD \cass{\kap(\vec{\lvar})}{\lrid} } & \defeq &
        \Setcon{(\unitH, \unitO, \ca, \ca')}{
            \ca \in \unitC \land \ca'  = \evalC{\cass{\kap(\vec{\lvar})}{\lrid}} 
        } \\
    \evalF{\cass{\kap(\vec{\lvar})}{\lrid} \fpU \cass{\kap'(\vec{\lvar}')}{\lrid} } & \defeq &
        \Setcon{(\unitH, \unitO, \ca, \ca')}{
            \ca = \evalC{\cass{\kap(\vec{\lvar})}{\lrid}} \land \ca'  = \evalC{\cass{\kap'(\vec{\lvar}')}{\lrid}} 
        } \\
    \evalF{\fp_{1} \sep \fp_{2}} & \defeq & \Setcon{ ( \h_{1} \composeH \h_{2}, \opset_{1} \composeO \opset_{2}, \ca_{1} \composeC \ca_{2}, \ca'_{1} \composeC \ca'_{2} ) }{(\h_{1}, \opset_{1}, \ca_{1}, \ca'_{1}) \in \evalF{\fp_{1}} \land (\h_{2}, \opset_{2}, \ca_{2}, \ca'_{2}) \in \evalF{\fp_{2}}}\\

\end{rclarray}
\]
\end{defn}

%\sx{ It should be fine for local assertion to include the capabilities, as it either becomes frame or (not sure) helps local reasoning}
The local assertions have true, false, conjunction \( \land \), disjunction \( \lor \), existential quantification \( \exists \), implication \( \implies  \), empty \( \assemp \),  heap-related fingerprint assertions \( \bar{\fp}\) and separation conjunction \( \sep \).
They describes the state of local heap used by a transaction and more importantly the fingerprint of the transaction.
They are interpreted to pairs of heaps and operation sets.

%The standard separation assertions describe the current local state, while the fingerprints are all the local effects that will be committed to the database.

\begin{defn}[Local assertions]
\label{def:local_assertions}
Given the set of logical expressions \( \LExpr \) and logical variables \( \LVar \), the set of \emph{local assertions}, $\lpre,  \lpost \in \LAst$, is defined by lifting the \emph{read-write fraction of fingerprint assertions} \( \bar{\fp} \),
\[
\begin{rclarray}
    \bar{\fp} & ::= & \lexpr \fpR \lexpr \mid \lexpr \fpW \lexpr \mid \lexpr \fpRW (\lexpr, \lexpr) \mid \lexpr \fpI \lexpr  \\
	\lpre, \lpost  & ::= & \False \mid \True \mid \lpre \land \lpost \mid \lpre \lor \lpost \mid \exsts{\lvar} \lpre \mid \lpre \implies \lpost \mid \Emp \mid \bar{\fp} \mid \lpre \sep \lpost  \\
\end{rclarray}	 
\]
Given a logical environment $\lenv \in \LEnv$, the \emph{local interpretation function}, $\evalLS[(.,.)]{.}: \LAst \times \LEnv \times \LAst \parfun \powerset{\Heaps \times \Opsets} $, is defined over the structure of local assertions as follows,
\[
\begin{rclarray}
	\evalLS{\assfalse} & \eqdef & \emptyset \\
	\evalLS{\asstrue} & \defeq & \Heaps \times \Opsets \\
	\evalLS{\lpre \land \lpost} & \defeq & \evalLS{\lpre} \cap \evalLS{\lpost} \\
	\evalLS{\lpre \lor \lpost} & \defeq & \evalLS{\lpre} \cup \evalLS{\lpost} \\
	\evalLS{\exsts{\lvar} \lpre} & \defeq & \bigcup\limits_{\val \in \textnormal{\Val}}\evalLS[\lenv\remapsto{\lvar}{\val}, \stk]{\lpre}  \\
	\evalLS{\lpre \implies \lpost} & \defeq & \Setcon{(\h, \opset)}{(\h , \opset) \in \evalLS{\lpre} \implies (\h , \opset) \in \evalLS{\lpost}}\\
	\evalLS{\assemp} & \defeq & \Set{ ( \unitH, \unitE) }  \\
	\evalLS{ \bar{\fp} } & \defeq & \Setcon{(\h, \opset)}{ \exsts{\h, \opset, \ca, \ca'} (\h, \opset, \ca, \ca') \in \evalF{\bar{\fp}} \land \ca,\ca' \in \unitC} \\
	\evalLS{\lpre \sep \lpost} & \defeq & 
    \Setcon{
        (\h_1 \composeH \h_2, \opset_{1} \composeE \opset_{2})
    }{ 
        (\h_{1},\opset_{1}) \in \evalLS{\lpre} 
        \land (\h_{2}, \opset_{2} ) \in \evalLS{\lpost} 
    } 
\end{rclarray}
\]
\end{defn}

\azalea{
    \sx{Leave this notation for now, when settle other parts, we can change the macro systematically for confused notations.}
    The definition of $\evalLS{ \bar{\fp} }$ looks cyclic as you use the same notation for interpreting local assertions and fingerprint assertions.
}

Observe that program expressions $\Expr$  (\defin\ref{def:language}) are contained in logical expressions $\LExpr$ (\defin\ref{def:local_assertions} above), \ie $\Expr \subset \LExpr$. 
Because the local assertions do not contain any assertions related to capabilities, it is enough to interpret them to heaps and sets of operations \( \Opsets \).

\begin{lem}
\(
    \fora{\bar{\fp},\ca,\ca'} (\stub, \stub, \ca, \ca') \in \evalF{\bar{\fp}} \implies \ca,\ca' \in \unitC
\)
\end{lem}
\begin{proof}
Induction on the structures.
\end{proof}

%For readability, we will write angle brackets, \eg \( \fpass{(\etR, \vx, 0)} \) instead of curly brackets \( \fpto{\Set{(\etR, \vx, 0)}} \) for fingerprint assertions.

\subsection{Global/Program}

%The interference \( \exsts{\vec{\lvar}} \perm{\kap} : \bar{\lpre} \mat \fp \) says if a thread holds the capability \( \perm{\kap}\) and \emph{the current state of database} satisfies the assertions \( \bar{\lpre} \), the thread is allowed to commit a transaction that has the fingerprint \( \fp \).
%The current state of database refers to the state that all the committed transactions are visible.

%\begin{defn}[Interference]
%\label{def:intf}
%Assume standard separation logic assertion \( \bar{\lpre}\) (the local assertion \( \LAst \) without fingerprint).
%Given the fingerprint assertion \( \fp \in \Fingerprint \) (\defref{def:fingerprint}), the grammar of \emph{interference assertions}, \( \intass \in \IAst \), is defined as the follows,
%\[
%\begin{rclarray}
	%\intass & ::=  &
	%\emptyset \mid \Set{ \perm{\kap} :  \exsts{\vec{\lvar}} \bar{\lpre} \mat \fp } \cup \intass 
%\end{rclarray}
%\]
%The interference assertions are interpreted to a set of \emph{interference environments} that is a function from client-specified capabilities to pairs of history heaps and operations,
%\[
%\begin{rclarray}
    %\inter \in \Interference & \defeq & \Kaps \to \powerset{\HisHeaps \times \Opsets}
%\end{rclarray}
%\]
%Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stacks$, the \emph{interference interpretation} function, $\evalI[(., .)]{.}: \IAst \times \LEnv \times \Stacks \to \Interference$, is defined as follows,
%%
%\[
%\begin{rclarray}
	%\evalI{\emptyset}(\kap) & \eqdef & \emptyset \\
	%\evalI{\Set{ \perm{\kap} : \exsts{\vec{\lvar}} \bar{\lpre} \mat \fp } \cup \intass }(\kap') & \eqdef &
    %\begin{cases}
    %\Setcon{(\hh, \evalF[\lenv',\stk]{\fp})}{\exsts{\h} \h \in \evalLS[\lenv',\stk]{\bar{\lpre}} \land {} \\ \h = \clpsHH{\hh} } \cup \evalI{\intass}(\kap')  & \kap = \kap' \\
    %\evalI{\intass}(\kap') & \text{ otherwise} \\
    %\end{cases} \\
    %& & \text{where there exists a vector of values \( \vec{\val}\) such that } \lenv' = \lenv\rmto{\vec{\lvar}}{\vec{\val}} \\
%\end{rclarray}
%\] 
%\end{defn}

%We will write \( \intfH(\kap) \)  and \( \intfO(\kap) \) for the first and second projections of all the elements.

The interference \( \exsts{\vec{\lvar}} \perm{\kap} : \fp \) says if a thread holds the capability \( \perm{\kap} \), it is allowed to commit a transaction that has the fingerprint \( \fp \).
The existential is for binding variables between the capability and the fingerprint assertions.

\sx{Parameter of the \( \kap \)? 
The \( \intf \) might simplify to single view to single view.
}
\begin{defn}[Interference]
\label{def:intf}
Given the fingerprint assertion \( \fp \in \Fingerprint \) (\defref{def:fingerprint}), the grammar of \emph{interference assertions}, \( \intass \in \IAst \), is defined as the follows,
\[
\begin{rclarray}
	\intass & ::=  &
	\emptyset \mid \Set{ \exsts{\vec{\lvar}} \perm{\kap} : \fp } \cup \intass 
\end{rclarray}
\]
The interference assertions are interpreted to \emph{interference environments} that is a set of transitions on history heap, a set of views, and capabilities,
\[
\begin{rclarray}
    \inter \in \Interference & \defeq & \Kaps \to ( \HisHeaps \times \Views \times \Caps ) \times  ( \HisHeaps \times \Views \times \Caps )
\end{rclarray}
\]
Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stacks$, the \emph{interference interpretation} function, $\evalI[(., .)]{.}: \IAst \times \LEnv \times \Stacks \to \Interference$, is defined as follows,
\sx{
    Notations are confused, there is different between syntactic \( \kap \) which can be parametrised by logical variables, and client-specified capabilities \( \kap' \).
    Fix the typesetting later.
    } 
\[
\begin{rclarray}
	\evalI{\Set{ \exsts{\vec{\lvar}} \perm{\kap} : \fp } \cup \intass }(\kap') & \eqdef &
    	\begin{cases}
	    		\Setcon{
                    \begin{B}
	    				(\hh, \vi, \ca_r \composeC \ca_f ), \\ 
	    				(\hh',\vi', \ca_f \composeC \ca_a)
                    \end{B}
	    		}{ 
	    			\exsts{\txid, \opset} \\
	    				\quad ( \stub, \opset, \ca_{a}, \ca_{r} ) \in \evalF[\lenv',\stk]{\fp}   \\
					\quad {} \land \txid \in \func{fresh}{\hh}  \\
	       			\quad {} \land \hh' = \func{updHisHp}{\hh, \vi, \txid, \opset}  \\
		        	\quad {} \land \vi' \geq \func{updView}{\hh', \vi, \opset} \\
	    		} 
	    		\cup \evalI{\intass}(\kap')  
    		& \text{ if } \dagger \\\\
    		
	    	\evalI{\intass}(\kap') 
	    	& \text{ otherwise} \\
    	\end{cases}  \\
        \dagger & \equiv & \exsts{\vec{\val}, \lenv'} \lenv' = \lenv\rmto{\vec{\lvar}}{\vec{\val}} \land \kap' = \evalI[\lenv', \stk]{\kap} \\
\end{rclarray}
\]
%
%\[
%\begin{rclarray}
	%\evalI{\emptyset}(\kap) & \eqdef & \emptyset \\
	%\evalI{\Set{ \exsts{\vec{\lvar}} \perm{\kap} : \fp } \cup \intass }(\kap') & \eqdef &
    %\begin{cases}
    %\evalF[\lenv',\stk]{\fp} \cup \evalI{\intass}(\kap')  & \text{if } \exsts{\vec{\val}, \lenv'} \lenv' = \lenv\rmto{\vec{\lvar}}{\vec{\val}} \land \kap' = \evalI[\lenv', \stk]{\kap} \\
    %\evalI{\intass}(\kap') & \text{ otherwise} \\
    %\end{cases} \\
%\end{rclarray}
%\] 

\end{defn}

%\begin{defn}[Labelled transition system]
%\label{def:labelled-transition-system}
%The labelled transition system is a tuple \( ( \hhset \times \cuset, \opsetset,\toLTS{}, \hhset_{0} \times \cuset_{0}, \como) \) consisting of pairs of history heaps and cuts \( \hhset \times \cuset \), a set of sets of operations \( \opsetset \subseteq \Opsets \), a relation \( \toLTS{} : \HisHeaps \times \Opsets \times \HisHeaps \), a set of initial history heaps and cuts \( \hhset_{0} \times \cuset_{0} \) and the consistency model associated with the transition system \( \como \).
%Assume all the initial abstract executions satisfies the consistency model.
%The relation \( \toLTS{}\) is defined as the follows,
%\[
%\begin{rclarray}
    %(\hh, \cu) \toLTS{\opset} (\hh',\cu') & \defeq &
    %\begin{array}[t]{@{}l}
        %\exsts{\thcu, \thcu', \txid, \thid}
        %\txid \in \func{fresh}{\hh} 
        %\land \hh' = \func{commit}{\hh, \cu, \txid, \opset} 
        %\land \cu' = \func{update}{\hh', \cu, \opset} \\
        %\quad {} \land ((\hh,\thcu),(\hh',\thcu')) \in \como
        %\land \h = \clpsHH{\hh,\cu} 
        %\land \thcu(\thid) = \cu 
        %\land \thcu'(\thid) = \cu' \\
        %\quad {} \land \fora{\addr,\val} (\otR, \addr, \val)  \in \opset \implies \h(\addr) = \val
    %\end{array}
%\end{rclarray}
%\]
%\end{defn}

%We lift the interference to a invariant.
%The invariant is a labelled transition system that describes how a region evolves providing all the allowed operations.
%Note that the labels are capabilities (with region identifiers) instead of client-specified capabilities, which is only for technical reason.

\azalea{
    \sx{Done}
I do not understand why you need this invariant and initial state at all. Why couldn't we just define: 
%
Also if you change the definition of $\extopset$ as I suggested, you also need to update the definition of $\func{getOps}{\extopset}$.
}
\sx{
    FOR THE RECORD IN CASE TO REVERSE.
\begin{defn}[Invariant of a region]
\label{def:labelled-transition-system}
\label{def:invariant-region}
\label{def:world2aexec}
\label{def:state2aexec}
Assuming a global function, \( \funcn{init} : \RegionID \to \powerset{ \HisHeaps \times \powerset{\Views} \times \powerset{\Caps} } \) that returns initial history heaps, sets of views, and a set of capabilities for regions, the invariant of a region, namely \( \func{inv}{\rid, \intf} \), is the labelled transition system with respect to \( \intf \), where the initial states \( \func{init}{\rid}\), the configuration is a tuple of history heap \( \hh \in \hhset \), a set of views \( \viset \in \visetset \), and capabilities, and the labels are client-specified capabilities \( \kap \).
\[
\begin{rclarray}
    \func{inv}{\rid, \intf} & \defeq & (\hhset \times \visetset, \toLTS{}, \func{init}{\rid}, \caset) \\
\end{rclarray}
\]
The transition system is the least fix point from the relation \( {} \toLTS{} {} : (\HisHeaps \times \powerset{\Views} \times \powerset{\Caps}) \times \Caps \times (\HisHeaps \times \powerset{\Views} \times \powerset{\Caps}) \) given the set of initial configurations \( \func{init}{\rid} \).
The relation \( \toLTS{} \) is defined as the follows,
\[
\begin{rclarray}
    (\hh, \viset \uplus \Set{\vi}, \ca ) \toLTS{\ca''} (\hh',\viset \uplus \Set{\vi'}, \ca') & \defeq &
    \begin{array}[t]{@{}l}
        \exsts{\txid, \extopset} 
        \txid \in \func{fresh}{\hh} 
        \land \extopset \in \intf(\ca''(\rid)) \\
        \quad {} \land \hh' = \func{updHisHp}{\hh, \vi, \txid, \func{getOps}{\extopset}}  \\
        \quad {} \land \vi' \geq \func{updView}{\hh', \vi, \func{getOps}{\extopset}} \\
        \quad {} \land \ca' = \func{updCaps}{\ca, \func{getCaps}{\extopset}} \\
    \end{array} \\
    \func{getOps}{\extopset} & \defeq & \Setcon{\extop}{\extop \in \extopset \land ( \extop = (\otR,\stub,\stub) \lor \extop = (\otW, \stub, \stub) ) } \\
    \func{getCaps}{\extopset} & \defeq & \extopset \setminus \func{getOps}{\extopset} \\
    \func{updCaps}{\ca, \emptyset} & \defeq & \ca \\
    \func{updCaps}{\ca, \Set{\otA, \ca'} \composeO \extopset} & \defeq & \func{updCaps}{\ca \composeC \ca', \extopset}\\
    \func{updCaps}{\ca \composeC \ca', \Set{\otD, \ca'} \composeO \extopset} & \defeq & \func{updCaps}{\ca, \extopset}\\
\end{rclarray}
\]
\end{defn}
For brevity, \( (\hh,\vi,\ca) \in \func{inv}{\rid, \intf} \), where \( \vi \) is a single view, denotes \( \exsts{\viset } \vi \in \viset \land (\hh,\viset,\ca) \in \func{inv}{\rid,\intf}\projection{1} \), and similarly \( (\hh,\vi,\ca) \toLTS{\kap} (\hh',\vi',\ca') \in \func{inv}{\rid, \intf} \) for the second projection.
}

%\begin{defn}[Invariant of a region]
%\label{def:invariant-region}
%\label{def:world2aexec}
%\label{def:state2aexec}
%Assume two global functions, \( \funcn{init} : \RegionID \to \powerset{ \HisHeaps \times \powerset{\Views} } \) that returns initial history heaps and sets of views for regions, and \( \funcn{como} : \RegionID \to \ConsisModels \) that returns the consistency models associated to regions.
%The invariant of a region, namely \( \func{inv}{\rid, \intf} \), is the labelled transition system where the initial state is \( \func{init}{\rid}\) and all the operations are included in the interference.
%\[
%\begin{rclarray}
    %\func{inv}{\rid, \intf} & \defeq & (\hhset \times \cuset, \Setcon{\opset}{\exsts{\kap} \opset \in \intfO(\kap)}, \toLTS{}, \func{init}{\rid}, \func{como}{\rid}) \\
%\end{rclarray}
%\]
%\end{defn}

%For brevity, \( (\hh,\cu) \in \func{inv}{\rid, \intf} \) denotes \( (\hh,\cu) \in \func{inv}{\rid,\intf}\projection{1} \), and similarly \( (\hh,\cu) \toLTS{\opset} (\hh',\cu') \in \func{inv}{\rid, \intf} \).

%\sx{This well form condition allows one to write weaker interference, \eg interference satisfies both SI and SER but to prove the correctness of SER. It is fine since logic only need to be sound?}
%\begin{defn}[Well-form of a region]
%\label{def:well-form-region}
%The well-form condition of the interference, namely \( \pred{wfintf}{\rid, \intf} \) predicate, assertions for any concrete events \( \opset \), the state before the events must be included in the interference.
%\[
%\begin{rclarray}
    %\pred{wfintf}{\rid, \intf} & \defeq & 
    %\begin{array}[t]{@{}l}
        %\fora{\hh, \hh', \opset} 
        %(\hh, \stub) \toLTS{\opset} (\hh',\stub) \in \func{inv}{\rid, \intf} 
        %\implies \exsts{ \kap}
        %(\hh, \opset ) \in \intf( \kap )
    %\end{array} \\
%\end{rclarray}
%\]
%\end{defn}

\sx{Need some verbal explanation here for \emph{worlds}. Later}

\begin{defn}[Worlds]
\label{def:world}
Given the set of history heaps $\HisHeaps$ (\defref{def:his_heap}), views \( \Views \) (\defref{def:views}), capabilities \( \Caps\) (\defref{def:capabilities}) and region identifiers \( \RegionID \), the set of \emph{shared states} is \( \SStates \eqdef \RegionID \parfun \HisHeaps \times \Views \times \Caps \times \Interference \).
Each region has its current state and the interference.
The \emph{shared state composition function}, $\composeS: \SStates \times \SStates \parfun \SStates$, is defined as $\composeS \eqdef \composeEq$, where for all domains $\sort M$ and all $m, m' \in \sort M$,
%
\[
\begin{rclarray}
	m \composeEq m' &  \eqdef  &
	\begin{cases}
		m & \text{if } m = m'\\
		\text{undefined} & \text{otherwise}
	\end{cases}
\end{rclarray}
\]
A \emph{world} \( \w \in \World \) is a pair of capabilities \( \ca \) (\defref{def:capabilities}) and a shared state \( \gs \) in which regions are well-formed, \ie (a) they are associated with disjointed part of history heaps; (b) the domain of the view in a region is the same as the domain of the history heap; and (c) the views should not be out of the range of history heaps.
Separately, capabilities from regions and local capabilities are compatible.
These constraints are derived by the clap \(\eraseS{(\ca, \gs)} \neq \emptyset \).
Finally, there is no garbage capability, a capability where the associated region identifier never appear in the shared state.
\[
\begin{rclarray}
	\world \in \World  & \eqdef & 
    \Setcon{
        (\ca, \gs) 
    }{ 
        \ca \in \Caps \land \gs \in \SStates \\
        \quad {} \land \exsts{ \ca' }
        (\stub, \stub, \ca') \in \eraseS{(\ca,\gs)}
        \land \dom(\ca') \subseteq \dom(\gs)  
        \land \fora{\rid}
        \exsts{\hh, \vi} \\
        \qquad \gs(\rid) = (\hh, \vi, \stub) 
        \land \dom(\hh) = \dom(\vi)
        \land \fora{ \addr \in \dom(\vi) }
        1 \leq \cu( \addr ) \leq \left| \hh(\addr) \right|
    }
\end{rclarray}
\]
The function \( \eraseW{.} : \Caps \times \SStates \parfun \powerset{\HisHeaps \times \Views \times \Caps} \) erases the region identifiers from the shared state and then composes the states component-wise.
\[
\begin{rclarray}
    \eraseW{(\ca, \gs)} & \defeq & \Setcon{(\hh, \vi, \ca \composeC \ca')}{(\hh, \vi, \ca') \in \func{collapse}{\gs}} \\
    \func{collapse}{\emptyset} & \defeq & \Set{(\unitHH, \unitVI, \unitC )} \\
    \func{collapse}{\Set{\rid \mapsto (\hh, \vi, \ca, \intf)} \uplus \gs } & \defeq & 
        \Setcon{ 
            (\hh \composeHH \hh', \vi \composeCU \vi', \ca \composeC \ca') 
        }{ 
            \land (\hh', \vi', \ca') \in \func{collapse}{\gs} }\\
\end{rclarray}
\] 
% 
The \emph{world composition function}, $\composeW: \World \times \World \parfun \World$, is defined component-wise as: $\composeW \eqdef (\composeC, \composeS)$.
The \emph{world unit set} is $\unitW \eqdef \Setcon{(\ca, \gs)}{(\ca, \gs) \in \World \land \ca \in \unitC}$.
The \emph{partial commutative monoid of worlds} is $(\World, \composeW, \unitW)$.
\end{defn}

%We also use the notation \( \eraseW{.}\) for a world, which denotes to erase the shared state, \ie \( \eraseW{(\ca, \gs)} \defeq \eraseS{\gs}\).
%Because the well-form condition requires all the regions in a world must associate with the same consistency model, so we write \( \func{como}{\w} \) for the model.

%\begin{defn}[Invariant of worlds]
%Because regions in a well-defined world must disjointed with each other and have the same consistency model, the invariants of regions can be lifted to a world,
%\[
%\begin{rclarray}
    %\func{inv}{(\ca, \emptyset),\como} & \defeq & ( \Set{\unitHH}, \Set{\unitO}, \Set{(\unitHH, \unitO, \unitHH)}, \Set{\unitHH}, \como \right) \\
    %\func{inv}{\Set{\rid \mapsto (\stub, \stub, \intf)} \uplus \gs} & \defeq & \Setcon{\aexec \composeAEX \aexec' }{\aexec \in \func{inv}{\rid, \intf} \land \aexec' \in \func{inv}{\gs}} \\
    %\func{transinv}{\emptyset} & = & \Setcon{ ( \aexec , \unitE, \aexec' ) }{\aexec, \aexec' \in \unitAEX } \\
    %\func{transinv}{\Set{\rid \mapsto (\stub, \stub, \intf)} \uplus \gs} & = & 
    %\Setcon{
        %( \aexec \composeAEX \aexec_{f}, \opset \composeE \opset_{f}, \aexec' \composeAEX \aexec_{f}' ) 
    %}{
        %(\aexec, \opset, \aexec') \in \func{transinv}{\rid, \intf} \\
        %\quad \land (\aexec_{f}, \opset_{f}, \aexec_{f}') \in \func{transinv}{\gs}
    %}
%\end{rclarray}
%\]
%\end{defn}

%\begin{defn}[Assertions]
%\label{def:assertion}
%Assume standard separation logic assertion \( \bar{\lpre}, \bar{\lpost }\) (the local assertion \( \LAst \) without fingerprint) and the interpretation function, The set of \emph{assertions}, $\gpre, \gpost \in \Ast$, are defined by the following inductive grammar:
%\[
%\begin{rclarray}
	%\gpre , \gpost & \defeq & \False \mid \True \mid \gpre \land \gpost \mid \gpre \lor \gpost \mid \exsts{\lvar}\gpre \mid \gpre \implies \gpost \mid \assemp \mid \cass{\kap}{\lrid} \mid \gpre \sep \gpost \mid \sptboxass{\bar{\lpre}}{\bar{\lpost}}{\lrid}{\intass}\\
%\end{rclarray}
%\]
%%
%where $\lvar, \lrid \in \LVar$, $\lexpr_1, \lexpr_2 \in \LExpr$ (\defin\ref{def:local_assertions}), $\kap \in \Kaps$ (\defin\ref{def:capabilities}) and $\intass \in \IAst$ (\defin\ref{def:intf}).
%Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stacks$, the \emph{assertion interpretation} function, $\evalW[(., .)]{.}: \Ast \times \LEnv \times \Stacks \to \powerset{\World}$, is defined as follows:
%%
%\[
%\begin{rclarray}
	%\evalW{\False} & \defeq & \emptyset \\
	%\evalW{\True} & \defeq & \World \\
	%\evalW{\emp} & \defeq & \unitW \\
	%\evalW{\gpre \land \gpost} & \defeq & \evalW{\gpre} \cap \evalW{\gpost} \\
	%\evalW{\gpre \lor \gpost} & \defeq & \evalW{\gpre} \cup \evalW{\gpost} \\ 
	%\evalW{\exsts{\lvar}  \gpre} & \defeq & \bigcup\limits_{\val \in \textnormal{\Val}} \evalW[\lenv\remapsto{\lvar}{\val}, \stk]{\gpre} \\
	%\evalW{\gpre \implies \gpost} & \defeq & \Setcon{\w}{\w \in \evalW{\gpre} \implies \w \in \evalW{\gpost}} \\
	%\evalW{\cass{\kap}{\lrid}} & \defeq & \Setcon{ (\Set{\lrid \mapsto \kap}, \gs) }{\gs \in \SStates} \\
	%\evalW{ \gpre \sep \gpost } & \defeq & 
	%\Setcon{
	   %(\world_1 \composeW \world_2) 
    %}{
       %\world_1 \in \evalW{\gpre} \land \world_2 \in \evalW{\gpost}
	%} \\
	%\evalW{ \sptboxass{\bar{\lpre}}{\bar{\lpost}}{\lrid}{\intass} } & \defeq & 
    %\Setcon{
        %(\ca,\Set{\lrid \mapsto (\hh, \cu, \evalI{\intass})} \uplus \gs)
    %}{         
        %\exsts{\h_{p}, \h_{q}}
        %\ca \in \unitC 
        %\land \h_{q} \in \evalLS{\bar{\lpost}}
        %\land \h_{q} = \func{clps}{\hh, \cu} \\
        %\quad {} \land \h_{p} \in \evalLS{\bar{\lpre}}
        %\land \h_{p} = \func{clps}{\hh} 
    %} \\
%\end{rclarray}
%\]
%\end{defn}
%We will write \( \boxass{\bar{\lpre}}{\lrid}{\intass} \) as a short-hand for \( \sptboxass{\bar{\lpre}}{\bar{\lpre}}{\lrid}{\intass} \) and \(\expr \pt N\) for \( \exsts{\nat \in N} \expr \pt \nat\) where \( N \subseteq \Val\).

\sx{Explain here: box assertion, local part, shared part, intuitively how they get interpreted}


\sx{
\begin{defn}[Assertions]
The set of \emph{assertions}, $\gpre, \gpost \in \Ast$, are defined by the following inductive grammar:
\[
\begin{rclarray}
    \bar{\lpre}, \bar{\lpost} & ::= & \False \mid \True \mid \bar{\lpre} \land \bar{\lpost} \mid \bar{\lpre} \lor \bar{\lpost} \mid \exsts{\lvar} \bar{\lpre} \mid \bar{\lpre} \implies \bar{\lpost} \mid \assemp \mid \cass{\kap}{\lrid} \mid \lexpr \pt \lexpr \mid \bar{\lpre} \sep \bar{\lpost} \\
	\gpre , \gpost & ::= & \False \mid \True \mid \gpre \land \gpost \mid \gpre \lor \gpost \mid \exsts{\lvar}\gpre \mid \gpre \implies \gpost \mid \assemp \mid \cass{\kap}{\lrid} \mid \gpre \sep \gpost \mid \boxass{\bar{\lpre}}{\lrid}{\intass}\\
\end{rclarray}
\]
%
where $\lvar, \lrid \in \LVar$, $\lexpr_1, \lexpr_2 \in \LExpr$ (\defin\ref{def:local_assertions}), $\kap \in \Kaps$ (\defin\ref{def:capabilities}) and $\intass \in \IAst$ (\defin\ref{def:intf}).
Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stacks$, the \emph{assertion interpretation} function, $\evalW[(., .)]{.}: \Ast \times \LEnv \times \Stacks \to \powerset{\World}$, is defined as follows,
%
\[
\begin{rclarray}
	\evalW{\False} & \defeq & \emptyset \\
	\evalW{\True} & \defeq & \World \\
	\evalW{\emp} & \defeq & \unitW \\
	\evalW{\gpre \land \gpost} & \defeq & \evalW{\gpre} \cap \evalW{\gpost} \\
	\evalW{\gpre \lor \gpost} & \defeq & \evalW{\gpre} \cup \evalW{\gpost} \\ 
	\evalW{\exsts{\lvar}  \gpre} & \defeq & \bigcup\limits_{\val \in \textnormal{\Val}} \evalW[\lenv\remapsto{\lvar}{\val}, \stk]{\gpre} \\
	\evalW{\gpre \implies \gpost} & \defeq & \Setcon{\w}{\w \in \evalW{\gpre} \implies \w \in \evalW{\gpost}} \\
	\evalW{\cass{\kap}{\lrid}} & \defeq & \Setcon{ (\Set{\lrid \mapsto \evalI{\kap}}, \gs) }{\gs \in \SStates} \\
	\evalW{ \gpre \sep \gpost } & \defeq & 
	\Setcon{
	   (\world_1 \composeW \world_2) 
    }{
       \world_1 \in \evalW{\gpre} \land \world_2 \in \evalW{\gpost}
	} \\
	\evalW{ \boxass{\bar{\lpre}}{\lrid}{\intass} } & \defeq & 
    \Setcon{
        (\ca, \gs)
    }{         
        \exsts{\hh, \vi, \ca', \intf}
        \ca \in \unitC 
        \land \intf = \evalI{\intass} 
        \land \gs(\lrid) = (\hh, \vi, \ca', \intf) 
        \land (\hh, \vi, \ca') \in \func{intp}{\bar{\lpre}, \lenv, \stk} 
    } \\
    \\
    \func{intp}{\assfalse,\lenv,\stk} & \defeq & \emptyset \\
    \func{intp}{\asstrue,\lenv,\stk} & \defeq & \HisHeaps \times \Views \times \Caps \\
    \func{intp}{\assemp,\lenv,\stk} & \defeq & \Setcon{ (\unitHH, \unitVI, \ca) }{\ca \in \unitC } \\
    \func{intp}{\bar{\lpre} \land \bar{\lpost},\lenv,\stk} & \defeq & \func{intp}{\bar{\lpre},\lenv,\stk} \cap \func{intp}{\bar{\lpost},\lenv,\stk} \\ 
    \func{intp}{\bar{\lpre} \lor \bar{\lpost},\lenv,\stk} & \defeq & \func{intp}{\bar{\lpre},\lenv,\stk} \cup \func{intp}{\bar{\lpost},\lenv,\stk} \\ 
    \func{intp}{\exsts{\lvar} \bar{\lpre},\lenv,\stk} & \defeq & \bigcup\limits_{\val \in \Val} \func{intp}{\bar{\lpre}, \lenv\rmto{\lvar}{\val}, \stk} \\
    \func{intp}{\bar{\lpre} \implies \bar{\lpost},\lenv,\stk} & \defeq & \Setcon{ (\hh, \vi, \ca) }{ (\hh, \vi, \ca) \in \func{intp}{\bar{\lpre},\lenv,\stk} \implies (\hh, \vi, \ca) \in \func{intp}{\bar{\lpost},\lenv,\stk} }\\
    \func{intp}{\cass{\kap}{\lrid},\lenv,\stk} & \defeq & \Set{ (\unitHH, \unitVI, \Set{\lrid \mapsto \evalC{\kap}}) }\\
    \func{intp}{\lexpr_{1} \pt \lexpr_{2},\lenv,\stk} & \defeq & \Setcon{ (\hh, \vi, \ca) }{\ca \in \unitC \land \Set{ \evalLE{\lexpr_{1}} \mapsto \evalLE{\lexpr_{2}} } = \clpsHH{\hh, \vi} }\\
    \func{intp}{\bar{\lpre} \sep \bar{\lpost},\lenv,\stk} & \defeq & \Setcon{ (\hh \composeHH \hh', \vi \composeVI \vi', \ca \composeC \ca') }{ (\hh, \vi, \ca) \in \func{intp}{\bar{\lpre},\lenv,\stk} \land (\hh', \vi', \ca') \in \func{intp}{\bar{\lpost},\lenv,\stk} }\\
\end{rclarray}
\]
\end{defn}
}

\begin{defn}[Assertions]
\label{def:assertion}
Given the set of logical expression \( \lexpr \in \exprset \subseteq \LExpr\), the set of \emph{assertions}, $\gpre, \gpost \in \Ast$, are defined by the following inductive grammar:
\[
\begin{rclarray}
    \bar{\lpre}, \bar{\lpost} & ::= & \False \mid \True \mid \bar{\lpre} \land \bar{\lpost} \mid \bar{\lpre} \lor \bar{\lpost} \mid \exsts{\lvar} \bar{\lpre} \mid \bar{\lpre} \implies \bar{\lpost} \mid \assemp \mid \cass{\kap}{\lrid} \mid \lexpr \pt \exprset \mid \bar{\lpre} \sep \bar{\lpost} \\
	\gpre , \gpost & ::= & \False \mid \True \mid \gpre \land \gpost \mid \gpre \lor \gpost \mid \exsts{\lvar}\gpre \mid \gpre \implies \gpost \mid \assemp \mid \cass{\kap}{\lrid} \mid \gpre \sep \gpost \mid \boxass{\bar{\lpre}}{\lrid}{\intass}\\
\end{rclarray}
\]
%
where $\lvar, \lrid \in \LVar$, $\lexpr_1, \lexpr_2 \in \LExpr$ (\defin\ref{def:local_assertions}), $\kap \in \Kaps$ (\defin\ref{def:capabilities}) and $\intass \in \IAst$ (\defin\ref{def:intf}).
Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stacks$, the \emph{assertion interpretation} function, $\evalW[(., .)]{.}: \Ast \times \LEnv \times \Stacks \to \powerset{\World}$, is defined as follows,
%
\[
\begin{rclarray}
	\evalW{\False} & \defeq & \emptyset \\
	\evalW{\True} & \defeq & \World \\
	\evalW{\emp} & \defeq & \unitW \\
	\evalW{\gpre \land \gpost} & \defeq & \evalW{\gpre} \cap \evalW{\gpost} \\
	\evalW{\gpre \lor \gpost} & \defeq & \evalW{\gpre} \cup \evalW{\gpost} \\ 
	\evalW{\exsts{\lvar}  \gpre} & \defeq & \bigcup\limits_{\val \in \textnormal{\Val}} \evalW[\lenv\remapsto{\lvar}{\val}, \stk]{\gpre} \\
	\evalW{\gpre \implies \gpost} & \defeq & \Setcon{\w}{\w \in \evalW{\gpre} \implies \w \in \evalW{\gpost}} \\
	\evalW{\cass{\kap}{\lrid}} & \defeq & \Setcon{ (\Set{\lrid \mapsto \evalI{\kap}}, \gs) }{\gs \in \SStates} \\
	\evalW{ \gpre \sep \gpost } & \defeq & 
	\Setcon{
	   (\world_1 \composeW \world_2) 
    }{
       \world_1 \in \evalW{\gpre} \land \world_2 \in \evalW{\gpost}
	} \\
	\evalW{ \boxass{\bar{\lpre}}{\lrid}{\intass} } & \defeq & 
    \Setcon{
        (\ca, \gs)
    }{         
        \exsts{\hh, \vi, \ca', \intf}
        \ca \in \unitC  \\
        \quad {} \land \intf = \evalI{\intass} 
        \land \gs(\lrid) = (\hh, \vi, \ca', \intf) 
        \land (\hh, \vi, \ca') \in \func{intp}{\bar{\lpre}, \lenv, \stk} 
    } \\
    \\
    \func{intp}{\assfalse,\lenv,\stk} & \defeq & \emptyset \\
    \func{intp}{\asstrue,\lenv,\stk} & \defeq & \HisHeaps \times \Views \times \Caps \\
    \func{intp}{\assemp,\lenv,\stk} & \defeq & \Setcon{ (\unitHH, \unitVI, \ca) }{\ca \in \unitC } \\
    \func{intp}{\bar{\lpre} \land \bar{\lpost},\lenv,\stk} & \defeq & \func{intp}{\bar{\lpre},\lenv,\stk} \cap \func{intp}{\bar{\lpost},\lenv,\stk} \\ 
    \func{intp}{\bar{\lpre} \lor \bar{\lpost},\lenv,\stk} & \defeq & \func{intp}{\bar{\lpre},\lenv,\stk} \cup \func{intp}{\bar{\lpost},\lenv,\stk} \\ 
    \func{intp}{\exsts{\lvar} \bar{\lpre},\lenv,\stk} & \defeq & \bigcup\limits_{\val \in \Val} \func{intp}{\bar{\lpre}, \lenv\rmto{\lvar}{\val}, \stk} \\
    \func{intp}{\bar{\lpre} \implies \bar{\lpost},\lenv,\stk} & \defeq & \Setcon{ (\hh, \vi, \ca) }{ (\hh, \vi, \ca) \in \func{intp}{\bar{\lpre},\lenv,\stk} \implies (\hh, \vi, \ca) \in \func{intp}{\bar{\lpost},\lenv,\stk} }\\
    \func{intp}{\cass{\kap}{\lrid},\lenv,\stk} & \defeq & \Set{ (\unitHH, \unitVI, \Set{\lrid \mapsto \evalC{\kap}}) }\\
    \func{intp}{\lexpr_{1} \pt \exprset,\lenv,\stk} & \defeq & \Setcon{ (\hh, \vi, \ca) }{ \fora{ \vi' \geq \vi } \exsts{\lexpr_{2} \in \exprset} \ca \in \unitC \land {} \\ \quad \Set{ \evalLE{\lexpr_{1}} \mapsto \evalLE{\lexpr_{2}} } = \clpsHH{\hh, \vi'} } \\
    \func{intp}{\bar{\lpre} \sep \bar{\lpost},\lenv,\stk} & \defeq & \Setcon{ (\hh \composeHH \hh', \vi \composeVI \vi', \ca \composeC \ca') }{ (\hh, \vi, \ca) \in \func{intp}{\bar{\lpre},\lenv,\stk} \land (\hh', \vi', \ca') \in \func{intp}{\bar{\lpost},\lenv,\stk} } \\
\end{rclarray}
\]
\end{defn}

\azalea{\sx{It is unnecessary. Initial to rule out garbage interpretation.} Why is the $(\hh, \vi) \in \func{inv}{\lrid, \intf}$ conjunct needed in the definition of $\evalW{ \boxass{\bar{\lpre}}{\lrid}{\intass} }$?}
