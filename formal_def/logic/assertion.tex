\subsection{Local/Transaction}

\begin{definition}[Logical Expressions]
\label{def:logical-expr}
Assume a countably infinite set of \emph{logical variables} $\lvar \in \LVar$.
The set of \emph{logical expressions}, $ \lexpr \in \LExpr$ is defined by the following inductive grammar, where \(\val \in \Val\) (\defref{def:program_values}) and \(\var \in \Vars\)(\defref{def:stacks}),
\[
\begin{rclarray}
   \lexpr & ::= & \val \mid \lvar \mid \var \mid \lexpr + \lexpr \mid \lexpr \times \lexpr \mid \dots 
\end{rclarray}
\]
Assume a set of \emph{logical environments} \(\lenv \in \LEnv: \LVar \parfun \Val\) which associates logical variables with values.
Given a stack $\stk \in \Stacks$ (\defin\ref{def:stacks}) and a logical environment $\lenv \in \LEnv$, the \emph{logical expression evaluation} function, $\evalLE[(., .)]{.}:\LExpr \times \Stacks \times \LEnv\rightharpoonup \Val$, is defined inductively over the structure of logical expressions as follows,
%
\[
    \begin{rclarray}
        \evalLE{\val} & \defeq & \val \\
        \evalLE{\lvar} & \defeq & \lenv(\lvar) \\
        \evalLE{\var} & \defeq & \txstk(\var) \\
        \evalLE{\lexpr_1 + \lexpr_2} & \defeq & \evalLE{\lexpr_1} + \evalLE{\lexpr_2} \\
        \evalLE{\lexpr_1 \times \lexpr_2} & \defeq & \evalLE{\lexpr_1} \times \evalLE{\lexpr_2} \\
        \dots & \defeq & \dots \\
    \end{rclarray}
\]
Note that the stack \( \stk \) includes transaction variables and thread variables.
\end{definition}

\sx{The variable \( \kap \) is a bit confused, since it is used in the model and the assertion}

\begin{definition}[Capabilities]
\label{def:capabilities}
Assume a \emph{partial commutative monoid (PCM)} of \emph{client-specified capabilities} \( (\Kaps, \composeK, \unitK) \) with \( \kap \in \Kaps \), the composition \( \composeK \) the units set \( \unitK \).
Then given a set of \emph{region identifiers} \( \rid \in \RegionID \), the \emph{capability composition function} or \emph{capabilities} \( \ca \in \Caps \defeq \RegionID \parfun \Kaps \), where the composition \( \composeC \) is defined as the follows,
\[
    \begin{rclarray}
        (\ca_{l} \composeC \ca_{r})(\rid) & \defeq  &
        \begin{cases}
            \ca_{l}(\rid) \composeK \ca_{r}(\rid) & \rid \in \dom(\ca_{l}) \cap \dom(\ca_{l}) \\
            \ca_{l}(\rid)  & \rid \in \dom(\ca_{l}) \setminus \dom(\ca_{l}) \\
            \ca_{r}(\rid) & \rid \in \dom(\ca_{r}) \setminus \dom(\ca_{l}) \\
            \text{undefined} & \text{otherwise} \\
        \end{cases}
    \end{rclarray}
\]
, and the units set \( \unitC \defeq \Setcon{\ca}{\for{\rid} \ca(\rid) \in \unitK } \) .
A capability assertion is in the form of \( \cass{\kap(\vec{\lvar})}{\lrid} \in \CAst \), where \( \kap(\vec{\lvar}) \) is a token parametrised by logical variables and \( \lrid \) is the region identifiers.
The capability assertion is interpreted to a capability in the model by interpreting all the logical expressions,
\[
\begin{rclarray}
    \evalC{\cass{\kap(\vec{\lvar})}{\lrid}} & \defeq & \Set{\lrid \mapsto \kap(\evalLE{\vec{\lvar}})} \\
\end{rclarray}
\]
\end{definition}

The capability are used, first, as a token that grants some abilities to access to access the database if a session holds the token.
Second, it is ghost resources to help the reasoning.
For brevity, when we write \( \cass{\kap}{\lrid} \), and this means there are implicit parameters.

\emph{Fingerprint assertion} or \emph{fingerprint} describes the possible global effect from a transaction.
It includes the first read \( \lexpr_{1} \fpR \lexpr_{2} \) and last write \( \lexpr_{1} \fpW \lexpr_{2} \) for the address \( \lexpr_{1} \).
If an address remains untouched, it will have the default fingerprint \( \lexpr \fpI \).
For better presentation, we introduce \( \fpE \) which means ``untouched for the rest addresses''.
We will use fingerprint assertions to specify local transition (shown later), therefore we also have fingerprint for transfer of capabilities, \ie adding to the shared state \( \cass{\kap}{\lrid} \fpA \) and deleting from the shared state \( \cass{\kap}{\lrid} \fpD \).
The shared state, intuitively, is the state aware by all sessions and we will explain the details later.

\begin{defn}[Fingerprint Assertions]
\label{def:fingerprint}
The \emph{fingerprint assertion} also \emph{fingerprint}, \( \fp \in \FAst \), is defined as the follows, 
\[
\begin{rclarray}    
    \fp, \fp' & ::= & \lexpr \fpR \lexpr \mid \lexpr \fpW \lexpr \mid \lexpr \fpI \mid \fpE \mid \cass{\kap(\vec{\lvar})}{\lrid} \fpA \mid \cass{\kap(\vec{\lvar})}{\lrid} \fpD \mid \fp \sep \fp'
\end{rclarray}
\] 
The fingerprint assertions is interpreted to a set of extended operations \( \ExtOps \).
It is extended from \( \Ops \) by including tuple for initial of address \( (\otI, \addr) \), adding capability \( (\otA, \ca) \) and deleting capability \( (\otD, \ca) \).
The well-form condition is also extended so that the initial of address is the bottom element, and a capability can transfer only one way. 
\[
\begin{rclarray}
    \wfO{\extopset} & \defeq & 
    \begin{array}[t]{@{}l}
        \for{ \otag, \otag', \addr, \addr', \ca, \ca'}  \\
        \quad (\otag, \addr, \stub),(\otag', \addr', \stub) \in \extopset  \implies \otag \neq \otag' \lor \addr \neq \addr' \\
        \quad {} \land (\otag, \ca),(\otag', \ca') \in \extopset  \implies \ca \neq \ca' \\
        \quad {} \land (\otI, \addr) \in \extopset \implies (\stub, \addr, \stub) \notin \extopset \\ 
    \end{array}
\end{rclarray}
\] 
The composition \(\extopset_{1} \composeO \extopset_{2} \) is disjointed set union if the result is well-formed.
Then, given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stacks$, the \emph{fingerprint} is interpreted through function, $\evalF[(., .)]{.}: \FAst \times \LEnv \times \Stacks \parfun \powerset{\scalebox{.8}{\(\powerset{\ExtOps}\)}}$.
\[
\begin{rclarray}
    \evalF{\lexpr_{1} \fpR \lexpr_{2}} & \defeq & \Set{\Set{(\otR, \evalLE{\lexpr_{1}}, \evalLE{\lexpr_{2}})}} \\
    \evalF{\lexpr_{1} \fpW \lexpr_{2}} & \defeq & \Set{\Set{(\otW, \evalLE{\lexpr_{1}}, \evalLE{\lexpr_{2}})}} \\
    \evalF{\lexpr \fpI} & \defeq & \Set{\Set{(\otI, \evalLE{\lexpr})}} \\
    \evalF{\fpE} & \defeq & \Setcon{\extopset}{\for{\extop \in \extopset} \extop = (\otI, \stub)} \\
    \evalF{\cass{\kap(\vec{\lvar})}{\lrid} \fpA} & \defeq & \Set{\Set{(\otA, \evalC{\cass{\kap(\vec{\lvar})}{\lrid}})}} \\
    \evalF{\cass{\kap(\vec{\lvar})}{\lrid} \fpD} & \defeq & \Set{\Set{(\otD, \evalC{\cass{\kap(\vec{\lvar})}{\lrid}})}} \\
    \evalF{\fp_{1} \sep \fp_{2}} & \defeq & \Setcon{\extopset_{1} \composeO \extopset_{2}}{\extopset_{1} \in \evalF{\fp_{1}} \land \extopset_{2} \in \evalF{\fp_{2}}} \\
\end{rclarray}
\]
\end{defn}

\sx{ It should be fine for local assertion to include the capabilities, as it either becomes frame or (not sure) helps local reasoning}
The local assertions include normal separation logic assertions and fingerprint assertions.
The standard separation assertions describe the current local state, while the fingerprints are all the local effects that will be committed to the database.

\begin{definition}[Local assertions]
\label{def:local_assertions}
Given the set of logical expressions \( \LExpr \), logical variables \( \LVar \) and fingerprint assertion \( \fp \in \FAst \), the set of \emph{local assertions}, $\lpre,  \lpost \in \LAst$, is defined inductively by the following grammar, 
\[
\begin{rclarray}
	\lpre, \lpost  & ::= & \False \mid \True \mid \lpre \land \lpost \mid \lpre \lor \lpost \mid \exsts{\lvar} \lpre \mid \lpre \implies \lpost \mid \Emp \mid \lexpr \pt \lexpr \mid \fp \mid \lpre \sep \lpost  \\
\end{rclarray}	 
\]
Given a logical environment $\lenv \in \LEnv$, the \emph{local interpretation function}, $\evalLS[(.,.)]{.}: \LAst \times \LEnv \times \LAst \parfun \powerset{\Heaps \times \powerset{\ExtOps}} $, is defined over the structure of local assertions as follows,
\[
\begin{rclarray}
	\evalLS{\assfalse} & \eqdef & \emptyset \\
	\evalLS{\asstrue} & \defeq & \Heaps \times \Opsets \\
	\evalLS{\lpre \land \lpost} & \defeq & \evalLS{\lpre} \cap \evalLS{\lpost} \\
	\evalLS{\lpre \lor \lpost} & \defeq & \evalLS{\lpre} \cup \evalLS{\lpost} \\
	\evalLS{\exsts{\lvar} \lpre} & \defeq & \bigcup\limits_{\val \in \textnormal{\Val}}\evalLS[\lenv\remapsto{\lvar}{\val}, \stk]{\lpre}  \\
	\evalLS{\lpre \implies \lpost} & \defeq & \Setcon{(\h, \extopset)}{(\h , \extopset) \in \evalLS{\lpre} \implies (\h , \extopset) \in \evalLS{\lpost}}\\
	\evalLS{\assemp} & \defeq & \Set{ ( \unitH, \unitE) }  \\
	\evalLS{\lexpr_{1} \pt \lexpr_2 } & \defeq & \Set{ (\evalLE{\lexpr_1} \pt \evalLE{\lexpr_2}, \unitE) } \\
	\evalLS{ \fp } & \defeq & \Setcon{ (\unitH, \extopset )}{\extopset \in \evalF{\fp}} \\
	\evalLS{\lpre \sep \lpost} & \defeq & 
    \Setcon{
        (\h_1 \composeH \h_2, \extopset_{1} \composeE \extopset_{2})
    }{ 
        (\h_{1},\extopset_{1}) \in \evalLS{\lpre} 
        \land (\h_{2}, \extopset_{2} ) \in \evalLS{\lpost} 
    } 
\end{rclarray}
\]
\end{definition}

Observe that program expressions $\Expr$  (\defin\ref{def:language}) are contained in logical expressions $\LExpr$ (\defin\ref{def:local_assertions} above), \ie $\Expr \subset \LExpr$. 
%For readability, we will write angle brackets, \eg \( \fpass{(\etR, \vx, 0)} \) instead of curly brackets \( \fpto{\Set{(\etR, \vx, 0)}} \) for fingerprint assertions.

\subsection{Global/Program}

%The interference \( \perm{\kap} :  \exsts{\vec{\lvar}} \bar{\lpre} \mat \fp \) says if a thread holds the capability \( \cass{\kap}{}\) and \emph{the current state of database} satisfies the assertions \( \bar{\lpre} \), the thread is allowed to commit a transaction that has the fingerprint \( \fp \).
%The current state of database refers to the state that all the committed transactions are visible.

%\begin{defn}[Interference]
%\label{def:intf}
%Assume standard separation logic assertion \( \bar{\lpre}\) (the local assertion \( \LAst \) without fingerprint).
%Given the fingerprint assertion \( \fp \in \Fingerprint \) (\defref{def:fingerprint}), the grammar of \emph{interference assertions}, \( \intass \in \IAst \), is defined as the follows,
%\[
%\begin{rclarray}
	%\intass & ::=  &
	%\emptyset \mid \Set{ \perm{\kap} :  \exsts{\vec{\lvar}} \bar{\lpre} \mat \fp } \cup \intass 
%\end{rclarray}
%\]
%The interference assertions are interpreted to a set of \emph{interference environments} that is a function from client-specified capabilities to pairs of history heaps and operations,
%\[
%\begin{rclarray}
    %\inter \in \Interference & \defeq & \Kaps \to \powerset{\HisHeaps \times \Opsets}
%\end{rclarray}
%\]
%Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stacks$, the \emph{interference interpretation} function, $\evalI[(., .)]{.}: \IAst \times \LEnv \times \Stacks \to \Interference$, is defined as follows,
%%
%\[
%\begin{rclarray}
	%\evalI{\emptyset}(\kap) & \eqdef & \emptyset \\
	%\evalI{\Set{ \perm{\kap} : \exsts{\vec{\lvar}} \bar{\lpre} \mat \fp } \cup \intass }(\kap') & \eqdef &
    %\begin{cases}
    %\Setcon{(\hh, \evalF[\lenv',\stk]{\fp})}{\exsts{\h} \h \in \evalLS[\lenv',\stk]{\bar{\lpre}} \land {} \\ \h = \clpsHH{\hh} } \cup \evalI{\intass}(\kap')  & \kap = \kap' \\
    %\evalI{\intass}(\kap') & \text{ otherwise} \\
    %\end{cases} \\
    %& & \text{where there exists a vector of values \( \vec{\val}\) such that } \lenv' = \lenv\rmto{\vec{\lvar}}{\vec{\val}} \\
%\end{rclarray}
%\] 
%\end{defn}

%We will write \( \intfH(\kap) \)  and \( \intfO(\kap) \) for the first and second projections of all the elements.

The interference \( \perm{\kap} : \exsts{\vec{\lvar}} \fp \) says if a thread holds the capability \( \perm{\kap} \), it is allowed to commit a transaction that has the fingerprint \( \fp \).

\sx{Parameter of the \( \kap \)?}
\begin{defn}[Interference]
\label{def:intf}
Given the fingerprint assertion \( \fp \in \Fingerprint \) (\defref{def:fingerprint}), the grammar of \emph{interference assertions}, \( \intass \in \IAst \), is defined as the follows,
\[
\begin{rclarray}
	\intass & ::=  &
	\emptyset \mid \Set{ \perm{\kap} :  \exsts{\vec{\lvar}} \fp } \cup \intass 
\end{rclarray}
\]
The interference assertions are interpreted to a set of \emph{interference environments} that is a function from client-specified capabilities to sets of operations,
\[
\begin{rclarray}
    \inter \in \Interference & \defeq & \Kaps \to \powerset{\powerset{\ExtOps}}
\end{rclarray}
\]
Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stacks$, the \emph{interference interpretation} function, $\evalI[(., .)]{.}: \IAst \times \LEnv \times \Stacks \to \Interference$, is defined as follows,
%
\[
\begin{rclarray}
	\evalI{\emptyset}(\kap) & \eqdef & \emptyset \\
	\evalI{\Set{ \perm{\kap} : \exsts{\vec{\lvar}} \fp } \cup \intass }(\kap') & \eqdef &
    \begin{cases}
    \Setcon{\extopset}{ \exsts{\vec{\val}} \extopset \in \evalF[\lenv\rmto{\vec{\lvar}}{\vec{\val}},\stk]{\fp} } \cup \evalI{\intass}(\kap')  & \kap = \kap' \\
    \evalI{\intass}(\kap') & \text{ otherwise} \\
    \end{cases} \\
\end{rclarray}
\] 
\end{defn}

%\begin{defn}[Labelled transition system]
%\label{def:labelled-transition-system}
%The labelled transition system is a tuple \( ( \hhset \times \cuset, \opsetset,\toLTS{}, \hhset_{0} \times \cuset_{0}, \como) \) consisting of pairs of history heaps and cuts \( \hhset \times \cuset \), a set of sets of operations \( \opsetset \subseteq \Opsets \), a relation \( \toLTS{} : \HisHeaps \times \Opsets \times \HisHeaps \), a set of initial history heaps and cuts \( \hhset_{0} \times \cuset_{0} \) and the consistency model associated with the transition system \( \como \).
%Assume all the initial abstract executions satisfies the consistency model.
%The relation \( \toLTS{}\) is defined as the follows,
%\[
%\begin{rclarray}
    %(\hh, \cu) \toLTS{\opset} (\hh',\cu') & \defeq &
    %\begin{array}[t]{@{}l}
        %\exsts{\thcu, \thcu', \txid, \thid}
        %\txid \in \func{fresh}{\hh} 
        %\land \hh' = \func{commit}{\hh, \cu, \txid, \opset} 
        %\land \cu' = \func{update}{\hh', \cu, \opset} \\
        %\quad {} \land ((\hh,\thcu),(\hh',\thcu')) \in \como
        %\land \h = \clpsHH{\hh,\cu} 
        %\land \thcu(\thid) = \cu 
        %\land \thcu'(\thid) = \cu' \\
        %\quad {} \land \for{\addr,\val} (\otR, \addr, \val)  \in \opset \implies \h(\addr) = \val
    %\end{array}
%\end{rclarray}
%\]
%\end{defn}

We lift the interference to a invariant.
The invariant is a labelled transition system that describes how a region evolves providing all the specified operations.

\begin{defn}[Invariant of a region]
\label{def:labelled-transition-system}
\label{def:invariant-region}
\label{def:world2aexec}
\label{def:state2aexec}
Assuming a global function, \( \funcn{init} : \RegionID \to \powerset{ \HisHeaps \times \powerset{\Views} \times \powerset{\Caps} } \) that returns initial history heaps, sets of views, and a set of capabilities for regions, the invariant of a region, namely \( \func{inv}{\rid, \intf} \), is the labelled transition system with respect to \( \intf \), where the initial states \( \func{init}{\rid}\), the configuration is a tuple of history heap \( \hh \in \hhset \), a set of views \( \viset \in \visetset \), and capabilities, and the labels are client-specified capabilities \( \kap \).
\[
\begin{rclarray}
    \func{inv}{\rid, \intf} & \defeq & (\hhset \times \visetset, \toLTS{}, \func{init}{\rid}, \kapset) \\
\end{rclarray}
\]
The transition system is the least fix point from the relation \( {} \toLTS{} {} : (\HisHeaps \times \powerset{\Views} \times \powerset{\Caps}) \times \Kaps \times (\HisHeaps \times \powerset{\Views} \times \powerset{\Caps}) \) given the set of initial configurations \( \func{init}{\rid} \).
The relation \( \toLTS{} \) is defined as the follows,
\[
\begin{rclarray}
    (\hh, \viset \uplus \Set{\vi}, \ca ) \toLTS{\kap} (\hh',\viset \uplus \Set{\vi'}, \ca') & \defeq &
    \begin{array}[t]{@{}l}
        \exsts{\txid, \extopset} 
        \txid \in \func{fresh}{\hh} 
        \land \extopset \in \intf(\kap) \\
        \quad {} \land \hh' = \func{commit}{\hh, \vi, \txid, \func{getOps}{\extopset}}  \\
        \quad {} \land \cu' = \func{update}{\hh', \vi, \func{getOps}{\extopset}} \\
        \quad {} \land \pred{updCaps}{\ca', \ca', \func{getCaps}{\extopset}} \\
    \end{array} \\
    \func{getOps}{\extopset} & \defeq & \Setcon{\extop}{\extop \in \extopset \land \extop = (\otR,\stub,\stub) \lor \extop = (\otW, \stub, \stub)} \\
    \func{getCaps}{\extopset} & \defeq & \extopset \setminus \func{getOps}{\extopset} \\
    \pred{updCaps}{\ca, \ca', \emptyset} & \defeq & \ca = \ca' \\
    \pred{updCaps}{\ca, \ca', \Set{\otA, \ca''} \uplus \extopset} & \defeq & \exsts{\ca'''} \ca' = \ca''' \composeC \ca'' \land \pred{updCaps}{\ca, \ca''', \extopset}\\
    \pred{updCaps}{\ca, \ca', \Set{\otD, \ca''} \uplus \extopset} & \defeq & \exsts{\ca'''} \ca''' = \ca' \composeC \ca'' \land \pred{updCaps}{\ca, \ca''', \extopset}\\
\end{rclarray}
\]
\end{defn}

%\begin{defn}[Invariant of a region]
%\label{def:invariant-region}
%\label{def:world2aexec}
%\label{def:state2aexec}
%Assume two global functions, \( \funcn{init} : \RegionID \to \powerset{ \HisHeaps \times \powerset{\Views} } \) that returns initial history heaps and sets of views for regions, and \( \funcn{como} : \RegionID \to \ConsisModels \) that returns the consistency models associated to regions.
%The invariant of a region, namely \( \func{inv}{\rid, \intf} \), is the labelled transition system where the initial state is \( \func{init}{\rid}\) and all the operations are included in the interference.
%\[
%\begin{rclarray}
    %\func{inv}{\rid, \intf} & \defeq & (\hhset \times \cuset, \Setcon{\opset}{\exsts{\kap} \opset \in \intfO(\kap)}, \toLTS{}, \func{init}{\rid}, \func{como}{\rid}) \\
%\end{rclarray}
%\]
%\end{defn}

%For brevity, \( (\hh,\cu) \in \func{inv}{\rid, \intf} \) denotes \( (\hh,\cu) \in \func{inv}{\rid,\intf}\projection{1} \), and similarly \( (\hh,\cu) \toLTS{\opset} (\hh',\cu') \in \func{inv}{\rid, \intf} \).

%\sx{This well form condition allows one to write weaker interference, \eg interference satisfies both SI and SER but to prove the correctness of SER. It is fine since logic only need to be sound?}
%\begin{defn}[Well-form of a region]
%\label{def:well-form-region}
%The well-form condition of the interference, namely \( \pred{wfintf}{\rid, \intf} \) predicate, assertions for any concrete events \( \opset \), the state before the events must be included in the interference.
%\[
%\begin{rclarray}
    %\pred{wfintf}{\rid, \intf} & \defeq & 
    %\begin{array}[t]{@{}l}
        %\for{\hh, \hh', \opset} 
        %(\hh, \stub) \toLTS{\opset} (\hh',\stub) \in \func{inv}{\rid, \intf} 
        %\implies \exsts{ \kap}
        %(\hh, \opset ) \in \intf( \kap )
    %\end{array} \\
%\end{rclarray}
%\]
%\end{defn}


For brevity, \( (\hh,\vi,\ca) \in \func{inv}{\rid, \intf} \), where \( \vi \) is a single view, denotes \( \exsts{\viset } \vi \in \viset \land (\hh,\viset,\ca) \in \func{inv}{\rid,\intf}\projection{1} \), and similarly \( (\hh,\vi,\ca) \toLTS{\kap} (\hh',\vi',\ca') \in \func{inv}{\rid, \intf} \) for the second projection.

\begin{definition}[Worlds]
\label{def:world}
Given the set of history heaps $\HisHeaps$ (\defref{def:his_heap}), views \( \Views \) (\defref{def:views}), capabilities \( \Caps\) (\defref{def:capabilities}) and region identifiers \( \RegionID \), the set of \emph{shared states} is \( \SStates \eqdef \RegionID \parfun \HisHeaps \times \Views \times \Caps \times \Interference \).
Each region has its current state and the interference.
The \emph{shared state composition function}, $\composeS: \SStates \times \SStates \parfun \SStates$, is defined as $\composeS \eqdef \composeEq$, where for all domains $\sort M$ and all $m, m' \in \sort M$,
%
\[
\begin{rclarray}
	m \composeEq m' &  \eqdef  &
	\begin{cases}
		m & \text{if } m = m'\\
		\text{undefined} & \text{otherwise}
	\end{cases}
\end{rclarray}
\]
A \emph{world} \( \w \in \World \) is a pair of capabilities \( \ca \) (\defref{def:capabilities}) and a shared state \( \gs \) from which regions are well-formed and associated with disjointed part of history heaps, and separately capabilities are compatible.
Note that these constraints can be derived by \(\eraseS{(\ca, \gs)}\) contains at least one element.
Finally, there is no garbage capability.
\[
\begin{rclarray}
	\world \in \World  & \eqdef & 
    \Setcon{
        (\ca, \gs) 
    }{ 
        \exsts{\ca'}
        \ca \in \Caps 
        \land \gs \in \SStates
        \land (\stub, \stub, \ca') \in \eraseS{(\ca,\gs)}
        \land \dom(\ca') \subseteq \dom(\gs) 
    }
\end{rclarray}
\]
The function, \( \eraseW{.} : \Caps \times \SStates \parfun \powerset{\HisHeaps \times \Views} \), ensure the states of regions satisfy their invariants, erases the region identifiers from the shared state and them compose the states point-wise.
\[
\begin{rclarray}
    \eraseW{(\ca, \gs)} & \defeq & \Setcon{(\hh, \vi, \ca \composeC \ca')}{(\hh, \vi, \ca \composeC \ca') \in \func{clpsSS}{\gs}} \\
    \func{clpsSS}{\emptyset} & \defeq & \Set{(\unitHH, \unitVI, \unitC )} \\
    \func{clpsSS}{\Set{\rid \mapsto (\hh, \vi, \ca, \intf)} \uplus \gs } & \defeq & 
        \Setcon{ 
            (\hh \composeHH \hh', \vi \composeCU \vi', \ca \composeC \ca') 
        }{ 
            \dom(\hh) = \dom(\cu) \land (\hh,\cu,\ca) \in \func{inv}{\rid, \intf} \\ \quad {} \land (\hh', \vi', \ca') \in \eraseS{\gs} }\\
\end{rclarray}
\] 
% 
The \emph{world composition function}, $\composeW: \World \times \World \parfun \World$, is defined component-wise as: $\composeW \eqdef (\composeC, \composeS)$.
The \emph{world unit set} is $\unitW \eqdef \Setcon{(\ca, \gs)}{(\ca, \gs) \in \World \land \ca \in \unitC}$.
The \emph{partial commutative monoid of worlds} is $(\World, \composeW, \unitW)$.
\end{definition}

%We also use the notation \( \eraseW{.}\) for a world, which denotes to erase the shared state, \ie \( \eraseW{(\ca, \gs)} \defeq \eraseS{\gs}\).
%Because the well-form condition requires all the regions in a world must associate with the same consistency model, so we write \( \func{como}{\w} \) for the model.

%\begin{defn}[Invariant of worlds]
%Because regions in a well-defined world must disjointed with each other and have the same consistency model, the invariants of regions can be lifted to a world,
%\[
%\begin{rclarray}
    %\func{inv}{(\ca, \emptyset),\como} & \defeq & ( \Set{\unitHH}, \Set{\unitO}, \Set{(\unitHH, \unitO, \unitHH)}, \Set{\unitHH}, \como \right) \\
    %\func{inv}{\Set{\rid \mapsto (\stub, \stub, \intf)} \uplus \gs} & \defeq & \Setcon{\aexec \composeAEX \aexec' }{\aexec \in \func{inv}{\rid, \intf} \land \aexec' \in \func{inv}{\gs}} \\
    %\func{transinv}{\emptyset} & = & \Setcon{ ( \aexec , \unitE, \aexec' ) }{\aexec, \aexec' \in \unitAEX } \\
    %\func{transinv}{\Set{\rid \mapsto (\stub, \stub, \intf)} \uplus \gs} & = & 
    %\Setcon{
        %( \aexec \composeAEX \aexec_{f}, \opset \composeE \opset_{f}, \aexec' \composeAEX \aexec_{f}' ) 
    %}{
        %(\aexec, \opset, \aexec') \in \func{transinv}{\rid, \intf} \\
        %\quad \land (\aexec_{f}, \opset_{f}, \aexec_{f}') \in \func{transinv}{\gs}
    %}
%\end{rclarray}
%\]
%\end{defn}

%\begin{definition}[Assertions]
%\label{def:assertion}
%Assume standard separation logic assertion \( \bar{\lpre}, \bar{\lpost }\) (the local assertion \( \LAst \) without fingerprint) and the interpretation function, The set of \emph{assertions}, $\gpre, \gpost \in \Ast$, are defined by the following inductive grammar:
%\[
%\begin{rclarray}
	%\gpre , \gpost & \defeq & \False \mid \True \mid \gpre \land \gpost \mid \gpre \lor \gpost \mid \exsts{\lvar}\gpre \mid \gpre \implies \gpost \mid \assemp \mid \cass{\kap}{\lrid} \mid \gpre \sep \gpost \mid \sptboxass{\bar{\lpre}}{\bar{\lpost}}{\lrid}{\intass}\\
%\end{rclarray}
%\]
%%
%where $\lvar, \lrid \in \LVar$, $\lexpr_1, \lexpr_2 \in \LExpr$ (\defin\ref{def:local_assertions}), $\kap \in \Kaps$ (\defin\ref{def:capabilities}) and $\intass \in \IAst$ (\defin\ref{def:intf}).
%Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stacks$, the \emph{assertion interpretation} function, $\evalW[(., .)]{.}: \Ast \times \LEnv \times \Stacks \to \powerset{\World}$, is defined as follows:
%%
%\[
%\begin{rclarray}
	%\evalW{\False} & \defeq & \emptyset \\
	%\evalW{\True} & \defeq & \World \\
	%\evalW{\emp} & \defeq & \unitW \\
	%\evalW{\gpre \land \gpost} & \defeq & \evalW{\gpre} \cap \evalW{\gpost} \\
	%\evalW{\gpre \lor \gpost} & \defeq & \evalW{\gpre} \cup \evalW{\gpost} \\ 
	%\evalW{\exsts{\lvar}  \gpre} & \defeq & \bigcup\limits_{\val \in \textnormal{\Val}} \evalW[\lenv\remapsto{\lvar}{\val}, \stk]{\gpre} \\
	%\evalW{\gpre \implies \gpost} & \defeq & \Setcon{\w}{\w \in \evalW{\gpre} \implies \w \in \evalW{\gpost}} \\
	%\evalW{\cass{\kap}{\lrid}} & \defeq & \Setcon{ (\Set{\lrid \mapsto \kap}, \gs) }{\gs \in \SStates} \\
	%\evalW{ \gpre \sep \gpost } & \defeq & 
	%\Setcon{
	   %(\world_1 \composeW \world_2) 
    %}{
       %\world_1 \in \evalW{\gpre} \land \world_2 \in \evalW{\gpost}
	%} \\
	%\evalW{ \sptboxass{\bar{\lpre}}{\bar{\lpost}}{\lrid}{\intass} } & \defeq & 
    %\Setcon{
        %(\ca,\Set{\lrid \mapsto (\hh, \cu, \evalI{\intass})} \uplus \gs)
    %}{         
        %\exsts{\h_{p}, \h_{q}}
        %\ca \in \unitC 
        %\land \h_{q} \in \evalLS{\bar{\lpost}}
        %\land \h_{q} = \func{clps}{\hh, \cu} \\
        %\quad {} \land \h_{p} \in \evalLS{\bar{\lpre}}
        %\land \h_{p} = \func{clps}{\hh} 
    %} \\
%\end{rclarray}
%\]
%\end{definition}
%We will write \( \boxass{\bar{\lpre}}{\lrid}{\intass} \) as a short-hand for \( \sptboxass{\bar{\lpre}}{\bar{\lpre}}{\lrid}{\intass} \) and \(\expr \pt N\) for \( \exsts{\nat \in N} \expr \pt \nat\) where \( N \subseteq \Val\).

\sx{Explain here: box assertion, local part, shared part, intuitively how they get interpreted}

\begin{definition}[Assertions]
\label{def:assertion}
The set of \emph{assertions}, $\gpre, \gpost \in \Ast$, are defined by the following inductive grammar:
\[
\begin{rclarray}
    \bar{\lpre}, \bar{\lpost} & ::= & \False \mid \True \mid \bar{\lpre} \land \bar{\lpost} \mid \bar{\lpre} \lor \bar{\lpost} \mid \exsts{\lvar} \bar{\lpre} \mid \bar{\lpre} \implies \bar{\lpost} \mid \assemp \mid \cass{\kap}{\lrid} \mid \lexpr \pt \lexpr \mid \bar{\lpre} \sep \bar{\lpost} \\
	\gpre , \gpost & ::= & \False \mid \True \mid \gpre \land \gpost \mid \gpre \lor \gpost \mid \exsts{\lvar}\gpre \mid \gpre \implies \gpost \mid \assemp \mid \cass{\kap}{\lrid} \mid \gpre \sep \gpost \mid \boxass{\bar{\lpre}}{\lrid}{\intass}\\
\end{rclarray}
\]
%
where $\lvar, \lrid \in \LVar$, $\lexpr_1, \lexpr_2 \in \LExpr$ (\defin\ref{def:local_assertions}), $\kap \in \Kaps$ (\defin\ref{def:capabilities}) and $\intass \in \IAst$ (\defin\ref{def:intf}).
Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stacks$, the \emph{assertion interpretation} function, $\evalW[(., .)]{.}: \Ast \times \LEnv \times \Stacks \to \powerset{\World}$, is defined as follows,
%
\[
\begin{rclarray}
	\evalW{\False} & \defeq & \emptyset \\
	\evalW{\True} & \defeq & \World \\
	\evalW{\emp} & \defeq & \unitW \\
	\evalW{\gpre \land \gpost} & \defeq & \evalW{\gpre} \cap \evalW{\gpost} \\
	\evalW{\gpre \lor \gpost} & \defeq & \evalW{\gpre} \cup \evalW{\gpost} \\ 
	\evalW{\exsts{\lvar}  \gpre} & \defeq & \bigcup\limits_{\val \in \textnormal{\Val}} \evalW[\lenv\remapsto{\lvar}{\val}, \stk]{\gpre} \\
	\evalW{\gpre \implies \gpost} & \defeq & \Setcon{\w}{\w \in \evalW{\gpre} \implies \w \in \evalW{\gpost}} \\
	\evalW{\cass{\kap}{\lrid}} & \defeq & \Setcon{ (\Set{\lrid \mapsto \evalI{\kap}}, \gs) }{\gs \in \SStates} \\
	\evalW{ \gpre \sep \gpost } & \defeq & 
	\Setcon{
	   (\world_1 \composeW \world_2) 
    }{
       \world_1 \in \evalW{\gpre} \land \world_2 \in \evalW{\gpost}
	} \\
	\evalW{ \boxass{\bar{\lpre}}{\lrid}{\intass} } & \defeq & 
    \Setcon{
        (\ca, \gs)
    }{         
        \exsts{\hh, \vi, \ca', \intf}
        \ca \in \unitC 
        \land \intf = \evalI{\intass} 
        \land \gs(\lrid) = (\hh, \vi, \ca', \intf) \\
        \quad {} \land (\hh, \vi, \ca') \in \func{intp}{\bar{\lpre}, \lenv, \stk} 
        \land (\hh, \vi) \in \func{inv}{\lrid, \intf}
    } \\
    \\
    \func{intp}{\assfalse,\lenv,\stk} & \defeq & \emptyset \\
    \func{intp}{\asstrue,\lenv,\stk} & \defeq & \HisHeaps \times \Views \times \Caps \\
    \func{intp}{\assemp,\lenv,\stk} & \defeq & \Setcon{ (\unitHH, \unitVI, \ca) }{\ca \in \unitC } \\
    \func{intp}{\bar{\lpre} \land \bar{\lpost},\lenv,\stk} & \defeq & \func{intp}{\bar{\lpre},\lenv,\stk} \cap \func{intp}{\bar{\lpost},\lenv,\stk} \\ 
    \func{intp}{\bar{\lpre} \lor \bar{\lpost},\lenv,\stk} & \defeq & \func{intp}{\bar{\lpre},\lenv,\stk} \cup \func{intp}{\bar{\lpost},\lenv,\stk} \\ 
    \func{intp}{\exsts{\lvar} \bar{\lpre},\lenv,\stk} & \defeq & \bigcup\limits_{\val \in \Val} \func{intp}{\bar{\lpre}, \lenv\rmto{\lvar}{\val}, \stk} \\
    \func{intp}{\bar{\lpre} \implies \bar{\lpost},\lenv,\stk} & \defeq & \Setcon{ (\hh, \vi, \ca) }{ (\hh, \vi, \ca) \in \func{intp}{\bar{\lpre},\lenv,\stk} \implies (\hh, \vi, \ca) \in \func{intp}{\bar{\lpost},\lenv,\stk} }\\
    \func{intp}{\cass{\kap}{\lrid},\lenv,\stk} & \defeq & \Set{ (\unitHH, \unitVI, \Set{\lrid \mapsto \evalC{\kap}}) }\\
    \func{intp}{\lexpr_{1} \pt \lexpr_{2},\lenv,\stk} & \defeq & \Setcon{ (\hh, \vi, \ca) }{\ca \in \unitC \land \Set{ \evalLE{\lexpr_{1}} \mapsto \evalLE{\lexpr_{2}} } = \clpsHH{\hh, \vi} }\\
    \func{intp}{\bar{\lpre} \sep \bar{\lpost},\lenv,\stk} & \defeq & \Setcon{ (\hh \composeHH \hh', \vi \composeVI \vi', \ca \composeC \ca') }{ (\hh, \vi, \ca) \in \func{intp}{\bar{\lpre},\lenv,\stk} \land (\hh', \vi', \ca') \in \func{intp}{\bar{\lpost},\lenv,\stk} }\\
\end{rclarray}
\]
\end{definition}
