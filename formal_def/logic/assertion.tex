\subsection{Local/Transaction}

 
\begin{definition}[Logical Expressions]
\label{def:logical-expr}
Assume a countably infinite set of \emph{logical variables} $\V x \in \LVar$.
The set of \emph{logical expressions}, $ \lexpr \in \LExpr$ is defined by the following inductive grammar, where \(\val \in \Val\) (\defref{def:program_values}), \(\txvar \in \TxVars\) and \( \thvar \in \ThdVars \) (\defref{def:stacks}),
\[
\begin{rclarray}
   \lexpr & ::= & \val \mid \txvar \mid \thvar \mid \lvar \mid \lexpr + \lexpr \mid \lexpr * \lexpr \mid \dots 
\end{rclarray}
\]
Assume a set of \emph{logical environments} \(\lenv \in \LEnv: \LVar \parfun \Val\) which associates logical variables with values.
Given a stack $\stk \in \Stacks$ (\defin\ref{def:stacks}) and a logical environment $\lenv \in \LEnv$, the \emph{logical expression evaluation} function, $\evalLE[(., .)]{.}:\LExpr \times \Stacks \times \LEnv\rightharpoonup \Val$, is defined inductively over the structure of logical expressions as follows,
%
\[
    \begin{rclarray}
        \evalLE{\val} & \defeq & \val \\
        \evalLE{\txvar} & \defeq & \stk(\txvar) \\
        \evalLE{\thvar} & \defeq & \stk(\thvar) \\
        \evalLE{\lvar} & \defeq & \lenv(\lvar) \\
        \evalLE{\lexpr_1 + \lexpr_2} & \defeq & \evalLE{\lexpr_1} + \evalLE{\lexpr_2} \\
        \evalLE{\lexpr_1 * \lexpr_2} & \defeq & \evalLE{\lexpr_1} * \evalLE{\lexpr_2} \\
        \dots & \defeq & \dots \\
    \end{rclarray}
\]
\end{definition}

Note the stack \( \stk \) includes transaction variables and thread variables.

\begin{defn}[Fingerprint Assertions]
\label{def:fingerprint}
The \emph{Fingerprint assertion} also \emph{fingerprint}, \( \fp \in \FAst \), is defined as the follows, 
\[
\begin{rclarray}
    \fp & \subseteq & \Setcon{ (\etag,\lexpr_{1},\lexpr_{2}) }{ \etag \in \ETags \land \lexpr_{1}, \lexpr_{2} \in \LExpr } \\
\end{rclarray}
\] 
Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stacks$, the \emph{fingerprint interpretation} function, $\evalF[(., .)]{.}: \FAst \times \LEnv \times \Stacks \parfun \powerset{\Events}$, is defined as follows,
\sx{there is variable clash for event tags and logical expression, leave it for now}
\[
\begin{rclarray}
    \evalF{\fp} & \defeq & \Setcon{ (\etag, \evalLE{\lexpr_{1}}, \evalLE{\lexpr_{2}}) }{ (\etag, \lexpr_{1}, \lexpr_{2}) \in \fp }  \\
\end{rclarray}
\]
\end{defn}

\begin{definition}[Local assertions]
\label{def:local_assertions}
Given the set of logical expressions \( \LExpr \), logical variables \( \LVar \) and fingerprint assertion \( \FAst \), the set of \emph{local assertions}, $\lpre,  \lpost \in \LAst$, is defined inductively by the following grammar, 
\[
\begin{rclarray}
	\lpre, \lpost  & ::= & \False \mid \True \mid \lpre \land \lpost \mid \lpre \lor \lpost \mid \exsts{\lvar} \lpre \mid \Emp \mid \lexpr \pt \lexpr \mid \fp \mid \lpre \sep \lpost  \\
\end{rclarray}	 
\]
Given a logical environment $\lenv \in \LEnv$, the \emph{local interpretation function}, $\evalLS[(.,.)]{.}: \LAst \times \LEnv \parfun \Heaps \times \powerset{ \Events } $, is defined over the structure of local assertions as follows,
\[
\begin{rclarray}
	\evalLS{\assfalse} & \eqdef & \emptyset \\
	\evalLS{\asstrue} & \defeq & \Heaps \times \powerset{ \Events } \\
	\evalLS{\lpre \land \lpost} & \defeq & \evalLS{\lpre} \cap \evalLS{\lpost} \\
	\evalLS{\lpre \lor \lpost} & \defeq & \evalLS{\lpre} \cup \evalLS{\lpost} \\
	\evalLS{\exsts{\lvar} \lpre} & \defeq & \bigcup\limits_{\val \in \textnormal{\Val}}\evalLS[\lenv\remapsto{\lvar}{\val}, \stk]{\lpre}  \\
	\evalLS{\assemp} & \defeq & \Set{ ( \unitH, \emptyset) }  \\
	\evalLS{\lexpr_{1} \pt \lexpr_2 } & \defeq & \Set{ (\evalLE{\lexpr_1} \pt \evalLE{\lexpr_2}, \emptyset) } \\
	\evalLS{ \fp } & \defeq & \Set{ (\unitH, \evalF{\fp}) } \\
	\evalLS{\lpre \sep \lpost} & \defeq & 
    \Setcon{
        (\h_1 \composeH \h_2, \evset_{1} \uplus \evset_{2})
    }{ 
        (\h_{1},\evset_{1}) \in \evalLS{\lpre} 
        \land (\h_{2}, \evset_{2} ) \in \evalLS{\lpost} 
        \land (\evset_{1} = \emptyset \lor \evset_{2} = \emptyset) 
    } 
\end{rclarray}
\]
    \sx{fingerprint cannot be split}
\end{definition}

Observe that program expressions $\Expr$  (\defin\ref{def:language}) are contained in logical expressions $\LExpr$ (\defin\ref{def:local_assertions} above). That is, $\Expr \subset \LExpr$. 

\subsection{Global/Program}

\sx{
    Current idea is, for each box(region) it records a single value for each address corresponding to the ``real'' value, \ie compute through arbitrary relation. 
    And a read function(or invariable of the box), which is a function that make sense with respect to the interference and consistency model.
    By given the current values of addresses the read buffer returns all observable values.
    For example, the read function for snapshot isolation, and serialisibility will be identity, but for PSI and causal consistency probably not the identity.
    The read buffer will need semantics checking.
}
\sx{Bring back the region and capability transfer}
\begin{definition}[Capabilities]
\label{def:capabilities}
Assume a \emph{partial commutative monoid (PCM)} of \emph{client-specified capabilities} \( (\Kaps, \composeK, \unitK) \) with \( \kap \in \Kaps \), the composition \( \composeK \) the units set \( \unitK \).
Then given a set of \emph{region identifiers} \( \rid \in \RegionID \), the \emph{capability composition function} \( \ca \in \Caps \defeq \RegionID \parfun \Kaps \), where the composition \( \composeC \) is defined as the follows,
\[
    \begin{rclarray}
        (\ca_{l} \composeC \ca_{r})(\rid) & \defeq  &
        \begin{cases}
            \ca_{l}(\rid) \composeK \ca_{r}(\rid) & \rid \in \dom(\ca_{l}) \cap \dom(\ca_{l}) \\
            \ca_{l}(\rid)  & \rid \in \dom(\ca_{l}) \setminus \dom(\ca_{l}) \\
            \ca_{r}(\rid) & \rid \in \dom(\ca_{r}) \setminus \dom(\ca_{l}) \\
            \text{undefined} & \text{otherwise} \\
        \end{cases}
    \end{rclarray}
\]
, and the units set \( \unitC \defeq \Setcon{\ca}{\for{\rid} \ca(\rid) \in \unitK } \) .
\end{definition}

\sx{event set be a way to represent actions? and also for interference as a set of fingerprint meaning syntactic event sets with logical values insides}
\begin{defn}
Given the set of transaction events \( \Events \) (\defref{def:transaction-event}), the set of \emph{actions} is defined as the follows,
\[
    \begin{rclarray}
        \action \in \Actions & \eqdef & \powerset{\Events}
    \end{rclarray}
\]
\end{defn}


\begin{definition}[Actions]
\label{def:action}
Given the set of heaps \( \Heaps \) (\defref{def:heaps}) and transaction events \( \Events \) (\defref{def:transaction-event}), the set of \emph{actions} is defined as the follows,
%
\[
    \begin{rclarray}
	\action \in \Actions & \eqdef &
	\Setcon{
		((\h_{\lpre},\emptyset), (h_{\lpost},\evset))
	}{
		\h_{\lpre}, \h_{\lpost} \in \Heaps 
        \land \orth{\h_{\lpre}} = \orth{\h_{\lpost}}
        \land \evset \subseteq \Events \\
        \quad {} \land \for{\addr,\val}  
        (\etR, \addr, \val) \in \evset \implies \h_{\lpre}(\addr)  = \val \\
        \qquad {} \land (\etW, \addr, \val) \in \evset \implies \h_{\lpost}(\addr)  = \val
	}
    \end{rclarray}
\] 
where, the \emph{orthogonal} \(\orth{(.)} \) is defined as follows, for all domains \( \sort M \), all \( m \in \sort{M} \) and its composition function \( \compose{} \),
\[
    \begin{rclarray}
    \orth{m} & \eqdef & \Setcon{m}{m \compose{} m \isdef} \\
    \end{rclarray}
\]
\end{definition}

\begin{defn}[Observation]
The set of \emph{observation} is defined as the follows,
\[
\begin{rclarray}
    \observation \in \Observations & \eqdef & \Heaps \to \powerset{\Heaps} \\
\end{rclarray}
\]
\end{defn}

\sx{For a given action, we attach a pair of assertions (or multiple pairs), to specify what is the observable state by a given global state}
\begin{defn}[Observable assertions]
The set of \emph{observable assertions}, \( \oass \in \OAst \), is defined by the following grammar, 
\[
\begin{rclarray}
    \oass & ::= & \emptyset \mid \Set{ \exsts{\vec{\lvar}} \lpre \oassto \lpost} \cup \oass
\end{rclarray}
\]
Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stacks$, the \emph{observation interpretation} function, $\evalO[(., .)]{.}: \OAst \times \LEnv \times \Stacks \to (\Heaps \to \powerset{\Heaps})$, is defined as follows, 
\[
\begin{rclarray}
\evalO{\emptyset}(\h) & \defeq & \emptyset \\
\evalO{\Set{ \exsts{\vec{\lvar}} \lpre \oassto \lpost} \cup \oass}(\h) & \defeq &
\begin{cases}
\evalO{\oass}(\h)  \cup \evalLS[\lenv', \stk]{\lpost} & \exsts{ \vec{\val}} \lenv' = \lenv\rmto{\vec{\lvar}}{\vec{\val}} \land \h \in \evalLS[\lenv', \stk]{\lpre}\\
\evalO{\oass}(\h) & \text{otherwise}\\
\end{cases} \\
\end{rclarray}
\]
\end{defn}

\begin{defn}[Interference]
\label{def:intf}
Given the local assertion \( \lpre, \lpost \in \LAst \) and observable assertion \( \oass \in \OAst \), the grammar of \emph{interference assertions}, \( \intass \in \IAst \), is defined as the follows,
\[
\begin{rclarray}
	\intass & ::=  &
	\emptyset \mid \Set{ \perm{\kap} : \oass \mat \exsts{\vec{\lvar}} \lpre \transfersto \lpost } \cup \intass 
\end{rclarray}
\]
The set of \emph{interference environments} is $\inter \in \Interference \defeq \Kaps \parfun  ( \Observations \to \powerset{\Actions} )$.
Then given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stacks$, the \emph{interference interpretation} function, $\evalI[(., .)]{.}: \IAst \times \LEnv \times \Stacks \to \Interference$, is defined as follows,
%
\[
\begin{rclarray}
	\evalI{\emptyset}(\kap)(\obs) & \eqdef & \emptyset \\
	\evalI{\Set{ \perm{\kap} : \oass \mat \exsts{\vec{\lvar}} \lpre \transfersto \lpost } \cup \intass }(\kap)(\obs) & \eqdef &
    \begin{cases}
    \{ \setaction \mid \dagger  \}
	\cup 
	\evalI{\intass}(\kap)(\obs) & \text{if } \evalO{\oass}  = \obs \\
	\evalI{\intass}(\kap)(\obs) & \text{otherwise} \\
    \end{cases}
    \\
    \dagger & \equiv & 
    \begin{array}[t]{l}
        \for{ \action \in \setaction }
        \action \in \Actions 
        \land \exsts{\rid, \vec{v}, \lenv'} \\
        \quad \lenv' = \lenv \remapsto{\vec{\lvar}}{\vec v} 
		\land \action\projection{1} \in \evalLS[\lenv', \stk]{\lpre} 
        \land \action\projection{2} \in \evalLS[\lenv', \stk]{\lpost}  \\
    \end{array}
\end{rclarray}
\] 
\end{defn}


\begin{definition}[Worlds]
\label{def:world}
Given the set of heaps $\Heaps$ (\defref{def:heaps}) and a set of \emph{region identifiers} \( \rid \in \RegionID \), the set of \emph{shared states} is \( \SStates \eqdef \RegionID \to \Heaps \times \Interference \) and the \emph{shared state composition function}, $\composeS: \SStates \times \SStates \parfun \SStates$, is defined as $\composeS \eqdef \composeEq$, where for all domains $\sort M$ and all $m, m' \in \sort M$,
%
\[
\begin{rclarray}
	m \composeEq m' &  \eqdef  &
	\begin{cases}
		m & \text{if } m = m'\\
		\text{undefined} & \text{otherwise}
	\end{cases}
\end{rclarray}
\]
Combining the above with capabilities (\defref{def:capabilities}), the set of \emph{worlds} is defined as follows,
%
\[
\begin{rclarray}
	\world \in \World  & \eqdef & 
    \Setcon{
        (\ca, \gs) 
    }{ 
        \ca \in \Caps 
        \land \gs \in \SStates 
        \land \for{\rid, \rid', \h, \h'} \\
        \quad \h = \gs(\rid)\projection{1}
        \land \h' = \gs(\rid')\projection{1}
        \land \dom(\h) \cap \dom(\h') = \emptyset \\
        \quad {} \land \for{\rid''} \wfW{\rid, \gs(\rid)\projection{2}}
    }
\end{rclarray}
\]
% 
The \emph{world composition function}, $\composeW: \World \times \World \parfun \World$, is defined component-wise as: $\composeW \eqdef (\composeC, \composeS)$.
The \emph{world unit set} is $\unitW \eqdef \Setcon{(\ca, \gs)}{(\ca, \gs) \in \World \land \ca \in \unitC}$.
The \emph{partial commutative monoid of worlds} is $(\World, \composeW, \unitW)$.
\end{definition}
 
\sx{Take a short cut of the grammar but the interpretation disallows fingerprint inside the box}
\begin{definition}[Assertions]
\label{def:assertion}
Given the local assertion \( \lpre \in \LAst \) (\defref{def:local_assertions}), The set of \emph{assertions}, $\gpre, \gpost \in \Ast$, are defined by the following inductive grammar:
\[
\begin{rclarray}
	\gpre , \gpost & \defeq & \False \mid \True \mid \gpre \land \gpost \mid \gpre \lor \gpost \mid \exsts{\lvar}\gpre \mid \assemp \mid \cass{\kap}{\lrid} \mid \gpre \sep \gpost \mid \boxass{\lpre}{\lrid}{\intass}\\
\end{rclarray}
\]
%
where $\lvar, \lrid \in \LVar$, $\lexpr_1, \lexpr_2 \in \LExpr$ (\defin\ref{def:local_assertions}), $\kap \in \Kaps$ (\defin\ref{def:capabilities}) and $\intass \in \IAst$ (\defin\ref{def:intf}).
Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stacks$, the \emph{assertion interpretation} function, $\evalW[(., .)]{.}: \Ast \times \LEnv \times \Stacks \rightarrow \World$, is defined as follows:
%
\[
\begin{rclarray}
	\evalW{\False} & \defeq & \emptyset \\
	\evalW{\True} & \defeq & \World \\
	\evalW{\emp} & \defeq & \unitW \\
	\evalW{\gpre \land \gpost} & \defeq & \evalW{\gpre} \cap \evalW{\gpost} \\
	\evalW{\gpre \lor \gpost} & \defeq & \evalW{\gpre} \cup \evalW{\gpost} \\
	\evalW{\exsts{\lvar}  \gpre} & \defeq 
	& \bigcup\limits_{\val \in \textnormal{\Val}} \evalW[\lenv\remapsto{\lvar}{\val}, \stk]{\gpre} \\
	\evalW{\cass{\kap}{\lrid}} & \defeq & \Set{ (\Set{\lrid \mapsto \kap}, \unitH) } \\
	\evalW{ \gpre \sep \gpost } & \defeq & 
	\Setcon{
	   (\world_1 \composeW \world_2) 
    }{
       \world_1 \in \evalW{\gpre} \land \world_2 \in \evalW{\gpost}
	} \\
	\evalW{ \boxass{\lpre}{\lrid}{\intass} } & \defeq & 
    \Setcon{
        (\ca,\gs)
    }{
        \ca \in \unitC 
        \land (\gs(\lrid)\projection{1}, \emptyset) \in \evalLS{\lpre}
        \land \gs(\lrid)\projection{2}  = \evalI{\intass}
    } \\
\end{rclarray}
\]
\end{definition}

\begin{defn}[Invariant and well-form of a region]
Assuming two functions, \( \funcn{init} : \RegionID \to \powerset{\Aexecs} \) that returns possible initial abstract executions for regions, and \( \funcn{como} : \RegionID \to \ConsisModels \) that returns the consistency models associated with regions, the invariant of a region, namely \( \func{inv}{\rid, \intf} \), is a set of abstract executions that is closed under the interference \( \intf \),
\[
\begin{rclarray}
    \func{inv}{\rid, \intf} & \defeq & \bigcup\limits_{\nat \in \Nat}\func{iter}{\rid, \intf, \nat} 
\end{rclarray}
\]
The well-form condition of a region, namely \( \wfW{\rid, \intf}\) predicate, is defined inductively with respect to each step of the iteration.
\[
\begin{rclarray}
    \wfW{\rid, \intf} & \defeq & \for{\aexec \in \func{inv}{\rid, \intf}} \pred{wfgf}{\rid, \intf, \aexec} 
\end{rclarray}
\]
All the auxiliary functions and predicates are defined as the follows,
\[
\begin{rclarray}
    \func{iter}{\rid, \intf, 0} & \defeq & \func{init}{\rid}  \\
    \pred{wfgf}{\rid, \intf, \aexec} & \defeq & \aexec \in \func{init}{\rid}  \\
    \func{iter}{\rid, \intf, \nat} & \defeq & 
    \Setcon{ 
        \aexec' 
    }{ 
        \for{ \txid, \kap, \obs, \aexec \in \func{iter}{\rid,\intf, \nat - 1} } 
        \pred{reachable}{\aexec, \aexec', \txid, \rid, \intf, \kap, \obs}
    }  \\
    \pred{wfgf}{\rid, \intf, \aexec} & \defeq & 
    \begin{array}[t]{@{}l}
        \exsts{ \aexec', \nat, \txid, \kap, \obs } \aexec' \in \func{iter}{\rid, \intf, \nat - 1}
        \land \pred{reachable}{\aexec', \aexec, \txid, \rid, \intf, \kap, \obs} \\
        \quad {} \land \for{\h, \h'} 
        \h \in \obsstate{\aexec', \aexec'\prjT,\func{como}{\rid}\projection{2}}  \\
        \qquad {} \land \h' \in \obsstate{\aexec, \aexec\prjV^{-1}(\txid),\func{como}{\rid}\projection{2}}  \\
        \qqquad {} \implies \h' \in \obs(\h)
    \end{array} \\
    \pred{reachable}{\aexec, \aexec', \txid, \rid, \intf, \kap, \obs} & \defeq & 
    \begin{array}[t]{@{}l}
        \exsts{\vis, \po, \ar, \evset}
        ((\stub,\stub), (\stub,\evset)) \in \intf( \kap )( \obs ) \\
        \quad {} \land \aexec' = (\aexec\prjT \uplus \Set{ \txid \mapsto \evset }, \aexec\prjP \uplus \po, \aexec\prjV \uplus \vis, \aexec\prjA \uplus \ar) \\
        \quad {} \land \vis, \po \subseteq \ar = \Setcon{(\txid', \txid)}{\txid' \in \dom(\aexec\prjT)} 
        \land \aexec' \in \evalCOM{\func{como}{\rid}}
    \end{array}
\end{rclarray}
\]
\end{defn}

\begin{defn}[State-to-execution]
\label{def:world2aexec}
\label{def:state2aexec}
Given a region (identifier) \(\rid\), its current state \( \h \), and its interference \( \intf \), the function \(\funcn{s2e} \) returns all the possible abstract executions,
\[
\begin{rclarray}
    \func{s2e}{\rid, \h, \intf} & \eqdef & \func{inv}{\rid, \intf} \cap \func{h2e}{\h,\func{como}{\rid}} \\
\end{rclarray}
\]
where the \( \funcn{h2e} \) returns all the possible abstract executions where the final state satisfies the heap \( \h \), 
\[
\begin{rclarray}
    \func{h2e}{\h, (\conguar, \respo)} & \defeq & \Setcon{\aexec}{\h \in \obsstate{\aexec,\aexec\prjT,\respo}}
\end{rclarray}
\]
\end{defn}
