\subsection{Local/Transaction}

 
\begin{definition}[Logical Expressions]
\label{def:logical-expr}
Assume a countably infinite set of \emph{logical variables} $\V x \in \LVar$.
The set of \emph{logical expressions}, $ \lexpr \in \LExpr$ is defined by the following inductive grammar, where $\val \in \Val$, $\vx \in \Var$ (\defin\ref{def:prgram_values}) and $\V x \in \LVar$:
%
\[
\begin{rclarray}
   \lexpr & ::= & \val \mid \var \mid \lvar \mid \lexpr + \lexpr \mid \lexpr * \lexpr \mid \dots 
\end{rclarray}
\]
Given the set of values $\Val$ (\defin\ref{def:prgram_values}), assume a set of \emph{logical environments} $\lenv \in \LEnv: \LVar \parfun \Val$.
Given a stack $\stk \in \Stack$ (\defin\ref{def:stacks}) and a logical environment $\lenv: \LEnv$, the \emph{logical expression evaluation} function, $\evalLE[(., .)]{.}:\LExpr \times \Stack \times \LEnv\rightharpoonup \Val$, is defined inductively over the structure of logical expressions as follows: 
%
\[
    \begin{rclarray}
        \evalLE{\val} & \defeq & \val \\
        \evalLE{\var} & \defeq & \stk(\var) \\
        \evalLE{\lvar} & \defeq & \lenv(\lvar) \\
        \evalLE{\lexpr_1 + \lexpr_2} & \defeq & \evalLE{\lexpr_1} + \evalLE{\lexpr_2}   \\
        \evalLE{\lexpr_1 * \lexpr_2} & \defeq & \evalLE{\lexpr_1} * \evalLE{\lexpr_2}  
    \end{rclarray}
\]
\end{definition}

\begin{definition}[Local assertions]
\label{def:local_assertions}
Given the set of logical expressions \( \LExpr \) (\defin\ref{def:logical-expr}), the set of \emph{local assertions}, $\lpre,  \lpost \in \LAst$, is defined inductively by the following grammar, where $\fp \in \Fingerprint$ denotes a fingerprint (\defin\ref{def:fingerprint_heaps}) and $\lvar, \lrid \in \LVar$: 
%
\[
\begin{rclarray}
	\lpre, \lpost  & ::= & \False \mid \True \mid \lpre \land \lpost \mid \lpre \lor \lpost \mid \exsts{\lvar} \lpre \mid \Emp \mid \lexpr \fpt{\fp} \lexpr \mid \lpre \sep \lpost 
\end{rclarray}	 
\]
%
Given a logical environment $\lenv \in \LEnv$, the \emph{local interpretation function}, $\evalLS[(.,.)]{.}: \LAst \times \LEnv \rightarrow \powerset{\FPHeaps}$, is defined over the structure of local assertions as follows:
%
\[
\begin{rclarray}
	\evalLS{\assfalse} & \eqdef & \emptyset  \\
	\evalLS{\asstrue} & \defeq & \FPHeaps  \\
	\evalLS{\lpre \land \lpost} & \defeq & \evalLS{\lpre} \cap \evalLS{\lpost} \\
	\evalLS{\lpre \lor \lpost} & \defeq & \evalLS{\lpre} \cup \evalLS{\lpost} \\
	\evalLS{\exsts{\lvar} \lpre} & \defeq & \bigcup\limits_{\val \in \textnormal{\Val}}\evalLS[\lenv\remapsto{\lvar}{\val}, \stk]{\lpre}  \\
	\evalLS{\assemp} & \defeq & \Set{\unitFPH}  \\
	\evalLS{\lexpr_1 \fpt{\fp} \lexpr_2} & \defeq & \Set{\evalLE{\lexpr_1} \mapsto (\evalLE{\lexpr_2}, \fp) } \\
	\evalLS{\lpre \sep \lpost} & \defeq & 
    \Setcon{ \fph_1 \composeFPH \fph_2 }{ \fph_{1} \in \evalLS{\lpre} \land \fph_{2} \in \evalLS{\lpost} } 
\end{rclarray}
\]
\end{definition}

Observe that program expressions ($\expr \in \Expr$ in \defin\ref{def:language}) are contained in logical expressions ($\lexpr \in \LExpr$ in \defin\ref{def:local_assertions} above). That is, $\Expr \subset \LExpr$. 

\subsection{Global/Program}

\begin{definition}[Capabilities]
\label{def:capabilities}
Assume a partial commutative monoid for \emph{capabilities} \( (\Caps, \composeC, \unitC) \) with \( \kap, \ca \in \Caps \), where the  \( \composeC: \Caps \times \Caps \parfun \Caps \), is \emph{capability composition function}, and \( \unitC \) is the set of units.
\end{definition}


\begin{definition}[Heaps]
\label{def:heaps}
The set of \emph{heaps} is defined as \( (\Heaps, \composeH, \unitH) \) with \( \h \in \Heaps \), where \( \Heaps = \Addr \parfun \Val \),  \( \composeH \defeq \uplus \), and \( \unitH  = \Set{ \emptyset }\) is the set of units.
\end{definition}

\begin{definition}[Actions]
\label{def:action}
Given the set of fingerprint heap $\FPHeaps$ (\defin\ref{def:fingerprint_heaps}), the set of \emph{actions}, $\action \in \Actions$, is defined as follows:
%
\[
    \begin{rclarray}
	\Actions & \eqdef &
	\Setcon{
		(\fph, \fph')
	}{
		(\fph,, \fph') \in \FPHeaps \times \FPHeaps \land \orth{\fph} = \orth{\fph'}\\
		\land\ \for{\loc} \fph(\loc) = (\val, \fp) \implies \\
			\quad 	\big(\fph'(\loc) = (-, \fp') \land \addFPW{\fp} \subseteq  \fp' \big)
			\lor
			\big(\fph'(\loc) = (\val, \fp') \land \fp' = \addFPR{\fp} \big)
	}
    \end{rclarray}
\] 
where, the \emph{orthogonal} \(\orth{(.)} \) is defined as follows, for all domains \( \sort M \), all \( m \in \sort{M} \) and its composition function \( \compose{} \),
\[
    \begin{rclarray}
    \orth{m} & \eqdef & \Setcon{m}{m \compose{} m \isdef} \\
    \end{rclarray}
\]
Given the set of capabilities $\Caps$ (\defin\ref{def:capabilities}), the set of \emph{interference environments} is $\inter \in \Interference \defeq \Caps \parfun \powerset{\Actions}$.
\end{definition}

\begin{definition}[Worlds]
\label{def:world}
Given the set of heaps $\Heaps$ (\defref{def:heaps}), the set of \emph{shared states} is \( \SStates \eqdef \Heaps \) and \( \unitS \defeq \unitH \).
However, the \emph{shared state composition function}, $\composeS: \SStates \times \SStates \parfun \SStates$, is defined as: $\composeS \eqdef \composeEq$, where for all domains $\sort M$ and all $m, m' \in \sort M$,
%
\[
\begin{rclarray}
	m \composeEq m' &  \eqdef  &
	\begin{cases}
		m & \text{if } m = m'\\
		\text{undefined} & \text{otherwise}
	\end{cases}
\end{rclarray}
\]
Combining the above with capabilities (\defref{def:capabilities}), the set of \emph{worlds} is defined as follows,
%
\[
\begin{rclarray}
	\world \in \World  & \eqdef & \Caps \times \SStates
\end{rclarray}
\]
% 
The \emph{world composition function}, $\composeW: \World \times \World \parfun \World$, is defined component-wise as: $\composeW \eqdef (\composeC, \composeS)$.
The \emph{world unit set} is $\unitW \eqdef \Setcon{(\ca, \gs)}{(\ca, \gs) \in \World \land \ca \in \unitC}$.
The \emph{partial commutative monoid of worlds} is $(\World, \composeW, \unitW)$.
\end{definition}
 
\begin{defn}[Interference]
\label{def:intf}
The set of \emph{interference assertions}, \( \intass \in \IAst \), are defined by the following grammar:
\[
\begin{rclarray}
	\intass & \eqdef  &
	\emptyset \mid \Set{ \perm{\kap} : \exsts{\vec{\lvar}} \lpre \transfersto \lpost } \cup \intass 
\end{rclarray}
\]
Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stack$, the \emph{interference interpretation} function, $\evalI[(., .)]{.}: \IAst \times \LEnv \times \Stack \parfun \Interference$, is defined as follows, for all $\kap \in \Caps$:
%
\[
\begin{rclarray}
	\evalI{\emptyset}(\kap) & \eqdef & \emptyset \\
	\evalI{\Set{ \perm{\kap} : \exsts{\vec{\lvar}} \lpre \transfersto \lpost } \cup \intass }(\kap) & \eqdef &
	\Setcon{
		(\fph_\lpre, \fph_\lpost)	 
    }{
		(\fph_\lpre, \fph_\lpost)	\in \Actions \land \exsts{\rid, \vec{v}, \lenv'} \land \lenv' = \lenv \remapsto{\vec{\lvar}}{\vec v} \land {} \\
			\fph_\lpre \in \evalLS[\lenv', \stk]{\lpre} \land \fph_\lpost \in \evalLS[\lenv', \stk]{\lpost}
	}
	\cup 
	\evalI{\intass}(\kap)
\end{rclarray}
\] 
\end{defn}
\sx{Default fingerprint in interference. Pre is empty and post is read}

\begin{definition}[Assertions]
\label{def:assertion}
The set of \emph{assertions}, $\gpre, \gpost \in \Ast$, are defined by the following inductive grammar:
\[
\begin{rclarray}
	\gpre , \gpost & \defeq & \False \mid \True \mid \gpre \land \gpost \mid \gpre \lor \gpost  \mid \exsts{\lvar}\gpre \mid \Emp \mid \lexpr_1 \pointsto \lexpr_2 \mid  \perm{\kap} \mid \gpre \sep \gpost \\
\end{rclarray}
\]
%
where $\lvar, \lrid \in \LVar$, $\lexpr_1, \lexpr_2 \in \LExpr$ (\defin\ref{def:local_assertions}), $\kap \in \Kaps$ (\defin\ref{def:capabilities}) and $\intass \in \IAst$ (\defin\ref{def:intf}).
Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stack$, the \emph{assertion interpretation} function, $\evalW[(., .)]{.}: \Ast \times \LEnv \times \Stack \rightarrow \World$, is defined as follows:
%
\[
\begin{rclarray}
	\evalW{\False} & \defeq & \emptyset \\
	\evalW{\True} & \defeq & \World \\
	\evalW{\emp} & \defeq & \unitW \\
	\evalW{\gpre \land \gpost} & \defeq & \evalW{\gpre} \cap \evalW{\gpost} \\
	\evalW{\gpre \lor \gpost} & \defeq & \evalW{\gpre} \cup \evalW{\gpost} \\
	\evalW{\exsts{\lvar}  \gpre} & \defeq 
	& \bigcup\limits_{\val \in \textnormal{\Val}} \evalW[\lenv\remapsto{\lvar}{\val}, \stk]{\gpre} \\
	\evalW{\lexpr_1 \pt \lexpr_2} & \defeq & 
    \Setcon{
		(\ca, \h) 
    }{
		\exsts{ \h' } \h = \Set{\evalLE{\lexpr_1} \mapsto \evalLE{\lexpr_2} } \composeH \h' \land \ca \in \unitC
	} \\
	\evalW{\perm{\kap}} & \defeq & 
    \Setcon{
		(\kap, \h) 
    }{
        \h \in \Heaps
	} \\
	\evalW{ \gpre \sep \gpost } & \defeq & 
	\Setcon{
	   (\world_1 \composeW \world_2) 
    }{
       \world_1 \in \evalW{\gpre} \land \world_2 \in \evalW{\gpost}
	}   
\end{rclarray}
\]
\end{definition}
