\subsection{Local/Transaction}

\begin{definition}[capabilities]
\label{def:capabilities}
Assume a partial commutative monoid for \emph{capabilities} \( (\Caps, \composeC, \unitC) \) with \( \kap, \ca \in \Caps \), where the  \( \composeC: \Caps \times \Caps \parfun \Caps \), is \emph{capability composition function}, and \( \unitC \) is the set of units.
\end{definition}
 
\begin{definition}[Local state]
\label{def:local_state}
Given the partial commutative monoids of fingerprint heaps \( (\FPHeaps, \composeFP, \{\unitFP\}) \) in \defin \ref{def:fingerprint_heaps} and capabilities \( (\Caps, \composeC, \unitC) \) in \defin\ref{def:capabilities}, the set of \emph{local states} is $\ls \in \LStates \eqdef \FPHeaps \times \Caps$.
The \emph{local state composition function}, $\composeLS: \LStates \times \LStates \parfun \LStates$, is defined component-wise as: $\composeLS \eqdef (\composeFP, \composeC)$.
The \emph{local state unit element} is $\unitLS \eqdef (\unitFP, \unitC)$.
The \emph{partial commutative monoid of local states} is $(\LStates, \composeLS, \{\unitLS\})$.
\end{definition}
 
Given a local state $\ls$, we write $\lsFPH{\ls}$ and $\lsCAP{\ls}$ for the first and second projections of $\ls$, respectively.
 
\begin{definition}[Logical Expressions]
\label{def:logical-expr}
Assume a countably infinite set of \emph{logical variables} $\V x \in \LVar$.
The set of \emph{logical expressions}, $ \lexpr \in \LExpr$ is defined by the following inductive grammar, where $\val \in \Val$, $\vx \in \Var$ (\defin\ref{def:prgram_values}) and $\V x \in \LVar$:
%
\[
\begin{rclarray}
   \lexpr & ::= & \val \mid \var \mid \lvar \mid \lexpr + \lexpr \mid \lexpr * \lexpr \mid \dots 
\end{rclarray}
\]
Given the set of values $\Val$ (\defin\ref{def:prgram_values}), assume a set of \emph{logical environments} $\lenv \in \LEnv: \LVar \parfun \Val$.
Given a stack $\stk \in \Stack$ (\defin\ref{def:stacks}) and a logical environment $\lenv: \LEnv$, the \emph{logical expression evaluation} function, $\evalLE[(., .)]{.}:\LExpr \times \Stack \times \LEnv\rightharpoonup \Val$, is defined inductively over the structure of logical expressions as follows: 
%
\[
    \begin{rclarray}
        \evalLE{\val} & \defeq & \val \\
        \evalLE{\var} & \defeq & \stk(\var) \\
        \evalLE{\lvar} & \defeq & \lenv(\lvar) \\
        \evalLE{\lexpr_1 + \lexpr_2} & \defeq & \evalLE{\lexpr_1} + \evalLE{\lexpr_2}   \\
        \evalLE{\lexpr_1 * \lexpr_2} & \defeq & \evalLE{\lexpr_1} * \evalLE{\lexpr_2}  
    \end{rclarray}
\]
\end{definition}

\begin{definition}[Local assertions]
\label{def:local_assertions}
Given the set of logical expressions \( \LExpr \) (\defin\ref{def:logical-expr}), the set of \emph{local assertions}, $\lpre,  \lpost \in \LAst$, is defined inductively by the following grammar, where $\fp \in \Fingerprint$ denotes a fingerprint (\defin\ref{def:fingerprint_heaps}) and $\lvar, \lrid \in \LVar$: 
%
\[
\begin{rclarray}
	\lpre, \lpost  & ::= & \False \mid \True \mid \lpre \land \lpost \mid \lpre \lor \lpost \mid \exsts{\lvar} \lpre \mid \Emp \mid \lexpr \fpt{\fp} \lexpr \mid \cass{\kap}{} \mid \lpre \sep \lpost 
\end{rclarray}	 
\]
%
Given a logical environment $\lenv \in \LEnv$, the \emph{local interpretation function}, $\evalLS[(.,.)]{.}: \LAst \times \LEnv \rightarrow \powerset{\LStates}$, is defined over the structure of local assertions as follows:
%
\[
\begin{rclarray}
	\evalLS{\assfalse} & \eqdef & \emptyset  \\
	\evalLS{\asstrue} & \defeq & \LStates  \\
	\evalLS{\lpre \land \lpost} & \defeq & \evalLS{\lpre} \cap \evalLS{\lpost} \\
	\evalLS{\lpre \lor \lpost} & \defeq & \evalLS{\lpre} \cup \evalLS{\lpost} \\
	\evalLS{\exsts{\lvar} \lpre} & \defeq & \bigcup\limits_{\val \in \textnormal{\Val}}\evalLS[\lenv\remapsto{\lvar}{\val}, \stk]{\lpre}  \\
	\evalLS{\assemp} & \defeq & \Set{\unitLS}  \\
	\evalLS{\lexpr_1 \fpt{\fp} \lexpr_2} & \defeq & 
    \Setcon{
		(\fph, \ca ) 
    }{
	   \fph {=} \Set{\evalLE{\lexpr_1} \mapsto (\evalLE{\lexpr_2}, \fp) }
       \land \ca \in \unitC
	} \\
	\evalLS{\cass{\kap}{}} & \defeq & \Set{ (\unitFP, \kap) } \\
	\evalLS{\lpre \sep \lpost} & \defeq & 
    \Setcon{ \ls_1 \composeLS \ls_2 }{ \ls_1 \in \evalLS{\lpre} \land \ls_2 \in \evalLS{\lpost} } 
\end{rclarray}
\]
\end{definition}

Observe that program expressions ($\expr \in \Expr$ in \defin\ref{def:language}) are contained in logical expressions ($\lexpr \in \LExpr$ in \defin\ref{def:local_assertions} above). That is, $\Expr \subset \LExpr$. 

\subsection{Global/Program}
\begin{definition}[Actions]
\label{def:action}
Given the set of local states $\LStates$ (\defin\ref{def:local_state}), the set of \emph{actions}, $\action \in \Actions$, is defined as follows:
%
\[
    \begin{rclarray}
	\Actions & \eqdef &
	\Setcon{
		((\fph, \ca), (\fph', \ca'))
	}{
		((\fph, \ca), (\fph', \ca')) \in \LStates \times \LStates \land \orth{(\fph, \ca)} = \orth{(\fph', \ca')}\\
		%\land\ \dom(\fph) = \dom(\fph') \\
		\land\ \for{\loc} \fph(\loc) = (\val, \fp) \implies \\
			\quad 	\big(\fph'(\loc) = (-, \fp') \land \addFPW{\fp} \subseteq  \fp' \big)
			\lor
			\big(\fph'(\loc) = (\val, \fp') \land \fp' = \addFPR{\fp} \big)
	}
    \end{rclarray}
\] 
where, the \emph{orthogonal} \(\orth{(.)} : \LStates \to \powerset{\LStates} \) is defined as follows:
\[
    \begin{rclarray}
    \orth{\ls} & \eqdef & \Setcon{\ls'}{\ls \composeLS \ls' \isdef} \\
    \end{rclarray}
\]
Given the set of primitive capabilities $\Kaps$ (\defin\ref{def:capabilities}), the set of \emph{interference environments} is $\inter \in \Interference \eqdef \Kaps \parfun \powerset{\Actions}$.
\end{definition}

\begin{definition}[Logical states]
\label{def:logical_states}
Given the partial commutative monoids of heaps \( (\PHeap, \composeH, \{\unitH\}) \) in \defin\ref{def:heaps} and capabilities $(\Caps, \composeC, \unitC)$ in \defin\ref{def:capabilities}, the set of \emph{logical states} is: \(\lgs \in \LGStates \eqdef \PHeap \times \Caps\).
The \emph{logical state composition function}, $\composeLGS: \LGStates \times \LGStates \parfun \LGStates$, is defined component-wise as: $\composeLGS \eqdef (\composeH, \composeC)$.
The \emph{logical state unit element} is $\unitLGS \eqdef \Setcon{(\unitH, \ca)}{\ca \in \unitC}$.
The \emph{partial commutative monoid of logical states} is $(\LGStates, \composeLGS,\unitLGS)$.
\end{definition}

\begin{definition}[Worlds]
\label{def:world}
Given the set of region identifiers $\RegionID$ (\defin\ref{def:capabilities}) and the partial commutative monoid of logical states $(\LGStates, \composeLGS, \unitLGS)$ in \defin\ref{def:logical_states}, the set of \emph{shared states} is \( \SStates \eqdef \LGStates \) and \( \unitS \defeq \unitLGS \).
However, the \emph{shared state composition function}, $\composeS: \SStates \times \SStates \parfun \SStates$, is defined as: $\composeS \eqdef \composeEq$, where for all domains $\sort M$ and all $m, m' \in \sort M$,
%
\[
\begin{rclarray}
	m \composeEq m' &  \eqdef  &
	\begin{cases}
		m & \text{if } m = m'\\
		\text{undefined} & \text{otherwise}
	\end{cases}
\end{rclarray}
\]
%
The \emph{flattening} function, $\flattenW{.}: \Caps \times \SStates  \parfun \LGStates$, is defined as follows,
%
\[
\begin{rclarray}
	\flattenW{(\ca, (\h, \ca') )}  & \eqdef & (\h, \ca \composeC \ca')
\end{rclarray}
\]
%
A pair $(\ca, \gs) \in \Caps \times \SStates$ is \emph{well-formed}, written $\wfW{\lgs, \gs}$,
%
\[
\begin{rclarray}
	\wfW{\ca, \gs} & \defeq & \flattenW{(\ca, \gs)}\isdef \\
\end{rclarray}
\]
%
The set of \emph{worlds}, $\world \in \World$, is defined as follows,
%
\[
\begin{rclarray}
	\world \in \World  & \eqdef  
	& \Setcon{
		(\ca, \gs)
	}{
		(\ca, \gs) \in \Caps \times \SStates \land \wfW{\ca, \gs}
	}
\end{rclarray}
\]
% 
The \emph{world composition function}, $\composeW: \World \times \World \parfun \World$, is defined component-wise as: $\composeW \eqdef (\composeC, \composeS)$.
The \emph{world unit set} is $\unitW \eqdef \Setcon{(\ca, \gs)}{(\ca, \gs) \in \World \land \ca \in \unitC}$.
The \emph{partial commutative monoid of worlds} is $(\World, \composeW, \unitW)$.
\end{definition}
 
\begin{defn}[Interference]
\label{def:intf}
The set of \emph{interference assertions}, \( \intass \in \IAst \), are defined by the following grammar:
\[
\begin{rclarray}
	\intass & \eqdef  &
	\emptyset \mid \Set{ \perm{\kap} : \exsts{\vec{\lvar}} \lpre \transfersto \lpost } \cup \intass 
\end{rclarray}
\]
Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stack$, the \emph{interference interpretation} function, $\evalI[(., .)]{.}: \IAst \times \LEnv \times \Stack \parfun \Interference$, is defined as follows, for all $\kap \in \Caps$:
%
\[
\begin{rclarray}
	\evalI{\emptyset}(\kap) & \eqdef & \emptyset \\
	\evalI{\Set{ \perm{\kap} : \exsts{\vec{\lvar}} \lpre \transfersto \lpost } \cup \intass }(\kap) & \eqdef &
	\Setcon{
		(\ls_\lpre, \ls_\lpost)	 
    }{
		(\ls_\lpre, \ls_\lpost)	\in \Actions \land \exsts{\rid, \vec{v}, \lenv'} \land \lenv' = \lenv \remapsto{\vec{\lvar}}{\vec v} \land {} \\
			\ls_\lpre \in \evalLS[\lenv', \stk]{\lpre} \land \ls_\lpost \in \evalLS[\lenv', \stk]{\lpost}
	}
	\cup 
	\evalI{\intass}(\kap)
\end{rclarray}
\] 
\end{defn}
\sx{Default fingerprint in interference. Pre is empty and post is read}

\begin{definition}[Assertions]
\label{def:assertion}
The set of \emph{assertions}, $\gpre, \gpost \in \Ast$, are defined by the following inductive grammar:
\[
\begin{rclarray}
	\gpre , \gpost & \defeq & \False \mid \True \mid \gpre \land \gpost \mid \gpre \lor \gpost  \mid \exsts{\lvar}\gpre \mid \Emp \mid \lexpr_1 \pointsto \lexpr_2 \mid \cassL{\kap} \mid \cassS{\kap} \mid \gpre \sep \gpost \\
\end{rclarray}
\]
%
where $\lvar, \lrid \in \LVar$, $\lexpr_1, \lexpr_2 \in \LExpr$ (\defin\ref{def:local_assertions}), $\kap \in \Kaps$ (\defin\ref{def:capabilities}) and $\intass \in \IAst$ (\defin\ref{def:intf}).
Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stack$, the \emph{assertion interpretation} function, $\evalW[(., .)]{.}: \Ast \times \LEnv \times \Stack \rightarrow \World$, is defined as follows:
%
\[
\begin{rclarray}
	\evalW{\False} & \defeq & \emptyset \\
	\evalW{\True} & \defeq & \World \\
	\evalW{\emp} & \defeq & \unitW \\
	\evalW{\gpre \land \gpost} & \defeq & \evalW{\gpre} \cap \evalW{\gpost} \\
	\evalW{\gpre \lor \gpost} & \defeq & \evalW{\gpre} \cup \evalW{\gpost} \\
	\evalW{\exsts{\lvar}  \gpre} & \defeq 
	& \bigcup\limits_{\val \in \textnormal{\Val}} \evalW[\lenv\remapsto{\lvar}{\val}, \stk]{\gpre} \\
	\evalW{\lexpr_1 \pt \lexpr_2} & \defeq & 
    \Setcon{
		(\ca, (\h, \ca')) 
    }{
		\exsts{ \h' } \h = \Set{\evalLE{\lexpr_1} \mapsto \evalLE{\lexpr_2} } \composeH \h' \land \ca \in \unitC
	} \\
	\evalW{\cassL{\kap}} & \defeq & \Set{ (\kap, \gs) } \\
	\evalW{\cassS{\kap}} & \defeq & 
    \Setcon{
		(\ca, (\h, \ca')) 
    }{
		\exsts{ \ca'' } \ca' = \kap \composeC \ca'' \land \ca \in \unitC
	} \\
	\evalW{ \gpre \sep \gpost } & \defeq & 
	\Setcon{
	   (\world_1 \composeW \world_2) 
    }{
       \world_1 \in \evalW{\gpre} \land \world_2 \in \evalW{\gpost}
	}   
\end{rclarray}
\]
\end{definition}
