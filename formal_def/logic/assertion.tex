\subsection{Local/Transaction}

 
\begin{definition}[Logical Expressions]
\label{def:logical-expr}
Assume a countably infinite set of \emph{logical variables} $\V x \in \LVar$.
The set of \emph{logical expressions}, $ \lexpr \in \LExpr$ is defined by the following inductive grammar, where \(\val \in \Val\) (\defref{def:program_values}), \(\txvar \in \TxVars\) and \( \thvar \in \ThdVars \) (\defref{def:stacks}),
\[
\begin{rclarray}
   \lexpr & ::= & \val \mid \txvar \mid \thvar \mid \lvar \mid \lexpr + \lexpr \mid \lexpr * \lexpr \mid \dots 
\end{rclarray}
\]
Assume a set of \emph{logical environments} \(\lenv \in \LEnv: \LVar \parfun \Val\) which associates logical variables with values.
Given a stack $\stk \in \Stacks$ (\defin\ref{def:stacks}) and a logical environment $\lenv \in \LEnv$, the \emph{logical expression evaluation} function, $\evalLE[(., .)]{.}:\LExpr \times \Stacks \times \LEnv\rightharpoonup \Val$, is defined inductively over the structure of logical expressions as follows,
%
\[
    \begin{rclarray}
        \evalLE{\val} & \defeq & \val \\
        \evalLE{\txvar} & \defeq & \stk(\txvar) \\
        \evalLE{\thvar} & \defeq & \stk(\thvar) \\
        \evalLE{\lvar} & \defeq & \lenv(\lvar) \\
        \evalLE{\lexpr_1 + \lexpr_2} & \defeq & \evalLE{\lexpr_1} + \evalLE{\lexpr_2} \\
        \evalLE{\lexpr_1 * \lexpr_2} & \defeq & \evalLE{\lexpr_1} * \evalLE{\lexpr_2} \\
        \dots & \defeq & \dots \\
    \end{rclarray}
\]
Note that the stack \( \stk \) includes transaction variables and thread variables.
\end{definition}

\emph{Fingerprint assertion} or \emph{fingerprint} is a set of tuples in the form of \( (\etag, \lexpr_{1}, \lexpr_{2}) \) where \( \etag \) is either read tag \( \etR \) or write \( \etW \) and the second and third elements are logical assertions representing the address and value respectively.
This assertion is interpreted to a set of events as expected.

\begin{defn}[Fingerprint Assertions]
\label{def:fingerprint}
The \emph{fingerprint assertion} also \emph{fingerprint}, \( \fp \in \FAst \), is defined as the follows, 
\[
\begin{rclarray}
    \fp & \subseteq & \Setcon{ (\etag,\lexpr_{1},\lexpr_{2}) }{ \etag \in \ETags \land \lexpr_{1}, \lexpr_{2} \in \LExpr } \\
\end{rclarray}
\] 
Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stacks$, the \emph{fingerprint interpretation} function, $\evalF[(., .)]{.}: \FAst \times \LEnv \times \Stacks \parfun \powerset{\Events}$, is defined as follows,
\[
\begin{rclarray}
    \evalF{\fp} & \defeq & \Setcon{ (\etag, \evalLE{\lexpr_{1}}, \evalLE{\lexpr_{2}}) }{ (\etag, \lexpr_{1}, \lexpr_{2}) \in \fp }  \\
\end{rclarray}
\]
\end{defn}

The local assertions includes normal separation logic assertions and extra fingerprint assertion (\defref{def:fingerprint}).
The interpretation are either classic interpretation for normal standard separation logic or to a set of events.
Notice that even though the fingerprint assertion is a set of syntactic events but it cannot be split.

\begin{definition}[Local assertions]
\label{def:local_assertions}
Given the set of logical expressions \( \LExpr \), logical variables \( \LVar \) and fingerprint assertion \( \FAst \), the set of \emph{local assertions}, $\lpre,  \lpost \in \LAst$, is defined inductively by the following grammar, 
\[
\begin{rclarray}
	\lpre, \lpost  & ::= & \False \mid \True \mid \lpre \land \lpost \mid \lpre \lor \lpost \mid \exsts{\lvar} \lpre \mid \Emp \mid \lexpr \pt \lexpr \mid \fp \mid \lpre \sep \lpost  \\
\end{rclarray}	 
\]
Given a logical environment $\lenv \in \LEnv$, the \emph{local interpretation function}, $\evalLS[(.,.)]{.}: \LAst \times \LEnv \parfun \Heaps \times \powerset{ \Events } $, is defined over the structure of local assertions as follows,
\[
\begin{rclarray}
	\evalLS{\assfalse} & \eqdef & \emptyset \\
	\evalLS{\asstrue} & \defeq & \Heaps \times \powerset{ \Events } \\
	\evalLS{\lpre \land \lpost} & \defeq & \evalLS{\lpre} \cap \evalLS{\lpost} \\
	\evalLS{\lpre \lor \lpost} & \defeq & \evalLS{\lpre} \cup \evalLS{\lpost} \\
	\evalLS{\exsts{\lvar} \lpre} & \defeq & \bigcup\limits_{\val \in \textnormal{\Val}}\evalLS[\lenv\remapsto{\lvar}{\val}, \stk]{\lpre}  \\
	\evalLS{\assemp} & \defeq & \Set{ ( \unitH, \emptyset) }  \\
	\evalLS{\lexpr_{1} \pt \lexpr_2 } & \defeq & \Set{ (\evalLE{\lexpr_1} \pt \evalLE{\lexpr_2}, \emptyset) } \\
	\evalLS{ \fp } & \defeq & \Set{ (\unitH, \evalF{\fp}) } \\
	\evalLS{\lpre \sep \lpost} & \defeq & 
    \Setcon{
        (\h_1 \composeH \h_2, \evset_{1} \uplus \evset_{2})
    }{ 
        (\h_{1},\evset_{1}) \in \evalLS{\lpre} 
        \land (\h_{2}, \evset_{2} ) \in \evalLS{\lpost} 
        \land (\evset_{1} = \emptyset \lor \evset_{2} = \emptyset) 
    } 
\end{rclarray}
\]
\end{definition}

Observe that program expressions $\Expr$  (\defin\ref{def:language}) are contained in logical expressions $\LExpr$ (\defin\ref{def:local_assertions} above). That is, $\Expr \subset \LExpr$. 

\subsection{Global/Program}

\sx{This is probably the simplified form  for a counter example (not necessary to be stable at the assertion level) in SI
\[
\begin{array}{@{}l@{}}
    \boxass{\vx \pt 1}{\lrid}{\intass} \\
    \intass: \perm{INC} : \Set{(\etR, \vx, k), (\etW, \vx, k + 1)} \mat \vx \pt n \oassto \vx \pt n \\
    \intass: \perm{READ} : \Set{(\etR, \vx, k)} \mat  \vx \pt n \oassto \vx \pt m \land m \leq n \\
\end{array}
\]
The first line of interference says one can increase the counter from \( k \) to \( k + 1 \) given by the fingerprint way to specify the action.
It also say if one want to increase the counter, it will have local state the same as the global state, specified by the thing after, which currently I call it observation assertion which will be interpreted into a function that maps a heap to a set of heap.
For example In the box assertion we show here, it will have \( \vx \pt 1\) as the initial local state if one increases the counter.
The second line says one can always read the value of \( \vx \) which will be an arbitrary \( k \).
If one only want to read, the initial local state will be any value \( m \) smaller than the global value \( n \).
For example In the box assertion we show here, it will have \( \vx \pt 0 \lor \vx \pt 1 \) as the initial local state if one only wants to read the counter.

Each box assertion together with the interference must make sense with respect to the consistency model.
}

\begin{definition}[Capabilities]
\label{def:capabilities}
Assume a \emph{partial commutative monoid (PCM)} of \emph{client-specified capabilities} \( (\Kaps, \composeK, \unitK) \) with \( \kap \in \Kaps \), the composition \( \composeK \) the units set \( \unitK \).
Then given a set of \emph{region identifiers} \( \rid \in \RegionID \), the \emph{capability composition function} or \emph{capabilities} \( \ca \in \Caps \defeq \RegionID \parfun \Kaps \), where the composition \( \composeC \) is defined as the follows,
\[
    \begin{rclarray}
        (\ca_{l} \composeC \ca_{r})(\rid) & \defeq  &
        \begin{cases}
            \ca_{l}(\rid) \composeK \ca_{r}(\rid) & \rid \in \dom(\ca_{l}) \cap \dom(\ca_{l}) \\
            \ca_{l}(\rid)  & \rid \in \dom(\ca_{l}) \setminus \dom(\ca_{l}) \\
            \ca_{r}(\rid) & \rid \in \dom(\ca_{r}) \setminus \dom(\ca_{l}) \\
            \text{undefined} & \text{otherwise} \\
        \end{cases}
    \end{rclarray}
\]
, and the units set \( \unitC \defeq \Setcon{\ca}{\for{\rid} \ca(\rid) \in \unitK } \) .
\end{definition}


\begin{defn}[Observation]
\label{def:observation}

Given the local assertion \(\lpre, \lpost \in \LAst \) (\defref{def:local_assertions}), the set of \emph{observation assertions}, \( \oass \in \OAst \), is defined by the following grammar, 
\[
\begin{rclarray}
    \oass & ::= & \emptyset \mid \Set{ \lpre \oassto \lpost} \cup \oass
\end{rclarray}
\]
The observation assertion will be interpreted to \emph{observation} that is a function from heaps that represent the global states, to sets of heaps that represent the observable states,
\[
\begin{rclarray}
    \observation \in \Observations & \eqdef & \Heaps \to \powerset{\Heaps} \\
\end{rclarray}
\]
Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stacks$, the \emph{observation interpretation} function, $\evalO[(., .)]{.}: \OAst \times \LEnv \times \Stacks \to \Observations$, is defined as follows.
\[
\begin{rclarray}
\evalO{\emptyset}(\h) & \defeq & \emptyset \\
\evalO{\Set{ \lpre \oassto \lpost} \cup \oass}(\h) & \defeq &
\begin{cases}
\evalO{\oass}(\h)  \cup \evalLS{\lpost} & \text{if } (\h, \emptyset) \in \evalLS{\lpre}\\
\evalO{\oass}(\h) & \text{otherwise}\\
\end{cases} \\
\end{rclarray}
\]
\end{defn}


\subsubsection{One action model}
\begin{defn}[Actions]
Given the set of transaction events \( \Events \) (\defref{def:transaction-event}), the set of \emph{actions} is defined as the follows,
\[
    \begin{rclarray}
        \action \in \Actions & \eqdef & \powerset{\Events}
    \end{rclarray}
\]
\end{defn}

\begin{defn}[Interference]
\label{def:intf}
Given the fingerprint assertion \( \fp \in \Fingerprint \) (\defref{def:fingerprint}) and observation assertion \( \oass \in \OAst \) (\defref{def:observation}), the grammar of \emph{interference assertions}, \( \intass \in \IAst \), is defined as the follows,
\[
\begin{rclarray}
	\intass & ::=  &
	\emptyset \mid \Set{ \perm{\kap} :  \exsts{\vec{\lvar}} \fp \mat \oass } \cup \intass 
\end{rclarray}
\]
It will be interpreted to a set of \emph{interference environments}, this is,
\[
\begin{rclarray}
    \inter \in \Interference & \defeq & \Kaps \parfun  ( \powerset{\Actions} \parfun \Observations )
\end{rclarray}
\]
Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stacks$, the \emph{interference interpretation} function, $\evalI[(., .)]{.}: \IAst \times \LEnv \times \Stacks \to \Interference$, is defined as follows,
%
\[
\begin{rclarray}
	\evalI{\emptyset}(\kap) & \eqdef & \text{undefined} \\
	\evalI{\Set{ \perm{\kap} : \exsts{\vec{\lvar}} \fp \mat \oass } \cup \intass }(\kap) & \eqdef &
    \Setcon{ \evalF[\lenv',\stk]{\fp} \mapsto \evalO[\lenv',\stk]{\oass} }{\exsts{ \vec{v} } \lenv' = \lenv\remapsto{\vec{\lvar}}{\vec v} }
	\uplus
	\evalI{\intass}(\kap) \\
\end{rclarray}
\] 
\end{defn}

{ \color{gray}
    \subsubsection{Another action model}
    \begin{definition}[Actions]
    \label{def:action}
    Given the set of heaps \( \Heaps \) (\defref{def:heaps}) and transaction events \( \Events \) (\defref{def:transaction-event}), the set of \emph{actions} is defined as the follows,
    %
    \[
        \begin{rclarray}
    	\action \in \Actions & \eqdef &
    	\Setcon{
    		((\h_{\lpre},\emptyset), (h_{\lpost},\evset))
    	}{
    		\h_{\lpre}, \h_{\lpost} \in \Heaps 
            \land \orth{\h_{\lpre}} = \orth{\h_{\lpost}}
            \land \evset \subseteq \Events \\
            \quad {} \land \for{\addr,\val}  
            (\etR, \addr, \val) \in \evset \implies \h_{\lpre}(\addr)  = \val \\
            \qquad {} \land (\etW, \addr, \val) \in \evset \implies \h_{\lpost}(\addr)  = \val
    	}
        \end{rclarray}
    \] 
    where, the \emph{orthogonal} \(\orth{(.)} \) is defined as follows, for all domains \( \sort M \), all \( m \in \sort{M} \) and its composition function \( \compose{} \),
    \[
        \begin{rclarray}
        \orth{m} & \eqdef & \Setcon{m}{m \compose{} m \isdef} \\
        \end{rclarray}
    \]
    \end{definition}
    
    \begin{defn}[Interference]
    \label{def:intf}
    Given the local assertion \( \lpre, \lpost \in \LAst \) and observation assertion \( \oass \in \OAst \) (\defref{def:observation}), the grammar of \emph{interference assertions}, \( \intass \in \IAst \), is defined as the follows,
    \[
    \begin{rclarray}
    	\intass & ::=  &
    	\emptyset \mid \Set{ \perm{\kap} :  \exsts{\vec{\lvar}} \oass \mat \lpre \transfersto \lpost } \cup \intass 
    \end{rclarray}
    \]
    The set of \emph{interference environments} is $\inter \in \Interference \defeq \Kaps \parfun  ( \Observations \to \powerset{\Actions} )$.
    Then given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stacks$, the \emph{interference interpretation} function, $\evalI[(., .)]{.}: \IAst \times \LEnv \times \Stacks \to \Interference$, is defined as follows,
    %
    \[
    \begin{rclarray}
    	\evalI{\emptyset}(\kap)(\obs) & \eqdef & \emptyset \\
    	\evalI{\Set{ \perm{\kap} : \exsts{\vec{\lvar}} \oass \mat \lpre \transfersto \lpost } \cup \intass }(\kap)(\obs) & \eqdef &
        \begin{cases}
        \{ \setaction \mid \dagger  \}
    	\cup 
    	\evalI{\intass}(\kap)(\obs) & \text{if } \exsts{ \vec{v}, \lenv'} \lenv' = \lenv \remapsto{\vec{\lvar}}{\vec v} \land \evalO[\lenv',\stk]{\oass} = \obs \\
    	\evalI{\intass}(\kap)(\obs) & \text{otherwise} \\
        \end{cases}
        \\
        \dagger & \equiv & 
        \begin{array}[t]{l}
            \for{ \action \in \setaction }
            \action \in \Actions 
    		\land \action\projection{1} \in \evalLS[\lenv', \stk]{\lpre} 
            \land \action\projection{2} \in \evalLS[\lenv', \stk]{\lpost}  \\
        \end{array}
    \end{rclarray}
    \] 
    \end{defn}
}
 
\begin{defn}[Invariant and well-form of a region]
Assume two functions, \( \funcn{init} : \RegionID \to \powerset{\Aexecs} \) that returns possible initial abstract executions for regions, and \( \funcn{como} : \RegionID \to \ConsisModels \) that returns the consistency models associated with regions.
The invariant of a region, namely \( \func{inv}{\rid, \intf} \), is a set of abstract executions that is closed under the interference \( \intf \),
\[
\begin{rclarray}
    \func{inv}{\rid, \intf} & \defeq & \bigcup\limits_{\nat \in \Nat}\func{iter}{\rid, \intf, \nat} 
\end{rclarray}
\]
Then the well-form condition of the interference of a region, namely \( \wfW{\rid, \intf}\) predicate, is defined with respect to the invariant.
\[
\begin{rclarray}
    \wfW{\rid, \intf} & \defeq & \for{\aexec \in \func{inv}{\rid, \intf}} \pred{wfgf}{\rid, \intf, \aexec} 
\end{rclarray}
\]
All the auxiliary functions and predicates are defined as the follows,
\[
\begin{rclarray}
    \func{iter}{\rid, \intf, 0} & \defeq & \func{init}{\rid}  \\
    \pred{wfgf}{\rid, \intf, \aexec} & \defeq & \aexec \in \func{init}{\rid}  \\
    \func{iter}{\rid, \intf, \nat + 1} & \defeq & 
    \Setcon{ 
        \aexec 
    }{ 
        \for{ \txid, \kap, \obs, \aexec' \in \func{iter}{\rid,\intf, \nat}, \evset \in ( \dom(\intf( \kap )) \uplus \Set{\emptyset} ) }  \\
        \quad \pred{reachable}{\aexec', \aexec, \txid, \evset, \func{como}{\rid}}
    }  \\
    \pred{wfgf}{\rid, \intf, \aexec} & \defeq & 
    \begin{array}[t]{@{}l}
        \exsts{ \nat, \txid, \kap, \obs, \aexec' \in \func{iter}{\rid, \intf, \nat}, \evset \in ( \dom(\intf( \kap )) \uplus \Set{\emptyset} ) } \\
        \quad \pred{reachable}{\aexec', \aexec, \txid, \evset, \func{como}{\rid}} 
        \land \for{\h, \h'}  \\
        \qquad \h \in \obsstate{\aexec', \aexec'\prjT,\func{como}{\rid}\projection{2}}  \\
        \qquad {} \land \h' \in \obsstate{\aexec, \aexec\prjV^{-1}(\txid),\func{como}{\rid}\projection{2}}  \\
        \qqquad {} \implies \h' \in \intf(\kap)(\aexec\prjT(\txid))(\h)
    \end{array} \\
    \pred{reachable}{\aexec, \aexec', \txid, \evset, \como} & \defeq & 
    \begin{array}[t]{@{}l}
        \exsts{\vis, \po, \ar } \\
        \quad {} \land \aexec' = (\aexec\prjT \uplus \Set{ \txid \mapsto \evset }, \aexec\prjP \uplus \po, \aexec\prjV \uplus \vis, \aexec\prjA \uplus \ar) \\
        \quad {} \land \vis, \po \subseteq \ar = \Setcon{(\txid', \txid)}{\txid' \in \dom(\aexec\prjT)} 
        \land \aexec' \in \evalCOM{\como}
    \end{array}
\end{rclarray}
\]
\end{defn}

The \( \predn{reachable} \) predicate allows the new abstract execution \( \aexec' \) to be appended with a transaction \( \txid \) associated with a empty event set, \ie \( \evset = \emptyset \).
The reason for that is, since a region is a representation of part of the entire machine state, we have to take into account the rest of the state, meaning the frame.

\begin{defn}[State-to-execution]
\label{def:world2aexec}
\label{def:state2aexec}
Given a region (identifier) \(\rid\), its current state \( \h \), and its interference \( \intf \), the function \(\funcn{s2e} \) returns all the possible abstract executions,
\[
\begin{rclarray}
    \func{s2e}{\rid, \h, \intf} & \eqdef & \func{inv}{\rid, \intf} \cap \func{h2e}{\h,\func{como}{\rid}} \\
\end{rclarray}
\]
where the \( \funcn{h2e} \) returns all the possible abstract executions where the final state satisfies the heap \( \h \), 
\[
\begin{rclarray}
    \func{h2e}{\h, (\conguar, \respo)} & \defeq & \Setcon{\aexec}{\h \in \obsstate{\aexec,\aexec\prjT,\respo}}
\end{rclarray}
\]
\end{defn}

\begin{definition}[Worlds]
\label{def:world}
Given the set of heaps $\Heaps$ (\defref{def:heaps}) and a set of \emph{region identifiers} \( \rid \in \RegionID \), the set of \emph{shared states} is \( \SStates \eqdef \RegionID \to \Heaps \times \Interference \) and the \emph{shared state composition function}, $\composeS: \SStates \times \SStates \parfun \SStates$, is defined as $\composeS \eqdef \composeEq$, where for all domains $\sort M$ and all $m, m' \in \sort M$,
%
\[
\begin{rclarray}
	m \composeEq m' &  \eqdef  &
	\begin{cases}
		m & \text{if } m = m'\\
		\text{undefined} & \text{otherwise}
	\end{cases}
\end{rclarray}
\]
Combining the above with capabilities (\defref{def:capabilities}), the set of \emph{worlds} is defined as follows,
\[
\begin{rclarray}
	\world \in \World  & \eqdef & 
    \Setcon{
        (\ca, \gs) 
    }{ 
        \ca \in \Caps 
        \land \gs \in \SStates
        \land \for{\rid, \rid'}  \\
        \quad ( \gs(\rid)\projection{1} \composeH \gs(\rid')\projection{1} )\isdef
        \land \func{como}{\rid} = \func{como}{\rid'}
        \land \clpsW{(\ca, \gs)}\isdef
        \land \dom(\ca) \subseteq \dom(\gs)
    }
\end{rclarray}
\]
The collapse function for a pair of capability and shared state \( \clpsW{.} : \Caps \times \SStates \parfun \powerset{\Aexecs} \) is defined as the follows,
\[
\begin{rclarray}
    \clpsW{( \ca, \emptyset )} & \defeq & \Setcon{\aexec }{ \for{ \txid } \aexec\prjT(\txid) = \emptyset }\\
    \clpsW{(\ca, \Set{\rid \mapsto (\h, \intf)} \uplus \gs)} & \defeq & 
        \Setcon{ \aexec \composeAEX \aexec' }{ \aexec \in \func{s2e}{\rid, \h, \intf} \land \pred{wf}{\rid, \intf} \land \aexec' \in \clpsW{(\ca, \gs)} }\\
\end{rclarray}
\] 
% 
The \emph{world composition function}, $\composeW: \World \times \World \parfun \World$, is defined component-wise as: $\composeW \eqdef (\composeC, \composeS)$.
The \emph{world unit set} is $\unitW \eqdef \Setcon{(\ca, \gs)}{(\ca, \gs) \in \World \land \ca \in \unitC}$.
The \emph{partial commutative monoid of worlds} is $(\World, \composeW, \unitW)$.
\end{definition}
 
\sx{Take a short cut of the grammar but the interpretation disallows fingerprint inside the box}
\begin{definition}[Assertions]
\label{def:assertion}
Given the local assertion \( \lpre \in \LAst \) (\defref{def:local_assertions}), The set of \emph{assertions}, $\gpre, \gpost \in \Ast$, are defined by the following inductive grammar:
\[
\begin{rclarray}
	\gpre , \gpost & \defeq & \False \mid \True \mid \gpre \land \gpost \mid \gpre \lor \gpost \mid \exsts{\lvar}\gpre \mid \assemp \mid \cass{\kap}{\lrid} \mid \gpre \sep \gpost \mid \boxass{\lpre}{\lrid}{\intass}\\
\end{rclarray}
\]
%
where $\lvar, \lrid \in \LVar$, $\lexpr_1, \lexpr_2 \in \LExpr$ (\defin\ref{def:local_assertions}), $\kap \in \Kaps$ (\defin\ref{def:capabilities}) and $\intass \in \IAst$ (\defin\ref{def:intf}).
Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stacks$, the \emph{assertion interpretation} function, $\evalW[(., .)]{.}: \Ast \times \LEnv \times \Stacks \rightarrow \World$, is defined as follows:
%
\[
\begin{rclarray}
	\evalW{\False} & \defeq & \emptyset \\
	\evalW{\True} & \defeq & \World \\
	\evalW{\emp} & \defeq & \unitW \\
	\evalW{\gpre \land \gpost} & \defeq & \evalW{\gpre} \cap \evalW{\gpost} \\
	\evalW{\gpre \lor \gpost} & \defeq & \evalW{\gpre} \cup \evalW{\gpost} \\
	\evalW{\exsts{\lvar}  \gpre} & \defeq 
	& \bigcup\limits_{\val \in \textnormal{\Val}} \evalW[\lenv\remapsto{\lvar}{\val}, \stk]{\gpre} \\
	\evalW{\cass{\kap}{\lrid}} & \defeq & \Set{ (\Set{\lrid \mapsto \kap}, \unitH) } \\
	\evalW{ \gpre \sep \gpost } & \defeq & 
	\Setcon{
	   (\world_1 \composeW \world_2) 
    }{
       \world_1 \in \evalW{\gpre} \land \world_2 \in \evalW{\gpost}
	} \\
	\evalW{ \boxass{\lpre}{\lrid}{\intass} } & \defeq & 
    \Setcon{
        (\ca,\gs)
    }{
        \ca \in \unitC 
        \land (\gs(\lrid)\projection{1}, \emptyset) \in \evalLS{\lpre}
        \land \gs(\lrid)\projection{2}  = \evalI{\intass}
    } \\
\end{rclarray}
\]
\end{definition}

