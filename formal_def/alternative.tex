\section{Alternative Semantics\label{sec:alter}}
\subsection{Weaken Atomic}

We reuse some notations in Sect. \ref{sec:semantics}, but redefined the meaning.
The \( \TSHeaps \) now is a partial function from locations to a tuple of \( \Timestamp \) and \( \Val \).
The thread state now is only a local stack and a global stack, and correspondingly, the join label is only parametrised by thread identifier.

\[
    \begin{rclarray}
        \tshp \in \TSHeaps & \defeq & \Loc \parfinfun ( \Timestamp \times  \Val ) \\
        \lb \in \Translabel & \defeq & 
              \lbID \quad               |
        \quad \lbS{\tsid} \quad         |
 t      \quad \lbC{\tsid} \quad        |
        \quad \lbF{\thid,\prog} \quad |
        \quad \lbJ{\thid} \\
    \end{rclarray}
\]

The notation \( \ptrans{\trans}_{\tsid, \tshp} \) indicates that the transaction identifier by \( \tsid \) has been started with the snapshot of heap \( \tshp \), but does not commit so far.

\[
    \begin{rclarray}
        \iprog & ::= &  \prog \mid \mid \ptrans{\trans}_{\tsid, \tshp} \pseq \iprog \mid \iprog \pseq \pwait{\thid} 
    \end{rclarray}
\]

The main difference of this semantics is, except removing all the local time, that the one-step \rl{Commit} is split into few steps.
Here we assume there is a global functions \(\funcn{freshTransId} \) that return a new transaction identifier each time.

\[
    \infer[\rl{TakeSnapshot}]{%
        ( \stk, \tshp ) , \ptrans{\trans} \ \toT{\lbS{\tsid}} \ ( \stk, \tshp ) , \ptrans{\trans}_{\tsid, \tshp}
    }{%
        \begin{array}{c}
            \quad \tsid = \func{freshTransId}{}
        \end{array}
    }
\]

We also redefine some functions and predicates used before.

\[
    \begin{rclarray}
        \func{startstate}{\tshp} & \defeq & \lambda \loc \ldotp (\val, \emptyset) \ \texttt{where} \ \tshp(\loc) = (\stub, \val)\\
        \pred{allowcommit}{\tshp,\tshp', \fph} & \defeq & \forall \loc \ldotp \fpW \in \fphFP[\fph](\loc) \land \tshp(\loc) = \tshp'(\loc)\\
        \func{commitTrans}{\tshp,\fph_{e}} & \defeq &
        \lambda \loc \ldotp
        \begin{cases}
            ( \tshp(\loc)\projection{1}+1, \fphVAL[\fph_{e}](\loc)) & \fpW \in \fphFP[\fph_{e}](\loc)  \\
            \tshp(\loc) & \text{otherwise}
        \end{cases} \\
    \end{rclarray}
\]

\[
    \infer[\rl{Commit}]{%
        ( \stk, \tshp ) , \ptrans{\trans}_{\tsid, \tshp'} \ \toT{\lbC{\tsid}} \ ( \stk', \tshp'' ) , \pskip
    }{%
        \begin{array}{c}
            \quad \fph_{s} = \func{startstate}{\tshp'}
            \quad ( \stk, \fph_{s}) , \trans \toL^{*} ( \stk', \fph_{e}) , \pskip \\
            \pred{allowcommit}{\tshp,\tshp', \fph}
            \quad \tshp'' = \func{commitTrans}{\tshp,\fph_{e}}
        \end{array}
    }
\]
