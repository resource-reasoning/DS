\section{Alternative Semantics\label{sec:alter}}

where,
\[
    \begin{rclarray}
        \rely_0 & \eqdef & \func{transitive\_close}{\relyU} \\
        \rely_{n+1} & \eqdef & \func{transitive\_close}{ \pred{merge\_close}{\rely_{n}} } \\
        \func{merge\_close}{\rely} & \eqdef 
        & \Setcon{%
            (\fpw, \mergeFW{\fpw_{l}}{\fpw_{r}})
        }{%
            (\fpw, \fpw_{l}), (\fpw, \fpw_{r}) \in \rely 
        } \cup \rely \\
        \func{transitive_close\_close}{\rely} & \eqdef 
        & \Setcon{%
            (\fpw_{p}, \fpw_{q})
        }{%
            \exsts{ \fpw_{m}, \fpw_{m}', \fpw_{q}' } 
            (\fpw_{p}, \fpw_{m}), (\fpw_{m}', \fpw_{q}') \in \rely  \\
            \quad {} \land \eraseFW{\fpw_{m}} =  \eraseFW{\fpw_{m}'} 
        } \cup \rely
    \end{rclarray}
\]
\sx{The fingerprint of \( \fpw_{m} \) does NOT propagate to \( \fpw_{m}'\) hope to fix unsoundness
\[
\begin{array}{l}
1: (0,0,0) \leadsto (1,0,0) \\
2: (1,0,0) \leadsto (1,1,0) \\
3: (0,0,0) \leadsto (0,0,1) \\
4: (0,0,0) \leadsto (2,0,2) \\
\end{array}
\]
It is possible to have \( (0,0,0)  \leadsto (2,1,2) \), 
\[
\begin{array}{l}
1: |---| \\
2: \qqqquad |---| \\
3: \qquad |---| \\
4: \qqquad \qqqquad |---| \\
\end{array}
\]
While if the transitive closure propagate the fingerprint, there is no way to get that.
}

\subsection{Merge}

\begin{defn}[Fingerprint heaps merge]
\label{def:merge-finger-heap}
The \emph{merge of fingerprint heaps}, \( \mergeFPH{.}{.} \), is defined as follows:
\[
    \begin{rclarray}
        \mergeFPH{\fph_{l}}{\fph_{r}}  & \defeq & \lambda \addr \ldotp 
            \begin{cases}
                \fph_{l}(\addr) & a \in \dom(\fph_{l}) \setminus \dom(\fph_{r})  \\
                \fph_{r}(\addr) & a \in \dom(\fph_{r}) \setminus \dom(\fph_{l}) \\
                \mergeVAL{\fph_{l}(\addr)}{\fph_{r}(\addr)}  & a \in \dom(\fph_{l}) \cap \dom(\fph_{r}) \\
            \end{cases}
    \end{rclarray}
\]
where the \emph{merge of fingerprint heap values} is defined:
\[ \begin{rclarray}
        \mergeVAL{(\val_{l}, \fp_{l})}{(\val_{r}, \fp_{r})} & \defeq &
            \begin{cases}
                (\val_{l}, \fp_{l} \cup \fp_{r} ) & \val_{l} = \val_{r} \land \fpW \notin \fp_{l} \cup \fp_{r} \\
                (\val_{l}, \fp_{l} \cup \fp_{r} ) & \fpW \in \fp_{l} \land \fpW \notin \fp_{r} \\
                (\val_{r}, \fp_{l} \cup \fp_{r} ) & \fpW \notin \fp_{l} \land \fpW \in \fp_{r} \\
            \end{cases}
    \end{rclarray}
\]
\end{defn}

\begin{definition}[Fingerprint worlds]
\label{def:fingerprint_worlds}
Given the set of fingerprint heap $\FPHeaps$ (\defref{def:fingerprint_heaps}) and the set of region identifiers $\RegionID$ (\defin\ref{def:capabilities}), the set of \emph{fingerprint worlds}, $\fpw \in \FPWorlds$, is defined as follows:
\[
\begin{rclarray}
	(\ca, \fph) \in \FPWorlds  & \eqdef & \Caps \times \FPHeaps
\end{rclarray}
\]
with the composition function \( \composeFPW \eqdef (\composeC, \composeEq) \) and unit \( \unitFPW  \defeq \Setcon{(\ca, \emptyset)}{\ca \in \unitC }\).
The \emph{erase function}, $\eraseFW{.}: \FPWorlds \rightarrow \World$, is defined as follows:
\[
\begin{rclarray}
	\eraseFW{(\ca, \fph)} & \eqdef & (\ca, \eraseFPH{\fph})
\end{rclarray}
\]
where,
\[
\begin{rclarray}
	\eraseFPH{\fph} & \defeq & \lambda \addr \ldotp \fphVAL(\addr)
\end{rclarray}
\]
The \( \predn{no\_fingerprint} \) is defined as the follows:
\[
\begin{rclarray}
    \pred{no\_fingerprint}{ \ca, \fph } & \defeq & \for{ \addr } \fphFP(\addr) = \emptyset
\end{rclarray}
\]
\end{definition}

\begin{definition}[Fingerprint worlds merge]
Given the set of fingerprint worlds $\FPWorlds$ (\defin\ref{def:fingerprint_worlds}), the \emph{merge} function, $\mergeName[\fpw]: \FPWorlds \times \FPWorlds \parfun \FPWorlds$, is defined as follows, for all $\fpw_{l},\fpw_{r} \in \FPWorlds$:
\[
    \begin{rclarray}
	\mergeFW{(\ca, \fph_{l})}{(\stub, \fph_{r})} & \eqdef & (\ca, \mergeFPH{\fph_{l}}{\fph_{r}}) 
    \end{rclarray}
\]
\end{definition}

Note that the \( \mergeName[\fpw] \) is not commutative, i.e.\ swapping \( \fpw_{l}\) and \( \fpw_{r}\) might yield different result.

\subsection{Timestamp}

We model the global database state as a \emph{timestamp heap}. A timestamp heap is a partial function from addresses to \emph{histories}.
A history is a partial function from timestamps to a set of \emph{events}.
An event is a triple comprising the value read or written, the identifier of the transaction carrying out the event, and an \emph{event tag} denoting a \emph{start event} ($\etS$), an \emph{end} event ($\etE$), a \emph{read} event ($\etR$) or a \emph{write} event ($\etW$).
We model our timestamps, $\ts \in \Timestamp$, as elements of an (uncountably) infinite set with a total order relation $<$. To ensure the availability of an appropriate timestamp, we assume that the timestamp set $\Timestamp$ is \emph{dense}. That is, given any two timestamps $\ts_1$ and $\ts_2$ such that $\ts_1 < \ts_2$, an intermediate timestamp $\ts$ can be found such that $\ts_1 < \ts < \ts_2$.

\begin{defn}[Event tags]
\label{ref:event-tag}
The set of \emph{event tags} is $\etag \in \ETags \eqdef \{\etS, \etE, \etR, \etW \}$.
\end{defn}
%
\begin{defn}[Timestamps]
\label{def:timestamp}
The set of \emph{timestamps}, $\Timestamp$, is a infinitely countable set, and there is a \emph{total order} relation on it, $<\ : \Timestamp \times \Timestamp$, such that:
%
\[
	\for{\ts_1, \ts_2 \in \Timestamp} \ts_1 < \ts_2 \lor \ts_2 < \ts_1
\]
%
This timestamp set $\Timestamp$ is \emph{dense} with respect to the ordering relation $<$. 
That is,
\[
	\for{\ts_1, \ts_2} \ts_1 < \ts_2 
	\implies 
	\exsts{\ts} \ts_1 < \ts < \ts_2	
\]
\end{defn}
%
We write $\ts_1 \leq \ts_2$ as a shorthand for $\ts_1 < \ts_2 \lor \ts_1 = \ts_2$.
We write $\ts_1 \oplus \ts \odot \ts_2 $ for $\ts_1 \oplus \ts \land \ts \odot \ts_2 $, where $\oplus, \odot \in \{<, \leq\}$.
We often use the mirrored symbols and write $\ts_1 > \ts_2$ (resp.~$\ts_1 \geq \ts_2$) for $\ts_2 < \ts_1$ (resp.~$\ts_2 \leq \ts_1$).
Lastly, we use the standard interval notation and write:
%
\[
\begin{rclarray}
	(\ts_1, \ts_2) & \text{for} & \Set{\ts \mid \ts_1 < \ts < \ts_2 } \\
	(\ts_1, \ts_2] & \text{for} & \Set{\ts \mid \ts_1 < \ts \leq \ts_2 } \\
	{[\ts_1, \ts_2)} & \text{for} & \Set{\ts \mid \ts_1 \leq \ts < \ts_2 } \\	
	{[\ts_1, \ts_2]} & \text{for} & \Set{\ts \mid \ts_1 \leq \ts \leq \ts_2 } 
\end{rclarray}
\]
\begin{defn}[Timestamp heaps]
\label{def:timestamp_heaps}
Assume a countably infinite set of \emph{transaction identifiers} $\tsid, \beta \in \TransID$.
Given the set of event tags $\ETags$ (\defin\ref{ref:event-tag}), program values $\Val$ (\defin\ref{def:prgram_values}), program addresses $\Addr$ (\defin\ref{def:prgram_values}) and timestamps \(\Timestamp\) (\defin\ref{def:timestamp}), the set of \emph{timestamp heaps} is defined as $\tshp \in \TSHeaps \eqdef \Addr \parfinfun (\Val \times \TransID \times \ETags)$.
The \emph{timestamp heap composition function}, $\composeTSH: \TSHeaps \times \TSHeaps \parfun \TSHeaps$, is defined as follows, for all $\addr \in \Addr$, where $\uplus$ denotes the standard disjoint function union:
%
\[
	(\tshp_1 \composeTSH \tshp_2)(\addr) \defeq 
	\begin{cases}
		\tshp_1(\addr) \uplus \tshp_2(\addr) & \text{if } \addr \in \dom(\tshp_1) \text{ and } \addr \in \dom(\tshp_2) \\
		\tshp_1(\addr) & \text{if } \addr \in \dom(\tshp_1) \text{ and } \addr \not\in \dom(\tshp_2) \\
		\tshp_2(\addr) & \text{if } \addr \not\in \dom(\tshp_1) \text{ and } \addr \in \dom(\tshp_2) \\
		\text{undefined} & \text{otherwise}
	\end{cases}
\]
%
The \emph{timestamp heap unit element} is $\unitTSH \eqdef \emptyset$, denoting a function with an empty domain.
The \emph{partial commutative monoid of timestamp heaps} is $(\TSHeaps, \composeTSH, \{\unitTSH\})$. 
\end{defn}
 
Whilst the state of the database is given by globally-accessed (by all threads) timestamp heaps, we use \emph{fingerprint heaps} to model a \emph{local snapshot} of the global timestamp heaps made available to transactions during their execution. 
In order to successfully commit a transaction and avoid conflicts, we must track the \emph{fingerprint} of a transaction, namely those addresses read from or written to by the transaction.
As such, we model fingerprint heaps as finite partial maps from addresses to pairs comprising a value and a fingerprint.
The fingerprint of an address may be 1) $\emptyset$ denoting that the address has not been touched;
2) $\Set{\fpR}$ denoting that the address has been read;
3) $\Set{\fpW}$ denoting that the address has been mutated (written to);
and 4) $\Set{\fpR, \fpW}$ denoting that the address has been initially read and subsequently mutated.   
%

\begin{defn}[Thread semantics]
Assume a countably infinite set of thread identifiers $\thid,j \in \ThreadID$.
The set of \emph{intermediate programs}, $\iprog \in \IntermediatePrograms$, is defined by the following grammar:
%
\[
    \iprog ::= \prog \mid \iprog \pseq \pwait{\thid}
\]
%
Given the set of stacks $\Stacks$ (\defin\ref{def:stacks}), timestamp heaps $\TSHeaps$ and timestamps $\Timestamp$ (\defin\ref{def:timestamp}), the \emph{per-thread operational semantics} of programs:
%
\[
	\toT{} : 
	\left((\Stacks \times \TSHeaps \times \Timestamp) \times \IntermediatePrograms \right) 
	\times \Translabel \times  
	\left((\Stacks \times \TSHeaps \times \Timestamp) \times \IntermediatePrograms \right) 
\]
%
is defined in \fig\ref{fig:thread_semantics}.
\end{defn}


\begin{figure}
%
\hrule\vspace{5pt}
%
\[
    \infer[\rl{Commit}]{%
        ( \stk, \tshp, \ts_{s} ) , \ptrans{\trans} \ \toT{\lbC{\tsid}} \ ( \stk', \tshp', \ts_{e} ) , \pskip
    }{%
        \begin{array}{c}
            \ts_s < \ts_e 
            \qquad \fph_s = \snapshot{\tshp}{\ts_s}
            \qquad ( \stk, \fph_s) , \trans \toL^{*} ( \stk', \fph_e) , \pskip \\
            \cancommit{\tshp}{\fph_e}{\ts_s}{\ts_e} 
            \quad \pred{fresh}{\tshp, \tsid}
            \quad \tshp' = \commit{\tshp}{\fph_s}{\fph_e}{\tsid}{\ts_s}{\ts_e}
        \end{array}
    }
\]

\[
    \infer[\rl{PChoiseL}]{%
        ( \stk, \tshp, \ts ) , \prog_{1} \pchoice \prog_{2} \ \toT{\lbID} \  ( \stk, \tshp, \ts ) , \prog_{1}
    }{%
    }
\]

\[
    \infer[\rl{PChoiseR}]{%
        ( \stk, \tshp, \ts ) , \prog_{1} \pchoice \prog_{2} \ \toT{\lbID} \  ( \stk, \tshp, \ts ) , \prog_{2}
    }{%
    }
\]

\[
    \infer[\rl{PLoop}]{%
        ( \stk, \tshp, \ts ) , \prog\prepeat \ \toT{\lbID} \  ( \stk, \tshp, \ts ) , \pskip \pchoice (\prog \pseq \prog\prepeat)
    }{%
    }
\]

\[
    \infer[\rl{PSeqSkip}]{%
        ( \stk, \tshp, \ts ) , \pskip \pseq \iprog \ \toT{\lbID} \  ( \stk, \tshp, \ts ) , \iprog
    }{%
    }
\]

\[
    \infer[\rl{PSeq}]{%
        ( \stk, \tshp, \ts ) , \iprog_{1} \pseq \iprog_{2} \ \toT{\lb} \ ( \stk', \tshp', \ts' ) , {\iprog_{1}}' \pseq \iprog_{2}
    }{%
        ( \stk, \tshp, \ts ) , \iprog_{1} \ \toT{\lb} \  ( \stk', \tshp', \ts' ) , {\iprog_{1}}' 
    }
\]

\[
    \infer[\rl{PPar}]{%
        ( \stk, \tshp, \ts ) , \prog_{1} \ppar \prog_{2} \ \toT{\lbF{\thid, \prog_{2}}} \  ( \stk, \tshp, \ts ) , \prog_{1} \pseq \pwait{\thid}
    }{%
    }
\]

\[
    \infer[\rl{PWait}]{%
        ( \stk, \tshp, \ts ) , \pwait{\thid} \ \toT{\lbJ{\thid,\ts'}} \  ( \stk, \tshp , \max\Set{\ts,\ts'} ) , \pskip 
    }{%
    }
\]

\[
    \infer[\rl{PIncTime}]{%
        ( \stk, \tshp, \ts ) , \iprog \ \toT{\lbID} \  ( \stk, \tshp , \ts' ) , \iprog 
    }{%
       \ts' > \ts
    }
\]
 
where,
\[
\begin{rclarray}
	\snapshot{.}{.} & : & \TSHeaps \times \Timestamp \parfun \FPHeaps \\
%	
	\snapshot{\tshp}{\ts} & \defeq & 
	\lambda \addr \ldotp
	\begin{cases} 
		(\val, \emptyset) & 
		\exsts{\ts' \leq \ts} \tshp(\addr)(\ts') {=} (\val,\etW, \stub) \\
		& \quad {} \land \for{\ts'' \in ( \ts', \ts), \etag} \tshp(\addr)(\ts'') {=} (\stub,\etag,\stub) \implies \etag \in \Set{\etR, \etE}\\
        \text{undefined} & \text{otherwise}
	\end{cases} 
	\vspace{3pt}\\
	\commit{.}{.}{.}{.}{.}{.} & : & \TSHeaps \times \FPHeaps \times \FPHeaps \times \TransID \times \Timestamp \times \Timestamp \to \TSHeaps \\
%	
	\commit{\tshp}{\fph_s}{\fph_e}{\tsid}{\ts_s}{\ts_e} & \defeq &
	\lambda \addr \ldotp
	\begin{cases}
		\tshp(\addr)\remapsto{\ts_s}{(\fphVAL[\fph_s](\addr),\etS,\tsid)}\remapsto{\ts_e}{(\fphVAL[\fph_e](\addr),\etW,\tsid)} 
		& \text{if \;} \fphFP[\fph_e](\addr) {=} \{\fpW\} \\
		\tshp(\addr)\remapsto{\ts_s}{(\fphVAL[\fph_s](\addr),\etR,\tsid)}\remapsto{\ts_e}{(\fphVAL[\fph_e](\addr),\etE,\tsid)} 
		& \text{if \;} \fphFP[\fph_e](\addr) {=} \{\fpR\} \\
		\tshp(\addr)\remapsto{\ts_s}{(\fphVAL[\fph_s](\addr),\etR,\tsid)}\remapsto{\ts_e}{(\fphVAL[\fph_e](\addr),\etW,\tsid)} & \text{if \;} \fphFP[\fph_e](\addr) {=} \{\fpR, \fpW\} \\
		\tshp(\addr)\remapsto{\ts_s}{(\fphVAL[\fph_s](\addr),\etS,\tsid)}\remapsto{\ts_e}{(\fphVAL[\fph_e](\addr),\etE,\tsid)} & \text{otherwise}
	\end{cases} 
	\vspace{3pt}\\
%
%              
	\cancommit{\tshp}{\fph}{\ts_s}{\ts_e} 
	& \defeq & 
	\wfhist{\tshp}{\fph}{\ts_s}{\ts_e} \land \consistent{\tshp}{\fph}{\ts_s}{\ts_e} 
	\vspace{3pt}\\
%
%        
	\wfhist{\tshp}{\fph}{\ts_s}{\ts_e} 
	& \defeq  & 
 	\for{\addr} \for{\ts \in \Set{\ts_{s},\ts_{e}}} \fphFP(\addr) {\ne} \emptyset \implies \tshp(\addr)(\ts)\isundef 
	\vspace{3pt}\\
%
%        
	\consistent{\tshp}{\fph}{\ts_s}{\ts_e}
	& \defeq & 
	\for{\addr} \fpW \in \fphFP(\addr) \implies \\
	&& \quad \for{\ts \in (\ts_s,\ts_e)} \tshp(\addr)(\ts) {\ne} (\stub, \etW, \stub) \\
	&& \quad \land\ \neg\exsts{\tsid, \ts'_s, \ts'_e} \ts'_s < \ts_e \land
       \ts'_e > \ts_e \land \tshp(\addr)(\ts'_s) = (\stub, \stub, \tsid) \land 
       \tshp(\addr)(\ts'_e) = (\stub, \etW, \tsid) \\
	&& \quad \land\ \for{\ts_m} \ts_m {=} \min(\Setcon{\ts'' }{ \ts'' > \ts_{e} \land
       \tshp(\addr)(\ts'')\isdef}) \implies \tshp(\addr)(\ts_{min}) \neq (\stub, \etR, \stub) 
	\vspace{3pt}\\
%
%        
	\pred{fresh}{\tshp, \tsid}  & \defeq & \neg\exsts{\addr, \ts} \tshp(\addr)(\ts) {=} (\stub, \stub, \tsid)
    \end{rclarray}
\]
\hrule\vspace{5pt}
\caption{Per-thread operational semantics}
\end{figure}


In order to formulate the operational semantics of a program $\prog$, we extend the programming language with an auxiliary wait construct, \(\pwait{\thid} \), added to programs as a suffix to denote thread joining points.
Intuitively, the \( \pwait{\thid} \) construct indicates that the current thread is waiting on the thread identified by \( \thid \) to finish its execution and join the current thread. We refer to the programs produced by this extended syntax as \emph{intermediate programs}. This is because the $\pwait{.}$ construct yields additional programs that cannot be written by the clients of the database and is merely used to capture intermediate steps during parallel execution. 
%

We define the per-thread operational semantics of programs with respect to a triple of the form $(\stk, \tshp, \ts)$ comprising a (locally-accessed) stack, a (globally-accessed) timestamp heap, and a (locally-recorded) timestamp. 
Each step of the per-thread operational semantics is decorated with a \emph{label} recording the action taken by the thread. In particular, a label may be $\lbID$, denoting an identity transition; $\lbC{\tsid}$, denoting the committing of transaction $\tsid$; $\lbF{\thid, \prog}$, denoting the forking a new thread $\thid$ the execute program $\prog$; or $\lbJ{\thid, \ts}$, denoting the joining of thread $\thid$ with the local timestamp $\ts$.
  
The per-thread operational semantics of programs is given in \fig\ref{fig:thread_semantics}.
With the exception of the \rl{PCommit}, \rl{PPar} and \rl{PWait}, the remaining rules are straightforward.



\begin{defn}[Fingerprints]
\label{def:fingerprint}
The set of \emph{fingerprints} is $\fp \in \Fingerprint \eqdef \powerset{\Set{\fpR,\fpW}}$.
\end{defn}
 
\begin{defn}[Fingerprint heaps]
\label{def:fingerprint_heaps}
Given the sets of program values $\Val$ (\defin\ref{def:prgram_values}), addresses $\Addr$ (\defin\ref{def:timestamp_heaps}) and fingerprints $\Fingerprint$ (\defin\ref{def:fingerprint}), the set of \emph{fingerprint heaps} is: $\fph \in \FPHeaps \eqdef \Addr \parfinfun (\Val \times \Fingerprint)$.
The \emph{fingerprint heap composition function}, $\composeFPH: \FPHeaps \times \FPHeaps \parfun \FPHeaps$, is defined as $\composeFPH \eqdef \uplus$, where $\uplus$ denotes the standard disjoint function union. The \emph{fingerprint heap unit element} is $\unitFPH \eqdef \emptyset$, denoting a function with an empty domain.
The \emph{partial commutative monoid of fingerprint heaps} is $(\FPHeaps, \composeFPH, \{\unitFPH\})$.  
\end{defn}
 
Given a fingerprint heap $\fph$ and an address $\addr$, we write $\fphVAL(\addr)$ and $\fphFP(\addr)$ for the first and second projections of $\fph(\addr)$, respectively. We write $\unitFPH$ for a fingerprint heap with an empty domain. We write $\fph_1 \uplus \fph_2$ for the standard disjoint function union of $\fph_1$ and $\fph_2$. 
%\ac{Why not define $\fphVAL$ and $\fphFP$ directly as functions from addresses to fingerprints and values directly, respectively?}

We introduce two update functions on fingerprints, $\addFPR{\fp}$ and $\addFPW{\fp}$, for updating a fingerprint $\fp$. Intuitively, the $\addFPW{\fp}$ always \emph{extends} $\fp$ with the $\fpW$ fingerprint. On the other hand, the $\addFPR{\fp}$ extends $\fp$ with $\fpR$ \emph{only if} $\fp$ does not already contain the $\fpW$ fingerprint (i.e.~$\fpW \not\in \fp$). This is to capture the fact that once an address is written to and thus the fingerprint contains $\fpW$, the following reads from the same address are considered local and need not be recorded in the fingerprint.
 
\begin{defn}[Fingerprint extension]
\label{def:fingerprint-extension}
Given the set of fingerprints $\Fingerprint$ (\defin\ref{def:fingerprint}), the \emph{read fingerprint extension} function, $\addFPR{(.)}{.}: \Fingerprint \rightarrow \Fingerprint$, and the \emph{write fingerprint extension} function, $\addFPW{(.)}{.}: \Fingerprint \rightarrow \Fingerprint$, are defined as follows, for all $\fp \in \Fingerprint$:
\[
\begin{rclarray}
	\addFPW{\fp} & \eqdef & \fp \cup \{\fpW\} \\
	\addFPR{\fp} & \eqdef &
	\begin{cases}
		\fp \cup \{\fpR\}  & \text{if } \fpW \not\in \fp \\
		\fp & \text{otherwise}
	\end{cases}
\end{rclarray}	
\]
\end{defn}
%\ac{Can you express heap composition, read and write extension of fingerprints under a single operator?}

\begin{defn}[Read and write sets]
\label{def:rs-ws}
Given the set of fingerprints $\Fingerprint$ (\defin\ref{def:fingerprint}), the \emph{read set} and \emph{write set} function, $\rsName, \wsName: \FPHeaps \to \powerset{\Addr}$ is defined as follows:
\[
\begin{rclarray}
    \ws{\fph} & \defeq & \myset{\loc}{ \exsts{\fp} \fph(\loc) = (\stub, \fp) \land \fpW \in \fp} \\
    \rs{\fph} & \defeq & \myset{\loc}{ \exsts{\fp} \fph(\loc) = (\stub, \fp) \land \fpR \in \fp} \\
\end{rclarray}	
\]
\end{defn}


\subsection{Weaken Atomic}

We reuse some notations in Sect. \ref{sec:semantics}, but redefined the meaning.
The \( \TSHeaps \) now is a partial function from locations to a tuple of \( \Timestamp \) and \( \Val \).
The thread state now is only a local stack and a global stack, and correspondingly, the join label is only parametrised by thread identifier.

\[
    \begin{rclarray}
        \tshp \in \TSHeaps & \defeq & \Loc \parfinfun ( \Timestamp \times  \Val ) \\
        \lb \in \Translabel & \defeq & 
              \lbID \quad               |
        \quad \lbS{\tsid} \quad         |
 t      \quad \lbC{\tsid} \quad        |
        \quad \lbF{\thid,\prog} \quad |
        \quad \lbJ{\thid} \\
    \end{rclarray}
\]

The notation \( \ptrans{\trans}_{\tsid, \tshp} \) indicates that the transaction identifier by \( \tsid \) has been started with the snapshot of heap \( \tshp \), but does not commit so far.

\[
    \begin{rclarray}
        \iprog & ::= &  \prog \mid \mid \ptrans{\trans}_{\tsid, \tshp} \pseq \iprog \mid \iprog \pseq \pwait{\thid} 
    \end{rclarray}
\]

The main difference of this semantics is, except removing all the local time, that the one-step \rl{Commit} is split into few steps.
Here we assume there is a global functions \(\funcn{freshTransId} \) that return a new transaction identifier each time.

\[
    \infer[\rl{TakeSnapshot}]{%
        ( \stk, \tshp ) , \ptrans{\trans} \ \toT{\lbS{\tsid}} \ ( \stk, \tshp ) , \ptrans{\trans}_{\tsid, \tshp}
    }{%
        \begin{array}{c}
            \quad \tsid = \func{freshTransId}{}
        \end{array}
    }
\]

We also redefine some functions and predicates used before.

\[
    \begin{rclarray}
        \func{startstate}{\tshp} & \defeq & \lambda \loc \ldotp (\val, \emptyset) \ \texttt{where} \ \tshp(\loc) = (\stub, \val)\\
        \pred{allowcommit}{\tshp,\tshp', \fph} & \defeq & \forall \loc \ldotp \fpW \in \fphFP[\fph](\loc) \land \tshp(\loc) = \tshp'(\loc)\\
        \func{commitTrans}{\tshp,\fph_{e}} & \defeq &
        \lambda \loc \ldotp
        \begin{cases}
            ( \tshp(\loc)\projection{1}+1, \fphVAL[\fph_{e}](\loc)) & \fpW \in \fphFP[\fph_{e}](\loc)  \\
            \tshp(\loc) & \text{otherwise}
        \end{cases} \\
    \end{rclarray}
\]

\[
    \infer[\rl{Commit}]{%
        ( \stk, \tshp ) , \ptrans{\trans}_{\tsid, \tshp'} \ \toT{\lbC{\tsid}} \ ( \stk', \tshp'' ) , \pskip
    }{%
        \begin{array}{c}
            \quad \fph_{s} = \func{startstate}{\tshp'}
            \quad ( \stk, \fph_{s}) , \trans \toL^{*} ( \stk', \fph_{e}) , \pskip \\
            \pred{allowcommit}{\tshp,\tshp', \fph}
            \quad \tshp'' = \func{commitTrans}{\tshp,\fph_{e}}
        \end{array}
    }
\]
