\section{Alternative Semantics\label{sec:alter}}
\subsection{Weaken Atomic}

We reuse some notations in Sect. \ref{sec:semantics}, but redefined the meaning.
The \( \Timestampheap \) now is a partial function from locations to a tuple of \( \Timestamp \) and \( \Val \).
The thread state now is only a local stack and a global stack, and correspondingly, the join label is only parametrised by thread identifier.

\[
    \begin{rclarray}
        \tshp \in \Timestampheap & \defeq & \Loc \parfinfun ( \Timestamp \times  \Val ) \\
        (\stk, \tshp) \in \Threadstate & \defeq & \Stack \times \Timestampheap \\
        \tll \in \Translabel & \defeq & 
              \lid \quad                |
        \quad \lst{\tsid} \quad         |
        %\quad \lrst{\tsid} \quad        |
        \quad \lcmt{\tsid} \quad        |
        \quad \lfork{\thid,\prog} \quad |
        \quad \ljoin{\thid} \\
    \end{rclarray}
\]

The notation \( \ptrans{\cmd}_{\tsid, \tshp} \) indicates that the transaction identifier by \( \tsid \) has been started with the snapshot of heap \( \tshp \), but does not commit so far.

\[
    \begin{syntax}{\progext}
              \prog \quad                                       |
        \quad \ptrans{\cmd}_{\tsid, \tshp} \pseq \progext \quad |
        \quad \progext \pseq \pwait{\thid} \quad 
    \end{syntax}
\]

The main difference of this semantics is, except removing all the local time, that the one-step \rl{Commit} is split into few steps.
Here we assume there is a global functions \(\func{freshTransId} \) that return a new transaction identifier each time.

\[
    \infer[\rl{TakeSnapshot}]{%
        ( \stk, \tshp ) , \ptrans{\cmd} \ \threadtransfer{\lst{\tsid}} \ ( \stk, \tshp ) , \ptrans{\cmd}_{\tsid, \tshp}
    }{%
        \begin{array}{c}
            \quad \tsid = \func{freshTransId}()
        \end{array}
    }
\]

We also redefine some functions and predicates used before.

\[
    \begin{rclarray}
        \func{startstate}(\tshp) & \defeq & \lambda \loc \ldotp \val \ \texttt{where} \ \tshp(\loc) = (\dontcare, \val)\\
        \pred{allowcommit}{\tshp,\tshp',\ws,\rs} & \defeq & \forall \loc \in \ws \ldotp \tshp(\loc) = \tshp'(\loc)\\
        \func{commitTrans}(\tshp,\hp_{e}) & \defeq &
        \lambda \loc \ldotp
        \begin{funcarray}
            ( \tshp(\loc)\projection{1}+1, \hp_{e}(\loc)) & \loc \in \ws \\
            \tshp(\loc) & o.w. \\
        \end{funcarray} \\
    \end{rclarray}
\]

\[
    \infer[\rl{Commit}]{%
        ( \stk, \tshp ) , \ptrans{\cmd}_{\tsid, \tshp'} \ \threadtransfer{\lcmt{\tsid}} \ ( \stk', \tshp'' ) , \pskip
    }{%
        \begin{array}{c}
            \quad \hp_{s} = \func{startstate}(\tshp') 
            \quad ( \stk, \hp_{s}, \emptyset, \emptyset ) , \cmd \localtransfer^{*} ( \stk', \hp_{e}, \rs, \ws ) , \pskip \\
            \pred{allowcommit}{\tshp,\tshp',\ws,\rs} 
            \quad \tshp'' = \func{commitTrans}(\tshp,\hp_{e})
        \end{array}
    }
\]
