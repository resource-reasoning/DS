\section{Alternative Semantics\label{sec:alter}}

\subsection{Timestamp}

We model the global database state as a \emph{timestamp heap}. A timestamp heap is a partial function from addresses to \emph{histories}.
A history is a partial function from timestamps to a set of \emph{events}.
An event is a triple comprising the value read or written, the identifier of the transaction carrying out the event, and an \emph{event tag} denoting a \emph{start event} ($\etS$), an \emph{end} event ($\etE$), a \emph{read} event ($\etR$) or a \emph{write} event ($\etW$).
We model our timestamps, $\ts \in \Timestamp$, as elements of an (uncountably) infinite set with a total order relation $<$. To ensure the availability of an appropriate timestamp, we assume that the timestamp set $\Timestamp$ is \emph{dense}. That is, given any two timestamps $\ts_1$ and $\ts_2$ such that $\ts_1 < \ts_2$, an intermediate timestamp $\ts$ can be found such that $\ts_1 < \ts < \ts_2$.

\begin{defn}[Event tags]
\label{ref:event-tag}
The set of \emph{event tags} is $\etag \in \ETags \eqdef \{\etS, \etE, \etR, \etW \}$.
\end{defn}
%
\begin{defn}[Timestamps]
\label{def:timestamp}
The set of \emph{timestamps}, $\Timestamp$, is a infinitely countable set, and there is a \emph{total order} relation on it, $<\ : \Timestamp \times \Timestamp$, such that:
%
\[
	\for{\ts_1, \ts_2 \in \Timestamp} \ts_1 < \ts_2 \lor \ts_2 < \ts_1
\]
%
This timestamp set $\Timestamp$ is \emph{dense} with respect to the ordering relation $<$. 
That is,
\[
	\for{\ts_1, \ts_2} \ts_1 < \ts_2 
	\implies 
	\exsts{\ts} \ts_1 < \ts < \ts_2	
\]
\end{defn}
%
We write $\ts_1 \leq \ts_2$ as a shorthand for $\ts_1 < \ts_2 \lor \ts_1 = \ts_2$.
We write $\ts_1 \oplus \ts \odot \ts_2 $ for $\ts_1 \oplus \ts \land \ts \odot \ts_2 $, where $\oplus, \odot \in \{<, \leq\}$.
We often use the mirrored symbols and write $\ts_1 > \ts_2$ (resp.~$\ts_1 \geq \ts_2$) for $\ts_2 < \ts_1$ (resp.~$\ts_2 \leq \ts_1$).
Lastly, we use the standard interval notation and write:
%
\[
\begin{rclarray}
	(\ts_1, \ts_2) & \text{for} & \Set{\ts \mid \ts_1 < \ts < \ts_2 } \\
	(\ts_1, \ts_2] & \text{for} & \Set{\ts \mid \ts_1 < \ts \leq \ts_2 } \\
	{[\ts_1, \ts_2)} & \text{for} & \Set{\ts \mid \ts_1 \leq \ts < \ts_2 } \\	
	{[\ts_1, \ts_2]} & \text{for} & \Set{\ts \mid \ts_1 \leq \ts \leq \ts_2 } 
\end{rclarray}
\]
\begin{defn}[Timestamp heaps]
\label{def:timestamp_heaps}
Assume a countably infinite set of \emph{transaction identifiers} $\tsid, \beta \in \TransID$.
Given the set of event tags $\ETags$ (\defin\ref{ref:event-tag}), program values $\Val$ (\defin\ref{def:prgram_values}), program addresses $\Addr$ (\defin\ref{def:prgram_values}) and timestamps \(\Timestamp\) (\defin\ref{def:timestamp}), the set of \emph{timestamp heaps} is defined as $\tshp \in \TSHeaps \eqdef \Addr \parfinfun (\Val \times \TransID \times \ETags)$.
The \emph{timestamp heap composition function}, $\composeTSH: \TSHeaps \times \TSHeaps \parfun \TSHeaps$, is defined as follows, for all $\addr \in \Addr$, where $\uplus$ denotes the standard disjoint function union:
%
\[
	(\tshp_1 \composeTSH \tshp_2)(\addr) \defeq 
	\begin{cases}
		\tshp_1(\addr) \uplus \tshp_2(\addr) & \text{if } \addr \in \dom(\tshp_1) \text{ and } \addr \in \dom(\tshp_2) \\
		\tshp_1(\addr) & \text{if } \addr \in \dom(\tshp_1) \text{ and } \addr \not\in \dom(\tshp_2) \\
		\tshp_2(\addr) & \text{if } \addr \not\in \dom(\tshp_1) \text{ and } \addr \in \dom(\tshp_2) \\
		\text{undefined} & \text{otherwise}
	\end{cases}
\]
%
The \emph{timestamp heap unit element} is $\unitTSH \eqdef \emptyset$, denoting a function with an empty domain.
The \emph{partial commutative monoid of timestamp heaps} is $(\TSHeaps, \composeTSH, \{\unitTSH\})$. 
\end{defn}
 
Whilst the state of the database is given by globally-accessed (by all threads) timestamp heaps, we use \emph{fingerprint heaps} to model a \emph{local snapshot} of the global timestamp heaps made available to transactions during their execution. 
In order to successfully commit a transaction and avoid conflicts, we must track the \emph{fingerprint} of a transaction, namely those addresses read from or written to by the transaction.
As such, we model fingerprint heaps as finite partial maps from addresses to pairs comprising a value and a fingerprint.
The fingerprint of an address may be 1) $\emptyset$ denoting that the address has not been touched;
2) $\Set{\fpR}$ denoting that the address has been read;
3) $\Set{\fpW}$ denoting that the address has been mutated (written to);
and 4) $\Set{\fpR, \fpW}$ denoting that the address has been initially read and subsequently mutated.   
%
\subsection{Weaken Atomic}

We reuse some notations in Sect. \ref{sec:semantics}, but redefined the meaning.
The \( \TSHeaps \) now is a partial function from locations to a tuple of \( \Timestamp \) and \( \Val \).
The thread state now is only a local stack and a global stack, and correspondingly, the join label is only parametrised by thread identifier.

\[
    \begin{rclarray}
        \tshp \in \TSHeaps & \defeq & \Loc \parfinfun ( \Timestamp \times  \Val ) \\
        \lb \in \Translabel & \defeq & 
              \lbID \quad               |
        \quad \lbS{\tsid} \quad         |
 t      \quad \lbC{\tsid} \quad        |
        \quad \lbF{\thid,\prog} \quad |
        \quad \lbJ{\thid} \\
    \end{rclarray}
\]

The notation \( \ptrans{\trans}_{\tsid, \tshp} \) indicates that the transaction identifier by \( \tsid \) has been started with the snapshot of heap \( \tshp \), but does not commit so far.

\[
    \begin{rclarray}
        \iprog & ::= &  \prog \mid \mid \ptrans{\trans}_{\tsid, \tshp} \pseq \iprog \mid \iprog \pseq \pwait{\thid} 
    \end{rclarray}
\]

The main difference of this semantics is, except removing all the local time, that the one-step \rl{Commit} is split into few steps.
Here we assume there is a global functions \(\funcn{freshTransId} \) that return a new transaction identifier each time.

\[
    \infer[\rl{TakeSnapshot}]{%
        ( \stk, \tshp ) , \ptrans{\trans} \ \toT{\lbS{\tsid}} \ ( \stk, \tshp ) , \ptrans{\trans}_{\tsid, \tshp}
    }{%
        \begin{array}{c}
            \quad \tsid = \func{freshTransId}{}
        \end{array}
    }
\]

We also redefine some functions and predicates used before.

\[
    \begin{rclarray}
        \func{startstate}{\tshp} & \defeq & \lambda \loc \ldotp (\val, \emptyset) \ \texttt{where} \ \tshp(\loc) = (\stub, \val)\\
        \pred{allowcommit}{\tshp,\tshp', \fph} & \defeq & \forall \loc \ldotp \fpW \in \fphFP[\fph](\loc) \land \tshp(\loc) = \tshp'(\loc)\\
        \func{commitTrans}{\tshp,\fph_{e}} & \defeq &
        \lambda \loc \ldotp
        \begin{cases}
            ( \tshp(\loc)\projection{1}+1, \fphVAL[\fph_{e}](\loc)) & \fpW \in \fphFP[\fph_{e}](\loc)  \\
            \tshp(\loc) & \text{otherwise}
        \end{cases} \\
    \end{rclarray}
\]

\[
    \infer[\rl{Commit}]{%
        ( \stk, \tshp ) , \ptrans{\trans}_{\tsid, \tshp'} \ \toT{\lbC{\tsid}} \ ( \stk', \tshp'' ) , \pskip
    }{%
        \begin{array}{c}
            \quad \fph_{s} = \func{startstate}{\tshp'}
            \quad ( \stk, \fph_{s}) , \trans \toL^{*} ( \stk', \fph_{e}) , \pskip \\
            \pred{allowcommit}{\tshp,\tshp', \fph}
            \quad \tshp'' = \func{commitTrans}{\tshp,\fph_{e}}
        \end{array}
    }
\]
