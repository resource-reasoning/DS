\section{Alternative Semantics\label{sec:alter}}

\subsection{Timestamp}

We model the global database state as a \emph{timestamp heap}. A timestamp heap is a partial function from addresses to \emph{histories}.
A history is a partial function from timestamps to a set of \emph{events}.
An event is a triple comprising the value read or written, the identifier of the transaction carrying out the event, and an \emph{event tag} denoting a \emph{start event} ($\etS$), an \emph{end} event ($\etE$), a \emph{read} event ($\etR$) or a \emph{write} event ($\etW$).
We model our timestamps, $\ts \in \Timestamp$, as elements of an (uncountably) infinite set with a total order relation $<$. To ensure the availability of an appropriate timestamp, we assume that the timestamp set $\Timestamp$ is \emph{dense}. That is, given any two timestamps $\ts_1$ and $\ts_2$ such that $\ts_1 < \ts_2$, an intermediate timestamp $\ts$ can be found such that $\ts_1 < \ts < \ts_2$.

\begin{defn}[Event tags]
\label{ref:event-tag}
The set of \emph{event tags} is $\etag \in \ETags \eqdef \{\etS, \etE, \etR, \etW \}$.
\end{defn}
%
\begin{defn}[Timestamps]
\label{def:timestamp}
The set of \emph{timestamps}, $\Timestamp$, is a infinitely countable set, and there is a \emph{total order} relation on it, $<\ : \Timestamp \times \Timestamp$, such that:
%
\[
	\for{\ts_1, \ts_2 \in \Timestamp} \ts_1 < \ts_2 \lor \ts_2 < \ts_1
\]
%
This timestamp set $\Timestamp$ is \emph{dense} with respect to the ordering relation $<$. 
That is,
\[
	\for{\ts_1, \ts_2} \ts_1 < \ts_2 
	\implies 
	\exsts{\ts} \ts_1 < \ts < \ts_2	
\]
\end{defn}
%
We write $\ts_1 \leq \ts_2$ as a shorthand for $\ts_1 < \ts_2 \lor \ts_1 = \ts_2$.
We write $\ts_1 \oplus \ts \odot \ts_2 $ for $\ts_1 \oplus \ts \land \ts \odot \ts_2 $, where $\oplus, \odot \in \{<, \leq\}$.
We often use the mirrored symbols and write $\ts_1 > \ts_2$ (resp.~$\ts_1 \geq \ts_2$) for $\ts_2 < \ts_1$ (resp.~$\ts_2 \leq \ts_1$).
Lastly, we use the standard interval notation and write:
%
\[
\begin{rclarray}
	(\ts_1, \ts_2) & \text{for} & \Set{\ts \mid \ts_1 < \ts < \ts_2 } \\
	(\ts_1, \ts_2] & \text{for} & \Set{\ts \mid \ts_1 < \ts \leq \ts_2 } \\
	{[\ts_1, \ts_2)} & \text{for} & \Set{\ts \mid \ts_1 \leq \ts < \ts_2 } \\	
	{[\ts_1, \ts_2]} & \text{for} & \Set{\ts \mid \ts_1 \leq \ts \leq \ts_2 } 
\end{rclarray}
\]
\begin{defn}[Timestamp heaps]
\label{def:timestamp_heaps}
Assume a countably infinite set of \emph{transaction identifiers} $\tsid, \beta \in \TransID$.
Given the set of event tags $\ETags$ (\defin\ref{ref:event-tag}), program values $\Val$ (\defin\ref{def:prgram_values}), program addresses $\Addr$ (\defin\ref{def:prgram_values}) and timestamps \(\Timestamp\) (\defin\ref{def:timestamp}), the set of \emph{timestamp heaps} is defined as $\tshp \in \TSHeaps \eqdef \Addr \parfinfun (\Val \times \TransID \times \ETags)$.
The \emph{timestamp heap composition function}, $\composeTSH: \TSHeaps \times \TSHeaps \parfun \TSHeaps$, is defined as follows, for all $\addr \in \Addr$, where $\uplus$ denotes the standard disjoint function union:
%
\[
	(\tshp_1 \composeTSH \tshp_2)(\addr) \defeq 
	\begin{cases}
		\tshp_1(\addr) \uplus \tshp_2(\addr) & \text{if } \addr \in \dom(\tshp_1) \text{ and } \addr \in \dom(\tshp_2) \\
		\tshp_1(\addr) & \text{if } \addr \in \dom(\tshp_1) \text{ and } \addr \not\in \dom(\tshp_2) \\
		\tshp_2(\addr) & \text{if } \addr \not\in \dom(\tshp_1) \text{ and } \addr \in \dom(\tshp_2) \\
		\text{undefined} & \text{otherwise}
	\end{cases}
\]
%
The \emph{timestamp heap unit element} is $\unitTSH \eqdef \emptyset$, denoting a function with an empty domain.
The \emph{partial commutative monoid of timestamp heaps} is $(\TSHeaps, \composeTSH, \{\unitTSH\})$. 
\end{defn}
 
Whilst the state of the database is given by globally-accessed (by all threads) timestamp heaps, we use \emph{fingerprint heaps} to model a \emph{local snapshot} of the global timestamp heaps made available to transactions during their execution. 
In order to successfully commit a transaction and avoid conflicts, we must track the \emph{fingerprint} of a transaction, namely those addresses read from or written to by the transaction.
As such, we model fingerprint heaps as finite partial maps from addresses to pairs comprising a value and a fingerprint.
The fingerprint of an address may be 1) $\emptyset$ denoting that the address has not been touched;
2) $\Set{\fpR}$ denoting that the address has been read;
3) $\Set{\fpW}$ denoting that the address has been mutated (written to);
and 4) $\Set{\fpR, \fpW}$ denoting that the address has been initially read and subsequently mutated.   
%

\begin{defn}[Thread semantics]
Assume a countably infinite set of thread identifiers $\thid,j \in \ThreadID$.
The set of \emph{intermediate programs}, $\iprog \in \IntermediatePrograms$, is defined by the following grammar:
%
\[
    \iprog ::= \prog \mid \iprog \pseq \pwait{\thid}
\]
%
Given the set of stacks $\Stacks$ (\defin\ref{def:stacks}), timestamp heaps $\TSHeaps$ and timestamps $\Timestamp$ (\defin\ref{def:timestamp}), the \emph{per-thread operational semantics} of programs:
%
\[
	\toT{} : 
	\left((\Stacks \times \TSHeaps \times \Timestamp) \times \IntermediatePrograms \right) 
	\times \Translabel \times  
	\left((\Stacks \times \TSHeaps \times \Timestamp) \times \IntermediatePrograms \right) 
\]
%
is defined in \fig\ref{fig:thread_semantics}.
\end{defn}


\begin{figure}
%
\hrule\vspace{5pt}
%
\[
    \infer[\rl{Commit}]{%
        ( \stk, \tshp, \ts_{s} ) , \ptrans{\trans} \ \toT{\lbC{\tsid}} \ ( \stk', \tshp', \ts_{e} ) , \pskip
    }{%
        \begin{array}{c}
            \ts_s < \ts_e 
            \qquad \fph_s = \snapshot{\tshp}{\ts_s}
            \qquad ( \stk, \fph_s) , \trans \toL^{*} ( \stk', \fph_e) , \pskip \\
            \cancommit{\tshp}{\fph_e}{\ts_s}{\ts_e} 
            \quad \pred{fresh}{\tshp, \tsid}
            \quad \tshp' = \commit{\tshp}{\fph_s}{\fph_e}{\tsid}{\ts_s}{\ts_e}
        \end{array}
    }
\]

\[
    \infer[\rl{PChoiseL}]{%
        ( \stk, \tshp, \ts ) , \prog_{1} \pchoice \prog_{2} \ \toT{\lbID} \  ( \stk, \tshp, \ts ) , \prog_{1}
    }{%
    }
\]

\[
    \infer[\rl{PChoiseR}]{%
        ( \stk, \tshp, \ts ) , \prog_{1} \pchoice \prog_{2} \ \toT{\lbID} \  ( \stk, \tshp, \ts ) , \prog_{2}
    }{%
    }
\]

\[
    \infer[\rl{PLoop}]{%
        ( \stk, \tshp, \ts ) , \prog\prepeat \ \toT{\lbID} \  ( \stk, \tshp, \ts ) , \pskip \pchoice (\prog \pseq \prog\prepeat)
    }{%
    }
\]

\[
    \infer[\rl{PSeqSkip}]{%
        ( \stk, \tshp, \ts ) , \pskip \pseq \iprog \ \toT{\lbID} \  ( \stk, \tshp, \ts ) , \iprog
    }{%
    }
\]

\[
    \infer[\rl{PSeq}]{%
        ( \stk, \tshp, \ts ) , \iprog_{1} \pseq \iprog_{2} \ \toT{\lb} \ ( \stk', \tshp', \ts' ) , {\iprog_{1}}' \pseq \iprog_{2}
    }{%
        ( \stk, \tshp, \ts ) , \iprog_{1} \ \toT{\lb} \  ( \stk', \tshp', \ts' ) , {\iprog_{1}}' 
    }
\]

\[
    \infer[\rl{PPar}]{%
        ( \stk, \tshp, \ts ) , \prog_{1} \ppar \prog_{2} \ \toT{\lbF{\thid, \prog_{2}}} \  ( \stk, \tshp, \ts ) , \prog_{1} \pseq \pwait{\thid}
    }{%
    }
\]

\[
    \infer[\rl{PWait}]{%
        ( \stk, \tshp, \ts ) , \pwait{\thid} \ \toT{\lbJ{\thid,\ts'}} \  ( \stk, \tshp , \max\Set{\ts,\ts'} ) , \pskip 
    }{%
    }
\]

\[
    \infer[\rl{PIncTime}]{%
        ( \stk, \tshp, \ts ) , \iprog \ \toT{\lbID} \  ( \stk, \tshp , \ts' ) , \iprog 
    }{%
       \ts' > \ts
    }
\]
 
where,
\[
\begin{rclarray}
	\snapshot{.}{.} & : & \TSHeaps \times \Timestamp \parfun \FPHeaps \\
%	
	\snapshot{\tshp}{\ts} & \defeq & 
	\lambda \addr \ldotp
	\begin{cases} 
		(\val, \emptyset) & 
		\exsts{\ts' \leq \ts} \tshp(\addr)(\ts') {=} (\val,\etW, \stub) \\
		& \quad {} \land \for{\ts'' \in ( \ts', \ts), \etag} \tshp(\addr)(\ts'') {=} (\stub,\etag,\stub) \implies \etag \in \Set{\etR, \etE}\\
        \text{undefined} & \text{otherwise}
	\end{cases} 
	\vspace{3pt}\\
	\commit{.}{.}{.}{.}{.}{.} & : & \TSHeaps \times \FPHeaps \times \FPHeaps \times \TransID \times \Timestamp \times \Timestamp \to \TSHeaps \\
%	
	\commit{\tshp}{\fph_s}{\fph_e}{\tsid}{\ts_s}{\ts_e} & \defeq &
	\lambda \addr \ldotp
	\begin{cases}
		\tshp(\addr)\remapsto{\ts_s}{(\fphVAL[\fph_s](\addr),\etS,\tsid)}\remapsto{\ts_e}{(\fphVAL[\fph_e](\addr),\etW,\tsid)} 
		& \text{if \;} \fphFP[\fph_e](\addr) {=} \{\fpW\} \\
		\tshp(\addr)\remapsto{\ts_s}{(\fphVAL[\fph_s](\addr),\etR,\tsid)}\remapsto{\ts_e}{(\fphVAL[\fph_e](\addr),\etE,\tsid)} 
		& \text{if \;} \fphFP[\fph_e](\addr) {=} \{\fpR\} \\
		\tshp(\addr)\remapsto{\ts_s}{(\fphVAL[\fph_s](\addr),\etR,\tsid)}\remapsto{\ts_e}{(\fphVAL[\fph_e](\addr),\etW,\tsid)} & \text{if \;} \fphFP[\fph_e](\addr) {=} \{\fpR, \fpW\} \\
		\tshp(\addr)\remapsto{\ts_s}{(\fphVAL[\fph_s](\addr),\etS,\tsid)}\remapsto{\ts_e}{(\fphVAL[\fph_e](\addr),\etE,\tsid)} & \text{otherwise}
	\end{cases} 
	\vspace{3pt}\\
%
%              
	\cancommit{\tshp}{\fph}{\ts_s}{\ts_e} 
	& \defeq & 
	\wfhist{\tshp}{\fph}{\ts_s}{\ts_e} \land \consistent{\tshp}{\fph}{\ts_s}{\ts_e} 
	\vspace{3pt}\\
%
%        
	\wfhist{\tshp}{\fph}{\ts_s}{\ts_e} 
	& \defeq  & 
 	\for{\addr} \for{\ts \in \Set{\ts_{s},\ts_{e}}} \fphFP(\addr) {\ne} \emptyset \implies \tshp(\addr)(\ts)\isundef 
	\vspace{3pt}\\
%
%        
	\consistent{\tshp}{\fph}{\ts_s}{\ts_e}
	& \defeq & 
	\for{\addr} \fpW \in \fphFP(\addr) \implies \\
	&& \quad \for{\ts \in (\ts_s,\ts_e)} \tshp(\addr)(\ts) {\ne} (\stub, \etW, \stub) \\
	&& \quad \land\ \neg\exsts{\tsid, \ts'_s, \ts'_e} \ts'_s < \ts_e \land
       \ts'_e > \ts_e \land \tshp(\addr)(\ts'_s) = (\stub, \stub, \tsid) \land 
       \tshp(\addr)(\ts'_e) = (\stub, \etW, \tsid) \\
	&& \quad \land\ \for{\ts_m} \ts_m {=} \min(\Setcon{\ts'' }{ \ts'' > \ts_{e} \land
       \tshp(\addr)(\ts'')\isdef}) \implies \tshp(\addr)(\ts_{min}) \neq (\stub, \etR, \stub) 
	\vspace{3pt}\\
%
%        
	\pred{fresh}{\tshp, \tsid}  & \defeq & \neg\exsts{\addr, \ts} \tshp(\addr)(\ts) {=} (\stub, \stub, \tsid)
    \end{rclarray}
\]
\hrule\vspace{5pt}
\caption{Per-thread operational semantics}
\end{figure}





\subsection{Weaken Atomic}

We reuse some notations in Sect. \ref{sec:semantics}, but redefined the meaning.
The \( \TSHeaps \) now is a partial function from locations to a tuple of \( \Timestamp \) and \( \Val \).
The thread state now is only a local stack and a global stack, and correspondingly, the join label is only parametrised by thread identifier.

\[
    \begin{rclarray}
        \tshp \in \TSHeaps & \defeq & \Loc \parfinfun ( \Timestamp \times  \Val ) \\
        \lb \in \Translabel & \defeq & 
              \lbID \quad               |
        \quad \lbS{\tsid} \quad         |
 t      \quad \lbC{\tsid} \quad        |
        \quad \lbF{\thid,\prog} \quad |
        \quad \lbJ{\thid} \\
    \end{rclarray}
\]

The notation \( \ptrans{\trans}_{\tsid, \tshp} \) indicates that the transaction identifier by \( \tsid \) has been started with the snapshot of heap \( \tshp \), but does not commit so far.

\[
    \begin{rclarray}
        \iprog & ::= &  \prog \mid \mid \ptrans{\trans}_{\tsid, \tshp} \pseq \iprog \mid \iprog \pseq \pwait{\thid} 
    \end{rclarray}
\]

The main difference of this semantics is, except removing all the local time, that the one-step \rl{Commit} is split into few steps.
Here we assume there is a global functions \(\funcn{freshTransId} \) that return a new transaction identifier each time.

\[
    \infer[\rl{TakeSnapshot}]{%
        ( \stk, \tshp ) , \ptrans{\trans} \ \toT{\lbS{\tsid}} \ ( \stk, \tshp ) , \ptrans{\trans}_{\tsid, \tshp}
    }{%
        \begin{array}{c}
            \quad \tsid = \func{freshTransId}{}
        \end{array}
    }
\]

We also redefine some functions and predicates used before.

\[
    \begin{rclarray}
        \func{startstate}{\tshp} & \defeq & \lambda \loc \ldotp (\val, \emptyset) \ \texttt{where} \ \tshp(\loc) = (\stub, \val)\\
        \pred{allowcommit}{\tshp,\tshp', \fph} & \defeq & \forall \loc \ldotp \fpW \in \fphFP[\fph](\loc) \land \tshp(\loc) = \tshp'(\loc)\\
        \func{commitTrans}{\tshp,\fph_{e}} & \defeq &
        \lambda \loc \ldotp
        \begin{cases}
            ( \tshp(\loc)\projection{1}+1, \fphVAL[\fph_{e}](\loc)) & \fpW \in \fphFP[\fph_{e}](\loc)  \\
            \tshp(\loc) & \text{otherwise}
        \end{cases} \\
    \end{rclarray}
\]

\[
    \infer[\rl{Commit}]{%
        ( \stk, \tshp ) , \ptrans{\trans}_{\tsid, \tshp'} \ \toT{\lbC{\tsid}} \ ( \stk', \tshp'' ) , \pskip
    }{%
        \begin{array}{c}
            \quad \fph_{s} = \func{startstate}{\tshp'}
            \quad ( \stk, \fph_{s}) , \trans \toL^{*} ( \stk', \fph_{e}) , \pskip \\
            \pred{allowcommit}{\tshp,\tshp', \fph}
            \quad \tshp'' = \func{commitTrans}{\tshp,\fph_{e}}
        \end{array}
    }
\]
