\subsection{Program Soundness}

The soundness judgement says for any terminated trace, a trace reaching \( \pskip \), where every step in the trace is either a environment step that is allowed by the rely and consistency model, or the command get reduced one step, if the precondition satisfies the initial world of the trace \( \w \in \evalW{\gpre} \), then the postcondition should satisfy the final world \( \w' \in \evalW[\lenv,\stk']{\gpost} \).

\begin{defn}[Soundness Judgement]
\label{def:semantic-triple}
\label{def:triple-semantic}
\label{def:semantic-steps}
\label{def:soundness-judgement}
%The collapse of update rely, written \( \clpsR{\relyU} \), is defined with respect to pointwise collapsing each elements of pairs and the second abstract executions in a pair must be reachable from the first one.
%\[
%\begin{rclarray}
    %\clpsR{\relyU} & \defeq & 
    %\Setcon{
        %(\aexec, \aexec')
    %}{
        %\exsts{\w, \w', \evset}  
        %\aexec \in \clpsW{\w}
        %\land \aexec' \in \clpsW{\w'}
        %\land ( \w, \w' ) \in \relyU
        %\land (\aexec, \evset, \aexec') \in \func{transinv}{\w}
    %}
%\end{rclarray}
%\]
%Therefore the collapse of rely is \( (\aexec,\aexec') \in \clpsR{\Rely} \iffdef ( \aexec, \aexec' ) \in \closure{(\clpsR{\relyU})} \).
%The collapse of guarantee, \( \clpsG{\Guar}\), is defined in a similar way.
The \( \predn{step} \) predicate is defined as the follows,
%\sx{To define \( \w, \w' \in \como\) which is straightforward. }
\[
\begin{rclarray}
    \pred{step}{0,\w, \w', \stk, \stk',\pskip, \como} & \defeq & 
    \begin{array}[t]{@{}l}
    %\fora{\hh, \hh', \vi, \vi'} 
    \stk = \stk' \land \w = \w'
    %\quad  ( (\hh, \vi, \stub) \in \clpsW{\w} \land (\hh', \vi', \stub) \in \clpsW{\w'}  \implies \hh = \hh' \land \vi = \vi' ) \\
    \end{array} \\
    \pred{step}{\nat + 1,\w, \w', \stk, \stk', \cmd, \como} & \defeq &
    \begin{array}[t]{@{}l}
    \exsts{ \hh, \hh', \w''}  \\
        \quad (\w,\w'') \in \Rely  
        \land (\hh, \stub, \stub ) \in \clpsW{\w}
        \land (\hh', \stub, \stub ) \in \clpsW{\w'} \\
        \qquad {} \land (\hh, \hh') \in \como 
        \land \pred{step}{\nat, \w'', \w', \stk, \stk', \cmd, \como} \\
    \end{array} \\
    \pred{step}{\nat + 1,\w, \w', \stk, \stk', \cmd, \como} & \defeq &
    \begin{array}[t]{@{}l}
        \fora{\hh, \hh'', \vi, \vi'', \stk'', \lb, \thid, \cmd'}
        (\hh,\vi, \stub) \in \clpsW{\w} \\
        \quad {} \land (\stk, \hh, \vi), \cmd \toT{\como} ( \stk'', \hh'', \vi'' ), \cmd' \\
        \qquad {} \land \exsts{\w''}
        (\w, \w'') \in \Guar
        \land (\hh'',\vi'', \stub) \in \clpsW{\w''} 
        \land \pred{step}{\nat, \w'', \w', \stk'', \stk', \cmd', \como} \\
    \end{array}
\end{rclarray}
\]
Given above the soundness judgement is as the follows,                                                  
\[
\begin{rclarray}
    \como \tripleSemG{\gpre}{\cmd}{\gpost} & \defeq &
    \begin{array}[t]{@{}l@{}}
        \fora{ \w,\w', \stk, \stk', \lenv, \nat }  
        \w \in \evalW[\lenv, \stk]{\gpre} 
        \land \pred{step}{\nat, \w, \w', \stk, \stk', \cmd, \como}
        \implies \w' \in \evalW[\lenv, \stk']{\gpost} 
    \end{array}
\end{rclarray}
\]
\end{defn}                                         

Here it is a over approximation of the view environment that assumes the view environment does not intertwine with the current view.
For many consistency models this judgement is good enough, because the specifications do not mentioned the view environment.
Yet the soundness judgement for SI, for example, is not very strong since it includes some cases that are allowed locally but might be disallowed when the view environment comes in.



%\begin{lem}[Locality of cut]
%\label{lem:locality-cut}
%A thread can only update its own cut when commit a new transaction,
%\[
%\begin{array}{@{}l}
    %\fora{\thstk, \thstk', \hh, \hh', \thcu, \thcu', \cu, \cu', \thid, \como} \exsts{\thcu''} \\
    %\quad \thid, \como \vdash (\thstk, \hh, \thcu), \ptrans{\trans} \toT{\lbC{\stub}} (\thstk', \hh', \thcu'), \pskip \\
    %\qquad \implies \thcu  = \thcu'' \uplus \setminus \Set{\thid \mapsto \cu } \land \thcu' = \thcu'' \uplus \setminus \Set{ \thid \mapsto \cu' }
%\end{array}
%\]
%This means the cut environment can be arbitrary as long as the local update remains the same and the entire environment satisfy the consistency model.
%\[
%\begin{array}{@{}l}
    %\fora{\thstk, \thstk', \hh, \hh', \thcu, \thcu', \cu, \cu', \thid, \thid', \como} \\
    %\quad \thid, \como \vdash (\thstk, \hh, \thcu \uplus \Set{\thid \mapsto \cu}), \ptrans{\trans} \toT{\lbC{\stub}} (\thstk', \hh', \thcu \uplus \Set{\thid \mapsto \cu'}), \pskip \\
    %\quad {} \land ((\hh,\thcu' \uplus \Set{\thid' \mapsto \cu}),(\hh',\thcu' \uplus \Set{\thid' \mapsto \cu'})) \in \como \\
    %\qquad \implies \thid', \como \vdash (\thstk, \hh, \thcu' \uplus \Set{\thid' \mapsto \cu}), \ptrans{\trans} \toT{\lbC{\stub}} (\thstk', \hh', \thcu' \uplus \Set{\thid' \mapsto \cu'}), \pskip \\
%\end{array}
%\]
%\end{lem}
%\begin{proof}
%The first one is trivial as \( \thcu' = \thcu\rmto{\thid}{\cu'}\) in the \rl{PCommit} rule, and no other side condition has side effect on \( \thcu' \).
%For the second part, by the hypothesis we have the following which are exactly the side conditions of the \rl{PCommit},
%\[
%\begin{array}{@{}l}
    %\exsts{\h, \h', \txstk_{0}, \txstk, \txid, \opset } \\
    %\quad \txid \in \func{fresh}{\hh}  
    %\land \h = \clpsHH{\hh,\cu}
    %\land \txstk_{0} = \emptyset 
    %\land \thstk \vdash (\txstk_{0}, \h, \unitO), \trans \ \toL^{*} \  (\txstk, \h', \opset) , \pskip \\
    %\quad {} \land \thstk' = \thstk\rmto{\ret}{\txstk(\ret)} 
    %\land \hh' = \func{commit}{\hh, \cu, \txid, \opset}  \\
    %\quad {} \land \cu' = \func{update}{\hh', \cu, \opset} 
    %\land ((\hh,\thcu \uplus \Set{\thid \mapsto \cu}),(\hh',\thcu \uplus \Set{\thid \mapsto \cu})) \in \como
%\end{array}
%\]
%If we replace \( \thcu \) by \( \thcu' \) and the thread identifier such that \( ((\hh, \thcu' \uplus \Set{\thid' \mapsto \cu}),(\hh',\thcu' \uplus \Set{\thid' \mapsto \cu'})) \in \como \) holds, it is easy to see other side conditions still hold, therefore we have the proof.
%\end{proof}
%\sx{need change for how we collapse a world}
%\begin{lem}
%\label{lem:rely-guar-como}
%Any transition in the rely or guarantee should satisfies the consistency model,
%\[
%\begin{array}{@{}l}
    %\fora{\w, \w', \hh, \hh', \cu, \cu'}
    %\exsts{\thcu, \thcu', \thid} \\
    %\quad (\w, \w') \in \Rely \cup \Guar
    %\land (\hh, \cu) \in \clpsW{\w}
    %\land (\hh', \cu') \in \clpsW{\w'} \\
    %\qquad \implies 
    %\thcu(\thid) = \cu
    %\land \thcu'(\thid) = \cu'
    %\land ((\hh, \thcu),(\hh', \thcu')) \in \func{como}{\w}
%\end{array}
%\]
%\end{lem}
%\begin{proof}
%The rely and guarantee are defined using the \( \predn{to}\) predicate by plugging in different capabilities.
%It is sufficient to prove that any transition allowed by the \(\predn{to}\) predicate is also allowed by the consistency model,
%\[
%\begin{array}{@{}l}
    %\fora{\opset, \ca, \gs, \gs', \hh, \hh', \cu, \cu'}
    %\exsts{\thcu, \thcu', \thid} \\
    %\quad \pred{to}{\opset, \ca, \gs, \gs'} 
    %\land (\hh, \cu) \in \clpsS{\gs}
    %\land (\hh', \cu') \in \clpsS{\gs'} \\
    %\qquad \implies 
    %\thcu(\thid) = \cu
    %\land \thcu'(\thid) = \cu'
    %\land ((\hh, \thcu),(\hh', \thcu')) \in \como
%\end{array}
%\]
%where the \( \como \) is the consistency model associated to regions.
%Since it is a recursive predicate, we are going to prove the property by induction.
%\caseB{\(\opset = \unitO\)}
%It is trivial because \(\gs = \gs'\), therefore \( \hh = \hh' \) and \( \thcu = \thcu' \) and the consistency model is reflexive.
%\caseI{\(\opset \neq \unitO\)}
%There exist a region \( \rid \) that has been updated from \( (\hh, \cu) \) to \( (\hh', \cu') \) which is allowed by the invariant, and the update for other regions satisfies the \predn{to} predicate, which is allowed by the consistency model by \ih,
%\[
    %\begin{array}[t]{@{}l}
    %\exsts{\rid, \hh, \hh', \hh'', \hh''', \cu, \cu', \thcu'', \thcu''', \opset', \intf, \gs'',\gs''' }  \\
    %\quad \opset' \subseteq \opset
    %\land \gs = \gs'' \uplus \Set{\rid \mapsto (\hh, \cu, \intf)} 
    %\land \gs' = \gs''' \uplus \Set{\rid \mapsto (\hh', \cu', \intf)}  \\
    %\quad {} \land (\hh,\cu) \toLTS{\opset'} (\hh',\cu') \in \func{inv}{\rid, \intf }
    %\land ((\hh'', \thcu''),(\hh''',\thcu''')) \in \como
    %\end{array}
%\]
%Given the definition of labelled transition system for a region (\defref{def:labelled-transition-system}), the transition \( (\hh, \cu) \toLTS{\opset} (\hh', \cu') \) should satisfy the consistency model,
%\[
%\begin{array}{@{}l}
    %\exsts{ \thcu, \thcu', \thid } 
    %(\hh, \cu) \toLTS{\opset'} (\hh', \cu') \in \func{inv}{\rid, \intf} \\
    %\quad \implies
    %\begin{B}
    %\txid \in \func{fresh}{\hh} 
    %\land \hh' = \func{commit}{\hh, \cu, \txid, \opset} 
    %\land \cu' = \func{update}{\hh', \cu, \opset} \\
    %{} \land ((\hh,\thcu),(\hh',\thcu')) \in \como
    %\land \thcu(\thid) = \cu 
    %\land \thcu'(\thid) = \cu' 
    %\end{B}
%\end{array}
%\]
%Because the well-formed condition for a world (\defref{def:world}), \ie regions must be disjointed, we know the compositions \( \hh \composeHH \hh'' \) and \( \hh' \composeHH \hh''' \) exist.
%Also because of the locality of cut (\lemref{lem:locality-cut}), we can pick a minimum cut environment \( \thcu = \Set{\thid \mapsto \cu} \), \( \thcu' = \Set{\thid \mapsto \cu'}\) and a fresh thread identifier, in a way that it satisfies the consistency when combined with the others.
%This is,
%\[
%\begin{array}{@{}l}
    %\exsts{\thid} \\
    %\begin{B}
    %\thid \notin \dom(\thcu'') 
    %\land (\hh \composeHH \hh'')\isdef 
    %\land (\hh' \composeHH \hh''')\isdef  \\
    %\land ((\hh', \Set{\thid \mapsto \cu}),(\hh'',\Set{\thid \mapsto \cu'})) \in \como 
    %\land ((\hh'', \thcu''),(\hh''',\thcu''')) \in \como 
    %\end{B} \\
    %\quad \implies ((\hh' \composeHH \hh'', \Set{\thid \mapsto \cu} \uplus \thcu''), (\hh'' \composeHH \hh''' ,\Set{\thid \mapsto \cu'} \uplus \thcu''')) \in \como
%\end{array}
%\]
%\end{proof}



\begin{thm}[Per-thread soundness]
\label{thm:per-thread-soundness}
The per-thread soundness is the follows,
\[
    \fora{\gpre, \cmd, \gpost}
    \como \tripleG{\gpre}{\cmd}{\gpost} 
    \implies 
    \como \tripleSemG{\gpre}{\cmd}{\gpost} 
\]
\end{thm}
\begin{proof}
Induction on the derivations.

\caseB{\rl{PRCommit}}

We have \( \prog \equiv \ptrans{\trans} \).
Because a transaction \( \ptrans{\trans} \) is reduced by one step in the semantics, it is sufficient to prove for any world \(\w\) that satisfies pre-condition, after arbitrary steps of rely, \ie \( (\w, \w') \in \Rely^{*} \) (\equref{equ:stable-pre-condition}) if the corresponding machine state \((\hh',\vi', \ca') \in \clpsW{\w'}\), can transfers to a new state \((\hh'',\vi'', \ca'')\) (\equref{equ:commit-transaction}) then again followed by arbitrary steps of rely \((\w'',\w''') \in \Rely^{*} \), the final world \( \w''' \) should satisfy the post-condition \(\gpost\) (\equref{equ:stable-post-condition}).
\sx{typesetting is a bit strange}
\begin{gather}
    \begin{array}{@{}l}
    \stable{\gpre, \como}  
    \implies 
    \fora{\w, \w',\lenv, \stk}  
    \exsts{ \hh, \hh' } \\
    \quad \w \in \evalW{\gpre} 
    \land (\w, \w') \in \Rely \\
    \qquad {} \land (\hh, \stub, \stub) \in \clpsW{\w}
    \land (\hh', \stub, \stub) \in \clpsW{\w'}
    \land (\hh, \hh') \in \como
    \implies \w' \in \evalW{\gpre} 
    \end{array} \tag{Stable Pre} \label{equ:stable-pre-condition} \\
%
    \begin{array}{@{}l}
    \tripleL{\lpre}{\trans}{\lpost}
    \land \repartition{\gpre}{\gpost}{\lpre}{\lpost}
    \implies 
    \fora{\w, \hh, \hh', \vi, \vi', \thid, \lenv, \stk, \stk'} \\
    \quad \w \in \evalW{\gpre}
    \land (\hh, \vi, \stub) \in \clpsW{\w} 
    \land \thid, (\stk, \hh, \vi), \ptrans{\trans} 
    \toT{\como} (\stk', \hh', \vi'), \pskip  \\
    \qquad {} \land \exsts{\w'}
    (\hh', \vi', \stub') \in \clpsW{\w'} 
    \land \w' \in \evalW[\lenv, \stk']{\gpost} 
    \end{array} \label{equ:commit-transaction} \tag{Commit} \\
%
    \begin{array}{@{}l}
    \stable{\gpost, \como}  
    \implies 
    \fora{\w, \w',\lenv, \stk}  
    \exsts{ \hh, \hh' } \\
    \quad \w \in \evalW{\gpre} 
    \land (\w, \w') \in \Rely \\
    \qquad {} \land (\hh, \stub, \stub) \in \clpsW{\w}
    \land (\hh', \stub, \stub) \in \clpsW{\w'}
    \land (\hh, \hh') \in \como
    \implies \w' \in \evalW{\gpost} 
    \end{array} \tag{Stable Post} \label{equ:stable-post-condition} 
\end{gather}

\sx{make sure the stack is correct}

\noindent\textbf{Stable pre-condition.} 
The \( \stable{\gpre, \como} \) predicate asserts any world \( \w \) that satisfies the pre-condition \( \gpre \), if the world can transfer to another world \( \w' \) through rely \( \Rely \), and if the transfer also satisfies the consistency model \( \como \), the new world \( \w' \) satisfies the pre-condition, which implies \equref{equ:stable-pre-condition}. 
\\
\textbf{Commit.}
For any \( \w, \hh, \vi, \lenv, \stk \) such that \( \w \in \evalW{\gpre} \) and \( (\hh, \vi, \ca) \in \clpsW{\w} \), we know \( (\clpsHH{\hh, \vi}, \unitO) \in \evalLS{\lpre} \), this is,
\begin{equation}
\label{equ:local-pre-condition}
\fora{\w, \hh, \vi, \lenv, \stk} \w \in \evalW{P} \land (\hh, \vi, \stub) \in \clpsW{\w} \implies (\clpsHH{\hh, \vi}, \unitO) \in \evalLS{\lpre}
\end{equation}
Because of the soundness of transaction (\thmref{thm:transaction-soundness}), given an initial stack \( \stk \) and a logical environment \( \lenv \), if the initial configuration \( (\stk, \h, \unitO), \trans \) satisfies the pre-condition, \ie \( (\h, \unitO) \in \evalLS[\lenv,\stk]{\lpre} \), and if it can transfer to a final configuration \( (\stk', \h', \opset), \pskip \), the final state should satisfy the post-condition \( \lpost \).
This is,
\begin{equation}
\label{equ:local-transaction-sound}
\begin{array}{@{}l}
    \tripleL{\lpre}{\trans}{\lpost} \implies \\
    \quad \fora{\lenv, \stk, \stk', \hh, \vi, \h', \opset}  
    (\func{clps}{\hh,\vi}, \unitO) \in \evalLS[\lenv,\stk]{\lpre}
    \land \vdash (\stk, \h, \unitO), \trans \toL (\stk', \h', \opset), \pskip
    \implies (\h', \opset) \in \evalLS[\lenv,\stk']{\lpost}
\end{array}
\end{equation}
The repartition \( \repartition{\gpre}{\gpost}{\lpre}{\lpost} \) also asserts that any world \( \w \) satisfying the pre-condition \( \gpre \), if the corresponding machine of the world (ignoring the capabilities here), \ie \( (\hh, \vi) \), can transfer to a new state \( (\hh',\vi') \), by committing the operations \( \opset \), then if a world \( \w' \) can collapses to the new machine state \( (\hh',\vi') \) and the transition \( (\w, \w') \) is allowed by both the guarantee and the consistency model, the new world \( \w' \) should satisfy the post-condition.
\begin{equation}
\label{equ:repartition}
\begin{array}{@{}l}
    \fora{\w,  \hh, \hh', \vi, \vi', \lenv, \stk, \stk', \txid, \opset} \exsts{\w'} \\
    \quad \w \in \evalW{\gpre}
    \land (\hh, \vi, \stub) \in \eraseW{\w}
    \land \txid \in \func{fresh}{\hh} 
    \land (\stub,\opset) \in \evalLS[\lenv, \stk']{\lpost} \\
    \quad {} \land \hh' = \func{updHisHp}{\hh, \vi, \txid, \opset}  
    \land \vi' \geq \func{updView}{\hh', \vi, \opset} \\
    \quad {} \land (\hh',\vi', \stub) \in \eraseW{\w'}
    \land (\w, \w') \in \Guar 
    \land (\hh, \vi') \csat \opset : \vi' 
    \land \w' \in \evalW[\lenv, \stk']{\gpost}
\end{array}
\end{equation}
First by \equref{equ:local-transaction-sound}, we substitute the \( (\stub, \opset) \in \evalLS[\lenv, \stk']{\lpost}\) in \equref{equ:repartition} by the transaction semantics,
\begin{equation}
\label{equ:combined-transaction-sound}
\begin{array}{@{}l}
    \fora{\w,  \hh, \hh', \vi, \vi', \lenv, \stk, \stk', \txid, \opset} \exsts{\w'} \\
    \quad \w \in \evalW{\gpre}
    \land (\hh, \vi, \stub) \in \eraseW{\w}
    \land \txid \in \func{fresh}{\hh}  \\
    \quad {} \land {} \vdash (\stk, \clpsHH{\hh, \cu}, \unitO), \trans \toL (\stk', \h', \opset), \pskip  \\
    \quad {} \land \hh' = \func{updHisHp}{\hh, \vi, \txid, \opset}  
    \land \vi' \geq \func{updView}{\hh', \vi, \opset} \\
    \quad {} \land (\hh',\vi', \stub) \in \eraseW{\w'}
    \land (\w, \w') \in \Guar 
    \land (\hh, \vi') \csat \opset : \vi' 
    \land \w' \in \evalW[\lenv, \stk']{\gpost}
\end{array}
\end{equation}
Hence we prove \equref{equ:commit-transaction} by folding all the side conditions for a atomic transaction,
\[
\begin{array}{@{}l}
    \fora{\w,  \hh, \hh', \vi, \vi', \lenv, \stk, \stk', \txid, \opset} \exsts{\w'} \\
    \quad \w \in \evalW{\gpre}
    \land (\hh, \vi, \stub) \in \eraseW{\w} 
    \land {} (\stk, \hh, \vi), \ptrans{\trans} \toT{\como} (\stk', \hh', \vi'), \pskip  \\
    \quad {} \land (\hh',\vi', \stub) \in \eraseW{\w'}
    \land (\w, \w') \in \Guar 
    \land \w' \in \evalW[\lenv, \stk']{\gpost}
\end{array}
\]
%Then, by the \lemref{lem:rely-guar-como} that the guarantee \( \Guar \) ensures the transition from \( \w \) to \( \w' \) satisfies the consistent model and picking the empty transaction stack as the initial \( \txstk = \txstk_{0} = \emptyset \) transaction stack for the transaction code \( \trans \), we have the follows,
%\[
%\begin{array}{@{}l}
    %\fora{\w, \w', \hh, \hh', \cu, \cu', \lenv, \stk, \txid, \h, \h', \thstk} 
    %\exsts{\thcu, \thcu', \thid } \\
    %\begin{B}
        %\exsts{\h, \h', \txstk_{0}, \txstk', \txid, \opset } \\
        %\quad \w \in \evalW{\gpre} 
        %\land (\hh, \cu) \in \eraseW{\w}
        %\land \txid \in \func{fresh}{\hh} 
        %\land \h = \clpsHH{\hh, \cu}
        %\land \txstk_{0} = \emptyset \\
        %\quad {} \land \thstk \vdash (\txstk, \h, \unitO), \trans \toL (\txstk', \h', \opset), \pskip 
        %\land \hh' = \func{commit}{\hh, \cu, \txid, \opset} \\
        %\quad {} \land \cu' = \func{update}{\hh, \cu, \opset} 
        %\land (\hh',\cu') \in \eraseW{\w'}  \\
        %\quad {} \land ((\hh,\thcu),(\hh',\thcu')) \in \func{como}{\w}
        %\land \thcu(\thid) = \cu 
        %\land \thcu'(\thid) = \cu' \\
    %\end{B}
    %\implies \w' \in \evalW{\gpost}
%\end{array}
%\]
%In the equation above, we have all the side conditions of the \rl{PCommit} rule except the return value, \ie \( \thstk' = \thstk\rmto{\ret}{\txstk(\ret)} \).
%Since the return value does not affect how the post condition \( \gpost \) is interpreted by the repartition, we can fold all the side conditions to the follows,
%\[
%\begin{array}{@{}l}
    %\fora{\w, \w', \hh, \hh', \cu, \cu', \lenv, \stk, \txid, \h, \h', \thstk, \thstk', \txid} 
    %\exsts{\thcu, \thcu', \thid } \\
    %\begin{B}
        %\quad \w \in \evalW{\gpre} 
        %\land (\hh, \cu) \in \eraseW{\w}
        %\land \thid, \func{como}{\w} \vdash (\thstk, \hh, \thcu), \ptrans{\trans} 
        %\toT{\lbC{\txid}} (\thstk', \hh', \thcu'), \pskip  \\
        %\quad {} \land (\hh',\cu') \in \eraseW{\w'}  
        %{} \land ((\hh,\thcu),(\hh',\thcu')) \in \func{como}{\w}
        %\land \thcu(\thid) = \cu 
        %\land \thcu'(\thid) = \cu' \\
    %\end{B}
    %\implies \w' \in \evalW{\gpost}
%\end{array}
%\]
%Now we can apply the \lemref{lem:locality-cut} which allows us to convert the existential quantification for \( \thcu, \thcu', \thid\) to global quantification, thus we have the proof for committing a new transaction, \ie \equref{equ:commit-transaction}. 
\textbf{Stable post-condition.} 
It can be proven for the similar reason as the proof for stable pre-condition.
\end{proof}

The program soundness is for the parallel rule.

\begin{thm}[Program soundness]
For any program \( \prog \), if a precondition \( \gpre \) satisfies a history heap \( \hh \) and a thread environment \( \thdenv \), and if there exist a final history heap and thread environment \( \hh', \thdenv' \)  such that \( (\hh, \thdenv, \prog) \toG{\como} (\hh', \thdenv', (\lambda \thid \ldotp \pskip) ) \) holds, then the post-condition \( \gpost \) derived from the logic rules should satisfies the final configuration.
This is,
\[
\begin{array}{@{}l}
\fora{\gpre, \gpost, \prog, \lenv, \como, \stk, \w, \hh, \hh', \vi, \thdenv, \thdenv'}\\
    \quad \tripleG{\gpre}{\prog}{\gpost}
    \land \w \in \evalW{\gpre}
    \land (\hh, \vi, \stub) \in \clpsW{\w}
    \land \dom(\thdenv) = \dom(\prog)  \\
    \quad {} \land \fora{\thid} \thdenv(\thid) = (\stk, \vi)
    \land (\hh, \thdenv, \prog) \toG{\como} (\hh', \thdenv', (\lambda \thid \ldotp \pskip) ) \\
    \qquad \implies  
    \exsts{\stk', \vi', \w'} \\
    \qqquad \begin{B}
        \fora{\addr, \thid',\var, \val} 
        \thdenv(\thid')\projection{1}(\var) = \val 
        \implies {} \\
        \quad \stk'(\var) = \val  
        \land \vi'(\addr) = \max\Setcon{n}{\exsts{\thid''} \thdenv(\thid'')\projection{2}(\addr) = n} 
    \end{B} \\
    \qqquad {} \land (\hh', \vi', \stub) \in \clpsW{\w'}
    \land \w' \in \evalW[\lenv, \stk']{\gpost}
\end{array}
\] 
\end{thm}
\begin{proof}
Induction on derivations.

\caseB{\( \dom(\prog) \equiv \Set{\txid} \)}
 
If there is only one thread, it is proved by the \thmref{thm:per-thread-soundness}.

\caseB{\( \dom(\prog) \equiv \Set{\txid, \txid'} \)}

We have \( \tripleG{\gpre_{1} \sep \gpre_{2}}{\cmd_{1} \ppar \cmd_{2}}{ \gpost_{1} \sep \gpost_{2} } \) and \( \tripleG{\gpre_{i}}{\cmd_{i}}{ \gpost_{i} } \) for \( i \in \Set{1,2} \).
Give the \ih and the soundness result per thread, we need to prove for any possible traces for the entire program \( \theta \), there exists traces \( \tau_{1} \) and \( \tau_{2} \) from the first thread and second thread with the same state for history heap in each step.
\[
\begin{array}{@{}l}
    \fora{\tau} \exsts{\tau_{1}, \tau_{2}} \\
    \quad 
    \begin{B}
        \fora{i \in \Set{1,2}, \w, \w', \w_{i}} 
        (\w, \w') \in \tau
        \land \clps{\w}\projection{1} = \clps{\w_{i}}\projection{1} 
        \land (\w\projection{1} \composeC \w_{i}\projection{1})\isdef
        \land \w_{i} \in \tau_{i} \\
        \quad \implies \exsts{\w_{i}'} (\w_{i}, \w_{i}) \in \tau_{i}
        \land \clps{\w'}\projection{1} = \clps{\w_{i}'}\projection{1} 
        \land (\w'\projection{1} \composeC \w_{i}'\projection{1})\isdef
    \end{B}
\end{array}
\]
We fix a trace, says from the first thread, and construct another trace.
Initially, because \( \gpre_{1} \sep \gpre_{2} \) is defined, we pick any states \( \w_{1}^{0} \)  and \( \w_{2}^{0} \) such that \( \w_{1}^{0} \in \evalW{\gpre_{1}}\), \( \w_{2}^{0} \in \evalW{\gpre_{2}}\) and \( (\w_{1}^{0} \composeW \w_{2}^{0})\isdef\) so that \( \clps{\w_{1}^{0}}\projection{1} = \clps{\w_{2}^{0}}\projection{1} \) and \( (\w_{1}^{0}\projection{1} \composeC \w_{2}^{0}\projection{1})\isdef \).
Now two traces \( tau_{1}\) and \( \tau_{2} \) where the current finial states are \( \w_{1}^{i} \) and \( \w_{2}^{j} \) such that \( \clps{\w_{1}^{i}}\projection{1} = \clps{\w_{2}^{j}}\projection{1} \) and \( (\w_{1}^{i}\projection{1} \composeC \w_{2}^{j}\projection{1})\isdef \).
There are two possibilities for the first thread: (a) it commits a transaction; or (b) it take a rely step which updates the history heap and shared capabilities.
If the first thread commits a transaction, which means the last step of the new trace \( \tau_{1}' = \tau_{1} \cup \Set{(\w_{1}^{i}, \w_{1}^{i+1})} \) it is allowed by the guarantee \( (\w_{1}^{i}, \w_{1}^{i+1}) \in \Guar \).
By the \lemref{lem:locality-update}, there exists \( \w_{2}^{j+1} \) satisfying the conditions, therefore we can construct the new trace for the second thread as \( \tau_{2}' = \tau_{2} \cup \Set{(\w_{2}^{j},\w_{2}^{j+1})} \).
If the first thread take a rely step, \ie \( \tau_{1}' = \tau_{1} \cup \Set{(\w_{1}^{i}, \w_{1}^{i+1})} \) such that \( (\w_{1}^{i}, \w_{1}^{i+1}) \in \Rely \), there are two possibilities, this transfer is triggered by a capability is either included in the second thread or not.
\end{proof}

\begin{lem}[Locality of update]
When a thread commits a transaction that is allowed by guarantee, the effect to the history heap is included in the rely of other threads.
\label{lem:locality-update}
\[
\begin{array}{@{}l}
    \fora{\w, \w', \w''} (\w\projection{1} \composeC \w'\projection{1})\isdef \land \clpsW{\w}\projection{1} = \clpsW{\w'}\projection{1} \land (\w, \w'') \in \Guar  \\
    \quad \implies \exsts{\w'''} (\w', \w''') \in \Rely \land (\w''\projection{1} \composeC \w'''\projection{1})\isdef \land \clpsW{\w''}\projection{1} = \clps{\w'''}\projection{1}
\end{array} 
\]
\end{lem}
\begin{proof}
Assume two worlds \( \w \) and \( \w' \) such that the composition of the local capabilities is defined \((\w\projection{1} \composeC \w'\projection{1})\isdef\) and the global history heap states are the same, \ie \( \clpsW{\w}\projection{1} = \clpsW{\w'}\projection{1} \).
If the first world can transfer to a new world \( \w'' \) allowed by guarantee \( (\w, \w'' ) \in \Guar \), by the \defref{def:rely-guarantee}, we know that for any region \( \rid \) that has been updated, there exists a \( \kap \) such that \( \kap \sqsubseteq \ca(\rid) \) which gives the permission.
Formally, let \( (\gs, \ca) = \w \) and \( (\gs', \ca') = \w' \), 
\[
\begin{array}{@{}l}
    \fora{\rid} 
    \gs(\rid) = \gs'(\rid) \lor {} \\
    \quad \gs(\rid) \neq \gs'(\rid) 
    \land \exsts{\hh, \hh', \vi, \vi', \ca'', \ca''', \intf, \kap} \\
    \qquad \gs(\rid) = (\hh, \vi, \ca'', \intf) 
    \land \gs'(\rid) = (\hh', \vi', \ca''', \intf)
    \land \kap \sqsubseteq \ca(\rid) \\
    \qquad {} \land ((\hh, \vi, \ca''), (\hh', \vi', \ca''')) \in \intf(\kap)
\end{array} 
\]
We can construct a world \( \w''' = (\ca''', \gs''') \) that satisfies the rely \( (\w', \w''') \in \Rely \).
First, we take the same local capabilities as the \( \w' \).
This is,
\[
    \ca''' = \w'\projection{1}
\]
Then we propagate history heaps and shared capabilities from \( \w'' \) to \( \w''' \) but keep the views as the same in the \( \w' \),
\[
    \fora{\rid} \exsts{\hh,\vi,\ca,\intf} \gs'''(\rid) = (\hh, \vi, \ca, \intf) \land \w''\projection{2}(\rid) = (\hh, \stub, \ca, \intf) \land \w'\projection{2}(\rid) = (\stub, \vi, \stub, \intf)
\]
Combining the two formulae with the local capabilities are compatible \( ( \ca \composeC \ca' )\isdef \), It is easy to see \( ( \w', \w''' ) \in \relyU \) by \defref{def:rely-guarantee}, therefore \( ( \w', \w''' ) \in \Rely \).
Given the way we construct \( \w''' \), it directly proves \( \clps{\w''}\projection{1} = \clps{\w'''}\projection{1} \).
Because the guarantee require the orthogonal of capabilities remains the same so alter the update, the local capabilities are still compatible.
\end{proof}

