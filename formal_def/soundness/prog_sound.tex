\subsection{Program Soundness}
\begin{thm}[Program soundness]
The program soundness is the follows,
\[
    \for{\gpre, \prog, \gpost}
    \tripleG{\gpre}{\prog}{\gpost} 
    \implies 
    \tripleSemG{\gpre}{\prog}{\gpost} 
\]
\end{thm}
\begin{proof}
Induction on the derivations.
\caseB{\rl{PRCommit}}
We have \( \prog \equiv \ptrans{\trans} \).
Because a transaction \( \ptrans{\trans} \) is reduced by one step in the semantics, it is sufficient to prove the follows,
\[
\begin{array}{l}
    \begin{B}
        \stable{\gpre} 
        \land \gpre \snap \bar{\lpre}
        \land \tripleL{\bar{\lpre} \sep \fpEMP}{\trans}{\lpost \sep \fpF}
        \land \rpt{\gpre}{\gpost}{\fp} 
        \land \stable{\gpost}
    \end{B} \\
    \implies 
    \for{\w, \w', \w'', \w''', \hh', \hh'', \cu', \cu'', \thcu', \thcu'', \thid, \lenv, \thstk, \thstk''} \\
    \quad \begin{B}
        \w \in \evalW[\lenv, \thstk]{\gpre} 
        \land (\w, \w') \in \Rely^{*} 
        \land (\hh', \cu') \in \clpsW{\w'}
        \land \thcu'(\thid) = \cu' \\
        {} \land \thid, \func{como}{\w'} \vdash (\thstk, \hh', \thcu'), \ptrans{\trans} 
        \toT{\lbC{\txid}} (\thstk'', \hh'', \thcu''), \pskip  \\
        {} \land \thcu''(\thid) = \cu''
        \land (\hh'', \cu'') \in \clpsW{\w''} 
        \land (\w'', \w''') \in \Rely^{*} 
    \end{B} \\
    \quad \implies  \w''' \in \evalW[\lenv, \thstk'']{\gpost} 
\end{array}
\]
\textbf{Stable pre-condition.} 
Given that \( \stable{\gpre} \), for any world \( \w \) satisfies the pre-condition \( \gpre \) if the world can transfer to another world \( \w' \) through any steps of rely, the new world \( \w' \) also satisfies the pre-condition.
This is, 
\begin{equation}
    \label{equ:stable-pre-condition}
    \for{\w, \w',\lenv, \thstk} 
    \stable{\gpre} 
    \land \w \in \evalW[\lenv, \thstk]{\gpre} 
    \land (\w, \w') \in \Rely^{*}
    \implies \w' \in \evalW[\lenv, \thstk]{\gpre}
\end{equation}
\textbf{Commit.}
Given the \equref{equ:stable-pre-condition}, we want to prove the follows,
\begin{equation}
\label{equ:commit-new-transaction}
    \begin{array}{@{}l}
    \begin{B}
        \gpre \snap \bar{\lpre}
        \land \tripleL{\bar{\lpre} \sep \fpEMP}{\trans}{\lpost \sep \fpF}
        \land \rpt{\gpre}{\gpost}{\fp} 
    \end{B} \\
    \implies 
    \for{\w, \w', \hh, \hh', \cu, \cu', \thcu, \thcu', \thid, \lenv, \thstk, \thstk'} \\
    \quad \begin{B}
        \w \in \evalW[\lenv, \thstk]{\gpre}
        \land (\hh, \cu) \in \clpsW{\w}
        \land \thcu(\thid) = \cu \\
        {} \land \thid, \func{como}{\w} \vdash (\thstk, \hh, \thcu), \ptrans{\trans} 
        \toT{\lbC{\txid}} (\thstk', \hh', \thcu'), \pskip  \\
        {} \land \thcu'(\thid) = \cu'
        \land (\hh', \cu') \in \clpsW{\w'} 
    \end{B} \\
    \quad \implies  \w' \in \evalW[\lenv, \thstk']{\gpost} 
    \end{array}
\end{equation}
For any \( \w, \hh, \cu, \lenv, \thstk \) such that \( \w \in \evalW[\lenv,\thstk]{\gpre} \) and \( (\hh, \cu) \in \clpsW{\w} \), by the predicate \( \gpre \snap \bar{\lpre} \) we know \( \clpsHH{\hh, \cu} \in \evalLS[\lenv,\thstk]{\bar{\lpre}} \), so that,
\begin{equation}
\label{equ:local-pre-condition}
(\clpsHH{\hh, \cu}, \unitO) \in \evalLS[\lenv,\thstk]{\bar{\lpre} \sep \fpEMP}
\end{equation}
Because of the soundness of transaction (\thmref{thm:transaction-soundness}), given a thread stack \( \thstk \) and a logical environment \( \lenv \), if a initial configuration \( (\txstk, \h, \unitO), \trans \) satisfies the pre-condition, \ie \( (\h, \unitO) \in \evalLS[\lenv,\thstk \uplus \txstk]{\bar{\lpre} \sep \fpEMP} \), and a final configuration \( (\txstk', \h', \opset), \pskip \) is semantics reachable from the initial configuration, this final configuration will satisfy the post-condition \( \lpost \sep \fpF \).
This is, for any \( \thstk, \txstk, \txstk', \h, \h', \opset \), they satisfy the follows,
\begin{equation}
\label{equ:local-transaction-sound}
\begin{array}{@{}l}
    (\h, \unitO) \in \evalLS[\lenv,\thstk \uplus \txstk]{\bar{\lpre} \sep \fpEMP}
    \land \thstk \vdash (\txstk, \h, \unitO), \trans \toL (\txstk', \h', \opset), \pskip
    \implies (\h, \opset) \in \evalLS[\lenv,\thstk \uplus \txstk']{\bar{\lpost} \sep \fpF}
\end{array}
\end{equation}
The repartition \( \rpt{\gpre}{\gpost}{\fp} \) requires that any machine state \( \hh' \) by committing the operations \( \opset = \evalF{\fp}\) to an initial state \( \hh \) that satisfies the precondition \( \gpre \), should satisfy the \( \gpost \).
Formally, for any \( \w, \w', \hh, \hh', \cu, \cu', \lenv, \stk, \txid \), we have,
\begin{equation}
\label{equ:repartition}
\begin{array}{@{}l}
    \begin{B}
        \w \in \evalW{\gpre}
        \land (\hh, \cu) \in \eraseW{\w}
        \land \txid \in \func{fresh}{\hh} 
        \land \hh' = \func{commit}{\hh, \cu, \txid, \evalF{\fp}}  \\
        \quad {} \land \cu' = \func{update}{\hh, \cu, \evalF{\fp}}
        \land (\hh',\cu') \in \eraseW{\w'}
        \land (\w, \w') \in \Guar 
    \end{B}
    \implies \w' \in \evalW{\gpost}
\end{array}
\end{equation}
First, if we combine \equref{equ:local-pre-condition}, \equref{equ:local-transaction-sound} and \equref{equ:repartition}, we know that for any world that satisfies \( \gpre \), there exists operations corresponding to the transaction code \( \trans \), and the new world is the result of committing the operations to the old world.
\[
\begin{array}{@{}l}
    \begin{B}
        \exsts{\h, \h', \txstk', \opset}
        \w \in \evalW{\gpre}
        \land (\hh, \cu) \in \eraseW{\w}
        \land \txid \in \func{fresh}{\hh} 
        \land \h = \clpsHH{\hh, \cu}  \\
        \quad {} \land \thstk \vdash (\txstk, \h, \unitO), \trans \toL (\txstk', \h', \opset), \pskip   
        \land \hh' = \func{commit}{\hh, \cu, \txid, \opset}  \\
        \quad {} \land \cu' = \func{update}{\hh, \cu, \opset}
        \land (\hh',\cu') \in \eraseW{\w'}
        \land (\w, \w') \in \Guar 
    \end{B}
    \implies \w' \in \evalW{\gpost}
\end{array}
\]
Second, the guarantee \( \Guar \) ensures regions that have been updated must not violate their invariants,
\[
\begin{array}{@{}l}
\for{\w,\w'} (\w,\w') \in \Guar  \\
\implies 
\for{\rid, \intf, \hh, \hh', \cu, \cu', \opset} \w(\rid) = \w'(\rid) \lor {} \\
\quad \w(\rid) = (\hh, \cu, \intf)
\land \w'(\rid) = (\hh', \cu', \intf)
\land (\hh, \cu) \toLTS{\opset} (\hh', \cu') \in \func{inv}{\rid, \intf}
\end{array}
\]
The transition must satisfy the consistency model by the definition of transition relation, and all the read operations must compatible with the cut \( \cu \),
\[
\begin{array}{@{}l}
    \exsts{ \thcu, \thcu', \txid, \thid, \opset }
    \txid \in \func{fresh}{\hh} 
    \land \hh' = \func{commit}{\hh, \cu, \txid, \opset} \\
    \quad {} \land ((\hh,\thcu),(\hh',\thcu')) \in \como
    \land \h = \clpsHH{\hh,\cu} 
    \land \thcu(\thid) = \cu 
    \land \thcu'(\thid) = \cu' \\
    \quad {} \land \for{\addr,\val} (\otR, \addr, \val)  \in \opset \implies \h(\addr) = \val
\end{array}
\]
Therefore, for any world transition that satisfies the guarantee, it also satisfies the consistency model,
\begin{equation}
\label{equ:transition-sat-consitency-model}
\begin{array}{@{}l}
    \for{\w, \w'} (\w, \w') \in \Guar \\
    \implies 
    \for{ \cu, \cu'}
    \exsts{ \thcu, \thcu', \txid, \thid, \opset }
    (\hh, \cu) \in \clpsW{\w}
    \land (\hh', \cu') \in \clpsW{\w'} \\
    \quad {} \land \txid \in \func{fresh}{\hh} 
    \land \hh' = \func{commit}{\hh, \cu, \txid, \opset} \\
    \quad {} \land ((\hh,\thcu),(\hh',\thcu')) \in \func{como}{\w}
    \land \h = \clpsHH{\hh,\cu} 
    \land \thcu(\thid) = \cu 
    \land \thcu'(\thid) = \cu' \\
\end{array}
\end{equation}
We apply the \equref{equ:transition-sat-consitency-model} to the \equref{equ:local-pre-condition}, \equref{equ:local-transaction-sound} and \equref{equ:repartition} and pick the empty transaction stack as the initial \( \txstk = \txstk_{0} = \emptyset \) transaction stack for transaction code \( \trans \), then we have the follows,
\[
\begin{array}{@{}l}
    \begin{B}
        \exsts{\h, \h', \txstk_{0}, \txstk', \thcu, \thcu', \txid, \thid, \opset } \\
        \quad \w \in \evalW{\gpre} 
        \land (\hh, \cu) \in \eraseW{\w}
        \land \txid \in \func{fresh}{\hh} 
        \land \h = \clpsHH{\hh, \cu}
        \land \txstk_{0} = \emptyset \\
        \quad {} \land \thstk \vdash (\txstk, \h, \unitO), \trans \toL (\txstk', \h', \opset), \pskip 
        \land \hh' = \func{commit}{\hh, \cu, \txid, \opset} \\
        \quad {} \land \cu' = \func{update}{\hh, \cu, \opset} 
        \land (\hh',\cu') \in \eraseW{\w'}  \\
        \quad {} \land ((\hh,\thcu),(\hh',\thcu')) \in \func{como}{\w}
        \land \thcu(\thid) = \cu 
        \land \thcu'(\thid) = \cu' \\
    \end{B}
    \implies \w' \in \evalW{\gpost}
\end{array}
\]
In the equation above, we have all the side conditions of the semantics for reducing a single transaction \( \ptrans{\trans}\), by folding these side conditions we have the proof for the \equref{equ:commit-new-transaction}.
\sx{Need to think twice}
\textbf{Stable post-condition.} 
It can be proven for the similar reason as the proof for stable pre-condition.
\end{proof}
