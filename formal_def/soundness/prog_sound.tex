\subsection{Program Soundness}


\begin{defn}[Rely-Guarantee Operational Semantics]
\label{def:rg-semantics}
Assume rely and guarantee under the time-stamp heap level, \ie \( \Rely, \Guar \in (\TSHeaps \times \Timestamp) \times (\TSHeaps \times \Timestamp)\).
The rely-guarantee operational semantics are show in \figref{fig:rg_semantics}, which are extended from the semantics in \figref{fig:thread_semantics}.

\begin{figure}[!t]
\hrule\vspace{5pt}
\[
    \infer[\rl{RGIncTime}]{%
        \Rely, \Guar, (\stk, \tsh, \ts), \iprog \ \toRG{\lbRELY} \ \Rely, \Guar, (\stk, \tsh, \ts'), \iprog
    }{%
        \ts' > \ts
    }
\]

\[
    \infer[\rl{RGEnv}]{%
        \Rely, \Guar, (\stk, \tsh, \ts), \iprog \ \toRG{\lbRELY} \ \Rely, \Guar, (\stk, \tsh', \ts), \iprog
    }{%
        (\tsh, \tsh') \in \Rely
    }
\]

\[
    \infer[\rl{RGCommit}]{%
        \Rely, \Guar, (\stk, \tsh, \ts), \ptrans{\trans} \ \toRG{\lbC{\tsid}} \ \Rely, \Guar, (\stk', \tsh', \ts'), \pskip
    }{%
        (\tsh, \tsh') \in \Guar
        && (\stk, \tsh, \ts), \ptrans{\trans} \ \toT{\lbC{\tsid}} \ (\stk', \tsh', \ts'), \pskip
    }
\]

\[
    \infer[\rl{RGLift}]{%
        \Rely, \Guar, (\stk, \tsh, \ts), \iprog \ \toRG{\lb} \ \Rely, \Guar, (\stk', \tsh', \ts'), {\iprog}'
    }{%
        \iprog \not\equiv \pwait{\stub}
        && \iprog \not\equiv \prog \ppar \prog
        && (\stk, \tsh, \ts), \iprog \ \toT{\lb} \ (\stk', \tsh', \ts'), {\iprog}'
    }
\]

\[
    \infer[\rl{RGFork}]{%
        \Rely, \Guar \cup \Guar', (\stk, \tsh, \ts), \prog_{1} \ppar \prog_{2}  \ \toRG{\lbF{\thid,\prog_{2}, \Rely \cup \Guar, \Guar'}} \ \Rely \cup \Guar', \Guar, (\stk', \tsh', \ts'), \prog_{1} \pseq \pwait{\thid}
    }{%
        (\stk, \tsh, \ts), \prog_{1} \ppar \prog_{2}  \ \toT{\lbF{\thid,\prog_{2}}} \ (\stk', \tsh', \ts'), \prog_{1} \pseq \pwait{\thid}
    }
\]

\[
    \infer[\rl{RGJoin}]{%
        \Rely \cup \Guar', \Guar, (\stk, \tsh, \ts), \pwait{\thid}  \ \toRG{\lbJ{\thid,\ts, \Rely \cup \Guar, \Guar'}} \ \Rely, \Guar \cup \Guar', (\stk', \tsh', \ts'), \pskip
    }{%
        (\stk, \tsh, \ts), \pwait{\thid}  \ \toT{\lbJ{\thid,\ts}} \  (\stk', \tsh', \ts'), \pskip
    }
\]

\hrule\vspace{5pt}

\[
    \infer[\rl{RGPSingle}]{%
        ( \tshp, \thpl \uplus \Set{ \thid \mapsto (\Rely, \Guar, \stk, \ts, \iprog) } ) \ \toGG{\lb} \  ( \tshp', \thpl \uplus \Set{ \thid \mapsto (\Rely', \Guar', \stk', \ts', {\iprog}') } ) 
    }{%
        \begin{array}{c}
        \Rely, \Guar, ( \stk, \tshp, \ts ) , \iprog \ \toRG{\lb} \  \Rely', \Guar', ( \stk', \tshp', \ts' ) , {\iprog}' 
        \quad \lb \in \Set{ \lbID, \lbC{\stub} } \\
        \begin{array}{l}
        \mathtt{for} \ \thid'' \in \dom(\thpl) \\
        \quad \begin{formulea}
            \thpl(\thid'') = (\Rely'', \Guar'', \stk'', \ts'', {\iprog}'')  \\
            \Rely'', \Guar'', ( \stk'', \tshp, \ts'' ) , \iprog \ \toRG{\lbRELY} \  \Rely'', \Guar'', ( \stk'', \tshp', \ts'' ) , {\iprog}'' \\
        \end{formulea}
        \end{array}
        \end{array}
    }
\]


\[
    \infer[\rl{RGPFork}]{%
        ( \tshp, \thpl \uplus \Set{ \thid \mapsto (\Rely, \Guar, \stk, \ts, \iprog) } ) \ \toGG{\lbF{\thid', \prog'', \Rely'', \Guar''}} \  ( \tshp', \thpl \uplus \Set{ \thid \mapsto (\Rely', \Guar', \stk', \ts', {\iprog}'), \thid' \mapsto (\Rely'', \Guar'', \lambda \var \ldotp 0, \ts', \prog'') } )
    }{%
        \Rely, \Guar, ( \stk, \tshp, \ts ) , \iprog \ \toRG{\lbF{\thid', \prog'', \Rely'', \Guar''}} \  \Rely', \Guar', ( \stk', \tshp', \ts' ) , {\iprog}' 
    }
\]

\[
    \infer[\rl{RGPJoin}]{%
        ( \tshp, \thpl \uplus \Set{ \thid \mapsto (\Rely, \Guar, \stk, \ts, \iprog), \thid' \mapsto (\Rely'', \Guar'', \stk', \ts'', \pskip) } )  \ \toGG{\lbJ{\thid',\ts'', \Rely'', \Guar''}} \ ( \tshp', \thpl \uplus \Set{ \thid \mapsto (\Rely', \Guar', \stk', \ts', {\iprog}')} )
    }{%
        \Rely, \Guar, ( \stk, \tshp, \ts ) , \iprog \ \toRG{\lbJ{\thid',\ts'', \Rely'', \Guar''}} \  \Rely', \Guar', ( \stk', \tshp', \ts' ) , {\iprog}' 
    }
\]

\hrule\vspace{5pt}
\caption{Extended Semantics}
\label{fig:rg_semantics}
\end{figure}
\end{defn}

\begin{defn}[Flatten to time-stamp heaps]
\label{def:x2tsh}
\label{def:flatten-to-tsh}
Given the set of  \( \h \in \Heaps\), \( \tsh \in \TSHeaps \), world \( \world \in \World \) and fingerprint world \( \fpw \in \FPWorlds \), the overloaded function \( \funcn{x2tsh} : \Set{ \Heaps, \FPHeaps, \World, \FPWorlds,} \to \powerset{\TSHeaps} \) is defined as follows,
\[
    \begin{rclarray}
        \func{x2tsh}{\h} & \defeq & 
        \Setcon{%
            (\tsh,\ts) 
        }{%
            \for{ \addr } 
            \snapshot{\tsh}{\ts}(\addr) = (\val, \stub) 
            \land \h(\addr) = \val 
        } \\
        \func{x2tsh}{\fph} & \defeq & \func{x2tsh}{\eraseFPH{\fph}} \\
        \func{x2tsh}{\world} & \defeq & \func{x2tsh}{\world\projection{2}} \\
        \func{x2tsh}{\fpw} & \defeq & \func{x2tsh}{\eraseFW{\fpw}} \\
    \end{rclarray}
\]
where the \( \snapshotName \) function (\fig \ref{fig:thread_semantics}) returns a fingerprint heap corresponding the state at time \( \ts \), and here we match first projection.
Similarly the \( \funcn{xx2tsh} : \FPWorlds \times \FPWorlds \parfun \pset{(\TSHeaps \times \Timestamp) \times (\TSHeaps \times \Timestamp )} \) function converts rely and guarantee into time-stamp heaps and time-stamps.
\[
\begin{rclarray}
    \func{xx2tsh}{(\ca_{p}, \fph_{p}), (\ca_{q},\fph_{q})} & \defeq & 
    \Setcon{%
        (\tsh_{p}, \tsh_{q})
    }{%
        \exsts{\ts_{p}, \ts_{q}}
        \cancommit{\tsh_{p}}{\tsh_{q}}{\ts_{p}}{\ts_{q}} \\
        \quad {} \land \pred{fresh}{\tsh_{p}, \tsid} 
        \land \tsh_{q} = \commit{\tsh_{p}}{\fph_{p}}{\fph_{q}}{\tsid}{\ts_{p}}{\ts_{q}}
    }
\end{rclarray}
\]

Assume the standard lift to a set of pairs of fingerprint worlds.
The flatten of assertion \( \Ast \) (\defref{def:assertion}), \( \flattenevalW[.,.,.]{.} : \FPWorlds \times \LEnv \times \Stack \times \Interference \parfun \pset{(\TSHeaps \times \Timestamp) \times (\TSHeaps \times \Timestamp) \times \TSHeaps \times \Timestamp}\)
\[
\begin{rclarray}
    \flattenevalW{\fpw} & \defeq & \Setcon{%
        (\Rely, \Guar, \tsh, \ts)
    }{%
        \land (\tsh, \ts) \in \func{x2tsh}{\fpw}  \\
        \quad {} \land \Rely = \func{xx2tsh}{\rely(\intf)}
        \land \Guar = \func{xx2tsh}{\guar(\intf)}
    }
\end{rclarray}
\]

\end{defn}

\begin{lem}[Write win]
\label{lem:write-win-merge}
During the merging, the write always wins.
This means,
\[
\begin{array}{@{}l@{}}
    \for{\fph_{p}, \fph_{l}, \fph_{q}, \intf, \addr, \fp, \val} \\
    \quad (\stub, \fph_{q}) \in \mergeR{(\stub, \fph_{p})}{(\stub, \fph_{l})}{\intf}
    \land \fph_{l}(\addr) = (\val, \fp) 
    \land \fpW \in \fp
    \implies \fph_{q}(\addr) = (\val, \fp)
\end{array}
\]
\end{lem}
\begin{proof}
Given the definition of \( \mergeName[\rely] \) function (\defref{def:repartitioning}), there exists \(  \fph_{r} \) such that,
\[
    (\stub, \fph_{r}) \in \RelyI((\stub, \fph_{p})) \land (\stub, \fph_{q}) = \mergeFPW{(\stub,\fph_{l})}{(\stub,\fph_{r})}
\]
therefore, 
\[
    \fph_{q} = \mergeFPH{\fph_{l}}{\fph_{r}}
\]
Given the definition \( \mergeName[\halfMath{\fph}] \) (\defref{def:merge-finger-heap}), for \( \addr_{l} \in \dom(\fph_{l}) \setminus \dom(\fph_{r})  \), we have 
\[
\fph_{q}(\addr_{l}) = \fph_{l}(\addr_{l})
\]
For addresses \( \addr_{lr} \in \dom(\fph_{l}) \cap \dom(\fph_{r})\), we have 
\[
\fph_{q}(\addr_{lr}) = \mergeVAL{\fph_{l}(\addr_{lr})}{\fph_{l}(\addr_{lr})}
\]
By the definition \( \mergeName[\halfMath{\mathtt{V}}] \) (\defref{def:merge-finger-heap}), we have,
\[
    \for{\fp, \val} \fph_{l}(\addr_{lr}) = (\val, \fp) 
    \land \fpW \in \fp
    \implies \fph_{q}(\addr_{lr}) = (\val, \fp)
\]
Combine two cases, we have the proof, \ie
\[
    \for{ \addr,\fp, \val}
     \fph_{l}(\addr) = (\val, \fp) 
    \land \fpW \in \fp
    \implies \fph_{q}(\addr) = (\val, \fp)
\]
\end{proof}


\begin{lem}[Merge to the current]
\label{lem:merge-current-sound}
Given the flatten functions (\defref{def:flatten-to-tsh}), the \emph{merge to the current} is as the follows,
\[
\begin{array}{@{}l@{}}
    \for{\trans, \tsid, \tsh_{p}, \tsh_{q}, \fpw_{p}, \fpw_{q}, \ts_{p}, \ts_{q}, \stk_{p}, \stk_{q}, \lenv, \intf}  \\
    (\Rely, \Guar, \tsh_{p}, \ts_{p}) \in \flattenevalW[\lenv, \stk_{p}, \intf]{\fpw_{p}}
    \land (\fpw_{p}, \fpw_{i} ) \in \GuarI
    \land (\tsh_{p}, \tsh_{q}) \in \func{xx2tsh}{\fpw_{p}, \fpw_{i}} \\
    {} \land \Rely, \Guar, (\stk_{p}, \tsh_{p}, \ts_{p}), \ptrans{\trans} \toRG{\lbC{\tsid}} \Rely, \Guar, (\stk_{q}, \tsh_{q}, \ts_{q}), \pskip  \\
    \quad \implies \exsts{\fpw_{q} \in \mergeR{\fpw_{p}}{\fpw_{i}}{\intf}}
    (\Rely, \Guar, \tsh_{q}, \ts_{q}) \in \flattenevalW[\lenv, \stk_{q}, \intf]{\fpw_{q}}
\end{array}
\]
Given a fingerprint world  and one of its corresponding machine state \( (\Rely, \Guar, \tsh_{p}, \ts_{p}) \in \flattenevalW[\lenv, \stk_{p}, \intf]{\fpw_{p}} \) and for any transition that is allowed by the guarantee \( (\tsh_{p}, \tsh_{q}) \in \Guar \), it must exist a merged fingerprint world \( \fpw_{q} \) such that the machine state after the transition match with the fingerprint world, \ie \((\Rely, \Guar, \tsh_{q}, \ts_{q}) \in \flattenevalW[\lenv, \stk_{q}, \intf]{\fpw_{q}}\).
\end{lem}
\begin{proof}
Given the Guarantee \( \GuarI \) (\defref{def:rely-guarantee}), assume \( \fph_{p}, \fph_{i} \) such that, 
\begin{equation}
\label{def:definition-ph-p-and-i}
\begin{array}{@{}l@{}}
    \exsts{ \ca_{p}, \ca_{i}, \kap, \fpw_{f} }  \\
    \quad \fpw_{p} = (\kap \composeC \ca_{p},\fph_{p} \composeFPH \fph_{f}) 
    \land \fpw_{i} = (\ca_{i},\fph_{i} \composeFPH \fph_{f}) 
    \land \pred{no\_fingerprint}{\fph_{p}} 
    \land ( \fph_{p}, \fph_{i} ) \in \intf(\kap)
\end{array}
\end{equation}
Given that \( (\tsh_{p}, \tsh_{q}) \in \func{xx2tsh}{\fpw_{p}, \fpw_{i}} \), and the fact that it can transfer semantically, we have, 
\begin{equation}
\label{equ:property-of-fph-i-tsh-pq}
\begin{array}{@{}l@{}}
\exsts{\tsid} \for{ \addr, \fp, \val } \fph_{i}(\addr) = (\val, \fp) \\
\quad {} \land (\fpW \in \fp \implies \tsh_{q}(\addr)(\ts_{q}) = (\val, \etW, \tsid))  \\
\quad {} \land (\Set{\fpR} = \fp \implies \tsh_{q}(\addr)(\ts_{p}) = (\val, \etR, \tsid) \land \tsh_{q}(\addr_{w})(\ts_{q}) = (\val_{w}, \etE, \tsid))

\end{array}
\end{equation}
Given the flatten (\defref{def:flatten-to-tsh}), we need to prove there exists a \( \fph_{q} \) such that,
\[
    ( \stub, \fph_{q}) \in \mergeR{\fpw_{p}}{\fpw_{i}}{\intf}
    \land \for{\addr, \val} \snapshot{\tsh_{q}}{\ts_{q}}(\addr) = (\val, \stub) 
    \land \eraseFPH{\fph_{q} }(\addr)  = \val
\]
Let discuss the addresses being written \( \addr_{w} \) and those only being read \( \addr_{r} \) separately.
For addresses \( \addr_{w} \) being written, assume the value is \( \val_{w} \).
By \equref{equ:property-of-fph-i-tsh-pq}, this means,
\begin{equation}
\label{equ:global-write}
\for{ \fp }
\fpW \in \fp
\land \fph_{i}(\addr_{w}) = (\val_{w}, \fp)
\land \tsh_{q}(\addr_{w})(\ts_{q}) = (\val_{w}, \etW, \tsid)
\end{equation}
Given  the \( \snapshotName \) function, we have, 
\begin{equation}
\label{equ:snap-write}
\snapshot{\tsh_{q}}{\ts_{q}}(\addr_{w}) = (\val_{w}, \stub)
\end{equation}
Meanwhile, by the \equref{equ:property-of-fph-i-tsh-pq} and the \lemref{lem:write-win-merge}, we have,
\begin{equation}
\label{equ:local-write}
    \for{ \fp }
    \fpW \in \fp
    \land \fph_{i}(\addr_{w}) = \fph_{q}(\addr_{w}) = (\fp, \val_{w})
    \land \eraseFPH{\fph_{q}}(\addr_{w}) = \val_{w}
\end{equation}
The \equref{equ:snap-write} and \equref{equ:local-write} shows that for all the addresses been written, the values match.

Now let consider addresses \( \addr_{r} \) only being read with the value \( \val_{r} \).
By \equref{equ:property-of-fph-i-tsh-pq}, this means,
\begin{equation}
\label{equ:global-read}
\fph_{i}(\addr_{r}) = ( \val_{r}, \Set{\fpR})
\land \tsh_{q}(\addr_{r})(\ts_{p}) = (\val_{r}, \etR, \tsid)
\land \tsh_{q}(\addr_{r})(\ts_{q}) = (\val_{r}, \etE, \tsid)
\end{equation}
However, note that,
\[
\neg\left(
    \begin{array}{@{}l@{}}
        \tsh_{q}(\addr_{r})(\ts_{p}) = (\val_{r}, \etR, \tsid )
        \land \tsh_{q}(\addr_{r})(\ts_{q}) = (\val_{r}, \etE , \tsid) \\
        \quad \implies \snapshot{\tsh_{q}}{\ts_{q}}(\addr_{r}) = (\val_{r}, \stub)
    \end{array}
\right)
\]
Because there might be other transactions that commit between times \( \ts_{p} \) and \( \ts_{q} \) and write to some addresses \( \addr_{r} \), while the current transaction \( \tsid \) is still allowed to commit, meaning not violating \( \consistentName \) predicate from the semantics (\figref{fig:rg_semantics}).
Yet in the semantics, each time a thread committing a transaction, it also check with other treads' rely using the \( \rl{RGEnv} \) rule.
Let assume an initial time-stamp heap \( \tsh_{0} \), such that,
\[
    \for{ \ts, \addr } \ts_{p} < \ts < \ts_{q} \land \tsh_{0} (\addr)(\ts)\undef
\]
\sx{Fork-Join? fork will adding more rely and join will push up the time to rule out those deleted rely}
and assume a series of time-stamp heap \( \tsh_{0} \dots \tsh_{\nat}\), such that,
\[
    \tsh_{n} = \tsh_{p} \land \Rely, \Guar, (\stub, \tsh_{0}, \stub), \ptrans{\trans} \toRG{\lbRELY} \Rely, \Guar, (\stub, \tsh_{1}, \stub), \ptrans{\trans} \toRG{\lbRELY} \dots \toRG{\lbRELY} \Rely, \Guar, (\stub, \tsh_{\nat}, \stub), \ptrans{\trans}
\]
We also assume each of the steps modifies the address \( \addr_{r} \) at a time between \( \ts_{p} \) and \( \ts_{q} \).
Because if it modifies at a time before \( \ts_{p} \) it covers by our hypothesis.
If it modifies at a time after \( \ts_{q} \), it does not affect the snapshot taken at time \( \ts_{q} \).
We first prove there exist \( \fpw_{p}', \fpw_{q}'\) such that,
\[
    (\tsh_{0}, \ts_{p}) \in \func{x2tsh}{\fpw_{p}'} 
    \implies (\fpw_{p}', \fpw_{q}') \in \RelyI 
    \land (\tsh_{\nat}, \ts_{q}) \in \func{x2tsh}{\fpw_{q}'}
\]




Given the \rl{RGEnv} rule, we have,
\[
    \bigwedge\limits_{ 1 \leq i \leq \nat}( \tsh_{ i - 1}, \tsh_{i}) \in \Rely
\]
\end{proof}

\begin{lem}[Merge with the future]
\label{lem:merge-sound}
\[
\begin{array}{@{}l@{}}
\end{array}
\]
\end{lem}


\begin{lem}[Stabilisation soundness]
\label{lem:stable-sound}

The stabilisation intuitively covers the transactions that happen sequentially in the future.
\[
\begin{array}{@{}l@{}}
    \for{\lenv, \stk, \gpre, \iprog, \intf, \Rely, \tsh_{p}, \tsh_{q}, \Guar, \ts_{q}, \ts_{p}}  \\
    \quad (\Rely, \Guar, \tsh_{p}, \ts_{p}) \in \flattenevalW{\gpre}
    \land \stable{\gpre}{\intf} 
    \land \Rely, \Guar, (\tsh_{p}, \stk, \ts_{p}), \iprog \toRG{\lbRELY} \Rely, \Guar, (\tsh_{q}, \stk, \ts_{q}), \iprog \\
    \qquad \implies \for{\addr, \ts}
    \ts \leq \ts_{p} \land \tsh_{p}(\addr)(\ts) = \tsh_{q}(\addr)(\ts) \\
    \qquad \implies  (\Rely, \Guar, \tsh_{q}, \ts_{q}) \in \flattenevalW{\gpre} 
\end{array}
\]
Note that before the time \( \ts_{p} \), all the records inside the \( \tsh_{q} \) must remains the same as those in \( \tsh_{p} \).
\end{lem}
\begin{proof}
Assume a fingerprint word \( \fpw_{p} \) that \( \eraseFW{\fpw_{p}} \in \evalW{\gpre} \) and \( \func{no\_fingerprint}{\fpw_{p}}\).
Because \( (\Rely, \Guar, \tsh_{p}, \ts_{p}) \in  \flattenevalW{\gpre} \), we have \( \Rely = \func{xx2tsh}{\RelyI\projection{\fpw_{p}}} \) and \( (\tsh_{p}, \ts_{p}) \in \func{x2tsh}{\fpw_{p}}\).
Given the semantics (\figref{fig:rg_semantics}) we have \( ((\tsh_{p}, \ts_{p}),(\tsh_{q}, \ts_{q})) \in \Rely \) and then by the \( \funcn{xx2tsh} \) function (\defref{def:x2tsh}) there must exists \( \fpw_{q}\) such that \( ( \fpw_{p}, \fpw_{q} ) \in \RelyI \).
Then because of \( \stable{\gpre}{\intf} \) (\defref{def:rely-guarantee}), we know \( \eraseFW{\fpw_{q}} \in \evalW{\gpre}\), so \( (\Rely, \Guar, \tsh_{q}, \ts_{q}) \in \flattenevalW{\gpre} \).
\end{proof}

\begin{defn}[Semantic triple]
\label{def:semantic-triple}
    The semantic triple \( \tripleSemG{\gpre}{\prog}{\gpost}\) is defined as the follows,
    \[
        \begin{rclarray}
            \tripleSemG{\gpre}{\prog}{\gpost} & \defeq &
            \begin{array}[t]{@{}l@{}}
                \for{\tsh_{p}, \tsh_{q}, \lenv, \stk_{p}, \stk_{q}, \ts_{p}, \ts_{q}, \Rely_{p}, \Rely_{q}, \Guar_{p}, \Guar_{q} }   \\
                \quad {} \land (\Rely_{p}, \Guar_{p}, \tsh_{p}, \ts_{p}) \in \flattenevalW[\lenv, \stk_{p}, \intf]{\gpre}
                \land \Rely_{p}, \Guar_{p}, (\stk_{p}, \tsh_{p}, \ts_{p}), \prog \toRG{}^{*} \Rely_{q}, \Guar_{q}, (\stk_{q}, \tsh_{q}, \ts_{q}), \pskip \\
                \quad \implies (\Rely_{q}, \Guar_{q}, \tsh_{q}, \ts_{q}) \in \flattenevalW[\lenv, \stk_{q}, \intf]{\gpost}
            \end{array}
        \end{rclarray}
    \]
\end{defn}


\begin{thm}[Soundness]
The soundness is defined as follows:
\[
    \begin{array}{@{}l@{}}
        \for{\gpre, \gpost, \prog, \intf } \tripleG{\gpre}{\prog}{\gpost} \implies \tripleSemG{\gpre}{\prog}{\gpost}
    \end{array}
\]
\end{thm}
\begin{proof}
Induction on the rules for program \( \prog \).

\caseB{\rl{PRCommit}}
We have \( \tripleG{\gpre}{\ptrans{\trans}}{\gpost} \) given that \( \tripleL{\lpre}{\trans}{\lpost} \), \( \repartition{\gpre}{\gpost}{\lpre}{\lpost} \), \( \stable{\gpre}{\intf} \) and \( \stable{\gpost}{\intf} \) for any \( \trans, \gpre, \gpost, \lpre, \lpost, \inter \). 
Given \( \tripleSemG{\gpre}{\ptrans{\trans}}{\gpost} \) (\defref{def:semantic-triple}) and the corresponding semantics (\defref{def:rg-semantics}),  for any \( \tsh_{p}, \tsh_{p}', \tsh_{q} ,\tsh_{q}', \ts_{p}, \ts_{p}', \ts_{q}, \ts_{q}', \Rely, \Guar, \lenv, \stk_{p}, \stk_{q}\) we have the follows,
\begin{equation}
    \label{equ:commit-current-trans}
    \begin{array}{@{}l@{}}
        (\Rely, \Guar, \tsh_{p}', \ts_{p}') \in \flattenevalW[\lenv, \stk_{p}, \intf]{\gpre} \\ 
        \quad {} \land (\Rely, \Guar, \tsh_{p}', \ts_{p}'), \ptrans{\trans} \toRG{\lbRELY}^{*} (\Rely, \Guar, \tsh_{p}, \ts_{p}), \ptrans{\trans} \toRG{\lbC{\tsid}} (\Rely, \Guar, \tsh_{q}, \ts_{q}),\pskip \toRG{\lbRELY}^{*} (\Rely, \Guar, \tsh_{q}', \ts_{q}'), \pskip
    \end{array}
\end{equation}
By \lemref{lem:stable-sound} and induction on the length of the reduction steps, we have \( (\Rely, \Guar, \tsh_{p}, \ts_{p}) \in \flattenevalW[\lenv, \stk_{p}, \intf]{\gpre} \).

Now we are going to prove \( (\Rely, \Guar, \tsh_{q}, \ts_{q}) \in \flattenevalW[\lenv, \stk_{p}, \intf]{\gpost} \).
Let variables \( \fpw_{p}, \fph_{p}, \fph_{f} \) to satisfy the follows, 
\begin{equation}
    \label{equ:def-wwhh}
    (\tsh_{p}, \ts_{p}) \in \func{x2tsh}{\fpw_{p}} 
    \land \eraseFW{\fpw_{p}} \in \evalW[\lenv, \stk_{p}]{\gpre} 
    \land \flattenFW{\fpw_{p}} = (\fph_{p} \composeFPH \fph_{f}, \stub)
    \land \fph_{p} \in \evalLS[\lenv, \stk_{p}]{\lpre}
\end{equation}
Note that we pick the names which are consistent with repartitioning in \defin \ref{def:repartitioning}.
By the soundness of \( \tripleL{\lpre}{\trans}{\lpost} \) (\thmref{thm:transaction-soundness}) and \equref{equ:def-wwhh}, for all \( \fph_{q}, \stk_{q} \), we have the follows,
\begin{equation}
    \label{equ:transaction-soundness}
    (\stk_{p}, \fph_{p} ), \trans \toL^{*}  (\stk_{q}, \fph_{q} ), \pskip 
    \implies \fph_{q} \in \evalLS[\lenv, \stk_{q}]{\lpost}
\end{equation}
Now we consider addresses in the domain of \( \fph_{q} \) being written and read separably.
First, for any address \( \addr_{w} \) being tagged as write or read/write in \( \fph_{q} \), assume the value is \( \val_{w} \).
\begin{equation}
    \label{equ:local-write}
    \exsts{\fp} 
    \fph_{q}(\addr_{w}) = (\val_{w}, \fp)
    \land \fpW \in \fp
\end{equation}
By the \( \commitName \) function in the semantics (\defref{fig:thread_semantics}), \equref{equ:commit-current-trans}, \equref{equ:transaction-soundness} and \equref{equ:local-write}, we have,
\begin{equation}
    \label{equ:global-write}
    \tsh_{q}(\addr_{w})(\ts_{q}) = (\val_{w}, \etW, \tsid)
\end{equation}
By the repartitioning (\defin \ref{def:repartitioning}), \equref{equ:def-wwhh} and \equref{equ:transaction-soundness}, for any \( \fpw_{q} \) we have,
\begin{equation*}
    \fpw_{q} \in \mergeR{\fpw_{p}}{\fpw_{i}}{\inter} \land \eraseFW{\fpw_{q}} \in \evalW[\lenv, \stk_{q}]{\gpost}
\end{equation*}
Given the \( \mergeName[\rely] \) function (\defin \ref{def:repartitioning}) that uses several levels of merges until \( \mergeName[\val] \) function (\defin \ref{def:merge-finger-heap}), \equref{equ:transaction-soundness} and \equref{equ:local-write}, we have,
\begin{equation}
    \label{equ:write-remain-the-same}
    \begin{array}{@{}l@{}}
      \for{ \fpw_{q} \in \mergeR{\fpw_{p}}{\fpw_{i}}{\inter} }  
      \eraseFW{\fpw_{q}} \in \evalW[\lenv, \stk_{q}]{\gpost} \\
      \quad {} \land \exsts{\fph} \flattenFW{\fpw_{q}} = (\fph, \stub) \land \fph(\addr_{w}) = \fph_{q}(\addr_{w}) = (\val_{w}, \etW)
    \end{array}
\end{equation}
which matches with Eq. \eqref{equ:global-write}.
Intuitively, because the address being written cannot be merged with others.

Second, we consider addresses \( \addr_{r} \) that are only being read with the value \( \val_{r} \),
\begin{equation}
    \label{equ:local-read}
    \fph_{q}(\addr_{r}) = (\val_{r}, \Set{\fpR})
\end{equation}
By the \( \commitName \) function in operational semantics (\defref{fig:thread_semantics}), \equref{equ:commit-current-trans}, \equref{equ:transaction-soundness} and \equref{equ:local-read}, we have,
\begin{equation}
    \label{equ:global-read}
    \tsh_{q}(\addr_{r})(\ts_{p}) = (\val_{r}, \etR , \tsid)
    \land \tsh_{q}(\addr_{r})(\ts_{q}) = (\val_{r}, \etE , \tsid)
\end{equation}
However, note that,
\[
\neg\left(
    \begin{array}{@{}l@{}}
        \for{\addr_{r}} \exsts{\val_{r}} 
        \tsh_{q}(\addr_{r})(\ts_{p}) = (\val_{r}, \etR, \tsid )
        \land \tsh_{q}(\addr_{r})(\ts_{q}) = (\val_{r}, \etE , \tsid) \\
        \quad \implies \snapshot{\tsh_{q}}{\ts_{q}}(\addr_{r}) = (\val_{r}, \stub)
    \end{array}
\right)
\]
Because there might be other transactions that commits between times \( \ts_{p} \) and \( \ts_{q} \) and writes to some addresses \( \addr_{r} \), which is allowed by the \( \consistentName \) predicate from the operational semantics (\figref{fig:thread_semantics}).
Let \( \tsid_{1} \) to \( \tsid_{\nat} \) be the transactions that commits between times \( \ts_{p} \) and \( \ts_{q} \) and writes to some addresses \( \addr_{r} \) as the follows.
We also assume those transactions are allowed by the \( \relyU \).
\begin{equation}
    \label{equ:concurrent-trans}
    \bigwedge\limits_{1 \leq i \leq \nat} 
    \begin{formulea}
    \exsts{\fpw, \fpw', \ts, \ts', \etag \in \Set{\etS, \etR} } 
    \ts < \ts' 
    \land \ts_{p} < \ts' < \ts_{q} \\
    {} \land \tsh_{q}(\addr_{r})(\ts) = (\stub, \etag, \tsid_{i}) 
    \land \tsh_{q}(\addr_{r})(\ts') = (\stub, \etW, \tsid_{i}) \\
    {} \land \exsts{\ca} \fpw_{p} = (\ca, \stub) 
    \land \fpw = (\ca, \stub) 
    \land \fpw' = (\ca, \stub) \\
    {} \land (\fpw, \fpw') \in \relyU
    \land (\tsh_{q}, \ts) \in \func{x2tsh}{\fpw}
    \land (\tsh_{q}, \ts') \in \func{x2tsh}{\fpw'}
    \end{formulea}
\end{equation}
By the \( \consistentName \) predicate from the operational semantics (\fig \ref{fig:thread_semantics}), we know the first transaction \( \tsid_{1} \) must read the same value as current transaction \( \tsid \).
\begin{equation}
\label{equ:read-the-same-value}   
\exsts{ \ts, \etag } 
\tsh_{q}(\addr_{r})(\ts) = (\val_{r}, \etag, \tsid_{1}) 
\land \etag \in \Set{\etS, \etR}
\end{equation}
Also, if two transactions write to the same addresses, it must be strictly one after another.
\begin{equation}
\label{equ:write-one-after-another}
    \begin{array}{@{}l@{}}
        \bigwedge\limits_{1 \leq i \leq \nat} 
        \exsts{ \ts, \ts', \etag \in \Set{\etS, \etR}, \val } 
        \ts < \ts'
        \land \tsh_{q}(\addr_{r})(\ts_{i}') = (\val, \etW, \tsid_{i - 1}) 
        \land \tsh_{q}(\addr_{r})(\ts_{i}) = (\val, \etag, \tsid_{i})
    \end{array}
\end{equation}
Given the definition of rely (\defref{def:rely-guarantee}), by \equref{equ:global-read}, \equref{equ:concurrent-trans}, \equref{equ:read-the-same-value}, \equref{equ:write-one-after-another}, and then induction on the number \( \nat \), we have,
\begin{equation}
    \label{equ:allowed-by-rely}
    \begin{array}{@{}l@{}}
        \exsts{\fpw, \ts, \etag \in \Set{\etS, \etR}, \ca }
        \tsh_{q}(\addr_{r})(\ts) = (\val_{r}, \etag, \tsid_{i}) 
        \land \fpw_{p} = (\ca, \stub) 
        \land \fpw = (\ca, \stub)  \\
        {} \land \bigwedge\limits_{1 \leq i \leq \nat} 
        \begin{formulea}
        \exsts{ \fpw', \ts' } 
        \ts < \ts' 
        \land \ts_{p} < \ts' < \ts_{q} 
        \land \tsh_{q}(\addr_{r})(\ts') = (\stub, \etW, \tsid_{i}) 
        \land \fpw' = (\ca, \stub) \\
        {} \land (\fpw, \fpw') \in \rely_{i}
        \land (\tsh_{q}, \ts) \in \func{x2tsh}{\fpw}
        \land (\tsh_{q}, \ts') \in \func{x2tsh}{\fpw'}
        \end{formulea}
    \end{array}
\end{equation}
where the \( \rely_{i} \) are defined in \defref{def:rely-guarantee}.
Let looks the first transaction \( \tsid_{1} \) and the last transaction \( \tsid_{\nat} \).
Assume the start state of \( \tsid_{1} \) is \( \fpw_{1} \), the end state of \( \tsid_{\nat} \) is \( \fpw_{\nat} \) and the final value being written to address \( \addr_{r} \) is \( \val_{\nat} \).
By re-writing the \equref{equ:allowed-by-rely}, we have the follows,
\begin{equation}
    \label{equ:first-and-last-concurrent-trans}
    \begin{array}{@{}l@{}}
        \exsts{ \ts_{1}, \ts_{\nat}, \etag \in \Set{\etS, \etR}, \ca }
        \ts_{1} < \ts_{\nat}
        \land \ts_{p} < \ts_{\nat} < \ts_{q}  \\
        \quad {} \land \fpw_{p} = (\ca, \stub) 
        \land \fpw_{1} = (\ca, \stub)  
        \land \fpw_{n} = (\ca, \stub) 
        \land (\fpw_{1}, \fpw_{\nat}) \in \rely_{\nat} \subseteq \Rely \\
        \quad {} \land \tsh_{q}(\addr_{r})(\ts_{1}) = (\val_{r}, \etag, \tsid_{1}) 
        \land \tsh_{q}(\addr_{r})(\ts_{\nat}) = (\val_{\nat}, \etW, \tsid_{\nat})  \\
        \quad {} \land (\tsh_{q}, \ts_{1}) \in \func{x2tsh}{\fpw_{1}}
        \land (\tsh_{q}, \ts_{\nat}) \in \func{x2tsh}{\fpw_{\nat}}
    \end{array}
\end{equation}
Given the  \equref{equ:first-and-last-concurrent-trans}, and the \( \mergeName[R] \) function that is used in repartitioning (\defref{def:repartitioning}), we have,
\begin{equation}
\label{equ:read-can-be-merged}
    \begin{array}{@{}l@{}}
      \exsts{ \fpw_{q} \in \mergeR{\fpw_{p}}{\fpw_{i}}{\inter}, \fph }  
      \eraseFW{\fpw_{q}} \in \evalW[\lenv, \stk_{q}]{\gpost} \\
      \quad {} \land \flattenFW{\fpw_{q}} = (\fph, \stub) \land \fph(\addr_{r}) = \fph_{q}(\addr_{r}) = (\val_{\nat}, \etW)
    \end{array}
\end{equation}

Now combining \equref{equ:write-remain-the-same} and \equref{equ:read-can-be-merged}, we have, 
\begin{equation}
    \eraseFW{\fpw_{q}} \in \evalW[\lenv, \stk_{q}]{\gpost}
    \land (\tsh_{q}, \ts_{q}) \in \func{x2tsh}{\fpw_{q}}  \\
\end{equation}
Since \( \stable{\gpost}{\intf} \) can be directly proven by the premiss, we have the prove for the \rl{PRCommit}.


\end{proof}










\sx{No use for below}

%\begin{defn}[Transaction interpretation]
%\label{def:transactions-interpretation}
%Given the set of transaction \( \trans \in \Transactions \) (\defin \ref{def:language}) and the operational semantics (\fig \ref{fig:transaction_semantics}), the \emph{transaction interpretation} function \( \intpSQ{.} : \Transactions \to \FPHeaps \to \powerset{\FPHeaps} \) is defined as follows:
%\[
    %\begin{rclarray}
        %\intpSQ{\trans}(\fph) & \defeq & 
            %\Setcon{%
                %\fph'
            %}{%
                %\exsts{ \stk, \stk' } (\stk, \fph ), \trans \toL^{*}  (\stk', \fph' ), \pskip
            %}\\
    %\end{rclarray}
%\]
%\end{defn}
%\sx{probably use the above to prove%
%\[
    %\tripleL{\lpre}{\trans}{\lpost}
%\]%
%Simply for less words, maybe?
%}
%Note that the stack is local and has no side effect to the fingerprint heap, therefore from now we will fix the stack and treat the stack as the same as logical environment.

%\begin{defn}[Reification function]
%\label{def:reification}
%Given the set of assertions \( \gpre \in \Ast \) and time-stamp heap \( \TSHeaps \), the \emph{reification} function \( \reif{.} : \Ast \to \powerset{\TSHeaps} \) is defined as follows:
%\[
%\begin{rclarray}
    %\reif{\gpre} & \defeq & 
    %\Setcon{%
        %\tsh
    %}{%
        %\exsts{\lenv, \stk, \h} \world \in \evalW{\gpre} 
        %\land (\h, \stub ) = \flattenW{\world}
        %\land \tsh \in\func{h2tsh}{\h} 
    %}
%\end{rclarray}
%\]
%where the interpretation of assertion \( \evalW{.} \) is defined in \defin \ref{def:assertion}, the world flattening \( \flattenW{.} \) in \defin \ref{def:world} and \( \funcn{h2tsh} \) function in \defin \ref{def:h2tsh}.
%\end{defn}

%\begin{defn}[Atomic interpretation]
%\label{def:atomic-intp}
%%Given the set of transactions \( \trans \in \Transactions \) (\defin \ref{def:language}), the set of programs \( \Programs \) and the operational semantics (\fig \ref{fig:thread_semantics}), the \emph{atomic interpretation} function \( \intfATOM{.} : \Atom \to \TSHeaps \to \powerset{\TSHeaps} \) is defined as follows, where \( \Atom \defeq \Setcon{\ptrans{\trans}}{\trans \in \Transactions \land \ptrans{\trans} \in \Programs} \).
%\[
    %\begin{rclarray}
        %\intpSQ{\ptrans{\trans}}(\tsh) & \defeq & 
            %\Setcon{%
                %\tsh'
            %}{%
                %\exsts{ \stk, \stk', \ts, \ts' } (\stk, \tsh, \ts ), \ptrans{\trans} \toT{\stub}  (\stk', \tsh', \ts' ), \pskip
            %}\\
    %\end{rclarray}
%\]
%\end{defn}

%\begin{thm}[Axiom soundness]
%Given the set of transactions \( \trans \in \Transactions \) (\defin \ref{def:language}) and the rely relation \( \Rely \) (\defin \ref{def:rely-guarantee}), and assume stardard lift for reification function (\defin \ref{def:reification}) and for atomic interpretation (\defin \ref{def:atomic-intp}), the axiom soundness is defined as follows:
%\[
    %\begin{array}{@{}l@{}}
        %\for{ \trans, \gpre, \gpost } 
        %\tripleG{\gpre}{\ptrans{\trans}}{\gpost} \\
        %\quad {} \land \for{\world } \intpSQ{\ptrans{\trans}}\left( \reif{\gpre \sep \Set{\world}} \right) \subseteq \left( \reif{\gpost \sep \Rely(\Set{\world})} \right) 
     %\end{array}
%\]
%where \( \Set{\world} \) denotes assertion satisfying \( \world \) under any logical environment and stack, i.e.\ \( \for{\lenv, \stk} \evalW{\Set{\world}} = \Set{\world} \).
%\end{thm}
%\begin{proof}
%Given the reification function, it is sufficient to prove:
%\[
    %\begin{array}{@{}l@{}}
        %\for{ \trans, \gpre, \gpost } 
        %\tripleG{\gpre}{\ptrans{\trans}}{\gpost} \\
        %\quad {} \land \for{ \stk ,\lenv, \world_{f}, \world_{p} } 
        %\exsts{ \world_{q}, \world_{f}' } 
        %\world_{p} \in \evalW{\gpre}
        %\land \world_{q} \in \evalW{\gpost}
        %\land \world_{f}' \in \Rely(\world_{f})  \\
        %\quad {} \land \for{ \h_{p}, \tsh_{p} } 
        %\exsts{ \h_{q}, \tsh_{q} }
        %(\h_{p}, \stub) = \flattenW{\world_{p} \composeW \world_{f}} 
        %\land \tsh_{p} \in \func{h2tsh}{\h_{p}}
        %\land (\h_{q}, \stub) = \flattenW{\world_{q} \composeW \world_{f}'} 
        %\land \tsh_{q} \in \func{h2tsh}{\h_{q}} \\
        %\quad \implies \tsh_{q} \in \intpSQ{\ptrans{\trans}} \left( \tsh_{p} \right)
     %\end{array}
%\]
%First we introduce some new variables \( \fpw_{p}, \fph_{p}, \fpw_{q}, \fph_{q} \) that satisfy the follows and whose names are consistent with those in \defin \ref{def:repartitioning}.
%\[
%\begin{array}{@{}l@{}}
    %\exsts{\fph} \\
    %\eraseFW{\fpw_{p}} = \world_{p} 
    %\land \flattenFW{\fpw_{p}} = (\fph_{p} \composeFPH \fph, \unitC)
    %\land \for{\addr} \fph_{p}(\addr) = (\stub, \emptyset) \land {} \\
    %\eraseFW{\fpw_{q}} = \world_{q} 
    %\land \flattenFW{\fpw_{q}} = (\fph_{q} \composeFPH \fph, \unitC)
%\end{array}
%\]
%By the definition of repartition (\defin \ref{def:repartitioning})  and transaction soundness (Theorem \ref{thm:transaction-soundness}):
%\[
%\begin{array}{@{}l@{}}
    %\for{\fph} 
    %\fph_{q} \composeFPH \fph \in \intpSQ{\trans}( \fph_{p} \composeFPH \fph) 
%\end{array}
%\]
%\end{proof}
