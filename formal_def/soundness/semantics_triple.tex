\subsection{Semantics Triple}

\begin{defn}[Flatten to time-stamp heaps]
\label{def:x2tsh}
\label{def:flatten-to-tsh}
Given the set of  \( \h \in \Heaps\), \( \tsh \in \TSHeaps \), world \( \world \in \World \) and fingerprint world \( \fpw \in \FPWorlds \), the overloaded function \( \funcn{x2tsh} : \Set{ \Heaps, \FPHeaps, \World, \FPWorlds,} \to \powerset{\TSHeaps} \) is defined as follows,
\[
    \begin{rclarray}
        \func{x2tsh}{\h} & \defeq & 
        \Setcon{%
            (\tsh,\ts) 
        }{%
            \for{ \addr } 
            \snapshot{\tsh}{\ts}(\addr) = (\val, \stub) 
            \land \h(\addr) = \val 
        } \\
        \func{x2tsh}{\fph} & \defeq & \func{x2tsh}{\eraseFPH{\fph}} \\
        \func{x2tsh}{\world} & \defeq & \func{x2tsh}{\world\projection{2}} \\
        \func{x2tsh}{\fpw} & \defeq & \func{x2tsh}{\eraseFW{\fpw}} \\
    \end{rclarray}
\]
where the \( \snapshotName \) function (\fig \ref{fig:thread_semantics}) returns a fingerprint heap corresponding the state at time \( \ts \), and here we match first projection.

The \( \funcn{xx2tsh} : \FPWorlds \times \FPWorlds \parfun \pset{(\TSHeaps \times \Timestamp) \times (\TSHeaps \times \Timestamp )} \) function converts an action (\defref{def:transactions-interpretation}) into time-stamp heaps and time-stamps.
\[
\begin{rclarray}
    \func{xx2tsh}{(\ca_{p}, \fph_{p}), (\ca_{q},\fph_{q})} & \defeq & 
    \Setcon{%
        (\tsh_{p}, \tsh_{q})
    }{%
        \exsts{\ts_{p}, \ts_{q}}
        \cancommit{\tsh_{p}}{\fph_{q}}{\ts_{p}}{\ts_{q}} \\
        \quad {} \land \pred{fresh}{\tsh_{p}, \tsid} 
        \land \tsh_{q} = \commit{\tsh_{p}}{\fph_{p}}{\fph_{q}}{\tsid}{\ts_{p}}{\ts_{q}}
    }
\end{rclarray}
\]
Therefore the flattened Rely \( \Rely \) and \( \Guar \) are defined as the follows,
\[
\begin{rclarray}
    \Rely & \defeq & \func{xx2tsh}{\rely(\intf)} \\
    \Guar & \defeq & \func{xx2tsh}{\guar(\intf)}
\end{rclarray}
\]

The flatten of a fingerprint world \( \fpw \) (\defref{def:fingerprint_worlds}), \( \flattenevalW[.,.,.]{.} : \FPWorlds \times \LEnv \times \Stack \times \Interference \parfun \pset{(\TSHeaps \times \Timestamp) \times (\TSHeaps \times \Timestamp) \times \TSHeaps \times \Timestamp}\)
\[
\begin{rclarray}
    \flattenevalW{\fpw} & \defeq & \Setcon{%
        (\Rely, \Guar, \tsh, \ts)
    }{%
        (\tsh, \ts) \in \func{x2tsh}{\fpw}  \\
    }
\end{rclarray}
\]
It then is lifted to assertion \( \Ast \) (\defref{def:assertion}),
\[
\begin{rclarray}
    \flattenevalW{\gpre} & \defeq &
    \bigcup\limits_{\eraseFW{\fpw} \in \evalW{\gpre}}  \flattenevalW{\fpw}
\end{rclarray}
\]
\end{defn}




\begin{defn}[Rely-Guarantee Operational Semantics]
\label{def:rg-semantics}
Assume rely and guarantee under the time-stamp heap level, \ie \( \Rely, \Guar \in (\TSHeaps \times \Timestamp) \times (\TSHeaps \times \Timestamp)\).
The rely-guarantee operational semantics are show in \figref{fig:rg_semantics}, which are extended from the semantics in \figref{fig:thread_semantics}.

\begin{figure}[!t]
\hrule\vspace{5pt}
\[
    \infer[\rl{RGEnv}]{%
        \Rely, \Guar, (\stk, \tsh, \ts), \iprog \ \toRG{\lbRELY} \ \Rely, \Guar, (\stk, \tsh', \ts'), \iprog
    }{%
        (\tsh, \tsh') \in \Rely
        && \ts' > \ts
    }
\]

\[
    \infer[\rl{RGCommit}]{%
        \Rely, \Guar, (\stk, \tsh, \ts), \ptrans{\trans} \ \toRG{\lbC{\tsid}} \ \Rely, \Guar, (\stk', \tsh', \ts'), \pskip
    }{%
        (\tsh, \tsh') \in \Guar
        && (\stk, \tsh, \ts), \ptrans{\trans} \ \toT{\lbC{\tsid}} \ (\stk', \tsh', \ts'), \pskip
    }
\]

\[
    \infer[\rl{RGLift}]{%
        \Rely, \Guar, (\stk, \tsh, \ts), \iprog \ \toRG{\lb} \ \Rely, \Guar, (\stk', \tsh', \ts'), {\iprog}'
    }{%
        \iprog \not\equiv \pwait{\stub}
        && \iprog \not\equiv \prog \ppar \prog
        && (\stk, \tsh, \ts), \iprog \ \toT{\lb} \ (\stk', \tsh', \ts'), {\iprog}'
    }
\]

\[
    \infer[\rl{RGFork}]{%
        \Rely, \Guar \cup \Guar', (\stk, \tsh, \ts), \prog_{1} \ppar \prog_{2}  \ \toRG{\lbF{\thid,\prog_{2}, \Rely \cup \Guar, \Guar'}} \ \Rely \cup \Guar', \Guar, (\stk', \tsh', \ts'), \prog_{1} \pseq \pwait{\thid}
    }{%
        (\stk, \tsh, \ts), \prog_{1} \ppar \prog_{2}  \ \toT{\lbF{\thid,\prog_{2}}} \ (\stk', \tsh', \ts'), \prog_{1} \pseq \pwait{\thid}
    }
\]

\[
    \infer[\rl{RGJoin}]{%
        \Rely \cup \Guar', \Guar, (\stk, \tsh, \ts), \pwait{\thid}  \ \toRG{\lbJ{\thid,\ts, \Rely \cup \Guar, \Guar'}} \ \Rely, \Guar \cup \Guar', (\stk', \tsh', \ts'), \pskip
    }{%
        (\stk, \tsh, \ts), \pwait{\thid}  \ \toT{\lbJ{\thid,\ts}} \  (\stk', \tsh', \ts'), \pskip
    }
\]

\hrule\vspace{5pt}

\[
    \infer[\rl{RGPSingle}]{%
        ( \tshp, \thpl \uplus \Set{ \thid \mapsto (\Rely, \Guar, \stk, \ts, \iprog) } ) \ \toGG{\lb} \  ( \tshp', \thpl \uplus \Set{ \thid \mapsto (\Rely', \Guar', \stk', \ts', {\iprog}') } ) 
    }{%
        \begin{array}{c}
        \Rely, \Guar, ( \stk, \tshp, \ts ) , \iprog \ \toRG{\lb} \  \Rely', \Guar', ( \stk', \tshp', \ts' ) , {\iprog}' 
        \quad \lb \in \Set{ \lbID, \lbC{\stub} } \\
        \begin{array}{l}
        \mathtt{for} \ \thid'' \in \dom(\thpl) \\
        \quad \begin{formulea}
            \thpl(\thid'') = (\Rely'', \Guar'', \stk'', \ts'', {\iprog}'')  \\
            \Rely'', \Guar'', ( \stk'', \tshp, \ts'' ) , \iprog \ \toRG{\lbRELY} \  \Rely'', \Guar'', ( \stk'', \tshp', \ts'' ) , {\iprog}'' \\
        \end{formulea}
        \end{array}
        \end{array}
    }
\]


\[
    \infer[\rl{RGPFork}]{%
        ( \tshp, \thpl \uplus \Set{ \thid \mapsto (\Rely, \Guar, \stk, \ts, \iprog) } ) \ \toGG{\lbF{\thid', \prog'', \Rely'', \Guar''}} \  ( \tshp', \thpl \uplus \Set{ \thid \mapsto (\Rely', \Guar', \stk', \ts', {\iprog}'), \thid' \mapsto (\Rely'', \Guar'', \lambda \var \ldotp 0, \ts', \prog'') } )
    }{%
        \Rely, \Guar, ( \stk, \tshp, \ts ) , \iprog \ \toRG{\lbF{\thid', \prog'', \Rely'', \Guar''}} \  \Rely', \Guar', ( \stk', \tshp', \ts' ) , {\iprog}' 
    }
\]

\[
    \infer[\rl{RGPJoin}]{%
        ( \tshp, \thpl \uplus \Set{ \thid \mapsto (\Rely, \Guar, \stk, \ts, \iprog), \thid' \mapsto (\Rely'', \Guar'', \stk', \ts'', \pskip) } )  \ \toGG{\lbJ{\thid',\ts'', \Rely'', \Guar''}} \ ( \tshp', \thpl \uplus \Set{ \thid \mapsto (\Rely', \Guar', \stk', \ts', {\iprog}')} )
    }{%
        \Rely, \Guar, ( \stk, \tshp, \ts ) , \iprog \ \toRG{\lbJ{\thid',\ts'', \Rely'', \Guar''}} \  \Rely', \Guar', ( \stk', \tshp', \ts' ) , {\iprog}' 
    }
\]

\hrule\vspace{5pt}
\caption{Extended Semantics}
\label{fig:rg_semantics}
\end{figure}
\end{defn}


\begin{defn}[Semantic triple]
\label{def:semantic-triple}
    The semantic triple \( \tripleSemG{\gpre}{\prog}{\gpost}\) is defined as the follows,
    \[
        \begin{rclarray}
            \tripleSemG{\gpre}{\prog}{\gpost} & \defeq &
            \begin{array}[t]{@{}l@{}}
                \for{\tsh_{p}, \tsh_{q}, \lenv, \stk_{p}, \stk_{q}, \ts_{p}, \ts_{q}, \Rely_{p}, \Rely_{q}, \Guar_{p}, \Guar_{q} }   \\
                \quad {} \land (\Rely_{p}, \Guar_{p}, \tsh_{p}, \ts_{p}) \in \flattenevalW[\lenv, \stk_{p}, \intf]{\gpre}
                \land \Rely_{p}, \Guar_{p}, (\stk_{p}, \tsh_{p}, \ts_{p}), \prog \toRG{}^{*} \Rely_{q}, \Guar_{q}, (\stk_{q}, \tsh_{q}, \ts_{q}), \pskip \\
                \quad \implies (\Rely_{q}, \Guar_{q}, \tsh_{q}, \ts_{q}) \in \flattenevalW[\lenv, \stk_{q}, \intf]{\gpost}
            \end{array}
        \end{rclarray}
    \]
\end{defn}
