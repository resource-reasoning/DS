\subsection{Transaction Soundness}


\begin{thm}[Transaction soundness]
\label{thm:transaction-soundness}
The transaction soundness is as follows:
\[
    \begin{array}{@{}l@{}}
        \for{ \lpre, \trans, \lpost } \tripleL{\lpre}{\trans}{\lpost} \implies \ \tripleSemL{\lpre}{\trans}{\lpost} \\
    \end{array}
\]
where,
\[
    \begin{rclarray}
    \tripleSemL{\lpre}{\trans}{\lpost} & \eqdef &
    \begin{array}[t]{@{}l@{}}
        \for{\lenv, \stk, \stk', \h, \h', \opset, \opset' } 
        (\h, \opset) \in \evalLS[\lenv, \stk]{\lpre} \\
        \quad {} \land \vdash (\stk, \h, \opset ), \trans \toL^{*}  (\stk', \h', \opset' ), \pskip 
        \implies (\h', \opset') \in \evalLS[\lenv, \stk']{\lpost}
    \end{array}
    \end{rclarray}
\]
\end{thm}
\begin{proof}
Induction on the derivations.

\caseB{\rl{TRSkip}}

We have \(\trans \equiv \pskip\), \( \lpre \equiv \lpost \equiv \assemp \), thus \( \h_{p} = \h_{q} = \unitH \), \( \opset = \opset' \) and \( \stk = \stk' \), and then \( (\unitH,\unitO ) \in \evalLS[\lenv, \stk']{\assemp} \) holds.

\caseB{\rl{TRAss}}

We have \(\trans \equiv ( \pass{\var}{\expr} ) \), \( \lpre \equiv ( \var \doteq \lexpr ) \) and \( \lpost \equiv ( \var \doteq \expr\sub{\var}{\lexpr} ) \) for some \( \expr, \lexpr \) and \( \var \) such that \( \var \notin \func{fv}{\lexpr} \land \var \in \Vars\).
Given the transaction semantics (\figref{fig:thread_semantics}), it has \( \stk' = \stk\rmto{\var}{\val} \) where \( \val = \evalLE[\lenv, \stk]{\expr\sub{\var}{\lexpr}} \).
Since \( \var \notin \func{fv}{\lexpr} \), we know \( \evalLE[\lenv, \stk]{\lexpr} = \evalLE[\lenv, \stk']{\lexpr} \), and then \( \evalLE[\lenv, \stk]{\expr\sub{\var}{\lexpr}} = \evalLE[\lenv, \stk']{\expr\sub{\var}{\lexpr}} \).
This means the assertions related to stack holds even thought the stack changes.
Also because the heap and operation set remain unchanged, this is \( \h = \h' \) and \( \opset = \opset' \), we prove \( (\h', \opset' ) \in \evalLS[\lenv, \stk']{\lpost} \).

\caseB{\rl{TRLookup}}

We have  \(\trans \equiv ( \plookup{\var}{\expr} ) \) and four cases for pre- and post-conditions defined by the relation \( \toFP{\otR(\expr, \lexpr)}\).
In all the four cases, the heap remains the same \( \h = \h' = \Set{\addr \mapsto \val}\) and the stack get updated to \( \stk' = \stk\rmto{\var}{\val} \), yet since \( \var \notin \func{fv}{\lexpr}\), the logical value \( \lexpr \) and new logical address \( \expr\sub{\var}{\lexpr}\) are evaluated to the same value \( \val \) and address \( \addr \) as before.
While different cases have different operation set.
Also note that the evaluation of the pre- and post-conditions in all four cases are singleton sets.
Now we do case analysis on four cases, especially on the operation set before and after.

If \( \lpre \equiv \expr \fpI \lexpr \) and \( \lpost \equiv \expr\sub{\var}{\lexpr} \fpR \lexpr \sep \var \dot= \lexpr \), the only interpretation for pre-condition \( \lpre \) is \( (\Set{\addr \mapsto \val}, \emptyset) \) where \( \addr = \evalLE{\expr} \) and \( \val = \evalLE{\lexpr}\).
In this case, a read operation is added \( \opset' = \Set{(\otR, \addr, \val)} \) and it is included in the interpretation of the post condition  \( \expr\sub{\var}{\lexpr} \fpR \lexpr  \).

If \( \lpre \equiv \expr \fpR \lexpr \) and \( \lpost \equiv \expr\sub{\var}{\lexpr} \fpR \lexpr \sep \var \dot= \lexpr \), since there is already a read operation in the operation set, adding a new read operation to does not change the set, \ie the new operation set  is \( \opset' = \Set{(\otR, \addr, \val)} \addO (\otR, \addr, \val ) = \Set{(\otR, \addr, \val)} \).
This is exactly the post-condition.
For the similar reason that the operation set remains the same in the rest two cases, so it is sound when \( \lpre \equiv \expr \fpW \lexpr \) and \( \lpost \equiv \expr\sub{\var}{\lexpr} \fpW \lexpr \sep \var \dot= \lexpr \), and when \( \lpre \equiv \expr \fpRW (\lexpr,\lexpr') \) and \( \lpost \equiv \expr\sub{\var}{\lexpr} \fpRW (\lexpr,\lexpr') \sep \var \dot= \lexpr' \).

\caseB{ \rl{TRMutate} }

We have  \( \trans \equiv (\pmutate{\expr_{1}}{\expr_{2}}) \) and four cases for pre- and post-conditions defined by the relation \( \toFP{\otW(\expr, \lexpr)}\). 
In all the four cases, the stack remains untouched and the heap is updated to \( \h' = \Set{\addr \mapsto \val' }\) where the logical address \( \evalLE[\lenv,\stk']{\expr_{1}}  = \addr \) and the new value \( \evalLE[\lenv,\stk']{\expr_{2}} = \val'\).
Now we do case analysis on four case and focus on the operations before and after.

If \( \lpre \equiv \expr_{1} \fpI \lexpr \) and \( \lpost \equiv \expr_{1} \fpW \expr_{2} \), a new write operation is added to the initially empty operation set, this is, \( \opset' = \Set{(\otW, \addr, \val)}\) where \( \addr = \evalLE[\lenv,\stk']{\expr_{1}}\) and \( \val = \evalLE[\lenv,\stk']{\expr_{1}}\).
This is exactly the post-condition \( \expr_{1} \fpW \expr_{2} \).
If \( \lpre \equiv \expr_{1} \fpW \lexpr \) and \( \lpost \equiv \expr_{1} \fpW \expr_{2} \), the operation set before execution is \( \opset = \Set{(\otW, \addr, \val)}\) where \( \addr = \evalLE{\expr_{1}}\) and \( \val = \evalLE{\lexpr}\).
Since the set only have the last write because of the property of the \( \addO \) operator (\defref{def:ops}), the set after is \( \opset' = \opset \addO (\otW, \addr, \val') = \Set{(\otW, \addr, \val')}\), where \( \val' = \evalLE[\lenv,\stk']{\expr_{1}}\).
Note that the stack remains untouched, so we have \( \addr = \evalLE{\expr_{1}} = \evalLE[\lenv,\stk']{\expr_{1}} \).
Thus, we have the proof for this case.
The remaining two cases follow the same argument as the operations set only have the last write.

\caseI{\rl{TRChoice}}

We have  \(\trans \equiv \trans_{1} + \trans_{2} \), where \( \tripleL{\lpre}{\trans_{1}}{\lpost} \) and \( \tripleL{\lpre}{\trans_{2}}{\lpost} \) hold, for some \( \trans_{1}, \trans_{2}, \lpre, \lpost \).
Given the transaction semantics (\figref{fig:thread_semantics}), it either has \( ( \stk, \h, \opset ), \trans_{1} \pchoice \trans_{2} \toL ( \stk, \h, \opset ), \trans_{1} \) or  \( ( \stk, \h, \opset ), \trans_{1} \pchoice \trans_{2} \toL ( \stk, \h, \opset ), \trans_{2} \).
Let us pick \( \trans_{1} \) and  assume it can be reduced to \( \pskip \) from the initial state, \ie \( ( \txstk, \h, \opset ), \trans_{1}  \toL^{*} ( \txstk', \h', \opset' ), \pskip \).
By the premiss of the rule \( \tripleL{\lpre}{\trans_{1}}{\lpost} \) and the \ih, it implies \( \tripleSemL{\lpre}{\trans_{1}}{\lpost} \), so we prove \( (\h', \opset') \in \evalLE[\lenv, \stk']{\lpost} \).
Symmetrically, if we pick \( \trans_{2} \), it gives the same result.

\caseI{\rl{TRSeq}}

We have \( \trans \equiv \trans_{1} \pseq \trans_{2} \) where \( \tripleL{\lpre}{\trans_{1}}{\lframe} \) and \( \tripleL{\lframe}{\trans_{2}}{\lpost} \) hold, for some \( \trans_{1}, \trans_{2}, \lpre, \lpost, \lframe \).
Given the transaction semantics (\figref{fig:thread_semantics}), it has \( \vdash ( \stk, \h, \opset ), \trans_{1} \pseq \trans_{2} \toL^{*} ( \stk'', \h'', \opset'' ), \pskip \pseq \trans_{1} \toL ( \stk'', \h'', \opset'' ), \trans_{1} \toL^{*} ( \stk', \h', \opset' ), \pskip \) for some intermediate state \( (\stk'', \h'', \opset'') \).
By the premiss of the rule and the \ih, we have \( \tripleSemL{\lpre}{\trans_{1}}{\lframe} \) and so \( (\h'', \opset'') \in \evalLE[\lenv, \stk'']{\lframe} \).
The elimination of prefix \( \pskip\) does not change any state, so \( (\h'', \opset'') \in \evalLE[\lenv, \stk'']{\lframe} \) still holds.
Then, by the premiss and the \ih, we know \( \tripleSemL{\lframe}{\trans_{2}}{\lpost} \) and therefore the proof that \( (\h', \opset') \in \evalLE[\lenv, \stk']{\lpost} \).

\caseI{\rl{TRLoop}}

Since the triple is only partial correct, meaning that if the transaction \( \trans \) terminates it will reach a state satisfying the post-condition \( \lpost \), it is sufficient to prove the follows,
\[
    \for{\lpre, \trans, \nat > 0} \tripleL{\lpre}{\trans^{\nat}}{\lpre} \implies \ \tripleSemL{\lpre}{\trans^{\nat}}{\lpre} 
\]
where,
\[
\begin{rclarray}
    \trans^{1} & \defeq  & \trans \\
    \trans^{\nat} & \defeq  & \trans \pseq \trans^{\nat - 1} \\
\end{rclarray}
\]

We prove that by induction on the number \( \nat \).
For \( \nat = 1 \), it is proven directly by the \ih
For \( \nat > 1 \), we have \( \vdash (\stk, \h, \opset), \trans \pseq \trans^{\nat - 1} \toL^{*} (\stk'', \h'', \opset''), \trans^{\nat - 1} \toL^{*} (\stk', \h', \opset'), \pskip \) for some intermediate state \( ( \stk'', \h'', \opset'' ) \).
By the premiss and the \ih, we have \(\tripleSemL{\lpre}{\trans}{\lpre} \) and thus \(  (\h'', \opset'') \in \evalLS[\lenv, \stk'']{\lpre} \).
Then by the \ih that \(\tripleSemL{\lpre}{\trans^{\nat - 1}}{\lpre} \), we prove \(  (\h', \opset') \in \evalLS[\lenv, \stk']{\lpre} \).

\caseI{\rl{TRFrame}}

We need to prove \( \tripleSemL{\lpre \sep \lframe }{\trans}{\lpost \sep \lframe} \) given that \( \tripleSemL{\lpre}{\trans}{\lpost} \).
Assume variables \( \h, \h', \h'', \opset, \opset', \opset'', \stk, \stk' \) such that \( ( \h, \opset ) \in \evalLS[\lenv, \stk]{\lpre} \), \( ( \h', \opset' ) \in \evalLS[\lenv, \stk']{\lpost} \) and \( ( \h'', \opset'' ) \in \evalLS[\lenv, \stk]{\lframe}\).
Since \( \lpre \sep \lframe \), the point-wise composition is defined, \ie \( (\h \composeH \h'', \opset \composeO \opset'') \in \evalLS[\lenv, \stk]{\lpre \sep \lframe} \).
The domain of the heaps and operations sets, therefore, are disjointed.
The domain of a operations set is all the addresses \( \dom(\opset) \defeq \opset\projection{2}\).
We also know the domain of the operation set is a subset of the domain of the heap, \(\dom(\opset) \subseteq \dom(\h) \) which can be proven by induction on the structures of local assertions \( \LAst \).
By the hypothesis \( \tripleSemL{\lpre}{\trans}{\lpost} \), we know \( ( \stk, \h, \opset ), \trans \toL^{*} ( \stk', \h', \opset' ), \pskip \).
The heap after the execution should contain the same resources as before, this is \( \dom(\h) = \dom(\h') \).
Since \( \dom(\opset') \subseteq \dom(\h') \), we know the compositions \( \h' \composeH \h''\) and \( \opset' \composeO \opset''\) exist.
This means the frame does not affect the semantic steps, \ie \( ( \stk, \h \composeH \h'', \opset \composeO \opset''), \trans \toL^{*} ( \stk', \h' \composeH \h'', \opset' \composeO \opset'' ), \pskip \).
Finally, because there is no free variables overlap between \( \lframe \) and \( \lpre, \lpost \), the update of stack does not change the evaluation of the frame, this is, \( \evalLS[\lenv, \stk]{\lframe} = \evalLS[\lenv, \stk']{\lframe} \) which then gives us the result \( (\h' \composeH \h'', \opset' \composeO \opset'') \in \evalLS[\lenv, \stk']{\lpost \sep \lframe} \).


%and similarly \( ( \h_{q} \composeH \h_{r}, \opset_{q} \uplus \opset_{r} ) \in \evalLS[\lenv, \thstk \uplus \txstk_{q}]{\lpost \sep \lframe} \land ( \h_{q} ,\opset_{q} ) \in \evalLS[\lenv, \thstk \uplus \txstk_{q}]{\lpost} \land ( \h_{r}, \opset_{r} ) \in \evalLS[\lenv, \thstk \uplus \txstk_{q}]{\lframe}\).
%By the \ih that \( \tripleSemL{\lpre}{\trans}{\lpost} \), it means .
%Now we need to prove the follows,
%\[
    %\thstk \vdash ( \txstk_{p}, \h_{p}  \composeH \h_{r}, \opset_{p} \composeO \opset_{r}), \trans \toL^{*} ( \txstk_{q}, \h_{q} \composeH \h_{r}, \opset_{q} \composeO \opset_{r}), \pskip 
%\]
%First for the heaps part, since both \( (\h_{p} \composeH \h_{r}) \) and  \( (\h_{q} \composeH \h_{r}) \) are defined, this means the domain of the frame \( \h_{r} \) are separate from the ones of \( \h_{p}\) and \( \h_{q} \).
%Then by the \ih, the transaction \( \trans \) does not need any resource from \( \h_{r} \) to progress.
%Second for the event sets part, since it has \( ( \h_{q} \composeH \h_{r}, \opset_{q} \composeO \opset_{r} ) \in \evalLS[\lenv, \thstk \uplus \txstk_{q}]{\lpost \sep \lframe} \), so \( \opset_{q} = \unitO \lor \opset_{r} = \unitO \).
%if \( \opset_{q} = \unitO \), it must be that \( \opset_{p} = \unitO \), it holds by the \ih
%If \( \opset_{r} = \unitO \), it also holds by the \ih
%Given above we have the prove that \( \tripleSemL{\lpre \sep \lframe }{\trans}{\lpost \sep \lframe} \).


\end{proof}
