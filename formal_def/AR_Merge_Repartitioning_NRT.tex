\section{AR Merge and Repartitioning -- No Resource Transfer}
\newcommand{\mergeW}[2]{\func{merge}{#1, #2}}
\newcommand{\mergeWAux}[3]{\func{merge_W}{#1, #2, #3}}
\renewcommand{\mergeR}[1]{\mrg[\scalebox{.5}{\(\rely\)}]{#1}}
\renewcommand{\flatten}[1]{\left\lfloor #1 \right\rfloor}


%\azalea{Shale, I have now removed (commented out) the previous section in AR\_Merge\_Repartitioning.tex from the main document to help us focus. From your formalism in \S 4 (rules.tex), the definitions I use (implicitly assume) are the local and global rules, plus the definition of fingerprint heap merge $\mopFP$. If you're happy with the formalism in this section let us clean up: 1) add the definition of $\mopFP$ to this section to be self-contained; 2) add the local and global rules to this section; 3) rename this section ``Logic"; 4) comment out the inclusion of rules.tex from draft.tex.  }
\azalea{The definition of actions is revisited below to restrict resource transfer}
\begin{definition}[Actions]
%\label{def:action}
Given the set of local states $\LStates$ (\defin\ref{def:local_state}), the set of \emph{actions}, $\action \in \Actions$, is defined as follows:
%
\[
	\Actions \eqdef 
	\Setcon{
		((\fph, \ca), (\fph', \ca'))
	}{
		((\fph, \ca), (\fph', \ca')) \in \LStates \times \LStates 
		\land \orth{(\fph, \ca)} = \orth{(\fph', \ca')}\\
%		\land\ \dom(\fph) = \dom(\fph') \\
		\land\ \for{\loc} \fph(\loc) = (\val, \fp) \Rightarrow \\
			\quad 	\big(\fph'(\loc) = (-, \fp') \land \addFPW{\fp} \subseteq  \fp' \big)
			\lor
			\big(\fph'(\loc) = (\val, \fp') \land \fp' = \addFPR{\fp} \big)
	}
\] 
%
where
%
\[
	\orth{\ls} \eqdef \myset{\ls'}{\ls \composeLS \ls' \isdef}
\]
%
Given the set of primitive capabilities $\Kaps$ (\defin\ref{def:capabilities}), the set of \emph{interference environments} is $\inter \in \Interference \eqdef \Kaps \parfun \powerset{\Actions}$.
\end{definition}

%The effect of an action $\action {=} (\ls, \ls')$, written $\effect{\action}$, computes the changes applied to the action precondition $\ls$ when updated to the postcondition $\ls'$. In particular, $\effect{(\ls, \ls')}$ yields a triple $(\ls_f, \ls_1, \ls_2)$, where $\ls_f$ denotes the maximal substate unchanged by $\action$ (i.e.~those parts present in both $\ls$ and $\ls'$), and $\ls_1$ denotes the substate updated by $\action$ to $\ls_2$.
%
%\begin{definition}[Action effect]
%Given the set of actions $\Actions$ (\defin\ref{def:action}), the \emph{effect of an action}, $\effect{(.)} : \Actions \rightarrow \LStates \times \LStates \times \LStates$, is defined as follows, for all $(\ls, \ls') \in \Actions$:
%%
%\[
%	\effect{(\ls, \ls')} \eqdef 
%	\myset{
%		(\ls_f, \ls_1, \ls_2)
%	}{
%		\ls = \ls_f \composeLS \ls_1
%		\;\land\; \ls' = \ls_f \composeLS  \ls_2 \\
%		\land\ \for{\ls''} \ls'' \leq \ls_1 \land \ls'' \leq \ls_2  \Rightarrow \ls'' \in \unitLS 
%		\;\land\; \orth{\ls_c} = \orth{\ls'_c} 
%	}
%\]
%%
%\end{definition}
%
%
\begin{definition}[Local state merge]
\[
	\mergeLS{\ls}{\ls_1}{\ls_2}
	\eqdef
	\myset{
		(\fph', \ca'_1 \composeC \ca_f \composeC \ca'_2) \\
	}{
%		\exsts{\fph, \fph_1, \fph_2, \ca, \ca_1, \ca_2, \ca_3, \ca_4, \ca_5, \ca_6, \ca_f}\\
%		\quad \land\; \ls = (\fph, \ca)		
%		\land \ls_1 = (\fph_1, \ca_1)
%		\land \ls_2 = (\fph_2, \ca_2) \\
%%		
%		\quad \land\ \ca =  \ca_3 \composeC \ca_f \composeC \ca_4
%		\land \ca_1 =  \ca_5 \composeC \ca_f \composeC \ca_4
%		\land \ca_2 =  \ca_3 \composeC \ca_f \composeC \ca_6 \\
%%		
%		\color{darkred} \quad \land\; \ws{\fph_1} \cap \ws{\fph_2} {=} \emptyset 
%		\land \fph' = \func{eager\_merge\_heap}{\fph_1, \fph_2} \\
%%		
%        \color{blue} \quad \land\; \fph' = \fph_1 \mopFP \fph_2 \\
%%
%		\quad \land\ \ca' = \ca_5 \composeC \ca_f \composeC \ca_6
%
%
		\fph' = \mergeFP{\lsFPH{(\ls_1)}}{\lsFPH{(\ls_2)}}
		\land \exsts{\ca_1, \ca_2}\\
%
		\quad \lsCAP{\ls} =  \ca_1 \composeC \ca_f \composeC \ca_2
		\land \lsCAP{(\ls_1)} =  \ca'_1 \composeC \ca_f \composeC \ca_2
		\land \lsCAP{(\ls_2)} =  \ca_1 \composeC \ca_f \composeC \ca'_2 
	}
\]
%
%\sx{It will be a singleton set?}
%\azalea{No. It is a singleton set iff your capability PCM is cancellative which we do not require/assume. That is, the set notation caters for the more general case where cancellativity is not satisfied.}
%Two local states $\ls_1$ and $\ls_2$ are \emph{conflicted} with respect to a snapshot $\ls$, written $\conflict{\ls}{\ls_1}{\ls_2}$, if and only if their merging yields no result:
%
\[
	\conflict{\ls}{\ls_1}{\ls_2} \iffdef \mergeLS{\ls}{\ls_1}{\ls_2} = \emptyset
\]
\end{definition}
%
%
\begin{definition}[Fingerprint worlds]\label{def:fingerprint_worlds}
Given the set of local states $\LStates$ (\defin\ref{def:local_state}) and the set of region identifiers $\RegionID$ (\defin\ref{def:capabilities}), the set of \emph{fingerprint worlds}, $\fpw \in \FPWorlds$, is defined as follows:
%
\[
\begin{rclarray}
	\FPWorlds  & \eqdef  
	& \myset{
		(\ls, \fpgs)
	}{
		(\ls, \fpgs) \in \LStates \times (\RegionID \parfinfun \LStates) \land \wfFW{\ls, \fpgs}
	}
\end{rclarray}
\]
%
with the definitions of the flattening function and the well-formedness predicate lifted as follows:
%
%
\[
\begin{rclarray}
	\flatten{(\ls, \fpgs)}  & \eqdef & \ls \composeLS \prod\limits_{\rid \in \dom(\fpgs)}^{\composeLS} \fpgs(\rid)\downarrow_1
\end{rclarray}
\]
%
\[
\begin{rclarray}
	\wfFW{\ls, \fpgs} & \defeq & \exsts{\fph, \ca}\flatten{(\ls, \fpgs)} {=} (\fph, \ca) \land\ \dom(\ca) \subseteq \dom(\fpgs) \\
\end{rclarray}
\]
%
The \emph{lift function}, $\lift{.}: \World \rightarrow \FPWorlds$, is defined as follows:
%
\[
	\lift{(\lgs, \gs)} \eqdef (\lift{\lgs}, \lift{\gs})
\]
%
where
%
\[
\begin{rclarray}
	\lift{\lgs} = \ls 
	& \iffdef 
	& \exsts{\h, \fph, \ca}
	\lgs = (\h, \ca) 
	\land \ls = (\fph, \ca) 
	\land \dom(\fph) = \dom(\h) 
	\land \for{\loc, \val} \h(\loc) = \val \Rightarrow \fph(\loc) = (\val, \emptyset) \\
%
	\lift{\gs} = \fpgs 
	& \iffdef
	& \dom(\fpgs) = \dom(\gs) \land \for{\rid, \lgs', \inter} \gs(\rid) = (\lgs', \inter) \Rightarrow \fpgs(\rid) = (\lift{\lgs'}, \inter) 
\end{rclarray}
\]
%
The \emph{erase function}, $\erase{.}: \FPWorlds \rightarrow \World$, is defined as follows:
%
\[
	\erase{(\ls, \fpgs)} \eqdef (\erase{\ls}, \erase{\fpgs})
\]
%
where
\[
\begin{rclarray}
	\erase{\ls} = \lgs 
	& \iffdef 
	& \exsts{\h, \fph, \ca}
	\ls = (\fph, \ca) 
	\land \lgs = (\h, \ca) 
	\land \dom(\fph) = \dom(\h) 
	\land \for{\loc, \val, \fp} \fph(\loc) = (\val, \fp) \Rightarrow \h(\loc) = \val \\
%
	\erase{\fpgs} = \gs 
	& \iffdef
	& \dom(\fpgs) = \dom(\gs) \land \for{\rid, \ls', \inter} \fpgs(\rid) = (\ls', \inter) \Rightarrow \gs(\rid) = (\erase{\ls'}, \inter) 
\end{rclarray}
\]
\end{definition}
%
%
\begin{definition}[Fingerprint worlds merge]
Given the set of fingerprint worlds $\FPWorlds$ (\defin\ref{def:fingerprint_worlds}), the \emph{merge} function, $\mergeWAux{.}{.}{.}: \FPWorlds \times \FPWorlds \times \FPWorlds \rightarrow \powerset{\FPWorlds}$, is defined as follows, for all $\fpw, \fpw_1, \fpw_2 \in \FPWorlds$:

%
\[
	\mergeWAux{(-, \fpgs)}{(\ls_1, \fpgs_1)}{(-, \fpgs_2)} \eqdef 
	\begin{cases}
		\emptyset & \text{if } \exsts{\rid} \conflict{\fpgs(\rid)}{\fpgs_1(\rid)}{\fpgs_2(\rid)} \\
		& \qqquad \lor\ \rid \in \dom(\fpgs_1) \land \rid \in \dom(\fpgs_2) \land \rid \not\in \dom(\fpgs) \\\\
		S & \text{otherwise}
	\end{cases}
\]
%
with
\[
	S = \myset{(\ls_1, \fpgs_3)}{
		\dom(\fpgs_3)= \dom(\fpgs_1) \cup \dom(\fpgs_2) \land \for{\rid}\\
		\quad \rid \in \dom(\fpgs_1) \land \rid \in \dom(\fpgs_2) \Rightarrow \fpgs_3(\rid) \in \mergeLS{\fpgs(\rid)}{\fpgs_1(\rid)}{\fpgs_2(\rid)} \\
		\quad \land\ \rid \in \dom(\fpgs_1) \land \rid \not\in \dom(\fpgs_2) \Rightarrow 	\fpgs_3(\rid) = \fpgs_1(\rid) \\
		\quad \land\ \rid \not\in \dom(\fpgs_1) \land \rid \in \dom(\fpgs_2) \Rightarrow 	\fpgs_3(\rid) = \fpgs_2(\rid)
	}
\]
\end{definition}
%
%
\begin{definition}[Rely and guarantee]
Given the set of fingerprint worlds $\FPWorlds$ (\defin\ref{def:fingerprint_worlds}), the \emph{update rely} relation, $\relyU: \FPWorlds \times \FPWorlds$, is defined as follows:
%
\[	
	\relyU \eqdef
	\myset{
		\big((\ls, \fpgs), (\ls, \fpgs')\big)	
	}{
		\exsts{\rid, \ca, \kap, \kap', \ls_1, \ls_2, \ls_f}\\
		\quad \for{\rid'} \rid \ne \rid' \Rightarrow \fpgs(\rid') = \fpgs'(\rid') \\
		\quad \land\ \fpgs(\rid) = (\ls_1 \composeLS \ls_f, \inter) \land \fpgs'(\rid) = (\ls_2 \composeLS \ls_f, \inter)		 \\
		\quad \land\ (\unitFP, \ca) \composeLS \flatten{(\ls, \fpgs)} \isdef 
		\land \ca(\rid) = \kap'
		\land \kap \leq \kap'
		\land (\ls_1, \ls_2) \in \inter(\kap)
	}
\]
%\sx{Do we want to say we only pick those interference \( (\ls_{1} , \ls_{2}) \) that the fingerprints in \( \ls_{1} \) are all empty sets.
%I define the chain of interference in definition \ref{def:intf-for-trans}, which allows to specify part of a transaction and chain them up.
%I have feel it is not necessary as when lifting up the pre-condition, we tagged all locations with empty fingerprints.}
%\azalea{It is not necessary. The only thing rely is used for is the definition of stability for worlds below. In the definition of stability, we lift normal worlds to fingerprint worlds with empty fingerprints.

%It is similarly not needed in the definition of guarantee: the only thing guarantee is used for is the definition of repartitioning (when you commit a transaction) which again lifts normal worlds to fingerprint worlds with empty fingerprints.}
% 
The \emph{extension rely} relation, $\relyE: \FPWorlds \times \FPWorlds$, is defined as follows:
%
\[	
	\relyE \eqdef
	\myset{
		\big((\ls, \fpgs), (\ls, \fpgs')\big)	
	}{
		\exsts{\rid}
		\dom(\fpgs') \setminus \dom(\fpgs) = \{\rid\} \\
		\qquad \land\ \for{\rid'} \rid \ne \rid' \Rightarrow \fpgs(\rid') = \fpgs'(\rid') \\
	}
\]
% 
%The \emph{rely} relation, $\myrely: \FPWorlds \times \FPWorlds$, is defined as follows:
%%
%\[
%	\myrely \eqdef (\relyU \cup \relyE)^{*} %{\scalebox{1.1}{*}}
%\]
%%
%where $*$ denotes the reflexive transitive closure of the relation.
The \emph{rely} relation, $\myrely: \FPWorlds \times \FPWorlds$, is defined as follows:
%
\[
\begin{array}{l @{\hspace{10pt}} r @{\hspace{2pt}} l}
	& \myrely \eqdef & \bigcup\limits_{n \in \Nat} R_n \\
	\text{with } & R_0 \eqdef & (\relyU \cup \relyE)^{*} %{\scalebox{1.1}{*}}
	\qqquad 
	R_{n {+} 1} \eqdef (R_n \cup \mergeR{R_n})^{*} \\
	\text{and} & \mergeR{S} \eqdef 
	& \myset{(\fpw, \fpw')}{
		\exsts{\fpw_1, \fpw_2} (\fpw, \fpw_1) \in S \land (\fpw, \fpw_2) \in S \land \fpw' \in \mergeWAux{\fpw}{\fpw_1}{\fpw_2}}
\end{array}
\]
%
where $*$ denotes the reflexive transitive closure of the relation.

%\sx{
    %Transitive closure is not enough for rely.
    %It should be closed also under merge, considering the environment can runs transactions concurrently.
    %Even that might be very tricky.
    %We find a tricky case, for 3 transactions, t1:[write(x,1)], t2:[write(y,2)], and t3:[write(x,3)].
    %We use s() for start and e() for end.
    %The tricky trace is: [s(t1), s(t2), e(t1), s(t3), e(t2), e(t3)], which gives the final result x=3 and y=2.
    %In this case, t2 merges with t1 and t3 respectively, but t3 is strictly after t1, yet t1 and t2 take the same snapshot but t3 takes a snapshot only have the effect from t1 but not t2.
%}
%\azalea{Shale, I think we discussed and resolved this by generalising the definition of rely to include merging. If you're happy, please remove your comment above.}
%
A set of fingerprint worlds $W \in \World$ is \emph{stable}, written $\stable{W}$, if and only if it is closed under the rely relation: 
%
\[
	\stable{W} \eqdef \for{\world \in W} \for{\fpw'} (\lift{\world}, \fpw') \in \myrely \Rightarrow \erase{\fpw'} \in W
\]
%
The \emph{update guarantee} relation, $\guarU: \FPWorlds \times \FPWorlds$, is defined as follows:
%
\[	
	\guarU \eqdef
	\myset{
		\big((\ls, \fpgs), (\ls', \fpgs')\big)	
	}{
		\orth{(\lsCAP{\flatten{(\ls, \fpgs)}})} = \orth{(\lsCAP{\flatten{(\ls', \fpgs')}})}  \\
		\land \Big(\for{\rid} \fpgs(\rid) = \fpgs'(\rid) \\
		\;\quad \lor \big(
			\orth{(\lsFPH{\flatten{(\ls, \fpgs)}})} = \orth{(\lsFPH{\flatten{(\ls', \fpgs')}})}
			\land \exsts{\rid, \ca, \kap, \kap', \ls_1, \ls_2, \ls_f}\\
				\qqquad \for{\rid'} \rid \ne \rid' \Rightarrow \fpgs(\rid') = \fpgs'(\rid') \\
				\qqquad \land\ \fpgs(\rid) = (\ls_1 \composeLS \ls_f, \inter) \land \fpgs'(\rid) = (\ls_2 \composeLS \ls_f, \inter)		 \\
				\qqquad \land\ (\unitFP, \ca) \leq \ls 
				\land \ca(\rid) = \kap'
				\land \kap \leq \kap'
				\land (\ls_1, \ls_2) \in \inter(\kap)
			\big)	
		\Big)	
	}
\]
% 
The \emph{extension guarantee} relation, $\guarE: \FPWorlds \times \FPWorlds$, is defined as follows:
%
\[	
	\guarE \eqdef
	\myset{
		\big((\ls_1 \composeLS \ls_2, \fpgs), (\ls_1 \composeLS (\unitFP, \ca_1), \fpgs')\big)	
	}{
		\exsts{\rid}
		\dom(\fpgs') \setminus \dom(\fpgs) = \{\rid\} \\
		\qquad \land\ \for{\rid'} \rid \ne \rid' \Rightarrow \fpgs(\rid') = \fpgs'(\rid') \\
		\qquad \land\ \fpgs'(\rid) = \ls_2 \composeLS (\unitFP, \ca_2)
		\land \dom(\ca_1) = \dom(\ca_2) = \{\rid\}
	}
\]
% 
The \emph{guarantee} relation, $\myguar: \FPWorlds \times \FPWorlds$, is defined as follows:
%
\[
	\myguar \eqdef (\guarU \cup \guarE)^{\scalebox{1.1}{*}}
\]
%
\end{definition}
%
%
%\begin{definition}[Fingerprint worlds merge]
%Given the set of fingerprint worlds $\FPWorlds$ (\defin\ref{def:fingerprint_worlds}), the \emph{merge} function, $\mergeW{.}{.}: \FPWorlds \times \FPWorlds \rightarrow \powerset{\FPWorlds}$, is defined as follows, for all $\fpw, \fpw' \in \FPWorlds$:
%%
%\[
%	\mergeW{\fpw}{\fpw'} \eqdef \bigcup\limits_{\fpw'' \in \myrely(\fpw)} \mergeWAux{\fpw}{\fpw'}{\fpw''}
%\]
%%
%where
%%
%\[
%	\mergeWAux{(-, \fpgs)}{(\ls_1, \fpgs_1)}{(-, \fpgs_2)} \eqdef 
%	\begin{cases}
%		\emptyset & \text{if } \exsts{\rid} \conflict{\fpgs(\rid)}{\fpgs_1(\rid)}{\fpgs_2(\rid)} \\
%		& \qqquad \lor\ \rid \in \dom(\fpgs_1) \land \rid \in \dom(\fpgs_2) \land \rid \not\in \dom(\fpgs) \\\\
%		S & \text{otherwise}
%	\end{cases}
%\]
%%
%with
%\[
%	S = \myset{(\ls_1, \fpgs_3)}{
%		\dom(\fpgs_3)= \dom(\fpgs_1) \cup \dom(\fpgs_2) \land \for{\rid}\\
%		\quad \rid \in \dom(\fpgs_1) \land \rid \in \dom(\fpgs_2) \Rightarrow \fpgs_3(\rid) \in \mergeLS{\fpgs(\rid)}{\fpgs_1(\rid)}{\fpgs_2(\rid)} \\
%		\quad \land\ \rid \in \dom(\fpgs_1) \land \rid \not\in \dom(\fpgs_2) \Rightarrow 	\fpgs_3(\rid) = \fpgs_1(\rid) \\
%		\quad \land\ \rid \not\in \dom(\fpgs_1) \land \rid \in \dom(\fpgs_2) \Rightarrow 	\fpgs_3(\rid) = \fpgs_2(\rid)
%	}
%\]
%\end{definition}
%%
%
\begin{definition}[Repartitioning]
\[
	\mrepartition{W_1 }{W_2}{\mathbf{H_1}}{\mathbf{H_2}} \; \iffdef \;
	\begin{array}[t]{@{} l @{}}
		\for{\world_1 \in W_1} \exsts{\fpw_1, \fph_1, \fph}\\
		\quad \fpw_1 = \lift{\world_1} \land \flatten{\fpw_1} = (\fph_1 \composeFP \fph, \unitC) \land \fph_1 \in \mathbf{H_1} \\
		\quad \land\ \for{\fph_2 \in \mathbf{H_2}} \exsts{\world_2, \fpw_2} \\
		\qquad \flatten{\fpw_2} = (\fph_2 \composeFP \fph, \unitC) \land (\fpw_1, \fpw_2) \in \myguar \land \erase{\fpw_2} = \world_2 \land \world_2 \in W_2 \\
		\qquad \land\ \for{\fpw_3 \in \mergeW{\fpw_1}{\fpw_2}} \erase{\fpw_3} \in W_2
	\end{array}
\]
with, $\mergeW{.}{.}: \FPWorlds \times \FPWorlds \rightarrow \powerset{\FPWorlds}$, defined as follows, for all $\fpw, \fpw' \in \FPWorlds$:
%
\[
	\mergeW{\fpw}{\fpw'} \eqdef \bigcup\limits_{\fpw'' \in \myrely(\fpw)} \mergeWAux{\fpw}{\fpw'}{\fpw''}
\]
%
\end{definition}
