\section{Proof of semantics\label{sec:proof_semantics}}
\begin{lem}
    \label{lem:no-over-write}
    A history cannot be overwritten, i.e.\ \( \forall \tshp, \tshp', \loc, \ts \ldotp ( \tshp, \dontcare ) \globaltransfer{\dontcare} ( \tshp', \dontcare ) \implies \tshp(\loc)(\ts) \subseteq \tshp'(\loc)(\ts)\)
\end{lem}
\begin{proof}
    Induction on the semantics.
    Except the \emph{commit}, the rest is trivial.
    From the \texttt{wellformhist}, a new transition must pick a starting time and a ending time that have no event for those locations touched.
\end{proof}

\begin{lem}
    \label{lem:start-before-end}
    \label{lem:read-before-write}
    All the reads of a transaction happen before all the writes. 
    This is 
    \( \forall \tshp, \loc, \loc', \ts, \ts', \tsid \ldotp \tshp(\loc)(\ts) = (\dontcare, \rop, \tsid) \land \tshp(\loc')(\ts') = (\dontcare, \wop, \tsid) \implies \ts < \ts' \).
\end{lem}
\begin{proof}
    From the \emph{commit} that \( \ts_{s} < \ts_{e} \).
\end{proof}

\begin{lem}
    \label{lem:atoic-rw}
    A transaction's reads and starts operations among all locations happen in the same time, so do all the writes and ends operations. This is 
    \( \forall \tshp, \loc, \loc', \ts, \ts', \tsid, \op, \op'\ldotp \tshp(\loc)(\ts) (\dontcare, \op, \tsid)  \land \tshp(\loc')(\ts') = (\dontcare, \op', \tsid) \land (\op, \op' \in \Set{\sop, \rop} \lor \op, \op' \in \Set{\eop, \wop} ) \implies \ts = \ts' \).
\end{lem}
\begin{proof}
    Given Lemma \ref{lem:no-over-write}, induction on semantics.
    The \emph{commit} is by the \(\func{commitTrans}\), the rest is trivial.
\end{proof}


\begin{defn}
Session order \( \so \), or program order.
\[ 
    \begin{rclarray}
        lc \in \texttt{LastCommit} & \defeq & \Threadid \parfun \powerset{\Transid} \\
        \func{sessionOrder}^{0}(\tshp_{init}, \tdpl_{init}) & \defeq & \Set{(\emptyset, \emptyset, \tshp_{init}, \tdpl_{init}, \emptyset)} \\
        \func{sessionOrder}^{\nat}(\tshp_{init}, \tdpl_{init}) & \defeq & 
        \Set{(\settrans, \so, \tshp, \tdpl \uplus \Set{\thid \mapsto \dontcare}, lc) \middle|
            \begin{array}{@{}l@{}}
                \exists \settrans', \so', \tshp', \tdpl', lc', \tll \ldotp \\
                (\settrans', \so', \tshp', \tdpl' \uplus \Set{\thid \mapsto \dontcare}, lc') \in {} \\
                \qquad \func{sessionOrder}^{\nat -1}(\tdpl_{init}, \tshp_{init}) \land {} \\
                ( \tshp', \tdpl' \uplus \Set{\thid \mapsto \dontcare}) \globaltransfer{\tll} ( \tshp, \tdpl \uplus \Set{\thid \mapsto \dontcare}) \land {} \\
                \tll = \lid \implies \\
                \begin{formulea}
                    \settrans = \settrans' \land \so = \so' \land \tdpl = \tdpl' \land lc = lc'
                \end{formulea} \land {} \\
                \exists \tsid \ldotp \tll = \lcmt{\tsid} \implies  \\
                \begin{formulea}
                    \settrans = \settrans' \uplus \Set{\tsid} \land {} \\
                    \so = \so' \uplus \Set{(\tsid', \tsid) \middle| \tsid' \in lc'(\thid)} \land {} \\
                    \tdpl = \tdpl' \land lc = lc'\remapsto{\thid}{\Set{\tsid}}
                \end{formulea} \land {} \\
                \exists \thid' \ldotp \tll = \lfork{\thid', \dontcare} \implies  \\
                \begin{formulea}
                    \settrans = \settrans' \land \so = \so' \land \tdpl = \tdpl' \uplus \Set{\thid' \mapsto \dontcare } \land {} \\
                    lc = lc' \uplus \Set{\thid' \mapsto lc'(\thid)}
                \end{formulea} \land {} \\
                \exists \thid'' \ldotp \tll = \ljoin{\thid'', \dontcare} \implies  \\
                \begin{formulea}
                    \settrans = \settrans' \land \so = \so' \land \tdpl = \tdpl' \uplus \Set{\thid'' \mapsto \dontcare } \land {} \\
                    lc = lc'\remapsto{\thid}{lc'(\thid) \uplus lc'(\thid'')} \setminus \Set{\thid'' \mapsto \dontcare}
                \end{formulea} \land {} \\
            \end{array}
        } \\
        \func{histories}(\tshp_{init}, \tdpl_{init}) & \defeq & \Set { (\settrans,\so,\tshp) \middle| (\settrans,\so,\tshp, \dontcare, \dontcare) \in  \bigcup\limits_{\nat \in \Nat } \func{sessionOrder}^{\nat}(\tshp_{init}, \tdpl_{init}) }
    \end{rclarray}
\]
\end{defn}

%\begin{lem}
    %Transactions ordered by session order \( \so \) appear in the same order in the time-stamp heap, i.e.\ \( \forall \tshp_{init}, \tdpl_{init}, (\settrans, \so, \tshp) \in \func{histories}(\tshp_{init}, \tdpl_{init}), \tsid, \tsid' \in \settrans, \loc \ldotp \exists \ts, ts' \ldotp \tshp(\loc)(\ts) = (\dontcare, \dontcare, \tsid) \land \tshp(\loc)(\ts') = (\dontcare, \dontcare, \tsid') \implies \ts < \ts' \)
%\end{lem}
%\begin{proof}
    %From the definition of session order and the semantics, especially \emph{commit}, \emph{seqnoskip}, \emph{par} and \emph{wait}.
%\end{proof}

\begin{defn}
    Visibility and potential arbitration relations.
    \[
        \begin{rclarray}
            \func{graph}(\settrans,\so,\tshp) & \defeq & (\settrans,\so,\vis,\tar) \\
                                              & & \texttt{where} \ \vis \defeq \Set{(\tsid,\tsid') \in \settrans \middle| 
            \begin{array}{@{}l@{}}
                \exists \loc, \loc', \ts, \ts', \op \in \Set{\wop,\eop}, \op' \in \Set{\rop,\sop} \ldotp \ts < \ts' \land {} \\
                \tshp(\loc)(\ts) = (\dontcare, \op,\tsid) \land \tshp(\loc')(\ts') = (\dontcare, \op',\tsid') 
            \end{array} } \\
                                              & & \quad \qquad \tar \defeq \Set{(\tsid,\tsid')  \in \settrans \middle| 
            \begin{array}{@{}l@{}}
                \exists \loc, \loc', \ts, \ts', \op, \op' \in \Set{\wop,\eop} \ldotp \ts < \ts' \land {} \\
                \tshp(\loc)(\ts) = (\dontcare, \op,\tsid) \land \tshp(\loc')(\ts') = (\dontcare, \op',\tsid') 
            \end{array} }
        \end{rclarray}
    \]
\end{defn}

%\begin{lem}
    %\label{lem:lc-latest}
    %In the definition of \( \func{sessionOrder} \), the \( lc \) records the latest committed transaction(s) of each thread.
%\end{lem}
%\begin{proof}
    %Induction on the number \( n \).

    %Case \( n = 0 \). 
    %There is no running thread and \( lc \) is undefined for all thread identifier \( \thid \).

    %Case \( n > 0 \). 
    %Assume when \( n - 1\) and \( (\settrans', \so', \tshp', \tdpl' \uplus \Set{\thid \mapsto \dontcare}, lc') \in \func{sessionOrder}^{\nat - 1}(\tdpl_{init}, \tshp_{init}) \), the \( lc' \) records the latest committed transactions.
    %Now we need to check \( n \).
    %We consider different \( \tll \), where \(( \tshp', \tdpl' \uplus \Set{\thid \mapsto \dontcare}) \globaltransfer{\tll} ( \tshp, \tdpl \uplus \Set{\thid \mapsto \dontcare}) \)

    %Sub-case \( \tll  = \actid \).
    %The program state does not change, and \( lc = lc' \).

    %Sub-case \( \tll = \lcmt{\tsid}\).
    %For the thread \( \thid \) that commits a new transaction \( \tsid \), given the semantics, the new transaction must pick a time greater all the transactions within the same thread.
    %Thus, the new \( lc = lc'\remapsto{\thid}{\Set{\tsid}} \).

    %Sub-case \( \tll = \lfork{\thid', \dontcare} \). 
    %The initial time of the new thread \( \thid' \) is the time of its parent thread, so the latest committed transactions of the new thread \( \thid' \) should be the same as its parent thread.
    %Thus, the new \( lc = lc' \uplus \Set{\thid' \mapsto lc'(\thid)} \).

    %Sub-case \( \tll = \ljoin{\thid'', \dontcare} \). 
    %Given the semantics, the thread \( \thid'' \) reduces all its transactions and return its local time to the parent thread \( \thid \).
    %The parent thread updates the time to the maximum between itself and the time returned from the child thread, so the latest committed transactions of the parent thread should include those from the child thread.  
    %Thus, the new \( lc = lc'\remapsto{\thid}{lc'(\thid) \uplus lc'(\thid'')} \setminus \Set{\thid'' \mapsto \dontcare} \).
%\end{proof}

\begin{lem}
    \label{lem:happen-in-same-time}
    The read/start operations of all the needed locations happen in the same time, so do write/end operations.
    This is \( \forall \tshp, \tsid, \loc, \loc', \ts, \ts', \op, \op' \ldotp ( \op, \op' \in \Set{\rop,\sop} \lor \op, \op' \in \Set{\wop,\eop} ) \land \tshp(\loc)(\ts) = (\dontcare, \op, \tsid) \land  \tshp(\loc')(\ts') = (\dontcare, \op', \tsid) \implies \ts = \ts' \)
\end{lem}
\begin{proof}
    Derive from \( \func{commitTrans} \) from the semantics.
\end{proof}

\begin{lem}[Session]
    \( \so \subseteq \vis \), for some \( \settrans \) and \( \tshp\), such that \( \func{graph}(\settrans,\so,\tshp) = (\settrans,\so,\vis,\dontcare ) \).
\end{lem}   
\begin{proof}
    Given the definition of \( \func{sessionOrder} \), assume a sequence of \( \so_n \), each of which represents the result of the \( n \)-steps \(\func{sessionOrder} \), so \( \so = \bigcup\limits_{n} \so_n \land \forall n, n' \ldotp n < n' \implies \so_n \subseteq \so_{n'} \).
    Therefore, if \( ( \tsid , \tsid' ) \in \so \), there must exist a \( n \) that \( ( \tsid , \tsid' ) \notin \so_{n-1} \) but \( ( \tsid , \tsid' ) \in \so_{n} \).
    This means there exists \( lc \) for same thread \( \thid \), such that \( \tsid \in lc(\thid) \).
    Since the \( lc \) is a partial function that records the last committed transactions of each thread.
    Note that if there is a new thread, it records the last committed transactions of its parent thread, while if it is a join point, it records both the parent and child last committed transactions.
    Then if the new transaction \( \tsid' \) commits, it must pick a starting time greater than any transactions included in \( lc(\thid) \).
    Assuming the time-stamp heap \( \tshp \) after the new transaction \( \tsid' \) committing and by the Lemma \ref{lem:happen-in-same-time}, we have \( \forall \loc, \loc', \ts, \ts', \op \in \Set{\wop,\eop}, \op' \in \Set{\rop,\sop} \ldotp \tshp(\loc)(\ts) = (\dontcare, \op, \tsid) \land \tshp(\loc')(\ts') = (\dontcare, \op', \tsid') \implies \ts < \ts' \), which implies \( (\tsid, \tsid') \in \so \).
\end{proof}

\begin{lem}[prefix]
    \label{lem:prefix}
    \( \tar; \vis \subseteq \vis \), for some \( \settrans, \so \) and \( \tshp\), such that \( \func{graph}(\settrans,\so,\tshp) = (\settrans,\so,\vis,\tar ) \).
\end{lem}
\begin{proof}
    For all \( \tsid, \tsid', \tsid'' \), if \( (\tsid, \tsid') \in \tar \) and \( (\tsid', \tsid'') \in \vis \), by the definitions of \( \so \) and \( \vis \), the commit time of \( \tsid' \) is greater than the one of \( \tsid \) but smaller than the start time of \( \tsid'' \).
    Thus there must exist \( \loc, \loc'', \ts, \ts' , \ts'', \op \in \Set{\wop, \eop}  \) and \( \op'' \in \Set{\rop, \sop } \) such that  \( \tshp(\loc)(\ts) = (\dontcare, \op, \tsid) \), \( \tshp(\loc'')(\ts'') = (\dontcare, \op'', \tsid'') \) and \( \ts < \ts'' \), thus \( ( \tsid, \tsid'' ) \in \vis \).
\end{proof}

\begin{lem}[nocoflict]
    \label{lem:nocoflict}
    Two transactions cannot concurrently write to the same location, this means that one must observe another one.
    This is \( \forall \loc, \tsid, \tsid' \ldotp \tshp(\loc)(\dontcare) = (\dontcare, \wop, \tsid) \land  \tshp(\loc)(\dontcare) = (\dontcare, \wop, \tsid' ) \implies ((\tsid, \tsid') \in \vis \lor (\tsid', \tsid) \in \vis ))\), for some \( \settrans, \so \) and \( \tshp\), such that \( \func{graph}(\settrans,\so,\tshp) = (\settrans,\so,\vis,\dontcare ) \).
\end{lem}
\begin{proof}
    Prove by contradiction.
    Assume \( (\tsid, \tsid') \notin \vis \land (\tsid', \tsid) \notin \vis \), this intuitively means one transaction is overlapped with another.
    Let \( \ts_{s}, \ts_{e}, \ts'_{s} \) and \( \ts'_{e} \) be the start time and end time of transaction \( \tsid \) and \( \tsid' \) respectively.
    Because of the symmetric,  we can assume that the start time of \( \tsid \) is in between \( \tsid' \), witch means \( \ts'_{s} < \ts_{s} < \ts'_{e} \).
    Now we consider \( \ts_{e} \).
    First note that \( \ts_{e} > \ts_{s} \) by Lemma \ref{lem:start-before-end}, therefore we need to consider two cases \( \ts'_{s} < \ts_{s} < \ts_{e} < \ts'_{e} \) and  \( \ts'_{s} < \ts_{s} < \ts'_{e} < \ts_{e}  \).
    Since both transaction write the same location \( \loc \), those two cases violate the \( \pred{consist} \) requirement in the semantics, so one of the transactions must pick another start and end time.
\end{proof}

\begin{lem}[ext]
    \label{lem:ext}
    A transaction should read the last values it can observe.
    This means that for all transaction \( \tsid \) and heap location \( \loc \), if the transaction read a value \( \val \) from the location, i.e.\ \( \exists \ts \ldotp \tshp(\loc)(\ts) = (\val, \rop, \tsid) \), the last transaction \( \tsid' \) who writes to the same location and can be observe by \( \tsid \), i.e.\ \( (\tsid, \tsid') \in \vis\), should have written the same value, meaning \( \exists \val', \ts' \ldotp \tshp(\loc)(\ts') = (\val', \wop, \tsid') \implies \val' = \val\)
\end{lem}
\begin{proof}
    Given the definition of \( \vis \), we have \( \ts' < \ts \).
    Because transaction \( \tsid' \) is the last one who write to the location, this means that \( \forall \tsid'', \ts'', \op'' \ldotp \tshp(\loc)(\ts'') = (\dontcare, \op'', \tsid'') \implies \op'' \neq \wop \).
    Thus by the \( \func{startstate} \) in the semantics, we have \( \val' = \val \).


\begin{lem}[acyclic]
    \label{lem:acyclic_relations}
    Both \( \vis \) and \( \tar \) are acyclic.
\end{lem}
\begin{proof}
    Proof by contradiction.
    Assume there are transactions from \( \tsid_{0} \) to \( \tsid_{n} \)  for some \( n \) that form a circle by \( \vis \) relation.
    By Lemma \ref{lem:atoic-rw}, let \( \ts^{s}_{i} \) and \( \ts^{e}_{i} \) be the start time and end time of the transaction \( \tsid_{i} \) respectively.
    By Lemma \ref{lem:read-before-write}, we have \( \ts^{s}_{i} < \ts^{e}_{i} \), and by definition of \( \vis \), thus \( \ts^{e}_{i} < \ts^{s}_{(i+1)\mod n} \).
    Therefore, \( \ts^{s}_{0} < \ts^{e}_{0} < \ts^{s}_{1} < \dots <  \ts^{e}_{n} < \ts^{s}_{0} \), so we have contradiction.

    Similarly for \( \tar \), we have contradiction that \( \ts^{e}_{0} < \ts^{e}_{1} < \dots  < \ts^{e}_{n} < \ts^{e}_{0} \).
\end{proof}

\begin{lem}[totalorder]
    The arbitration relations \( \tar \) can be extended to a total order \( \ar \) that does not violate Lemma \ref{lem:prefix}, Lemma \ref{lem:ext} and Lemma \ref{lem:acyclic_relations}.
\end{lem}
\begin{proof}
    We construct \( \ar \) from \( \tar \).
    Assume there is an initialisation transaction \( \tsid_{init} \) that happens before all other transactions, which means \( \forall \tsid \in \settrans \ldotp (\tsid_{init} , \tsid ) \in \tar\).
    Now we extend \( \tar \) until it is a total order.
    Let \( \tar_{0} = \tar \), and clearly \( \tar_{0} \) satisfies those Lemmas.

    Now assume that we have \( \tar_{n} \) for some \( n \) that satisfies Lemma \ref{lem:prefix}, Lemma \ref{lem:ext} and Lemma \ref{lem:acyclic_relations}.
    We pick first two transactions \( \tsid_{1} \) and \( \tsid_{2} \) that satisfies the following.
    First, if a transaction can reach \( \tsid_{1} \), it also can reach \( \tsid_{2} \), and vice versa, \( \forall \tsid \in \settrans \uplus \Set{\tsid_{init}} \ldotp (\tsid, \tsid_{1}) \in \tar_{n} \iff (\tsid, \tsid_{2}) \in \tar_{n} \).
    Second, let \( \mathcal{S} \) be the set of such transactions, we requires it is a strict total order with respect to \( \tar_{n} \), i.e.\ \( \forall \tsid, \tsid' \in \mathcal{S} \ldotp (\tsid,\tsid') \in \tar_{n} \lor (\tsid',\tsid) \in \tar_{n}  \).
    Intuitively, \( \tsid_{1} \) and \( \tsid_{2} \) is a branching point since \( \tsid_{init} \) with respect to \( \tar_{n} \).

    Immediately, there are two important properties of the transactions.
    Since that each step we add a new relations, so \( \vis \subseteq \tar \subseteq \tar_{0} \subseteq \dots \subseteq \tar_{n} \).
    Therefore, given \( ( \tsid_{1}, \tsid_{2} ) \notin \tar \land ( \tsid_{2}, \tsid_{1} ) \notin \tar \) and Lemma \ref{lem:atoic-rw}, these two transactions write locations in exactly the same time and given \( ( \tsid_{1}, \tsid_{2} ) \notin \vis \land ( \tsid_{2}, \tsid_{1} ) \notin \vis \) and the contrapositive of Lemma \ref{lem:nocoflict}, the transactions must write different locations.
    Now we claim that we can extend \( \tar_{n} \) by arbitrarily adding a relation between the two transactions and then taking the transitive closure, for instance \( \tar_{n+1} = ( \tar_{n} \uplus \Set{(\tsid_{1}, \tsid_{2})} )^{+}  \), and this new \( \tar_{n+1} \) still satisfies Lemma \ref{lem:prefix}, Lemma \ref{lem:ext} and Lemma \ref{lem:acyclic_relations}.

    Lemma \ref{lem:prefix}  holds, because \( \tsid_{1} \) and \( \tsid_{2} \) commit at the same time, so \( \forall \tsid \ldotp (\tsid_{1}, \tsid) \in \vis \iff  (\tsid_{2}, \tsid) \in \vis \).
    Then, by the assumption \( \tar_{n} ; \vis \subseteq \vis \), we have \( \tar_{n+1} ; \vis \subseteq \vis \).

    Lemma \ref{lem:ext} holds because \( \tsid_{1} \) and \( \tsid_{2} \) write different locations.
    Therefore, even though there is a new relation \( (\tsid_{1}, \tsid_{2}) \), the transaction \( \tsid_{2} \) still reads the newest values it can observe.
    Similarly for those transactions who depends on the values written by \( \tsid_{1} \), they still read the newest values they can observe.
                                                   
    Note that \( \vis \) remains the same some we only need to check \( \tar_{n+1} \).
    Assume that the new relation intrudes a circle, this circle must contain \( \tsid_{1} \) and \( \tsid_{2} \), for instance \( \tsid, \dots \tsid_{1}, \tsid_{2}, \dots \tsid' \).
    Given how we pick \( \tsid_{1} \) and \( \tsid_{2} \), all the transactions before \( \tsid_{1} \) in the circle also can reach \( \tsid_{2} \).
    This means \( \tsid, \dots \tsid_{1}, \dots \tsid' \) is also a circle, which contradict with assumption that \( \tar_{n} \) has no circle.
\end{proof}

%Now we need to recover \( \ww \), \( \wr \) and \( \rw \) from \( \tshp \).
%We need to prove that there is no circle that does not contain contain adjacent \( \rw \).
%By contradiction, if such circle exists, we can prove that the time goes backward in the circle.
                                                                          
%\[
    %\begin{rclarray}
        %\func{graph}(\settrans, \so, \tshp) & \defeq & (\settrans, \so, \wr, \ww, \rw) \\
                                            %& & \texttt{where} \ \forall \tsid, \tsid' \in \settrans \ldotp \tsid \neq \tsid' \land \exists \loc, \ts, \ts' > \ts \ldotp  \\
                                            %& & (\tsid, \tsid') \in \wr \implies  \ts = \max(\Set{\ts'' \middle| \ts'' < \ts }), \val \ldotp \tshp(\loc)(\ts) = (\dontcare,\wop,\tsid) \land \tshp(\loc)(\ts') = (\dontcare,\rop,\tsid') \land {} \\
                                            %& & (\tsid, \tsid') \in \ww \implies \tshp(\loc)(\ts) = (\dontcare,\wop,\tsid) \land \tshp(\loc)(\ts') = (\dontcare,\wop,\tsid') \land {} \\
                                            %& & (\tsid, \tsid') \in \rw \implies \tshp(\loc)(\ts) = (\dontcare,\rop,\tsid) \land \tshp(\loc)(\ts') = (\dontcare,\wop,\tsid') 
    %\end{rclarray}
%\]

%\begin{lem}
    %Given two transactions, \( \tsid_{1} \), \( \tsid_{2} \) and \( \tsid_{3} \), if there is a relation between \( \tsid_{1} \) and \( \tsid_{2} \), so does \( \tsid_{2} \) and \( \tsid_{3} \), and at least one of these two relations is not a read-write relation, then the time, associated with the events that determines the orders, strictly increases.

    %The ABOVE NOT REALLY DESCRIBE THE PROPERTY!!! BUT LEAVE IT FOR NOW. BECAUSE MIGHT CHANGE THE PROOF STRATEGY.

    %This is, given \( (\settrans, \so, \wr, \ww, \rw) \) generated from \( \tshp \), it satisfies the following property:
     
    %\[
        %\begin{array}{@{}l@{}}
            %\forall \tsid_{1}, \tsid_{2},\tsid_{3} \in \settrans \ldotp \exists \tll, \tll' \in \Set{\so, \wr, \ww, \rw}, \loc_{1}, \loc_{2}, \loc_{3}, \ts_{1}, \ts_{2}, \ts_{3}, \op_{1}, \op_{2}, \op_{3} \ldotp  (\tsid_{1}, \tsid_{2}) \in \tll \land (\tsid_{2}, \tsid_{3}) \in \tll' \land {} \\
            %\tshp(\loc_{1})(\ts_{1}) = (\dontcare, \op_{1}, \tsid_{1}) \land \tshp(\loc_{2})(\ts_{2}) = (\dontcare, \op_{2}, \ts_{2}) \land \tshp(\loc_{3})(\ts_{3}) = (\dontcare, \op_{3}, \ts_{3}) \land \ts_{1} < \ts_{2} < \ts_{3} \land {} \\
            %\tll = \so \land \tll' = \so \implies \loc_{2} = \loc_{3} \land \op_{1}, \op_{2}, \op_{3} \in \Set{\wop, \rop} \land {} \\
            %\tll = \so \land \tll' = \ww \implies \loc_{2} = \loc_{3} \land \op_{1} \in \Set{\wop, \rop} \land \op_{2} = \op_{3} = \wop \land {} \\
            %\tll = \so \land \tll' = \wr \implies \loc_{2} = \loc_{3} \land \op_{1} \in \Set{\wop, \rop} \land \op_{2} = \wop \land \op_{3} = \rop \land {} \\
            %\tll = \so \land \tll' = \rw \implies \loc_{2} = \loc_{3} \land \op_{1} \in \Set{\wop, \rop} \land \op_{2} = \rop \land \op_{3} = \wop \land {} \\
            %\tll = \ww \land \tll' = \so \implies \loc_{1} = \loc_{2} \land \op_{1} = \op_{2} = \wop \land \op_{3} \in \Set{\wop, \rop} \land {} \\
            %\tll = \ww \land \tll' = \ww \implies \loc_{1} = \loc_{2} \land \op_{1} = \op_{2} = \op_{3} = \wop \land {} \\
            %\tll = \ww \land \tll' = \wr \implies \loc_{1} = \loc_{2} \land \op_{1} = \op_{2} = \wop \land \op_{3} = \rop \land {} \\
            %\tll = \ww \land \tll' = \rw \implies \loc_{2} = \loc_{3} \land \op_{1} = \wop \land \op_{2} = \rop \land \op_{3} = \wop \land {} \\
            %\tll = \wr \land \tll' = \so \implies \loc_{1} = \loc_{2} \land \op_{1} = \wop \land \op_{2} = \rop \land \op_{3} \in \Set{\wop, \rop} \land {} \\
            %\tll = \wr \land \tll' = \ww \implies \loc_{2} = \loc_{3} \land \op_{1} = \op_{2} = \op_{3} = \wop \land {} \\
            %\tll = \wr \land \tll' = \wr \implies \loc_{2} = \loc_{3} \land \op_{1} = \op_{2} = \wop \land \op_{3} = \rop {} \\
            %\tll = \wr \land \tll' = \rw \implies \loc_{2} = \loc_{3} \land \op_{1} = \wop \land \op_{2} = \rop \land \op_{3} = \wop \land {} \\
            %\tll = \rw \land \tll' = \so \implies \loc_{1} = \loc_{2} \land \op_{1} = \rop \land \op_{2} = \wop \land \op_{3} \in \Set{\wop, \rop} \land {} \\
            %\tll = \rw \land \tll' = \ww \implies \loc_{2} = \loc_{3} \land \op_{1} = \rop \land \op_{2} = \op_{3} = \wop \land {} \\
            %\tll = \rw \land \tll' = \wr \implies \loc_{2} = \loc_{3} \land \op_{1} = \rop \land \op_{2} = \wop \land \op_{3} = \rop 
        %\end{array}
    %\]
%\end{lem}
%\begin{proof}

%\end{proof}
