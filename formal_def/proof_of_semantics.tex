\section{Semantics\label{sec:proof_semantics}}
\subsection{Soundness of the time-stamp semantics}
\begin{lem}[No overwrite]
    \label{lem:no-over-write}
    For a given location and time, if there is a value, threads cannot overwrite the values.
    \[ 
        \for{ \stk, \stk', \tshp, \tshp', \ts, \ts', \iprog, {\iprog}' ,\lb,\loc, \ts } 
        ( \stk, \tshp, \ts ), \iprog \toT{\lb} ( \stk', \tshp', \ts' ), {\iprog}'
        \implies \tshp(\loc)(\ts)\undef \lor \tshp(\loc)(\ts) = \tshp'(\loc)(\ts)
    \]
\end{lem}
\begin{proof}
    Prove by structural induction on the semantics.
    For base cases \rl{PChoiseLeft}, \rl{PChoiseRight}, \rl{PLoop}, \rl{PSeqSkip}, \rl{PPar} and \rl{Pwait}, they are trivial because those rules do not change time-stamp heap, i.e.\ \( \tshp = \tshp' \).
    For base case \rl{Commit}, the new state \( \tshp' = \commit{\tshp}{\fph_{s}}{\fph_{e}}{\tsid}{\ts_{s}}{\ts_{e}} \) for some \( \fph_{s},\fph_{e}, \tsid, \ts_{s},\ts_{e} \).
    For any locations updated by the new transaction \( \tsid \), It must pick times \( \ts_{s} \) and \( \ts_{e} \) when the values of those locations are undefined, because of the constrain \( \cancommitName \), especially the sub-predicate \( \wfhistName \).
    For the inductive case \rl{PSeq}, prove directly by the inductive hypothesis.
\end{proof}

\begin{lem}[Start before end]
    \label{lem:start-before-end}
    \label{lem:read-before-write}
    All the reads/starts operations of a transaction happen before all the writes/ends. 
    Formally,
    \[
        \for{ \stk, \stk', \tshp, \tshp', \ts, \ts', \iprog, {\iprog}' ,\lb } 
        \pred{rw}{\tshp} 
        \land ( \stk, \tshp, \ts ), \iprog \toT{\lb} ( \stk', \tshp', \ts' ), {\iprog}' 
        \implies \pred{rw}{\tshp'}
    \]
    where,
    \[
        \begin{rclarray}
            \pred{rw}{\tshp} & \defeq & 
            \for{ \loc, \loc', \ts, \ts',\etag \in \Set{\etS, \etR}, \etag' \in \Set{\etE,\etW}, \tsid } 
            \tshp(\loc)(\ts) = (\stub, \etag, \tsid) 
            \land \tshp(\loc')(\ts') = (\stub, \etag', \tsid)
            \implies \ts < \ts' 
        \end{rclarray}
    \]
\end{lem}
\begin{proof}
    Prove by structural induction on the semantics.
    For base cases \rl{PChoiseLeft}, \rl{PChoiseRight}, \rl{PLoop}, \rl{PSeqSkip}, \rl{PPar} and \rl{PWait}, they are trivial because those rules do not change time-stamp heap, i.e.\ \( \tshp = \tshp' \).
    For base case \rl{Commit}, the new state \( \tshp' = \commit{\tshp}{\fph_{s}}{\fph_{e}}{\tsid}{\ts_{s}}{\ts_{e}} \) for some \( \fph_{s},\fph_{e}, \tsid, \ts_{s},\ts_{e} \). 
    First by Lemma \ref{lem:no-over-write}, for those transactions in \( \tshp \) it remains the same as in \( \tshp' \).
    Then, the \(\commitName\) function associates \( \etR \) or \( \etS \) to time \( \ts_{s} \), and \( \etW \) or \( \etE \) to \( \ts_{e} \), and \( \ts_{s} < \ts_{e} \), so \( \pred{rw}{\tshp'}\) holds.
    For the inductive case \rl{PSeq}, prove directly by the inductive hypothesis.
\end{proof}

\begin{lem}[Pair of start and end]
    \label{lem:start-end-pair}
    Reads/starts operations are writes/ends operations appear as pairs.
    \[
        \for{ \stk, \stk', \tshp, \tshp', \ts, \ts', \iprog, {\iprog}' ,\lb }
        \pred{pair}{\tshp} 
        \land ( \stk, \tshp, \ts ), \iprog \toT{\lb} ( \stk', \tshp', \ts' ), {\iprog}' 
        \implies \pred{pair}{\tshp'}
    \]
    where,
    \[
        \begin{rclarray}
            \pred{pair}{ \tshp } & \defeq & 
            \for{ \loc, \loc', \ts, \ts',\etag \in \Set{\etS, \etR}, \etag' \in \Set{\etE,\etW}, \tsid } 
            (\tshp(\loc)(\ts) = (\stub, \etag, \tsid) \iff \tshp(\loc')(\ts') = (\stub, \etag', \tsid)  )
        \end{rclarray}
    \]
\end{lem}
\begin{proof}
    Prove by structural induction on the semantics.
    For base cases \rl{PChoiseLeft}, \rl{PChoiseRight}, \rl{PLoop}, \rl{PSeqSkip}, \rl{PPar} and \rl{PWait}, they are trivial because those rules do not change time-stamp heap, i.e.\ \( \tshp = \tshp' \).
    For base case \rl{Commit}, the new state \( \tshp' = \commit{\tshp}{\fph_{s}}{\fph_{e}}{\tsid}{\ts_{s}}{\ts_{e}} \) for some \( \fph_{s},\fph_{e}, \tsid, \ts_{s},\ts_{e} \). 
    First by Lemma \ref{lem:no-over-write}, for those transactions in \( \tshp \) it remains the same as in \( \tshp' \).
    Then the \(\commitName\) function always extends locations with pairs of operations, so \( \pred{rw}{\tshp'}\) holds.
    For the inductive case \rl{PSeq}, prove directly by the inductive hypothesis.
\end{proof}


\begin{lem}[Start/end at the same time]
    \label{lem:atoic-rw}
    \label{lem:happen-in-same-time}
    All the reads/starts operations among all locations of a transaction happen in the same time, so do all the writes/ends operations. 
    \[
        \for{ \stk, \stk', \tshp, \tshp', \ts, \ts', \iprog, {\iprog}' ,\lb } 
        \pred{atom}{\tshp} 
        \land ( \stk, \tshp, \ts ), \iprog \toT{\lb} ( \stk', \tshp', \ts' ), {\iprog}' 
        \implies \pred{atom}{\tshp'}
    \]
    where,
    \[
        \begin{rclarray}
        \pred{atom}{\tshp} & \defeq & 
        \for{ \loc, \loc', \ts, \ts', \tsid, \etag, \etag' }
        \tshp(\loc)(\ts) (\stub, \etag, \tsid) 
        \land \tshp(\loc')(\ts') = (\stub, \etag', \tsid) \\
        & & \land (\etag, \etag' \in \Set{\etS, \etR} \lor \etag, \etag' \in \Set{\etE, \etW} ) 
        \implies \ts = \ts'
        \end{rclarray}
    \]
\end{lem}
\begin{proof}
    Prove by structural induction on the semantics.
    For base cases \rl{PChoiseLeft}, \rl{PChoiseRight}, \rl{PLoop}, \rl{PSeqSkip}, \rl{PPar} and \rl{Pwait}, they are trivial because those rules do not change time-stamp heap, i.e.\ \( \tshp = \tshp' \).
    For base case \rl{Commit}, the new state \( \tshp' = \commit{\tshp}{\fph_{s}}{\fph_{e}}{\tsid}{\ts_{s}}{\ts_{e}} \) for some \( \fph_{s},\fph_{e}, \tsid, \ts_{s},\ts_{e} \). 
    First by Lemma \ref{lem:no-over-write}, for those transactions in \( \tshp \) it remains the same as in \( \tshp' \).
    Then the \( \commitName \) function associates all reads/starts operations, \( \etR \) and \(\etS \), of all locations to the start time \( \ts_{s} \), and writes/ends operations to the end time \( \ts_{e} \), so \( \pred{atom}{\tshp'}\) holds.
    For the inductive case \rl{PSeq}, prove directly by the inductive hypothesis.
\end{proof}

\begin{defn}[Well-form time-stamp heaps]
\label{def:wf-timestamp-heap}
    The well-formedness of time-stamp heap is defined as those satisfying Lemma \ref{lem:start-before-end}, Lemma \ref{lem:start-end-pair} and Lemma \ref{lem:atoic-rw}.
    \[
        \begin{rclarray}
            \wfH{\tshp} & \defeq & \pred{rw}{\tshp} \land \pred{pair}{\tshp} \land \pred{atom}{\tshp} \\
        \end{rclarray}
    \]
\end{defn}

\begin{defn}[Extended Labels]
Given the set of transaction labels \( \Translabel \) (\defin \ref{def:label}) and thread identifiers \( \ThreadID \) (\defin \ref{def:thread_semantics}), the set of extended labels \( \ExtTranslabel \defeq \Nat \times \TransID \times \Translabel \) is defined as follows:
\[
	\ExtTranslabel ::= (\thid,\lbC{\tsid}) \mid (\thid,\lbF{\thid',\prog}) \mid (\thid,\lbJ{\thid',\ts})
\]
\end{defn}

For brevity, we will write \( \lbC{\thid, \tsid} \) instead of \( ( \thid,\lbC{\tsid}) \), similarly for \( \lbF{\thid, \thid',\prog}\) and \( \lbJ{\thid, \thid',\ts} \).
Also we will use the same meta-variable \( \lb \) to range over extended transaction labels.

\begin{defn}[Traces]
\label{def:traces}
    Given an initial time-stamp heap \( \tshp \) and  a thread pool \( \thpl \), a trace \( \trc \in \Trace \defeq \powerset{ \ExtTranslabel } \times (\ExtTranslabel \times \ExtTranslabel) \) is defined as a tuple \( (\setlabels,<) \) that satisfies predicate \( \pred{trace}{\tshp,\thpl,\setlabels,<,\nat} \), for some number \( \nat \).
\[
    \begin{rclarray}
        \func{traces}{\tshp,\thpl,0} & \defeq & \Set{(\emptyset, \emptyset,\tshp,\thpl)} \\
        \func{traces}{\tshp,\thpl,\nat} & \defeq & 
        \Setcon{%
            (\setlabels,<,\tshp',\thpl')
        }{%
            (\tshp'', \thpl'') \toG{\lbID} (\tshp', \thpl' ) 
            \land (\setlabels,<,\tshp'',\thpl'') \in \func{trace}{\tshp,\thpl,\setlabels,<,\nat-1}
        } \\
		& & \uplus \Setcon{
				(\setlabels \uplus \Set{\lb}
                , < \uplus \myset{(\lb',\lb)}{ \lb' \in \setlabels}
                , \tshp',\thpl')
			}{ 
	            (\tshp'', \thpl'') \toG{\lb} (\tshp', \thpl' ) 
                \land \lb \neq \lbID \land {} \\
                (\setlabels,<,\tshp'',\thpl'') \in \func{trace}{\tshp,\thpl,\setlabels,<,\nat-1}
			}  \\
    \end{rclarray}
\]
\end{defn}
\sx{
    Not robust enough against the same events happening twice.
    Might fix later or simply assume all labels are unique by tagged a unique identifier. }

\begin{defn}[Program Order]
\label{def:po}
Given a trace \( \trc \in \Trace \) (\defin \ref{def:traces}), the \( \funcn{programOrder} : \powerset{\ExtTranslabel} \times (\ExtTranslabel \times \ExtTranslabel) \to \powerset{\Transactions} \times (\Transactions \times \Transactions) \) function is defined as follows:
\[ 
    \begin{rclarray}
        \func{programOrder}{\setlabels, <} & \defeq & ( \settrans, \po ) \\
    \end{rclarray}
\]
where,
\[ 
    \begin{rclarray}
        \settrans & \equiv & \Setcon{\tsid}{\lbC{\thid,\tsid} \in \setlabels } \\
        \po & \equiv & \myset{(\tsid, \tsid')}{\lbC{\thid,\tsid} < \lbC{\thid,\tsid'} } 
        \uplus \myset{(\tsid, \tsid')}{\lbC{\thid,\tsid} < \lbF{\thid,\thid', \stub} < \lbC{\thid',\tsid'} } \\
            & & \uplus \myset{(\tsid, \tsid')}{\lbC{\thid,\tsid} < \lbJ{\thid',\thid, \stub} < \lbC{\thid',\tsid'} }
    \end{rclarray}
\]
\end{defn}

\begin{defn}[Visibility and arbitration]
    \label{def:vis-ar}
    The \( \funcn{graph}: \TSHeaps \to ( (\Transactions \times \Transactions) \times (\Transactions \times \Transactions) )  \) function convert a time-stamp heap into corresponding \emph{visibility relation} and \emph{arbitration relation}, written \( \vis \) and \( \ar \) respectively.
    \[
        \begin{rclarray}
            \func{graph}{\tshp} & \defeq & (\vis,\tar) \\
        \end{rclarray}
    \]
    where,
    \[
        \begin{rclarray}
            \vis & \equiv & 
            \Setcon{%
                (\tsid,\tsid')
            }{ %
                \exsts{ \loc, \loc', \ts, \ts', \etag \in \Set{\etW,\etE}, \etag' \in \Set{\etR,\etS} } 
                \ts < \ts' \land {} \\
                \tshp(\loc)(\ts) = (\stub, \etag,\tsid)
                \land \tshp(\loc')(\ts') = (\stub, \etag',\tsid') 
			} \\
            \tar & \equiv & 
            \Setcon{%
            (\tsid,\tsid')
            }{%
                \exsts{ \loc, \loc', \ts, \ts', \etag, \etag' \in \Set{\etW,\etE} } 
                \ts < \ts' \land {} \\
                \tshp(\loc)(\ts) = (\stub, \etag,\tsid) 
                \land \tshp(\loc')(\ts') = (\stub, \etag',\tsid') 
			}
        \end{rclarray}
    \]
\end{defn}

Note that all transactions in the visibility or arbitration relations, for instance \( (\tsid, \tsid') \in \vis \), they must be in the set of transactions given by program order, meaning \( \tsid, \tsid' \in \settrans \).
For brevity, we might only mention and quantify few elements of this tuple but one should think they are quantified as an entire tuple.

\begin{defn}[Partial Graph]
\label{def:partial-graph}
Given the well-formedness of time-stamp heaps (\defin \ref{def:wf-timestamp-heap}), program order (\defin \ref{def:po}), and visibility and arbitration relation (\defin \ref{def:vis-ar}), the set of \emph{partial graph} is defined as follows, where the ``partial'' means the arbitration relation is partial.
\[
    \begin{rclarray}
    \PGraphs & \defeq & 
    \Setcon{%
        (\settrans, \po, \vis, \tar, \tshp)
    }{ 
        \exsts{\tshp', \thpl'} \wfH{\tshp'}
        \land (\setlabels,<,\tshp,\thpl) \in \bigcup\limits_{\nat \in \Nat}\func{traces}{\tshp',\thpl',\nat} \land {} \\
        (\settrans,\po) = \func{programOrder}{\setlabels,<} 
        \land (\vis,\tar) = \func{graph}{\tshp} 
    } 
    \end{rclarray}
\]
\end{defn}

\sx{Rework a bit until this point}

\begin{lem}[Separation]
    \label{lem:seperate}
    If two transactions that are not associated by potentially arbitration relation \( \tar \), they access different locations but commit at the same time.
    \[
        \begin{array}{@{}l@{}}
            \for{ \tshp, \tar, \tsid, \tsid' } (\tsid, \tsid'), (\tsid',\tsid) \notin \tar \\
            \qquad \implies \for{ \loc, \loc', \ts, \ts', \etag, \etag \in \Set{\etW, \etE } } \tshp(\loc)(\ts) = ( \stub, \etag, \tsid) \land  \tshp(\loc')(\ts') = ( \stub, \etag', \tsid') \implies \ts = \ts' \land \loc \neq \loc'
        \end{array}
    \]
\end{lem}
\begin{proof}
    Given the definition of \( \tar \), \( \ts = \ts' \) holds, and \( \loc \neq \loc' \) is derived from Lemma \ref{lem:atoic-rw}.
\end{proof}


\begin{lem}[Semi-acyclic]
    \label{lem:semi-acyclic}
    Both \( \vis \) and \( \tar \) are acyclic.
\end{lem}
\begin{proof}
    Proof by contradiction.
    Assume that there is a circle by \( \vis \), which means that \( \bigwedge\limits_{0 \leq i \leq n} (\tsid_{i}, \tsid_{i+1}) \in \vis \land \tsid_{0} = \tsid_{n} \) for some \( \tsid_{0} \) to \( \tsid_{n}\).
    By Lemma \ref{lem:atoic-rw}, each transaction has a start time and a end time, thus let \( \ts^{s}_{i} \) and \( \ts^{e}_{i} \) be the start time and end time of the transaction \( \tsid_{i} \) respectively.
    By Lemma \ref{lem:read-before-write}, we have \( \ts^{s}_{i} < \ts^{e}_{i} \), and by definition of \( \vis \), thus \( \ts^{e}_{i} < \ts^{s}_{i+1} \).
    Therefore, \( \ts^{s}_{0} < \ts^{e}_{0} < \ts^{s}_{1} < \dots <  \ts^{s}_{n} \), and we have contradiction that \( \ts^{s}_{0} < \ts^{s}_{n} \).

    Similarly for \( \tar \), we have contradiction that \( \ts^{e}_{0} < \ts^{e}_{1} < \dots  < \ts^{e}_{n} \).
\end{proof}

We can extend partial order \( \tar \) to a total order \( \ar \) by pick orders between those unrelated transactions.
First, we define an auxiliary function that returns a set that includes the first transactions (might be more than two) that branch.
To simplify, assume there is a unique initial transactions denoted by \( \tsid_{init} \), where \( (\tsid_{init}, \tsid) \in \tar \) for all \( \tsid \).

\begin{defn}[First Branch]
    \[
        \begin{rclarray}
            \func{firstTrans}{\settrans, \tar} & \defeq & \tsid \ \texttt{where} \ \for{\tsid' \in \settrans } \tsid = \tsid' \lor (\tsid, \tsid') \in \tar \\
            \func{firstBranch}{\settrans, \tar} & \defeq &
            \begin{cases}
                \emptyset & \settrans = \emptyset \\
                \func{firstBranch}{\settrans \setminus \Set{\func{firstTrans}{\settrans, \tar}}, \tar} & |\func{dec}{\settrans, \tar}| = 1 \\
                \func{dec}{\settrans, \tar} & |\func{dec}{\settrans, \tar}| > 1 \\
            \end{cases} \\
            \func{dec}{\settrans, \tar} & \defeq & \myset{\tsid}{\exsts{ \tsid_{init} = \func{firstTrans}{\settrans, \tar} } (\tsid_{init}, \tsid) \in \tar \land \neg\exsts{ \tsid' } (\tsid_{init}, \tsid'),(\tsid', \tsid) \in \tar}
        \end{rclarray}
    \]
\end{defn}
\sx{Need a bit work to change the first trans function}

Intuitively, we take the first two transactions that are not connected, which definitely touch different locations by Lemma \ref{lem:seperate}, therefore we can simply pick a order and take the transitive closure.
We continue the process until it is a total order.

\begin{defn}[Total relation]
    \label{def:tototal}
    \[
        \begin{rclarray}
            \func{toTotal}{\settrans, \tar} & \defeq & 
                \begin{cases}
                    (\settrans, \tar) & \func{firstBranch}{\settrans, \tar} = \emptyset\\ 
                    \func{toTotal}{\settrans, ( \tar \uplus \Set{(\tsid, \tsid')})^{+}} & \tsid, \tsid' \in \func{firstBranch}{\settrans, \tar} \\    
                \end{cases}
            \\
        \end{rclarray}
    \]
\end{defn}

We will use notations \( (\settrans,\po,\vis,\ar, \tshp) \) to refer an element of the set:
\[
\myset{(\settrans, \po, \vis, \ar, \tshp)}{( \settrans, \ar ) = \func{toTotal}{\settrans, \tar}} \\
\]

\begin{lem}[Visibility]
    \label{lem:visibility}
    Visibility relation should be a subset of arbitration relation, i.e.\ \( \vis \subseteq \ar \).
\end{lem}
\begin{proof}
    For all transactions \( \tsid \) and \( \tsid' \), if \( ( \tsid, \tsid' ) \in \vis \), it means that transaction \( \tsid \) commits before \( \tsid' \) starts, so that \( \tsid \) must start before \( \tsid' \) starts, by Lemma \ref{lem:start-before-end}.
    This means \( (\tsid, \tsid') \in \tar \) by the definition of \( \tar \), and because \( \tar \subseteq \ar \), so \( (\tsid, \tsid') \in \ar \).
\end{proof}

\begin{lem}[Monotonic time in a thread]
    \label{lem:mono-time-thread}
    The thread's local time monotonically increase.
    This is  
    \[ 
        \for{ \stk, \stk', \tshp, \tshp', \ts, \ts', \iprog, {\iprog}' ,\lb,\loc, \ts } ( \stk, \tshp, \ts ), \iprog \toT{\lb} ( \stk', \tshp', \ts' ), {\iprog}' \implies \ts < \ts'
    \]
\end{lem}
\begin{proof}
    Indication on the structure of the operational semantics.
    For base cases \rl{PChoiseLeft}, \rl{PChoiseRight}, \rl{PLoop}, \rl{PSeqSkip} and \rl{PPar}, it is trivial since those rules do not change the time.
    For \rl{Commit}, the premiss implies that \( \ts' > \ts \) and for \rl{PWait}, \( \ts' = \max\Set{\ts, \stub} \geq \ts\).
    For the inductive case \rl{PSeq}, prove directly by the inductive hypothesis.
\end{proof}

\begin{lem}[Session]
    \label{lem:session}
    \( \po \subseteq \vis \).
\end{lem}   
\begin{proof}
    By a case analysis of the definition of \( \po \).
    For \( \tsid \) and \( \tsid' \) where \( \lbC{\thid,\tsid} < \lbC{\thid,\tsid'} \), it means that transaction \( \tsid \) is reduced by the semantics before \( \tsid' \) is reduced.
    Then by Lemma \ref{lem:mono-time-thread}, the commit time of \( \tsid \) is smaller than the start time of \( \tsid' \), so that \( (\tsid, \tsid') \in \vis \).

    For \( \tsid \) and \( \tsid' \) where \( \lbC{\thid,\tsid} < \lbF{\thid,\thid', \stub} < \lbC{\thid',\tsid'} \), first note that in the \rl{PFork} the parent thread starts at time \( \ts \) and ends at \( \ts' \), and the child thread initialises with the time \( \ts' \), where  in fact \( \ts = \ts' \)
    By \( \lbC{\thid,\tsid} < \lbF{\thid,\thid', \stub}  \), the transaction \( \thid \) is reduced before the fork, so by Lemma \ref{lem:mono-time-thread}, the end time of \( \thid \) is smaller than \( \ts \).
    By \( \lbF{\thid,\thid', \stub} < \lbC{\thid',\tsid'} \), the transaction \( \thid' \) is reduced after the fork and also by Lemma \ref{lem:mono-time-thread}, the start time of \( \thid \) is greater or equal to \( \ts' \).
    Therefore, \( (\tsid, \tsid') \in \vis \).

    Similarly, for \( \tsid \) and \( \tsid' \) where \( \lbC{\thid,\tsid} < \lbJ{\thid',\thid, \stub} < \lbC{\thid',\tsid'} \), all the transactions by thread \( \thid \) must have smaller start and end times than all the transactions by thread \( \thid' \) after the join point.
    Therefore, \( (\tsid, \tsid') \in \vis \).
\end{proof}

\sx{The session lemma I feel slightly unhappy, because it seems not very formal.}

\begin{lem}[Semi-prefix]
    \label{lem:semi-prefix}
    \( \tar; \vis \subseteq \vis \).
\end{lem}
\begin{proof}
    For all \( \tsid, \tsid', \tsid'' \), if \( (\tsid, \tsid') \in \tar \) and \( (\tsid', \tsid'') \in \vis \), by the definitions of \( \po \) and \( \vis \), the commit time of \( \tsid' \) is greater than the one of \( \tsid \) but smaller than the start time of \( \tsid'' \).
    Thus there must exist \( \loc, \loc'', \ts, \ts' , \ts'', \etag \in \Set{\etW, \etE}  \) and \( \etag'' \in \Set{\etR, \etS } \) such that  \( \tshp(\loc)(\ts) = (\stub, \etag, \tsid) \), \( \tshp(\loc'')(\ts'') = (\stub, \etag'', \tsid'') \) and \( \ts < \ts'' \), thus \( ( \tsid, \tsid'' ) \in \vis \).
\end{proof}

\begin{lem}[Prefix]
    \label{lem:prefix}
    \( \ar; \vis \subseteq \vis \).
\end{lem}
\begin{proof}
    For all \( \tsid, \tsid', \tsid'' \) that \( (\tsid, \tsid') \in \ar \) and \( (\tsid', \tsid'') \in \vis \), if \( (\tsid, \tsid') \in \tar \), it is proven by Lemma \ref{lem:semi-prefix}.
    If \( ( \tsid, \tsid' ) \notin \tar \), it means it is a new edge by the \funcn{toTotal} function from Definition \ref{def:tototal}.
    By the Lemma \ref{lem:seperate}, \( \tsid \) and \( \tsid' \) commit at the same time.
    By the definition of \( \vis \), the commit time of \( \tsid' \) is smaller than the start time of \( \tsid'' \).
    Therefore, the commit time of \( \tsid \) is also smaller than the start time of \( \tsid'' \), so that \( ( \tsid, \tsid'' ) \in \vis \).
\end{proof}

\begin{lem}[No conflict]
    \label{lem:nocoflict}
    Two transactions cannot concurrently write to the same location, this means that one must observe another one.
    This is \( \for{ \loc, \tsid, \tsid' } \tshp(\loc)(\stub) = (\stub, \etW, \tsid) \land  \tshp(\loc)(\stub) = (\stub, \etW, \tsid' ) \implies ((\tsid, \tsid') \in \vis \lor (\tsid', \tsid) \in \vis ))\).
\end{lem}
\begin{proof}
    Prove by contradiction.
    Assume \( (\tsid, \tsid') \notin \vis \land (\tsid', \tsid) \notin \vis \), this intuitively means one transaction is overlapped with another.
    Let \( \ts_{s}, \ts_{e}, \ts'_{s} \) and \( \ts'_{e} \) be the start time and end time of transaction \( \tsid \) and \( \tsid' \) respectively.
    Because of the symmetry,  we can assume that the start time of \( \tsid \) is in between \( \tsid' \), witch means \( \ts'_{s} < \ts_{s} < \ts'_{e} \).
    Now we consider \( \ts_{e} \).
    First note that \( \ts_{e} > \ts_{s} \) by Lemma \ref{lem:start-before-end}, therefore we need to consider two cases \( \ts'_{s} < \ts_{s} < \ts_{e} < \ts'_{e} \) and  \( \ts'_{s} < \ts_{s} < \ts'_{e} < \ts_{e}  \).
    Since both transaction write the same location \( \loc \), those two cases violate the \( \predn{consist} \) requirement in the semantics, so one of the transactions must pick another start and end time.
\end{proof}

\begin{lem}[External]
    \label{lem:ext}
    A transaction should read the last values it can observe.
    This means that for all transaction \( \tsid \) and heap location \( \loc \), if the transaction read a value \( \val \) from the location, i.e.\ \( \exsts{ \ts } \tshp(\loc)(\ts) = (\val, \etR, \tsid) \), the last transaction \( \tsid' \) who writes to the same location and can be observe by \( \tsid \), i.e.\ \( (\tsid, \tsid') \in \vis\), should have written the same value, meaning \( \exsts{ \val', \ts' } \tshp(\loc)(\ts') = (\val', \etW, \tsid') \implies \val' = \val\)
\end{lem}
\begin{proof}
    Given the definition of \( \vis \), we have \( \ts' < \ts \).
    Because transaction \( \tsid' \) is the last one who write to the location, this means that \( \for{ \tsid'', \ts'', \etag'' } \tshp(\loc)(\ts'') = (\stub, \etag'', \tsid'') \implies \etag'' \neq \etW \).
    Thus by the \( \funcn{startstate} \) in the semantics, we have \( \val' = \val \).
\end{proof}

\begin{lem}[Acyclic]
    \label{lem:acyclic}
    Both \( \vis \) and \( \ar \) are acyclic.
\end{lem}
\begin{proof}
    For \( \vis \), it is proven by Lemma \ref{lem:semi-acyclic}.

    To prove \( \ar \) is acyclic, we prove inductively \( \tar_{i} \) is acyclic, where \( \tar_{0} = \tar \), \( \tar_{n} = \ar \) and \( \tar_{i+1} = (\tar_{i} \uplus \Set{(\tsid, \tsid')})^{+} \) for some \( \tsid \) and \( \tsid' \), which follows the process of \funcn{toTotal} from Definition \ref{def:tototal}.
    For base case \( \tar_{0} \), it is proven by Lemma \ref{lem:semi-acyclic}.
    Now assume \( \tar_{i} \) is acyclic and \( \tar_{i+1} = (\tar_{i} \uplus \Set{(\tsid, \tsid')})^{+} \) for some \( \tsid \) and \( \tsid' \), we prove by contradiction that \( \tar_{i+1} \) is acyclic.
    Given the hypothesis, if there is circle in \( \tar_{i+1} \), such circle either contain the edge \( (\tsid, \tsid') \), or can be broken down to a circle containing the edge \( (\tsid, \tsid') \), because of the transitive closure.
    Note that by breaking down to a circle containing \( ( \tsid, \tsid' ) \), the rest edges inside the circle must be in \( \tar_{i} \).
    Let assume the circle is \( \tsid_{0}, \tsid_{1}, \dots, \tsid_{i}, \tsid, \tsid', \tsid_{i+1}, \dots, \tsid_{n} \) where \( \tsid_{0} = \tsid_{n} \).
    By the \( \funcn{toTotal} \) function from Definition \ref{def:tototal}, \( \tsid, \tsid' \in \func{firstBranch}{\settrans, \tar_{i}}\), which means that for all \( \tsid'' \), \( (\tsid'', \tsid) \in \tar_{i} \) if and only if \( ( \tsid'', \tsid') \in \tar_{i} \), therefore \( (\tsid'', \tsid) \in \tar_{i+1} \) if and only if \( ( \tsid'', \tsid') \in \tar_{i+1} \).
    This means that the sequence without \( \tsid \), i.e.\ \( \tsid_{0}, \tsid_{1}, \dots, \tsid_{i}, \tsid', \tsid_{i+1}, \dots, \tsid_{n} \), is still a sequence where two adjacent transactions are connected by \( \tar_{i+1} \), and this new sequence is a circle.
    Now all the edges in the new sequence/circle already exist in \( \tar_{i} \), which violates our hypothesis.
    Therefore by contradiction, \( \tar_{i+1} \) is acyclic.
    Given that, \( \ar \) is acyclic.
\end{proof}

\begin{lem}[Total order]
    \label{lem:totalorder}
    \( \ar \) is a total order.
\end{lem}
\begin{proof}
    By Lemma \ref{lem:acyclic}, \( \ar \) is acyclic, and by \defin \ref{def:tototal}, for all \( \tsid \) and \( \tsid' \), either \( (\tsid, \tsid') \in \ar \) or \( (\tsid', \tsid) \in \ar \).
    Therefore, it is a total order.
\end{proof}

\begin{defn}[Snapshot Isolation Graph]
    \(\sig \in \SIGraphs \)
\end{defn}

\begin{thm}[Soundness of the semantics]
    The thread pool operational semantics $\toG{}$ (\defin\ref{def:thread_pool_semantics}) is sound.
    This means
    \[
        \begin{array}{@{}l@{}}
            \exsts{ f } \for{ \tshp, \thpl, \tshp', \thpl' } (\tshp, \thpl) \toG{\lb} (\tshp', \thpl') \land \exsts{ \sig \in \SIGraphs } f(\tshp, \thpl) = \sig \implies \exsts{ \sig' \in \SIGraphs } f(\tshp', \thpl') = \sig'
        \end{array}
    \]
\end{thm}
\begin{proof}
    Given the \defin \ref{def:traces}, there is a unique corresponding trace \trace, and then by \defin \ref{def:po}, \ref{def:vis-ar} and \ref{def:tototal} there exists a \( \sig' \).
    Then, by Lemma \ref{lem:visibility}, \ref{lem:session}, \ref{lem:prefix}, \ref{lem:nocoflict}, \ref{lem:ext}, \ref{lem:totalorder}, the \( \sig' \in \SIGraphs \).
\end{proof}
\sx{Not really right but keep this way for now}

\subsection{Completeness}
\sx{Define a function from a graph to a set of possible \( \fph \) }

