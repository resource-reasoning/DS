\section{Proof of semantics\label{sec:proof_semantics}}
\begin{lem}
    A history cannot be overwritten, i.e.\ \( \forall \tshp, \tshp', \loc, \ts \ldotp ( \tshp, \dontcare ) \globaltransfer{\dontcare} ( \tshp', \dontcare ) \implies \tshp(\loc)(\ts) \subseteq \tshp'(\loc)(\ts)\)
\end{lem}
\begin{proof}
    From the \( \pred{allowcommit} \).
\end{proof}

\begin{lem}
    For any time, it can have at most one write event and, if it has then no read events happen in the same time. This is \ \( \forall \tshp, \loc, \ts \ldotp ( \dontcare, \wop, \dontcare ) \in \tshp(\loc)(\ts) \implies \tshp(\loc)(\ts) =  \Set{( \dontcare, \wop, \dontcare )} \)
\end{lem}
\begin{proof}
    From the \( \pred{allowcommit} \).
\end{proof}

\begin{lem}
    \label{lem:read-before-write}
    All the reads of a transaction happen before all the writes. This is 
    \( \forall \tshp, \loc, \loc', \ts, \ts', \tsid \ldotp \tshp(\loc)(\ts) = (\dontcare, \rop, \tsid) \land \tshp(\loc')(\ts') = (\dontcare, \wop, \tsid) \implies \ts < \ts' \).
\end{lem}
\begin{proof}
    From the semantics that \( \ts_{s} < \ts_{e} \).
\end{proof}

\begin{lem}
    \label{lem:atoic-rw}
    All the reads of a transaction happen in the same time, so do all the writes. This is 
    \( \forall \tshp, \loc, \loc', \ts, \ts', \tsid, \op \in \Set{\rop, \wop} \ldotp \tshp(\loc)(\ts) =  \tshp(\loc')(\ts') = (\dontcare, \op, \tsid) \implies \ts = \ts' \).
\end{lem}
\begin{proof}
    From the \( \func{commit} \).
\end{proof}

First we define session order \( \so \), or program order.

\[ 
    \begin{rclarray}
        lc \in \texttt{LastCommit} & \defeq & \Threadid \parfun \powerset{\Transid} \\
        \func{sessionOrder}^{0}(\tshp_{init}, \tdpl_{init}) & \defeq & \Set{(\emptyset, \emptyset, \tshp_{init}, \tdpl_{init}, \emptyset)} \\
        \func{sessionOrder}^{\nat}(\tshp_{init}, \tdpl_{init}) & \defeq & 
        \Set{(\settrans, \so, \tshp, \tdpl \uplus \Set{\thid \mapsto \dontcare}, lc) \middle|
            \begin{array}{@{}l@{}}
                \exists \settrans', \so', \tshp', \tdpl', lc', \tll \ldotp \\
                (\settrans', \so', \tshp', \tdpl' \uplus \Set{\thid \mapsto \dontcare}, lc') \in {} \\
                \qquad \func{sessionOrder}^{\nat -1}(\tdpl_{init}, \tshp_{init}) \land {} \\
                ( \tshp', \tdpl' \uplus \Set{\thid \mapsto \dontcare}) \globaltransfer{\tll} ( \tshp, \tdpl \uplus \Set{\thid \mapsto \dontcare}) \land {} \\
                \tll = \lid \implies \\
                \begin{formulea}
                    \settrans = \settrans' \land \so = \so' \land \tdpl = \tdpl' \land lc = lc'
                \end{formulea} \land {} \\
                \exists \tsid \ldotp \tll = \lcmt{\tsid} \implies  \\
                \begin{formulea}
                    \settrans = \settrans' \uplus \Set{\tsid} \land {} \\
                    \so = \so' \uplus \Set{(\tsid', \tsid) \middle| \tsid' \in lc'(\thid)} \land {} \\
                    \tdpl = \tdpl' \land lc = lc'\remapsto{\thid}{\Set{\tsid}}
                \end{formulea} \land {} \\
                \exists \thid' \ldotp \tll = \lfork{\thid', \dontcare} \implies  \\
                \begin{formulea}
                    \settrans = \settrans' \land \so = \so' \land \tdpl = \tdpl' \uplus \Set{\thid' \mapsto \dontcare } \land {} \\
                    lc = lc' \uplus \Set{\thid' \mapsto lc'(\thid)}
                \end{formulea} \land {} \\
                \exists \thid'' \ldotp \tll = \ljoin{\thid'', \dontcare} \implies  \\
                \begin{formulea}
                    \settrans = \settrans' \land \so = \so' \land \tdpl = \tdpl' \uplus \Set{\thid'' \mapsto \dontcare } \land {} \\
                    lc = lc'\remapsto{\thid}{lc'(\thid) \uplus lc'(\thid'')} \setminus \Set{\thid'' \mapsto \dontcare}
                \end{formulea} \land {} \\
            \end{array}
        } \\
        \func{histories}(\tshp_{init}, \tdpl_{init}) & \defeq & \Set { (\settrans,\so,\tshp) \middle| (\settrans,\so,\tshp, \dontcare, \dontcare) \in  \bigcup\limits_{\nat \in \Nat } \func{sessionOrder}^{\nat}(\tshp_{init}, \tdpl_{init}) }
    \end{rclarray}
\]

\begin{lem}
    Transactions ordered by session order \( \so \) appear in the same order in the time stamp heap, i.e.\ \( \forall \tshp_{init}, \tdpl_{init}, (\settrans, \so, \tshp) \in \func{histories}(\tshp_{init}, \tdpl_{init}), \tsid, \tsid' \in \settrans, \loc \ldotp \exists \ts, ts' \ldotp \tshp(\loc)(\ts) = (\dontcare, \dontcare, \tsid) \land \tshp(\loc)(\ts') = (\dontcare, \dontcare, \tsid') \implies \ts < \ts' \)
\end{lem}
\begin{proof}
    From the definition of session order and the semantics, especially \emph{commit}, \emph{seqnoskip}, \emph{par} and \emph{wait}.
\end{proof}

Now we need to recover \( \ww \), \( \wr \) and \( \rw \) from \( \tshp \).
We need to prove that there is no circle that does not contain contain adjacent \( \rw \).
By contradiction, if such circle exists, we can prove that the time goes backward in the circle.

\[
    \begin{rclarray}
        \func{graph}(\settrans, \so, \tshp) & \defeq & (\settrans, \so, \wr, \ww, \rw) \\
                                            & & \texttt{where} \ \forall \tsid, \tsid' \in \settrans \ldotp \exists \loc, \ts, \ts' > \ts \ldotp  \\
                                            & & (\tsid, \tsid') \in \wr \implies  \ts = \max(\Set{\ts'' \middle| \ts'' < \ts }), \val \ldotp \tshp(\loc)(\ts) = (\dontcare,\wop,\tsid) \land \tshp(\loc)(\ts') = (\dontcare,\rop,\tsid') \land {} \\
                                            & & (\tsid, \tsid') \in \ww \implies \tshp(\loc)(\ts) = (\dontcare,\wop,\tsid) \land \tshp(\loc)(\ts') = (\dontcare,\wop,\tsid') \land {} \\
                                            & & (\tsid, \tsid') \in \rw \implies \tshp(\loc)(\ts) = (\dontcare,\rop,\tsid) \land \tshp(\loc)(\ts') = (\dontcare,\wop,\tsid') 
    \end{rclarray}
\]

\begin{lem}
    Given threes transactions, \( \tsid_{1} \), \( \tsid_{2} \) and \( \tsid_{3} \), if there is a order between \( \tsid_{1} \) and \( \tsid_{2} \), so does \( \tsid_{2} \) and \( \tsid_{3} \), and at least one of these two orders are not read-write relation, then the time, associated with the events that determines the orders, strictly increases.
    This is, given \( (\settrans, \so, \wr, \ww, \rw) \), \( \forall \tsid_{1}, \tsid_{2},\tsid_{3} \in \settrans \ldotp \exists \tll, \tll' \in \Set{\so, \wr, \ww, \rw}, \ts_{1}, \ts_{21}, \ts_{22}, \ts_{3} \ldotp \ts_{1} < \ts_{21} \leq \ts_{22} < \ts_{3} \land {} \) 
    \[
        \begin{array}{@{}l@{}}
        \end{array}
    \]
\end{lem}


%Similarly for a transaction that only has writes event, we add end operations \( (\bot, \tsid, \sop ) \) in time \( (\ts-1) \).

%\[
%\begin{rclarray}
    %\func{stretch}(\tshp) & \defeq & \lambda \loc \ldotp \lambda \ts \            ldot
    %\begin{funcarray}
        %\tshp(\loc)(\ts') & \ts = 3 * \ts' \\
        %\texttt{undef} & o.w. \\
    %\end{funcarray} \\
    %\func{extend}(\tshp) & \defeq & \lambda \loc \ldotp \tshp(\loc) \uplus \Set{\ts + 1 \mapsto (\bot, \tsid, \eop ) \ \middle| \ \tshp(\loc)(\ts) = (\dontcare, \tsid, \rop) \land \forall \loc', \ts' \ldotp \tshp(\loc')(\ts') = (\dontcare, \tsid, \wop)} \\
                         %& & \quad \quad \quad \uplus \Set{\ts - 1 \mapsto (\bot, \tsid, \sop ) \ \middle| \ \tshp(\loc)(\ts) = (\dontcare, \tsid, \wop) \land \forall \loc', \ts' \ldotp \tshp(\loc')(\ts') = (\dontcare, \tsid, \rop)}
%\end{rclarray}
%\]

%\begin{lem}
    %After stretching the time by 3, there is no record in time \( 3 * \nat + 1 \) and \( 3 * \nat - 1 \).
    %Therefore after extending, there are only \( (\dontcare, \tsid, \eop) \) in time \( 3 * \ts + 1 \) and only \( (\dontcare, \tsid, \sop) \) in time \( 3 * \ts - 1 \).
    %This is \( \forall \tshp \ldotp \exists \tshp' = \func{extend} \circ \func{stetch}(\tshp) \ldotp \forall \loc, \ts \ldotp (\tshp'(\loc)(3 * \ts + 1)\isdef \implies \tshp'(\loc)(3 * \ts + 1) = (\dontcare, \dontcare, \eop) ) \land (\tshp'(\loc)(2 * \ts - 1)\isdef \implies \tshp'(\loc)(3 * \ts - 1) = (\dontcare, \dontcare, \sop) ) \).
%\end{lem}
%\begin{proof}
    %trivial.
%\end{proof}

%\begin{lem}
    %\label{lem:start-before-end}
    %In the extended heap, all the reads or starts of a transaction happen before all the writes or end. This is 
    %\( \forall \tshp, \loc, \loc', \ts, \ts', \op \in \Set{\rop, \sop}, \op' \in \Set{\wop, \eop}, \tsid \ldotp \tshp(\loc)(\ts) = (\dontcare, \op, \tsid) \land \tshp(\loc')(\ts') = (\dontcare, \op', \tsid) \implies \ts < \ts' \).
%\end{lem}
%\begin{proof}
    %From Lemma \ref{lem:read-before-write} and the definition of \func{strech} and \func{extend}.
%\end{proof}

%\begin{lem}
    %\label{lem:happen-in-same-time}
    %For an extended heap, all the reads of a transaction happen in the same time, so do all the writes, starts and ends. This is 
    %\( \forall \tshp, \loc, \loc', \ts, \ts', \tsid, \op \ldotp \tshp(\loc)(\ts) =  \tshp(\loc')(\ts') = (\dontcare, \op, \tsid) \implies \ts = \ts' \).
%\end{lem}
%\begin{proof}
    %From Lemma \ref{lem:atoic-rw} and the definition of \func{strech} and \func{extend}.
%\end{proof}

%\begin{lem}
    %\label{lem:unique-label}
    %A transaction in an extended heap, must have either starts or reads, and either ends or writes.
%\end{lem}
%\begin{proof}
    %From the definition of \func{extend}.
%\end{proof}

%\[
%\begin{rclarray}
    %(\settrans, \tvis, \tar) = \func{graph}(\tshp) & \defeq & (\Set{ \tsid \ \middle| \ \forall \loc \ldotp \tshp(\loc) = (\dontcare, \tsid, \dontcare)}, \\
                                                   %& & \Set{(\tsid, \tsid') \ \middle| \ 
    %\begin{array}{@{}l@{}}
        %\exists \loc, \loc', \ts, \ts', \op \in \Set{\wop, \eop}, \op' \in \Set{\rop, \sop} \ldotp \\
        %\ts < \ts' \land \tshp(\loc)(\ts) = (\dontcare, \tsid, \op) \land \tshp(\loc')(\ts') = (\dontcare, \tsid', \op')
    %\end{array}
%}, \\
                                                   %& & \Set{(\tsid, \tsid') \ \middle| \ 
    %\begin{array}{@{}l@{}}
        %\exists \loc, \loc', \ts, \ts', \op, \op' \in \Set{\wop, \eop} \ldotp \\
        %\ts < \ts' \land \tshp(\loc)(\ts) = (\dontcare, \tsid, \op) \land \tshp(\loc')(\ts') = (\dontcare, \tsid', \op')
    %\end{array}
%}, \\
%\end{rclarray}
%\]

%\begin{lem}
    %For an extended heap, the corresponding \tvis\ and \tar\ have no circle.
%\end{lem}
%\begin{proof}
    %Assume there is a circle in \(\rvis\), says, \( \tsid_{1} \rvis \tsid_{2} \rvis \dots \rvis \tsid_{n} \rvis \tsid_{n+1} \), where \( \tsid_{1} = \tsid_{n+1} \).
    %Therefore, \( \bigwedge\limits_{ 1 \leq i \leq n} \exists \loc, \loc', \ts, \ts', \op \in \Set{\wop, \eop}, \op' \in \Set{\rop, \sop} \ldotp \ts < \ts' \land \tshp(\loc)(\ts) = (\dontcare, \tsid_{i}, \op) \land \tshp(\loc')(\ts') = (\dontcare, \tsid_{i+1}, \op')\).
    %By Lemma \ref{lem:unique-label} we can relabel read to start and write to end.
    %Then by Lemma \ref{lem:happen-in-same-time}, we can define a list of starts and ends events that is ordered by time: \( \List{ (\tsid_{1},\eop), (\tsid_{2},\sop), (\tsid_{2},\eop), \dots, (\tsid_{n},\eop), (\tsid_{n+1},\sop) } \).
    %By the assumption, we have \( \tsid_{1} = \tsid_{n+1} \), thus this contradict Lemma \ref{lem:start-before-end}.

    %Similarly for \(\rtar\), the list of write events  \( \List{ (\tsid_{1},\eop), (\tsid_{2},\eop), (\tsid_{2},\eop), \dots, (\tsid_{n},\eop), (\tsid_{n+1},\eop) } \) contradict Lemma \ref{lem:happen-in-same-time}.
%\end{proof}

%\begin{lem}
    %Given a \( \tshp \), the corresponding \((\settrans, \tvis, \tar)\) can be extended to \((\settrans, \vis, \ar)\) so that it is a valid dependency graph of snapshot isolation.
%\end{lem}
%\begin{proof}
    %First, we extend the relations \( \tar \) to a total order \( \ar \).
    %Initially, \( \ar \) includes all relations in \( \tar \).
    %Given the definition, only if the ends or writes of transactions happen in the same time, those transactions are not ordered by \( \tar \).
    %To simplify, we introduce an initial event, i.e.\ \( \forall \tsid \in \settrans \ldotp \tsid_{init} \rar \tsid \).
    %From \( \tsid_{init} \), we pick the first two transactions \( \tsid_{1} \) and \( \tsid_{2} \) that are not ordered, this is, \( \forall \tsid, \tsid' \in \Set{\tsid'' \ \middle| \ \tsid'' \rar \tsid_{1} \lor \tsid'' \rar \tsid_{2} } \ldotp \tsid \rar \tsid' \lor \tsid' \rar \tsid \).
    %We can add either \( \tsid_{1} \rar \tsid_{2} \) or \( \tsid_{2} \rar \tsid_{1} \), without introducing any circle.
%\end{proof}

%\begin{lem}
    %For the first two transactions \( \tsid_{1} \) and \( \tsid_{2} \) in a given \( \ar \) that are not ordered, we can add either \( \tsid_{1} \rar \tsid_{2} \) or \( \tsid_{2} \rar \tsid_{1} \), without introducing any circle.
%\end{lem}
%\begin{proof}
    %Since \( \tsid_{1} \) and \( \tsid_{2} \) are the first two that are not ordered, there exists an unique \( \tsid_{pre} \) where branching happens, i.e.\ \( \tsid_{pre} \rar \tsid_{1} \land \tsid_{pre} \rar \tsid_{2} \land \nexists \tsid \ldotp \tsid_{pre} \rar \tsid \rar \tsid_{1} \lor \tsid_{pre} \rar \tsid \rar \tsid_{2} \).
    %Assume we choose \( \tsid_{1} \rar \tsid_{2} \) and introduce a circle, says, \( \List{\tsid, \dots, \tsid_{1}, \tsid_{2}, \dots, \tsid' } \).
%\end{proof}
