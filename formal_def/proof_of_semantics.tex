\section{Proof of semantics\label{sec:proof_semantics}}
\begin{lem}
    \label{lem:no-over-write}
    A history cannot be overwritten, i.e.\ \( \forall \tshp, \tshp', \loc, \ts \ldotp ( \tshp, \dontcare ) \globaltransfer{\dontcare} ( \tshp', \dontcare ) \implies \tshp(\loc)(\ts)\undef \lor \tshp(\loc)(\ts) = \tshp'(\loc)(\ts)\)
\end{lem}
\begin{proof}
    Induction on the semantics.
    Except the \rl{Commit}, the rest is trivial.
    From the \texttt{wellformhist}, a new transition must pick a starting time and a ending time that have no event for those locations touched.
\end{proof}

\begin{lem}
    \label{lem:start-before-end}
    \label{lem:read-before-write}
    All the reads of a transaction happen before all the writes. 
    This is 
    \( \forall \tshp, \loc, \loc', \ts, \ts', \tsid \ldotp \tshp(\loc)(\ts) = (\dontcare, \rop, \tsid) \land \tshp(\loc')(\ts') = (\dontcare, \wop, \tsid) \implies \ts < \ts' \).
\end{lem}
\begin{proof}
    From the \rl{Commit} that \( \ts_{s} < \ts_{e} \).
\end{proof}

\begin{lem}
    \label{lem:atoic-rw}
    A transaction's reads and starts operations among all locations happen in the same time, so do all the writes and ends operations. This is 
    \( \forall \tshp, \loc, \loc', \ts, \ts', \tsid, \op, \op'\ldotp \tshp(\loc)(\ts) (\dontcare, \op, \tsid)  \land \tshp(\loc')(\ts') = (\dontcare, \op', \tsid) \land (\op, \op' \in \Set{\sop, \rop} \lor \op, \op' \in \Set{\eop, \wop} ) \implies \ts = \ts' \).
\end{lem}
\begin{proof}
    Given Lemma \ref{lem:no-over-write}, induction on semantics.
    The \rl{Commit} is by the \(\func{commitTrans}\), the rest is trivial.
\end{proof}


\begin{defn}
Program order \( \po \).
\[ 
    \begin{rclarray}
        lc \in \texttt{LastCommit} & \defeq & \Threadid \parfun \powerset{\Transid} \\
        \func{programOrder}^{0}(\tshp_{init}, \tdpl_{init}) & \defeq & \Set{(\emptyset, \emptyset, \tshp_{init}, \tdpl_{init}, \emptyset)} \\
        \func{programOrder}^{\nat}(\tshp_{init}, \tdpl_{init}) & \defeq & 
        \Set{(\settrans, \po, \tshp, \tdpl, lc) \middle| \ \dagger \ } \\
        \dagger & \equiv & 
            \begin{array}{@{}l@{}}
                \exists \settrans', \po', \tshp', \tdpl', lc', \tll \ldotp (\settrans', \po', \tshp', \tdpl' , lc') \in \func{sessionOrder}^{\nat -1}(\tdpl_{init}, \tshp_{init}) \land {} \\
                ( \tshp', \tdpl' ) \globaltransfer{\tll} ( \tshp, \tdpl ) \land {} \\
                \tll = \lid \implies 
                \begin{formulea}
                    \settrans = \settrans' \land \po = \po' \land \tdpl = \tdpl' \land lc = lc'
                \end{formulea} \land {} \\
                \exists \tsid \ldotp \tll = \lcmt{\tsid} \implies  
                \begin{formulea}
                    \exists \tdpl'', \stk,\stk', \ts, \ts', \progext, {\progext}', \thid \ldotp \settrans = \settrans' \uplus \Set{\tsid} \land {} \\
                        \po = \po' \uplus \Set{(\tsid', \tsid) \middle| \tsid' \in lc'(\thid)} \land {} \\
                        \tdpl = \tdpl'' \uplus \Set{\thid \mapsto (\stk,\ts,\progext)} \land {} \\
                        \tdpl' = \tdpl'' \uplus \Set{\thid \mapsto (\stk',\ts',{\progext}')} \land {}\\
                        lc = lc'\remapsto{\thid}{\Set{\tsid}}
                \end{formulea} \land {} \\
                \exists \thid, \prog \ldotp \tll = \lfork{\thid, \prog} \implies 
                \begin{formulea}
                    \exists \tdpl'', \stk, \ts, \progext, {\progext}', \thid' \ldotp \settrans = \settrans' \land \po = \po' \land {} \\
                    lc = lc' \uplus \Set{\thid \mapsto lc'(\thid')} \land {} \\
                    \tdpl = \tdpl'' \uplus \Set{\thid \mapsto (\emptyset,\ts,\prog), \thid' \mapsto (\stk,\ts,{\progext}')} \land {} \\
                    \tdpl' = \tdpl'' \uplus \Set{\thid' \mapsto (\stk,\ts,\progext)} 
                \end{formulea} \land {} \\
                \exists \thid,\ts \ldotp \tll = \ljoin{\thid, \ts} \implies 
                \begin{formulea}
                    \exists \tdpl'', \stk,\stk',  \ts', \progext, \progext', \thid' \ldotp
                    \settrans = \settrans' \land \po = \po' \land {} \\
                    lc = lc'\remapsto{\thid'}{lc'(\thid) \uplus lc'(\thid')} \setminus \Set{\thid \mapsto \dontcare} \land {} \\
                    \tdpl = \tdpl'' \uplus \Set{\thid' \mapsto (\stk',\max\Set{\ts,\ts'},\progext)} \land {} \\
                    \tdpl' = \tdpl'' \uplus \Set{\thid \mapsto (\stk,\ts,\pskip), \thid' \mapsto (\stk',\ts',{\progext}')}
                \end{formulea} 
            \end{array} \\
        \func{histories}(\tshp_{init}, \tdpl_{init}) & \defeq & \Set { (\settrans,\po,\tshp) \middle| (\settrans,\po,\tshp, \dontcare, \dontcare) \in  \bigcup\limits_{\nat \in \Nat } \func{sessionOrder}^{\nat}(\tshp_{init}, \tdpl_{init}) }
    \end{rclarray}
\]
\end{defn}

To define trace and then program order, we first extend the labels used in the semantics.
Each label has one extra parameter to record the thread that preforms the step, so the label looks like \( \lcommit{\thid,\tsid} \), \( \lfork{\thid,\thid',\prog} \) and \( \ljoin{\thid,\thid',\ts} \).

\begin{defn}[Traces]
    Given a initial state \( \tshp \) and \( \tdpl \), a trace \( \trc \) is define as a tuple \( (\setlabels,<) \) that satisfies predicate \( \pred{trace}{\tshp,\tdpl,\setlabels,<,\nat} \), for some number \( \nat \).
\[
    \begin{rclarray}
        \func{traces}(\tshp,\tdpl,0) & \defeq & \Set{(\emptyset, \emptyset,\tshp,\tdpl)} \\
        \func{traces}(\tshp,\tdpl,\nat) & \defeq & \Set{(\setlabels,<,\tshp',\tdpl') \middle| (\tshp'', \tdpl'') \globaltransfer{\lid} (\tshp', \tdpl' ) \land (\setlabels,<,\tshp'',\tdpl'') \in \func{trace}(\tshp,\tdpl,\setlabels,<,\nat-1)} \\
                                                    & & \uplus \Set{(\setlabels \uplus \Set{\tll} ,< \uplus \Set{(\tll',\tll) \middle| \tll' \in \setlabels}, \tshp',\tdpl') \middle| 
        \begin{array}{@{}l@{}}
            (\tshp'', \tdpl'') \globaltransfer{\tll} (\tshp', \tdpl' ) \land \tll \neq \lid \land {} \\
            (\setlabels,<,\tshp'',\tdpl'') \in \func{trace}(\tshp,\tdpl,\setlabels,<,\nat-1)
        \end{array}
}  \\
    \end{rclarray}
\]
\end{defn}


\begin{defn}[Program Order]
\[ 
    \begin{rclarray}
        \func{programOrder}(\setlabels, <) & \defeq & ( \settrans, \po ) \\
        \settrans & \equiv & \Set{\tsid \middle| \lcmt{\thid,\tsid} \in \setlabels } \\
        \po & \equiv & \Set{(\tsid, \tsid') \middle| \lcmt{\thid,\tsid} < \lcmt{\thid,\tsid'} } \\
            & & \uplus \Set{(\tsid, \tsid') \middle| \lcmt{\thid,\tsid} < \lfork{\thid,\thid', \dontcare} < \lcmt{\thid',\tsid'} } \\
            & & \uplus \Set{(\tsid, \tsid') \middle| \lcmt{\thid,\tsid} < \ljoin{\thid',\thid, \dontcare} < \lcmt{\thid',\tsid'} }
    \end{rclarray}
\]
\end{defn}

\begin{defn}
    Visibility and potential arbitration relations.
    \[
        \begin{rclarray}
            \func{graph}(\settrans,\tshp) & \defeq & (\vis,\tar) \\
            \vis & \equiv & \Set{(\tsid,\tsid') \in \settrans \middle| 
            \begin{array}{@{}l@{}}
                \exists \loc, \loc', \ts, \ts', \op \in \Set{\wop,\eop}, \op' \in \Set{\rop,\sop} \ldotp \ts < \ts' \land {} \\
                \tshp(\loc)(\ts) = (\dontcare, \op,\tsid) \land \tshp(\loc')(\ts') = (\dontcare, \op',\tsid') 
            \end{array} } \\
            \tar & \defeq & \Set{(\tsid,\tsid')  \in \settrans \middle| 
            \begin{array}{@{}l@{}}
                \exists \loc, \loc', \ts, \ts', \op, \op' \in \Set{\wop,\eop} \ldotp \ts < \ts' \land {} \\
                \tshp(\loc)(\ts) = (\dontcare, \op,\tsid) \land \tshp(\loc')(\ts') = (\dontcare, \op',\tsid') 
            \end{array} }
        \end{rclarray}
    \]
\end{defn}

We will simple use notations \( (\settrans,\po,\vis,\tar) \) to refer an element of the set:
\[
    \Set{(\settrans,\po,\vis,\tar) \middle| 
        \begin{array}{@{}l@{}}
            (\settrans,\po) = \func{programOrder}(\setlabels,<) \land (\vis,\tar) = \func{graph}(\settrans,\tshp) \land {} \\
            (\setlabels,<,\tshp,\tdpl) \in \bigcup\limits_{\nat \in \Nat}\func{traces}(\tshp',\tdpl',\nat)
        \end{array}
    } 
\]
\begin{lem}[Session]
    \( \po \subseteq \vis \).
\end{lem}   
\begin{proof}
    Given the definition of \( \func{sessionOrder} \), assume a sequence of \( \po_n \), each of which represents the result of the \( n \)-steps \(\func{sessionOrder} \), so \( \po = \bigcup\limits_{n} \po_n \land \forall n, n' \ldotp n < n' \implies \po_n \subseteq \po_{n'} \).
    Therefore, if \( ( \tsid , \tsid' ) \in \po \), there must exist a \( n \) that \( ( \tsid , \tsid' ) \notin \po_{n-1} \) but \( ( \tsid , \tsid' ) \in \po_{n} \).
    This means there exists \( lc \) for same thread \( \thid \), such that \( \tsid \in lc(\thid) \).
    Since the \( lc \) is a partial function that records the last committed transactions of each thread.
    Note that if there is a new thread, it records the last committed transactions of its parent thread, while if it is a join point, it records both the parent and child last committed transactions.
    Then if the new transaction \( \tsid' \) commits, it must pick a starting time greater than any transactions included in \( lc(\thid) \).
    Assuming the time-stamp heap \( \tshp \) after the new transaction \( \tsid' \) committing and by the Lemma \ref{lem:happen-in-same-time}, we have \( \forall \loc, \loc', \ts, \ts', \op \in \Set{\wop,\eop}, \op' \in \Set{\rop,\sop} \ldotp \tshp(\loc)(\ts) = (\dontcare, \op, \tsid) \land \tshp(\loc')(\ts') = (\dontcare, \op', \tsid') \implies \ts < \ts' \), which implies \( (\tsid, \tsid') \in \po \).
\end{proof}

\begin{lem}[prefix]
    \label{lem:prefix}
    \( \tar; \vis \subseteq \vis \).
\end{lem}
\begin{proof}
    For all \( \tsid, \tsid', \tsid'' \), if \( (\tsid, \tsid') \in \tar \) and \( (\tsid', \tsid'') \in \vis \), by the definitions of \( \po \) and \( \vis \), the commit time of \( \tsid' \) is greater than the one of \( \tsid \) but smaller than the start time of \( \tsid'' \).
    Thus there must exist \( \loc, \loc'', \ts, \ts' , \ts'', \op \in \Set{\wop, \eop}  \) and \( \op'' \in \Set{\rop, \sop } \) such that  \( \tshp(\loc)(\ts) = (\dontcare, \op, \tsid) \), \( \tshp(\loc'')(\ts'') = (\dontcare, \op'', \tsid'') \) and \( \ts < \ts'' \), thus \( ( \tsid, \tsid'' ) \in \vis \).
\end{proof}

\begin{lem}[nocoflict]
    \label{lem:nocoflict}
    Two transactions cannot concurrently write to the same location, this means that one must observe another one.
    This is \( \forall \loc, \tsid, \tsid' \ldotp \tshp(\loc)(\dontcare) = (\dontcare, \wop, \tsid) \land  \tshp(\loc)(\dontcare) = (\dontcare, \wop, \tsid' ) \implies ((\tsid, \tsid') \in \vis \lor (\tsid', \tsid) \in \vis ))\).
\end{lem}
\begin{proof}
    Prove by contradiction.
    Assume \( (\tsid, \tsid') \notin \vis \land (\tsid', \tsid) \notin \vis \), this intuitively means one transaction is overlapped with another.
    Let \( \ts_{s}, \ts_{e}, \ts'_{s} \) and \( \ts'_{e} \) be the start time and end time of transaction \( \tsid \) and \( \tsid' \) respectively.
    Because of the symmetric,  we can assume that the start time of \( \tsid \) is in between \( \tsid' \), witch means \( \ts'_{s} < \ts_{s} < \ts'_{e} \).
    Now we consider \( \ts_{e} \).
    First note that \( \ts_{e} > \ts_{s} \) by Lemma \ref{lem:start-before-end}, therefore we need to consider two cases \( \ts'_{s} < \ts_{s} < \ts_{e} < \ts'_{e} \) and  \( \ts'_{s} < \ts_{s} < \ts'_{e} < \ts_{e}  \).
    Since both transaction write the same location \( \loc \), those two cases violate the \( \pred{consist} \) requirement in the semantics, so one of the transactions must pick another start and end time.
\end{proof}

\begin{lem}[ext]
    \label{lem:ext}
    A transaction should read the last values it can observe.
    This means that for all transaction \( \tsid \) and heap location \( \loc \), if the transaction read a value \( \val \) from the location, i.e.\ \( \exists \ts \ldotp \tshp(\loc)(\ts) = (\val, \rop, \tsid) \), the last transaction \( \tsid' \) who writes to the same location and can be observe by \( \tsid \), i.e.\ \( (\tsid, \tsid') \in \vis\), should have written the same value, meaning \( \exists \val', \ts' \ldotp \tshp(\loc)(\ts') = (\val', \wop, \tsid') \implies \val' = \val\)
\end{lem}
\begin{proof}
    Given the definition of \( \vis \), we have \( \ts' < \ts \).
    Because transaction \( \tsid' \) is the last one who write to the location, this means that \( \forall \tsid'', \ts'', \op'' \ldotp \tshp(\loc)(\ts'') = (\dontcare, \op'', \tsid'') \implies \op'' \neq \wop \).
    Thus by the \( \func{startstate} \) in the semantics, we have \( \val' = \val \).


\begin{lem}[acyclic]
    \label{lem:acyclic_relations}
    Both \( \vis \) and \( \tar \) are acyclic.
\end{lem}
\begin{proof}
    Proof by contradiction.
    Assume there are transactions from \( \tsid_{0} \) to \( \tsid_{n} \)  for some \( n \) that form a circle by \( \vis \) relation.
    By Lemma \ref{lem:atoic-rw}, let \( \ts^{s}_{i} \) and \( \ts^{e}_{i} \) be the start time and end time of the transaction \( \tsid_{i} \) respectively.
    By Lemma \ref{lem:read-before-write}, we have \( \ts^{s}_{i} < \ts^{e}_{i} \), and by definition of \( \vis \), thus \( \ts^{e}_{i} < \ts^{s}_{(i+1)\mod n} \).
    Therefore, \( \ts^{s}_{0} < \ts^{e}_{0} < \ts^{s}_{1} < \dots <  \ts^{e}_{n} < \ts^{s}_{0} \), so we have contradiction.

    Similarly for \( \tar \), we have contradiction that \( \ts^{e}_{0} < \ts^{e}_{1} < \dots  < \ts^{e}_{n} < \ts^{e}_{0} \).
\end{proof}

\begin{lem}[totalorder]
    The arbitration relations \( \tar \) can be extended to a total order \( \ar \) that does not violate Lemma \ref{lem:prefix}, Lemma \ref{lem:ext} and Lemma \ref{lem:acyclic_relations}.
\end{lem}
\begin{proof}
    We construct \( \ar \) from \( \tar \).
    Assume there is an initialisation transaction \( \tsid_{init} \) that happens before all other transactions, which means \( \forall \tsid \in \settrans \ldotp (\tsid_{init} , \tsid ) \in \tar\).
    Now we extend \( \tar \) until it is a total order.
    Let \( \tar_{0} = \tar \), and clearly \( \tar_{0} \) satisfies those Lemmas.

    Now assume that we have \( \tar_{n} \) for some \( n \) that satisfies Lemma \ref{lem:prefix}, Lemma \ref{lem:ext} and Lemma \ref{lem:acyclic_relations}.
    We pick first two transactions \( \tsid_{1} \) and \( \tsid_{2} \) that satisfies the following.
    First, if a transaction can reach \( \tsid_{1} \), it also can reach \( \tsid_{2} \), and vice versa, \( \forall \tsid \in \settrans \uplus \Set{\tsid_{init}} \ldotp (\tsid, \tsid_{1}) \in \tar_{n} \iff (\tsid, \tsid_{2}) \in \tar_{n} \).
    Second, let \( \mathcal{S} \) be the set of such transactions, we requires it is a strict total order with respect to \( \tar_{n} \), i.e.\ \( \forall \tsid, \tsid' \in \mathcal{S} \ldotp (\tsid,\tsid') \in \tar_{n} \lor (\tsid',\tsid) \in \tar_{n}  \).
    Intuitively, \( \tsid_{1} \) and \( \tsid_{2} \) is a branching point since \( \tsid_{init} \) with respect to \( \tar_{n} \).

    Immediately, there are two important properties of the transactions.
    Since that each step we add a new relations, so \( \vis \subseteq \tar \subseteq \tar_{0} \subseteq \dots \subseteq \tar_{n} \).
    Therefore, given \( ( \tsid_{1}, \tsid_{2} ) \notin \tar \land ( \tsid_{2}, \tsid_{1} ) \notin \tar \) and Lemma \ref{lem:atoic-rw}, these two transactions write locations in exactly the same time and given \( ( \tsid_{1}, \tsid_{2} ) \notin \vis \land ( \tsid_{2}, \tsid_{1} ) \notin \vis \) and the contrapositive of Lemma \ref{lem:nocoflict}, the transactions must write different locations.
    Now we claim that we can extend \( \tar_{n} \) by arbitrarily adding a relation between the two transactions and then taking the transitive closure, for instance \( \tar_{n+1} = ( \tar_{n} \uplus \Set{(\tsid_{1}, \tsid_{2})} )^{+}  \), and this new \( \tar_{n+1} \) still satisfies Lemma \ref{lem:prefix}, Lemma \ref{lem:ext} and Lemma \ref{lem:acyclic_relations}.

    Lemma \ref{lem:prefix}  holds, because \( \tsid_{1} \) and \( \tsid_{2} \) commit at the same time, so \( \forall \tsid \ldotp (\tsid_{1}, \tsid) \in \vis \iff  (\tsid_{2}, \tsid) \in \vis \).
    Then, by the assumption \( \tar_{n} ; \vis \subseteq \vis \), we have \( \tar_{n+1} ; \vis \subseteq \vis \).

    Lemma \ref{lem:ext} holds because \( \tsid_{1} \) and \( \tsid_{2} \) write different locations.
    Therefore, even though there is a new relation \( (\tsid_{1}, \tsid_{2}) \), the transaction \( \tsid_{2} \) still reads the newest values it can observe.
    Similarly for those transactions who depends on the values written by \( \tsid_{1} \), they still read the newest values they can observe.
                                                   
    Note that \( \vis \) remains the same some we only need to check \( \tar_{n+1} \).
    Assume that the new relation intrudes a circle, this circle must contain \( \tsid_{1} \) and \( \tsid_{2} \), for instance \( \tsid, \dots \tsid_{1}, \tsid_{2}, \dots \tsid' \).
    Given how we pick \( \tsid_{1} \) and \( \tsid_{2} \), all the transactions before \( \tsid_{1} \) in the circle also can reach \( \tsid_{2} \).
    This means \( \tsid, \dots \tsid_{1}, \dots \tsid' \) is also a circle, which contradict with assumption that \( \tar_{n} \) has no circle.
\end{proof}

