\section{Proof of semantics\label{sec:proof_semantics}}
\subsection{Soundness}
\begin{lem}[No overwrite]
    \label{lem:no-over-write}
    For a given location and time, if there is a value, threads cannot overwrite the values.
    \[ 
        \for{ \stk, \stk', \tshp, \tshp', \ts, \ts', \iprog, {\iprog}' ,\lb,\loc, \ts } ( \stk, \tshp, \ts ), \iprog \toT{\lb} ( \stk', \tshp', \ts' ), {\iprog}' \implies \tshp(\loc)(\ts)\undef \lor \tshp(\loc)(\ts) = \tshp'(\loc)(\ts)
    \]
\end{lem}
\begin{proof}
    Prove by structural induction on the semantics.
    For base cases \rl{PChoiseLeft}, \rl{PChoiseRight}, \rl{PLoop}, \rl{PSeqSkip}, \rl{PPar} and \rl{Pwait}, it is trivial because those rules do not change the state of time-stamp heap \( \tshp \).
    For base case \rl{Commit}, the new state \( \tshp' = \commit{\tshp}{\fph_{s}}{\fph_{e}}{\tsid}{\ts_{s}}{\ts_{e}} \) for some \( \fph_{s},\fph_{e}, \tsid, \ts_{s},\ts_{e} \).
    It only changes the values corresponding to times \( \ts_{s} \) or \( \ts_{e} \) of locations that are included in either tagged \( \etR \) or  \( \etW \).
    Those must be undefined in the original time-stamp heap \( \tshp \), because of the constrain \( \cancommitName \), especially the \( \wfhistName \).
    For the inductive case \rl{PSeq}, prove directly by the inductive hypothesis.
\end{proof}

\begin{lem}[Start before end]
    \label{lem:start-before-end}
    \label{lem:read-before-write}
    All the reads/starts operations of a transaction happen before all the writes/ends. 
    Formally,
    \[
        \for{ \stk, \stk', \tshp, \tshp', \ts, \ts', \iprog, {\iprog}' ,\lb } \pred{rw}{\tshp} \land ( \stk, \tshp, \ts ), \iprog \toT{\lb} ( \stk', \tshp', \ts' ), {\iprog}' \implies \pred{rw}{\tshp'}
    \]
    Where,
    \[
        \pred{rw}{\tshp} \defeq \for{ \loc, \loc', \ts, \ts',\etag \in \Set{\etS, \etR}, \etag' \in \Set{\etE,\etW}, \tsid } \tshp(\loc)(\ts) = (\stub, \etag, \tsid) \land \tshp(\loc')(\ts') = (\stub, \etag', \tsid) \implies \ts < \ts' 
    \]
\end{lem}
\begin{proof}
    Prove by structural induction on the semantics.
    For base cases \rl{PChoiseLeft}, \rl{PChoiseRight}, \rl{PLoop}, \rl{PSeqSkip}, \rl{PPar} and \rl{PWait}, it is trivial because those rules do not change the state of time-stamp heap \( \tshp \).
    For base case \rl{Commit}, the new state \( \tshp' = \commit{\tshp}{\fph_{s}}{\fph_{e}}{\tsid}{\ts_{s}}{\ts_{e}} \) for some \( \fph_{s},\fph_{e}, \tsid, \ts_{s},\ts_{e} \). 
    Because the functions associates \( \etR \), \( \etS \) to time \( \ts_{s} \), and \( \etW \), \( \etE \) to \( \ts_{e} \), and the fact that  \( \ts_{s} < \ts_{e} \), so \( \pred{rw}{\tshp'}\) holds.
    For the inductive case \rl{PSeq}, prove directly by the inductive hypothesis.
\end{proof}

\begin{lem}[Pair of start and end]
    Reads/starts operations are writes/ends operations appear as pairs.
    \[
            \for{ \stk, \stk', \tshp, \tshp', \ts, \ts', \iprog, {\iprog}' ,\lb } \pred{pair}{\tshp} \land ( \stk, \tshp, \ts ), \iprog \toT{\lb} ( \stk', \tshp', \ts' ), {\iprog}' \implies \pred{pair}{\tshp'}
    \]
    where,
    \[
        \pred{pair}{\tshp} \defeq \for{ \loc, \loc', \ts, \ts',\etag \in \Set{\etS, \etR}, \etag' \in \Set{\etE,\etW}, \tsid }  (\tshp(\loc)(\ts) = (\stub, \etag, \tsid) \iff \tshp(\loc')(\ts') = (\stub, \etag', \tsid)  )
    \]
\end{lem}
\begin{proof}
    Prove by structural induction on the semantics.
    For base cases \rl{PChoiseLeft}, \rl{PChoiseRight}, \rl{PLoop}, \rl{PSeqSkip}, \rl{PPar} and \rl{PWait}, it is trivial because those rules do not change the state of time-stamp heap \( \tshp \).
    For base case \rl{Commit}, the new state \( \tshp' = \commit{\tshp}{\fph_{s}}{\fph_{e}}{\tsid}{\ts_{s}}{\ts_{e}} \) for some \( \fph_{s},\fph_{e}, \tsid, \ts_{s},\ts_{e} \). 
    Because the function \(\commitName\) always extends a location \( \loc \) with a pair of operations, so \( \pred{rw}{\tshp'}\) holds.
    For the inductive case \rl{PSeq}, prove directly by the inductive hypothesis.
\end{proof}


\begin{lem}[Start/end at the same time]
    \label{lem:atoic-rw}
    \label{lem:happen-in-same-time}
    All the reads/starts operations among all locations of a transaction happen in the same time, so do all the writes/ends operations. 
    \[
        \for{ \stk, \stk', \tshp, \tshp', \ts, \ts', \iprog, {\iprog}' ,\lb } \pred{atom}{\tshp} \land ( \stk, \tshp, \ts ), \iprog \toT{\lb} ( \stk', \tshp', \ts' ), {\iprog}' \implies \pred{atom}{\tshp'}
    \]
    Where,
    \[
        \pred{atom}{\tshp} \defeq \for{ \loc, \loc', \ts, \ts', \tsid, \etag, \etag' } \tshp(\loc)(\ts) (\stub, \etag, \tsid)  \land \tshp(\loc')(\ts') = (\stub, \etag', \tsid) \land (\etag, \etag' \in \Set{\etS, \etR} \lor \etag, \etag' \in \Set{\etE, \etW} ) \implies \ts = \ts'
    \]
\end{lem}
\begin{proof}
    Prove by structural induction on the semantics.
    For base cases \rl{PChoiseLeft}, \rl{PChoiseRight}, \rl{PLoop}, \rl{PSeqSkip}, \rl{PPar} and \rl{Pwait}, it is trivial because those rules do not change the state of time-stamp heap \( \tshp \).
    For base case \rl{Commit}, the new state \( \tshp' = \commit{\tshp}{\fph_{s}}{\fph_{e}}{\tsid}{\ts_{s}}{\ts_{e}} \) for some \( \fph_{s},\fph_{e}, \tsid, \ts_{s},\ts_{e} \). 
    Because the functions associates all reads/starts operations, \( \etR \) and \(\etS \), of all locations to the same time \( \ts_{s} \), and writes/ends operations of all locations to the same time \( \ts_{e} \), so \( \pred{atom}{\tshp'}\) holds.
    For the inductive case \rl{PSeq}, prove directly by the inductive hypothesis.
\end{proof}

To define trace and then program order, we first extend the labels used in the semantics.
Each label has one extra parameter to record the thread that preforms the step, so the label looks like \( \lbC{\thid,\tsid} \), \( \lbF{\thid,\thid',\prog} \) and \( \lbJ{\thid,\thid',\ts} \).

\begin{defn}[Traces]
\label{def:traces}
    Given a initial state \( \tshp \) and \( \thpl \), a trace \( \trc \) is defined as a tuple \( (\setlabels,<) \) that satisfies predicate \( \pred{trace}{\tshp,\thpl,\setlabels,<,\nat} \), for some number \( \nat \).
\[
    \begin{rclarray}
        \func{traces}{\tshp,\thpl,0} & \defeq & \Set{(\emptyset, \emptyset,\tshp,\thpl)} \\
        \func{traces}{\tshp,\thpl,\nat} & \defeq & \myset{(\setlabels,<,\tshp',\thpl')}{(\tshp'', \thpl'') \toG{\lbID} (\tshp', \thpl' ) \land (\setlabels,<,\tshp'',\thpl'') \in \func{trace}{\tshp,\thpl,\setlabels,<,\nat-1}} \\
		& & \uplus \Setcon{
				(\setlabels \uplus \Set{\lb} ,< \uplus \myset{(\lb',\lb)}{| \lb' \in \setlabels}, \tshp',\thpl')
			}{ 
	            (\tshp'', \thpl'') \toG{\lb} (\tshp', \thpl' ) \land \lb \neq \lbID \land {} \\
	            (\setlabels,<,\tshp'',\thpl'') \in \func{trace}{\tshp,\thpl,\setlabels,<,\nat-1}
			}  \\
    \end{rclarray}
\]
\end{defn}

\begin{defn}[Program Order]
    \label{def:po}
\[ 
    \begin{rclarray}
        \func{programOrder}{\setlabels, <} & \defeq & ( \settrans, \po ) \\
        \settrans & \equiv & \myset{\tsid}{\lbC{\thid,\tsid} \in \setlabels } \\
        \po & \equiv & \myset{(\tsid, \tsid')}{\lbC{\thid,\tsid} < \lbC{\thid,\tsid'} } \uplus \myset{(\tsid, \tsid')}{\lbC{\thid,\tsid} < \lbF{\thid,\thid', \stub} < \lbC{\thid',\tsid'} } \\
            & & \uplus \myset{(\tsid, \tsid')}{\lbC{\thid,\tsid} < \lbJ{\thid',\thid, \stub} < \lbC{\thid',\tsid'} }
    \end{rclarray}
\]
\end{defn}

\begin{defn}[Visibility and arbitration]
    \label{def:vis-ar}
    Visibility and potential arbitration relations.
    \[
        \begin{rclarray}
            \func{graph}{\settrans,\tshp} & \defeq & (\vis,\tar) \\
            \vis & \equiv & \myset{(\tsid,\tsid') \in \settrans}{ 
                \exsts{ \loc, \loc', \ts, \ts', \etag \in \Set{\etW,\etE}, \etag' \in \Set{\etR,\etS} } \ts < \ts' \land {} \\
                \tshp(\loc)(\ts) = (\stub, \etag,\tsid) \land \tshp(\loc')(\ts') = (\stub, \etag',\tsid') 
			} \\
            \tar & \defeq & 
            \myset{(\tsid,\tsid')  \in \settrans}{ 
                \exsts{ \loc, \loc', \ts, \ts', \etag, \etag' \in \Set{\etW,\etE} } \ts < \ts' \land {} \\
                \tshp(\loc)(\ts) = (\stub, \etag,\tsid) \land \tshp(\loc')(\ts') = (\stub, \etag',\tsid') 
			}
        \end{rclarray}
    \]
\end{defn}

We will use notations \( (\settrans,\po,\vis,\tar, \tshp) \) to refer an element of the set:
\[
    \myset{(\settrans,\po,\vis,\tar, \tshp)}{ 
            (\settrans,\po) = \func{programOrder}{\setlabels,<} \land (\vis,\tar) = \func{graph}{\settrans,\tshp} \land {} \\
            (\setlabels,<,\tshp,\thpl) \in \bigcup\limits_{\nat \in \Nat}\func{traces}{\tshp',\thpl',\nat}
    } 
\]
For brevity, sometime we only mention and quantify few elements of this tuple but one should think they are quantified as an entire tuple.


\begin{lem}[Separation]
    \label{lem:seperate}
    If two transactions that are not associated by potentially arbitration relation \( \tar \), they access different locations but commit at the same time.
    \[
        \begin{array}{@{}l@{}}
            \for{ \tshp, \tar, \tsid, \tsid' } (\tsid, \tsid'), (\tsid',\tsid) \notin \tar \\
            \qquad \implies \for{ \loc, \loc', \ts, \ts', \etag, \etag \in \Set{\etW, \etE } } \tshp(\loc)(\ts) = ( \stub, \etag, \tsid) \land  \tshp(\loc')(\ts') = ( \stub, \etag', \tsid') \implies \ts = \ts' \land \loc \neq \loc'
        \end{array}
    \]
\end{lem}
\begin{proof}
    Given the definition of \( \tar \), \( \ts = \ts' \) holds, and \( \loc \neq \loc' \) is derived from Lemma \ref{lem:atoic-rw}.
\end{proof}


\begin{lem}[Semi-acyclic]
    \label{lem:semi-acyclic}
    Both \( \vis \) and \( \tar \) are acyclic.
\end{lem}
\begin{proof}
    Proof by contradiction.
    Assume that there is a circle by \( \vis \), which means that \( \bigwedge\limits_{0 \leq i \leq n} (\tsid_{i}, \tsid_{i+1}) \in \vis \land \tsid_{0} = \tsid_{n} \) for some \( \tsid_{0} \) to \( \tsid_{n}\).
    By Lemma \ref{lem:atoic-rw}, each transaction has a start time and a end time, thus let \( \ts^{s}_{i} \) and \( \ts^{e}_{i} \) be the start time and end time of the transaction \( \tsid_{i} \) respectively.
    By Lemma \ref{lem:read-before-write}, we have \( \ts^{s}_{i} < \ts^{e}_{i} \), and by definition of \( \vis \), thus \( \ts^{e}_{i} < \ts^{s}_{i+1} \).
    Therefore, \( \ts^{s}_{0} < \ts^{e}_{0} < \ts^{s}_{1} < \dots <  \ts^{s}_{n} \), and we have contradiction that \( \ts^{s}_{0} < \ts^{s}_{n} \).

    Similarly for \( \tar \), we have contradiction that \( \ts^{e}_{0} < \ts^{e}_{1} < \dots  < \ts^{e}_{n} \).
\end{proof}

We can extend partial order \( \tar \) to a total order \( \ar \) by pick orders between those unrelated transactions.
First, we define an auxiliary function that returns a set that includes the first transactions (might be more than two) that branch.
To simplify, assume there is a unique initial transactions denoted by \( \tsid_{init} \), where \( (\tsid_{init}, \tsid) \in \tar \) for all \( \tsid \).

\begin{defn}[First Branch]
    \[
        \begin{rclarray}
            \func{firstTrans}{\settrans, \tar} & \defeq & \tsid \ \texttt{where} \ \for{\tsid' \in \settrans } \tsid = \tsid' \lor (\tsid, \tsid') \in \tar \\
            \func{firstBranch}{\settrans, \tar} & \defeq &
            \begin{cases}
                \emptyset & \settrans = \emptyset \\
                \func{firstBranch}{\settrans \setminus \Set{\func{firstTrans}{\settrans, \tar}}, \tar} & |\func{dec}{\settrans, \tar}| = 1 \\
                \func{dec}{\settrans, \tar} & |\func{dec}{\settrans, \tar}| > 1 \\
            \end{cases} \\
            \func{dec}{\settrans, \tar} & \defeq & \myset{\tsid}{\exsts{ \tsid_{init} = \func{firstTrans}{\settrans, \tar} } (\tsid_{init}, \tsid) \in \tar \land \neg\exsts{ \tsid' } (\tsid_{init}, \tsid'),(\tsid', \tsid) \in \tar}
        \end{rclarray}
    \]
\end{defn}
\sx{Need a bit work to change the first trans function}

Intuitively, we take the first two transactions that are not connected, which definitely touch different locations by Lemma \ref{lem:seperate}, therefore we can simply pick a order and take the transitive closure.
We continue the process until it is a total order.

\begin{defn}[Total relation]
    \label{def:tototal}
    \[
        \begin{rclarray}
            \func{toTotal}{\settrans, \tar} & \defeq & 
                \begin{cases}
                    (\settrans, \tar) & \func{firstBranch}{\settrans, \tar} = \emptyset\\ 
                    \func{toTotal}{\settrans, ( \tar \uplus \Set{(\tsid, \tsid')})^{+}} & \tsid, \tsid' \in \func{firstBranch}{\settrans, \tar} \\    
                \end{cases}
            \\
        \end{rclarray}
    \]
\end{defn}

We will use notations \( (\settrans,\po,\vis,\ar, \tshp) \) to refer an element of the set:
\[
\myset{(\settrans, \po, \vis, \ar, \tshp)}{( \settrans, \ar ) = \func{toTotal}{\settrans, \tar}} \\
\]

\begin{lem}[Visibility]
    \label{lem:visibility}
    Visibility relation should be a subset of arbitration relation, i.e.\ \( \vis \subseteq \ar \).
\end{lem}
\begin{proof}
    For all transactions \( \tsid \) and \( \tsid' \), if \( ( \tsid, \tsid' ) \in \vis \), it means that transaction \( \tsid \) commits before \( \tsid' \) starts, so that \( \tsid \) must start before \( \tsid' \) starts, by Lemma \ref{lem:start-before-end}.
    This means \( (\tsid, \tsid') \in \tar \) by the definition of \( \tar \), and because \( \tar \subseteq \ar \), so \( (\tsid, \tsid') \in \ar \).
\end{proof}

\begin{lem}[Monotonic time in a thread]
    \label{lem:mono-time-thread}
    The thread's local time monotonically increase.
    This is  
    \[ 
        \for{ \stk, \stk', \tshp, \tshp', \ts, \ts', \iprog, {\iprog}' ,\lb,\loc, \ts } ( \stk, \tshp, \ts ), \iprog \toT{\lb} ( \stk', \tshp', \ts' ), {\iprog}' \implies \ts < \ts'
    \]
\end{lem}
\begin{proof}
    Indication on the structure of the operational semantics.
    For base cases \rl{PChoiseLeft}, \rl{PChoiseRight}, \rl{PLoop}, \rl{PSeqSkip} and \rl{PPar}, it is trivial since those rules do not change the time.
    For \rl{Commit}, the premiss implies that \( \ts' > \ts \) and for \rl{PWait}, \( \ts' = \max\Set{\ts, \stub} \geq \ts\).
    For the inductive case \rl{PSeq}, prove directly by the inductive hypothesis.
\end{proof}

\begin{lem}[Session]
    \label{lem:session}
    \( \po \subseteq \vis \).
\end{lem}   
\begin{proof}
    By a case analysis of the definition of \( \po \).
    For \( \tsid \) and \( \tsid' \) where \( \lbC{\thid,\tsid} < \lbC{\thid,\tsid'} \), it means that transaction \( \tsid \) is reduced by the semantics before \( \tsid' \) is reduced.
    Then by Lemma \ref{lem:mono-time-thread}, the commit time of \( \tsid \) is smaller than the start time of \( \tsid' \), so that \( (\tsid, \tsid') \in \vis \).

    For \( \tsid \) and \( \tsid' \) where \( \lbC{\thid,\tsid} < \lbF{\thid,\thid', \stub} < \lbC{\thid',\tsid'} \), first note that in the \rl{PFork} the parent thread starts at time \( \ts \) and ends at \( \ts' \), and the child thread initialises with the time \( \ts' \), where  in fact \( \ts = \ts' \)
    By \( \lbC{\thid,\tsid} < \lbF{\thid,\thid', \stub}  \), the transaction \( \thid \) is reduced before the fork, so by Lemma \ref{lem:mono-time-thread}, the end time of \( \thid \) is smaller than \( \ts \).
    By \( \lbF{\thid,\thid', \stub} < \lbC{\thid',\tsid'} \), the transaction \( \thid' \) is reduced after the fork and also by Lemma \ref{lem:mono-time-thread}, the start time of \( \thid \) is greater or equal to \( \ts' \).
    Therefore, \( (\tsid, \tsid') \in \vis \).

    Similarly, for \( \tsid \) and \( \tsid' \) where \( \lbC{\thid,\tsid} < \lbJ{\thid',\thid, \stub} < \lbC{\thid',\tsid'} \), all the transactions by thread \( \thid \) must have smaller start and end times than all the transactions by thread \( \thid' \) after the join point.
    Therefore, \( (\tsid, \tsid') \in \vis \).
\end{proof}

\sx{The session lemma I feel slightly unhappy, because it seems not very formal.}

\begin{lem}[Semi-prefix]
    \label{lem:semi-prefix}
    \( \tar; \vis \subseteq \vis \).
\end{lem}
\begin{proof}
    For all \( \tsid, \tsid', \tsid'' \), if \( (\tsid, \tsid') \in \tar \) and \( (\tsid', \tsid'') \in \vis \), by the definitions of \( \po \) and \( \vis \), the commit time of \( \tsid' \) is greater than the one of \( \tsid \) but smaller than the start time of \( \tsid'' \).
    Thus there must exist \( \loc, \loc'', \ts, \ts' , \ts'', \etag \in \Set{\etW, \etE}  \) and \( \etag'' \in \Set{\etR, \etS } \) such that  \( \tshp(\loc)(\ts) = (\stub, \etag, \tsid) \), \( \tshp(\loc'')(\ts'') = (\stub, \etag'', \tsid'') \) and \( \ts < \ts'' \), thus \( ( \tsid, \tsid'' ) \in \vis \).
\end{proof}

\begin{lem}[Prefix]
    \label{lem:prefix}
    \( \ar; \vis \subseteq \vis \).
\end{lem}
\begin{proof}
    For all \( \tsid, \tsid', \tsid'' \) that \( (\tsid, \tsid') \in \ar \) and \( (\tsid', \tsid'') \in \vis \), if \( (\tsid, \tsid') \in \tar \), it is proven by Lemma \ref{lem:semi-prefix}.
    If \( ( \tsid, \tsid' ) \notin \tar \), it means it is a new edge by the \funcn{toTotal} function from Definition \ref{def:tototal}.
    By the Lemma \ref{lem:seperate}, \( \tsid \) and \( \tsid' \) commit at the same time.
    By the definition of \( \vis \), the commit time of \( \tsid' \) is smaller than the start time of \( \tsid'' \).
    Therefore, the commit time of \( \tsid \) is also smaller than the start time of \( \tsid'' \), so that \( ( \tsid, \tsid'' ) \in \vis \).
\end{proof}

\begin{lem}[No conflict]
    \label{lem:nocoflict}
    Two transactions cannot concurrently write to the same location, this means that one must observe another one.
    This is \( \for{ \loc, \tsid, \tsid' } \tshp(\loc)(\stub) = (\stub, \etW, \tsid) \land  \tshp(\loc)(\stub) = (\stub, \etW, \tsid' ) \implies ((\tsid, \tsid') \in \vis \lor (\tsid', \tsid) \in \vis ))\).
\end{lem}
\begin{proof}
    Prove by contradiction.
    Assume \( (\tsid, \tsid') \notin \vis \land (\tsid', \tsid) \notin \vis \), this intuitively means one transaction is overlapped with another.
    Let \( \ts_{s}, \ts_{e}, \ts'_{s} \) and \( \ts'_{e} \) be the start time and end time of transaction \( \tsid \) and \( \tsid' \) respectively.
    Because of the symmetry,  we can assume that the start time of \( \tsid \) is in between \( \tsid' \), witch means \( \ts'_{s} < \ts_{s} < \ts'_{e} \).
    Now we consider \( \ts_{e} \).
    First note that \( \ts_{e} > \ts_{s} \) by Lemma \ref{lem:start-before-end}, therefore we need to consider two cases \( \ts'_{s} < \ts_{s} < \ts_{e} < \ts'_{e} \) and  \( \ts'_{s} < \ts_{s} < \ts'_{e} < \ts_{e}  \).
    Since both transaction write the same location \( \loc \), those two cases violate the \( \predn{consist} \) requirement in the semantics, so one of the transactions must pick another start and end time.
\end{proof}

\begin{lem}[External]
    \label{lem:ext}
    A transaction should read the last values it can observe.
    This means that for all transaction \( \tsid \) and heap location \( \loc \), if the transaction read a value \( \val \) from the location, i.e.\ \( \exsts{ \ts } \tshp(\loc)(\ts) = (\val, \etR, \tsid) \), the last transaction \( \tsid' \) who writes to the same location and can be observe by \( \tsid \), i.e.\ \( (\tsid, \tsid') \in \vis\), should have written the same value, meaning \( \exsts{ \val', \ts' } \tshp(\loc)(\ts') = (\val', \etW, \tsid') \implies \val' = \val\)
\end{lem}
\begin{proof}
    Given the definition of \( \vis \), we have \( \ts' < \ts \).
    Because transaction \( \tsid' \) is the last one who write to the location, this means that \( \for{ \tsid'', \ts'', \etag'' } \tshp(\loc)(\ts'') = (\stub, \etag'', \tsid'') \implies \etag'' \neq \etW \).
    Thus by the \( \funcn{startstate} \) in the semantics, we have \( \val' = \val \).
\end{proof}

\begin{lem}[Acyclic]
    \label{lem:acyclic}
    Both \( \vis \) and \( \ar \) are acyclic.
\end{lem}
\begin{proof}
    For \( \vis \), it is proven by Lemma \ref{lem:semi-acyclic}.

    To prove \( \ar \) is acyclic, we prove inductively \( \tar_{i} \) is acyclic, where \( \tar_{0} = \tar \), \( \tar_{n} = \ar \) and \( \tar_{i+1} = (\tar_{i} \uplus \Set{(\tsid, \tsid')})^{+} \) for some \( \tsid \) and \( \tsid' \), which follows the process of \funcn{toTotal} from Definition \ref{def:tototal}.
    For base case \( \tar_{0} \), it is proven by Lemma \ref{lem:semi-acyclic}.
    Now assume \( \tar_{i} \) is acyclic and \( \tar_{i+1} = (\tar_{i} \uplus \Set{(\tsid, \tsid')})^{+} \) for some \( \tsid \) and \( \tsid' \), we prove by contradiction that \( \tar_{i+1} \) is acyclic.
    Given the hypothesis, if there is circle in \( \tar_{i+1} \), such circle either contain the edge \( (\tsid, \tsid') \), or can be broken down to a circle containing the edge \( (\tsid, \tsid') \), because of the transitive closure.
    Note that by breaking down to a circle containing \( ( \tsid, \tsid' ) \), the rest edges inside the circle must be in \( \tar_{i} \).
    Let assume the circle is \( \tsid_{0}, \tsid_{1}, \dots, \tsid_{i}, \tsid, \tsid', \tsid_{i+1}, \dots, \tsid_{n} \) where \( \tsid_{0} = \tsid_{n} \).
    By the \( \funcn{toTotal} \) function from Definition \ref{def:tototal}, \( \tsid, \tsid' \in \func{firstBranch}{\settrans, \tar_{i}}\), which means that for all \( \tsid'' \), \( (\tsid'', \tsid) \in \tar_{i} \) if and only if \( ( \tsid'', \tsid') \in \tar_{i} \), therefore \( (\tsid'', \tsid) \in \tar_{i+1} \) if and only if \( ( \tsid'', \tsid') \in \tar_{i+1} \).
    This means that the sequence without \( \tsid \), i.e.\ \( \tsid_{0}, \tsid_{1}, \dots, \tsid_{i}, \tsid', \tsid_{i+1}, \dots, \tsid_{n} \), is still a sequence where two adjacent transactions are connected by \( \tar_{i+1} \), and this new sequence is a circle.
    Now all the edges in the new sequence/circle already exist in \( \tar_{i} \), which violates our hypothesis.
    Therefore by contradiction, \( \tar_{i+1} \) is acyclic.
    Given that, \( \ar \) is acyclic.
\end{proof}

\begin{lem}[Total order]
    \label{lem:totalorder}
    \( \ar \) is a total order.
\end{lem}
\begin{proof}
    By Lemma \ref{lem:acyclic}, \( \ar \) is acyclic, and by \defin \ref{def:tototal}, for all \( \tsid \) and \( \tsid' \), either \( (\tsid, \tsid') \in \ar \) or \( (\tsid', \tsid) \in \ar \).
    Therefore, it is a total order.
\end{proof}

\begin{defn}[Snapshot Isolation Graph]
    \(\sig \in \SIGraphs \)
\end{defn}

\begin{thm}[Soundness of the semantics]
    The thread pool operational semantics $\toG{}$ (\defin\ref{def:thread_pool_semantics}) is sound.
    This means
    \[
        \begin{array}{@{}l@{}}
            \exsts{ f } \for{ \tshp, \thpl, \tshp', \thpl' } (\tshp, \thpl) \toG{\lb} (\tshp', \thpl') \land \exsts{ \sig \in \SIGraphs } f(\tshp, \thpl) = \sig \implies \exsts{ \sig' \in \SIGraphs } f(\tshp', \thpl') = \sig'
        \end{array}
    \]
\end{thm}
\begin{proof}
    Given the \defin \ref{def:traces}, there is a unique corresponding trace \trace, and then by \defin \ref{def:po}, \ref{def:vis-ar} and \ref{def:tototal} there exists a \( \sig' \).
    Then, by Lemma \ref{lem:visibility}, \ref{lem:session}, \ref{lem:prefix}, \ref{lem:nocoflict}, \ref{lem:ext}, \ref{lem:totalorder}, the \( \sig' \in \SIGraphs \).
\end{proof}
\sx{Not really right but keep this way for now}

\subsection{Completeness}
\sx{Define a function from a graph to a set of possible \( \fph \) }

