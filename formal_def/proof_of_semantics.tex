\section{Proof of semantics\label{sec:proof_semantics}}
\begin{lem}
    \label{lem:no-over-write}
    Threads can only write to values that are originally undefined,
    \[ 
        \forall \stk, \stk', \tshp, \tshp', \ts, \ts', \progext, {\progext}' ,\tll,\loc, \ts \ldotp ( \stk, \tshp, \ts ), \progext \threadtransfer{\tll} ( \stk', \tshp', \ts' ), {\progext}' \implies \tshp(\loc)(\ts)\undef \lor \tshp(\loc)(\ts) = \tshp'(\loc)(\ts)
    \]
\end{lem}
\begin{proof}
    Prove by structural induction on the semantics.
    For base cases \rl{PChoiseLeft}, \rl{PChoiseRight}, \rl{PLoopSkip}, \rl{PLoop}, \rl{PSeqSkip}, \rl{PPar} and \rl{Pwait}, it is trivial because those rules do not change the state of time-stamp heap \( \tshp \).
    For base case \rl{Commit}, the new state \( \tshp' = \func{commitTrans}{\tshp,\hp_{s},\hp_{e},\ws,\rs, \tsid, \ts_{s},\ts_{e}} \) for some \( \hp_{s},\hp_{e},\ws,\rs, \tsid, \ts_{s},\ts_{e} \).
    It only changes the values corresponding to times \( \ts_{s} \) or \( \ts_{e} \) of locations that are included in either the read set \( \rs \) or the write set \( \ws \).
    Those must be undefined in the original time-stamp heap \( \tshp \), because of the constrain \( \texttt{allowcommit} \), especially the \( \texttt{wellformhist} \).
    For the inductive case \rl{PSeq}, prove directly by the inductive hypothesis.
\end{proof}

\begin{lem}
    \label{lem:start-before-end}
    \label{lem:read-before-write}
    All the reads/starts operations of a transaction happen before all the writes/ends. 
    Formally,
    \[
        \forall \stk, \stk', \tshp, \tshp', \ts, \ts', \progext, {\progext}' ,\tll \ldotp \pred{rw}{\tshp} \land ( \stk, \tshp, \ts ), \progext \threadtransfer{\tll} ( \stk', \tshp', \ts' ), {\progext}' \implies \pred{rw}{\tshp'}
    \]
    Where,
    \[
        \pred{rw}{\tshp} \defeq \forall \loc, \loc', \ts, \ts',\op \in \Set{\sop, \rop}, \op' \in \Set{\eop,\wop} \tsid \ldotp \tshp(\loc)(\ts) = (\dontcare, \op, \tsid) \land \tshp(\loc')(\ts') = (\dontcare, \op', \tsid) \implies \ts < \ts' 
    \]
\end{lem}
\begin{proof}
    Prove by structural induction on the semantics.
    For base cases \rl{PChoiseLeft}, \rl{PChoiseRight}, \rl{PLoopSkip}, \rl{PLoop}, \rl{PSeqSkip}, \rl{PPar} and \rl{PWait}, it is trivial because those rules do not change the state of time-stamp heap \( \tshp \).
    For base case \rl{Commit}, the new state \( \tshp' = \func{commitTrans}{\tshp,\hp_{s},\hp_{e},\ws,\rs, \tsid, \ts_{s},\ts_{e}} \) for some \( \hp_{s},\hp_{e},\ws,\rs, \tsid, \ts_{s},\ts_{e} \). 
    Because the functions associates \( \rop \), \( \sop \) to time \( \ts_{s} \), and \( \wop \), \( \eop \) to \( \ts_{e} \), and the fact that  \( \ts_{s} < \ts_{e} \), so \( \pred{rw}{\tshp'}\) holds.
    For the inductive case \rl{PSeq}, prove directly by the inductive hypothesis.
\end{proof}


\begin{lem}
    \label{lem:atoic-rw}
    \label{lem:happen-in-same-time}
    All the reads/starts operations among all locations of a transaction happen in the same time, so do all the writes/ends operations. 
    \[
        \forall \stk, \stk', \tshp, \tshp', \ts, \ts', \progext, {\progext}' ,\tll \ldotp \pred{atom}{\tshp} \land ( \stk, \tshp, \ts ), \progext \threadtransfer{\tll} ( \stk', \tshp', \ts' ), {\progext}' \implies \pred{atom}{\tshp'}
    \]
    Where,
    \[
        \pred{atom}{\tshp} \defeq \forall \loc, \loc', \ts, \ts', \tsid, \op, \op'\ldotp \tshp(\loc)(\ts) (\dontcare, \op, \tsid)  \land \tshp(\loc')(\ts') = (\dontcare, \op', \tsid) \land (\op, \op' \in \Set{\sop, \rop} \lor \op, \op' \in \Set{\eop, \wop} ) \implies \ts = \ts'
    \]
\end{lem}
\begin{proof}
    Prove by structural induction on the semantics.
    For base cases \rl{PChoiseLeft}, \rl{PChoiseRight}, \rl{PLoopSkip}, \rl{PLoop}, \rl{PSeqSkip}, \rl{PPar} and \rl{Pwait}, it is trivial because those rules do not change the state of time-stamp heap \( \tshp \).
    For base case \rl{Commit}, the new state \( \tshp' = \func{commitTrans}{\tshp,\hp_{s},\hp_{e},\ws,\rs, \tsid, \ts_{s},\ts_{e}} \) for some \( \hp_{s},\hp_{e},\ws,\rs, \tsid, \ts_{s},\ts_{e} \). 
    Because the functions associates all reads/starts operations, \( \rop \) and \(\sop \), of all locations to the same time \( \ts_{s} \), and writes/ends operations of all locations to the same time \( \ts_{e} \), so \( \pred{atom}{\tshp'}\) holds.
    For the inductive case \rl{PSeq}, prove directly by the inductive hypothesis.
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  Define the po in one go
%\begin{defn}
%Program order \( \po \).
%\[ 
    %\begin{rclarray}
        %lc \in \texttt{LastCommit} & \defeq & \Threadid \parfun \powerset{\Transid} \\
        %\func{programOrder}^{0}(\tshp_{init}, \tdpl_{init}) & \defeq & \Set{(\emptyset, \emptyset, \tshp_{init}, \tdpl_{init}, \emptyset)} \\
        %\func{programOrder}^{\nat}(\tshp_{init}, \tdpl_{init}) & \defeq & 
        %\Set{(\settrans, \po, \tshp, \tdpl, lc) \middle| \ \dagger \ } \\
        %\dagger & \equiv & 
            %\begin{array}{@{}l@{}}
                %\exists \settrans', \po', \tshp', \tdpl', lc', \tll \ldotp (\settrans', \po', \tshp', \tdpl' , lc') \in \func{sessionOrder}^{\nat -1}(\tdpl_{init}, \tshp_{init}) \land {} \\
                %( \tshp', \tdpl' ) \globaltransfer{\tll} ( \tshp, \tdpl ) \land {} \\
                %\tll = \lid \implies 
                %\begin{formulea}
                    %\settrans = \settrans' \land \po = \po' \land \tdpl = \tdpl' \land lc = lc'
                %\end{formulea} \land {} \\
                %\exists \tsid \ldotp \tll = \lcmt{\tsid} \implies  
                %\begin{formulea}
                    %\exists \tdpl'', \stk,\stk', \ts, \ts', \progext, {\progext}', \thid \ldotp \settrans = \settrans' \uplus \Set{\tsid} \land {} \\
                        %\po = \po' \uplus \Set{(\tsid', \tsid) \middle| \tsid' \in lc'(\thid)} \land {} \\
                        %\tdpl = \tdpl'' \uplus \Set{\thid \mapsto (\stk,\ts,\progext)} \land {} \\
                        %\tdpl' = \tdpl'' \uplus \Set{\thid \mapsto (\stk',\ts',{\progext}')} \land {}\\
                        %lc = lc'\remapsto{\thid}{\Set{\tsid}}
                %\end{formulea} \land {} \\
                %\exists \thid, \prog \ldotp \tll = \lfork{\thid, \prog} \implies 
                %\begin{formulea}
                    %\exists \tdpl'', \stk, \ts, \progext, {\progext}', \thid' \ldotp \settrans = \settrans' \land \po = \po' \land {} \\
                    %lc = lc' \uplus \Set{\thid \mapsto lc'(\thid')} \land {} \\
                    %\tdpl = \tdpl'' \uplus \Set{\thid \mapsto (\emptyset,\ts,\prog), \thid' \mapsto (\stk,\ts,{\progext}')} \land {} \\
                    %\tdpl' = \tdpl'' \uplus \Set{\thid' \mapsto (\stk,\ts,\progext)} 
                %\end{formulea} \land {} \\
                %\exists \thid,\ts \ldotp \tll = \ljoin{\thid, \ts} \implies 
                %\begin{formulea}
                    %\exists \tdpl'', \stk,\stk',  \ts', \progext, \progext', \thid' \ldotp
                    %\settrans = \settrans' \land \po = \po' \land {} \\
                    %lc = lc'\remapsto{\thid'}{lc'(\thid) \uplus lc'(\thid')} \setminus \Set{\thid \mapsto \dontcare} \land {} \\
                    %\tdpl = \tdpl'' \uplus \Set{\thid' \mapsto (\stk',\max\Set{\ts,\ts'},\progext)} \land {} \\
                    %\tdpl' = \tdpl'' \uplus \Set{\thid \mapsto (\stk,\ts,\pskip), \thid' \mapsto (\stk',\ts',{\progext}')}
                %\end{formulea} 
            %\end{array} \\
        %\func{histories}(\tshp_{init}, \tdpl_{init}) & \defeq & \Set { (\settrans,\po,\tshp) \middle| (\settrans,\po,\tshp, \dontcare, \dontcare) \in  \bigcup\limits_{\nat \in \Nat } \func{sessionOrder}^{\nat}(\tshp_{init}, \tdpl_{init}) }
    %\end{rclarray}
%\]
%\end{defn}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  Define the po in one go

To define trace and then program order, we first extend the labels used in the semantics.
Each label has one extra parameter to record the thread that preforms the step, so the label looks like \( \lcommit{\thid,\tsid} \), \( \lfork{\thid,\thid',\prog} \) and \( \ljoin{\thid,\thid',\ts} \).

\begin{defn}[Traces]
    Given a initial state \( \tshp \) and \( \tdpl \), a trace \( \trc \) is define as a tuple \( (\setlabels,<) \) that satisfies predicate \( \pred{trace}{\tshp,\tdpl,\setlabels,<,\nat} \), for some number \( \nat \).
\[
    \begin{rclarray}
        \func{traces}{\tshp,\tdpl,0} & \defeq & \Set{(\emptyset, \emptyset,\tshp,\tdpl)} \\
        \func{traces}{\tshp,\tdpl,\nat} & \defeq & \Set{(\setlabels,<,\tshp',\tdpl') \middle| (\tshp'', \tdpl'') \globaltransfer{\lid} (\tshp', \tdpl' ) \land (\setlabels,<,\tshp'',\tdpl'') \in \func{trace}{\tshp,\tdpl,\setlabels,<,\nat-1}} \\
                                                    & & \uplus \Set{(\setlabels \uplus \Set{\tll} ,< \uplus \Set{(\tll',\tll) \middle| \tll' \in \setlabels}, \tshp',\tdpl') \middle| 
        \begin{array}{@{}l@{}}
            (\tshp'', \tdpl'') \globaltransfer{\tll} (\tshp', \tdpl' ) \land \tll \neq \lid \land {} \\
            (\setlabels,<,\tshp'',\tdpl'') \in \func{trace}{\tshp,\tdpl,\setlabels,<,\nat-1}
        \end{array}
}  \\
    \end{rclarray}
\]
\end{defn}

\begin{defn}[Program Order]
\[ 
    \begin{rclarray}
        \func{programOrder}{\setlabels, <} & \defeq & ( \settrans, \po ) \\
        \settrans & \equiv & \Set{\tsid \middle| \lcmt{\thid,\tsid} \in \setlabels } \\
        \po & \equiv & \Set{(\tsid, \tsid') \middle| \lcmt{\thid,\tsid} < \lcmt{\thid,\tsid'} } \uplus \Set{(\tsid, \tsid') \middle| \lcmt{\thid,\tsid} < \lfork{\thid,\thid', \dontcare} < \lcmt{\thid',\tsid'} } \\
            & & \uplus \Set{(\tsid, \tsid') \middle| \lcmt{\thid,\tsid} < \ljoin{\thid',\thid, \dontcare} < \lcmt{\thid',\tsid'} }
    \end{rclarray}
\]
\end{defn}

\begin{defn}
    Visibility and potential arbitration relations.
    \[
        \begin{rclarray}
            \func{graph}{\settrans,\tshp} & \defeq & (\vis,\tar) \\
            \vis & \equiv & \Set{(\tsid,\tsid') \in \settrans \middle| 
            \begin{array}{@{}l@{}}
                \exists \loc, \loc', \ts, \ts', \op \in \Set{\wop,\eop}, \op' \in \Set{\rop,\sop} \ldotp \ts < \ts' \land {} \\
                \tshp(\loc)(\ts) = (\dontcare, \op,\tsid) \land \tshp(\loc')(\ts') = (\dontcare, \op',\tsid') 
            \end{array} } \\
            \tar & \defeq & \Set{(\tsid,\tsid')  \in \settrans \middle| 
            \begin{array}{@{}l@{}}
                \exists \loc, \loc', \ts, \ts', \op, \op' \in \Set{\wop,\eop} \ldotp \ts < \ts' \land {} \\
                \tshp(\loc)(\ts) = (\dontcare, \op,\tsid) \land \tshp(\loc')(\ts') = (\dontcare, \op',\tsid') 
            \end{array} }
        \end{rclarray}
    \]
\end{defn}

We will use notations \( (\settrans,\po,\vis,\tar, \tshp) \) to refer an element of the set:
\[
    \Set{(\settrans,\po,\vis,\tar, \tshp) \middle| 
        \begin{array}{@{}l@{}}
            (\settrans,\po) = \func{programOrder}{\setlabels,<} \land (\vis,\tar) = \func{graph}{\settrans,\tshp} \land {} \\
            (\setlabels,<,\tshp,\tdpl) \in \bigcup\limits_{\nat \in \Nat}\func{traces}{\tshp',\tdpl',\nat}
        \end{array}
    } 
\]
For brevity, sometime we only mention and quantify few elements of this tuple but one should think they are quantified as an entire tuple.


\begin{lem}[Separation]
    \label{lem:seperate}
    If two transactions that are not associated by potentially arbitration relation \( \tar \), they access different locations but commit at the same time.
    \[
        \begin{array}{@{}l@{}}
            \forall \tshp, \tar, \tsid, \tsid' \ldotp (\tsid, \tsid'), (\tsid',\tsid) \notin \tar \\
            \qquad \implies \forall \loc, \loc', \ts, \ts', \op, \op \in \Set{\wop, \eop } \ldotp \tshp(\loc)(\ts) = ( \dontcare, \op, \tsid) \land  \tshp(\loc')(\ts') = ( \dontcare, \op', \tsid') \implies \ts = \ts' \land \loc \neq \loc'
        \end{array}
    \]
\end{lem}
\begin{proof}
    Given the definition of \( \tar \), \( \ts = \ts' \) holds, and \( \loc \neq \loc' \) is derived from Lemma \ref{lem:atoic-rw}.
\end{proof}


\begin{lem}[Acyclic]
    \label{lem:acyclic_relations}
    Both \( \vis \) and \( \tar \) are acyclic.
\end{lem}
\begin{proof}
    Proof by contradiction.
    Assume that there is a circle by \( \vis \), which means that \( \bigwedge\limits_{0 \leq i \leq n} (\tsid_{i}, \tsid_{i+1}) \in \vis \land \tsid_{0} = \tsid_{n} \) for some \( \tsid_{0} \) to \( \tsid_{n}\).
    By Lemma \ref{lem:atoic-rw}, each transaction has a start time and a end time, thus let \( \ts^{s}_{i} \) and \( \ts^{e}_{i} \) be the start time and end time of the transaction \( \tsid_{i} \) respectively.
    By Lemma \ref{lem:read-before-write}, we have \( \ts^{s}_{i} < \ts^{e}_{i} \), and by definition of \( \vis \), thus \( \ts^{e}_{i} < \ts^{s}_{i+1} \).
    Therefore, \( \ts^{s}_{0} < \ts^{e}_{0} < \ts^{s}_{1} < \dots <  \ts^{s}_{n} \), and we have contradiction that \( \ts^{s}_{0} < \ts^{s}_{n} \).

    Similarly for \( \tar \), we have contradiction that \( \ts^{e}_{0} < \ts^{e}_{1} < \dots  < \ts^{e}_{n} \).
\end{proof}

We can extend partial order \( \tar \) to a total order \( \ar \) by pick orders between those unrelated transactions.
First, we define an auxiliary function that returns a set that includes first transactions (might be more than two) that have branch.
To simplify, assume there is a unique initial transactions denoted by \( \tsid_{init} \), where \( (\tsid_{init}, \tsid) \in \tar \).

\begin{defn}[First Branch]
    \[
        \begin{rclarray}
            \func{firstBranch}{\tsid_{init},\settrans, \tar} & \defeq &
            \begin{funcarray}
                \emptyset & \settrans = \emptyset \\
                \func{dec}{\tsid_{init},\settrans, \tar} & |\func{dec}{\tsid_{init},\settrans, \tar}| > 1 \\
                \func{firstBranch}(\tsid,\settrans \setminus \Set{\tsid_{init}}, \tar) & \func{dec}{\tsid_{init},\settrans, \tar} = \Set{\tsid} 
            \end{funcarray} \\
            \func{dec}{\tsid_{init},\settrans, \tar} & \defeq & \Set{\tsid \middle| (\tsid_{init}, \tsid) \in \tar \land \nexists \tsid' \ldotp (\tsid_{init}, \tsid'),(\tsid', \tsid) \in \tar}
        \end{rclarray}
    \]
\end{defn}

Intuitively, we take the first two transactions that are not connected, which definitely touch different locations by Lemma \ref{lem:seperate}, therefore we can simply pick a order and take the transitive closure.
We continue the process until it is a total order.

\begin{defn}[Total Order]
    \[
        \begin{rclarray}

        \end{rclarray}
    \]
\end{defn}

\begin{lem}[Session]
    \( \po \subseteq \vis \).
\end{lem}   
\begin{proof}
    Given the definition of \( \funcn{sessionOrder} \), assume a sequence of \( \po_n \), each of which represents the result of the \( n \)-steps \(\funcn{sessionOrder} \), so \( \po = \bigcup\limits_{n} \po_n \land \forall n, n' \ldotp n < n' \implies \po_n \subseteq \po_{n'} \).
    Therefore, if \( ( \tsid , \tsid' ) \in \po \), there must exist a \( n \) that \( ( \tsid , \tsid' ) \notin \po_{n-1} \) but \( ( \tsid , \tsid' ) \in \po_{n} \).
    This means there exists \( lc \) for same thread \( \thid \), such that \( \tsid \in lc(\thid) \).
    Since the \( lc \) is a partial function that records the last committed transactions of each thread.
    Note that if there is a new thread, it records the last committed transactions of its parent thread, while if it is a join point, it records both the parent and child last committed transactions.
    Then if the new transaction \( \tsid' \) commits, it must pick a starting time greater than any transactions included in \( lc(\thid) \).
    Assuming the time-stamp heap \( \tshp \) after the new transaction \( \tsid' \) committing and by the Lemma \ref{lem:happen-in-same-time}, we have \( \forall \loc, \loc', \ts, \ts', \op \in \Set{\wop,\eop}, \op' \in \Set{\rop,\sop} \ldotp \tshp(\loc)(\ts) = (\dontcare, \op, \tsid) \land \tshp(\loc')(\ts') = (\dontcare, \op', \tsid') \implies \ts < \ts' \), which implies \( (\tsid, \tsid') \in \po \).
\end{proof}

\begin{lem}[prefix]
    \label{lem:prefix}
    \( \tar; \vis \subseteq \vis \).
\end{lem}
\begin{proof}
    For all \( \tsid, \tsid', \tsid'' \), if \( (\tsid, \tsid') \in \tar \) and \( (\tsid', \tsid'') \in \vis \), by the definitions of \( \po \) and \( \vis \), the commit time of \( \tsid' \) is greater than the one of \( \tsid \) but smaller than the start time of \( \tsid'' \).
    Thus there must exist \( \loc, \loc'', \ts, \ts' , \ts'', \op \in \Set{\wop, \eop}  \) and \( \op'' \in \Set{\rop, \sop } \) such that  \( \tshp(\loc)(\ts) = (\dontcare, \op, \tsid) \), \( \tshp(\loc'')(\ts'') = (\dontcare, \op'', \tsid'') \) and \( \ts < \ts'' \), thus \( ( \tsid, \tsid'' ) \in \vis \).
\end{proof}

\begin{lem}[nocoflict]
    \label{lem:nocoflict}
    Two transactions cannot concurrently write to the same location, this means that one must observe another one.
    This is \( \forall \loc, \tsid, \tsid' \ldotp \tshp(\loc)(\dontcare) = (\dontcare, \wop, \tsid) \land  \tshp(\loc)(\dontcare) = (\dontcare, \wop, \tsid' ) \implies ((\tsid, \tsid') \in \vis \lor (\tsid', \tsid) \in \vis ))\).
\end{lem}
\begin{proof}
    Prove by contradiction.
    Assume \( (\tsid, \tsid') \notin \vis \land (\tsid', \tsid) \notin \vis \), this intuitively means one transaction is overlapped with another.
    Let \( \ts_{s}, \ts_{e}, \ts'_{s} \) and \( \ts'_{e} \) be the start time and end time of transaction \( \tsid \) and \( \tsid' \) respectively.
    Because of the symmetric,  we can assume that the start time of \( \tsid \) is in between \( \tsid' \), witch means \( \ts'_{s} < \ts_{s} < \ts'_{e} \).
    Now we consider \( \ts_{e} \).
    First note that \( \ts_{e} > \ts_{s} \) by Lemma \ref{lem:start-before-end}, therefore we need to consider two cases \( \ts'_{s} < \ts_{s} < \ts_{e} < \ts'_{e} \) and  \( \ts'_{s} < \ts_{s} < \ts'_{e} < \ts_{e}  \).
    Since both transaction write the same location \( \loc \), those two cases violate the \( \pred{consist} \) requirement in the semantics, so one of the transactions must pick another start and end time.
\end{proof}

\begin{lem}[ext]
    \label{lem:ext}
    A transaction should read the last values it can observe.
    This means that for all transaction \( \tsid \) and heap location \( \loc \), if the transaction read a value \( \val \) from the location, i.e.\ \( \exists \ts \ldotp \tshp(\loc)(\ts) = (\val, \rop, \tsid) \), the last transaction \( \tsid' \) who writes to the same location and can be observe by \( \tsid \), i.e.\ \( (\tsid, \tsid') \in \vis\), should have written the same value, meaning \( \exists \val', \ts' \ldotp \tshp(\loc)(\ts') = (\val', \wop, \tsid') \implies \val' = \val\)
\end{lem}
\begin{proof}
    Given the definition of \( \vis \), we have \( \ts' < \ts \).
    Because transaction \( \tsid' \) is the last one who write to the location, this means that \( \forall \tsid'', \ts'', \op'' \ldotp \tshp(\loc)(\ts'') = (\dontcare, \op'', \tsid'') \implies \op'' \neq \wop \).
    Thus by the \( \funcn{startstate} \) in the semantics, we have \( \val' = \val \).
\end{proof}


\begin{lem}[totalorder]
    The arbitration relations \( \tar \) can be extended to a total order \( \ar \) that does not violate Lemma \ref{lem:prefix}, Lemma \ref{lem:ext} and Lemma \ref{lem:acyclic_relations}.
\end{lem}
\begin{proof}
    We construct \( \ar \) from \( \tar \).
    Assume there is an initialisation transaction \( \tsid_{init} \) that happens before all other transactions, which means \( \forall \tsid \in \settrans \ldotp (\tsid_{init} , \tsid ) \in \tar\).
    Now we extend \( \tar \) until it is a total order.
    Let \( \tar_{0} = \tar \), and clearly \( \tar_{0} \) satisfies those Lemmas.

    Now assume that we have \( \tar_{n} \) for some \( n \) that satisfies Lemma \ref{lem:prefix}, Lemma \ref{lem:ext} and Lemma \ref{lem:acyclic_relations}.
    We pick first two transactions \( \tsid_{1} \) and \( \tsid_{2} \) that satisfies the following.
    First, if a transaction can reach \( \tsid_{1} \), it also can reach \( \tsid_{2} \), and vice versa, \( \forall \tsid \in \settrans \uplus \Set{\tsid_{init}} \ldotp (\tsid, \tsid_{1}) \in \tar_{n} \iff (\tsid, \tsid_{2}) \in \tar_{n} \).
    Second, let \( \mathcal{S} \) be the set of such transactions, we requires it is a strict total order with respect to \( \tar_{n} \), i.e.\ \( \forall \tsid, \tsid' \in \mathcal{S} \ldotp (\tsid,\tsid') \in \tar_{n} \lor (\tsid',\tsid) \in \tar_{n}  \).
    Intuitively, \( \tsid_{1} \) and \( \tsid_{2} \) is a branching point since \( \tsid_{init} \) with respect to \( \tar_{n} \).

    Immediately, there are two important properties of the transactions.
    Since that each step we add a new relations, so \( \vis \subseteq \tar \subseteq \tar_{0} \subseteq \dots \subseteq \tar_{n} \).
    Therefore, given \( ( \tsid_{1}, \tsid_{2} ) \notin \tar \land ( \tsid_{2}, \tsid_{1} ) \notin \tar \) and Lemma \ref{lem:atoic-rw}, these two transactions write locations in exactly the same time and given \( ( \tsid_{1}, \tsid_{2} ) \notin \vis \land ( \tsid_{2}, \tsid_{1} ) \notin \vis \) and the contrapositive of Lemma \ref{lem:nocoflict}, the transactions must write different locations.
    Now we claim that we can extend \( \tar_{n} \) by arbitrarily adding a relation between the two transactions and then taking the transitive closure, for instance \( \tar_{n+1} = ( \tar_{n} \uplus \Set{(\tsid_{1}, \tsid_{2})} )^{+}  \), and this new \( \tar_{n+1} \) still satisfies Lemma \ref{lem:prefix}, Lemma \ref{lem:ext} and Lemma \ref{lem:acyclic_relations}.

    Lemma \ref{lem:prefix}  holds, because \( \tsid_{1} \) and \( \tsid_{2} \) commit at the same time, so \( \forall \tsid \ldotp (\tsid_{1}, \tsid) \in \vis \iff  (\tsid_{2}, \tsid) \in \vis \).
    Then, by the assumption \( \tar_{n} ; \vis \subseteq \vis \), we have \( \tar_{n+1} ; \vis \subseteq \vis \).

    Lemma \ref{lem:ext} holds because \( \tsid_{1} \) and \( \tsid_{2} \) write different locations.
    Therefore, even though there is a new relation \( (\tsid_{1}, \tsid_{2}) \), the transaction \( \tsid_{2} \) still reads the newest values it can observe.
    Similarly for those transactions who depends on the values written by \( \tsid_{1} \), they still read the newest values they can observe.
                                                   
    Note that \( \vis \) remains the same some we only need to check \( \tar_{n+1} \).
    Assume that the new relation intrudes a circle, this circle must contain \( \tsid_{1} \) and \( \tsid_{2} \), for instance \( \tsid, \dots \tsid_{1}, \tsid_{2}, \dots \tsid' \).
    Given how we pick \( \tsid_{1} \) and \( \tsid_{2} \), all the transactions before \( \tsid_{1} \) in the circle also can reach \( \tsid_{2} \).
    This means \( \tsid, \dots \tsid_{1}, \dots \tsid' \) is also a circle, which contradict with assumption that \( \tar_{n} \) has no circle.
\end{proof}

