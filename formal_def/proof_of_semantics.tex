\section{Semantics\label{sec:proof_semantics}}
\subsection{Soundness of the time-stamp semantics}
\begin{lem}[No overwrite]
    \label{lem:no-over-write}
    For a given address and time, if there is a value, threads cannot overwrite the values.
    \[ 
        \for{ \stk, \stk', \tshp, \tshp', \ts, \ts', \iprog, {\iprog}' ,\lb,\addr, \ts } 
        ( \stk, \tshp, \ts ), \iprog \toT{\lb} ( \stk', \tshp', \ts' ), {\iprog}'
        \implies \tshp(\addr)(\ts)\undef \lor \tshp(\addr)(\ts) = \tshp'(\addr)(\ts)
    \]
\end{lem}
\begin{proof}
    Prove by structural induction on the semantics.
    For base cases \rl{PChoiseLeft}, \rl{PChoiseRight}, \rl{PLoop}, \rl{PSeqSkip}, \rl{PPar} and \rl{Pwait}, they are trivial because those rules do not change time-stamp heap, i.e.\ \( \tshp = \tshp' \).
    For base case \rl{Commit}, the new state \( \tshp' = \commit{\tshp}{\fph_{s}}{\fph_{e}}{\tsid}{\ts_{s}}{\ts_{e}} \) for some \( \fph_{s},\fph_{e}, \tsid, \ts_{s},\ts_{e} \).
    For any addresses updated by the new transaction \( \tsid \), It must pick times \( \ts_{s} \) and \( \ts_{e} \) when the values of those addresses are undefined, because of the constrain \( \cancommitName \), especially the sub-predicate \( \wfhistName \).
    For the inductive case \rl{PSeq}, prove directly by the inductive hypothesis.
\end{proof}

\begin{lem}[Start before end]
    \label{lem:start-before-end}
    \label{lem:read-before-write}
    All the reads/starts operations of a transaction happen before all the writes/ends. 
    Formally,
    \[
        \for{ \stk, \stk', \tshp, \tshp', \ts, \ts', \iprog, {\iprog}' ,\lb } 
        \pred{rw}{\tshp} 
        \land ( \stk, \tshp, \ts ), \iprog \toT{\lb} ( \stk', \tshp', \ts' ), {\iprog}' 
        \implies \pred{rw}{\tshp'}
    \]
    where,
    \[
        \begin{rclarray}
            \pred{rw}{\tshp} & \defeq & 
            \for{ \addr, \addr', \ts, \ts',\etag \in \Set{\etS, \etR}, \etag' \in \Set{\etE,\etW}, \tsid } 
            \tshp(\addr)(\ts) = (\stub, \etag, \tsid) 
            \land \tshp(\addr')(\ts') = (\stub, \etag', \tsid)
            \implies \ts < \ts' 
        \end{rclarray}
    \]
\end{lem}
\begin{proof}
    Prove by structural induction on the semantics.
    For base cases \rl{PChoiseLeft}, \rl{PChoiseRight}, \rl{PLoop}, \rl{PSeqSkip}, \rl{PPar} and \rl{PWait}, they are trivial because those rules do not change time-stamp heap, i.e.\ \( \tshp = \tshp' \).
    For base case \rl{Commit}, the new state \( \tshp' = \commit{\tshp}{\fph_{s}}{\fph_{e}}{\tsid}{\ts_{s}}{\ts_{e}} \) for some \( \fph_{s},\fph_{e}, \tsid, \ts_{s},\ts_{e} \). 
    First by Lemma \ref{lem:no-over-write}, for those transactions in \( \tshp \) it remains the same as in \( \tshp' \).
    Then, the \(\commitName\) function associates \( \etR \) or \( \etS \) to time \( \ts_{s} \), and \( \etW \) or \( \etE \) to \( \ts_{e} \), and \( \ts_{s} < \ts_{e} \), so \( \pred{rw}{\tshp'}\) holds.
    For the inductive case \rl{PSeq}, prove directly by the inductive hypothesis.
\end{proof}

\begin{lem}[Pair of start and end]
    \label{lem:start-end-pair}
    Reads/starts operations are writes/ends operations appear as pairs.
    \[
        \for{ \stk, \stk', \tshp, \tshp', \ts, \ts', \iprog, {\iprog}' ,\lb }
        \pred{pair}{\tshp} 
        \land ( \stk, \tshp, \ts ), \iprog \toT{\lb} ( \stk', \tshp', \ts' ), {\iprog}' 
        \implies \pred{pair}{\tshp'}
    \]
    where,
    \[
        \begin{rclarray}
            \pred{pair}{ \tshp } & \defeq & 
            \for{ \addr, \addr', \ts, \ts',\etag \in \Set{\etS, \etR}, \etag' \in \Set{\etE,\etW}, \tsid } 
            (\tshp(\addr)(\ts) = (\stub, \etag, \tsid) \iff \tshp(\addr')(\ts') = (\stub, \etag', \tsid)  )
        \end{rclarray}
    \]
\end{lem}
\begin{proof}
    Prove by structural induction on the semantics.
    For base cases \rl{PChoiseLeft}, \rl{PChoiseRight}, \rl{PLoop}, \rl{PSeqSkip}, \rl{PPar} and \rl{PWait}, they are trivial because those rules do not change time-stamp heap, i.e.\ \( \tshp = \tshp' \).
    For base case \rl{Commit}, the new state \( \tshp' = \commit{\tshp}{\fph_{s}}{\fph_{e}}{\tsid}{\ts_{s}}{\ts_{e}} \) for some \( \fph_{s},\fph_{e}, \tsid, \ts_{s},\ts_{e} \). 
    First by Lemma \ref{lem:no-over-write}, for those transactions in \( \tshp \) it remains the same as in \( \tshp' \).
    Then the \(\commitName\) function always extends addresses with pairs of operations, so \( \pred{rw}{\tshp'}\) holds.
    For the inductive case \rl{PSeq}, prove directly by the inductive hypothesis.
\end{proof}


\begin{lem}[Start/end at the same time]
    \label{lem:atoic-rw}
    \label{lem:happen-in-same-time}
    All the reads/starts operations among all addresses of a transaction happen in the same time, so do all the writes/ends operations. 
    \[
        \for{ \stk, \stk', \tshp, \tshp', \ts, \ts', \iprog, {\iprog}' ,\lb } 
        \pred{atom}{\tshp} 
        \land ( \stk, \tshp, \ts ), \iprog \toT{\lb} ( \stk', \tshp', \ts' ), {\iprog}' 
        \implies \pred{atom}{\tshp'}
    \]
    where,
    \[
        \begin{rclarray}
        \pred{atom}{\tshp} & \defeq & 
        \for{ \addr, \addr', \ts, \ts', \tsid, \etag, \etag' }
        \tshp(\addr)(\ts) (\stub, \etag, \tsid) 
        \land \tshp(\addr')(\ts') = (\stub, \etag', \tsid) \\
        & & \land (\etag, \etag' \in \Set{\etS, \etR} \lor \etag, \etag' \in \Set{\etE, \etW} ) 
        \implies \ts = \ts'
        \end{rclarray}
    \]
\end{lem}
\begin{proof}
    Prove by structural induction on the semantics.
    For base cases \rl{PChoiseLeft}, \rl{PChoiseRight}, \rl{PLoop}, \rl{PSeqSkip}, \rl{PPar} and \rl{Pwait}, they are trivial because those rules do not change time-stamp heap, i.e.\ \( \tshp = \tshp' \).
    For base case \rl{Commit}, the new state \( \tshp' = \commit{\tshp}{\fph_{s}}{\fph_{e}}{\tsid}{\ts_{s}}{\ts_{e}} \) for some \( \fph_{s},\fph_{e}, \tsid, \ts_{s},\ts_{e} \). 
    First by Lemma \ref{lem:no-over-write}, for those transactions in \( \tshp \) it remains the same as in \( \tshp' \).
    Then the \( \commitName \) function associates all reads/starts operations, \( \etR \) and \(\etS \), of all addresses to the start time \( \ts_{s} \), and writes/ends operations to the end time \( \ts_{e} \), so \( \pred{atom}{\tshp'}\) holds.
    For the inductive case \rl{PSeq}, prove directly by the inductive hypothesis.
\end{proof}

\begin{defn}[Well-form time-stamp heaps]
\label{def:wf-timestamp-heap}
    The well-formedness of time-stamp heap is defined as those satisfying Lemma \ref{lem:start-before-end}, Lemma \ref{lem:start-end-pair} and Lemma \ref{lem:atoic-rw}.
    \[
        \begin{rclarray}
            \wfH{\tshp} & \defeq & \pred{rw}{\tshp} \land \pred{pair}{\tshp} \land \pred{atom}{\tshp} \\
        \end{rclarray}
    \]
\end{defn}

\begin{defn}[Extended Labels]
\label{def:ext-label}
Given the set of transaction labels \( \Translabel \) (\defin \ref{def:label}) and thread identifiers \( \ThreadID \) (\defin \ref{def:thread_semantics}), the set of extended labels \( \ExtTranslabel \defeq ( \Nat \times \TransID \times \Translabel ) \cup \Set{\lbID} \) is defined as follows:
\[
	\ExtTranslabel ::= \lbID \mid (\thid,\lbC{\tsid}) \mid (\thid,\lbF{\thid',\prog}) \mid (\thid,\lbJ{\thid',\ts})
\]
\end{defn}

For brevity, we will write \( \lbC{\thid, \tsid} \) instead of \( ( \thid,\lbC{\tsid}) \), similarly for \( \lbF{\thid, \thid',\prog}\) and \( \lbJ{\thid, \thid',\ts} \).
Also we will use the same meta-variable \( \lb \) to range over extended transaction labels.

\begin{defn}[Traces]
\label{def:traces}
    Assume lifting the operational semantics in \fig \ref{fig:thread_semantics} and \fig \ref{fig:thread_pool_semantics} to cope with extended transaction label (\defin \ref{def:ext-label}), then given an initial time-stamp heap \( \tshp  \TSHeaps \) (\defin \ref{def:timestamp_heaps}) and a thread pool \( \thpl \) (\defin \ref{def:thread_pools}), a trace \( \trc \in \Trace \defeq \powerset{ \ExtTranslabel } \times (\ExtTranslabel \times \ExtTranslabel) \) is a tuple \( (\setlabels,<) \) that satisfies predicate \( \pred{trace}{\tshp,\thpl,\setlabels,<,\nat} \), for some number \( \nat \).
\[
    \begin{rclarray}
        \func{traces}{\tshp,\thpl,0} & \defeq & \Set{(\emptyset, \emptyset,\tshp,\thpl)} \\
        \func{traces}{\tshp,\thpl,\nat} & \defeq & 
        \Setcon{%
            (\setlabels,<,\tshp',\thpl')
        }{%
            (\tshp'', \thpl'') \toG{\lbID} (\tshp', \thpl' ) 
            \land (\setlabels,<,\tshp'',\thpl'') \in \func{trace}{\tshp,\thpl,\setlabels,<,\nat-1}
        } \\
		& & \uplus \Setcon{
				(\setlabels \uplus \Set{\lb}
                , < \uplus \myset{(\lb',\lb)}{ \lb' \in \setlabels}
                , \tshp',\thpl')
			}{ 
	            (\tshp'', \thpl'') \toG{\lb} (\tshp', \thpl' ) 
                \land \lb \neq \lbID \land {} \\
                (\setlabels,<,\tshp'',\thpl'') \in \func{trace}{\tshp,\thpl,\setlabels,<,\nat-1}
			}  \\
    \end{rclarray}
\]
\end{defn}
\sx{
    Not robust enough against the same events happening twice.
    Might fix later or simply assume all labels are unique by tagged a unique identifier. 
    Could add local time also in the label which should be usefully to give more formal prove of program order is inside visibility.}

\begin{defn}[Program Order]
\label{def:po}
Given a trace \( \trc \in \Trace \) (\defin \ref{def:traces}), the \( \funcn{programOrder} : \powerset{\ExtTranslabel} \times (\ExtTranslabel \times \ExtTranslabel) \to \powerset{\Transactions} \times (\Transactions \times \Transactions) \) function is defined as follows:
\[ 
    \begin{rclarray}
        \func{programOrder}{\setlabels, <} & \defeq & ( \settrans, \po ) \\
    \end{rclarray}
\]
where,
\[ 
    \begin{rclarray}
        \settrans & \equiv & \Setcon{\tsid}{\lbC{\thid,\tsid} \in \setlabels } \\
        \po & \equiv & \myset{(\tsid, \tsid')}{\lbC{\thid,\tsid} < \lbC{\thid,\tsid'} } 
        \uplus \myset{(\tsid, \tsid')}{\lbC{\thid,\tsid} < \lbF{\thid,\thid', \stub} < \lbC{\thid',\tsid'} } \\
            & & \uplus \myset{(\tsid, \tsid')}{\lbC{\thid,\tsid} < \lbJ{\thid',\thid, \stub} < \lbC{\thid',\tsid'} }
    \end{rclarray}
\]
\end{defn}

\begin{defn}[Visibility and partial arbitration]
    \label{def:vis-ptlar}
    The \( \funcn{graph}: \TSHeaps \to ( (\Transactions \times \Transactions) \times (\Transactions \times \Transactions) )  \) function convert a time-stamp heap into corresponding \emph{visibility relation} and \emph{partial arbitration relation}, written \( \vis \) and \( \ptlar \) respectively.
    \[
        \begin{rclarray}
            \func{graph}{\tshp} & \defeq & (\vis,\ptlar) \\
        \end{rclarray}
    \]
    where,
    \[
        \begin{rclarray}
            \vis & \equiv & 
            \Setcon{%
                (\tsid,\tsid')
            }{ %
                \exsts{ \addr, \addr', \ts, \ts', \etag \in \Set{\etW,\etE}, \etag' \in \Set{\etR,\etS} } 
                \ts < \ts' \land {} \\
                \tshp(\addr)(\ts) = (\stub, \etag,\tsid)
                \land \tshp(\addr')(\ts') = (\stub, \etag',\tsid') 
			} \\
            \ptlar & \equiv & 
            \Setcon{%
            (\tsid,\tsid')
            }{%
                \exsts{ \addr, \addr', \ts, \ts', \etag, \etag' \in \Set{\etW,\etE} } 
                \ts < \ts' \land {} \\
                \tshp(\addr)(\ts) = (\stub, \etag,\tsid) 
                \land \tshp(\addr')(\ts') = (\stub, \etag',\tsid') 
			}
        \end{rclarray}
    \]
\end{defn}

Note that all transactions in the visibility or partial arbitration relations, for instance \( (\tsid, \tsid') \in \vis \), they must be in the set of transactions given by program order, meaning \( \tsid, \tsid' \in \settrans \).
For brevity, we might only mention and quantify few elements of this tuple but one should think they are quantified as an entire tuple.
For readability, we use \( (\tsid, \tsid') \in \vis \) or \( \tsid \toVIS \tsid' \) interchangeably, and similar for \( \ar \).

\begin{defn}[Partial graph]
\label{def:partial-graph}
Given the well-formedness of time-stamp heaps (\defin \ref{def:wf-timestamp-heap}), program order (\defin \ref{def:po}), and visibility and arbitration relation (\defin \ref{def:vis-ptlar}), the set of \emph{partial graph} is defined as follows, where the ``partial'' means the arbitration relation is partial.
\[
    \begin{rclarray}
    \PGraphs & \defeq & 
    \Setcon{%
        (\settrans, \po, \vis, \ptlar, \tshp)
    }{ 
        \exsts{\tshp', \thpl'} \wfH{\tshp'}
        \land (\setlabels,<,\tshp,\thpl) \in \bigcup\limits_{\nat \in \Nat}\func{traces}{\tshp',\thpl',\nat} \land {} \\
        (\settrans,\po) = \func{programOrder}{\setlabels,<} 
        \land (\vis,\ptlar) = \func{graph}{\tshp} 
    } 
    \end{rclarray}
\]
\end{defn}

\begin{lem}[Separation]
    \label{lem:seperate}
    If two transactions that are not associated by partial arbitration relation \( \ptlar \), they access different addresses but commit at the same time.
    \[
        \begin{array}{@{}l@{}}
            \for{ \tshp, \ptlar, \tsid, \tsid' } (\tsid, \tsid'), (\tsid',\tsid) \notin \ptlar \\
            \qquad \implies \for{ \addr, \addr', \ts, \ts', \etag, \etag \in \Set{\etW, \etE } }
            \tshp(\addr)(\ts) = ( \stub, \etag, \tsid) 
            \land \tshp(\addr')(\ts') = ( \stub, \etag', \tsid') 
            \implies \ts = \ts'
            \land \addr \neq \addr'
        \end{array}
    \]
\end{lem}
\begin{proof}
    Given \( \ptlar \) in \defin \ref{def:partial-graph}, \( \ts = \ts' \) holds, and then \( \addr \neq \addr' \) is derived from Lemma \ref{lem:atoic-rw}.
\end{proof}


\begin{lem}[Semi-acyclic]
    \label{lem:semi-acyclic}
    Both \( \vis \) and \( \ptlar \) are acyclic.
\end{lem}
\begin{proof}
    Proof by contradiction.
    Assume that there is a circle in \( \vis \), which means that \( \bigwedge\limits_{0 \leq i \leq n} \tsid_{i} \toVIS \tsid_{i+1} \land \tsid_{0} = \tsid_{n} \) for some \( \tsid_{0} \) to \( \tsid_{n}\).
    By Lemma \ref{lem:atoic-rw}, each transaction has a start time and a end time, thus let \( \ts^{s}_{i} \) and \( \ts^{e}_{i} \) denote the start time and end time of the transaction \( \tsid_{i} \).
    By Lemma \ref{lem:read-before-write}, we have \( \ts^{s}_{i} < \ts^{e}_{i} \), and  then by \( \vis \) which is defined in \defin \ref{def:vis-ptlar}, we have \( \ts^{e}_{i} < \ts^{s}_{i+1} \).
    Therefore, \( \ts^{s}_{0} < \ts^{e}_{0} < \ts^{s}_{1} < \dots <  \ts^{s}_{n} \), and we have contradiction that \( \ts^{s}_{0} < \ts^{s}_{n} \) with respect to Lemma \ref{lem:atoic-rw}.

    Similarly for \( \ptlar \), we have contradiction that \( \ts^{e}_{0} < \ts^{e}_{1} < \dots  < \ts^{e}_{n} \).
\end{proof}

We can extend partial arbitration relation \( \ptlar \) to a total order, called total arbitration relation or shortly arbitration \( \ar \) by taking the first two transactions that are not connected and then picking a order and take the transitive closure.
To simplify, assume there is a unique initial transactions denoted by \( \tsid_{init} \), where \( (\tsid_{init}, \tsid) \in \ptlar \) for all \( \tsid \).

\begin{defn}[Total graph]
\label{def:tototal}
\label{def:total-graph}
    First, the \( \funcn{toTotal} : \powerset{\Transactions} \times (\Transactions \times \Transactions) \parfun \powerset{\Transactions} \times (\Transactions \times \Transactions) \) function is defined as follows, which convert partial arbitration relation to total one.
    \[
        \begin{rclarray}
            \func{toTotal}{\settrans, \ptlar} & \defeq & 
                \begin{cases}
                    (\settrans, \ptlar) & \text{if} \ \func{firstBranch}{\settrans, \ptlar} = \emptyset\\ 
                    \func{toTotal}{\settrans, ( \ptlar \uplus \Set{(\tsid, \tsid')})^{+}} & \text{if} \ \tsid, \tsid' \in \func{firstBranch}{\settrans, \ptlar} \\    
                \end{cases}
            \\
        \end{rclarray}
    \]
    where, the \( \funcn{firstBranch} : \powerset{\Transactions} \times (\Transactions \times \Transactions) \parfun \powerset{\Transactions} \) function that returns a set that includes the first branched transactions (might be more than two).
    \[
        \begin{rclarray}
            \func{firstBranch}{\settrans, \ptlar} & \defeq &
            \begin{cases}
                \emptyset & \text{if} \ \settrans = \emptyset \\
                \func{firstBranch}{\settrans \setminus \Set{\tsid}} & \text{if} \ \func{dec}{\settrans, \ptlar} = \Set{\tsid} \\
                \func{dec}{\settrans, \ptlar} & \text{if} \ |\func{dec}{\settrans, \ptlar}| > 1 ) \\
                \text{undefined} & \text{otherwise}
            \end{cases} \\
        \end{rclarray}
    \]
    and the \( \funcn{dec} \) function returns all the direct descendants of the first transaction.
    \[
        \begin{rclarray}
            \func{dec}{\settrans, \ptlar} & \defeq &
            \myset{%
                \tsid
            }{%
                \exsts{ \tsid_{init}  } 
                \pred{firstTrans}{\settrans, \ptlar, \tsid_{init}} \land {} \\
                \quad (\tsid_{init}, \tsid) \in \ptlar 
                \land \neg\exsts{ \tsid' } 
                (\tsid_{init}, \tsid'),(\tsid', \tsid) \in \ptlar} \\
                \pred{firstTrans}{\settrans, \ptlar, \tsid} & \defeq & \for{\tsid' \in \settrans } \tsid = \tsid' \lor (\tsid, \tsid') \in \ptlar \\
        \end{rclarray}
    \]
    Now given the set of partial graphs \( \PGraphs \) (\defin \ref{def:partial-graph}), the set of \emph{total graph} \( \TGraphs \) is defined as follows:
    \[
        \begin{rclarray}
            \Setcon{%
                (\settrans, \po, \vis, \ar, \tshp)
            }{
                ( \settrans, \ar ) = \func{toTotal}{\settrans, \ptlar} 
                \land (\settrans, \po, \vis, \ptlar, \tshp) \in \PGraphs
            } \\
        \end{rclarray}
    \]
\end{defn}

\begin{lem}[Visibility]
    \label{lem:visibility}
    Visibility relation is a subset of arbitration relation, i.e.\ \( \vis \subseteq \ar \).
\end{lem}
\begin{proof}
    For all transactions \( \tsid \) and \( \tsid' \), if \( ( \tsid, \tsid' ) \in \vis \), it means that transaction \( \tsid \) commits before \( \tsid' \) starts, so that by Lemma \ref{lem:start-before-end} \( \tsid \) must start before \( \tsid' \) starts.
    This means \( (\tsid, \tsid') \in \ptlar \) (\defin \ref{def:vis-ptlar}), therefore \( (\tsid, \tsid') \in \ar \).
\end{proof}

\begin{lem}[Monotonic time in a thread]
    \label{lem:mono-time-thread}
    The thread's local time monotonically increase.
    This is  
    \[ 
        \for{ \stk, \stk', \tshp, \tshp', \ts, \ts', \iprog, {\iprog}' ,\lb,\addr, \ts } ( \stk, \tshp, \ts ), \iprog \toT{\lb} ( \stk', \tshp', \ts' ), {\iprog}' \implies \ts < \ts'
    \]
\end{lem}
\begin{proof}
    Prove by structural induction on the semantics.
    For base cases \rl{PChoiseLeft}, \rl{PChoiseRight}, \rl{PLoop}, \rl{PSeqSkip} and \rl{PPar}, it is trivial since those rules do not change the time.
    For \rl{Commit}, the premiss enforces that \( \ts' > \ts \) and for \rl{PWait}, \( \ts' = \max\Set{\ts, \stub} \geq \ts\).
    For the inductive case \rl{PSeq}, prove directly by the inductive hypothesis.
\end{proof}

\begin{lem}[Session]
    \label{lem:session}
    \( \po \subseteq \vis \).
\end{lem}   
\begin{proof}
    Prove by case analysis of \( \po \) (\defin \ref{def:po}).
    For \( \tsid \) and \( \tsid' \) where \( \lbC{\thid,\tsid} < \lbC{\thid,\tsid'} \), it means that transaction \( \tsid \) is reduced by the semantics before \( \tsid' \).
    Then by Lemma \ref{lem:mono-time-thread}, the commit time of the first transaction \( \tsid \) is smaller than the start time of the second one \( \tsid' \), so that \( (\tsid, \tsid') \in \vis \).

    For \( \tsid \) and \( \tsid' \) where \( \lbC{\thid,\tsid} < \lbF{\thid,\thid', \stub} < \lbC{\thid',\tsid'} \).
    By Lemma \ref{lem:mono-time-thread}, it means the parent thread \( \thid \) commits transaction \( \tsid \) before the fork of the child thread \( \thid' \), and also the child thread commits transaction \( \tsid' \) after the fork point.
    In the \rl{PFork} rule, the parent thread starts at time \( \ts \) and ends at \( \ts' \), and the child thread initialises with the time \( \ts' \), where in fact \( \ts = \ts' \).
    Therefore, \( (\tsid, \tsid') \in \vis \).

    Similarly, for \( \tsid \) and \( \tsid' \) where \( \lbC{\thid,\tsid} < \lbJ{\thid',\thid, \stub} < \lbC{\thid',\tsid'} \), all the transactions by child thread \( \thid \) must commits before the join point and therefore before all the uncommitted transactions by the parent thread \( \thid' \).
    Therefore, \( (\tsid, \tsid') \in \vis \).
\end{proof}

\sx{The session lemma I feel slightly unhappy, because it seems not very formal.}

\begin{lem}[Semi-prefix]
    \label{lem:semi-prefix}
    \( \ptlar; \vis \subseteq \vis \).
\end{lem}
\begin{proof}
    For all \( \tsid, \tsid', \tsid'' \), if \( (\tsid, \tsid') \in \ptlar \) and \( (\tsid', \tsid'') \in \vis \), by the definitions of \( \po \) and \( \vis \) (\defin \ref{def:vis-ptlar}), transaction \( \tsid' \) commits after \( \tsid \) commits but before \( \tsid'' \) starts.
    There must exist \( \addr, \addr'', \ts, \ts'', \etag \in \Set{\etW, \etE}  \) and \( \etag'' \in \Set{\etR, \etS } \) such that  \( \tshp(\addr)(\ts) = (\stub, \etag, \tsid) \), \( \tshp(\addr'')(\ts'') = (\stub, \etag'', \tsid'') \) and \( \ts < \ts'' \), thus \( ( \tsid, \tsid'' ) \in \vis \).
\end{proof}
\sx{Rework a bit until this point}

\begin{lem}[Prefix]     
    \label{lem:prefix}
    \( \ar; \vis \subseteq \vis \).
\end{lem}
\begin{proof}
    Prove by case analysis of the total arbitration relation \( \ar \).
    For all \( \tsid, \tsid', \tsid'' \) that \( (\tsid, \tsid') \in \ar \) and \( (\tsid', \tsid'') \in \vis \), if \( (\tsid, \tsid') \in \ptlar \), it is proven by Lemma \ref{lem:semi-prefix}.
    If \( ( \tsid, \tsid' ) \notin \ptlar \), it means it is a new edge by the \funcn{toTotal} function from Definition \ref{def:tototal}.
    By the Lemma \ref{lem:seperate}, \( \tsid \) and \( \tsid' \) commit at the same time.
    By the definition of \( \vis \), the commit time of \( \tsid' \) is smaller than the start time of \( \tsid'' \).
    Therefore, the commit time of \( \tsid \) is also smaller than the start time of \( \tsid'' \), so that \( ( \tsid, \tsid'' ) \in \vis \).
\end{proof}

\begin{lem}[No conflict]
    \label{lem:nocoflict}
    Two transactions cannot concurrently write to the same address, this means that one must observe another one.
    This is \( \for{ \addr, \tsid, \tsid' } \tshp(\addr)(\stub) = (\stub, \etW, \tsid) \land  \tshp(\addr)(\stub) = (\stub, \etW, \tsid' ) \implies ((\tsid, \tsid') \in \vis \lor (\tsid', \tsid) \in \vis ))\).
\end{lem}
\begin{proof}
    Prove by contradiction.
    Assume \( (\tsid, \tsid') \notin \vis \land (\tsid', \tsid) \notin \vis \), this intuitively means one transaction is overlapped with another.
    Let \( \ts_{s}, \ts_{e}, \ts'_{s} \) and \( \ts'_{e} \) be the start time and end time of transaction \( \tsid \) and \( \tsid' \) respectively.
    Because of the symmetry,  we can assume that the start time of \( \tsid \) is in between \( \tsid' \), witch means \( \ts'_{s} < \ts_{s} < \ts'_{e} \).
    Now we consider \( \ts_{e} \).
    First note that \( \ts_{e} > \ts_{s} \) by Lemma \ref{lem:start-before-end}, therefore we need to consider two cases \( \ts'_{s} < \ts_{s} < \ts_{e} < \ts'_{e} \) and  \( \ts'_{s} < \ts_{s} < \ts'_{e} < \ts_{e}  \).
    Since both transaction write the same address \( \addr \), those two cases violate the \( \predn{consist} \) requirement in the semantics, so one of the transactions must pick another start and end time.
\end{proof}

\begin{lem}[External]
    \label{lem:ext}
    A transaction should read the last values it can observe.
    This means that for all transaction \( \tsid \) and heap address \( \addr \), if the transaction read a value \( \val \) from the address, i.e.\ \( \exsts{ \ts } \tshp(\addr)(\ts) = (\val, \etR, \tsid) \), the last transaction \( \tsid' \) who writes to the same address and can be observe by \( \tsid \), i.e.\ \( (\tsid, \tsid') \in \vis\), should have written the same value, meaning \( \exsts{ \val', \ts' } \tshp(\addr)(\ts') = (\val', \etW, \tsid') \implies \val' = \val\)
\end{lem}
\begin{proof}
    Given the definition of \( \vis \), we have \( \ts' < \ts \).
    Because transaction \( \tsid' \) is the last one who write to the address, this means that \( \for{ \tsid'', \ts'', \etag'' } \tshp(\addr)(\ts'') = (\stub, \etag'', \tsid'') \implies \etag'' \neq \etW \).
    Thus by the \( \funcn{startstate} \) in the semantics, we have \( \val' = \val \).
\end{proof}

\begin{lem}[Acyclic]
    \label{lem:acyclic}
    Both \( \vis \) and \( \ar \) are acyclic.
\end{lem}
\begin{proof}
    For \( \vis \), it is proven by Lemma \ref{lem:semi-acyclic}.

    To prove \( \ar \) is acyclic, we prove inductively \( \ptlar_{i} \) is acyclic, where \( \ptlar_{0} = \ptlar \), \( \ptlar_{n} = \ar \) and \( \ptlar_{i+1} = (\ptlar_{i} \uplus \Set{(\tsid, \tsid')})^{+} \) for some \( \tsid \) and \( \tsid' \), which follows the process of \funcn{toTotal} from Definition \ref{def:tototal}.
    For base case \( \ptlar_{0} \), it is proven by Lemma \ref{lem:semi-acyclic}.
    Now assume \( \ptlar_{i} \) is acyclic and \( \ptlar_{i+1} = (\ptlar_{i} \uplus \Set{(\tsid, \tsid')})^{+} \) for some \( \tsid \) and \( \tsid' \), we prove by contradiction that \( \ptlar_{i+1} \) is acyclic.
    Given the hypothesis, if there is circle in \( \ptlar_{i+1} \), such circle either contain the edge \( (\tsid, \tsid') \), or can be broken down to a circle containing the edge \( (\tsid, \tsid') \), because of the transitive closure.
    Note that by breaking down to a circle containing \( ( \tsid, \tsid' ) \), the rest edges inside the circle must be in \( \ptlar_{i} \).
    Let assume the circle is \( \tsid_{0}, \tsid_{1}, \dots, \tsid_{i}, \tsid, \tsid', \tsid_{i+1}, \dots, \tsid_{n} \) where \( \tsid_{0} = \tsid_{n} \).
    By the \( \funcn{toTotal} \) function from Definition \ref{def:tototal}, \( \tsid, \tsid' \in \func{firstBranch}{\settrans, \ptlar_{i}}\), which means that for all \( \tsid'' \), \( (\tsid'', \tsid) \in \ptlar_{i} \) if and only if \( ( \tsid'', \tsid') \in \ptlar_{i} \), therefore \( (\tsid'', \tsid) \in \ptlar_{i+1} \) if and only if \( ( \tsid'', \tsid') \in \ptlar_{i+1} \).
    This means that the sequence without \( \tsid \), i.e.\ \( \tsid_{0}, \tsid_{1}, \dots, \tsid_{i}, \tsid', \tsid_{i+1}, \dots, \tsid_{n} \), is still a sequence where two adjacent transactions are connected by \( \ptlar_{i+1} \), and this new sequence is a circle.
    Now all the edges in the new sequence/circle already exist in \( \ptlar_{i} \), which violates our hypothesis.
    Therefore by contradiction, \( \ptlar_{i+1} \) is acyclic.
    Given that, \( \ar \) is acyclic.
\end{proof}

\begin{lem}[Total order]
    \label{lem:totalorder}
    \( \ar \) is a total order.
\end{lem}
\begin{proof}
    By Lemma \ref{lem:acyclic}, \( \ar \) is acyclic, and by \defin \ref{def:tototal}, for all \( \tsid \) and \( \tsid' \), either \( (\tsid, \tsid') \in \ar \) or \( (\tsid', \tsid) \in \ar \).
    Therefore, it is a total order.
\end{proof}

\begin{defn}[Snapshot Isolation Graph]
    \(\sig \in \SIGraphs \)
\end{defn}

\begin{thm}[Soundness of the semantics]
    The thread pool operational semantics $\toG{}$ (\defin\ref{def:thread_pool_semantics}) is sound.
    This means
    \[
        \begin{array}{@{}l@{}}
            \exsts{ f } \for{ \tshp, \thpl, \tshp', \thpl' } (\tshp, \thpl) \toG{\lb} (\tshp', \thpl') \land \exsts{ \sig \in \SIGraphs } f(\tshp, \thpl) = \sig \implies \exsts{ \sig' \in \SIGraphs } f(\tshp', \thpl') = \sig'
        \end{array}
    \]
\end{thm}
\begin{proof}
    Given the \defin \ref{def:traces}, there is a unique corresponding trace \trace, and then by \defin \ref{def:po}, \ref{def:vis-ptlar} and \ref{def:tototal} there exists a \( \sig' \).
    Then, by Lemma \ref{lem:visibility}, \ref{lem:session}, \ref{lem:prefix}, \ref{lem:nocoflict}, \ref{lem:ext}, \ref{lem:totalorder}, the \( \sig' \in \SIGraphs \).
\end{proof}
\sx{Not really right but keep this way for now}

\subsection{Completeness}
\sx{Define a function from a graph to a set of possible \( \fph \) }

