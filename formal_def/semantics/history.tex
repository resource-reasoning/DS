\subsection{Program Semantics}

We model the state of database as a history heap, where each address has a list \emph{versions} from the initial one to the latest one.
Each version contains a value and a transaction identifier who writes it and a set of transactions who read it.

\begin{defn}[History Heaps]
\label{def:his_heap}
Assuming a set of \emph{transactions identifiers} \( \TxID \defeq \Set{\txid, \dots}\), a \emph{history heap}, \( \hh \in \HisHeaps \), is a partial function from addresses to lists of \emph{versions}.
Each version a tuple contains a value, a transaction (identifier) and a set of transactions (identifiers).
\[
\begin{rclarray}
    \Versions & \defeq &  \Val \times \TxID \times \powerset{\TxID} \\
    \HisHeaps & \defeq & \Addr \parfinfun \Versions^{*}
\end{rclarray}
\]
The composition of two history heaps is \( \hh \composeHH \hh' \defeq \hh \uplus \hh' \) and the unit element is \( \unitHH \defeq \emptyset \). 
\end{defn}
 
Let \( \hh(\addr)(i)\) denotes the \emph{i-th} version associated with address \( \addr \), and \( \hhV(\addr)(i) \), \( \hhW(\addr)(i) \) and \( \hhR(\addr)(i) \) denote the first (value), second (write) and third element (read) of the version.
We assume the version number starts from 1.

For weak consistency models, or weak isolation levels which are more common term used in database community, a session is not necessary to work on the up-to-date version of a database in exchange for better performance. 
Even in a single machine database, a session wants to make less synchronisation with the hard drivers and other running threads.
This means a session could operate on a out-of-date state.
We use \emph{views} to model sessions of a database.
A \emph{view} is a cut in a history heap that corresponds the version that a session work with.

\begin{defn}[Views]
\label{def:cuts}
\emph{A view of of a history heap}, short as \emph{view}, is a partial function from addresses to indexes,
\[
\begin{rclarray}
    \vi \in \Views & \defeq & \Addr \parfinfun \Nat
\end{rclarray}
\]                                                                     
The composition is \( \vi \composeVI \vi' \defeq \vi \uplus \vi'\) and the unit is \( \unitVI \defeq \emptyset\).
The order between two views if they have the same domain is the order of all the indexes, 
\[
\begin{rclarray}
    \cu \orderCU \cu' & \defiff & \dom(\cu) = \dom(\cu') \land \for{\addr} \cu(\addr) \leq \cu'(\addr) \\
\end{rclarray}
\]
Assuming a set of thread identifiers \( \setthid \subseteq \ThreadID \), \emph{a view environment} is a function from thread identifiers to views, this is, \( \vienv \in \ViEnv \defeq \ThreadID \parfun \Views \).
\end{defn}

\begin{defn}[Consistency Models]
\label{def:consistency-models}
A \emph{Consistency model} \( \como \) is a \emph{reflexive and transitive relation} over pairs of history heaps and cut environments, written \( ((\hh,\thcu),(\hh',\thcu')) \in \como  \), that the transition from the state \( (\hh,\thcu)\) to the state \( (\hh',\thcu') \) satisfies certain constraints.
Each tuple in the set should satisfy a well-formed condition that the cut environment should contain no more address than the history heap,
\[
    \bigcup\limits_{\thid \in \dom(\thcu)} \dom(\thcu(\thid)) \subseteq \dom(\hh)
\]
The constraints should be local to the owned history heaps, so that the combination of two disjointed parts also satisfies the constraints,
\[
    \begin{array}{@{}l}
    \for{\hh,\hh',\hh'',\hh''', \thcu, \thcu', \thcu'', \thcu'''} \\
        \quad ((\hh, \thcu),(\hh',\thcu')) \in \como 
        \land ((\hh'', \thcu''),(\hh''',\thcu''')) \in\como 
        \land ( \hh \composeHH \hh'' )\isdef
        \land ( \hh' \composeHH \hh''' )\isdef \\
        \qquad \implies  ((\hh \composeHH \hh'', \thcu \uplus \thcu''),(\hh' \composeHH \hh''',\thcu' \uplus \thcu''')) \in \como
    \end{array}
\]
\sx{The following says the consistency model transfer from a valid state to another valid state. }
A consistency model also requires to transfer from a \emph{valid} state to another \emph{valid} state, and the validity is independent from the transition.
\[
    \for{\como} \exsts{\funcn{valid}} (\hh, \vienv) \in \como \implies \func{valid}{\hh, \vienv}
\]
\end{defn}

\sx{Need Andrea for more clarify about defining consistency model}

There are two ways to specify consistency models, one by converting the history heaps to dependant graphs and checking if the cycles satisfy certain property, while another by checking if the view environment satisfy certain property.
We introduce \( \funcn{graph} : \HisHeaps \to \sort{DGraph} \) function for converting history heaps to dependant graphs.
\[
\begin{rclarray}
    \DGraph & \defeq & \Setcon{(\txidset, \ww, \wrr, \rw)}{ \txidset \subseteq \TxID \land \ww, \wrr, \rw \subseteq (\txidset \times \txidset)} \\
    \func{graph}{\hh} & \defeq & \left(
    \begin{array}{@{}l}
        \Setcon{\txid}{\exsts{\addr, i} \txid = \hhW(\addr)(i) \lor \txid \in \hhR(\addr)(i) }, \\
        \Setcon{(\txid, \txid')}{\exsts{\addr, i, i'} \txid = \hhW(\addr)(i) \lor \txid' = \hhW(\addr)(i') \land i < i' }, \\
        \Setcon{(\txid, \txid')}{\exsts{\addr, i} \txid = \hhW(\addr)(i) \lor \txid' \in \hhR(\addr)(i) }, \\
        \Setcon{(\txid, \txid')}{\exsts{\addr, i, i'} \txid \in \hhR(\addr)(i) \lor \txid' = \hhW(\addr)(i') \land i < i' }, \\
    \end{array}
    \right)
\end{rclarray}
\]

\begin{example}[Serialisibility]
\end{example}

\begin{example}[Snapshot]
Any cycle in the corresponding dependant graph of the history heap after the transition must have adjacent anti-dependent edges (\( \rw \) edges).
\[
    \begin{rclarray}
    \SI & \defeq & \Setcon{((\hh, \thcu),(\hh', \thcu'))}{\exsts{\ww, \rw, \wrr} (\stub, \ww, \wrr, \rw)  = \func{graph}{\hh'} \land (\wrr \cup \ww) ; \rw? \text{ is acyclic}}
    \end{rclarray}
\]
\end{example}

{ \color{gray}
\begin{defn}[Thread transition labels]
\label{def:label}
Given the set of thread identifiers \(\thid \in \ThreadID\), the set of \emph{thread transition labels}, $\lb \in \Translabel$, is defined by the following grammar, where $\prog$ denotes a program (\defref{def:language}), the $\txid$ demotes a transaction identifier and $\thstk$ denotes a thread stack (\defref{def:stacks}),
\[
    \begin{rclarray}
	\iota \in \Translabel & ::= & \lbID \mid \lbC{\txid} \mid \lbF{\thid,\prog} \mid \lbJ{\thid,\thstk}
    \end{rclarray}
\]
\end{defn}
}

We introduce \( \funcn{clps} \) function that collapses a history heap with a view to a normal heap, which is the local state with respect to the view.
{ \color{gray}
A spacial version of this function only takes a history heap, and it returns a normal heap that is the latest state of the database.
}

\begin{defn}[Collapse of history heaps]
A view \( \vi \) can collapse a history heap \( \hh \) to a (normal) heap \( h \) through the function \(\funcn{clps} : \HisHeaps \times \Cuts \parfun \Heaps\),
\[
\begin{rclarray}
    \clpsHH{\hh, \cu} & \defeq & 
    \begin{cases}
        \lambda \addr \ldotp \hhV(\addr)(\cu(\addr)) & \text{if } \dom(\hh) = \dom(\cu) \land \for{\addr'} \cu(\addr') \leq \left|\hh(\addr')\right| \\
        \text{undefined} & \text{otherwise}
    \end{cases}
\end{rclarray}
\]
{ \color{gray}
The function is overloaded with one parameter version that collapses history heaps by picking the last values,
\[
\begin{rclarray}
    \clpsHH{\hh} & \defeq & \lambda \addr \ldotp \hhV(\addr)(\left|\hh(\addr)\right|) 
\end{rclarray}
\]
}
\end{defn}

\begin{defn}[Thread semantics]
\label{def:thread_semantics}
{ \color{gray}
Given the thread identifiers \(\thid \in \ThreadID\), the set of \emph{intermediate programs}, \(\iprog \in \IntermediatePrograms\), is defined by the following grammar,
\[
    \iprog ::= \prog \mid \iprog \pseq \pwait{\thid}
\]
}
Given the set of consistency model \( \ConsisModels \) (\defref{def:consistency-models}), stacks \( \Stacks \) (\defref{def:stacks}), history heaps \( \HisHeaps \) (\defref{def:his_heap}) and views \( \Views \) (\defref{def:cuts}), the \emph{per-thread operational semantics} of programs,
\[
\begin{rclarray}
	\toT{} & : &
    \begin{array}[t]{@{}l@{}}
    \Como 
    \times {} \\
	\quad \left( ( \Stacks \times \HisHeaps \times \Views ) \times \Commands \right) 
	\times 
	\left( ( \Stacks \times \HisHeaps \times \Views ) \times \Commands \right) 
    \end{array}
\end{rclarray}
\]
is defined in \figref{fig:thread_semantics}.
\end{defn}

\begin{figure}[!t]
%
\hrule
%
\[
    \infer[\rl{PCommit}]{%
        \como \vdash ( \stk, \hh, \vi ), \ptrans{\trans} \ \toT \ ( \stk', \hh', \vi' ) , \pskip
    }{%
        \begin{array}{c}
            \txid \in \func{fresh}{\hh}  
            \quad \h = \clpsHH{\hh,\vi}
            \quad \vdash (\stk, \h, \unitO), \trans \ \toL^{*} \  (\stk', \h', \opset) , \pskip \\
            \hh' = \func{commit}{\hh, \vi, \txid, \opset}  
            \quad \cu = \func{update}{\hh', \vi, \opset} 
            \quad ((\hh,\vi),(\hh',\vi)) \in \como
        \end{array}
    }
\]

\[
    \infer[\rl{PAssign}]{%
        \como \vdash ( \stk, \hh, \vi ) , \passign{\var}{\expr} \ \toT \  ( \stk\rmto{\var}{\val}, \hh, \vi ) , \pskip
    }{
        \val = \evalE[\thstk]{\expr}
    }
\]

\[
    \infer[\rl{PAssume}]{%
        \como \vdash ( \stk, \hh, \vi ) , \passume{\expr} \ \toT \  ( \stk, \hh, \vi ) , \pskip
    }{%
        \evalE[\thstk]{\expr} = 0
    }
\]

\[
    \infer[\rl{PCutShift}]{
        \como, \thid \vdash ( \thstk, \hh, \thcu ) , \prog \ \toT{\lbID} \  ( \thstk, \hh, \thcu' ) , \prog
    }{
        \thcu \leq \thcu'
    }
\]

\[
    \infer[\rl{PChoice}]{%
        \como, \thid \vdash ( \thstk, \hh, \thcu ) , \prog_{1} \pchoice \prog_{2} \ \toT{\lbID} \  ( \thstk, \hh, \thcu ) , \prog'
    }{
        \prog' \in \Set{\prog_{1}, \prog_{2}}
    }
\]

\[
    \infer[\rl{PLoop}]{%
        \como, \thid \vdash ( \thstk, \hh, \thcu ) , \prog\prepeat \ \toT{\lbID} \  ( \thstk, \hh, \thcu ) , \pskip \pchoice (\prog \pseq \prog\prepeat)
    }{}
\]

\[
    \infer[\rl{PSeqSkip}]{%
        \como, \thid \vdash ( \thstk, \hh, \thcu ) , \pskip \pseq \iprog \ \toT{\lbID} \  ( \thstk, \hh, \thcu ) , \iprog
    }{}
\]

\[
    \infer[\rl{PSeq}]{%
        \como, \thid \vdash ( \thstk, \hh, \thcu ) , \iprog_{1} \pseq \iprog_{2} \ \toT{\lb} \ ( \thstk', \hh, \thcu' ) , {\iprog_{1}}' \pseq \iprog_{2}
    }{%
        \como, \thid \vdash ( \thstk, \hh, \thcu ) , \iprog_{1} \ \toT{\lb} \  ( \thstk', \hh, \thcu' ) , {\iprog_{1}}' 
    }
\]

\[
    \infer[\rl{PPar}]{%
        \como, \thid \vdash ( \thstk, \hh, \thcu ) , \prog_{1} \ppar \prog_{2} \ \toT{\lbF{\thid', \prog_{2}}} \  \left( \thstk, \hh, \thcu \uplus \Set{\thid' \mapsto \thcu(\thid)} \right) , \prog_{1} \pseq \pwait{\thid'}
    }{}
\]

\[
    \infer[\rl{PWait}]{%
        \como, \thid \vdash \left( \thstk_{1} \uplus \thstk_{f}, \hh, \thcu \uplus \Set{\thid' \mapsto \thcu(\thid)} \right) , \pwait{\thid'} \ \toT{\lbJ{\thid', \thstk_{2} \uplus \thstk_{f}}} \  ( \thstk_{1} \uplus \thstk_{2} \uplus \thstk_{f}, \hh, \thcu ) , \pskip 
    }{}
\]

\sx{The stack could be polluted by the child thread, but they must agree?}
 
where,
\[
\begin{rclarray}                                 
    \func{commit}{\hh, \cu, \txid, \opset} & \defeq & 
    \begin{cases}
        \hh & \text{if } \opset = \unitO \\
        \func{commit}{\hh', \cu, \txid, \opset'} & \text{if } \opset = \opset' \addO (\otR, \addr, \val) \\
        \func{commit}{\hh'', \cu, \txid, \opset''} & \text{if } \opset = \opset'' \addO (\otW, \addr, \val) \\
    \end{cases} \\
    \hh' & \equiv & \hh\rmto{\addr}{\hh(\addr)\rmto{\cu(\addr)}{\left(\hhV(\addr)(\cu(\addr)),\hhW(\addr)(\cu(\addr)),\hhR(\addr)(\cu(\addr)) \uplus \Set{\txid} \right)}} \\
    \hh'' & \equiv & \hh\rmto{\addr}{\hh(\addr) +\!\!+ [(\val, \txid, \emptyset)] } \\
%
%
    \func{update}{\hh, \cu, \opset} & \defeq &
    \begin{cases}
        \cu & \text{if } \opset = \unitO \\
        \func{update}{\hh, \cu, \opset'} & \text{if } \opset = \opset' \addO (\otR, \addr, \val) \\
        \func{update}{\hh, \cu\rmto{\addr}{\left| \hh(\addr) \right|}, \opset''} & \text{if } \opset = \opset'' \addO (\otW, \addr, \val) \\
    \end{cases} \\
%
%              
	\func{fresh}{\aexecrun}  & \defeq & \Setcon{ \txid }{ \txid \in \TxID \land \for{\addr, i} \txid \neq \hhW(\addr)(i) \land \txid \notin \hhR(\addr)(i) } \\
\end{rclarray}
\]
\hrule
\caption{Per-thread operational semantics}
\label{fig:thread_semantics}
\end{figure}

\sx{The full version should support dynamic thread, but we might only need fixed thread so that the thread pool semantics will be pick one thread and run one step}

\begin{defn}[Thread pools]
\label{def:thread_pools}
Given the set of thread stacks $\ThdStacks$ (\defref{def:stacks}) and intermediate programs $\IntermediatePrograms$ (\defref{def:thread_semantics}), a \emph{thread pool} is a a finite partial function from thread identifiers to triples of thread stacks and intermediate programs, \(\thpl \in \TPool \eqdef \ThreadID \parfinfun \ThdStacks \times \IntermediatePrograms\).
\end{defn}
 
\begin{defn}[Thread pool semantics] 
\label{def:thread_pool_semantics}
Given the set of consistent models \( \ConsisModels \) (\defref{def:consistency-models}), history heaps \(\HisHeaps\) (\defref{def:his_heap}), cuts' runtime \(\ThCuts\) (\defref{def:cuts}), transition labels \( \Translabel \) (\defref{def:label}) and thread pools  \( \TPool \) (\defref{def:thread_pools}), the \emph{thread pool semantics}, 
\[
	\toG{} : \Como \times (\HisHeaps \times \ThCuts \times \TPool) \times \Translabel \times (\HisHeaps \times \ThCuts \times \TPool) 
\]
is defined in \figref{fig:thread_pool_semantics}.
\end{defn}
 
The thread pool operational semantics is given in \figref{fig:thread_pool_semantics}, where an arbitrary thread in the pool \(\thpl\) is picked to run for one step.
If the next execution step is a thread fork, then a new thread \(\thid'\) is allocated in the pool to be executed with its thread stack copied from its parent (forking) thread.
Conversely, when the next execution step is the joining of thread \(\thid'\), then \(\thid'\) is removed from the thread pool and the stack from the child thread merges into the parent thread.

\begin{figure}
\hrule\vspace{5pt}
%
\[
    \infer[\rl{PSingle}]{%
        \como \vdash ( \hh, \thcu, \thpl \uplus \Set{ \thid \mapsto (\thstk, \iprog) } ) \ \toG{\lb} \  ( \hh', \thcu', \thpl \uplus \Set{ \thid \mapsto (\thstk', {\iprog}') } ) 
    }{%
        \como, \thid \vdash ( \thstk, \hh, \thcu ) , \iprog \ \toT{\lb} \  ( \thstk', \hh', \thcu' ) , {\iprog}' 
        \quad \lb \in \Set{ \lbID, \lbC{\stub} }
    }
\]

\[
    \infer[\rl{PFork}]{%
        \como \vdash ( \hh, \thcu, \thpl \uplus \Set{ \thid \mapsto (\thstk, \iprog) } ) \ \toG{\lbF{\thid', \prog}} \  ( \hh', \thcu', \thpl \uplus \Set{ \thid \mapsto (\thstk, {\iprog}'), \thid' \mapsto (\thstk, \prog) } )
    }{%
        \como, \thid \vdash ( \thstk, \hh, \thcu ) , \iprog \ \toT{\lbF{\thid', \prog}} \  ( \thstk, \hh', \thcu' ) , {\iprog}' 
    }
\]

\[
    \infer[\rl{PJoin}]{%
        \como \vdash ( \hh, \thcu, \thpl \uplus \Set{ \thid \mapsto (\thstk, \iprog), \thid' \mapsto (\thstk', \pskip) } )  \ \toG{\lbJ{\thid',\thstk''}} \ ( \hh', \thcu', \thpl \uplus \Set{ \thid \mapsto (\thstk'', {\iprog}')} )
    }{%
        \como, \thid \vdash ( \thstk, \hh, \thcu ) , \iprog \ \toT{\lbJ{\thid',\thstk'}} \  ( \thstk'', \hh', \thcu' ) , {\iprog}' 
    }
\]
%
\hrule\vspace{5pt}
\caption{Thread pool semantics}
\label{fig:thread_pool_semantics}
\end{figure}
