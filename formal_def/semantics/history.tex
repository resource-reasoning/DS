\subsection{Program Semantics}

We model the state of database as a history heap, where each address has a list \emph{versions} from the initial one to the latest one.
Each version contains a value and a transaction identifier who writes it and a set of transactions who read it.

\begin{defn}[History Heaps]
\label{def:his_heap}
Assuming a set of \emph{transactions identifiers} \( \TxID \defeq \Set{\txid, \dots}\), a \emph{history heap}, \( \hh \in \HisHeaps \), is a partial function from addresses to lists of \emph{versions}.
Each version a tuple contains a value, a transaction (identifier) and a set of transactions (identifiers).
\[
\begin{rclarray}
    \Versions & \defeq &  \Val \times \TxID \times \powerset{\TxID} \\
    \HisHeaps & \defeq & \Addr \parfinfun \Versions^{*}
\end{rclarray}
\]
The composition of two history heaps is \( \hh \composeHH \hh' \defeq \hh \uplus \hh' \) and the unit element is \( \unitHH \defeq \emptyset \). 
\end{defn}
 
Let \( \hh(\addr)(i)\) denotes the \emph{i-th} version associated with address \( \addr \), and \( \hhV(\addr)(i) \), \( \hhW(\addr)(i) \) and \( \hhR(\addr)(i) \) denote the first (value), second (write) and third element (read) of the version.
We assume the version number starts from 1.

For weak consistency models, or weak isolation levels which are more common term used in database community, a session is not necessary to work on the up-to-date version of a database in exchange for better performance. 
Even in a single machine database, a session running under weak consistency model can make less synchronisation with the hard drivers and other running threads, which means the session could observe out-of-date state.
We use \emph{views} to model sessions of a database.
A \emph{view} is a cut in a history heap that corresponds the version that a session work with.

\begin{defn}[Views]
\label{def:cuts}
\label{def:views}
\emph{A view of of a history heap}, short as \emph{view}, is a partial function from addresses to indexes,
\[
\begin{rclarray}
    \vi \in \viset \subseteq \Views & \defeq & \Addr \parfinfun \Nat
\end{rclarray}
\]                                                                     
The composition is \( \vi \composeVI \vi' \defeq \vi \uplus \vi'\) and the unit is \( \unitVI \defeq \emptyset\).
The order between two views if they have the same domain is the order of all the indexes, 
\[
\begin{rclarray}
    \cu \orderCU \cu' & \defiff & \dom(\cu) = \dom(\cu') \land \for{\addr} \cu(\addr) \leq \cu'(\addr) \\
\end{rclarray}
\]
Assuming a set of thread identifiers \( \setthid \subseteq \ThreadID \), \emph{a view environment} is a function from thread identifiers to views, this is, \( \vienv \in \ViEnv \defeq \ThreadID \parfun \Views \).
\end{defn}

Consistency models are specified as relations over pairs of history heaps and cut environments, and it describes what transitions are allowed.

\begin{defn}[Consistency Models]
\label{def:consistency-models}
A \emph{Consistency model} \( \como \) is a \emph{reflexive and transitive relation} over pairs of history heaps and cut environments, written \( ((\hh,\viset),(\hh',\viset')) \in \como \) or \( (\hh, \viset) \toCO{\como} (\hh', \viset' )\), that the transition from the state \( (\hh,\viset)\) to the state \( (\hh',\viset') \) satisfies certain constraints.
Each tuple in the set should satisfy a well-formed condition that the cut environment should contain no more address than the history heap,
\[
    \bigwedge\limits_{\vi \in \viset} \dom(\vi) \subseteq \dom(\hh)
\]
\sx{Might be useful constraint for soundness of logic, if never used, just delete this.}
The specification of a certain consistency model should be local to the owned history heaps, so that the combination of two disjointed parts also satisfies the specification.
\[
    \begin{array}{@{}l}
    \for{\hh,\hh',\hh'',\hh''', \viset, \viset', \viset'', \viset'''} \\
        \quad ((\hh, \viset),(\hh',\viset')) \in \como 
        \land ((\hh'', \viset''),(\hh''',\viset''')) \in\como 
        \land ( \hh \composeHH \hh'' )\isdef
        \land ( \hh' \composeHH \hh''' )\isdef \\
        \qquad \implies  ((\hh \composeHH \hh'', \viset \uplus \viset''),(\hh' \composeHH \hh''',\viset' \uplus \viset''')) \in \como
    \end{array}
\]
\sx{The following says the consistency model transfer from a valid state to another valid state. }
A consistency model also requires to transfer from a \emph{valid} state to another \emph{valid} state where the validity is independent from the transition.
\[
    \for{\como} \exsts{\funcn{valid}} (\hh, \viset) \in \como \implies \func{valid}{\hh, \viset}
\]
where \( (\hh , \viset) \in \como\) means the state \((\hh, \viset)\) appears in the relation.
\end{defn}

\sx{Need Andrea for more clarify about defining consistency model}

There are two ways to specify consistency models, one by converting the history heaps to dependant graphs and checking if the cycles satisfy certain property, while another by checking if the view environment satisfy certain property.
We introduce \( \funcn{graph} : \HisHeaps \to \sort{DGraph} \) function for converting history heaps to dependant graphs.
\[
\begin{rclarray}
    \DGraph & \defeq & \Setcon{(\txidset, \ww, \wrr, \rw)}{ \txidset \subseteq \TxID \land \ww, \wrr, \rw \subseteq (\txidset \times \txidset)} \\
    \func{graph}{\hh} & \defeq & \left(
    \begin{array}{@{}l}
        \Setcon{\txid}{\exsts{\addr, i} \txid = \hhW(\addr)(i) \lor \txid \in \hhR(\addr)(i) }, \\
        \Setcon{(\txid, \txid')}{\exsts{\addr, i, i'} \txid = \hhW(\addr)(i) \lor \txid' = \hhW(\addr)(i') \land i < i' }, \\
        \Setcon{(\txid, \txid')}{\exsts{\addr, i} \txid = \hhW(\addr)(i) \lor \txid' \in \hhR(\addr)(i) }, \\
        \Setcon{(\txid, \txid')}{\exsts{\addr, i, i'} \txid \in \hhR(\addr)(i) \lor \txid' = \hhW(\addr)(i') \land i < i' }, \\
    \end{array}
    \right)
\end{rclarray}
\]

\begin{example}[Serialisibility]
\end{example}

\begin{example}[Snapshot]
Any cycle in the corresponding dependant graph of the history heap after the transition must have adjacent anti-dependent edges (\( \rw \) edges).
\[
    \begin{rclarray}
    \SI & \defeq & \Setcon{((\hh, \thcu),(\hh', \thcu'))}{\exsts{\ww, \rw, \wrr} (\stub, \ww, \wrr, \rw)  = \func{graph}{\hh'} \land (\wrr \cup \ww) ; \rw? \text{ is acyclic}}
    \end{rclarray}
\]
\end{example}

%{ \color{gray}
%\begin{defn}[Thread transition labels]
%\label{def:label}
%Given the set of thread identifiers \(\thid \in \ThreadID\), the set of \emph{thread transition labels}, $\lb \in \Translabel$, is defined by the following grammar, where $\prog$ denotes a program (\defref{def:language}), the $\txid$ demotes a transaction identifier and $\thstk$ denotes a thread stack (\defref{def:stacks}),
%\[
    %\begin{rclarray}
	%\iota \in \Translabel & ::= & \lbID \mid \lbC{\txid} \mid \lbF{\thid,\prog} \mid \lbJ{\thid,\thstk}
    %\end{rclarray}
%\]
%\end{defn}
%}

%{ \color{gray}
%A spacial version of this function only takes a history heap, and it returns a normal heap that is the latest state of the database.
%}

%{ \color{gray}
%The function is overloaded with one parameter version that collapses history heaps by picking the last values,
%\[
%\begin{rclarray}
    %\clpsHH{\hh} & \defeq & \lambda \addr \ldotp \hhV(\addr)(\left|\hh(\addr)\right|) 
%\end{rclarray}
%\]
%}
%\end{defn}

\begin{defn}[Thread semantics]
\label{def:thread_semantics}
%{ \color{gray}
%Given the thread identifiers \(\thid \in \ThreadID\), the set of \emph{intermediate programs}, \(\iprog \in \IntermediatePrograms\), is defined by the following grammar,
%\[
    %\iprog ::= \prog \mid \iprog \pseq \pwait{\thid}
%\]
%}
Given the set of consistency model \( \ConsisModels \) (\defref{def:consistency-models}), stacks \( \Stacks \) (\defref{def:stacks}), history heaps \( \HisHeaps \) (\defref{def:his_heap}) and views \( \Views \) (\defref{def:cuts}), the \emph{per-thread operational semantics} of programs,
\[
\begin{rclarray}
	\toT{} & : &
    \begin{array}[t]{@{}l@{}}
    \Como 
    \times {} \\
	\quad \left( ( \Stacks \times \HisHeaps \times \Views ) \times \Commands \right) 
	\times \Translabel \times
	\left( ( \Stacks \times \HisHeaps \times \Views ) \times \Commands \right) 
    \end{array}
\end{rclarray}
\]
is defined in \figref{fig:thread_semantics}.
The labels are for technical reason because some steps need to satisfy certain constraints related other threads. 
The labels includes commit \( \lbC{\txid} \), view shift \( \lbV \) and identify \( \lbID \).
\end{defn}

\begin{figure}[!t]
%
\hrule
%
\[
    \infer[\rl{PCommit}]{%
        \como \vdash ( \stk, \hh, \vi ), \ptrans{\trans} \ \toT{\lbC{\txid}} \ ( \stk', \hh', \vi' ) , \pskip
    }{%
        \begin{array}{c}
            \txid \in \func{fresh}{\hh}  
            \quad \h = \clpsHH{\hh,\vi}
            \quad \vdash (\stk, \h, \unitO), \trans \ \toL^{*} \  (\stk', \h', \opset) , \pskip \\
            \hh' = \func{updHisHp}{\hh, \vi, \txid, \opset}  
            \quad \func{updView}{\hh', \vi, \opset} \orderVI \vi 
            \quad \pred{wfView}{\hh', \vi'}  \\
            \hh,\Set{\vi} \toCO{\como} \hh',\Set{\vi}
        \end{array}
    }
\]

\[
    \infer[\rl{PAssign}]{%
        \como \vdash ( \stk, \hh, \vi ) , \passign{\var}{\expr} \ \toT{\lbID} \  ( \stk\rmto{\var}{\val}, \hh, \vi ) , \pskip
    }{
        \val = \evalE{\expr}
    }
\]

\[
    \infer[\rl{PAssume}]{%
        \como \vdash ( \stk, \hh, \vi ) , \passume{\expr} \ \toT{\lbID} \  ( \stk, \hh, \vi ) , \pskip
    }{%
        \evalE[\thstk]{\expr} = 0
    }
\]

\[
    \infer[\rl{PViewLShift}]{
        \como \vdash ( \stk, \hh, \vi ) , \cmd \ \toT{\lbV} \  ( \stk, \hh, \cu' ) , \cmd
    }{
        \vi \orderVI \vi'
    }
\]

\[
    \infer[\rl{PChoice}]{%
        \como \vdash ( \stk, \hh, \vi ) , \cmd_{1} \pchoice \cmd_{2} \ \toT{\lbID} \  ( \stk, \hh, \vi ) , \cmd'
    }{
        \cmd' \in \Set{\cmd_{1}, \cmd_{2}}
    }
\]

\[
    \infer[\rl{PLoop}]{%
        \como \vdash ( \stk, \hh, \vi ) , \cmd\prepeat \ \toT{\lbID} \  ( \stk, \hh, \vi ) , \pskip \pchoice (\cmd \pseq \cmd\prepeat)
    }{}
\]

\[
    \infer[\rl{PSeqSkip}]{%
        \como \vdash ( \stk, \hh, \vi ) , \pskip \pseq \cmd \ \toT{\lbID} \  ( \stk, \hh, \vi ) , \cmd
    }{}
\]

\[
    \infer[\rl{PSeq}]{%
        \como \vdash ( \stk, \hh, \vi ) , \cmd_{1} \pseq \cmd_{2} \ \toT{\lb} \ ( \stk', \hh, \vi' ) , {\cmd_{1}}' \pseq \cmd_{2}
    }{% 
        \como \vdash ( \stk, \hh, \vi ) , \cmd_{1} \ \toT{\lb} \  ( \stk', \hh, \vi' ) , {\cmd_{1}}' 
    }
\]

%{ \color{gray}
%\[
    %\infer[\rl{PPar}]{%
        %\como, \thid \vdash ( \thstk, \hh, \thcu ) , \prog_{1} \ppar \prog_{2} \ \toT{\lbF{\thid', \prog_{2}}} \  \left( \thstk, \hh, \thcu \uplus \Set{\thid' \mapsto \thcu(\thid)} \right) , \prog_{1} \pseq \pwait{\thid'}
    %}{}
%\]

%\[
    %\infer[\rl{PWait}]{%
        %\como, \thid \vdash \left( \thstk_{1} \uplus \thstk_{f}, \hh, \thcu \uplus \Set{\thid' \mapsto \thcu(\thid)} \right) , \pwait{\thid'} \ \toT{\lbJ{\thid', \thstk_{2} \uplus \thstk_{f}}} \  ( \thstk_{1} \uplus \thstk_{2} \uplus \thstk_{f}, \hh, \thcu ) , \pskip 
    %}{}
%\]
%}

\hrule
 
\[
\begin{rclarray}                                 
    \pred{wfView}{\hh,\vi} & \defeq & \for{\addr} \vi(\addr) \leq \left|\hh(\addr) \right| \\
    \clpsHH{\hh, \cu} & \defeq & 
    \begin{cases}
        \lambda \addr \ldotp \hhV(\addr)(\cu(\addr)) & \text{if } \dom(\hh) = \dom(\cu) \land \for{\addr'} \cu(\addr') \leq \left|\hh(\addr')\right| \\
        \text{undefined} & \text{otherwise}
    \end{cases} \\
    \func{updHisHp}{\hh, \vi, \txid, \opset} & \defeq & 
    \begin{cases}
        \hh & \text{if } \opset = \unitO \\
        \func{updHisHp}{\hh', \vi, \txid, \opset'} & \text{if } \opset = \opset' \addO (\otR, \addr, \val) \\
        \func{updHisHp}{\hh'', \vi, \txid, \opset'} & \text{if } \opset = \opset' \addO (\otW, \addr, \val) \\
    \end{cases} \\
    \hh' & \equiv & \hh\rmto{\addr}{\hh(\addr)\rmto{\vi(\addr)}{\left(\hhV(\addr)(\vi(\addr)),\hhW(\addr)(\vi(\addr)),\hhR(\addr)(\vi(\addr)) \uplus \Set{\txid} \right)}} \\
    \hh'' & \equiv & \hh\rmto{\addr}{\hh(\addr) \lcat \List{(\val, \txid, \emptyset)} } \\
%
%
    \func{updView}{\hh, \vi, \opset} & \defeq &
    \begin{cases}
        \vi & \text{if } \opset = \unitO \\
        \func{updView}{\hh, \vi, \opset'} & \text{if } \opset = \opset' \addO (\otR, \addr, \val) \\
        \func{updView}{\hh, \vi\rmto{\addr}{\left| \hh(\addr) \right|}, \opset'} & \text{if } \opset = \opset' \addO (\otW, \addr, \val) \\
    \end{cases} \\
%
%              
	\func{fresh}{\hh}  & \defeq & \Setcon{ \txid }{ \txid \in \TxID \land \for{\addr, i} \txid \neq \hhW(\addr)(i) \land \txid \notin \hhR(\addr)(i) } \\
\end{rclarray}
\]
\hrule
\caption{Per-thread operational semantics}
\label{fig:thread_semantics}
\end{figure}

A new transaction is committed through the \rl{PCommit} rule.
The transaction code \( \trans \) is executed locally given the local state that is decided by the current state of database and the local view, \ie the history heap \( \hh \) and view \( \vi \) respectively.
The \( \funcn{clps} \) function collapses a history heap and a view to a normal heap by picking the versions corresponding to the view.
After local execution, the transaction picks a fresh identifier \( \txid \) and commits the set of operations \( \opset \).
The operations are the first read and last write of each address, which are the operations might affect the database, because of the atomicity of transactions.
The \funcn{updHisHp} function updates the history heap.
If there is a read operation, it includes the new identifier to the version relates to the address and the local view \( \vi \).
If there is a write operation, it extends a new version to the end and puts the new identifier as the writer.
Since we assume strong session, we set the lower bound for the new local view by \funcn{updView} function.
This function shifts the view to the latest version if the version is written by the current transaction.
This guarantees if there is no currency, the following transaction will read the write.
Since it is a lower bound, the new local view \( \vi' \) can advance the view as long as it is not out-of-bound.
Finally, the transition from \( (\hh, \vi) \) to \( (\hh', \vi') \) should be allowed by the consistency model \( \como \).

To model synchronisation between sessions, the \rl{PViewLShift} rule allows to non-deterministically advance a view.
Except \rl{PCommit} and \rl{PViewLShift}, the rest rules have the expected behaviours.

\begin{lem}[Confluence of \funcn{updHisHp} and \funcn{updView}]
Given a valid set of operations \( \opset \), all the computation paths for \( \funcn{updHisHp} \) function (\( \funcn{updView} \) function) yield the same result.
\end{lem}

%\sx{The full version should support dynamic thread, but we might only need fixed thread so that the thread pool semantics will be pick one thread and run one step}

%{ \color{gray}
%\begin{defn}[Thread pools]
%\label{def:thread_pools}
%Given the set of thread stacks $\ThdStacks$ (\defref{def:stacks}) and intermediate programs $\IntermediatePrograms$ (\defref{def:thread_semantics}), a \emph{thread pool} is a a finite partial function from thread identifiers to triples of thread stacks and intermediate programs, \(\thpl \in \TPool \eqdef \ThreadID \parfinfun \ThdStacks \times \IntermediatePrograms\).
%\end{defn}
%}
 
\begin{defn}[Programs semantics] 
\label{def:thread_pool_semantics}
\label{def:program_semantics}
Given the set of consistent models \( \ConsisModels \) (\defref{def:consistency-models}), history heaps \(\HisHeaps\) (\defref{def:his_heap}) and view environment \(\ViEnv \) (\defref{def:cuts}), the \emph{thread pool semantics}, 
\[
	\toG{} : \Como 
    \times ( \StkEnv \times \HisHeaps \times \ViEnv \times \Programs) 
    \times ( \StkEnv \times \HisHeaps \times \ViEnv \times \Programs) 
\]
is defined in \figref{fig:thread_pool_semantics}.
The stack environment \( \StkEnv \) is a partial function from thread identifiers to stacks.
\end{defn}
 
The program has standard interleaving semantics by picking a thread and then running one step.
If the step is commit \( \lbC{\txid} \), the overall transition of history heap and view environment should satisfy consistency model.
In anther words, the view that has been changed should be compatible with those has not been changed.
It is necessary to check the compatibility because some consistency models are specified as constraints among all views.
We write \( \hh, \vienv \toCO{\como} \hh', \vienv' \) as short-hand for \( \hh, \func{range}{\vienv} \toCO{\como} \hh', \func{range}{\vienv'} \).
If the step is view shift \( \lbV \), it should shift to a valid state\footnote{It is not necessary to always shift to a valid state, yet it is a design choice for abstract operational semantics.}.
 
%The thread pool operational semantics is given in \figref{fig:thread_pool_semantics}, where an arbitrary thread in the pool \(\thpl\) is picked to run for one step.
%If the next execution step is a thread fork, then a new thread \(\thid'\) is allocated in the pool to be executed with its thread stack copied from its parent (forking) thread.
%Conversely, when the next execution step is the joining of thread \(\thid'\), then \(\thid'\) is removed from the thread pool and the stack from the child thread merges into the parent thread.

\begin{figure}
\hrule\vspace{5pt}
%
\[
    \infer[\rl{PSingle}]{%
        \como \vdash ( \stkenv, \hh, \vienv, \prog ) \ \toG \  ( \stkenv\rmto{\thid}{\stk'}, \hh', \vienv\rmto{\thid}{\vi'}, \prog\rmto{\thid}{\cmd'} ) 
    }{%
    \begin{array}{c}
        \stk = \stkenv(\thid)
        \quad \vi = \vienv(\thid)
        \quad \cmd = \prog(\thid) \\
        \como \vdash ( \stk, \hh, \vi ), \cmd, \ \toT{\lb} \  ( \stk', \hh', \vi' ) , \cmd'  \\
        \begin{B}
        \lb = \lbID \lor (\lb = \lbC{\stub} \land \hh, \vienv \toCO{\como} \hh', \vienv') \lor \begin{B}\lb = \lbV \land \pred{valid}{\hh',\vienv'}\end{B}
        \end{B}
    \end{array}
    }
\]

%{ \color{gray}
%\[
    %\infer[\rl{PFork}]{%
        %\como \vdash ( \hh, \thcu, \thpl \uplus \Set{ \thid \mapsto (\thstk, \iprog) } ) \ \toG{\lbF{\thid', \prog}} \  ( \hh', \thcu', \thpl \uplus \Set{ \thid \mapsto (\thstk, {\iprog}'), \thid' \mapsto (\thstk, \prog) } )
    %}{%
        %\como, \thid \vdash ( \thstk, \hh, \thcu ) , \iprog \ \toT{\lbF{\thid', \prog}} \  ( \thstk, \hh', \thcu' ) , {\iprog}' 
    %}
%\]

%\[
    %\infer[\rl{PJoin}]{%
        %\como \vdash ( \hh, \thcu, \thpl \uplus \Set{ \thid \mapsto (\thstk, \iprog), \thid' \mapsto (\thstk', \pskip) } )  \ \toG{\lbJ{\thid',\thstk''}} \ ( \hh', \thcu', \thpl \uplus \Set{ \thid \mapsto (\thstk'', {\iprog}')} )
    %}{%
        %\como, \thid \vdash ( \thstk, \hh, \thcu ) , \iprog \ \toT{\lbJ{\thid',\thstk'}} \  ( \thstk'', \hh', \thcu' ) , {\iprog}' 
    %}
%\]
%}
%
\hrule\vspace{5pt}
\caption{Thread pool semantics}
\label{fig:thread_pool_semantics}
\end{figure}
