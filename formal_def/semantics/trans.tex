\subsection{Programming language}

For simplify, \emph{a program} \( \prog \) contains fixed numbers of top level threads and there is no dynamic fork and join.
Each thread has a unique thread identifier \( \thid \in \ThreadID \) and associated \emph{commands}.
The \emph{commands}, ranged over by $\cmd$, are defined by an inductive grammar comprising the standard constructs of $\pskip$, sequential composition ($\cmd; \cmd$), non-deterministic choice ($\cmd+\cmd$) and loops ($\cmd^*$).
To simulate conditional branching and loops, we have primitive commands assume (\( \passume{\expr}\)) and assignment (\( \passign{\var}{\expr} \)), where \( \var \) denotes stack variable and \( \expr \) denotes arithmetic expressions which have no side effect.
Additionally, the programming language contains the \emph{transaction} construct $\ptrans{\trans}$ denoting the \emph{atomic} execution of the transaction $\trans$. 
The atomicity guarantees the execution are dictated by the underlying consistency model.
\emph{Transactions}, ranged over by $\trans$, are defined by a similar inductive grammar comprising $\pskip$, non-deterministic choice, loops and sequential composition, as well as primitive constructs, ranged over by \( \transpri \), including assignment (\( \passign{\var}{\expr}\)), assume (\( \passume{\expr}\)), lookup (\( \pderef{\expr}{\expr}\)), mutation (\( \pmutate{\expr}{\expr}\)) and return(\( \preturn{\expr}\)). 
Transactions do \emph{not} contain the \emph{parallel} composition construct ($\ppar$) as they are to be executed atomically.
We assume a valid transactions codes must have the only return at the end.
For better presentation, sometime we omit the default return zero \( \preturn{0} \).
%Transactions can only assign to their own variables, namely transaction variables (\defref{def:program_values}), but it can read from both the thread and transaction stacks.

\begin{defn}[Program values]
\label{def:program_values}
Assume a countably infinite set of \emph{addresses}, $\addr \in \Addr$. The set of \emph{program values} is $\val \in \Val \eqdef \Nat \cup \Addr$, where $ \nat \in \Nat$ denotes the set of natural numbers.
\end{defn}

\begin{defn}[Programming language]
\label{def:language}
A \emph{program}, $\prog \in \Programs$, is a partial function from thread identifiers to commands.
Assuming the set of \emph{variables} \( \var \in \Vars \), the commands \( \cmd \in \Commands \) are defined by the following grammar,
\[
    \begin{rclarray}
    \cmd & ::= &
        \pskip \mid 
        \passign{\thvar}{\expr} \mid
        \passume{\expr} \mid
        \ptrans{\trans} \mid 
        \cmd \pseq \cmd \mid 
        \cmd \pchoice \cmd \mid 
        \cmd \prepeat 
    \end{rclarray}
\]
The $\trans \in \Transactions$ in the grammar above denotes a \emph{transaction} defined by the following grammar.
The transaction codes \( \ptrans{\trans} \) satisfy a well-form condition that there is exactly a return at the end, \ie \( \ptrans{\trans} \iff \exsts{\trans', \expr} \trans \equiv ( \trans' \pseq \preturn{\expr} )  \land \pred{noRet}{\trans'} \).
\[
    \begin{rclarray}
        \transpri & ::= &
        \pass{\txvar}{\expr} \mid
        \pderef{\txvar}{\expr} \mid
        \pmutate{\expr}{\expr} \mid
        \passume{\expr} \mid
        \preturn{\expr} \\
        \trans & ::= &
        \pskip \mid
        \transpri \mid 
        \trans \pseq \trans \mid
        \trans \pchoice \trans \mid
        \trans\prepeat
    \end{rclarray}
\]
The $\expr \in \Expressions$ denotes an \emph{arithmetic expression} defined by the grammar below with $\val \in \Val$ (\defin\ref{def:program_values}),
\[
    \begin{rclarray}
        \expr & ::= &
        \val \mid
        \var \mid
        \expr + \expr \mid
        \expr \times \expr \mid
        \dots 
    \end{rclarray}
\]
\end{defn}

\subsection{Local/Transaction Semantics}

Each thread has it own stack, where local variables are stored.
A thread can access the stack inside or outside transactions.
When a transaction start, it determine a local heap from the current state of database and local view, which we will explain the process later.
Yet this local heap does not affect outside world, instead we use \emph{operation} to connect a transaction to outside world.
A operation could be read or write to a address with a value.
Intuitively, when a transaction is about to commit, it will have \emph{a set of operations} containing the first read and last write for each address.
Because a transaction is executed atomically, all the intermediate steps are not observable from the outside world.

we introduce \emph{a well-formed set of operations} \( \opset \in \Opsets\) that is a subset of operations in which there are at most one read and one write for each address.
The composition, then, is defined as set disjointed union as long as the result is well-formed.
To help us write down the semantics, we assume a binary operator \( \opset \addO \op \) that specifies the effects of adding a new operation \( \op \) to the set \( \opset \).
If the new operation is a read, for example \(\otR, \addr, \val\) that \( \addr \) is the address and \( \val\) is the value, and there is no other operation related to the same address, this new read operation will be included in the set.
Note that if there is already a write in the set, this mean the following reads are all local.
Meanwhile, if the new operation is a write, it will overwrite all preview write operations to the same address.

\sx{Single stack for simplicity. Design choice, total stack vs partial stack, make sure it is consistent.}

\begin{defn}[Stacks]
\label{def:stacks}
A \emph{stack} is a partial function from variables \( \Vars \) (\defref{def:language}) to values program values \( \Val \) (\defref{def:program_values}), this is \( \stk \in \Stacks \defeq \Vars \parfun \Val \).
\end{defn}

%{ \color{gray}
%\begin{defn}[Stacks]
%Given the program values (\defref{def:program_values}) and a set of \emph{transaction variables} \( \TxVars \defeq \Set{\txvar, \dots}\), a \emph{transaction stack} is a partial function from transaction variables to values \( \txstk \in \TxStacks \defeq \TxVars \parfun \Val \).
%Similarly, assuming a set of \emph{thread variables} \( \ThdVars \defeq \Set{\thvar, \dots}\), a \emph{thread stack} is defined as \( \thstk \in \ThdStacks \defeq \ThdVars \parfun \Val \).
%Then, the set of \emph{stacks} is defined as the union of transaction stacks and thread stacks \( \stk \in \Stacks \eqdef \TxStacks \uplus \ThdStacks \).
%\end{defn}
%}

\begin{definition}[Heaps]
\label{def:heaps}
Given the sets of program values $\Val$  and addresses \( \Addr\)  (\defin\ref{def:program_values}), the set of \emph{heaps} is: $\h \in \Heaps \eqdef \Addr \parfinfun \Val$.
The \emph{heap composition function}, $\composeH: \Heaps \times \Heaps \parfun \Heaps$, is defined as $\composeH \eqdef \uplus$, where $\uplus$ denotes the standard disjoint function union. The \emph{ heap unit element} is $\unitH \eqdef \emptyset$, denoting a function with an empty domain.
The \emph{partial commutative monoid of  heaps} is $(\Heaps, \composeH, \{\unitH\})$.
\end{definition}

\begin{defn}[Evaluation of expression]
Given a stack $\stk \in \Stacks$ (\defin\ref{def:stacks}), the \emph{arithmetic expression evaluation} function, $\evalE[(.)]{.}:\Expressions \times \Stacks \parfun \Val$, is defined inductively over the structure of expressions as follows: 
%
\[
    \begin{rclarray}
        \evalE{\val} & \defeq & \val \\
        \evalE{\var} & \defeq & \stk(\var) \\
        \evalE{\expr_{1} + \expr_{2}} & \defeq & \evalE{\expr_{1}} + \evalE{\expr_{2}} \\
        \evalE{\expr_{1} \times \expr_{2}} & \defeq & \evalE{\expr_{1}} \times \evalE{\expr_{2}} \\
        \dots & \eqdef & \dots \\
    \end{rclarray}
\]
\end{defn}


\begin{defn}[Operation and valid operations]
\label{def:transaction-event}
\label{def:transactions}
Assume a set of \emph{operations tags}, a \emph{transaction operation} \( \op \in \Ops \) is a tuple of an operation tag, an address and a value.
The tuple represents either read or write of the address.
The \emph{operation tags} \( \etR \) and \( \etW \) correspond to read and write respectively.
\[
\begin{rclarray}
\OTags & \defeq & \Set{\otR, \otW} \\
\op \in \Ops & \defeq  & \OTags \times \Addr \times \Val
\end{rclarray}
\]
\emph{a well-formed set of operations}, \( \opset \in \Opsets \), is a subset of \( \Ops \) in which any two elements contain either different tags or different address.
\[
    \begin{rclarray}
        \Opsets & \defeq & \Setcon{\opset}{\opset \subseteq \Events \land \wfO{\opset} } \\
        \wfO{\opset} & \defeq & \for{\op, \op' \in \opset} \op\projection{1} \neq  \op'\projection{1} \lor \op\projection{2} \neq  \op'\projection{2}
    \end{rclarray}
\]
The unit element is \( \unitE \defeq \emptyset\) and the composition of two set of operations is only defined when the two sets contains disjointed addresses,
\[ 
\begin{rclarray}
    \opset \composeO \opset' & \defeq & 
    \begin{cases}
        \opset \uplus \opset' & \text{if } \opset\projection{2} \cap \opset'\projection{2} = \emptyset \\
        \text{undefined} & \text{otherwise}
    \end{cases}
\end{rclarray}
\]
A partial binary operation \( \addO \) adds a new operation to valid operations \( \opset \) that ensures the set contains the first read and last write.
For technical reason, if the right hand side is a special token \( \emptyop \), which represents no operation, the operations remains the same.
\[
\begin{rclarray}
    \opset \addO (\etR, \addr, \val) & \defeq & 
    \begin{cases}
        \opset \uplus \Set{(\etR, \addr, \val)} & (\stub, \addr, \stub) \notin \opset \\
        \opset &  \text{otherwise} \\
    \end{cases} \\
    \opset \addO (\etW, \addr, \val) & \defeq & \left( \opset \setminus \Set{(\etW, \addr, \stub)} \right) \uplus \Set{(\etW, \addr, \val)} \\
    \opset \addO \emptyop & \defeq & \opset \\
\end{rclarray}
\]
\end{defn}

\begin{lem}
The \( \addO \) operator preserves the well-form property.
\end{lem}

\azalea{
\label{comm:operations}
This can all be very simplified as follows. Each location is associated with a value and a set of tags in $\pset{\Set{\otR, \otW}}$, where $\emptyset$ means no finger print and the rest have the obvious meaning. 
This way you won't need the well-formedness condition or the lemma. 
%
\begin{defn}[Operations]
An \emph{operation map} \( \opset \in \Opsets \eqdef \Addr \fm \Val \times \pset{\Set{\otR, \otW}} \) is function associating each address with its tags.
The \emph{operation tags} \( \etR \) and \( \etW \) correspond to read and write respectively.

The unit element is the function with empty domain, i.e.\ $\emptyset$. 

The composition of two operation maps is defined as the standard disjoint function union: 
\[ 
\begin{rclarray}
    (\opset \composeO \opset')(a) & \defeq & 
    \begin{cases}
        \opset(a)  & \text{if } a \in \dom(\opset) \land a \not\in \dom(\opset') \\
        \opset'(a)  & \text{if } a \in \dom(\opset') \land a \not\in \dom(\opset) \\
        \text{undefined} & \text{otherwise}
    \end{cases}
\end{rclarray}
\]
%
A partial binary operation \( \addO \) updates an operation map $\opset$ with a tuple $(t, \addr, \val)$ where $t \in \Set{\etR, \etW}$ as follows:
\[
\begin{rclarray}
    \opset \addO (\etR, \addr, \val) & \defeq & 
    \begin{cases}
        \opset[\addr \mapsto (\val, \{\etR\})] & \opset(\addr) = (\val, \emptyset) \\
        \opset &  \text{otherwise} \\
    \end{cases} \\
%
%
	\opset \addO (\etW, \addr, \val) & \defeq & 
    \begin{cases}
        \opset[\addr \mapsto (\val, S \cup \{\etW\})] & \opset(\addr) = (-, S) \\
        \opset &  \text{otherwise} \\
    \end{cases} \\
%      
    \opset \addO \emptyop & \defeq & \opset \\
\end{rclarray}
\]
%
For technical reason, if the right hand side is a special token \( \emptyop \), which represents no operation, the operations remains the same.
\end{defn}
}


%We define a labelled transition system for primitive transaction commands where the labels are commands.
The operational semantics for transactions \(\trans\) is defined with respect to a configuration of the form \((\stk, \h, \opset)\) comprising a stack, a (local) heap and a set of operations.
The operations are those that might affect other transactions, meaning the first read and the last write for each address.
We first define a transition between pairs of stacks and heaps for the primitive commands \( \trans_{p}\).
We also define its operation by \( \funcn{op} \) function, which denotes the contribution of the primitive command that might observed by the external environment, \ie transactions from other threads.
The \( \funcn{op} \) extracts the read or write operation from loop-up and mutation respectively, otherwise returns \( \emptyop \).
The semantics for non-deterministic choices, sequential compositions, and loops have the expected behaviours.


\begin{defn}[Transaction operational semantics]
Given the set of stacks \( \Stacks \) (\defref{def:stacks}), heaps \( \Heaps \) (\defin\ref{def:heaps}) and transactions \( \Transactions \) (\defin\ref{def:language}), the \emph{operational semantics of transactions}, 
\[
\begin{rclarray}
\toL & : & \ThdStacks \times \\
& & \quad ((\TxStacks \times \Heaps \times \Opsets) \times \Transactions) \times ((\TxStacks \times \Heaps \times \Opsets) \times \Transactions)
\end{rclarray}
\]
is given in \fig\ref{fig:transaction_semantics}.
Note that arithmetic expression evaluation \( \evalE{\expr} \) is defined in \defref{def:language} and the \( \addO \) operators is defined in \defref{def:transactions}.
\end{defn}

\begin{figure}[!t]
\hrule\vspace{5pt}
\[
\begin{array}{@{} r c l r  c l @{}}
    (\stk, \h) & \toLTS{\passign{\var}{\expr}} & (\stk\rmto{\var}{\evalE{\expr}}, \h) & \func{op}{\stk, \h, \passign{\var}{\expr}} & \defeq & \emptyop \\
    (\stk, \h) & \toLTS{\pderef{\var}{\expr}} & (\stk\rmto{\var}{\h(\evalE{\expr})}, \h) & \func{op}{\stk, \h, \pderef{\var}{\expr}} & \defeq & (\etR, \evalE{\expr}, \h(\evalE{\expr})) \\
    (\stk, \h) & \toLTS{\pmutate{\expr_{1}}{\expr_{2}}} & (\stk, \h\rmto{\evalE{\expr_{1}}}{\evalE{\expr_{2}}}) & \func{op}{\stk, \h, \pmutate{\expr_{1}}{\expr_{2}}} & \defeq & (\etW, \evalE{\expr_{1}}, \evalE{\expr_{2}}) \\
    (\stk, \h) & \toLTS{\passume{\expr}} & (\stk, \h) \text{ where } \evalE{\expr} = 0 & \func{op}{\stk, \h, \passume{\expr}} & \defeq & \emptyop \\
    (\stk, \h) & \toLTS{\preturn{\expr}} & (\stk\rmto{\ret}{\evalE{\expr}}, \h) & \func{op}{\stk, \h, \preturn{\expr}} & \defeq & \emptyop \\
\end{array}
\]
\hrule\vspace{5pt}
\[	
    \infer[\rl{TPrimitive}]{%
        \vdash (\stk, \h, \opset) , \transpri \ \toL \  (\stk', \h', \opset \addO \op) , \pskip
    }{%
        (\stk, \h) \toLTS{\transpri} (\stk', \h')
        && \op = \func{op}{\stk, \h, \transpri}
    }
\]

\[
    \infer[\rl{TChoice}]{%
        \stk \vdash (\txstk, \h, \opset) , \trans_{1} \pchoice \trans_{2} \ \toL \  (\stk, \h, \opset) , \trans'
    }{
        \trans' \in \Set{\trans_{1}, \trans_{2}}
    }
\]

\[
    \infer[\rl{TLoop}]{%
        \stk \vdash (\txstk, \h, \opset),  \trans\prepeat \ \toL \  (\stk, \h, \opset), \pskip \pchoice (\trans \pseq \trans\prepeat)
    }{}
\]


\[
    \infer[\rl{TSeqSkip}]{%
        \stk \vdash (\txstk, \h, \opset), \pskip \pseq \trans \ \toL \  (\stk, \h, \opset), \trans
    }{%
    }
\]

\[
    \infer[\rl{TSeq}]{%
        \stk \vdash (\txstk, \h, \opset), \trans_{1} \pseq \trans_{2} \ \toL \  (\stk', \h', \opset'), \trans_{1}' \pseq \trans_{2}
    }{%
        \stk \vdash (\txstk, \h, \opset), \trans_{1} \ \toL \  (\stk', \h', \opset'), \trans_{1}'
    }
\]

\hrule\vspace{5pt}
\caption{The transaction operational semantics}
\label{fig:transaction_semantics}
\end{figure}

