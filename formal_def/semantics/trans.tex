\subsection{Programming language}

\ac{For the reason \( \Nat \) is a set while \( \mathbb{C} \)  is a instance, change it to \( \cmd \) }

\emph{A program} \( \prog \) contains fixed numbers of top level threads and there is no dynamic fork and join.
Each thread has a unique thread identifier \( \thid \in \ThreadID \) and associated \emph{commands}.
The \emph{commands}, ranged over by $\cmd$, are defined by an inductive grammar comprising the standard constructs of $\pskip$, sequential composition ($\cmd; \cmd$), non-deterministic choice ($\cmd+\cmd$) and iterations ($\cmd^*$).
To simulate conditional branching and iterations, we have primitive commands assume (\( \passume{\expr}\)) and assignment (\( \passign{\var}{\expr} \)), where \( \var \) denotes stack variable and \( \expr \) denotes arithmetic expressions which have no side effect.
Additionally, the programming language contains the \emph{transaction} construct $\ptrans{\trans}$ denoting the \emph{atomic} execution of the transaction $\trans$. 
The atomicity guarantees the execution are dictated by the underlying consistency model.
\emph{Transactions}, ranged over by $\trans$, are defined by a similar inductive grammar comprising $\pskip$, the primitive command \( \transpri \), non-deterministic choice, iteration and sequential composition.
The primitive commands include assignment (\( \passign{\var}{\expr}\)), lookup (\( \pderef{\expr}{\expr}\)), mutation (\( \pmutate{\expr}{\expr}\)) and assume (\( \passume{\expr}\)). 
Transactions do \emph{not} contain the \emph{parallel} composition construct ($\ppar$) as they are to be executed atomically.
%We assume a valid transactions codes must have the only return at the end.
%For better presentation, sometime we omit the default return zero \( \preturn{0} \).
%Transactions can only assign to their own variables, namely transaction variables (\defref{def:program_values}), but it can read from both the thread and transaction stacks.

\begin{defn}[Program values]
\label{def:program_values}
Assume a countably infinite set of \emph{addresses}, $\addr \in \Addr$. The set of \emph{program values} is $\val \in \Val \eqdef \Nat \cup \Addr$.
%where $ \nat \in \Nat$ denotes the set of natural numbers.
\end{defn}

\begin{defn}[Programming language]
\label{def:language}
A \emph{program}, $\prog \in \Programs$, is a partial finite function from thread identifiers to commands.
Assuming the set of \emph{variables} \( \var \in \Vars \), the commands \( \cmd \in \Commands \) are defined by the following grammar,
\[
    \begin{rclarray}
    \cmd & ::= &
        \pskip \mid 
        \passign{\thvar}{\expr} \mid
        \passume{\expr} \mid
        \ptrans{\trans} \mid 
        \cmd \pseq \cmd \mid 
        \cmd \pchoice \cmd \mid 
        \cmd \prepeat 
    \end{rclarray}
\]
The $\trans \in \Transactions$ in the grammar above denotes a \emph{transaction} defined by the following grammar.
%The transaction codes \( \ptrans{\trans} \) satisfy a well-form condition that there is exactly a return at the end, \ie \( \ptrans{\trans} \iff \exsts{\trans', \expr} \trans \equiv ( \trans' \pseq \preturn{\expr} )  \land \pred{noRet}{\trans'} \).
\[
    \begin{rclarray}
        \transpri & ::= &
        \pass{\txvar}{\expr} \mid
        \pderef{\txvar}{\expr} \mid
        \pmutate{\expr}{\expr} \mid
        \passume{\expr} \mid \\
        %\preturn{\expr} \\
        \trans & ::= &
        \pskip \mid
        \transpri \mid 
        \trans \pseq \trans \mid
        \trans \pchoice \trans \mid
        \trans\prepeat
    \end{rclarray}
\]
The $\expr \in \Expressions$ denotes an \emph{arithmetic expression} defined by the grammar below with $\val \in \Val$ (\defin\ref{def:program_values}),
\[
    \begin{rclarray}
        \expr & ::= &
        \val \mid
        \var \mid
        \expr + \expr \mid
        \expr \times \expr \mid
        \dots 
    \end{rclarray}
\]
\end{defn}

We write \( \cmd_{1} \ppar \cmd_{2} \ppar \dots \ppar \cmd_{n}\) as a syntactic sugar for a program \( \prog \) with implicit unique thread identifiers \( \prog = \Set{\thid_{1} \mapsto \cmd_{1}, \thid_{2} \mapsto \cmd_{2}, \dots, \thid_{n} \mapsto \cmd_{n}  }\).

\subsection{Local/Transaction Semantics}

Each thread has a local stack, where local variables are stored.
A thread can access the stack inside or outside transactions.
When a transaction starts, it determines a local heap from the current state of database and local view, which we will explain the process later.
Yet this local heap does not affect outside world, instead we use \emph{operation} to connect a transaction to outside world.
A operation could be read or write to a address with a value.
Intuitively, when a transaction is about to commit, it will have \emph{a set of operations} or \emph{operation set} containing the \emph{first read} and \emph{last write} for each address.
Note that \emph{first read} actually refers to \emph{first read before any other reads and writes}.
Because a transaction is executed atomically, all the intermediate steps are not observable from the outside world.

We introduce \emph{a well-formed operation set} \( \opset \in \Opsets\) that is a set of operations in which there are at most one read and one write for each address.
The composition, then, is defined as set disjointed union as long as the result is well-formed.
To help us write down the semantics, we define a binary operator \( \opset \addO \op \) that specifies the effects of adding a new operation \( \op \) to the set \( \opset \).
If the new operation is a read, for example \((\otR, \addr, \val)\) where \( \addr \) is the address and \( \val\) is the associated value, and there is no other operation related to the same address, this new read operation will be included in the result.
Meanwhile, if the new operation is a write, it will overwrite all preview write operations to the same address.

\sx{Design choice, total stack vs partial stack, we pick partial here but make sure it is consistent through the document.}

\begin{defn}[Stacks]
\label{def:stacks}
A \emph{stack} is a partial finite function from variables \( \Vars \) (\defref{def:language}) to program values \( \Val \) (\defref{def:program_values}): \( \stk \in \Stacks \defeq \Vars \parfinfun \Val \).
\end{defn}

%{ \color{gray}
%\begin{defn}[Stacks]
%Given the program values (\defref{def:program_values}) and a set of \emph{transaction variables} \( \TxVars \defeq \Set{\txvar, \dots}\), a \emph{transaction stack} is a partial function from transaction variables to values \( \txstk \in \TxStacks \defeq \TxVars \parfun \Val \).
%Similarly, assuming a set of \emph{thread variables} \( \ThdVars \defeq \Set{\thvar, \dots}\), a \emph{thread stack} is defined as \( \thstk \in \ThdStacks \defeq \ThdVars \parfun \Val \).
%Then, the set of \emph{stacks} is defined as the union of transaction stacks and thread stacks \( \stk \in \Stacks \eqdef \TxStacks \uplus \ThdStacks \).
%\end{defn}
%}

\ac{Key-value stores vs Heaps}

\begin{defn}[Heaps]
\label{def:heaps}
Given the sets of program values $\Val$  and addresses \( \Addr\)  (\defin\ref{def:program_values}), the set of \emph{heaps} is: $\h \in \Heaps \eqdef \Addr \parfinfun \Val$.
The \emph{heap composition function}, $\composeH: \Heaps \times \Heaps \parfun \Heaps$, is defined as $\composeH \eqdef \uplus$, where $\uplus$ denotes the standard disjoint function union. The \emph{ heap unit element} is $\unitH \eqdef \emptyset$, denoting a function with an empty domain.
The \emph{partial commutative monoid of  heaps} is $(\Heaps, \composeH, \{\unitH\})$.
\end{defn}

\begin{defn}[Evaluation of expression]
Given a stack $\stk \in \Stacks$ (\defin\ref{def:stacks}), the \emph{arithmetic expression evaluation} function, $\evalE[(.)]{.}:\Expressions \times \Stacks \parfun \Val$, is defined inductively over the structure of expressions as follows: 
%
\[
    \begin{rclarray}
        \evalE{\val} & \defeq & \val \\
        \evalE{\var} & \defeq & \stk(\var) \\
        \evalE{\expr_{1} + \expr_{2}} & \defeq & \evalE{\expr_{1}} + \evalE{\expr_{2}} \\
        \evalE{\expr_{1} \times \expr_{2}} & \defeq & \evalE{\expr_{1}} \times \evalE{\expr_{2}} \\
        \dots & \eqdef & \dots \\
    \end{rclarray}
\]
\end{defn}

\emph{A operation} is either a read \( (\etR, \addr, \val)\) or write \( (\etW, \addr, \val) \), where the \( \addr \) is the address and \( \val \) is the value.
In the \( \defref{def:ops} \), the \( (.)\projection{(.)} \) denotes projection.
For a tuple, for example \( \op\projection{i} \), it gives the \emph{i-th} element of the tuple.
It is lifted to a set of tuples, for example \( \opset\projection{i}\), which gives a set of all the \emph{i-th} elements.

\begin{defn}[Operation and operation set]
\label{def:ops}
A \emph{transaction operation} \( \op \in \Ops \) is a tuple of \emph{an operation tag} containing either read or write, an address and a value.
\[
\begin{rclarray}
\OTags & \defeq & \Set{\otR, \otW} \\
\op \in \Ops & \defeq  & \OTags \times \Addr \times \Val
\end{rclarray}
\]
\emph{A well-formed operation set}, \( \opset \in \Opsets \), is a subset of \( \Ops \) in which any two elements contain either different tags or different address.
\[
    \begin{rclarray}
        \Opsets & \defeq & \Setcon{\opset}{\opset \subseteq \Events \land \wfO{\opset} } \\
        \wfO{\opset} & \defeq & \fora{\op, \op' \in \opset} \op\projection{1} \neq  \op'\projection{1} \lor \op\projection{2} \neq  \op'\projection{2}
    \end{rclarray}
\]
The unit element is \( \unitE \defeq \emptyset\) and the composition of two set of operations is the disjointed union when the two sets contain disjointed addresses,
\[ 
\begin{rclarray}
    \opset \composeO \opset' & \defeq & 
    \begin{cases}
        \opset \uplus \opset' & \text{if } \opset\projection{2} \cap \opset'\projection{2} = \emptyset \\
        \text{undefined} & \text{otherwise}
    \end{cases}
\end{rclarray}
\]
A partial binary operation \( \addO \) adds a new operation to operation set \( \opset \) that ensures the set contains the first read and last write.
For technical reasons, if the right hand side is a special token \( \emptyop \), which represents no operation, the operations remains the same.
\[
\begin{rclarray}
    \opset \addO (\etR, \addr, \val) & \defeq & 
    \begin{cases}
        \opset \uplus \Set{(\etR, \addr, \val)} & (\stub, \addr, \stub) \notin \opset \\
        \opset &  \text{otherwise} \\
    \end{cases} \\
    \opset \addO (\etW, \addr, \val) & \defeq & \left( \opset \setminus \Set{(\etW, \addr, \stub)} \right) \uplus \Set{(\etW, \addr, \val)} \\
    \opset \addO \emptyop & \defeq & \opset \\
\end{rclarray}
\]
\end{defn}
\pg{ \(\opset \addO \opset'\)?. \sx{We can define this but not sure it is useful}}

\begin{lem}
The \( \addO \) operator preserves the well-formedness property.
\end{lem}


\azalea{
\label{comm:operations}
\sx{ After discussion with Andrea and Philippa, we think it is better to keep as a SET structure, as we can have a future extension by having more things in the set, for example tokens for fence, or tokens for a transaction should be serialisable under SI.
}
This can all be very simplified as follows. Each location is associated with a value and a set of tags in $\pset{\Set{\otR, \otW}}$, where $\emptyset$ means no finger print and the rest have the obvious meaning. 
This way you won't need the well-formedness condition or the lemma. 

\begin{defn}[Operations]
\label{def:transaction-event}
\label{def:transactions}
\label{def:ops-map}
An \emph{operation map} \( \opset \in \Opsets \eqdef \Addr \parfinfun \Val \times \Val \times \pset{\Set{\otR, \otW}} \) is function associating each address with its tags.
The \emph{operation tags} \( \etR \) and \( \etW \) correspond to read and write respectively.
The first value corresponds to the read and the second to the write.

The unit element is the function with empty domain, i.e.\ $\emptyset$. 

The composition of two operation maps is defined as the standard disjoint function union: 
\[ 
\begin{rclarray}
    (\opset \composeO \opset')(a) & \defeq & 
    \begin{cases}
        \opset(a)  & \text{if } a \in \dom(\opset) \land a \not\in \dom(\opset') \\
        \opset'(a)  & \text{if } a \in \dom(\opset') \land a \not\in \dom(\opset) \\
        \text{undefined} & \text{otherwise}
    \end{cases}
\end{rclarray}
\]
%
A partial binary operation \( \addO \) updates an operation map $\opset$ with a tuple $(t, \addr, \val)$ where $t \in \Set{\etR, \etW}$ as follows:
\[
\begin{rclarray}
    \opset \addO (\etR, \addr, \val) & \defeq & 
    \begin{cases}
        \opset[\addr \mapsto (\val, \val, \{\etR\})] & \opset(\addr) = (\val, \val, \emptyset) \\
        \opset &  \text{otherwise} \\
    \end{cases} \\
%
%
	\opset \addO (\etW, \addr, \val) & \defeq & 
    \begin{cases}
        \opset[\addr \mapsto (\val', \val, S \cup \{\etW\})] & \opset(\addr) = (\val', \val'', S) \\
        \opset &  \text{otherwise} \\
    \end{cases} \\
%      
    \opset \addO \emptyop & \defeq & \opset \\
\end{rclarray}
\]
%
For technical reason, if the right hand side is a special token \( \emptyop \), which represents no operation, the operation map remains the same.
\end{defn}
}

\sx{Re-assemble some words from Andrea}

%We define a labelled transition system for primitive transaction commands where the labels are commands.
The operational semantics for transactions \(\trans\) is defined with respect to a configuration of the form \((\stk, \h, \opset)\) comprising a stack, a heap and a operation set.
The operation set includes those that might affect other transactions, meaning the first read and the last write for each address.
We first define a state transformers between pairs of stacks and heaps for the primitive commands \(\trans_{p}\).
We also define its operation by \( \funcn{op} \) function, which denotes the contribution of the primitive command that might observed by the external environment, \ie transactions from other threads.
The \( \funcn{op} \) extracts the read or write operation from loop-up and mutation respectively, otherwise \( \emptyop \).
The semantics for primitive command updates the stack and heap by the transformers relation and updates the operation set by extracting the operation and adding it via \( \addO \) operator (\defref{def:ops}).
The semantics for non-deterministic choices, sequential compositions, and loops have the expected behaviours.


\begin{defn}[Transaction operational semantics]
Given the set of stacks \( \Stacks \) (\defref{def:stacks}), heaps \( \Heaps \) (\defin\ref{def:heaps}) and transactions \( \Transactions \) (\defin\ref{def:language}), the \emph{operational semantics of transactions}, 
\[
\begin{rclarray}
\toL & : & ((\Stacks \times \Heaps \times \Opsets) \times \Transactions) \times ((\Stacks \times \Heaps \times \Opsets) \times \Transactions)
\end{rclarray}
\]
is given in \fig\ref{fig:transaction_semantics}.
\end{defn}

\begin{figure}[!t]
\hrule\vspace{5pt}
\sx{design choice: assume zero or non-zero? }
\[
\begin{array}{@{} r c l r  c l @{}}
    (\stk, \h) & \toLTS{\passign{\var}{\expr}} & (\stk\rmto{\var}{\evalE{\expr}}, \h) & \func{fp}{\stk, \h, \passign{\var}{\expr}} & \defeq & \emptyop \\
    (\stk, \h) & \toLTS{\pderef{\var}{\expr}} & (\stk\rmto{\var}{\h(\evalE{\expr})}, \h) & \func{fp}{\stk, \h, \pderef{\var}{\expr}} & \defeq & (\etR, \evalE{\expr}, \h(\evalE{\expr})) \\
    (\stk, \h) & \toLTS{\pmutate{\expr_{1}}{\expr_{2}}} & (\stk, \h\rmto{\evalE{\expr_{1}}}{\evalE{\expr_{2}}}) & \func{fp}{\stk, \h, \pmutate{\expr_{1}}{\expr_{2}}} & \defeq & (\etW, \evalE{\expr_{1}}, \evalE{\expr_{2}}) \\
    (\stk, \h) & \toLTS{\passume{\expr}} & (\stk, \h) \text{ where } \evalE{\expr} = 0 & \func{fp}{\stk, \h, \passume{\expr}} & \defeq & \emptyop \\
    %(\stk, \h) & \toLTS{\preturn{\expr}} & (\stk\rmto{\ret}{\evalE{\expr}}, \h) & \func{fp}{\stk, \h, \preturn{\expr}} & \defeq & \emptyop \\
\end{array}
\]
\hrule\vspace{5pt}
\[	
    \infer[\rl{TPrimitive}]{%
        (\stk, \h, \opset) , \transpri \ \toL \  (\stk', \h', \opset \addO \op) , \pskip
    }{%
        (\stk, \h) \toLTS{\transpri} (\stk', \h')
        && \op = \func{fp}{\stk, \h, \transpri}
    }
\]

\[
    \infer[\rl{TChoice}]{%
        (\stk, \h, \opset) , \trans_{1} \pchoice \trans_{2} \ \toL \  (\stk, \h, \opset) , \trans_{i}
    }{
        i \in \Set{1,2}
    }
\]

\[
    \infer[\rl{TIter}]{%
        (\stk, \h, \opset),  \trans\prepeat \ \toL \  (\stk, \h, \opset), \pskip \pchoice (\trans \pseq \trans\prepeat)
    }{}
\]


\[
    \infer[\rl{TSeqSkip}]{%
        (\stk, \h, \opset), \pskip \pseq \trans \ \toL \  (\stk, \h, \opset), \trans
    }{%
    }
\]

\[
    \infer[\rl{TSeq}]{%
        (\stk, \h, \opset), \trans_{1} \pseq \trans_{2} \ \toL \  (\stk', \h', \opset'), \trans_{1}' \pseq \trans_{2}
    }{%
        (\stk, \h, \opset), \trans_{1} \ \toL \  (\stk', \h', \opset'), \trans_{1}'
    }
\]

Note that arithmetic expression evaluation \( \evalE{\expr} \) is defined in \defref{def:language} and the \( \addO \) operator is defined in \defref{def:transactions}.

\hrule\vspace{5pt}
\caption{The operational semantics for transactions}
\label{fig:transaction_semantics}
\end{figure}

