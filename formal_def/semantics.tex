\section{semantics\label{sec:semantics}}
\begin{definition}[Program values]\label{def:prgram_values}
Assume a countably infinite set of \emph{locations}, $\loc \in \Loc$, and a countably infinite set of \emph{program variables} $\vx \in {\Var}$. The set of \emph{program values} is $\val \in \Val \eqdef \Nat \cup \Loc$, where $\Nat$ denotes the set of natural numbers.
\end{definition}
%
%
\begin{definition}[Stacks]\label{def:stacks}
Given the set of program variables $\Var$ and the set of program values $\Val$ (\defin\ref{def:prgram_values}), the set of variable stacks is $\stk \in \Stack \eqdef \Var \parfinfun \Val$.
\end{definition}
%
%
Our programs (ranged over by $\prog$) are defined by an inductive grammar comprising the standard constructs of $\pskip$, sequential composition ($\prog; \prog$), non-deterministic choice ($\prog+\prog$), loops ($\prog^*$) and parallel composition ($\prog \ppar \prog$). Additionally, our programming language contains the \emph{transaction} construct $\ptrans{\cmd}$ denoting the \emph{atomic} execution of the transaction $\cmd$. The atomicity guarantees of this execution are dictated by the underlying consistency model (snapshot isolation in this case).
Transactions (ranged over by $\cmd$) are defined by a similar inductive grammar comprising $\pskip$, non-deterministic choice, loops and sequential composition, as well as constructs for assignment, lookup and update. Transactions do \emph{not} contain the \emph{parallel} composition construct ($\ppar$) as they are to be executed atomically.

\begin{definition}[Programming language]
The set of \emph{programs}, $\prog \in \Programs$, is defined by the following grammar:
\[
    \begin{syntax}{\prog}
              \pskip \quad        |
        \quad \ptrans{\cmd} \quad |
        \quad \prog ; \prog \quad |
        \quad \prog + \prog \quad |
        \quad \prog^{*} \quad     |
        \quad \prog \ppar \prog 
    \end{syntax}
\]
%
The $\cmd \in \Transactions$ in the grammar above denotes a \emph{transaction} defined by the following grammar:
%
\[
    \begin{syntax}{\cmd}
              \pskip \quad                 |
        \quad \pass{\vx}{\expr} \quad      |
        \quad \pmutate{\expr}{\expr} \quad |
        \quad \pderef{\vx}{\expr} \quad    |
        \quad \cmd + \cmd \quad            |
        \quad \cmd^{*} \quad               |
        \quad \cmd ; \cmd
    \end{syntax}
\]
%
where $\expr \in \Expressions$ denotes an \emph{arithmetic expression} defined by the grammar below with $\val \in \Val$ and $\vx \in \Var$ (\defin\ref{def:prgram_values}).
%
\[
    \begin{syntax}{\expr}
              \val \quad          |
        \quad \var \quad          |
        \quad \expr + \expr \quad |
        \quad \expr * \expr \quad |
        \quad \dots 
    \end{syntax}
\]
%
Given a stack $\stk \in \Stack$ (\defin\ref{def:stacks}), the \emph{expression evaluation} function, $\eval{.}_{(.)}:\Expressions \times \Stack \rightharpoonup \Val$, is defined inductively over the structure of expressions as follows: 
%
\[
    \begin{rclarray}
        \eval{\val}_{\stk} & \defeq & \val \\
        \eval{\var}_{\stk} & \defeq & \stk(\val) \\
        \eval{\expr_{1} + \expr_{2}}_{\stk} & \defeq & \eval{\expr_{1}}_{\stk} + \eval{\expr_{2}}_{\stk}   \\
        \eval{\expr_{1} * \expr_{2}}_{\stk} & \defeq & \eval{\expr_{1}}_{\stk} * \eval{\expr_{2}}_{\stk}  
    \end{rclarray}
\]
%
\end{definition}
%

We model the database state as a \emph{timestamp heap}. A timestamp heap is a partial function from locations to \emph{histories}.
A history is a partial function from timestamps to a set of \emph{events}.
An event is a triple comprising the value read or written, the identifier of the transaction carrying out the event, and an \emph{event tag} denoting a \emph{start event} ($\ops$), an \emph{end} event ($\ope$), a \emph{read} event ($\opr$) or a \emph{write} event ($\opw$).
We model our timestamps, $\ts \in \Timestamp$, as elements of an (uncountably) infinite set with a total order relation $<$. To ensure the availability of an appropriate timestamp, we assume that the timestamp set $\Timestamp$ is \emph{dense}. That is, given any two timestamps $\ts_1$ and $\ts_2$ such that $\ts_1 < \ts_2$, an intermediate timestamp $\ts$ can be found such that $\ts_1 < \ts < \ts_2$.

\begin{definition}[Timestamp heaps]\label{def:timestamp_heaps}
Assume a set of \emph{timestamps}, $\ts \in \Timestamp$. Assume a \emph{total order} relation on timestamps, $<\ : \Timestamp \times \Timestamp$, such that:
%
\[
	\for{\ts_1, \ts_2 \in \Timestamp} \ts_1 < \ts_2 \lor \ts_2 < \ts_1
\]
%
Assume that the timestamp set $\Timestamp$ is \emph{dense} with respect to the ordering relation $<$. That is,
\[
	\for{\ts_1, \ts_2} \ts_1 < \ts_2 
	\Rightarrow 
	\exsts{\ts} \ts_1 < \ts < \ts_2	
\]
%
The set of \emph{event tags} is: $\op \in \Operation \eqdef \{\ops, \ope, \opr, \opw \}$. 

\noindent Assume a countably infinite set of \emph{transaction identifiers} $\alpha, \beta \in \TransID$.
Given the set of program values $\Val$ (\defin\ref{def:prgram_values}), the set of \emph{timestamp heaps} is defined as $\tshp \in \Timestampheap \eqdef \Loc \parfinfun (\Val \times \TransID \times \Operation)$.
\end{definition}

We use thread pools to model the concurrency.
A thread pool is modelled as a finite partial map from thread identifiers to triples of the form $(\stk, \ts, \prog)$. That is, each thread is associated with a stack $\stk$,a timestamp $\ts$ and a program $\prog$ to be executed. 

\begin{definition}[Thread pools]
Assume a countably infinite set of thread identifiers $i,j \in \ThreadID$.
Given the sets of stacks $\Stack$ (\defin\ref{def:stacks}) and the set of timestamps $\Timestamp$ (\ref{def:timestamp_heaps}), the set of \emph{thread pools} is: $\tdpl \in \Threadpool \eqdef \ThreadID \parfinfun \Stack \times \Timestamp \times \Programs$.
\end{definition}
%
%
Therefore a thread pool is a partial functions from thread identifiers to the corresponding stack, time and transactions.
The state of each transaction, i.e.\ local state, are a stack which is shared between transactions from the same thread, a heap that is a  snapshot of the time-stamp heap, and fingerprints that are the heap locations being read and written.


%
\[
    \begin{rclarray}
%        \loc \in \Loc & \defeq & \Nat \\
%        \val \in \Val & \defeq & \Nat \cup \Loc \\
%        \Var & \defeq & \Set{ \vx, \vy, \dots } \\
%        \ts \in \Timestamp & \defeq & \texttt{rational number or real number} \\
%        \hp \in \Heap & \defeq & \Loc \parfinfun \Val \\
%        \stk \in \Stack & \defeq & \Var \parfinfun \Val \\
%        \op \in \Operation & \defeq & \Set{\opr, \opw, \ops, \ope} \\
%        \settrans \subseteq \TransID & \defeq & \Set{ \alpha , \beta, \dots } \\
%        \ThreadID & \defeq & \Set{ i , j, \dots } \\
        \rs \in \Readset, \ws \in \Writeset & \defeq & \powerset{\Loc} \\
        %\tshp \in \Timestampheap & \defeq & \Loc \parfun ( \Timestamp \parfun \powerset{\Val \times \Operation \times \TransID}) \\
%        \tshp \in \Timestampheap & \defeq & \Loc \parfinfun ( \Timestamp \parfun ( \Val \times \Operation \times \TransID ) ) \\
        (\stk, \tshp, \ts) \in \Threadstate & \defeq & \Stack \times \Timestampheap \times \Timestamp \\
%        \tdpl \in \Threadpool & \defeq & \ThreadID \parfun \Stack \times \Timestamp \times \prog \\
        \stt \in \State & \defeq & \Timestampheap \times \Threadpool \\
        \lstt = (\stk, \hp, \rs, \ws ) \in \Localstate & \defeq & \Stack \times \Heap \times \Readset \times \Writeset \\
    \end{rclarray}
\]

%The arithmetic expression and boolean expression are standard and have no side effect.
%
%
%
%
%
%\[
%    \begin{syntax}{\bool}
%              \true \quad                |
%        \quad \false \quad               |
%        \quad \expr = \expr \quad        |
%        \quad \expr < \expr \quad        |
%        \quad \boolnot \bool \quad       |
%        \quad \bool \booland \bool \quad |
%        \quad \bool \boolor \bool \quad  |
%        \quad \dots 
%    \end{syntax}
%\]
%
%\[
%    \begin{rclarray}
%        \eval{\true}_{\stk}& \defeq & \true \\
%        \eval{\false}_{\stk} & \defeq & \false \\
%        \eval{\expr_{1} = \expr_{2}}_{\stk} & \defeq & \eval{\expr_{1}}_{\stk} = \eval{\expr_{2}}_{\stk}   \\
%        \eval{\expr_{1} < \expr_{2}}_{\stk} & \defeq & \eval{\expr_{1}}_{\stk} < \eval{\expr_{2}}_{\stk}   \\
%        \eval{\boolnot \bool}_{\stk} & \defeq & \neg \eval{\bool}_{\stk} \\
%        \eval{\bool_{1} \booland \bool_{2}}_{\stk} & \defeq & \eval{\bool_{1}}_{\stk} \land \eval{\bool_{2}}_{\stk}  \\
%        \eval{\bool_{1} \boolor \bool_{2}}_{\stk}& \defeq & \eval{\bool_{1}}_{\stk} \lor \eval{\bool_{2}}_{\stk}  
%    \end{rclarray}
%\]
%
%\[
%    \begin{syntax}{\cmd}
%              \pskip \quad                 |
%        \quad \pass{\vx}{\expr} \quad      |
%        \quad \pmutate{\expr}{\expr} \quad |
%        \quad \pderef{\vx}{\expr} \quad    |
%        \quad \cmd + \cmd \quad            |
%        \quad \cmd^{*} \quad               |
%        \quad \cmd ; \cmd
%    \end{syntax}
%\]

The syntax and semantics of a single transaction are standard except \rl{Mutate} and \rl{Seref}.
The \rl{Mutate} also adds the location being written to the write fingerprint set \( \ws \) and the \rl{Deref} adds the location to \( \rs \).
Note that there is no parallel composition, because it is within a transaction.

\[
    \begin{rclarray}
        ( \dontcare, \dontcare ) \ \localtransfer \  ( \dontcare, \dontcare ) & \defeq &  ( \Localstate \times \cmd ) \times ( \Localstate \times \cmd ) \\
    \end{rclarray}
\]

\[
    \infer[\rl{TAss}]{%
        ( \stk, \hp, \rs, \ws ) , \pass{\var}{\expr} \ \localtransfer \  ( \stk \remapsto{\var}{\val}, \hp, \rs, \ws ) , \pskip
    }{%
    \eval{\expr}_{\stk} = \val
    }
\]

\[
    \infer[\rl{TMutate}]{%
        ( \stk, \hp, \rs, \ws ) , \pmutate{\expr_{1}}{\expr_{2}} \ \localtransfer \  ( \stk, \hp \remapsto{\loc}{\val}, \rs, \ws \cup \Set{\loc} ) , \pskip
    }{%
        \eval{\expr_{1}}_{\stk} = \loc \quad 
        \eval{\expr_{2}}_{\stk} = \val \quad 
        \loc \in \dom(\hp)
    }
\]

\[
    \infer[\rl{TSeref}]{%
        ( \stk, \hp, \rs, \ws ) , \pderef{\var}{\expr} \ \localtransfer \  ( \stk \remapsto{\var}{\val}, \hp, \rs \cup \Set{\loc}, \ws ) , \pskip
    }{%
        \eval{\expr}_{\stk} = \loc \quad 
        \val = \hp(\loc) \quad
        \loc \in \dom(\hp)
    }
\]

\[
    \infer[\rl{TChoiseLeft}]{%
        ( \stk, \hp, \rs, \ws ) , \cmd_{1} + \cmd_{2} \ \localtransfer \  ( \stk, \hp, \rs, \ws ) , \cmd_{1}
    }{%
    }
\]

\[
    \infer[\rl{TChoiseRight}]{%
        ( \stk, \hp, \rs, \ws ) , \cmd_{1} + \cmd_{2} \ \localtransfer \  ( \stk, \hp, \rs, \ws ) , \cmd_{2}
    }{%
    }
\]

\[
    \infer[\rl{TLoop}]{%
        ( \stk, \hp, \rs, \ws ) ,  \cmd^{*} \ \localtransfer \  ( \stk, \hp, \rs, \ws ) , \pskip + (\cmd ; \cmd^{*})
    }{%
    }
\]

\[
    \infer[\rl{TSeqSkip}]{%
        ( \stk, \hp, \rs, \ws ) , \pskip ; \cmd_{2} \ \localtransfer \  ( \stk, \hp, \rs, \ws ) , \cmd_{2}
    }{%
    }
\]

\[
    \infer[\rl{TSeq}]{%
        ( \stk, \hp, \rs, \ws ) , \cmd_{1} ; \cmd_{2} \ \localtransfer \  ( \stk', \hp', \rs', \ws' ) , \cmd_{1}' ; \cmd_{2}
    }{%
        ( \stk, \hp, \rs, \ws ) , \cmd_{1} \ \localtransfer \  ( \stk', \hp', \rs', \ws' ) , \cmd_{1}'
    }
\]

A program is sequential and parallel composition of transactions.
To give semantics for a program, we extend the syntax by adding an extra waiting command, \( \pwait{\thid} \), as suffix.
Intuitively, this \( \pwait{\thid} \) indicates that current thread is waiting another thread identified by \( \thid \) until it commits all its transactions and then join the thread.

\[
    \begin{syntax}{\prog}
              \pskip \quad        |
        \quad \ptrans{\cmd} \quad |
        \quad \prog ; \prog \quad |
        \quad \prog + \prog \quad |
        \quad \prog^{*} \quad     |
        \quad \prog \ppar \prog 
    \end{syntax}
\]

\[
    \begin{syntax}{\progext}
              \prog \quad                        |
        \quad \progext ; \pwait{\thid} \quad |
    \end{syntax}
\]

We will explain the \rl{Commit}, \rl{Par} and \rl{Wait}, and the rest are straightforward.
We give label to each transition, and these labels are only usefully for parallel composition.

The \rl{Commit} rule says that a transaction prophesies a starting time when this transaction takes a snapshot \( \hp_{s} \) and runs locally, and an ending time when it successfully commits ensured by the \texttt{allowcommit}.

The \rl{Par} rule forks a new thread and appends a \( \pwait{\thid} \), parametrised by the new thread identifier \( \thid \), at the merging point.
The \rl{Wait} rule waits the thread \( \thid \) until it finishes, then joins the thread and updates the time to the maximum between the two threads.
Note that these two rules are labelled with \( \lfork{\thid, \prog} \) or \( \ljoin{\thid, \ts} \) which are used by the semantics of a top level theadpool.

\[
    \begin{rclarray}
        \tll \in \Translabel & \defeq & 
              \lid \quad                |
        \quad \lcmt{\tsid} \quad        |
        \quad \lfork{\thid,\prog} \quad |
        \quad \ljoin{\thid,\ts} \\
        ( \dontcare, \dontcare ) \ \threadtransfer{ \dontcare } \ ( \dontcare, \dontcare ) & \defeq &  ( \Threadstate \times \progext ) \times \Translabel \times  ( \Threadstate \times \progext )  \\
    \end{rclarray}
\]

\[
    \begin{rclarray}
        \func{startstate}{\tshp,\ts} & \defeq & \lambda \loc \ldotp \val \\
                                     & & \texttt{where} \ \exists \ts' \leq \ts \ldotp \tshp(\loc)(\ts') = (\val,\wop, \dontcare) \land \forall \ts'' \in ( \ts', \ts) \ldotp \tshp(\loc)(\ts'') = (\dontcare,\rop,\dontcare) \\
        \pred{allowcommit}{\tshp,\ws,\rs,\ts_{s},\ts_{e}} & \defeq & 
        \pred{wellformhist}{\tshp,\ws,\rs,\ts_{s},\ts_{e}} \land \pred{consistent}{\tshp,\ws,\rs,\ts_{s},\ts_{e}} \\
        \pred{wellformhist}{\tshp,\ws,\rs,\ts_{s},\ts_{e}} & \defeq  & \forall \ts \in \Set{\ts_{s},\ts_{e}}, \loc \in \ws \cup \rs \ldotp \tshp(\loc)(\ts)\undef \\
        \pred{consistent}{\tshp,\ws,\rs,\ts_{s},\ts_{e}} & \defeq & \forall \loc_{w} \in \ws , \ts \in (\ts_{s},\ts_{e}) \ldotp \tshp(\loc_{w})(\ts) \neq (\dontcare, \wop, \dontcare) \land {} \\
                                                         & & \forall \tsid \ldotp \nexists \ts_{\tsid s} < \ts_{e}, \ts_{\tsid e} > \ts_{e} \ldotp \tshp(\loc_{w})(\ts_{\tsid s}) = (\dontcare, \dontcare, \tsid) \land \tshp(\loc_{w})(\ts_{\tsid e}) = (\dontcare, \wop, \tsid) \land {} \\
                                                         & & \exists \ts_{min} = \min(\Set{\ts'' \ \middle| \ \ts'' > \ts_{e} \land \tshp(\loc_{w})(\ts'')\isdef}) \ldotp  \tshp(\loc_{w})(\ts_{min}) \neq (\dontcare, \rop, \dontcare) \\
        \func{commitTrans}{\tshp,\hp_{s},\hp_{e},\ws,\rs, \tsid, \ts_{s},\ts_{e}} & \defeq &
        \lambda \loc \ldotp
        \begin{funcarray}
            \tshp(\loc)\remapsto{\ts_{s}}{(\hp_{s}(\loc),\sop,\tsid)}\remapsto{\ts_{e}}{(\hp_{e}(\loc),\wop,\tsid)} & \loc \in \ws \setminus \rs \\
            \tshp(\loc)\remapsto{\ts_{s}}{(\hp_{s}(\loc),\rop,\tsid)}\remapsto{\ts_{e}}{(\hp_{e}(\loc),\eop,\tsid)} & \loc \in \rs \setminus \ws \\
            \tshp(\loc)\remapsto{\ts_{s}}{(\hp_{s}(\loc),\rop,\tsid)}\remapsto{\ts_{e}}{(\hp_{e}(\loc),\wop,\tsid)} & \loc \in \rs \cap \ws \\
            \tshp(\loc) & o.w. \\
        \end{funcarray} \\
        \pred{fresh}{\tshp, \tsid}  & \defeq & \neg\exists \loc, \ts, \val, \op.\ \tshp(\loc)(\ts) {=} (\val, \op, \tsid)
%        \tid \ \texttt{where} \ \tsid \notin \Set{\tsid' \ \middle| \ (\dontcare,\dontcare,\tsid') \in \bigcup\limits_{\loc,\ts}\tshp(\loc)(\ts)} \\
    \end{rclarray}
\]

\[
    \infer[\rl{Commit}]{%
        ( \stk, \tshp, \ts ) , \ptrans{\cmd} \ \threadtransfer{\lcmt{\tsid}} \ ( \stk', \tshp', \ts_{e} ) , \pskip
    }{%
        \begin{array}{c}
            \ts_{s} \geq \ts
            \quad \ts_{e} > \ts_{s} 
            \quad \hp_{s} = \func{startstate}{\tshp, \ts_{s}}
            \quad ( \stk, \hp_{s}, \emptyset, \emptyset ) , \cmd \localtransfer^{*} ( \stk', \hp_{e}, \rs, \ws ) , \pskip \\
            \pred{allowcommit}{\tshp,\ws,\rs,\ts_{s},\ts_{e}} 
            \quad \pred{fresh}{\tshp, \tsid}
            \quad \tshp' = \func{commitTrans}{\tshp,\hp_{s},\hp_{e},\ws,\rs,\tsid,\ts_{s},\ts_{e}}
        \end{array}
    }
\]

\[
    \infer[\rl{PChoiseLeft}]{%
        ( \stk, \tshp, \ts ) , \prog_{1} + \prog_{2} \ \threadtransfer{\lid} \  ( \stk, \tshp, \ts ) , \prog_{1}
    }{%
    }
\]

\[
    \infer[\rl{PChoiseRight}]{%
        ( \stk, \tshp, \ts ) , \prog_{1} + \prog_{2} \ \threadtransfer{\lid} \  ( \stk, \tshp, \ts ) , \prog_{2}
    }{%
    }
\]

\[
    \infer[\rl{PLoopSkip}]{%
        ( \stk, \tshp, \ts ) , \prog^{*} \ \threadtransfer{\lid} \ ( \stk, \tshp, \ts ) , \pskip
    }{%
    }
\]

\[
    \infer[\rl{PLoop}]{%
        ( \stk, \tshp, \ts ) , \prog^{*} \ \threadtransfer{\lid} \  ( \stk, \tshp, \ts ) , \pskip + (\prog ; \prog^{*})
    }{%
    }
\]

\[
    \infer[\rl{PSeqSkip}]{%
        ( \stk, \tshp, \ts ) , \pskip ; \progext \ \threadtransfer{\lid} \  ( \stk, \tshp, \ts ) , \progext
    }{%
    }
\]

\[
    \infer[\rl{PSeq}]{%
        ( \stk, \tshp, \ts ) , \progext_{1} ; \progext_{2} \ \threadtransfer{\tll} \ ( \stk', \tshp', \ts' ) , {\progext_{1}}' ; \progext_{2}
    }{%
        ( \stk, \tshp, \ts ) , \progext_{1} \ \threadtransfer{\tll} \  ( \stk', \tshp', \ts' ) , {\progext_{1}}' 
    }
\]

\[
    \infer[\rl{PPar}]{%
        ( \stk, \tshp, \ts ) , \prog_{1} \ppar \prog_{2} \ \threadtransfer{\lfork{\thid, \prog_{2}}} \  ( \stk, \tshp, \ts ) , \prog_{1} ; \pwait{\thid}
    }{%
    }
\]

\[
    \infer[\rl{PWait}]{%
        ( \stk, \tshp, \ts ) , \pwait{\thid} \ \threadtransfer{\ljoin{\thid,\ts'}} \  ( \stk, \tshp , \max\Set{\ts,\ts'} ) , \pskip 
    }{%
    }
\]

\[
    \begin{rclarray}
        \dontcare \ \globaltransfer{\dontcare} \ \dontcare & \defeq & \State \times \Translabel \times \State  \\
    \end{rclarray}
\]

The semantics of theadpool picks a thread to run one step.
If the step is a fork, it generates a new thread with a new stack and a local time that is the same as its parent thread.
If it is a join, the threadpool passes the child's local time to its parent thread.

\[
    \infer[\rl{PSingle}]{%
        ( \tshp, \tdpl \uplus \Set{ \thid \mapsto (\stk, \ts, \progext) } ) \ \globaltransfer{\tll} \  ( \tshp', \tdpl \uplus \Set{ \thid \mapsto (\stk', \ts', {\progext}') } ) 
    }{%
        ( \stk, \tshp, \ts ) , \progext \ \threadtransfer{\tll} \  ( \stk', \tshp', \ts' ) , {\progext}' 
        \quad \tll \in \Set{ \lid, \lcmt{\dontcare} }
    }
\]

\[
    \infer[\rl{PFork}]{%
        ( \tshp, \tdpl \uplus \Set{ \thid \mapsto (\stk, \ts, \progext) } ) \ \globaltransfer{\lfork{\thid', \prog''}} \  ( \tshp', \tdpl \uplus \Set{ \thid \mapsto (\stk', \ts', {\progext}'), \thid' \mapsto (\lambda \var \ldotp 0, \ts', \prog'') } )
    }{%
        ( \stk, \tshp, \ts ) , \progext \ \threadtransfer{\lfork{\thid', \prog''}} \  ( \stk', \tshp', \ts' ) , {\progext}' 
    }
\]

\[
    \infer[\rl{PJoin}]{%
        ( \tshp, \tdpl \uplus \Set{ \thid \mapsto (\stk, \ts, \progext), \thid' \mapsto (\stk', \ts'', \pskip) } )  \ \globaltransfer{\ljoin{\thid',\ts''}} \ ( \tshp', \tdpl \uplus \Set{ \thid \mapsto (\stk', \ts', {\progext}')} )
    }{%
        ( \stk, \tshp, \ts ) , \progext \ \threadtransfer{\ljoin{\thid',\ts''}} \  ( \stk', \tshp', \ts' ) , {\progext}' 
    }
\]

