\section{Semantics\label{sec:semantics}}
\begin{defn}[Program values]
\label{def:prgram_values}
Assume a countably infinite set of \emph{addresses}, $\addr \in \Addr$. The set of \emph{program values} is $\val \in \Val \eqdef \Nat \cup \Addr$, where $\Nat$ denotes the set of natural numbers.
\end{defn}
 
\begin{defn}[Stacks]
\label{def:stacks}
Assume a set of \emph{transaction variables} \( \TxVars \defeq \Set{\txvar, \dots}\), the set of \emph{transaction stacks} is \( \txstk \in \TxStacks \defeq \TxVars \parfun \Val \).
Assume a set of \emph{thread variables} \( \ThdVars \defeq \Set{\thvar, \dots}\), the set of \emph{thread stacks} is \( \thstk \in \ThdStacks \defeq \ThdVars \parfun \Val \).
We also define the set of stacks as \( \stk \in \Stacks \eqdef \TxStacks \uplus \ThdStacks \).
\end{defn}

\begin{definition}[Heaps]
\label{def:heaps}
Given the sets of program values $\Val$ (\defin\ref{def:prgram_values}) and  addresses $\Addr$ (\defin\ref{def:timestamp_heaps}), the set of \emph{ heaps} is: $\h \in \Heaps \eqdef \Addr \parfinfun \Val$.
The \emph{heap composition function}, $\composeH: \Heaps \times \Heaps \parfun \Heaps$, is defined as $\composeH \eqdef \uplus$, where $\uplus$ denotes the standard disjoint function union. The \emph{ heap unit element} is $\unitH \eqdef \emptyset$, denoting a function with an empty domain.
The \emph{partial commutative monoid of  heaps} is $(\Heaps, \composeH, \{\unitH\})$.
\end{definition}

Our programs (ranged over by $\prog$) are defined by an inductive grammar comprising the standard constructs of $\pskip$, sequential composition ($\prog; \prog$), non-deterministic choice ($\prog+\prog$), loops ($\prog^*$) and  parallel composition ($\prog \ppar \prog$).
To simulate branching and conditional loop, we also have assume (\( \passume{\expr}\)) and assignment to thread variables (\( \passign{\thvar}{\expr} \)), where \( \expr \) denotes arithmetic expressions.
Additionally, our programming language contains the \emph{transaction} construct $\ptrans{\trans}$ denoting the \emph{atomic} execution of the transaction $\trans$. 
The atomicity guarantees the execution are dictated by the underlying consistency model.
Transactions (ranged over by $\trans$) are defined by a similar inductive grammar comprising $\pskip$, non-deterministic choice, loops and sequential composition, as well as constructs for assignment, lookup and update. 
Transactions do \emph{not} contain the \emph{parallel} composition construct ($\ppar$) as they are to be executed atomically.
Transactions can only assign to their own variables, namely transaction variables ranged over by \( \txvar \), but it can read from the thread and transaction stack.

\begin{defn}[Programming language]
\label{def:language}
Given the set of thread variables \( \thvar \in \ThdVars \) (\defref{def:stacks}), the set of \emph{programs}, $\prog \in \Programs$, is defined by the following grammar:
\[
    \begin{rclarray}
    \prog & ::= &
        \pskip \mid 
        \passign{\thvar}{\expr} \mid
        \passume{\expr} \mid
        \ptrans{\trans} \mid 
        \prog \pseq \prog \mid 
        \prog \pchoice \prog \mid 
        \prog\prepeat \mid
        \prog \ppar \prog 
    \end{rclarray}
\]
Given the set of thread variables \( \txvar \in \TxVars \) (\defref{def:stacks}), the $\trans \in \Transactions$ in the grammar above denotes a \emph{transaction} defined by the following grammar,
\[
    \begin{rclarray}
        \trans & ::= &
        \pskip \mid
        \pass{\txvar}{\expr} \mid
        \pmutate{\expr}{\expr} \mid
        \pderef{\txvar}{\expr} \mid
        \passume{\expr} \mid
        \preturn{\expr} \mid
        \trans \pseq \trans \mid
        \trans \pchoice \trans \mid
        \trans\prepeat
    \end{rclarray}
\]
%
where $\expr \in \Expressions$ denotes an \emph{arithmetic expression} defined by the grammar below with $\val \in \Val$, $\thvar \in \ThdVars$ and \( \txvar \in \TxVars \) (\defin\ref{def:prgram_values}).
%\ac{\defin\ref{def:program_values} only introduces the set \Val, not \TxVars nor \ThdVars.}
%
\[
    \begin{rclarray}
        \expr & ::= &
        \val \mid
        \thvar \mid
        \txvar \mid
        \expr + \expr \mid
        \expr * \expr \mid
        \dots 
    \end{rclarray}
\]
%
Given a thread stack \( \thstk \in \ThdStacks  \) a transaction stack \( \txstk \in \TxStacks \) and  a stack $\stk \in \Stacks$ (\defin\ref{def:stacks}), the \emph{expression evaluation} function, $\evalE[(.)]{.}:\Expressions \times \Stacks \parfun \Val$, is defined inductively over the structure of expressions as follows: 
%
\[
    \begin{rclarray}
        \evalE{\val} & \defeq & \val \\
        \evalE[\thstk \uplus \txstk]{\thvar} & \defeq & \thstk(\thvar) \\
        \evalE[\thstk \uplus \txstk]{\txvar} & \defeq & \txstk(\txvar) \\
        \evalE{\expr_{1} + \expr_{2}} & \defeq & \evalE{\expr_{1}} + \evalE{\expr_{2}} \\
        \evalE{\expr_{1} * \expr_{2}} & \defeq & \evalE{\expr_{1}} * \evalE{\expr_{2}} \\
        \dots & \eqdef & \dots \\
    \end{rclarray}
\]
\end{defn}

\subsection{Local/Transaction Semantics}

We define the operational semantics of transactions $\trans$ with respect to a configuration of the form $(\txstk, \h, \evset)$ comprising a transaction stack, a (local) heap and a set of events that might affect other transactions.

\begin{defn}[Transactions and transaction events]
\label{def:transaction-event}
\label{def:transactions}
Assume a set of transactions identifiers \( \TxID \defeq \Set{\txid, \dots}\).
The set of transaction events \( \Events \) is defined as the follows,
\[
\begin{rclarray}
\ETags & \defeq & \Set{\etR, \etW} \\
\ev \in \evset \subseteq \Events & \defeq  & \ETags \times \Addr \times \Val
\end{rclarray}
\]
The event tags \( \etR \) and \( \etW \) correspond to read and write respectively.
Given a set of events and a new read or write event, the \emph{flush read} \( \flushR \) and \emph{flush write} \(\flushW \) are defined as the follows, 
\[
\begin{rclarray}
    \evset \flushR (\etR, \addr, \val) & \defeq & 
    \begin{cases}
        \evset \uplus \Set{(\etR, \addr, \val)} & (\etR, \addr, \stub) \notin \evset \land (\etW, \addr, \stub) \notin \evset  \\
        \evset &  \text{otherwise} \\
    \end{cases} \\
    \evset \flushW (\etW, \addr, \val) & \defeq & ( \evset \setminus \Set{(\etW, \addr, \stub)} ) \uplus \Set{(\etW, \addr, \val)} \\
\end{rclarray}
\]
The flush read includes the new read event if there is no other read or write event.
The flush write always deletes other write events from the event set and includes the new one.

The transactions are defined as a finite partial function from transactions identifiers \( \TxID \) to a set of events \( \powerset{\Events} \),
\[
\begin{rclarray}
\tx \in \Tx & \defeq & \TxID \parfinfun \powerset{\Events}
\end{rclarray}
\]
\end{defn}


\begin{defn}[Transaction operational semantics]
Given the sets of stacks including thread stacks \( \ThdStacks \) and transaction stacks \( \TxStacks \) (\defin\ref{def:stacks}), heaps \( \Heaps \) (\defin\ref{def:heaps}) and transactions \( \Transactions \) (\defin\ref{def:language}), the \emph{operational semantics of transactions}, 
\[
\begin{rclarray}
\toL & : & \ThdStacks \times \\
& & \quad ((\TxStacks \times \Heaps \times \powerset{\Events}) \times \Transactions) \times ((\TxStacks \times \Heaps \times \powerset{\Events}) \times \Transactions)
\end{rclarray}
\], 
is given in \fig\ref{fig:transaction_semantics}.
Note that the evaluation of arithmetic expression \( \evalE[\thstk \uplus \txstk]{\expr} \) is defined in \defref{def:language} and the flush read \( \flushR \) and flush write \( \flushW \) operator are defined in \defref{def:transactions}.
\end{defn}

\begin{figure}[!t]
\hrule\vspace{5pt}
\[	
    \infer[\rl{TAss}]{%
        \thstk \vdash (\txstk, \h, \evset) , \pass{\txvar}{\expr} \ \toL \  (\txstk \remapsto{\txvar}{\val}, \h, \evset) , \pskip
    }{%
        \evalE[\thstk \uplus \txstk]{\expr} = \val
        && \txvar \in \dom(\txstk)
    }
\]

\[
    \infer[\rl{TWrite}]{%
        \thstk \vdash (\txstk, \h, \evset), \pmutate{\expr_{1}}{\expr_{2}} \ \toL \  (\txstk, \h \remapsto{\addr}{\val}, \evset \flushW (\etW, \addr, \val)) , \pskip
    }{%
        \evalE[\thstk \uplus \txstk]{\expr_{1}} = \addr 
        && \evalE[\thstk \uplus \txstk]{\expr_{2}} = \val 
    }
\]

\[
    \infer[\rl{TRead}]{
        \thstk \vdash (\txstk, \h, \evset) , \pderef{\txvar}{\expr} \ \toL \  (\txstk\remapsto{\txvar}{\val}, \h, \evset \flushR (\etR, \addr, \val)), \pskip
    }{
        \evalE[\thstk \uplus \txstk]{\expr} = \addr
        && \h(\addr) = \val 
    }
\]

\[
    \infer[\rl{TAssume}]{%
        \thstk \vdash (\txstk, \h, \evset), \passume{\expr} \ \toL \  (\txstk, \h, \evset), \pskip
    }{%
        \evalE[\thstk \uplus \txstk]{\expr} = 0
    }
\]

\[
    \infer[\rl{TReturn}]{%
        \thstk \vdash (\txstk, \h, \evset), \preturn{\expr} \ \toL \  (\txstk\rmto{\ret}{\val}, \h, \evset), \pskip
    }{ 
        \val = \evalE[\thstk \uplus \txstk]{\expr}
    }
\]

\[
    \infer[\rl{TChoise}]{%
        \thstk \vdash (\txstk, \h, \evset) , \trans_{1} \pchoice \trans_{2} \ \toL \  (\txstk, \h, \evset) , \trans'
    }{
        \trans' \in \Set{\trans_{1}, \trans_{2}}
    }
\]

\[
    \infer[\rl{TLoop}]{%
        \thstk \vdash (\txstk, \h, \evset),  \trans\prepeat \ \toL \  (\txstk, \h, \evset), \pskip \pchoice (\trans \pseq \trans\prepeat)
    }{}
\]


\[
    \infer[\rl{TSeqSkip}]{%
        \thstk \vdash (\txstk, \h, \evset), \pskip \pseq \trans \ \toL \  (\txstk, \h, \evset), \trans
    }{%
    }
\]

\[
    \infer[\rl{TSeq}]{%
        \thstk \vdash (\txstk, \h, \evset), \trans_{1} \pseq \trans_{2} \ \toL \  (\txstk', \h', \evset'), \trans_{1}' ; \trans_{2}
    }{%
        \thstk \vdash (\txstk, \h, \evset), \trans_{1} \ \toL \  (\txstk', \h', \evset'), \trans_{1}'
    }
\]

\hrule\vspace{5pt}
\caption{The transaction operational semantics}
\label{fig:transaction_semantics}
\end{figure}

Instead of heap, we use abstract executions to model the machine states.
The abstract execution is a graph that each node represents a committed transaction identified by a unique transaction identifier, and the note contains the events that have global affect, \ie first reads and last writes.
There are three types of edges in the graph, program order that is a total order for transactions from the same thread, visibility relations that decides the observable history (a set of transactions) of each transaction, and arbitration order that decides the actual global states \cite{eventually-consistent-transactions,Burckhardt:2014:RDT:2535838.2535848,cerone_et_al:LIPIcs:2015:5375}.

\begin{defn}[Runtime abstract executions and abstract executions]
\label{def:run-abs-exec}
\label{def:abs-exec}
An runtime abstract execution is a tuple \( \aexecrun = (\tx, \setthid, \porun, \vis, \ar) \in \Aexecrun \) that satisfies the follows,
\begin{itemize}
\item
The transactions \( \tx \) is a partial function from a set of transaction identifiers to their corresponding events (\defref{def:transactions}).
\item 
The \emph{runtime threads} \( \setthid \) is a set of transaction identifiers, \ie \( \setthid \subseteq \ThreadID \).
\item 
The \emph{arbitration order} $\ar \subseteq \dom(\tx) \times \dom(\tx)$ is a strict, total order%
\footnote{Recall that a relation $R \subseteq A \times A$ is a strict partial order if it is irreflexive and transitive.
It is a strict total order if for any $a_1, a_2 \in A$, either $a_1 = a_2$, $(a_1, a_2) \in R$ or $(a_2, a_1) \in R$.}.
\item 
The \emph{runtime program order} $\porun \subseteq \dom(\tx) \times ( \dom(\tx) \uplus \setthid )$ is the union of disjoint, strict total orders \( \porun_{i} \).
That is, there exists a partition $\Set{ \dom(\tx)_{i} }_{i \in I}$ of $\dom(\tx)$ such that $\porun = \bigcup_{i \in I} \porun_{i}$, where $\porun_{i}$ is a strict, total order.
It also requires \( \po \subseteq \ar\).
\item 
The \emph{visibility relation} $\vis \subseteq \dom(\tx) \times \dom(\tx)$ is a relation such that \( \vis \subseteq \ar \).
\end{itemize} The set of abstract executions $\aexec  = (\tx, \po, \vis, \ar) \in \Aexecs$ is by erasing the runtime threads from the runtime abstract executions \( \Aexecrun \),
\[
\begin{rclarray}
    \Aexecs & \defeq & \Setcon{\eraseAEX{\aexecrun}}{\aexecrun \in \Aexecrun} \\
\end{rclarray} 
\]
where the function  \( \eraseAEX{.}: \Aexecrun \to \Aexecs \) converts a runtime abstract execution to an abstract execution by erasing all the thread identifiers,
\[
    \begin{rclarray}
        \eraseAEX{(\tx, \setthid, \hat{\po}, \vis, \ar)} & \defeq & (\tx, \hat{\po} \setminus \Setcon{(\txid, \thid)}{ \txid \in \dom(\tx) \land \thid \in \setthid}, \vis, \ar)
    \end{rclarray}
\]
Given two runtime abstract executions \( \aexecrun_{1} \) and \( \aexecrun_{2} \), the order between them is defined as point-wise set inclusion,
\[
\begin{rclarray}
\aexecrun_{1} \ordAEXRUN \aexecrun_{2} & \iffdef & 
    \begin{array}[t]{@{}l@{}}
        ( \for{\txid} \aexecrun_{1}\projection{\tx}(\txid) \implies \aexecrun_{2}\projection{\tx}(\txid) )  
        \land \aexecrun_{1}\projection{\setthid} \subseteq  \aexecrun_{2}\projection{\setthid}  \\
        {} \quad \land \aexecrun_{1}\projection{\porun} \subseteq  \aexecrun_{2}\projection{\porun} 
        \land \aexecrun_{1}\projection{\vis} \subseteq  \aexecrun_{2}\projection{\vis} 
        \land \aexecrun_{1}\projection{\ar} \subseteq  \aexecrun_{2}\projection{\ar} 
    \end{array}
\end{rclarray}
\]
Then by erasing the runtime, the order between two abstract executions is defined as the follows,
\[
\begin{rclarray}
\aexec_{1} \ordAEX \aexec_{2} & \iffdef & 
    \exsts{\aexecrun_{1}, \aexecrun_{2}} \aexec_{1} = \eraseAEX{\aexecrun_{1}}
    \land \aexec_{2} = \eraseAEX{\aexecrun_{2}}
    \land \aexecrun_{1} \ordAEXRUN \aexecrun_{2}
\end{rclarray}
\]
\end{defn}

We parametrise the consistency models in our semantics.
A consistency model contains two parts, a resolution policy and a consistency guarantee.
Given a abstract execution \( \aexec \), a set of observable transactions \( \txidset \) and an address \( \addr \), the resolution policy \( \respo(\aexec, \txidset, \addr) \) decides the observable values for the address \( \addr \).
A common resolution policy is \emph{last-write-win} that if a transaction observes several writes for the same address, it always reads the last write (by the arbitration order).
The consistency guarantee gives the minimum constraint for the visibility relation.


\begin{defn}[Consistency Models]
\label{def:consistency-models}
\emph{Consistency models} are define a set of of tuple, \( \como = (\respo, \conguar) \in \Como\), including \emph{resolution policies} and \emph{consistency guarantees}.
A \emph{resolution policy} \( \respo \) is a function,
\[
\begin{rclarray}
    \ResPos & \defeq & 
    \Setcon{%
        \respo
     }{%
        \respo \in \Aexecs \times \powerset{\TxID} \times \Addr \to \powerset{\Val}\\
        \quad {} \land \for{\aexec, \txidset, \addr } \respo(\aexec, \txidset, \addr)\isdef \implies \txidset \subseteq \dom(\aexec\projection{\tx})
    }
\end{rclarray}
\]
A \emph{consistency guarantee} \( \conguar \) is a function such that,
\[ 
\begin{rclarray}
\ConGuar & \defeq & 
\Setcon{%
        \conguar
    }{%
        \conguar \in \Aexecs \to \powerset{\TransID \times \TransID}
        \land \for{\aexec} \\
        \quad \conguar(\aexec) \subseteq \aexec\projection{\ar}
        \land \for{\txid, \txid'} (\txid, \txid') \in \conguar(\aexec) 
        \land \txid,\txid'  \in \dom(\aexec\projection{\tx})
        
    }
\end{rclarray}
\]
The order \( \ordCOM \)  between two consistency model \( \como_{1}, \como_{2} \) is defined as the follows,
\[
\begin{rclarray}
    (\respo_{1}, \conguar_{1}) \ordCOM (\respo_{2}, \conguar_{2}) & \iffdef & 
    \begin{array}[t]{@{}l@{}}
    \for{\aexec, \txidset, \addr} \\
    \quad \respo_{2}(\aexec, \txidset, \addr) \subseteq \respo_{1}(\aexecrun, \txidset, \addr) \land \conguar_{1}(\aexec) \subseteq  \conguar_{2}(\aexec)
    \end{array} \\
\end{rclarray}
\]
The bottom element is \( \btmCOM \defeq (\lambda (\aexec, \txidset, \addr ) \ldotp \Val, \lambda (\aexec) \ldotp \emptyset) \).
\end{defn}

\begin{example}[Last write win]
\[
\begin{rclarray}
        \respo_{LWW}(\aexec, \txidset, \addr) & \defeq & 
        \Setcon{\val}{%
            \exsts{\ar = \aexec\projection{\ar}}
            \Set{(\etW, \addr, \val)} = \max_{\ar}\Setcon{\txid}{\txid \in \txidset \land (\etW, \addr, \stub) \in \tx(\txid) } \\
            \quad {} \lor \emptyset = \max_{\ar}\Setcon{\txid}{\txid \in \txidset \land (\etW, \addr, \stub) \in \tx(\txid) } \land v = 0
        }\\
\end{rclarray}
\]
\end{example}

\begin{example}[Write-write conflict]
\[
\begin{rclarray}
        \conguar_{WW}(\aexec) & \defeq & \Setcon{(\txid, \txid')}{ \exsts{ \addr } (\etW, \addr, \stub) \in \aexec\projection{\tx}(\txid) \land (\etW, \addr, \stub) \in \aexec\projection{\tx}(\txid') \land (\txid, \txid') \in \aexec\projection{\ar} } \\
\end{rclarray}
\]
\end{example}

Given two sets of relations \( A \) and \( B \), the notation \( A ; B \) denotes that \( A;B \defeq \Setcon{(a,b)}{(a,c) \in A \land (c,b) \in B} \).

\begin{example}[Serialisibility(SER)]
\[
    \begin{rclarray}                                   
        \respo_{SER} & \defeq & \respo_{LWW} \\
        \conguar_{SER}(\aexec) & \defeq & \aexec\projection{\ar} \\
    \end{rclarray}                                                      
\]
\end{example}
%\ac{Why $\como_{SER}$ and not $\respo_{SER}?$ Also, the resolution policy is the last write wins, which you need to define only once.}

\begin{example}[Snapshot isolation(SI)]
\[
    \begin{rclarray}                                   
        \respo_{SI} & \defeq & \respo_{LWW} \\
        \conguar_{SI}(\aexec) & \defeq & ( \aexec\projection{\ar} ; \aexec\projection{\vis} )  \cup \conguar_{WW}(\aexec) \\
    \end{rclarray}
\]
\end{example}
%\ac{Why not just say that $\conguar_{SI}(\aexec) = \aexec\projection{\vis} ; \aexec\projection{\ar}$? Also, you are missing 
%write conflict detection ($\conguar_{\mathsf{WWconf}} = \bigcup_{\addr \in \Addr} [\mathsf{Write}_\addr] ; \aexec\projection{\ar} ; [\mathsf{Write}_\addr]$.}

\begin{example}[Parallel snapshot isolation(PSI)]
\[
    \begin{rclarray}                                   
        \respo_{PSI} & \defeq & \respo_{LWW} \\
        \conguar_{PSI}(\aexec) & \defeq & ( \aexec\projection{\vis} ; \aexec\projection{\vis} ) \cup \conguar_{WW}(\aexec) \\
    \end{rclarray}
\]
\end{example}

\begin{defn}[Thread transition labels]
\label{def:label}
Assume a countably infinite set of thread identifiers $\ThreadID \defeq \Set{\thid, j, \dots} $.
The set of \emph{thread transition labels}, $\lb \in \Translabel$, is defined by the following grammar, where $\prog$ denotes a program (\defref{def:language}), the $\txid$ demotes a transaction identifier and $\thstk$ denotes a thread stack (\defref{def:stacks}),
\[
    \begin{rclarray}
	\iota \in \Translabel & ::= & \lbID \mid \lbC{\txid} \mid \lbF{\thid,\prog} \mid \lbJ{\thid,\thstk}
    \end{rclarray}
\]
\end{defn}


\begin{defn}[Thread semantics]
\label{def:thread_semantics}
Given the thread identifiers $\thid,j \in \ThreadID$.
The set of \emph{intermediate programs}, $\iprog \in \IntermediatePrograms$, is defined by the following grammar:
%
\[
    \iprog ::= \prog \mid \iprog \pseq \pwait{\thid}
\]
%
Given the set of thread stacks \( \stk \in \Stacks (\defref{def:stacks}) \) and runtime abstract executions (\defref{def:run-abs-exec}), the \emph{per-thread operational semantics} of programs:
%
\[
\begin{rclarray}
	\toT{} & : &
    \begin{array}[t]{@{}l@{}}
    \Como \times \ThreadID 
    \times \\
	\quad \left( ( \ThdStacks \times \Aexecrun ) \times \IntermediatePrograms \right) 
	\times  \Translabel \times
	\left( ( \ThdStacks \times \Aexecrun ) \times \IntermediatePrograms \right) 
    \end{array}
\end{rclarray}
\]
%
is defined in \fig\ref{fig:thread_semantics}.
\end{defn}

The \rl{PCommit} rule ``substitute'' the dummy node for the thread \( \thid \) in the runtime abstract execution \( \aexecrun \) with a newly concrete transaction \( \txid \) with its associated events \( \evset \).
To obtain the set of events \( \evset \), it prophesies a set of observable transactions \( \txidset \), which will turn into visibility relations later.
Given the observable transactions, the \( \obsstateName \) function computes a possible initial heap, by applying the resolution policy \( \respo \) for each address
Note that if the resolution policy returns more than one value, it will non-deterministically pick a value for each address to form the initial heap.
With the initial heap \( \h \) and the transaction code \( \trans \), by the transaction semantics (\figref{fig:transaction_semantics}), we get the events set \( \evset \).
To extend the runtime abstract execution, it replaces the dummy node \( \thid \) with the new transaction \( \txid \), links all the observable transactions \( \txidset \) to the new transition, and puts the new transaction at the end of arbitration order.
It also alters the program order by adding back the dummy node \( \thid \) after the transition \( \txid \) for preserving program order for the future transactions from the same thread.

The \rl{Par} rule forks a new thread and inserts the appropriate joining point by appending the auxiliary \( \pwait{\thid'} \) operation, where $\thid'$ denotes the identifier of the newly forked thread.
The \rl{Wait} rule dually awaits the termination of thread $\thid'$ and subsequently updates its thread stack.
Note that these two rules are labelled with the $\lbF{\thid, \prog}$ and $\lbJ{\thid, \thstk}$ which are used by the semantics of the thread pool described shortly.

\begin{figure}
%
\hrule
%
\[
    \infer[\rl{PCommit}]{%
        (\respo, \conguar), \thid \vdash ( \thstk, \aexecrun ), \ptrans{\trans} \ \toT{\lbC{\txid}} \ ( \thstk\rmto{\ret}{\txstk(\ret)}, \aexecrun' ) , \pskip
    }{%
        \begin{array}{c}
            \pred{fresh}{\aexecrun, \txid}
            %\quad \txidset \in \addpotvis{\aexecrun, \thid}
            \quad \txidset \subseteq \dom(\aexecrun\projection{\tx})
            \quad \h \in \obsstate{\aexecrun, \txidset, \respo} \\
            %\quad \fph = \lambda \addr \ldotp  (\respo(\eraseAEX{\aexecrun}, \txidset , \addr), \emptyset) \\
            \thstk \vdash (\emptyset, \h, \emptyset) , \trans \ \toL^{*} \  (\txstk, \h', \evset) , \pskip 
            %\quad \evset = \getevent{\fph, \fph'}
            \quad \aexecrun' = \newaexec{\aexecrun, \thid, \evset, \txid, A, \conguar }
        \end{array}
    }
\]

%\ac{I believe that $\addpotvis{}$ is obsolete; why not just take a subset of $\aexec\projection{\mathcal{T}}$?}
%\ac{Same for $\obsstate{}$: what about $\lambda \addr.(\respo(\eraseAEX{\aexecrun}, A , \addr), \emptyset)$? - 
%this requires changing the last write win policy so that at least one value is always returned by $(\respo(\eraseAEX{\aexecrun}, A, \addr)$.}

\[
    \infer[\rl{PAssign}]{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \passign{\thvar}{\expr} \ \toT{\lbID} \  ( \thstk\rmto{\thvar}{\val}, \aexecrun  ) , \pskip
    }{
        \val = \evalE[\thstk]{\expr}
    }
\]

\[
    \infer[\rl{PIncTime}]{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \passume{\expr} \ \toT{\lbID} \  ( \thstk, \aexecrun ) , \pskip
    }{%
        \evalE[\thstk]{\expr} = 0
    }
\]

\[
    \infer[\rl{PChoise}]{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \prog_{1} \pchoice \prog_{2} \ \toT{\lbID} \  ( \thstk, \aexecrun ) , \prog'
    }{
        \prog' \in \Set{\prog_{1}, \prog_{2}}
    }
\]

\[
    \infer[\rl{PLoop}]{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \prog\prepeat \ \toT{\lbID} \  ( \thstk, \aexecrun ) , \pskip \pchoice (\prog \pseq \prog\prepeat)
    }{}
\]

\[
    \infer[\rl{PSeqSkip}]{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \pskip \pseq \iprog \ \toT{\lbID} \  ( \thstk, \aexecrun ) , \iprog
    }{}
\]

\[
    \infer[\rl{PSeq}]{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \iprog_{1} \pseq \iprog_{2} \ \toT{\lb} \ ( \thstk', \aexecrun' ) , {\iprog_{1}}' \pseq \iprog_{2}
    }{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \iprog_{1} \ \toT{\lb} \  ( \thstk', \aexecrun' ) , {\iprog_{1}}' 
    }
\]

\[
    \infer[\rl{PPar}]{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \prog_{1} \ppar \prog_{2} \ \toT{\lbF{\thid', \prog_{2}}} \  ( \thstk, \aexecrun' ) , \prog_{1} \pseq \pwait{\thid'}
    }{
        \aexecrun' = \func{extend\_thread}{\aexecrun, \thid, \thid'}
    }
\]

\[
    \infer[\rl{PWait}]{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \pwait{\thid'} \ \toT{\lbJ{\thid', \thstk'}} \  (  \thstk_{1} \uplus \thstk_{2} \uplus \thstk_{f}, \aexecrun' ) , \pskip 
    }{
        \thstk = \thstk_{1} \uplus \thstk_{f}
        && \thstk' = \thstk_{2} \uplus \thstk_{f}
        && \aexecrun = \func{erase\_thread}{\aexecrun', \thid'}
    }
\]

\sx{The stack could be polluted by the child thread. }
 
where,
\[
\begin{rclarray}                                 
    %\addpotvisName{} & : & \Aexecrun \times \ThreadID \parfun \powerset{\powerset{\TxID}} \\
    %\addpotvis{\aexecrun, \thid} & \defeq  &  
    %\begin{cases}
        %\powerset{\dom(\aexecrun\projection{\tx})} & \thid \in \aexecrun\projection{\setthid} \\
        %\text{undefined} & \text{otherwise} \\
    %\end{cases} \\
%
%
    \consis{\aexecrun, \thid, \txid, \conguar} & \defeq & 
    \begin{array}[t]{@{}l@{}}
        \thid \in \aexecrun\projection{\setthid} \land  \for{ \txid' } ( (\txid', \txid) \in \conguar(\eraseAEX{\aexecrun}) \implies (\txid, \txid) \in \aexecrun\projection{\vis} ) \\
    \end{array} \\
    \newaexecName & : & 
    \left(\begin{array}{l}
        \Aexecrun \times \ThreadID \times \TxID \times \\
        \quad  \powerset{\Events} \times \powerset{\TxID} \times \ConGuar \end{array} \right)
        \parfun \Aexecrun \\
    \newaexec{\aexecrun, \thid, \txid, \evset, \txidset, \conguar } & \defeq & 
    \begin{cases}
        \aexecrun' & \consis{\aexecrun', \thid, \txid, \conguar} \\
        \text{undefined} & \text{otherwise} \\
    \end{cases} \\
    \text{where} \ \aexecrun' & \equiv & 
        \left(
        \begin{array}{@{}l@{}}
            \aexecrun\projection{\tx} \uplus \Set{\txid \mapsto \evset},
            \aexecrun\projection{\setthid}, 
            \aexecrun\projection{\hat{\po}} \uplus \Setcon{(\txid', \txid)}{(\txid', \thid) \in \aexecrun\projection{\hat{\po}}} \uplus \Set{(\txid, \thid)}, \\
            \quad \aexecrun\projection{\vis} \uplus \Setcon{(\txid', \txid)}{\txid' \in \txidset}, 
            \aexecrun\projection{\ar} \uplus \Setcon{(\txid', \txid)}{\txid' \in \dom(\aexecrun\projection{\tx})}
        \end{array}
        \right) \\
%	
%
    \obsstateName & : & \Aexecrun \times \powerset{\TxID} \times \ResPos \parfun \powerset{\FPHeaps} \\
    \obsstate{\aexecrun, \txidset, \respo} & \defeq & 
    \Setcon{%
        \h
    }{%            
        \for{\addr, \val}  \val \in \respo(\eraseAEX{\aexecrun}, \txidset, \addr) \iff \h(\addr) = \val \\
    } \\
%
%              
	\pred{fresh}{\aexecrun, \txid}  & \defeq & \neg \txid \in \dom(\aexecrun\projection{\tx}) \\
%
%
    %\geteventName & : & \FPHeaps \times \FPHeaps \to \powerset{\Events} \\
    %\getevent{\fph, \fph'} & \defeq & 
    %\begin{array}[t]{@{}l@{}}
        %\Setcon{ (\etW, \addr, \val ) }{ \exsts{ \fp } \fph(\addr) = ( \val, \fp ) \land \fpW \in \fp} \\
        %\quad {} \uplus \Setcon{ (\etR, \addr, \val ) }{ \exsts{ \fp } \fph(\addr) = (\val, \stub) \land \fph(\addr) = ( \stub, \fp ) \land \fpR \in \fp} \\ 
    %\end{array} \\
%
%
    \func{extend\_thread}{\aexecrun, \thid, \thid'} & \defeq & (\aexecrun\projection{\tx}, \aexecrun\projection{\setthid} \uplus \Set{\thid'}, \aexecrun\projection{\hat{\po}} \uplus \Setcon{(\txid, \thid')}{ (\txid, \thid) \in \aexecrun\projection{\hat{\po}}}, \aexecrun\projection{\vis}, \aexecrun\projection{\ar}) \\
    \func{erase\_thread}{\aexecrun, \thid} & \defeq & (\aexecrun\projection{\tx}, \aexecrun\projection{\setthid} \setminus \Set{\thid}, \aexecrun\projection{\hat{\po}} \setminus \Setcon{(\txid, \thid)}{ \txid \in \dom(\aexecrun\projection{\tx})}, \aexecrun\projection{\vis}, \aexecrun\projection{\ar})                                                                                                                                                                                                                   
    \end{rclarray}
\]
\hrule
\caption{Per-thread operational semantics}
\label{fig:thread_semantics}
\end{figure}

In order to model concurrency, we use thread pools.
A thread pool is modelled as a finite partial map from thread identifiers to triples of the form $(\thstk, \iprog)$. That is, each thread is associated with a thread stack $\thstk$ and a  intermediate program $\iprog$ to be executed. 

\begin{defn}[Thread pools]
\label{def:thread_pools}
Given the sets of stacks $\Stacks$ (\defref{def:stacks}) and programs $\Programs$ (\defref{def:language}), the set of \emph{thread pools} is: $\thpl \in \TPool \eqdef \ThreadID \parfinfun \ThdStacks \times \IntermediatePrograms$.
\end{defn}
 
\begin{defn}[Thread pool semantics] 
\label{def:thread_pool_semantics}
Given the sets of timestamp heaps $\TSHeaps$ (\defin\ref{def:timestamp_heaps}), transition labels \( \Translabel \) (\defin\ref{def:label}) and thread pools $\TPool$ (\defin\ref{def:thread_pools}), the \emph{thread pool semantics}, 
%
\[
	\toG{} : \Como \times (\Aexecrun \times \TPool) \times \Translabel \times (\Aexecrun \times \TPool) 
\]
%
is defined in \fig\ref{fig:thread_pool_semantics}.
%
\end{defn}
%
The thread pool operational semantics is given in \fig\ref{fig:thread_pool_semantics}, where an arbitrary thread in the pool $\thpl$ is picked to run for one step.
If the next execution step is a thread fork, then a new thread $\thid$ is allocated in the pool to be executed with its stack copied from those of the parent (forking) thread.
Conversely, when the next execution step is the joining of thread $\thid'$, then $\thid'$ is removed from the thread pool and the stack from the thread being joined merges into the parent thread.
%
\begin{figure}
\hrule\vspace{5pt}
%
\[
    \infer[\rl{PSingle}]{%
        \como \vdash ( \aexecrun, \thpl \uplus \Set{ \thid \mapsto (\thstk, \iprog) } ) \ \toG{\lb} \  ( \aexecrun, \thpl \uplus \Set{ \thid \mapsto (\thstk', {\iprog}') } ) 
    }{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \iprog \ \toT{\lb} \  ( \thstk', \aexecrun ' ) , {\iprog}' 
        \quad \lb \in \Set{ \lbID, \lbC{\stub} }
    }
\]

\[
    \infer[\rl{PFork}]{%
        \como \vdash ( \aexecrun, \thpl \uplus \Set{ \thid \mapsto (\thstk, \iprog) } ) \ \toG{\lbF{\thid', \prog}} \  ( \aexecrun', \thpl \uplus \Set{ \thid \mapsto (\thstk', {\iprog}'), \thid' \mapsto (\thstk', \prog) } )
    }{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \iprog \ \toT{\lbF{\thid', \prog}} \  ( \thstk', \aexecrun' ) , {\iprog}' 
    }
\]

\[
    \infer[\rl{PJoin}]{%
        \como \vdash ( \aexecrun, \thpl \uplus \Set{ \thid \mapsto (\thstk, \iprog), \thid' \mapsto (\thstk', \pskip) } )  \ \toG{\lbJ{\thid',\thstk''}} \ ( \aexecrun', \thpl \uplus \Set{ \thid \mapsto (\thstk'', {\iprog}')} )
    }{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \iprog \ \toT{\lbJ{\thid',\thstk'}} \  ( \thstk'', \aexecrun' ) , {\iprog}' 
    }
\]
%
\hrule\vspace{5pt}
\caption{Thread pool semantics}
\label{fig:thread_pool_semantics}
\end{figure}

\subsection{Soundness and Completeness}

\begin{defn}[Valid abstract executions]
\label{def:valid-aexec}
Given a consistency model \( (\respo, \conguar) = \como \in \Como \), the set of all the valid abstract executions under the model is defined as the follows,
\[
    \begin{rclarray}
        \evalCOM{(\respo, \conguar)} & \defeq & 
        \Setcon{%
            \aexec = (\tx, \po, \vis, \ar)
        }{%
            \conguar(\aexec) \subseteq \vis 
            \land \for{\txid, \addr, \val}  \\
            \qquad (\etR, \addr, \val) \in \tx(\txid) 
            \implies \val \in \respo(\aexec, \vis(\txid), \addr)
        }
    \end{rclarray}
\]
\end{defn}    
 
\begin{lem}[Consistency models monotonicity]
\label{lem:consistency-include}
\label{lem:consistency-monotonicity}
\[
    \como_{1} \ordCOM \como_{2} \implies \evalCOM{\como_{2}} \subseteq \evalCOM{\como_{1}}
\]
\end{lem}
\begin{proof}
For any abstract execution \( \aexec \) that satisfies the stronger consistency model \( \como_{2} = (\respo_{2}, \conguar_{2}) \), we have \( \conguar_{2}(\aexec) \subseteq \aexec\projection{\vis}  \) and \( \for{\txid, \addr, \val} (\etW, \addr, \val) \in \tx(\txid) \implies \val \in \respo_{2}(\aexec, \vis(\txid), \addr) \) by the \defref{def:valid-aexec}.
Given the hypothesis \( \como_{1} \ordAEX \como_{2} \) and the definition (\defref{def:consistency-models}), we have \( \conguar_{1}(\aexec)  \subseteq \conguar_{2}(\aexec)  \)  and \( \respo_{2}(\aexec, \aexec\projection{\vis}(\txid), \addr) \subseteq \respo_{1}(\aexec, \aexec\projection{\vis}(\txid), \addr)\), thus \( \aexec \in \evalCOM{\como_{1}}\).
\end{proof}



\begin{thm}[Soundness of the semantics]
For any runtime abstract abstract execution \( \aexecrun \) that satisfies a certain consistency model \( \como \), and if it takes one step under consistency model \( \como \) to another state \( \aexecrun' \), the new state \( \aexecrun' \) should also satisfy the consistency model.
This is,
 \[
 \begin{array}{@{}l@{}}
    \for{\como, \thid, \aexecrun, \aexecrun', \thstk, \thstk', \iprog, {\iprog}', \lb} \\
    \qquad \eraseAEX{\aexecrun} \in \evalCOM{\como}
    \land \como, \thid \vdash (\aexecrun, \thstk), \iprog \toT{\lb} (\aexecrun', \thstk'), {\iprog}' 
    \implies \eraseAEX{\aexecrun'} \in \evalCOM{\como}
 \end{array}
 \]
\end{thm}
\begin{proof}
    We prove it by induction on the rules.
    The only interesting case is the \rl{Commit} rule where \( \iprog = \ptrans{\trans} \), \( \iprog' = \pskip \) and \( \lb = \lbC{\txid} \).
    We need to prove the follows,
    \begin{align}
        & \exsts{\aexec' = \eraseAEX{\aexecrun'}} \for{ \txid', \txid'', \addr, \val}  \nonumber \\
        & \quad (\etR, \addr, \val) \in \aexec\projection{\tx}(\txid') \implies \val \in \respo(\aexec',\aexec'\projection{\vis}(\txid'), \addr) \label{equ:res_policy}\\
        & \quad (\txid', \txid'') \in \conguar(\aexec') \implies (\txid', \txid'') \in \aexec'\projection{\vis} \label{equ:con_guarantee}
    \end{align}
    For brevity, assume \( \aexec = \eraseAEX{\aexecrun} \) and \( \aexec' = \eraseAEX{\aexecrun'} \) in the following discussion.
    First, we consider \equref{equ:res_policy} and we only need to consider the new transaction, \ie \( \txid' = \txid \).
    By the premiss of the rule, we can rewrite the equation we need to prove to the following form,
    \[
        (\etR, \addr, \val) \in \evset \implies \val \in \respo(\aexec',\txidset, \addr) \\
    \]
    where \( \evset \) is the set of all the events associated with \( \txid \) and \( \txidset \) is the set of transactions that observed by the new transaction \( \txid \).
    By the flush read \( \flushR \) \defref{def:transaction-event} and the transaction semantics \figref{fig:transaction_semantics}, assume some initial heap \( \h \) that satisfies the follows,
    \[
    \begin{array}{@{}l@{}}
        \exsts{\thstk, \txstk, \h'} \nonumber \\
        \quad \thstk \vdash (\emptyset, \h, \emptyset), \trans \toL^{*} (\txstk, \h', \evset), \pskip 
        \land \h \in \obsstate{\aexecrun, \txidset, \respo} \nonumber \\
    \end{array}
    \]
    Given the initial heap \( \h \), we have the follows,
    \begin{equation}
        \label{equ:first-read-from-the-init-heap} 
        (\etR, \addr, \val) \in \evset \implies \h(\addr) = \val
    \end{equation}
    because a transaction only records the first read event for each address.
    It can be proved by induction on the rules for transaction operational semantics, where the only rule that involves read event is \rl{TRead}.
    If the new read event in the final events set, \ie \( (\etR, \addr, \val) \in ( \evset \flushR (\etR, \addr, \val) ) \), this means their is no other read and write before, so that the value \( \val  \) associate with the address \( \addr \) remains unchanged.
    By the definition of \( \obsstateName \) \figref{fig:thread_semantics},  we have \( \h(\addr) = \val \iff \respo(\aexec, \txidset, \addr) \).
    Since \( \aexec \ordAEX \aexec' \), the following holds,
    \[
        (\etR, \addr, \val) \in \evset \implies \h(\addr) = \val \implies  \respo(\aexec, \txidset, \addr) \implies \respo(\aexec', \txidset, \addr)
    \]
    
    Second, we need to prove \equref{equ:con_guarantee}, meaning the visibility relation of the new abstract execution still satisfies the consistency guarantee.
    Similarly, we only consider those visibility relation related with the new transaction \( \tsid \).
    Note that for any transaction \( \tsid'' \in \dom(\aexec'\projection{\tx}) \) such that \( (\tsid, \tsid'') \notin \conguar(\aexec') \), because by the function \( \newaexecName \) we have \( (\tsid'', \tsid) \in \aexec'\projection{\ar} \) and then by the definition of consistency guarantee \defref{def:consistency-models}, we have \( \conguar(\aexec') \subseteq \aexec'\projection{\ar}\).
    So let's pick a transaction \( \tsid' \in \dom(\aexec'\projection{\tx}) \) such that \( (\tsid', \tsid) \in \conguar(\aexec') \).
    By the \( \predn{consis}\) predicate, we have \( (\tsid', \tsid) \in \conguar(\aexec') \implies (\tsid', \tsid) \in \aexec'\projection{\vis}\).
\end{proof}

\begin{lem}[Semantics monotonicity]
\label{lem:semantics-monotonicity}
\[
\begin{array}{@{}l@{}}
    \for{\como_{1}, \como_{2}, \thid, \aexecrun, \aexecrun', \iprog, \iprog', \thstk, \thstk', \lb}  \\
    \quad \como_{2}, \thid \vdash ( \aexecrun, \thstk ), \iprog \toT{\lb} ( \aexecrun', \thstk' ), \iprog'
    \land \como_{1} \ordCOM \como_{2} \\
    \quad \implies \como_{1}, \thid \vdash ( \aexecrun, \thstk ), \iprog \toT{\lb} ( \aexecrun', \thstk' ), \iprog'
\end{array}
\]
\end{lem}
\begin{proof}
We prove it by induction on the rules.
The only interesting case is the  \rl{Commit} rule, especially given \( \aexecrun, \txidset, \thid \), we need to prove the follows,
\begin{itemize}
\item All the observable states under the stronger consistency model \( \como_{2} \), they can be observed under the weaker one \( \como_{1} \).
This is, \( \obsstate{\aexecrun, \txidset, \respo_{2}} \subseteq  \obsstate{\aexecrun, \txidset, \respo_{1}} \).

For any observable heap \( \h \) under stronger consistency model \( \como_{1}\), \ie \( \h \in \obsstate{\aexecrun, \txidset, \respo_{2}} \), from the definition in \figref{fig:thread_semantics}, we have \( \for{\addr, \val}  \val \in \respo_{2}(\eraseAEX{\aexecrun}, \txidset, \addr) \implies \h(\addr) = \val \).
Since \( \respo_{2}(\eraseAEX{\aexecrun}, \txidset, \addr) \subseteq \respo_{1}(\eraseAEX{\aexecrun}, \txidset, \addr) \), therefore \( \for{\addr, \val}  \val \in \respo_{1}(\eraseAEX{\aexecrun}, \txidset, \addr) \implies \h(\addr) = \val \) also holds, so that \( \h \in \obsstate{\aexecrun, \txidset, \respo_{1}} \).

\item If the new runtime abstract execution exists under the stronger concurrency model \( \como_{2} \), it should also exist under weaker one.
This means, \( \consis{\aexecrun, \txid, \thid, \conguar_{2}} \implies \consis{\aexecrun, \txid, \thid, \conguar_{1}} \).

Assume a transaction \( \txid' \) such that \( (\txid', \txid) \in \conguar_{2}(\eraseAEX{\aexec}) \) therefore by the definition, we have \( (\txid', \txid) \in \aexecrun\projection{\vis} \).
Since \( \conguar_{1}(\eraseAEX{\aexec}) \subseteq \conguar_{2}(\eraseAEX{\aexec})\), so that \( (\txid', \txid) \in \conguar_{1}(\eraseAEX{\aexec}) \implies (\txid', \txid) \in \aexecrun\projection{\vis} \) also holds.
Therefore we have \( \consis{\aexecrun, \txid, \thid, \conguar_{2}} \implies \consis{\aexecrun, \txid, \thid, \conguar_{1}} \).
\end{itemize}
\end{proof}

\begin{lem}[Preservation of the consistency model]
\label{lem:preserve-of-consistency}
\[
 \begin{array}{@{}l@{}}
    \for{\como_{1}, \como_{2}, \thid, \aexecrun, \aexecrun', \thstk, \thstk', \iprog, {\iprog}', \lb} \\
    \qquad \como_{1}, \thid \vdash (\aexecrun, \thstk), \iprog \toT{\lb} (\aexecrun', \thstk'), {\iprog}'
    \land \eraseAEX{\aexecrun'} \in \evalCOM{\como_{2}}
    \implies \eraseAEX{\aexecrun} \in \evalCOM{\como_{2}}
 \end{array}
\]
\end{lem}
\begin{proof}
    We prove it by induction on the rules.
    The only interesting case is the \rl{Commit} rule where \( \iprog = \ptrans{\trans} \), \( \iprog' = \pskip \) and \( \lb = \lbC{\txid} \).
    We prove  \rl{Commit} by deriving contradiction.
    Assume that \( \eraseAEX{\aexecrun} \in \evalCOM{\como_{2}} \) does not hold.
    This mean there exists two transactions \( \txid' \) and \( \txid'' \) such that either \( (\txid', \txid'') \in \conguar_{2}(\eraseAEX{\aexecrun}) \land (\txid', \txid'') \notin \aexecrun\projection{\vis} \) or \( \exsts{\addr, \val} (\etW, \addr, \val) \in \aexecrun\projection{\tx} \land \val \notin \respo_{2}(\eraseAEX{\aexecrun}, \aexecrun\projection{\vis}(\txid'), \addr) \).
    By the rule, we have \( \aexecrun \ordAEXRUN \aexecrun'\), therefore for the such \( \txid', \txid'' \) we have \( (\txid', \txid'') \in \conguar_{2}(\eraseAEX{\aexecrun'}) \land (\txid', \txid'') \notin \aexecrun\projection{\vis} \) or \( \exsts{\addr, \val} (\etW, \addr, \val) \in \aexecrun'\projection{\tx} \land \val \notin \respo_{2}(\eraseAEX{\aexecrun'}, \aexecrun'\projection{\vis}(\txid'), \addr) \).
    This means \( \aexecrun' \notin \evalCOM{\como_{2}} \), which contradicts the assumption.
\end{proof}


\begin{thm}[Completeness of the semantics]
For any runtime abstract abstract execution \( \aexecrun \) that satisfies a certain consistency model \( \como \), and if it takes one step under the weakest consistency model \( \btmCOM \) to another state \( \aexecrun' \), and if the new state satisfies the consistency model \( \como \), there is a corresponding step of the semantics under consistency model \( \como \).
 \[
 \begin{array}{@{}l@{}}
    \for{\como, \thid, \aexecrun, \aexecrun', \thstk, \thstk', \iprog, {\iprog}', \lb} \\
    \qquad \btmCOM, \thid \vdash (\aexecrun, \thstk), \iprog \toT{\lb} (\aexecrun', \thstk'), {\iprog}' \land \eraseAEX{\aexecrun'} \in \evalCOM{\como} \\
    \qqquad \implies \como, \thid \vdash (\aexecrun, \thstk), \iprog \toT{\lb} (\aexecrun', \thstk'), {\iprog}' 
 \end{array}
 \]
\end{thm}
\begin{proof}
Since \( \eraseAEX{\aexecrun'} \in \evalCOM{\como} \), by the \lemref{lem:preserve-of-consistency}, we have \( \eraseAEX{\aexecrun} \in \evalCOM{\como} \).
Then because \( \btmCOM \) is the bottom element such that \( \btmCOM \ordCOM \como \).
Then by \lemref{lem:semantics-monotonicity}, we have the proof.
\end{proof}
