\section{semantics\label{sec:semantics}}

We model the state of a database by a time stamp heap that is a partial function from locations to their histories.
The history is a partial functions from times to a set of events.
A event is a triple consisting of the value being read or written, the operation, i.e. either read or write, and the transaction identifier.
We use thread pool to model the concurrency.
Each thread has a local stack and a local time, but a globally shared time stamp heap.
Therefore a thread pool is a partial functions from thread identifiers to the corresponding stack, time and transactions.
The state of each transaction, i.e.\ local state, are a stack which is shared between transactions in the same thread, a heap that is a  snapshot of the time stamp heap, and fingerprints that are the heap locations being read and written.

\[
    \begin{rclarray}
        \loc \in \Loc & \defeq & \Nat \\
        \val \in \Val & \defeq & \Nat \uplus \Loc \\
        \Var & \defeq & \Set{ \vx, \vy, \dots } \\
        \ts \in \Timestamp & \defeq & \Nat \\
        \hp \in \Heap & \defeq & \Loc \parfun \Val \\
        \stk \in \Stack & \defeq & \Var \to \Val \\
        \op \in \Operation & \defeq & \Set{\opr, \opw} \\
        \settrans \subseteq \TransID & \defeq & \Set{ \alpha , \beta, \dots } \\
        \ThreadID & \defeq & \Set{ i , j, \dots } \\
        \rs \in \Readset, \ws \in \Writeset & \defeq & \powerset{\Loc} \\
        \tshp \in \Timestampheap & \defeq & \Loc \parfun ( \Timestamp \parfun \powerset{\Val \times \Operation \times \TransID}) \\
        (\stk, \tshp, \ts) \in \Threadstate & \defeq & \Stack \times \Timestampheap \times \Timestamp \\
        \tdpl \in \Threadpool & \defeq & \ThreadID \parfun \Stack \times \Timestamp \times \prog \\
        \stt \in \State & \defeq & \Timestampheap \times \Threadpool \\
        \lstt = (\stk, \hp, \rs, \ws ) \in \Localstate & \defeq & \Stack \times \Heap \times \Readset \times \Writeset \\
    \end{rclarray}
\]

No side effect of evaluation of arithmetic expression.

\[
    \begin{syntax}{\expr}
              \val \quad          |
        \quad \var \quad          |
        \quad \expr + \expr \quad |
        \quad \expr * \expr \quad |
        \quad \dots 
    \end{syntax}
\]

No side effect of evaluation of boolean expression.

\[
    \begin{rclarray}
        \eval{\val}_{\stk} & \defeq & \val \\
        \eval{\var}_{\stk} & \defeq & \stk(\val) \\
        \eval{\expr_{1} + \expr_{2}}_{\stk} & \defeq & \eval{\expr_{1}}_{\stk} + \eval{\expr_{2}}_{\stk}   \\
        \eval{\expr_{1} * \expr_{2}}_{\stk} & \defeq & \eval{\expr_{1}}_{\stk} * \eval{\expr_{2}}_{\stk}  
    \end{rclarray}
\]

\[
    \begin{syntax}{\bool}
              \true \quad                |
        \quad \false \quad               |
        \quad \expr = \expr \quad        |
        \quad \expr < \expr \quad        |
        \quad \boolnot \bool \quad       |
        \quad \bool \booland \bool \quad |
        \quad \bool \boolor \bool \quad  |
        \quad \dots 
    \end{syntax}
\]

\[
    \begin{rclarray}
        \eval{\true}_{\stk}& \defeq & \true \\
        \eval{\false}_{\stk} & \defeq & \false \\
        \eval{\expr_{1} = \expr_{2}}_{\stk} & \defeq & \eval{\expr_{1}}_{\stk} = \eval{\expr_{2}}_{\stk}   \\
        \eval{\expr_{1} < \expr_{2}}_{\stk} & \defeq & \eval{\expr_{1}}_{\stk} < \eval{\expr_{2}}_{\stk}   \\
        \eval{\boolnot \bool}_{\stk} & \defeq & \neg \eval{\bool}_{\stk} \\
        \eval{\bool_{1} \booland \bool_{2}}_{\stk} & \defeq & \eval{\bool_{1}}_{\stk} \land \eval{\bool_{2}}_{\stk}  \\
        \eval{\bool_{1} \boolor \bool_{2}}_{\stk}& \defeq & \eval{\bool_{1}}_{\stk} \lor \eval{\bool_{2}}_{\stk}  
    \end{rclarray}
\]

\[
    \begin{syntax}{\cmd}
              \pskip \quad                  |
        \quad \pass{\vx}{\expr} \quad       |
        \quad \pmutate{\expr}{\expr} \quad  |
        \quad \pderef{\vx}{\expr} \quad     |
        \quad \pif{\bool}{\cmd}{\cmd} \quad | \\
              \ploop{\bool}{\cmd} \quad     |
        \quad \cmd \pseq \cmd
    \end{syntax}
\]

\[
    \begin{rclarray}
        ( \dontcare, \dontcare ) \ \localtransfer \  ( \dontcare, \dontcare ) & \defeq &  ( \Localstate \times \cmd ) \times ( \Localstate \times \cmd ) \\
    \end{rclarray}
\]

\[
    \infer[ass]{%
        ( \stk, \hp, \rs, \ws ) , \pass{\var}{\expr} \ \localtransfer \  ( \stk \remapsto{\var}{\val}, \hp, \rs, \ws ) , \pskip
    }{%
    \eval{\expr}_{\stk} = \val
    }
\]

\[
    \infer[mutate]{%
        ( \stk, \hp, \rs, \ws ) , \pmutate{\expr_{1}}{\expr_{2}} \ \localtransfer \  ( \stk, \hp \remapsto{\loc}{\val}, \rs, \ws \cup \Set{\loc} ) , \pskip
    }{%
        \eval{\expr_{1}}_{\stk} = \loc \quad 
        \eval{\expr_{2}}_{\stk} = \val \quad 
        \loc \in \dom(\hp)
    }
\]

\[
    \infer[deref]{%
        ( \stk, \hp, \rs, \ws ) , \pderef{\var}{\expr} \ \localtransfer \  ( \stk \remapsto{\var}{\val}, \hp, \rs \cup \Set{\loc}, \ws ) , \pskip
    }{%
        \eval{\expr}_{\stk} = \loc \quad 
        \val = \hp(\loc) \quad
        \loc \in \dom(\hp)
    }
\]

\[
    \infer[ifelsetrue]{%
        ( \stk, \hp, \rs, \ws ) , \pif{\bool}{\cmd_{1}}{\cmd_{2}} \ \localtransfer \  ( \stk, \hp, \rs, \ws ) , \cmd_{1}
    }{%
        \eval{\bool}_{\stk} = \true
    }
\]

\[
    \infer[ifelsefalse]{%
        ( \stk, \hp, \rs, \ws ) , \pif{\bool}{\cmd_{1}}{\cmd_{2}} \ \localtransfer \  ( \stk, \hp, \rs, \ws ) , \cmd_{2}
    }{%
        \eval{\bool}_{\stk} = \false
    }
\]

\[
    \infer[whiletrue]{%
        ( \stk, \hp, \rs, \ws ) , \ploop{\bool} \cmd \ \localtransfer \  ( \stk, \hp, \rs, \ws ) , \cmd \pseq \ploop{\bool} \cmd
    }{%
        \eval{\bool}_{\stk} = \true
    }
\]

\[
    \infer[whilefalse]{%
        ( \stk, \hp, \rs, \ws ) , \ploop{\bool} \cmd \ \localtransfer \  ( \stk, \hp, \rs, \ws ) , \pskip
    }{%
        \eval{\bool}_{\stk} = \false \quad
    }
\]

\[
    \infer[seqskip]{%
        ( \stk, \hp, \rs, \ws ) , \pskip \pseq \cmd_{2} \ \localtransfer \  ( \stk, \hp, \rs, \ws ) , \cmd_{2}
    }{%
    }
\]

\[
    \infer[seqnonskip]{%
        ( \stk, \hp, \rs, \ws ) , \cmd_{1} \pseq \cmd_{2} \ \localtransfer \  ( \stk', \hp', \rs', \ws' ) , \cmd_{1}' \pseq \cmd_{2}
    }{%
        ( \stk, \hp, \rs, \ws ) , \cmd_{1} \ \localtransfer \  ( \stk', \hp', \rs', \ws' ) , \cmd_{1}'
    }
\]

The semantics of transaction are interleaving of start, commit, and restart.

\[
    \begin{syntax}{\prog}
              \pskip \quad                    |
        \quad \ptrans{\cmd} \quad             |
        \quad \prog \pseq \prog \quad         |
        \quad \pif{\bool}{\prog}{\prog} \quad | 
        \quad \ploop{\bool}{\prog} \quad      |
        \quad \prog \ppar \prog 
    \end{syntax}
\]

\[
    \begin{syntax}{\progext}
              \pwait{\thid} \quad                |
        \quad \prog \quad                        |
        \quad \progext \pseq \pwait{\thid} \quad |
    \end{syntax}
\]

\[
    \begin{rclarray}
        \tll \in \Translabel & \defeq & 
              \lid \quad              |
        \quad \lfork{\thid,\prog} \quad |
        \quad \ljoin{\thid,\ts} \\
        ( \dontcare, \dontcare ) \ \threadtransfer{ \dontcare } \ ( \dontcare, \dontcare ) & \defeq &  ( \Threadstate \times \progext ) \times \Translabel \times  ( \Threadstate \times \progext )  \\
    \end{rclarray}
\]

\[
    \begin{rclarray}
        \func{startstate}(\tshp,\ts) & \defeq & \lambda \loc \ldotp \val \\
                                     & & \texttt{where} \ \exists \ts' \leq \ts \ldotp \tshp(\loc)(\ts') = \Set{(\val,\wop, \dontcare) } \land \forall \ts'' \in ( \ts', \ts''] \ldotp (\dontcare,\wop,\dontcare) \notin \tshp(\loc)(\ts') \\
        \pred{allowcommit}(\tshp,\ws,\rs,\ts_{s},\ts_{e}) & \defeq & 
        \pred{atomicop}(\tshp,\ws,\rs,\ts_{s},\ts_{e}) \land \pred{consistent}(\tshp,\ws,\rs,\ts_{s},\ts_{e}) \\
        \pred{atomicop}(\tshp,\ws,\rs,\ts_{s},\ts_{e}) & \defeq  & \forall \loc_{w} \in \ws \ldotp \tshp(\loc_{w})(\ts_{e})\undef \land \forall \loc_{r} \in \rs \ldotp (\dontcare,\wop,\dontcare) \notin \tshp(\loc_{r})(\ts_{s})\\
        \pred{consistent}(\tshp,\ws,\rs,\ts_{s},\ts_{e}) & \defeq & \forall \ts \in (\ts_{s},\ts_{e}], \loc_{w} \in \ws \ldotp (\dontcare, \wop, \dontcare)  \notin \tshp(\loc_{w})(\ts) \land {} \\
                                                         & & \forall \tsid \ldotp \nexists \ts_{\tsid s} < \ts_{e}, \ts_{\tsid e} > \ts_{e} \ldotp \tshp(\loc)(\ts_{\tsid s}) = (\dontcare, \rop, \tsid) \land \tshp(\loc)(\ts_{\tsid e}) = (\dontcare, \wop, \tsid) \land {} \\
                                                         & & \exists \ts_{min} = \min(\Set{\ts'' \ \middle| \ \ts'' \geq \ts_{e} \land \tshp(l)(\ts'')\isdef}) \ldotp (\dontcare, \rop, \dontcare) \notin \tshp(\loc)(\ts_{min}) \\
        \func{commit}(\tshp,\hp,\ws,\rs,\ts_{s},\ts_{e}) & \defeq &
        \lambda \loc \ldotp
        \begin{funcarray}
            \tshp(\loc) & \loc \notin \ws \cup \rs \\
            \tshp(\loc)\remapsto{\ts_{e}}{\tshp(\loc)(\ts_{e}) \uplus \Set{(\hp(\loc),\wop,\tsid)}} & \loc \in \ws \\
            \tshp(\loc)\remapsto{\ts_{s}}{\tshp(\loc)(\ts_{s}) \uplus \Set{(\hp(\loc),\rop,\tsid)}} & \loc \in \rs \\
        \end{funcarray} \\
        & & \texttt{where} \  \tsid \notin \Set{\tsid' \ \middle| \ (\dontcare,\dontcare,\tsid') \in \bigcup\limits_{\loc,\ts}\tshp(\loc)(\ts)} \\
    \end{rclarray}
\]

\[
    \infer[commit]{%
        ( \stk, \tshp, \ts ) , \ptrans{\cmd} \ \threadtransfer{\lid} \ ( \stk', \tshp', \ts_{e} ) , \pskip
    }{%
        \begin{array}{c}
            \ts_{s} \geq \ts
            \quad \ts_{e} > \ts_{s} 
            \quad \hp_{s} = \func{startstate}(\tshp, \ts_{s}) 
            \quad ( \stk, \hp_{s}, \emptyset, \emptyset ) , \cmd \localtransfer^{*} ( \stk', \hp_{e}, \rs, \ws ) , \pskip \\
            \pred{allowcommit}(\tshp,\ws,\rs,\ts_{s},\ts_{e}) 
            \quad \tshp' = \func{commit}(\tshp,\hp_{e},\ws,\rs,\ts_{s},\ts_{e})
        \end{array}
    }
\]

\[
    \infer[conditiontrue]{%
        ( \stk, \tshp, \ts ) , \pif{\bool}{\prog_{1}}{\prog_{2}} \ \threadtransfer{\lid} \  ( \stk, \tshp, \ts ) , \prog_{1}
    }{%
        \eval{\bool}_{s} = \true
    }
\]

\[
    \infer[conditionfalse]{%
        ( \stk, \tshp, \ts ) , \pif{\bool}{\prog_{1}}{\prog_{2}} \ \threadtransfer{\lid} \  ( \stk, \tshp, \ts ) , \prog_{2}
    }{%
        \eval{\bool}_{s} = \false
    }
\]

\[
    \infer[norep]{%
        ( \stk, \tshp, \ts ) , \ploop{\bool}{\prog} \ \threadtransfer{\lid} \ ( \stk, \tshp, \ts ) , \pskip
    }{%
        \eval{\bool}_{s} = \false
    }
\]

\[
    \infer[rep]{%
        ( \stk, \tshp, \ts ) , \ploop{\bool}{\prog} \ \threadtransfer{\lid} \  ( \stk, \tshp, \ts ) , \prog \pseq \ploop{\bool}{\prog}
    }{%
        \eval{\bool}_{s} = \true
    }
\]

\[
    \infer[seqskip]{%
        ( \stk, \tshp, \ts ) , \pskip \pseq \progext \ \threadtransfer{\lid} \  ( \stk, \tshp, \ts ) , \progext
    }{%
    }
\]

\[
    \infer[seqnoskip]{%
        ( \stk, \tshp, \ts ) , \progext_{1} \pseq \progext_{2} \ \threadtransfer{\tll} \ ( \stk', \tshp', \ts' ) , \progext_{1}' \pseq \progext_{2}
    }{%
        ( \stk, \tshp, \ts ) , \progext_{1} \ \threadtransfer{\tll} \  ( \stk', \tshp', \ts' ) , \progext_{1}' 
    }
\]

\[
    \infer[par]{%
        ( \stk, \tshp, \ts ) , \prog_{1} \ppar \prog_{2} \ \threadtransfer{\lfork{\thid, \prog_{2}}} \  ( \stk, \tshp, \ts ) , \prog_{1} \pseq \pwait{\thid}
    }{%
    }
\]

\[
    \infer[wait]{%
        ( \stk, \tshp, \ts ) , \pwait{\thid} \ \threadtransfer{\ljoin{\thid,\ts'}} \  ( \stk, \tshp , \max\Set{\ts,\ts'} ) , \pskip 
    }{%
    }
\]

\[
    \begin{rclarray}
        \dontcare \ \globaltransfer \ \dontcare & \defeq & \State \times \State  \\
    \end{rclarray}
\]

\[
    \infer[single]{%
        ( \tshp, \tdpl \uplus \Set{ \thid \mapsto (\stk, \ts, \progext) } ) \ \globaltransfer \  ( \tshp', \tdpl \uplus \Set{ \thid \mapsto (\stk', \ts', \progext') } ) 
    }{%
        ( \stk, \tshp, \ts ) , \progext \ \threadtransfer{\tll} \  ( \stk', \tshp', \ts' ) , \progext' 
        \quad \tll = \lid
    }
\]

\[
    \infer[par]{%
        ( \tshp, \tdpl \uplus \Set{ \thid \mapsto (\stk, \ts, \progext) } ) \ \globaltransfer \  ( \tshp', \tdpl \uplus \Set{ \thid \mapsto (\stk', \ts', \progext'), \thid' \mapsto (\lambda \var \ldotp 0, \ts', \prog'') } )
    }{%
        ( \tshp, \stk, \ts ) , \progext \ \threadtransfer{\lfork{\thid', \prog''}} \  ( \tshp', \stk', \ts' ) , \progext' 
    }
\]

\[
    \infer[wait]{%
        ( \tshp, \tdpl \uplus \Set{ \thid \mapsto (\stk, \ts, \progext), \thid' \mapsto (\stk', \ts'', \pskip) } )  \ \globaltransfer \ ( \tshp', \tdpl \uplus \Set{ \thid \mapsto (\stk', \ts', \progext')} )
    }{%
    ( \tshp, \stk, \ts ) , \progext \ \threadtransfer{\ljoin{\thid',\ts''}} \  ( \tshp', \stk', \ts' ) , \progext' 
    }
\]

\begin{lem}
    A history cannot be overwritten, i.e.\ \( \forall \tshp, \tshp', \loc,\ts \ldotp \tshp, \dontcare \globaltransfer{\dontcare} \tshp', \dontcare \land \tshp(\loc)(\ts)\isdef \implies \tshp(\loc)(\ts) = \tshp'(\loc)(\ts)\)
\end{lem}
\begin{proof}
    From the \( \pred{allowcommit} \).
\end{proof}

\begin{lem}
    \label{lem:read-before-write}
    All the reads of a transaction happen before all the writes. This is 
    \( \forall \tshp, \loc, \loc', \ts, \ts', \tsid \ldotp \tshp(\loc)(\ts) = (\dontcare, \rop, \tsid) \land \tshp(\loc')(\ts') = (\dontcare, \wop, \tsid) \implies \ts < \ts' \).
\end{lem}
\begin{proof}
    From the semantics that \( \ts_{s} < \ts_{e} \).
\end{proof}

\begin{lem}
    \label{lem:atoic-rw}
    All the reads of a transaction happen in the same time, so do all the writes. This is 
    \( \forall \tshp, \loc, \loc', \ts, \ts', \tsid, \op \in \Set{\rop, \wop} \ldotp \tshp(\loc)(\ts) =  \tshp(\loc')(\ts') = (\dontcare, \op, \tsid) \implies \ts = \ts' \).
\end{lem}
\begin{proof}
    From the \( \func{commit} \).
\end{proof}

Now we need to recover \( \vis \) and \( \ar \) from \( \tshp \).
First we need to extend the \( \tshp \) because there are some transactions that only have reads or writes.
We stretch the time by 3, and add extra operation for those transactions.
For a transaction \( \tsid \) that only has reads event, says in time \( \ts \), we add end operations \( (\bot, \tsid, \eop ) \) to the heap cells it reads in time \( (\ts + 1 ) \).
Similarly for a transaction that only has writes event, we add end operations \( (\bot, \tsid, \sop ) \) in time \( (\ts-1) \).

\[
\begin{rclarray}
    \func{stretch}(\tshp) & \defeq & \lambda \loc \ldotp \lambda \ts \ldotp
    \begin{funcarray}
        \tshp(\loc)(\ts') & \ts = 3 * \ts' \\
        \texttt{undef} & o.w. \\
    \end{funcarray} \\
    \func{extend}(\tshp) & \defeq & \lambda \loc \ldotp \tshp(\loc) \uplus \Set{\ts + 1 \mapsto (\bot, \tsid, \eop ) \ \middle| \ \tshp(\loc)(\ts) = (\dontcare, \tsid, \rop) \land \forall \loc', \ts' \ldotp \tshp(\loc')(\ts') = (\dontcare, \tsid, \wop)} \\
                         & & \quad \quad \quad \uplus \Set{\ts - 1 \mapsto (\bot, \tsid, \sop ) \ \middle| \ \tshp(\loc)(\ts) = (\dontcare, \tsid, \wop) \land \forall \loc', \ts' \ldotp \tshp(\loc')(\ts') = (\dontcare, \tsid, \rop)}
\end{rclarray}
\]

\begin{lem}
    After stretching the time by 3, there is no record in time \( 3 * \nat + 1 \) and \( 3 * \nat - 1 \).
    Therefore after extending, there are only \( (\dontcare, \tsid, \eop) \) in time \( 3 * \ts + 1 \) and only \( (\dontcare, \tsid, \sop) \) in time \( 3 * \ts - 1 \).
    This is \( \forall \tshp \ldotp \exists \tshp' = \func{extend} \circ \func{stetch}(\tshp) \ldotp \forall \loc, \ts \ldotp (\tshp'(\loc)(3 * \ts + 1)\isdef \implies \tshp'(\loc)(3 * \ts + 1) = (\dontcare, \dontcare, \eop) ) \land (\tshp'(\loc)(2 * \ts - 1)\isdef \implies \tshp'(\loc)(3 * \ts - 1) = (\dontcare, \dontcare, \sop) ) \).
\end{lem}
\begin{proof}
    trivial.
\end{proof}

\begin{lem}
    \label{lem:start-before-end}
    In the extended heap, all the reads or starts of a transaction happen before all the writes or end. This is 
    \( \forall \tshp, \loc, \loc', \ts, \ts', \op \in \Set{\rop, \sop}, \op' \in \Set{\wop, \eop}, \tsid \ldotp \tshp(\loc)(\ts) = (\dontcare, \op, \tsid) \land \tshp(\loc')(\ts') = (\dontcare, \op', \tsid) \implies \ts < \ts' \).
\end{lem}
\begin{proof}
    From Lemma \ref{lem:read-before-write} and the definition of \func{strech} and \func{extend}.
\end{proof}

\begin{lem}
    \label{lem:happen-in-same-time}
    For an extended heap, all the reads of a transaction happen in the same time, so do all the writes, starts and ends. This is 
    \( \forall \tshp, \loc, \loc', \ts, \ts', \tsid, \op \ldotp \tshp(\loc)(\ts) =  \tshp(\loc')(\ts') = (\dontcare, \op, \tsid) \implies \ts = \ts' \).
\end{lem}
\begin{proof}
    From Lemma \ref{lem:atoic-rw} and the definition of \func{strech} and \func{extend}.
\end{proof}

\begin{lem}
    \label{lem:unique-label}
    A transaction in an extended heap, must have either starts or reads, and either ends or writes.
\end{lem}
\begin{proof}
    From the definition of \func{extend}.
\end{proof}

\[
\begin{rclarray}
    (\settrans, \tvis, \tar) = \func{graph}(\tshp) & \defeq & (\Set{ \tsid \ \middle| \ \forall \loc \ldotp \tshp(\loc) = (\dontcare, \tsid, \dontcare)}, \\
                                                   & & \Set{(\tsid, \tsid') \ \middle| \ 
    \begin{array}{@{}l@{}}
        \exists \loc, \loc', \ts, \ts', \op \in \Set{\wop, \eop}, \op' \in \Set{\rop, \sop} \ldotp \\
        \ts < \ts' \land \tshp(\loc)(\ts) = (\dontcare, \tsid, \op) \land \tshp(\loc')(\ts') = (\dontcare, \tsid', \op')
    \end{array}
}, \\
                                                   & & \Set{(\tsid, \tsid') \ \middle| \ 
    \begin{array}{@{}l@{}}
        \exists \loc, \loc', \ts, \ts', \op, \op' \in \Set{\wop, \eop} \ldotp \\
        \ts < \ts' \land \tshp(\loc)(\ts) = (\dontcare, \tsid, \op) \land \tshp(\loc')(\ts') = (\dontcare, \tsid', \op')
    \end{array}
}, \\
\end{rclarray}
\]

\begin{lem}
    For an extended heap, the corresponding \tvis\ and \tar\ have no circle.
\end{lem}
\begin{proof}
    Assume there is a circle in \(\rvis\), says, \( \tsid_{1} \rvis \tsid_{2} \rvis \dots \rvis \tsid_{n} \rvis \tsid_{n+1} \), where \( \tsid_{1} = \tsid_{n+1} \).
    Therefore, \( \bigwedge\limits_{ 1 \leq i \leq n} \exists \loc, \loc', \ts, \ts', \op \in \Set{\wop, \eop}, \op' \in \Set{\rop, \sop} \ldotp \ts < \ts' \land \tshp(\loc)(\ts) = (\dontcare, \tsid_{i}, \op) \land \tshp(\loc')(\ts') = (\dontcare, \tsid_{i+1}, \op')\).
    By Lemma \ref{lem:unique-label} we can relabel read to start and write to end.
    Then by Lemma \ref{lem:happen-in-same-time}, we can define a list of starts and ends events that is ordered by time: \( \List{ (\tsid_{1},\eop), (\tsid_{2},\sop), (\tsid_{2},\eop), \dots, (\tsid_{n},\eop), (\tsid_{n+1},\sop) } \).
    By the assumption, we have \( \tsid_{1} = \tsid_{n+1} \), thus this contradict Lemma \ref{lem:start-before-end}.

    Similarly for \(\rtar\), the list of write events  \( \List{ (\tsid_{1},\eop), (\tsid_{2},\eop), (\tsid_{2},\eop), \dots, (\tsid_{n},\eop), (\tsid_{n+1},\eop) } \) contradict Lemma \ref{lem:happen-in-same-time}.
\end{proof}

\begin{lem}
    Given a \( \tshp \), the corresponding \((\settrans, \tvis, \tar)\) can be extended to \((\settrans, \vis, \ar)\) so that it is a valid dependency graph of snapshot isolation.
\end{lem}
\begin{proof}
    First, we extend the relations \( \tar \) to a total order \( \ar \).
    Initially, \( \ar \) includes all relations in \( \tar \).
    Given the definition, only if the ends or writes of transactions happen in the same time, those transactions are not ordered by \( \tar \).
    To simplify, we introduce an initial event, i.e.\ \( \forall \tsid \in \settrans \ldotp \tsid_{init} \rar \tsid \).
    From \( \tsid_{init} \), we pick the first two transactions \( \tsid_{1} \) and \( \tsid_{2} \) that are not ordered, this is, \( \forall \tsid, \tsid' \in \Set{\tsid'' \ \middle| \ \tsid'' \rar \tsid_{1} \lor \tsid'' \rar \tsid_{2} } \ldotp \tsid \rar \tsid' \lor \tsid' \rar \tsid \).
    We can add either \( \tsid_{1} \rar \tsid_{2} \) or \( \tsid_{2} \rar \tsid_{1} \), without introducing any circle.
\end{proof}

\begin{lem}
    For the first two transactions \( \tsid_{1} \) and \( \tsid_{2} \) in a given \( \ar \) that are not ordered, we can add either \( \tsid_{1} \rar \tsid_{2} \) or \( \tsid_{2} \rar \tsid_{1} \), without introducing any circle.
\end{lem}
\begin{proof}
    Since \( \tsid_{1} \) and \( \tsid_{2} \) are the first two that are not ordered, there exists an unique \( \tsid_{pre} \) where branching happens, i.e.\ \( \tsid_{pre} \rar \tsid_{1} \land \tsid_{pre} \rar \tsid_{2} \land \nexists \tsid \ldotp \tsid_{pre} \rar \tsid \rar \tsid_{1} \lor \tsid_{pre} \rar \tsid \rar \tsid_{2} \).
    Assume we choose \( \tsid_{1} \rar \tsid_{2} \) and introduce a circle, says, \( \List{\tsid, \dots, \tsid_{1}, \tsid_{2}, \dots, \tsid' } \).
\end{proof}
