\section{Semantics\label{sec:semantics}}
\begin{defn}[Program values]
\label{def:prgram_values}
Assume a countably infinite set of \emph{addresses}, $\addr \in \Addr$. The set of \emph{program values} is $\val \in \Val \eqdef \Nat \cup \Addr$, where $\Nat$ denotes the set of natural numbers.
\end{defn}
%
\begin{defn}[Stacks]
\label{def:stacks}
Assume a set of \emph{transaction variables} \( \TxVars \defeq \Set{\txvar, \dots}\), the set of \emph{transaction stacks} is \( \txstk \in \TxStacks \defeq \TxVars \parfun \Val \).
Assume a set of \emph{thread variables} \( \ThdVars \defeq \Set{\thvar, \dots}\), the set of \emph{thread stacks} is \( \thstk \in \ThdStacks \defeq \ThdVars \parfun \Val \).
We also define the set of stacks as \( \stk \in \Stacks \eqdef \TxStacks \uplus \ThdStacks \).
\end{defn}
%
\sx{\( \stk \) is for thread stack and \( \txstk \) is for transactions}
Our programs (ranged over by $\prog$) are defined by an inductive grammar comprising the standard constructs of $\pskip$, sequential composition ($\prog; \prog$), non-deterministic choice ($\prog+\prog$), loops ($\prog^*$) and parallel composition ($\prog \ppar \prog$). Additionally, our programming language contains the \emph{transaction} construct $\ptrans{\trans}$ denoting the \emph{atomic} execution of the transaction $\trans$. The atomicity guarantees of this execution are dictated by the underlying consistency model (snapshot isolation in this case).
Transactions (ranged over by $\trans$) are defined by a similar inductive grammar comprising $\pskip$, non-deterministic choice, loops and sequential composition, as well as constructs for assignment, lookup and update. Transactions do \emph{not} contain the \emph{parallel} composition construct ($\ppar$) as they are to be executed atomically.

\begin{defn}[Programming language]
\label{def:language}
The set of \emph{programs}, $\prog \in \Programs$, is defined by the following grammar:
\[
    \begin{rclarray}
    \prog & ::= &
        \pskip \mid 
        \passign{\thvar}{\expr} \mid
        \passume{\expr} \mid
        \ptrans{\trans} \mid 
        \prog \pseq \prog \mid 
        \prog \pchoice \prog \mid 
        \prog\prepeat \mid
        \prog \ppar \prog 
    \end{rclarray}
\]
%\sx{add assume and assign here}
%\ac{The syntax allows the expression $\passign{\thvar}{\txvar}$, which was not allowed before. Is this intentional?}
%
The $\trans \in \Transactions$ in the grammar above denotes a \emph{transaction} defined by the following grammar,
%\ac{Do you assume that \TxVars and \ThdVars are disjoint?}
%
\[
    \begin{rclarray}
        \trans & ::= &
        \pskip \mid
        \pass{\txvar}{\expr} \mid
        \pmutate{\expr}{\expr} \mid
        \pderef{\txvar}{\expr} \mid
        \passume{\expr} \mid
        \preturn{\expr} \mid
        \trans \pseq \trans \mid
        \trans \pchoice \trans \mid
        \trans\prepeat
    \end{rclarray}
\]
\sx{add assume and return}
%
where $\expr \in \Expressions$ denotes an \emph{arithmetic expression} defined by the grammar below with $\val \in \Val$, $\thvar \in \ThdVars$ and \( \txvar \in \TxVars \) (\defin\ref{def:prgram_values}).
%\ac{\defin\ref{def:program_values} only introduces the set \Val, not \TxVars nor \ThdVars.}
%
\[
    \begin{rclarray}
        \expr & ::= &
        \val \mid
        \thvar \mid
        \txvar \mid
        \expr + \expr \mid
        \expr * \expr \mid
        \dots 
    \end{rclarray}
\]
%
Given a stack $\stk \in \Stacks$ (\defin\ref{def:stacks}), the \emph{expression evaluation} function, $\evalE[.]{.}:\Expressions \times \Stacks \parfun \Val$, is defined inductively over the structure of expressions as follows: 
%
\[
    \begin{rclarray}
        \evalE{\val} & \defeq & \val \\
        \evalE[\thstk \uplus \txstk]{\thvar} & \defeq & \thstk(\thvar) \\
        \evalE[\thstk \uplus \txstk]{\txvar} & \defeq & \txstk(\txvar) \\
        \evalE{\expr_{1} + \expr_{2}} & \defeq & \evalE{\expr_{1}} + \evalE{\expr_{2}} \\
        \evalE{\expr_{1} * \expr_{2}} & \defeq & \evalE{\expr_{1}} * \evalE{\expr_{2}} \\
\\
    \end{rclarray}
\]
\end{defn}


\begin{definition}[Heaps]\label{def:heaps}
Given the sets of program values $\Val$ (\defin\ref{def:prgram_values}) and  addresses $\Addr$ (\defin\ref{def:timestamp_heaps}), the set of \emph{ heaps} is: $\h \in \Heaps \eqdef \Addr \parfinfun \Val$.
The \emph{heap composition function}, $\composeH: \Heaps \times \Heaps \parfun \Heaps$, is defined as $\composeH \eqdef \uplus$, where $\uplus$ denotes the standard disjoint function union. The \emph{ heap unit element} is $\unitH \eqdef \emptyset$, denoting a function with an empty domain.
The \emph{partial commutative monoid of  heaps} is $(\Heaps, \composeH, \{\unitH\})$.
\end{definition}

\sx{
 
\begin{defn}[Fingerprints]
\label{def:fingerprint}
The set of \emph{fingerprints} is $\fp \in \Fingerprint \eqdef \powerset{\Set{\fpR,\fpW}}$.
\end{defn}
 
\begin{defn}[Fingerprint heaps]
\label{def:fingerprint_heaps}
Given the sets of program values $\Val$ (\defin\ref{def:prgram_values}), addresses $\Addr$ (\defin\ref{def:timestamp_heaps}) and fingerprints $\Fingerprint$ (\defin\ref{def:fingerprint}), the set of \emph{fingerprint heaps} is: $\fph \in \FPHeaps \eqdef \Addr \parfinfun (\Val \times \Fingerprint)$.
The \emph{fingerprint heap composition function}, $\composeFPH: \FPHeaps \times \FPHeaps \parfun \FPHeaps$, is defined as $\composeFPH \eqdef \uplus$, where $\uplus$ denotes the standard disjoint function union. The \emph{fingerprint heap unit element} is $\unitFPH \eqdef \emptyset$, denoting a function with an empty domain.
The \emph{partial commutative monoid of fingerprint heaps} is $(\FPHeaps, \composeFPH, \{\unitFPH\})$.  
\end{defn}
 
Given a fingerprint heap $\fph$ and an address $\addr$, we write $\fphVAL(\addr)$ and $\fphFP(\addr)$ for the first and second projections of $\fph(\addr)$, respectively. We write $\unitFPH$ for a fingerprint heap with an empty domain. We write $\fph_1 \uplus \fph_2$ for the standard disjoint function union of $\fph_1$ and $\fph_2$. 
%\ac{Why not define $\fphVAL$ and $\fphFP$ directly as functions from addresses to fingerprints and values directly, respectively?}

We introduce two update functions on fingerprints, $\addFPR{\fp}$ and $\addFPW{\fp}$, for updating a fingerprint $\fp$. Intuitively, the $\addFPW{\fp}$ always \emph{extends} $\fp$ with the $\fpW$ fingerprint. On the other hand, the $\addFPR{\fp}$ extends $\fp$ with $\fpR$ \emph{only if} $\fp$ does not already contain the $\fpW$ fingerprint (i.e.~$\fpW \not\in \fp$). This is to capture the fact that once an address is written to and thus the fingerprint contains $\fpW$, the following reads from the same address are considered local and need not be recorded in the fingerprint.
 
\begin{defn}[Fingerprint extension]
\label{def:fingerprint-extension}
Given the set of fingerprints $\Fingerprint$ (\defin\ref{def:fingerprint}), the \emph{read fingerprint extension} function, $\addFPR{(.)}{.}: \Fingerprint \rightarrow \Fingerprint$, and the \emph{write fingerprint extension} function, $\addFPW{(.)}{.}: \Fingerprint \rightarrow \Fingerprint$, are defined as follows, for all $\fp \in \Fingerprint$:
\[
\begin{rclarray}
	\addFPW{\fp} & \eqdef & \fp \cup \{\fpW\} \\
	\addFPR{\fp} & \eqdef &
	\begin{cases}
		\fp \cup \{\fpR\}  & \text{if } \fpW \not\in \fp \\
		\fp & \text{otherwise}
	\end{cases}
\end{rclarray}	
\]
\end{defn}
%\ac{Can you express heap composition, read and write extension of fingerprints under a single operator?}

\begin{defn}[Read and write sets]
\label{def:rs-ws}
Given the set of fingerprints $\Fingerprint$ (\defin\ref{def:fingerprint}), the \emph{read set} and \emph{write set} function, $\rsName, \wsName: \FPHeaps \to \powerset{\Addr}$ is defined as follows:
\[
\begin{rclarray}
    \ws{\fph} & \defeq & \myset{\loc}{ \exsts{\fp} \fph(\loc) = (\stub, \fp) \land \fpW \in \fp} \\
    \rs{\fph} & \defeq & \myset{\loc}{ \exsts{\fp} \fph(\loc) = (\stub, \fp) \land \fpR \in \fp} \\
\end{rclarray}	
\]
\end{defn}
}

\subsection{Local/Transaction Semantics}

We define the operational semantics of transactions $\trans$ with respect to a configuration of the form $(\stk, \txstk, \fph)$ comprising a thread stack, a transaction stack and a (local) fingerprint heap.
%\ac{Thread and Transaction stacks are not defined anymore, there is only one single stack which comprises thread variables and transaction variables.}
%The operational semantics of transactions is given in \fig\ref{fig:transaction_semantics}.
%It is standard except the \rl{TRead} and \rl{TWrite} rules where the fingerprint of the address read from (resp.~written to) is extended with $\fpR$ (resp.~$\fpW$).
%Also, transactions are not allowed to modify the thread stack.


\begin{defn}[Transaction events]
Assume a set of transactions identifiers \( \TxID \defeq \Set{\txid, \dots}\).
The set of transactions events \( \Events \) is as the follows,
\[
\begin{rclarray}
\ETags & \defeq & \Set{\etR, \etW} \\
\ev \in \evset \subseteq \Events & \defeq  & \ETags \times \Addr \times \Val
\end{rclarray}
\]
Given a set of events and a read or write event, the \emph{flush read} \( \flushR\) and \emph{flush write} \(\flushW \) are defined as the follows, 
\[
\begin{rclarray}
    \evset \flushR (\etR, \addr, \val) & \defeq & 
    \begin{cases}
        \evset &  (\etR, \addr, \stub) \in \evset \\
        \evset \uplus \Set{(\etR, \addr, \val)} & (\etR, \addr, \stub) \notin \evset \\
    \end{cases} \\
    \evset \flushW (\etW, \addr, \val) & \defeq & ( \evset \setminus \Set{(\etW, \addr, \stub)} ) \uplus \Set{(\etW, \addr, \val)} \\
\end{rclarray}
\]

The transactions are defined as a finite partial function from transactions identifiers \( \TxID \) to a set of events \( \powerset{\Events} \),
\[
\begin{rclarray}
\tx \in \Tx & \defeq & \TxID \parfinfun \powerset{\Events}
\end{rclarray}
\]
\end{defn}


\begin{defn}[Transaction semantics]
Given the sets of stacks (\defin\ref{def:stacks}), fingerprint heaps (\defin\ref{def:fingerprint_heaps}) and transactions (\defin\ref{def:language}), the \emph{operational semantics of transactions}, 
\[
\begin{rclarray}
\toL & : & \ThdStacks \times \\
& & \quad ((\TxStacks \times \Heaps \times \powerset{\Events}) \times \Transactions) \times ((\TxStacks \times \Heaps \times \powerset{\Events}) \times \Transactions)
\end{rclarray}
\], 
is given in \fig\ref{fig:transaction_semantics}.
\end{defn}
%\ac{What is the point of having a single stack, if you still use two different kinds of stack in the semantics?\\
%I believe that one of two choices needs to be made: either the transaction uses two different stacks, in which case transaction and thread stacks need to be 
%defined individually, or the semantics uses only one stack, in which case there needs to be a unique notion of stack for threads and transactions, 
%where a distinction among thread variables and transaction variables needs to be made.}

\begin{figure}[!t]
\hrule\vspace{5pt}
\[	
    \infer[\rl{TAss}]{%
        \thstk \vdash (\txstk, \h, \evset) , \pass{\txvar}{\expr} \ \toL \  (\txstk \remapsto{\txvar}{\val}, \h, \evset) , \pskip
    }{%
        \evalE[\thstk \uplus \txstk]{\expr} = \val
        && \txvar \in \dom(\txstk)
    }
\]

\[
    \infer[\rl{TWrite}]{%
        \thstk \vdash (\txstk, \h, \evset), \pmutate{\expr_{1}}{\expr_{2}} \ \toL \  (\txstk, \h \remapsto{\addr}{\val}, \evset \flushW (\etW, \addr, \val)) , \pskip
    }{%
        \evalE[\thstk \uplus \txstk]{\expr_{1}} = \addr 
        && \evalE[\thstk \uplus \txstk]{\expr_{2}} = \val 
    }
\]

\[
    \infer[\rl{TRead}]{
        \thstk \vdash (\txstk, \h, \evset) , \pderef{\txvar}{\expr} \ \toL \  (\txstk\remapsto{\txvar}{\val}, \h, \evset \flushR (\etR, \addr, \val)), \pskip
    }{
        \evalE[\thstk \uplus \txstk]{\expr} = \addr
        && \h(\addr) = \val 
    }
\]

\[
    \infer[\rl{TAssume}]{%
        \thstk \vdash (\txstk, \h, \evset), \passume{\expr} \ \toL \  (\txstk, \h, \evset), \pskip
    }{%
        \evalE[\thstk \uplus \txstk]{\expr} = 0
    }
\]

\[
    \infer[\rl{TReturn}]{%
        \thstk \vdash (\txstk, \h, \evset), \preturn{\expr} \ \toL \  (\txstk\rmto{\ret}{\val}, \h, \evset), \pskip
    }{ 
        \val = \evalE[\thstk \uplus \txstk]{\expr}
    }
\]

\[
    \infer[\rl{TChoise}]{%
        \thstk \vdash (\txstk, \h, \evset) , \trans_{1} \pchoice \trans_{2} \ \toL \  (\txstk, \h, \evset) , \trans'
    }{
        \trans' \in \Set{\trans_{1}, \trans_{2}}
    }
\]

\[
    \infer[\rl{TLoop}]{%
        \thstk \vdash (\txstk, \h, \evset),  \trans\prepeat \ \toL \  (\txstk, \h, \evset), \pskip \pchoice (\trans \pseq \trans\prepeat)
    }{}
\]


\[
    \infer[\rl{TSeqSkip}]{%
        \thstk \vdash (\txstk, \h, \evset), \pskip \pseq \trans \ \toL \  (\txstk, \h, \evset), \trans
    }{%
    }
\]

\[
    \infer[\rl{TSeq}]{%
        \thstk \vdash (\txstk, \h, \evset), \trans_{1} \pseq \trans_{2} \ \toL \  (\txstk', \h', \evset'), \trans_{1}' ; \trans_{2}
    }{%
        \thstk \vdash (\txstk, \h, \evset), \trans_{1} \ \toL \  (\txstk', \h', \evset'), \trans_{1}'
    }
\]

\hrule\vspace{5pt}
\caption{The transaction operational semantics}
\label{fig:transaction_semantics}
\end{figure}



\begin{defn}[Abstract executions]
\label{def:abs-exec}
An abstract execution is a tuple $\aexec = (\tx, \po, \vis, \ar) \in \Aexecs$, where the follows hold,

\begin{itemize}
\item
the \emph{program order} $\po \subseteq \dom(\tx) \times \dom(\tx)$ is the union of disjoint, strict total orders \( \po_{i} \).
That is, there exists a partition $\Set{ \dom(\tx)_{i} }_{i \in I}$ of $\dom(\tx)$ such that $\po = \bigcup_{i \in I} \po_{i}$, where $\po_{i}$ is a strict, total order over $\tx_i$%
\footnote{Recall that a relation $R \subseteq A \times A$ is a strict partial order if it is irreflexive and transitive.
It is a strict total order if for any $a_1, a_2 \in A$, either $a_1 = a_2$, $(a_1, a_2) \in R$ or $(a_2, a_1) \in R$.}.


\item 
$\vis \subseteq \dom(\tx) \times \dom(\tx)$ is a strict, partial order.
%\footnote{Recall that a relation $R \subseteq A \times A$ is transitive if for any \( a_{1}, a_{2}, a_{3}\) such that \( (a_{1}, a_{2} ) \in R\) and \( (a_{2}, a_{3} ) \in R \) then \( (a_{1}, a_{3} ) \in R \)}

\item 
$\ar \subseteq \dom(\tx) \times \dom(\tx)$ is a strict, total order such that $\vis \subseteq \ar$ and \( \po \subseteq \ar\).

\end{itemize}

\end{defn}


\begin{defn}[Thread transition labels]
\label{def:label}
Assume a countably infinite set of thread identifiers $\thid,j \in \ThreadID$.
The set of \emph{thread transition labels}, $\lb \in \Translabel$, is defined by the following grammar, where $\prog$ denotes a program (\defin\ref{def:language}), the $\tsid$ demotes a transaction identifier and $\ts$ denotes a timestamp (\defin\ref{def:timestamp_heaps}):
\[
	\iota \in \Translabel ::= \lbID \mid \lbC{\tsid} \mid \lbF{\thid,\prog} \mid \lbJ{\thid,\stk}
\]
\end{defn}


\begin{defn}[Runtime abstract executions]
\label{def:run-abs-exec}
An runtime abstract execution \( \aexecrun = (\tx, \setthid, \hat{\po}, \vis, \ar) \in \Aexecrun \) extends the abstract execution \( \aexec = (\tx, \po, \vis, \ar) \) (\defref{def:abs-exec}) with a set of (runtime) threads \( \setthid \).
The \emph{runtime program order} \( \hat{\po}\)  extends the \( \po \) by allowing any transaction \( \tsid \) relating to any thread \( \thid \in \setthid \).
This is, \( \hat{\po} \subseteq \dom(\tx) \times \setthid \land \po \subseteq \hat{\po} \).

The function that convert runtime abstract executions to abstract executions, \( \eraseAEX{.}: \Aexecrun \to \Aexecs \), is defined as the follows, 
\[
    \begin{rclarray}
        \eraseAEX{(\tx, \setthid, \hat{\po}, \vis, \ar)} & \defeq & (\tx, \hat{\po} \setminus \Setcon{(\txid, \thid)}{ \txid \in \dom(\tx) \land \thid \in \setthid}, \vis, \ar)
    \end{rclarray}
\]
\end{defn}
\ac{Non-sequitur: first you introduce a semantic object (abstract executions), then you switch to an argument about syntax (transition labels), then you get 
back at semantic definitions (run-time abstract executions).}
\ac{An abstract execution is a run-time abstract execution where $\setthid = \emptyset$; you can just say that and get rid of \defin\ref{def:abs-exec}.}

\begin{defn}[Consistency Models]
\label{def:consistency-models}
\emph{Consistency models} are define a set of of tuple, \( \como = (\respo, \conguar) \in \Como\), including \emph{resolution policies} and \emph{consistency guarantees}.
\emph{Resolution policy} \( \respo \) is a function \( \respo \in \ResPos : \Aexecs \times \powerset{\TxID} \times \Addr \to \powerset{\Val}\) that decides the observable values given the set of visible transactions.
\emph{Consistency guarantee} is a function \( \conguar \in \ConGuar : \aexec \to \powerset{\dom(\aexec\projection{\tx}) \times \dom(\aexec\projection{\tx})}\).

The order \( \ordCOM \)  between two consistency model \( \como_{1}, \como_{2} \) is defined as the follows,
\[
\begin{rclarray}
    (\respo_{1}, \conguar_{1}) \ordCOM (\respo_{2}, \conguar_{2}) & \iffdef & 
    \begin{array}[t]{@{}l@{}}
    \for{\aexec, \txidset, \addr} \\
    \quad \respo_{2}(\aexec, \txidset, \addr) \subseteq \respo_{1}(\aexecrun, \txidset, \addr) \land \conguar_{1}(\aexec) \subseteq  \conguar_{2}(\aexec)
    \end{array} \\
\end{rclarray}
\]
Then, the bottom element is \( \btmCOM \defeq (\lambda (\aexecrun, \txidset, \addr ) \ldotp \Val, \lambda (\po, \vis, \ar ) \ldotp \emptyset) \).
\end{defn}

\begin{example}[Last write win]
\[
\begin{rclarray}
        \respo_{LWW}(\aexec, \txidset, \addr) & \defeq & 
        \Setcon{\val}{%
            \exsts{\ar = \aexec\projection{\ar}}
            \Set{(\etW, \addr, \val)} = \max_{\ar}\Setcon{\txid}{\txid \in \txidset \land (\etW, \addr, \stub) \in \tx(\txid) } \\
            \quad {} \lor \emptyset = \max_{\ar}\Setcon{\txid}{\txid \in \txidset \land (\etW, \addr, \stub) \in \tx(\txid) } \land v = 0
        }\\
\end{rclarray}
\]
\end{example}

\begin{example}[Write-write conflict]
\[
\begin{rclarray}
        \conguar_{WW}(\aexec) & \defeq & \Setcon{(\txid, \txid')}{ \exsts{ \addr } (\etW, \addr, \stub) \in \aexec\projection{\tx}(\txid) \land (\etW, \addr, \stub) \in \aexec\projection{\tx}(\txid') \land (\txid, \txid') \in \aexec\projection{\ar} } \\
\end{rclarray}
\]
\end{example}

Given two sets of relations \( A \) and \( B \), the notation \( A ; B \) denotes that \( A;B \defeq \Setcon{(a,b)}{(a,c) \in A \land (c,b) \in B} \).

\begin{example}[Serialisibility(SER)]
\[
    \begin{rclarray}                                   
        \respo_{SER} & \defeq & \respo_{LWW} \\
        \conguar_{SER}(\aexec) & \defeq & \aexec\projection{\ar} \\
    \end{rclarray}                                                      
\]
\end{example}
%\ac{Why $\como_{SER}$ and not $\respo_{SER}?$ Also, the resolution policy is the last write wins, which you need to define only once.}

\begin{example}[Snapshot isolation(SI)]
\[
    \begin{rclarray}                                   
        \respo_{SI} & \defeq & \respo_{LWW} \\
        \conguar_{SI}(\aexec) & \defeq & ( \aexec\projection{\ar} ; \aexec\projection{\vis} )  \cup \conguar_{WW}(\aexec) \\
    \end{rclarray}
\]
\end{example}
%\ac{Why not just say that $\conguar_{SI}(\aexec) = \aexec\projection{\vis} ; \aexec\projection{\ar}$? Also, you are missing 
%write conflict detection ($\conguar_{\mathsf{WWconf}} = \bigcup_{\addr \in \Addr} [\mathsf{Write}_\addr] ; \aexec\projection{\ar} ; [\mathsf{Write}_\addr]$.}

\begin{example}[Parallel snapshot isolation(PSI)]
\[
    \begin{rclarray}                                   
        \respo_{PSI} & \defeq & \respo_{LWW} \\
        \conguar_{PSI}(\aexec) & \defeq & ( \aexec\projection{\vis} ; \aexec\projection{\vis} ) \cup \conguar_{WW}(\aexec) \\
    \end{rclarray}
\]
\end{example}

\begin{defn}[Thread semantics]
\label{def:thread_semantics}
Given the thread identifiers $\thid,j \in \ThreadID$.
The set of \emph{intermediate programs}, $\iprog \in \IntermediatePrograms$, is defined by the following grammar:
%
\[
    \iprog ::= \prog \mid \iprog \pseq \pwait{\thid}
\]
%
Given the set of thread stacks \( \stk \in \Stacks (\defref{def:stacks}) \) and runtime abstract executions (\defref{def:run-abs-exec}), the \emph{per-thread operational semantics} of programs:
%
\[
\begin{rclarray}
	\toT{} & : &
    \begin{array}[t]{@{}l@{}}
    \Como \times \ThreadID 
    \times \\
	\quad \left( ( \ThdStacks \times \Aexecrun ) \times \IntermediatePrograms \right) 
	\times  \Translabel \times
	\left( ( \ThdStacks \times \Aexecrun ) \times \IntermediatePrograms \right) 
    \end{array}
\end{rclarray}
\]
%
is defined in \fig\ref{fig:thread_semantics}.
\end{defn}

The \rl{PCommit} rule states that a transaction prophesies a starting timestamp $\ts_s$ (at which point it takes a snapshot $\fph_s$ and runs locally), and an ending timestamp $\ts_e$ (at which point the transaction is successfully committed as ensured by the $\cancommitName$ predicate).

The \rl{Par} rule forks a new thread and inserts the appropriate joining point by appending the auxiliary \( \pwait{\thid} \) operation, where $\thid$ denotes the identifier of the newly forked thread. 
The \rl{Wait} rule dually awaits the termination of thread $\thid$ and subsequently updates its timestamp to the maximum value between its own timestamp and that of $\thid$.
Note that these two rules are labelled with the $\lbF{\thid, \prog}$ and $\lbJ{\thid, \ts}$ which are used by the semantics of the thread pool described shortly.

\begin{figure}
%
\hrule
%
\[
    \infer[\rl{Commit}]{%
        (\respo, \conguar), \thid \vdash ( \thstk, \aexecrun ), \ptrans{\trans} \ \toT{\lbC{\tsid}} \ ( \thstk\rmto{\ret}{\txstk(\ret)}, \aexecrun' ) , \pskip
    }{%
        \begin{array}{c}
            \pred{fresh}{\aexecrun, \txid}
            %\quad \txidset \in \addpotvis{\aexecrun, \thid}
            \quad \txidset \subseteq \dom(\aexecrun\projection{\tx})
            \quad \fph \in \obsstate{\aexecrun, \txidset, \respo} \\
            %\quad \fph = \lambda \addr \ldotp  (\respo(\eraseAEX{\aexecrun}, \txidset , \addr), \emptyset) \\
            \thstk \vdash (\emptyset, \h, \emptyset) , \trans \ \toL^{*} \  (\txstk, \h', \evset) , \pskip 
            %\quad \evset = \getevent{\fph, \fph'}
            \quad \aexecrun' = \newaexec{\aexecrun, \thid, \evset, \txid, A, \conguar }
        \end{array}
    }
\]

%\ac{I believe that $\addpotvis{}$ is obsolete; why not just take a subset of $\aexec\projection{\mathcal{T}}$?}
%\ac{Same for $\obsstate{}$: what about $\lambda \addr.(\respo(\eraseAEX{\aexecrun}, A , \addr), \emptyset)$? - 
%this requires changing the last write win policy so that at least one value is always returned by $(\respo(\eraseAEX{\aexecrun}, A, \addr)$.}

\[
    \infer[\rl{PAssign}]{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \passign{\thvar}{\expr} \ \toT{\lbID} \  ( \thstk\rmto{\thvar}{\val}, \aexecrun  ) , \pskip
    }{
        \val = \evalE[\thstk]{\expr}
    }
\]

\[
    \infer[\rl{PIncTime}]{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \passume{\expr} \ \toT{\lbID} \  ( \thstk, \aexecrun ) , \pskip
    }{%
        \evalE[\thstk]{\expr} = 0
    }
\]

\[
    \infer[\rl{PChoise}]{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \prog_{1} \pchoice \prog_{2} \ \toT{\lbID} \  ( \thstk, \aexecrun ) , \prog'
    }{
        \prog' \in \Set{\prog_{1}, \prog_{2}}
    }
\]

\[
    \infer[\rl{PLoop}]{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \prog\prepeat \ \toT{\lbID} \  ( \thstk, \aexecrun ) , \pskip \pchoice (\prog \pseq \prog\prepeat)
    }{}
\]

\[
    \infer[\rl{PSeqSkip}]{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \pskip \pseq \iprog \ \toT{\lbID} \  ( \thstk, \aexecrun ) , \iprog
    }{}
\]

\[
    \infer[\rl{PSeq}]{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \iprog_{1} \pseq \iprog_{2} \ \toT{\lb} \ ( \thstk', \aexecrun' ) , {\iprog_{1}}' \pseq \iprog_{2}
    }{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \iprog_{1} \ \toT{\lb} \  ( \thstk', \aexecrun' ) , {\iprog_{1}}' 
    }
\]

\[
    \infer[\rl{PPar}]{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \prog_{1} \ppar \prog_{2} \ \toT{\lbF{\thid', \prog_{2}}} \  ( \thstk, \aexecrun' ) , \prog_{1} \pseq \pwait{\thid'}
    }{
        \aexecrun' = \func{extend\_thread}{\aexecrun, \thid, \thid'}
    }
\]

\[
    \infer[\rl{PWait}]{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \pwait{\thid'} \ \toT{\lbJ{\thid', \thstk'}} \  (  \thstk_{1} \uplus \thstk_{2} \uplus \thstk_{f}, \aexecrun' ) , \pskip 
    }{
        \thstk = \thstk_{1} \uplus \thstk_{f}
        && \thstk' = \thstk_{2} \uplus \thstk_{f}
        && \aexecrun = \func{erase\_thread}{\aexecrun', \thid'}
    }
\]
 
where,
\[
\begin{rclarray}                                 
    %\addpotvisName{} & : & \Aexecrun \times \ThreadID \parfun \powerset{\powerset{\TxID}} \\
    %\addpotvis{\aexecrun, \thid} & \defeq  &  
    %\begin{cases}
        %\powerset{\dom(\aexecrun\projection{\tx})} & \thid \in \aexecrun\projection{\setthid} \\
        %\text{undefined} & \text{otherwise} \\
    %\end{cases} \\
%
%
    \consis{\aexecrun, \txid, \thid, \conguar} & \defeq & 
    \begin{array}[t]{@{}l@{}}
        \thid \in \aexecrun\projection{\setthid} \land  \for{ \txid' } ( (\txid', \txid) \in \conguar(\eraseAEX{\aexecrun}) \implies (\txid, \txid) \in \aexecrun\projection{\vis} ) \\
    \end{array} \\
    \newaexecName & : & 
    \left(\begin{array}{l}
        \Aexecrun \times \ThreadID \times \TxID \times \\
        \quad  \powerset{\Events} \times \powerset{\TxID} \times \ConGuar \end{array} \right)
        \parfun \Aexecrun \\
    \newaexec{\aexecrun, \thid, \evset, \txid, \txidset, \conguar } & \defeq & 
    \begin{cases}
        \aexecrun' & \consis{\aexecrun', \thid, \txid, \conguar} \\
        \text{undefined} & \text{otherwise} \\
    \end{cases} \\
    \text{where} \ \aexecrun' & \equiv & 
        \left(
        \begin{array}{@{}l@{}}
            \aexecrun\projection{\tx} \uplus \Set{\txid \mapsto \evset},
            \aexecrun\projection{\setthid}, 
            \aexecrun\projection{\hat{\po}} \uplus \Setcon{(\txid', \txid)}{(\txid', \thid) \in \aexecrun\projection{\hat{\po}}} \uplus \Set{(\txid, \thid)}, \\
            \quad \aexecrun\projection{\vis} \uplus \Setcon{(\txid', \txid)}{\txid' \in \txidset}, 
            \aexecrun\projection{\ar} \uplus \Setcon{(\txid', \txid)}{\txid' \in \dom(\aexecrun\projection{\tx})}
        \end{array}
        \right) \\
%	
%
    \obsstateName & : & \Aexecrun \times \powerset{\TxID} \times \ResPos \parfun \powerset{\FPHeaps} \\
    \obsstate{\aexecrun, \txidset, \respo} & \defeq & 
    \Setcon{%
        \h
    }{%            
        \for{\addr, \val}  \val \in \respo(\eraseAEX{\aexecrun}, \txidset, \addr) \implies \h(\addr) = \val \\
    } \\
%
%              
	\pred{fresh}{\aexecrun, \tsid}  & \defeq & \neg \tsid \in \dom(\aexecrun\projection{\tx}) \\
%
%
    %\geteventName & : & \FPHeaps \times \FPHeaps \to \powerset{\Events} \\
    %\getevent{\fph, \fph'} & \defeq & 
    %\begin{array}[t]{@{}l@{}}
        %\Setcon{ (\etW, \addr, \val ) }{ \exsts{ \fp } \fph(\addr) = ( \val, \fp ) \land \fpW \in \fp} \\
        %\quad {} \uplus \Setcon{ (\etR, \addr, \val ) }{ \exsts{ \fp } \fph(\addr) = (\val, \stub) \land \fph(\addr) = ( \stub, \fp ) \land \fpR \in \fp} \\ 
    %\end{array} \\
%
%
    \func{extend\_thread}{\aexecrun, \thid, \thid'} & \defeq & (\aexecrun\projection{\tx}, \aexecrun\projection{\setthid} \uplus \Set{\thid'}, \aexecrun\projection{\hat{\po}} \uplus \Setcon{(\txid, \thid')}{ (\txid, \thid) \in \aexecrun\projection{\hat{\po}}}, \aexecrun\projection{\vis}, \aexecrun\projection{\ar}) \\
    \func{erase\_thread}{\aexecrun, \thid} & \defeq & (\aexecrun\projection{\tx}, \aexecrun\projection{\setthid} \setminus \Set{\thid}, \aexecrun\projection{\hat{\po}} \setminus \Setcon{(\txid, \thid)}{ \txid \in \dom(\aexecrun\projection{\tx})}, \aexecrun\projection{\vis}, \aexecrun\projection{\ar})                                                                                                                                                                                                                   
    \end{rclarray}
\]
\hrule
\caption{Per-thread operational semantics}
\label{fig:thread_semantics}
\end{figure}

In order to model concurrency, we use thread pools.
A thread pool is modelled as a finite partial map from thread identifiers to triples of the form $(\thstk, \iprog)$. That is, each thread is associated with a thread stack $\thstk$ and a  intermediate program $\iprog$ to be executed. 

\begin{defn}[Thread pools]
\label{def:thread_pools}
Given the sets of stacks $\Stacks$ (\defref{def:stacks}) and programs $\Programs$ (\defref{def:language}), the set of \emph{thread pools} is: $\thpl \in \TPool \eqdef \ThreadID \parfinfun \ThdStacks \times \IntermediatePrograms$.
\end{defn}
 
\begin{defn}[Thread pool semantics] 
\label{def:thread_pool_semantics}
Given the sets of timestamp heaps $\TSHeaps$ (\defin\ref{def:timestamp_heaps}), transition labels \( \Translabel \) (\defin\ref{def:label}) and thread pools $\TPool$ (\defin\ref{def:thread_pools}), the \emph{thread pool semantics}, 
%
\[
	\toG{} : \Como \times (\Aexecrun \times \TPool) \times \Translabel \times (\Aexecrun \times \TPool) 
\]
%
is defined in \fig\ref{fig:thread_pool_semantics}.
%
\end{defn}
%
The thread pool operational semantics is given in \fig\ref{fig:thread_pool_semantics}, where an arbitrary thread in the pool $\thpl$ is picked to run for one step.
If the next execution step is a thread fork, then a new thread $\thid$ is allocated in the pool to be executed with its stack copied from those of the parent (forking) thread.
Conversely, when the next execution step is the joining of thread $\thid'$, then $\thid'$ is removed from the thread pool and the stack from the thread being joined merges into the parent thread.
%
\begin{figure}
\hrule\vspace{5pt}
%
\[
    \infer[\rl{PSingle}]{%
        \como \vdash ( \aexecrun, \thpl \uplus \Set{ \thid \mapsto (\thstk, \iprog) } ) \ \toG{\lb} \  ( \aexecrun, \thpl \uplus \Set{ \thid \mapsto (\thstk', {\iprog}') } ) 
    }{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \iprog \ \toT{\lb} \  ( \thstk', \aexecrun ' ) , {\iprog}' 
        \quad \lb \in \Set{ \lbID, \lbC{\stub} }
    }
\]

\[
    \infer[\rl{PFork}]{%
        \como \vdash ( \aexecrun, \thpl \uplus \Set{ \thid \mapsto (\thstk, \iprog) } ) \ \toG{\lbF{\thid', \prog}} \  ( \aexecrun', \thpl \uplus \Set{ \thid \mapsto (\thstk', {\iprog}'), \thid' \mapsto (\thstk', \prog) } )
    }{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \iprog \ \toT{\lbF{\thid', \prog}} \  ( \thstk', \aexecrun' ) , {\iprog}' 
    }
\]

\[
    \infer[\rl{PJoin}]{%
        \como \vdash ( \aexecrun, \thpl \uplus \Set{ \thid \mapsto (\thstk, \iprog), \thid' \mapsto (\thstk', \pskip) } )  \ \toG{\lbJ{\thid',\thstk''}} \ ( \aexecrun', \thpl \uplus \Set{ \thid \mapsto (\thstk'', {\iprog}')} )
    }{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \iprog \ \toT{\lbJ{\thid',\thstk'}} \  ( \thstk'', \aexecrun' ) , {\iprog}' 
    }
\]
%
\hrule\vspace{5pt}
\caption{Thread pool semantics}
\label{fig:thread_pool_semantics}
\end{figure}

\subsection{Soundness and Completeness}

\begin{defn}[Valid abstract executions]
\label{def:valid-aexec}
Given a consistency model \( (\respo, \conguar) = \como \in \Como \), the set of all the valid abstract executions under the model is defined as the follows,
\[
    \begin{rclarray}
        \evalCOM{(\respo, \conguar)} & \defeq & 
        \Setcon{%
            \aexec = (\tx, \po, \vis, \ar)
        }{%
            \conguar(\aexec) \subseteq \vis 
            \land \for{\txid, \addr, \val}  \\
            \qquad (\etW, \addr, \val) \in \tx(\txid) 
            \implies \val \in \respo(\aexec, \vis\projection{\txid}, \addr)
        }
    \end{rclarray}
\]
\end{defn}    

\begin{lem}[Consistency models monotonicity]
\label{lem:consistency-include}
\[
    \como_{1} \ordCOM \como_{2} \implies \evalCOM{\como_{2}} \subseteq \evalCOM{\como_{1}}
\]
\end{lem}
\begin{proof}
For any abstract execution \( \aexec \) that satisfies the stronger consistency model \( \como_{2} \), we have \( \conguar_{2}(\aexec) \subseteq \vis  \) and \( \for{\txid, \addr, \val} (\etW, \addr, \val) \in \tx(\txid) \implies \val \in \respo_{2}(\aexec, \vis\projection{\txid}, \addr) \) by the \defref{def:valid-aexec}.
Because \( \conguar_{1}(\aexec)  \subseteq \conguar_{2}(\aexec)  \)  and \( \respo_{2}(\aexec, \vis\projection{\txid}, \addr) \subseteq \respo_{1}(\aexec, \vis\projection{\txid}, \addr)\) by \defref{def:consistency-models}, we have \( \aexec \in \evalCOM{\como_{1}}\).
\end{proof}

\begin{lem}[Semantics monotonicity]
\[
\begin{array}{@{}l@{}}
    \for{\como_{1}, \como_{2}, \thid, \aexecrun, \aexecrun', \iprog, \iprog', \thstk, \thstk', \lb}  \\
    \quad \como_{2}, \thid \vdash ( \aexecrun, \thstk ), \iprog \toT{\lb} ( \aexecrun', \thstk' ), \iprog'
    \land \como_{1} \ordCOM \como_{2} \\
    \quad \implies \como_{1}, \thid \vdash ( \aexecrun, \thstk ), \iprog \toT{\lb} ( \aexecrun', \thstk' ), \iprog'
\end{array}
\]
\end{lem}
\begin{proof}
We prove it by induction on the rules.
The only interesting case is the  \rl{Commit} rule, especially given \( \aexecrun, \txidset, \thid \), we need to prove the follows,
\begin{itemize}
\item All the observable states under the stronger consistency model \( \como_{2} \), they can be observed under the weaker one \( \como_{1} \).
This is, \( \obsstate{\aexecrun, \txidset, \respo_{2}} \subseteq  \obsstate{\aexecrun, \txidset, \respo_{1}} \).

For any fingerprint heap \( \fph \) under stronger consistency model \( \como_{1}\), \ie \( \fph \in \obsstate{\aexecrun, \txidset, \respo_{2}} \), from the definition in \figref{fig:thread_semantics}, we have \( \for{\addr, \val}  \val \in \respo_{2}(\eraseAEX{\aexecrun}, \txidset, \addr) \implies \fph(\addr) = (\val, \emptyset) \).
Since \( \respo_{2}(\eraseAEX{\aexecrun}, \txidset, \addr) \subseteq \respo_{1}(\eraseAEX{\aexecrun}, \txidset, \addr) \), therefore \( \for{\addr, \val}  \val \in \respo_{1}(\eraseAEX{\aexecrun}, \txidset, \addr) \implies \fph(\addr) = (\val, \emptyset) \) also holds, so that \( \fph \in \obsstate{\aexecrun, \txidset, \respo_{1}} \).

\item If the new runtime abstract execution exists under the stronger concurrency model \( \como_{2} \), it should also exist under weaker one.
This means, \( \consis{\aexecrun, \txid, \thid, \conguar_{2}} \implies \consis{\aexecrun, \txid, \thid, \conguar_{1}} \).

Assume a transaction \( \txid' \) such that \( (\txid', \txid) \in \conguar_{2}(\eraseAEX{\aexec}) \) therefore by the definition, we have \( (\txid', \txid) \in \aexecrun\projection{\vis} \).
Since \( \conguar_{1}(\eraseAEX{\aexec}) \subseteq \conguar_{2}(\eraseAEX{\aexec})\), so that \( (\txid', \txid) \in \conguar_{1}(\eraseAEX{\aexec}) \implies (\txid', \txid) \in \aexecrun\projection{\vis} \) also holds.
Therefore we have \( \consis{\aexecrun, \txid, \thid, \conguar_{2}} \implies \consis{\aexecrun, \txid, \thid, \conguar_{1}} \).
\end{itemize}
\end{proof}


\begin{thm}[Soundness of the semantics]
For any runtime abstract abstract execution \( \aexecrun \) that satisfies a certain consistency model \( \como \), and if it takes one step under consistency model \( \como \) to another state \( \aexecrun' \), the new state should also satisfy the consistency model.
 \[
 \begin{array}{@{}l@{}}
    \for{\como, \thid, \aexecrun, \aexecrun', \thstk, \thstk', \iprog, {\iprog}', \lb} \\
    \qquad \eraseAEX{\aexecrun} \in \evalCOM{\como}
    \land \como, \thid \vdash (\aexecrun, \thstk), \iprog \toT{\lb} (\aexecrun', \thstk'), {\iprog}' \implies \eraseAEX{\aexecrun'} \in \evalCOM{\como}
 \end{array}
 \]
\end{thm}

\begin{thm}[Completeness of the semantics]
For any runtime abstract abstract execution \( \aexecrun \) that satisfies a certain consistency model \( \como \), and if it takes one step under the weakest consistency model \( \btmCOM \) to another state \( \aexecrun' \), and if the new state satisfies the consistency model \( \como \), there is a corresponding step of the semantics under consistency model \( \como \).
 \[
 \begin{array}{@{}l@{}}
    \for{\como, \thid, \aexecrun, \aexecrun', \thstk, \thstk', \iprog, {\iprog}', \lb} \\
    \qquad \btmCOM, \thid \vdash (\aexecrun, \thstk), \iprog \toT{\lb} (\aexecrun', \thstk'), {\iprog}' \land \eraseAEX{\aexecrun'} \in \evalCOM{\como} \\
    \qqquad \implies \como, \thid \vdash (\aexecrun, \thstk), \iprog \toT{\lb} (\aexecrun', \thstk'), {\iprog}' 
 \end{array}
 \]
\end{thm}
