
\section{semantics\label{sec:semantics}}

Assume that heap and stack are initialised to zero.

\[
    \begin{rclarray}
        \loc \in \Loc & \defeq & \Nat \\
        \val \in \Val & \defeq & \Nat \uplus \Loc \\
        \Var & \defeq & \Set{ \vx, \vy, \dots } \\
        \ts \in \Timestamp & \defeq & \Nat \\
        \hp \in \Heap & \defeq & \Loc \parfun \Val \\
        \stk \in \Stack & \defeq & \Var \to \Val \\
        \rs \in \Readset, \ws \in \Writeset & \defeq & \powerset{\Loc} \\
        \lstt = (\hp, \stk, \rs, \ws ) \in \Localstate & \defeq & \Stack \times \Heap \times \Readset \times \Writeset \\
        \op \in \Operation & \defeq & \Set{\opr, \opw} \\
        \settrans \subseteq \TransID & \defeq & \Set{ \alpha , \beta, \dots } \\
        \tshp \in \Timestampheap & \defeq & \Loc \parfun ( \Timestamp \parfun \Val \times \Operation \times \TransID) \\
        \ThreadID & \defeq & \Set{ i , j, \dots } \\
        (\tshp, \stk, \ts) \in \Threadstate & \defeq & \Timestampheap \times \Stack \times \Timestamp \\
        \tdpl \in \Threadpool & \defeq & \ThreadID \parfun \Stack \times \Timestamp \times \prog \\
        \stt \in \State & \defeq & \Timestampheap \times \Threadpool \\
    \end{rclarray}
\]

No side effect of evaluation of arithmetic expression.

\[
    \begin{syntax}{\texpr}
              \val \quad            |
        \quad \var \quad            |
        \quad \texpr + \texpr \quad |
        \quad \texpr * \texpr \quad |
        \quad \dots 
    \end{syntax}
\]

No side effect of evaluation of boolean expression.

\[
    \begin{rclarray}
        \eval{\val}_{\stk} & \defeq & \val \\
        \eval{\var}_{\stk} & \defeq & \stk(\val) \\
        \eval{\texpr_{1} + \texpr_{2}}_{\stk} & \defeq & \eval{\texpr_{1}}_{\stk} + \eval{\texpr_{2}}_{\stk}   \\
        \eval{\texpr_{1} * \texpr_{2}}_{\stk} & \defeq & \eval{\texpr_{1}}_{\stk} * \eval{\texpr_{2}}_{\stk}  
    \end{rclarray}
\]

\[
    \begin{syntax}{\tbool}
              \true \quad                  |
        \quad \false \quad                 |
        \quad \texpr = \texpr \quad        |
        \quad \texpr < \texpr \quad        |
        \quad \boolnot \tbool \quad        |
        \quad \tbool \booland \tbool \quad |
        \quad \tbool \boolor \tbool \quad  |
        \quad \dots 
    \end{syntax}
\]

\[
    \begin{rclarray}
        \eval{\true}_{\stk}& \defeq & \true \\
        \eval{\false}_{\stk} & \defeq & \false \\
        \eval{\texpr_{1} = \texpr_{2}}_{\stk} & \defeq & \eval{\texpr_{1}}_{\stk} = \eval{\texpr_{2}}_{\stk}   \\
        \eval{\texpr_{1} < \texpr_{2}}_{\stk} & \defeq & \eval{\texpr_{1}}_{\stk} < \eval{\texpr_{2}}_{\stk}   \\
        \eval{\boolnot \tbool}_{\stk} & \defeq & \neg \eval{\tbool}_{\stk} \\
        \eval{\tbool_{1} \booland \tbool_{2}}_{\stk} & \defeq & \eval{\tbool_{1}}_{\stk} \land \eval{\tbool_{2}}_{\stk}  \\
        \eval{\tbool_{1} \boolor \tbool_{2}}_{\stk}& \defeq & \eval{\tbool_{1}}_{\stk} \lor \eval{\tbool_{2}}_{\stk}  
    \end{rclarray}
\]

\[
    \begin{syntax}{\tcmd}
              \tskip \quad                     |
        \quad \tass{\vx}{\texpr} \quad         |
        \quad \tmutate{\texpr}{\texpr} \quad   |
        \quad \tderef{\vx}{\texpr} \quad       |
        \quad \tif{\tbool}{\tcmd}{\tcmd} \quad | \\
              \tloop{\tbool}{\tcmd} \quad      |
        \quad \tcmd \tseq \tcmd
    \end{syntax}
\]

\[
    \begin{rclarray}
        \dontcare, \dontcare, \dontcare, \dontcare, \dontcare \ \localtransfer \ \dontcare, \dontcare, \dontcare, \dontcare, \dontcare & \defeq & \Localstate \times \tcmd \times \Localstate \times \tcmd \\
    \end{rclarray}
\]

\[
    \infer[ass]{%
        \stk, \hp, \rs, \ws, \tass{\var}{\texpr} \ \localtransfer \  \stk \remapsto{\var}{\val}, \hp, \rs, \ws, \tskip
    }{%
    \eval{\texpr}_{\stk} = \val
    }
\]

\[
    \infer[mutate]{%
        \stk, \hp, \rs, \ws, \tmutate{\texpr_{1}}{\texpr_{2}} \ \localtransfer \  \stk, \hp \remapsto{\loc}{\val}, \rs, \ws \cup \Set{\loc}, \tskip
    }{%
        \eval{\texpr_{1}}_{\stk} = \loc \quad 
        \eval{\texpr_{2}}_{\stk} = \val \quad 
        \loc \in \dom(\hp)
    }
\]

\[
    \infer[deref]{%
        \stk, \hp, \rs, \ws, \tderef{\var}{\texpr} \ \localtransfer \  \stk \remapsto{\var}{\val}, \hp, \rs \cup \Set{\loc}, \ws, \tskip
    }{%
        \eval{\texpr}_{\stk} = \loc \quad 
        \val = \hp(\loc) \quad
        \loc \in \dom(\hp)
    }
\]

\[
    \infer[ifelsetrue]{%
        \stk, \hp, \tif{\tbool}{\tcmd_{1}}{\tcmd_{2}} \ \localtransfer \  \stk, \hp, \tcmd_{1}
    }{%
        \eval{\tbool}_{\stk} = \true
    }
\]

\[
    \infer[ifelsefalse]{%
        \stk, \hp, \tif{\tbool}{\tcmd_{1}}{\tcmd_{2}} \ \localtransfer \  \stk, \hp, \tcmd_{2}
    }{%
        \eval{\tbool}_{\stk} = \false
    }
\]

\[
    \infer[whiletrue]{%
        \stk, \hp, \tloop{\tbool} \tcmd \ \localtransfer \  \stk, \hp,  \tcmd \tseq \tloop{\tbool} \tcmd
    }{%
        \eval{\tbool}_{\stk} = \true
    }
\]

\[
    \infer[whilefalse]{%
        \stk, \hp, \tloop{\tbool} \tcmd \ \localtransfer \  \stk, \hp, \tskip
    }{%
        \eval{\tbool}_{\stk} = \false \quad
    }
\]

\[
    \infer[seqskip]{%
        \stk, \hp, \tskip \tseq \tcmd_{2} \ \localtransfer \  \stk, \hp, \tcmd_{2}
    }{%
    }
\]

\[
    \infer[seqnonskip]{%
        \stk, \hp, \tcmd_{1} \tseq \tcmd_{2} \ \localtransfer \  \stk', \hp', \tcmd_{1}' \tseq \tcmd_{2}
    }{%
        \stk, \hp, \tcmd_{1} \ \localtransfer \  \stk', \hp', \tcmd_{1}'
    }
\]

The semantics of transaction are interleaving of start, commit, and restart.

\[
    \begin{syntax}{\prog}
              \pemp \quad               |
        \quad \ptrans{\tcmd} \quad      |
        \quad \prog \pcond \prog \quad  |
        \quad \prept{\prog} \quad       |
        \quad \prog \pseq \prog \quad   |
        \quad \pfork{\var}{\prog} \quad |
        \quad \pjoin{\texpr}   
    \end{syntax}
\]

\[
    \begin{rclarray}
        \prog_{1} \ppar \prog_{2} & \equiv & \pfork{\var}{\prog_{1}} \pseq \prog_{2} \pseq \pjoin{\var} \\
        \tll \in \Translabel & \defeq & 
              \lid \quad                |
              \quad \lfork{\prog} \quad |
        \quad \ljoin{\thid,\ts} \\
        \dontcare, \dontcare, \dontcare, \dontcare \ \threadtransfer{ \dontcare } \ \dontcare, \dontcare, \dontcare, \dontcare & \defeq & \Threadstate \times \prog \times \Translabel \times \Threadstate \times \prog \\
    \end{rclarray}
\]

\[
    \begin{rclarray}
        \func{startstate}(\tshp,\ts) & \defeq & \lambda \loc \ldotp \tshp(\loc)(\max(\Set{\ \ts' \ \middle| \ \ts' \leq \ts \land \tshp(\ts') = (\dontcare,\wop, \dontcare) }))
    \end{rclarray}
\]

\[
    \begin{rclarray}
        \pred{allowcommit}(\tshp,\ws,\rs,\ts_{s},\ts_{e}) & \defeq & 
        \pred{atomicop}(\tshp,\ws,\rs,\ts_{s},\ts_{e}) \land {} \\
        & & \pred{consistent}(\tshp,\ws,\rs,\ts_{s},\ts_{e}) \\
        \pred{atomicop}(\tshp,\ws,\rs,\ts_{s},\ts_{e}) & \defeq  & \forall \loc \in \ws \cup \rs \ldotp \tshp(\loc)(\ts_{s})\undef \land \tshp(\loc)(\ts_{e})\undef \\
        \pred{consistent}(\tshp,\ws,\rs,\ts_{s},\ts_{e}) & \defeq & \forall \ts \in [\ts_{s},\ts_{e}], \loc \in \ws \ldotp \tshp(\loc)(\ts) \neq (\dontcare, \wop, \dontcare) \land {} \\
                                                       & & \exists \ts_{min} = \min(\Set{\ts'' \ \middle| \ \ts'' \geq \ts_{e} \land \tshp(l)(\ts'')\isdef}) \ldotp \\
                                                       & & \ts_{min} \neq \bot \implies \tshp(\loc)(\ts_{min}) = (\dontcare, \wop, \dontcare) \\
        \func{commit}(\tshp,\hp,\ws,\rs,\ts_{s},\ts_{e}) & \defeq &
        \lambda \loc \ldotp
        \begin{funcarray}
            \tshp(\loc) & \loc \notin \ws \cup \rs \\
            \tshp(\loc) \uplus \Set{ \ts_{e} \mapsto (\hp(\loc),\wop,\tsid)} & \loc \in \ws \\
            \tshp(\loc) \uplus \Set{ \ts_{s} \mapsto (\hp(\loc),\rop,\tsid)} & \loc \in \rs \\
        \end{funcarray} \\
        & & \texttt{where} \  \tsid \notin \Set{\tshp(\loc)(\ts)\projection{3} \ \middle| \ \loc \in \dom(\tshp) \land \ts \in \dom(\tshp(\loc))} \\
    \end{rclarray}
\]

\[
    \infer[commit]{%
        \tshp, \stk, \ts, \ptrans{\tcmd} \ \threadtransfer{\lid} \  \tshp', \stk', \ts_{e}, \pemp
    }{%
        \begin{array}{c}
            \ts_{s} \geq \ts \quad \stk, \func{startstate}(\tshp, \ts_{s}), \emptyset, \emptyset \localtransfer^{*} \stk', \hp, \rs, \ws \\
            \pred{allowcommit}(\tshp,\ws,\rs,\ts_{s},\ts_{e}) \quad \ts_{e} > \ts_{s} \quad \tshp' = \func{commit}(\tshp,\hp,\ws,\rs,\ts_{s},\ts_{e})
        \end{array}
    }
\]

\[
    \infer[choiceleft]{%
        \tshp, \stk, \ts, \prog_{1} \pcond \prog_{2} \ \threadtransfer{\lid} \  \tshp, \stk, \ts, \prog_{1}
    }{%
    }
\]

\[
    \infer[choiceright]{%
        \tshp, \stk, \ts, \prog_{1} \pcond \prog_{2} \ \threadtransfer{\lid} \  \tshp, \stk, \ts, \prog_{2}
    }{%
    }
\]

\[
    \infer[norep]{%
        \tshp, \stk, \ts, \prept{\prog} \ \threadtransfer{\lid} \  \tshp, \stk, \ts, \pemp
    }{%
    }
\]

\[
    \infer[rep]{%
        \tshp, \stk, \ts, \prept{\prog} \ \threadtransfer{\lid} \  \tshp, \stk, \ts, \prog \pseq \prept{\prog}
    }{%
    }
\]

\[
    \infer[seqskip]{%
        \tshp, \stk, \ts, \pemp \pseq \prog \ \threadtransfer{\lid} \  \tshp, \stk, \ts, \prog
    }{%
    }
\]

\[
    \infer[seqnoskip]{%
        \tshp, \stk, \ts, \prog_{1} \pseq \prog_{2} \ \threadtransfer{\tll} \  \tshp', \stk', \ts', \prog_{1}' \pseq \prog_{2}
    }{%
        \tshp, \stk, \ts, \prog_{1} \ \threadtransfer{\tll} \  \tshp', \stk', \ts', \prog_{1}' 
    }
\]

\[
    \infer[fork]{%
        \tshp, \stk, \ts, \pfork{\var}{\prog} \ \threadtransfer{\lfork{\thid,\prog}} \  \tshp, \stk\remapsto{\var}{\thid}, \ts, \pemp 
    }{%
    }
\]

\[
    \infer[join]{%
        \tshp, \ts, \pjoin{\texpr} \ \threadtransfer{\ljoin{\eval{\texpr}_{\stk},\ts'}} \  \tshp, \max\Set{\ts,\ts'}, \pemp 
    }{%
    }
\]

\[
    \begin{rclarray}
        \dontcare, \dontcare \ \globaltransfer{ \dontcare } \ \dontcare, \dontcare & \defeq & \State \times \Translabel \times \State  \\
    \end{rclarray}
\]

\[
    \infer[single]{%
        \tshp, \tdpl \uplus \Set{ \thid \mapsto (\stk, \ts, \prog) } \ \globaltransfer{\tll} \  \tshp', \tdpl \uplus \Set{ \thid \mapsto (\stk', \ts', \prog') }
    }{%
        \tshp, \stk, \ts, \prog \ \threadtransfer{\tll} \  \tshp', \stk', \ts', \prog' 
        \quad \tll \notin \Set{\lfork{\dontcare,\dontcare},\ljoin{\dontcare,\dontcare}}
    }
\]

\[
    \infer[fork]{%
        \tshp, \tdpl \uplus \Set{ \thid \mapsto (\stk, \ts, \prog) } \ \globaltransfer{\lfork{\thid',\prog''}} \  \tshp', \tdpl \uplus \Set{ \thid \mapsto (\stk', \ts', \prog'), \thid' \mapsto (\lambda \var \ldotp 0, \ts', \prog'') }
    }{%
        \tshp, \stk, \ts, \prog \ \threadtransfer{\lfork{\thid',\prog''}} \  \tshp', \stk', \ts', \prog' 
    }
\]

\[
    \infer[join]{%
        \tshp, \tdpl \uplus \Set{ \thid \mapsto (\stk, \ts, \prog), \thid' \mapsto (\stk', \ts'', \pemp) } \ \globaltransfer{\ljoin{\thid',\ts''}} \  \tshp', \tdpl \uplus \Set{ \thid \mapsto (\stk', \ts', \prog')}
    }{%
        \tshp, \stk, \ts, \prog \ \threadtransfer{\ljoin{\thid',\ts''}} \  \tshp', \stk', \ts', \prog' 
    }
\]

\begin{rclarray}
    (\settrans, \tvis, \tar) = \func{graph}(\tshp) & \defeq & (\Set{ \tsid \ \middle| \ \forall \loc \ldotp \tshp(\loc) = (\dontcare, \tsid, \dontcare)}, \\
                                                   & & \Set{(\tsid, \tsid') \ \middle| \ \forall \loc, \ts, \ts' \ldotp \ts < \ts' \land \tshp(\loc)(\ts) = (\dontcare, \tsid, \wop) \land \tshp(\loc')(\ts') = (\dontcare, \tsid', \rop)}, \\
                        & & \Set{(\tsid, \tsid') \ \middle| \ \forall \loc, \ts, \ts' \ldotp \ts < \ts' \land \tshp(\loc)(\ts) = (\dontcare, \tsid, \wop) \land \tshp(\loc')(\ts') = (\dontcare, \tsid', \wop)}) \\
\end{rclarray}


\begin{lem}
    \label{lem:atoic-rw}
    All the reads of a transaction happen in the same time, so do all the writes. This is 
    \( \forall \tshp, \loc, \loc', \ts, \ts', \tsid, \op \in \Set{\rop, \wop} \ldotp \tshp(\loc)(\ts) =  \tshp(\loc')(\ts') = (\dontcare, \op, \tsid) \implies \ts = \ts' \).
\end{lem}
\begin{proof}
    From the semantics.
\end{proof}

\begin{lem}
    \label{lem:read-before-write}
    All the reads of a transaction happen before all the writes. This is 
    \( \forall \tshp, \loc, \loc', \ts, \ts', \tsid \ldotp \tshp(\loc)(\ts) = (\dontcare, \rop, \tsid) \land \tshp(\loc')(\ts') = (\dontcare, \wop, \tsid) \implies \ts < \ts' \).
\end{lem}
\begin{proof}
    From the semantics.
\end{proof}

\begin{lem}
    Both \tvis\ and \tar\ have no circle.
\end{lem}
\begin{proof}
    Assume there is a circle in \(\rtvis\), says, \( \tsid_{1} \rtvis \tsid_{2} \rtvis \dots \rtvis \tsid_{n} \rtvis \tsid_{n+1} \), where \( \tsid_{1} = \tsid_{n+1} \).
    Therefore, \( \exists \loc_{1}, \loc_{2}, \dots, \loc_{n}, \loc_{n+1} \ldotp \loc_{1} = \loc_{n+1} \land \bigwedge\limits_{ 1 \leq i \leq n} \exists \ts, \ts' \ldotp \ts < \ts' \land \tshp(\loc_{i})(\ts) = (\dontcare, \tsid_{i}, \wop) \land \tshp(\loc_{i})(\ts') = (\dontcare, \tsid_{i+1}, \rop)\).
    By Lemma \ref{lem:atoic-rw}, we can defined a list of reads and writes events that is order by time: \( \List{ (\tsid_{1},\wop), (\tsid_{2},\rop), (\tsid_{2},\wop), \dots, (\tsid_{n},\wop), (\tsid_{n+1},\rop) } \).
    By the assumption, we have \( \tsid_{1} = \tsid_{n+1} \), thus this contradict Lemma \ref{lem:read-before-write}.

    Similarly for \(\rtar\), the list of write events  \( \List{ (\tsid_{1},\wop), (\tsid_{2},\wop), (\tsid_{2},\wop), \dots, (\tsid_{n},\wop), (\tsid_{n+1},\wop) } \) contradict Lemma \ref{lem:atoic-rw}.
\end{proof}

A better proof is first to flatten the heap into a list of read write events. for those events happen in the same time, we need to prove we can order then in anyway without change the result because they are complete disjointed. 
Then we order then in the location order. 
Now we can define vis and ar based on the list of events.

