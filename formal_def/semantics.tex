\section{Semantics\label{sec:semantics}}
\begin{defn}[Program values]
\label{def:program_values}
Assume a countably infinite set of \emph{addresses}, $\addr \in \Addr$. The set of \emph{program values} is $\val \in \Val \eqdef \Nat \cup \Addr$, where $\Nat$ denotes the set of natural numbers.
\end{defn}
 
\begin{defn}[Stacks]
\label{def:stacks}
Given the program values (\defref{def:program_values}) and a set of \emph{transaction variables} \( \TxVars \defeq \Set{\txvar, \dots}\), a \emph{transaction stack} is a partial function from transaction variables to values \( \txstk \in \TxStacks \defeq \TxVars \parfun \Val \).
Similarly, assuming a set of \emph{thread variables} \( \ThdVars \defeq \Set{\thvar, \dots}\), a \emph{thread stack} is defined as \( \thstk \in \ThdStacks \defeq \ThdVars \parfun \Val \).
Then, the set of \emph{stacks} is defined as the union of transaction stacks and thread stacks \( \stk \in \Stacks \eqdef \TxStacks \uplus \ThdStacks \).
\end{defn}

\begin{definition}[Heaps]
\label{def:heaps}
Given the sets of program values $\Val$  and addresses \( \Addr\)  (\defin\ref{def:program_values}), the set of \emph{heaps} is: $\h \in \Heaps \eqdef \Addr \parfinfun \Val$.
The \emph{heap composition function}, $\composeH: \Heaps \times \Heaps \parfun \Heaps$, is defined as $\composeH \eqdef \uplus$, where $\uplus$ denotes the standard disjoint function union. The \emph{ heap unit element} is $\unitH \eqdef \emptyset$, denoting a function with an empty domain.
The \emph{partial commutative monoid of  heaps} is $(\Heaps, \composeH, \{\unitH\})$.
\end{definition}

Our program, ranged over by $\prog$, are defined by an inductive grammar comprising the standard constructs of $\pskip$, sequential composition ($\prog; \prog$), non-deterministic choice ($\prog+\prog$), loops ($\prog^*$) and  parallel composition ($\prog \ppar \prog$) (\defref{def:language}).
To simulate conditional branching and loop, we also have assume (\( \passume{\expr}\)) and assignment to thread variables (\( \passign{\thvar}{\expr} \)), where \( \expr \) denotes arithmetic expressions.
Additionally, our programming language contains the \emph{transaction} construct $\ptrans{\trans}$ denoting the \emph{atomic} execution of the transaction $\trans$. 
The atomicity guarantees the execution are dictated by the underlying consistency model.
Transactions, ranged over by $\trans$, are defined by a similar inductive grammar comprising $\pskip$, non-deterministic choice, loops and sequential composition, as well as constructs for assignment, lookup and mutation. 
Transactions do \emph{not} contain the \emph{parallel} composition construct ($\ppar$) as they are to be executed atomically.
Transactions can only assign to their own variables, namely transaction variables (\defref{def:program_values}), but it can read from both the thread and transaction stacks.

\begin{defn}[Programming language]
\label{def:language}
Given the set of thread variables \( \thvar \in \ThdVars \) (\defref{def:stacks}), the set of \emph{programs}, $\prog \in \Programs$, is defined by the following grammar:
\[
    \begin{rclarray}
    \prog & ::= &
        \pskip \mid 
        \passign{\thvar}{\expr} \mid
        \passume{\expr} \mid
        \ptrans{\trans} \mid 
        \prog \pseq \prog \mid 
        \prog \pchoice \prog \mid 
        \prog\prepeat \mid
        \prog \ppar \prog 
    \end{rclarray}
\]
Given the set of thread variables \( \txvar \in \TxVars \) (\defref{def:stacks}), the $\trans \in \Transactions$ in the grammar above denotes a \emph{transaction} defined by the following grammar,
\[
    \begin{rclarray}
        \trans & ::= &
        \pskip \mid
        \pass{\txvar}{\expr} \mid
        \pderef{\txvar}{\expr} \mid
        \pmutate{\expr}{\expr} \mid
        \passume{\expr} \mid
        \preturn{\expr} \mid
        \trans \pseq \trans \mid
        \trans \pchoice \trans \mid
        \trans\prepeat
    \end{rclarray}
\]
The $\expr \in \Expressions$ denotes an \emph{arithmetic expression} defined by the grammar below with $\val \in \Val$, $\thvar \in \ThdVars$ and \( \txvar \in \TxVars \) (\defin\ref{def:program_values}).
\[
    \begin{rclarray}
        \expr & ::= &
        \val \mid
        \thvar \mid
        \txvar \mid
        \expr + \expr \mid
        \expr * \expr \mid
        \dots 
    \end{rclarray}
\]
Given a thread stack \( \thstk \in \ThdStacks  \), a transaction stack \( \txstk \in \TxStacks \) and a stack $\stk \in \Stacks$ (\defin\ref{def:stacks}), the \emph{arithmetic expression evaluation} function, $\evalE[(.)]{.}:\Expressions \times \Stacks \parfun \Val$, is defined inductively over the structure of expressions as follows: 
%
\[
    \begin{rclarray}
        \evalE{\val} & \defeq & \val \\
        \evalE[\thstk \uplus \txstk]{\thvar} & \defeq & \thstk(\thvar) \\
        \evalE[\thstk \uplus \txstk]{\txvar} & \defeq & \txstk(\txvar) \\
        \evalE{\expr_{1} + \expr_{2}} & \defeq & \evalE{\expr_{1}} + \evalE{\expr_{2}} \\
        \evalE{\expr_{1} * \expr_{2}} & \defeq & \evalE{\expr_{1}} * \evalE{\expr_{2}} \\
        \dots & \eqdef & \dots \\
    \end{rclarray}
\]
\end{defn}

\subsection{Local/Transaction Semantics}

We define the operational semantics of transactions \(\trans \in \Transactions\) with respect to a configuration of the form $(\txstk, \h, \evset)$ comprising a transaction stack, a (local) heap and a set of events that might affect other transactions.
The events are the first read and the last write of each address.

\begin{defn}[Transactions and transaction events]
\label{def:transaction-event}
\label{def:transactions}
Assume a set of \emph{transactions identifiers} \( \TxID \defeq \Set{\txid, \dots}\).
The set of \emph{transaction events} \( \Events \) is defined as the follows,
\[
\begin{rclarray}
\ETags & \defeq & \Set{\etR, \etW} \\
\ev \in \evset \subseteq \Events & \defeq  & \ETags \times \Addr \times \Val
\end{rclarray}
\]
The \emph{event tags} \( \etR \) and \( \etW \) correspond to read and write respectively.
Given above, the \emph{flush read} \( \flushR \) and \emph{flush write} \(\flushW \) operators are defined as the follows, 
\[
\begin{rclarray}
    \evset \flushR (\etR, \addr, \val) & \defeq & 
    \begin{cases}
        \evset \uplus \Set{(\etR, \addr, \val)} & (\stub, \addr, \stub) \notin \evset \\
        \evset &  \text{otherwise} \\
    \end{cases} \\
    \evset \flushW (\etW, \addr, \val) & \defeq & ( \evset \setminus \Set{(\etW, \addr, \stub)} ) \uplus \Set{(\etW, \addr, \val)} \\
\end{rclarray}
\]
The flush read \( \flushR\) includes the new read event if there is no other read or write event to the same address.
While the flush write  \( \flushW \) deletes other write events from the set and includes the new one.
Assume the following,
\[
    \begin{rclarray}
        (\etag, \addr, \stub) \compose[\ev] (\etag', \addr', \stub) & \defeq & 
        \begin{cases}
        \text{defined} & \text{ if } \addr \neq \addr' \lor \etag \neq \etag' \\
        \text{undefined} & \text{ otherwise} \\
        \end{cases}
    \end{rclarray}
\]
A set of events is valid if the compositions of any of two elements are defined,
\[
    \begin{rclarray}
        \pred{valid}{\evset} & \defeq & \for{\ev, \ev' \in \evset} (\ev \compose[\ev] \ev')\isdef
    \end{rclarray}
\]
All the valid sets of events form a PCM, \( (\Setcon{\evset}{\evset \subseteq \Events \land \pred{valid}{\evset}}, \composeE, \unitE) \) , where \( \composeE \defeq \uplus \) and \( \unitE \defeq \emptyset\).
Last, the \emph{transactions} \( \tx \in \Tx \) is defined as a finite partial function from transactions identifiers \( \TxID \) to a valid set of events,
\[
\begin{rclarray}
\tx \in \Tx & \defeq & \TxID \parfinfun \Setcon{\evset}{\evset \subseteq \Events \land \pred{valid}{\evset}}
\end{rclarray}
\]
\end{defn}

\begin{defn}[Transaction operational semantics]
Given the set of stacks including thread stacks \( \ThdStacks \) and transaction stacks \( \TxStacks \) (\defref{def:stacks}), heaps \( \Heaps \) (\defin\ref{def:heaps}) and transactions \( \Transactions \) (\defin\ref{def:language}), the \emph{operational semantics of transactions}, 
\[
\begin{rclarray}
\toL & : & \ThdStacks \times \\
& & \quad ((\TxStacks \times \Heaps \times \powerset{\Events}) \times \Transactions) \times ((\TxStacks \times \Heaps \times \powerset{\Events}) \times \Transactions)
\end{rclarray}
\]
is given in \fig\ref{fig:transaction_semantics}.
Note that arithmetic expression evaluation \( \evalE[\thstk \uplus \txstk]{\expr} \) is defined in \defref{def:language} and the flush read \( \flushR \) and flush write \( \flushW \) operators are defined in \defref{def:transactions}.
\end{defn}

\begin{figure}[!t]
\hrule\vspace{5pt}
\[	
    \infer[\rl{TAss}]{%
        \thstk \vdash (\txstk, \h, \evset) , \pass{\txvar}{\expr} \ \toL \  (\txstk \remapsto{\txvar}{\val}, \h, \evset) , \pskip
    }{%
        \evalE[\thstk \uplus \txstk]{\expr} = \val
        && \txvar \in \TxVars
    }
\]

\[
    \infer[\rl{TRead}]{
        \thstk \vdash (\txstk, \h, \evset) , \pderef{\txvar}{\expr} \ \toL \  (\txstk\remapsto{\txvar}{\val}, \h, \evset \flushR (\etR, \addr, \val)), \pskip
    }{
        \evalE[\thstk \uplus \txstk]{\expr} = \addr
        && \h(\addr) = \val 
        && \txvar \in \TxVars
    }
\]

\[
    \infer[\rl{TMutate}]{%
        \thstk \vdash (\txstk, \h, \evset), \pmutate{\expr_{1}}{\expr_{2}} \ \toL \  (\txstk, \h \remapsto{\addr}{\val}, \evset \flushW (\etW, \addr, \val)) , \pskip
    }{%
        \evalE[\thstk \uplus \txstk]{\expr_{1}} = \addr 
        && \evalE[\thstk \uplus \txstk]{\expr_{2}} = \val 
    }
\]

\[
    \infer[\rl{TAssume}]{%
        \thstk \vdash (\txstk, \h, \evset), \passume{\expr} \ \toL \  (\txstk, \h, \evset), \pskip
    }{%
        \evalE[\thstk \uplus \txstk]{\expr} = 0
    }
\]

\[
    \infer[\rl{TReturn}]{%
        \thstk \vdash (\txstk, \h, \evset), \preturn{\expr} \ \toL \  (\txstk\rmto{\ret}{\val}, \h, \evset), \pskip
    }{ 
        \val = \evalE[\thstk \uplus \txstk]{\expr}
    }
\]

\[
    \infer[\rl{TChoice}]{%
        \thstk \vdash (\txstk, \h, \evset) , \trans_{1} \pchoice \trans_{2} \ \toL \  (\txstk, \h, \evset) , \trans'
    }{
        \trans' \in \Set{\trans_{1}, \trans_{2}}
    }
\]

\[
    \infer[\rl{TLoop}]{%
        \thstk \vdash (\txstk, \h, \evset),  \trans\prepeat \ \toL \  (\txstk, \h, \evset), \pskip \pchoice (\trans \pseq \trans\prepeat)
    }{}
\]


\[
    \infer[\rl{TSeqSkip}]{%
        \thstk \vdash (\txstk, \h, \evset), \pskip \pseq \trans \ \toL \  (\txstk, \h, \evset), \trans
    }{%
    }
\]

\[
    \infer[\rl{TSeq}]{%
        \thstk \vdash (\txstk, \h, \evset), \trans_{1} \pseq \trans_{2} \ \toL \  (\txstk', \h', \evset'), \trans_{1}' \pseq \trans_{2}
    }{%
        \thstk \vdash (\txstk, \h, \evset), \trans_{1} \ \toL \  (\txstk', \h', \evset'), \trans_{1}'
    }
\]

\hrule\vspace{5pt}
\caption{The transaction operational semantics}
\label{fig:transaction_semantics}
\end{figure}

\subsection{Global Semantics}

To model the global machine states, instead of heap-based states, we use \emph{abstract executions} (\defref{def:abs-exec}).
A \emph{abstract execution} is a graph where each node represents a committed transaction with a unique transaction identifier, and its associated events that have global effect, \ie the first reads and last writes.
There are three types of edges in the graph, a \emph{program order} that is a total order for transactions from the same thread, a \emph{visibility relation} that decides the observable history (a set of transactions) for each transaction, and an \emph{arbitration order} that decides the actual global state that is not necessary to be the same as the observable state for each transaction \cite{eventually-consistent-transactions,Burckhardt:2014:RDT:2535838.2535848,cerone_et_al:LIPIcs:2015:5375}.

\begin{defn}[Runtime abstract executions and abstract executions]
\label{def:run-abs-exec}
\label{def:abs-exec}
An \emph{runtime abstract execution} is a tuple \( \aexecrun = (\tx, \setthid, \porun, \vis, \ar) \in \Aexecrun \) that satisfies the following conditions,
\begin{itemize}
\item
The \emph{transactions} \( \tx \) is a partial function from transaction identifiers to their corresponding events (\defref{def:transactions}).
\item 
Assume a countably infinite set of thread identifiers \( \thid \in \setthid \subseteq \ThreadID \). 
The \emph{runtime threads} \( \setthid \) is a set of transaction identifiers.
\item 
The \emph{arbitration order} $\ar \subseteq \dom(\tx) \times \dom(\tx)$ is a strict, total order%
\footnote{Recall that a relation $R \subseteq A \times A$ is a strict partial order if it is irreflexive and transitive.
It is a strict total order if for any $a_1, a_2 \in A$, either $a_1 = a_2$, $(a_1, a_2) \in R$ or $(a_2, a_1) \in R$.}.
\item 
The \emph{runtime program order} $\porun \subseteq \dom(\tx) \times ( \dom(\tx) \uplus \setthid )$ is the union of several disjoint, strict total orders \( \porun_{i} \).
That is, there exists a partition $\Set{ \dom(\tx)_{i} }_{i \in I}$ of $\dom(\tx)$ such that $\porun = \biguplus_{i \in I} \porun_{i}$, where $\porun_{i}$ is a strict, total order.
It also requires \( \po \subseteq \ar\).
\item 
The \emph{visibility relation} $\vis \subseteq \dom(\tx) \times \dom(\tx)$ is a relation such that \( \vis \subseteq \ar \).
\end{itemize} 
The set of \emph{abstract executions} $\aexec  = (\tx, \po, \vis, \ar) \in \Aexecs$, where the \emph{program order} \( \po \subseteq \dom(\tx) \times \dom(\tx)\), is defined by erasing the runtime threads from the runtime abstract executions \( \Aexecrun \),
\[
\begin{rclarray}
    \Aexecs & \defeq & \Setcon{\eraseAEX{\aexecrun}}{\aexecrun \in \Aexecrun} \\
\end{rclarray} 
\]
where the erasing function \( \eraseAEX{.}: \Aexecrun \to \Aexecs \) converts a runtime abstract execution to an abstract execution by erasing the second element, \ie the set of thread identifiers, and also any thread identifiers from the runtime program order,
\[
    \begin{rclarray}
        \eraseAEX{(\tx, \setthid, \porun, \vis, \ar)} & \defeq & (\tx, \hat{\po} \setminus \Setcon{(\txid, \thid)}{ \txid \in \dom(\tx) \land \thid \in \setthid}, \vis, \ar)
    \end{rclarray}
\]
For brevity, the \( \aexecrun\prjT \), \( \aexecrun\prjI \), \( \aexecrun\prjP \), \( \aexecrun\prjV \) and \( \aexecrun\prjA \) denote the corresponding elements in the tuple and similarly for \( \aexec\projection{(.)} \).
The composition of two runtime abstract executions, \( \composeAEXRUN : \Aexecrun \times \Aexecrun \parfun \Aexecrun \), is defined as the follows,
\[
\begin{rclarray}
    \aexecrun_{1} \composeAEXRUN \aexecrun_{2} & \defeq & 
    \begin{cases}
        \left( \lambda \txid \ldotp \aexecrun_{1}\prjT(\txid) \uplus \aexecrun_{2}\prjT(\txid), \aexecrun_{1}\prjI, \aexecrun_{1}\prjP, \aexecrun_{1}\prjV, \aexecrun_{1}\prjA \right) & \dagger \\
        \text{undefined} & \text{ otherwise}
    \end{cases} \\
    \dagger & \equiv &  
    \begin{array}[t]{@{}l@{}}
        \dom(\aexecrun_{1}\prjT) = \dom(\aexecrun_{2}\prjT)
        \land \aexecrun_{1}\prjI = \aexecrun_{2}\prjI \\
        \quad {} \land \aexecrun_{1}\prjP = \aexecrun_{2}\prjP
        \land \aexecrun_{1}\prjV = \aexecrun_{2}\prjV
        \land \aexecrun_{1}\prjA = \aexecrun_{2}\prjA \\
    \end{array} \\
\end{rclarray}
\]
Then, the order between two runtime abstract executions \( \aexecrun_{1} \) and \( \aexecrun_{2} \) is defined as point-wise set inclusions,
\[
\begin{rclarray}
\aexecrun_{1} \ordAEXRUN \aexecrun_{2} & \iffdef & 
    \begin{array}[t]{@{}l@{}}
        ( \for{\txid} \aexecrun_{1}\prjT(\txid) \implies \aexecrun_{2}\prjT(\txid) )  
        \land \aexecrun_{1}\prjI \subseteq  \aexecrun_{2}\prjI  \\
        {} \quad \land \aexecrun_{1}\prjP \subseteq  \aexecrun_{2}\prjP 
        \land \aexecrun_{1}\prjV \subseteq  \aexecrun_{2}\prjV 
        \land \aexecrun_{1}\prjA \subseteq  \aexecrun_{2}\prjA 
    \end{array}
\end{rclarray}
\]
Last, by erasing the runtime, the order between two abstract executions is defined as the follows,
\[
\begin{rclarray}
\aexec_{1} \ordAEX \aexec_{2} & \iffdef & 
    \exsts{\aexecrun_{1}, \aexecrun_{2}} \aexec_{1} = \eraseAEX{\aexecrun_{1}}
    \land \aexec_{2} = \eraseAEX{\aexecrun_{2}}
    \land \aexecrun_{1} \ordAEXRUN \aexecrun_{2}
\end{rclarray}
\]
\end{defn}

We parametrise the consistency models in our semantics.
A \emph{consistency model} contains two parts, a \emph{resolution policy} and a \emph{consistency guarantee} (\defref{def:consistency-models}) \cite{cerone_et_al:lipics:2017:7794}.
Given a abstract execution \( \aexec \), a set of observable transactions \( \txidset \) and an address \( \addr \), the \emph{resolution policy} \( \respo(\aexec, \txidset, \addr) \) decides the observable values for the address \( \addr \) through some computation on the observable transactions \( \txidset \).
A common resolution policy is \emph{last-write-win} that if a transaction observes several writes for the same address, it always reads the last write (by the arbitration order).
The consistency guarantee gives the minimum constraint for the visibility relation.


\begin{defn}[Consistency Models]
\label{def:consistency-models}
A \emph{Consistency model} is a tuple, \( \como = (\respo, \conguar) \in \Como\), including a \emph{resolution policy} and a \emph{consistency guarantee}.
A \emph{resolution policy} \( \respo \) is a function such that for a given address \( \addr \) and a set of observable transactions from a abstract execution, it returns a set of possible observable values.
\[
\begin{rclarray}
    \ResPos & \defeq & 
    \Setcon{%
        \respo
     }{%
        \respo \in \Aexecs \times \powerset{\TxID} \times \Addr \to \powerset{\Val}\\
        \quad {} \land \for{\aexec, \txidset, \addr } \respo(\aexec, \txidset, \addr)\isdef \implies \txidset \subseteq \dom(\aexec\prjT)
    }
\end{rclarray}
\]
A \emph{consistency guarantee} \( \conguar \) is a function such that for an abstract execution, it returns a relation which corresponds to the minimum visibility relation.
\[ 
\begin{rclarray}
\ConGuar & \defeq & 
\Setcon{%
        \conguar
    }{%
        \conguar \in \Aexecs \to \powerset{\TransID \times \TransID}
        \land \for{\aexec} \\
        \quad \conguar(\aexec) \subseteq \aexec\prjA
        \land \for{\txid, \txid'} (\txid, \txid') \in \conguar(\aexec) 
        \land \txid,\txid'  \in \dom(\aexec\prjT)
        
    }
\end{rclarray}
\]
Note that a well-formed consistency guarantee must not violate the arbitrary order.
The order \( \ordCOM \)  between two consistency model \( \como_{1}, \como_{2} \) is defined as the follows,
\[
\begin{rclarray}
    (\respo_{1}, \conguar_{1}) \ordCOM (\respo_{2}, \conguar_{2}) & \iffdef & 
    \begin{array}[t]{@{}l@{}}
    \for{\aexec, \txidset, \addr} \\
    \quad \respo_{2}(\aexec, \txidset, \addr) \subseteq \respo_{1}(\aexecrun, \txidset, \addr) \land \conguar_{1}(\aexec) \subseteq  \conguar_{2}(\aexec)
    \end{array} \\
\end{rclarray}
\]
The bottom element is \( \btmCOM \defeq (\lambda (\aexec, \txidset, \addr ) \ldotp \Val, \lambda (\aexec) \ldotp \emptyset) \), which means one is able to observe any arbitrary value for each address and there is no constraint for visibility relation.
\end{defn}

\begin{example}[Last write win]
\[
\begin{rclarray}
        \respo_{LWW}(\aexec, \txidset, \addr) & \defeq & 
        \Setcon{\val}{%
            \exsts{\ar = \aexec\prjA}
            \Set{(\etW, \addr, \val)} = \max_{\ar}\Setcon{\txid}{\txid \in \txidset \land (\etW, \addr, \stub) \in \tx(\txid) } \\
            \quad {} \lor \emptyset = \max_{\ar}\Setcon{\txid}{\txid \in \txidset \land (\etW, \addr, \stub) \in \tx(\txid) } \land v = 0
        }\\
\end{rclarray}
\]
\end{example}

\begin{example}[Write-write conflict]
\[
\begin{rclarray}
        \conguar_{WW}(\aexec) & \defeq & \Setcon{(\txid, \txid')}{ \exsts{ \addr } (\etW, \addr, \stub) \in \aexec\prjT(\txid) \land (\etW, \addr, \stub) \in \aexec\prjT(\txid') \land (\txid, \txid') \in \aexec\prjA } \\
\end{rclarray}
\]
\end{example}

Given two sets of relations \( A \) and \( B \), the notation \( A ; B \) denotes that \( A;B \defeq \Setcon{(a,b)}{(a,c) \in A \land (c,b) \in B} \).

\begin{example}[Serialisibility(SER)]
\[
    \begin{rclarray}                                   
        \respo_{SER} & \defeq & \respo_{LWW} \\
        \conguar_{SER}(\aexec) & \defeq & \aexec\prjA \\
    \end{rclarray}                                                      
\]
\end{example}
%\ac{Why $\como_{SER}$ and not $\respo_{SER}?$ Also, the resolution policy is the last write wins, which you need to define only once.}

\begin{example}[Snapshot isolation(SI)]
\[
    \begin{rclarray}                                   
        \respo_{SI} & \defeq & \respo_{LWW} \\
        \conguar_{SI}(\aexec) & \defeq & ( \aexec\prjA ; \aexec\prjV )  \cup \conguar_{WW}(\aexec) \\
    \end{rclarray}
\]
\end{example}
%\ac{Why not just say that $\conguar_{SI}(\aexec) = \aexec\prjV ; \aexec\prjA$? Also, you are missing 
%write conflict detection ($\conguar_{\mathsf{WWconf}} = \bigcup_{\addr \in \Addr} [\mathsf{Write}_\addr] ; \aexec\prjA ; [\mathsf{Write}_\addr]$.}

\begin{example}[Parallel snapshot isolation(PSI)]
\[
    \begin{rclarray}                                   
        \respo_{PSI} & \defeq & \respo_{LWW} \\
        \conguar_{PSI}(\aexec) & \defeq & ( \aexec\prjV ; \aexec\prjV ) \cup \conguar_{WW}(\aexec) \\
    \end{rclarray}
\]
\end{example}

\begin{defn}[Thread transition labels]
\label{def:label}
Given the set of thread identifiers \(\ThreadID\) (\defref{def:abs-exec}), the set of \emph{thread transition labels}, $\lb \in \Translabel$, is defined by the following grammar, where $\prog$ denotes a program (\defref{def:language}), the $\txid$ demotes a transaction identifier and $\thstk$ denotes a thread stack (\defref{def:stacks}),
\[
    \begin{rclarray}
	\iota \in \Translabel & ::= & \lbID \mid \lbC{\txid} \mid \lbF{\thid,\prog} \mid \lbJ{\thid,\thstk}
    \end{rclarray}
\]
\end{defn}


\begin{defn}[Thread semantics]
\label{def:thread_semantics}
Given the thread identifiers $\thid \in \ThreadID$, the set of \emph{intermediate programs}, $\iprog \in \IntermediatePrograms$, is defined by the following grammar:
\[
    \iprog ::= \prog \mid \iprog \pseq \pwait{\thid}
\]
Given the set of consistency model \( \ConsisModels \) (\defref{def:consistency-models}), the set of thread stacks \( \ThdStacks \) (\defref{def:stacks}) and runtime abstract executions \( \Aexecrun \) (\defref{def:run-abs-exec}), the \emph{per-thread operational semantics} of programs,
\[
\begin{rclarray}
	\toT{} & : &
    \begin{array}[t]{@{}l@{}}
    \Como \times \ThreadID 
    \times \\
	\quad \left( ( \ThdStacks \times \Aexecrun ) \times \IntermediatePrograms \right) 
	\times  \Translabel \times
	\left( ( \ThdStacks \times \Aexecrun ) \times \IntermediatePrograms \right) 
    \end{array}
\end{rclarray}
\]
is defined in \figref{fig:thread_semantics}.
\end{defn}

The \rl{PCommit} rule ``substitutes'' the dummy node for the thread \( \thid \) in the runtime abstract execution \( \aexecrun \) with a newly allocated transaction \( \txid \) with its associated events \( \evset \).
To obtain the events \( \evset \), it prophesies a set of observable transactions \( \txidset \), which will be added into the visibility relation later.
Given the observable transactions, the \( \obsstateName \) function computes possible initial heaps, by applying the resolution policy \( \respo \) for each address.
Note that the resolution policy might return more than one value for an address, so there are more than many possible initial heaps.
Given the transaction code \( \trans \), first pick an initial heap \( \h \) and then given the transaction semantics (\figref{fig:transaction_semantics}), we can get the events set \( \evset \).
To \emph{extend the runtime abstract execution}, it replaces the dummy node \( \thid \) with the new transaction \( \txid \), links all transaction from the observable transactions \( \txidset \) to the new transaction, and puts the new transaction at the end of arbitration order.
Then, it extends the program order by adding back the dummy node \( \thid \) after the transaction \( \txid \) for preserving program order for the future transactions from the same thread.

The \rl{Par} rule forks a new thread and inserts the appropriate joining point by appending the auxiliary \( \pwait{\thid} \) command, where the parameter \(\thid\) denotes the identifier of the newly forked thread.
The \rl{Wait} rule dually awaits the termination of the child thread \(\thid\) indicated by the auxiliary \( \pwait{\thid} \) command, and subsequently updates the thread stack.
Note that these two rules are labelled with the \(\lbF{\thid, \prog}\) and \(\lbJ{\thid, \thstk}\) which are used by the semantics of the thread pool described shortly (\figref{fig:thread_pool_semantics}).

\begin{figure}
%
\hrule
%
\[
    \infer[\rl{PCommit}]{%
        (\respo, \conguar), \thid \vdash ( \thstk, \aexecrun ), \ptrans{\trans} \ \toT{\lbC{\txid}} \ ( \thstk\rmto{\ret}{\txstk(\ret)}, \aexecrun' ) , \pskip
    }{%
        \begin{array}{c}
            \txid \in \func{fresh}{\aexecrun}
            %\quad \txidset \in \addpotvis{\aexecrun, \thid}
            \quad \txidset \subseteq \dom(\aexecrun\prjT)
            \quad \h \in \obsstate{\aexecrun, \txidset, \respo} \\
            %\quad \fph = \lambda \addr \ldotp  (\respo(\eraseAEX{\aexecrun}, \txidset , \addr), \emptyset) \\
            \thstk \vdash (\emptyset, \h, \emptyset) , \trans \ \toL^{*} \  (\txstk, \h', \evset) , \pskip 
            %\quad \evset = \getevent{\fph, \fph'}
            \quad \aexecrun' = \newaexec{\aexecrun, \thid, \evset, \txid, A, \conguar }
        \end{array}
    }
\]

\[
    \infer[\rl{PAssign}]{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \passign{\thvar}{\expr} \ \toT{\lbID} \  ( \thstk\rmto{\thvar}{\val}, \aexecrun  ) , \pskip
    }{
        \val = \evalE[\thstk]{\expr}
        && \thvar \in \ThdVars
    }
\]

\[
    \infer[\rl{PAssume}]{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \passume{\expr} \ \toT{\lbID} \  ( \thstk, \aexecrun ) , \pskip
    }{%
        \evalE[\thstk]{\expr} = 0
    }
\]

\[
    \infer[\rl{PChoice}]{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \prog_{1} \pchoice \prog_{2} \ \toT{\lbID} \  ( \thstk, \aexecrun ) , \prog'
    }{
        \prog' \in \Set{\prog_{1}, \prog_{2}}
    }
\]

\[
    \infer[\rl{PLoop}]{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \prog\prepeat \ \toT{\lbID} \  ( \thstk, \aexecrun ) , \pskip \pchoice (\prog \pseq \prog\prepeat)
    }{}
\]

\[
    \infer[\rl{PSeqSkip}]{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \pskip \pseq \iprog \ \toT{\lbID} \  ( \thstk, \aexecrun ) , \iprog
    }{}
\]

\[
    \infer[\rl{PSeq}]{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \iprog_{1} \pseq \iprog_{2} \ \toT{\lb} \ ( \thstk', \aexecrun' ) , {\iprog_{1}}' \pseq \iprog_{2}
    }{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \iprog_{1} \ \toT{\lb} \  ( \thstk', \aexecrun' ) , {\iprog_{1}}' 
    }
\]

\[
    \infer[\rl{PPar}]{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \prog_{1} \ppar \prog_{2} \ \toT{\lbF{\thid', \prog_{2}}} \  ( \thstk, \aexecrun' ) , \prog_{1} \pseq \pwait{\thid'}
    }{
        \aexecrun' = \func{extend\_thread}{\aexecrun, \thid, \thid'}
    }
\]

\[
    \infer[\rl{PWait}]{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \pwait{\thid'} \ \toT{\lbJ{\thid', \thstk'}} \  (  \thstk_{1} \uplus \thstk_{2} \uplus \thstk_{f}, \aexecrun' ) , \pskip 
    }{
        \thstk = \thstk_{1} \uplus \thstk_{f}
        && \thstk' = \thstk_{2} \uplus \thstk_{f}
        && \aexecrun = \func{erase\_thread}{\aexecrun', \thid'}
    }
\]

\sx{The stack could be polluted by the child thread, but they must agree?}
 
where,
\[
\begin{rclarray}                                 
    \consis{\aexecrun, \thid, \txid, \conguar} & \defeq & 
    \begin{array}[t]{@{}l@{}}
        \thid \in \aexecrun\prjI \land  \for{ \txid' } ( (\txid', \txid) \in \conguar(\eraseAEX{\aexecrun}) \implies (\txid', \txid) \in \aexecrun\prjV ) \\
    \end{array} \\
    \newaexecName & : & 
    \left(\begin{array}{l}
        \Aexecrun \times \ThreadID \times \TxID \times \\
        \quad  \powerset{\Events} \times \powerset{\TxID} \times \ConGuar \end{array} \right)
        \parfun \Aexecrun \\
    \newaexec{\aexecrun, \thid, \txid, \evset, \txidset, \conguar } & \defeq & 
    \begin{cases}
        \aexecrun' & \consis{\aexecrun', \thid, \txid, \conguar} \\
        \text{undefined} & \text{otherwise} \\
    \end{cases} \\
    \aexecrun' & \equiv & 
        \left(
        \begin{array}{@{}l@{}}
            \aexecrun\prjT \uplus \Set{\txid \mapsto \evset},
            \aexecrun\prjI, 
            \aexecrun\prjP \uplus \Setcon{(\txid', \txid)}{(\txid', \thid) \in \aexecrun\prjP} \uplus \Set{(\txid, \thid)}, \\
            \quad \aexecrun\prjV \uplus \Setcon{(\txid', \txid)}{\txid' \in \txidset}, 
            \aexecrun\prjA \uplus \Setcon{(\txid', \txid)}{\txid' \in \dom(\aexecrun\prjT)}
        \end{array}
        \right) \\
%	
%
    \obsstateName & : & \Aexecrun \times \powerset{\TxID} \times \ResPos \parfun \powerset{\FPHeaps} \\
    \obsstate{\aexecrun, \txidset, \respo} & \defeq & 
    \Setcon{%
        \h
    }{%            
        \for{\addr, \val}  \val \in \respo(\eraseAEX{\aexecrun}, \txidset, \addr) \iff \h(\addr) = \val \\
    } \\
%
%              
	\func{fresh}{\aexecrun}  & \defeq & \Setcon{ \txid }{ \neg \txid \in \dom(\aexecrun\prjT) } \\
%
%
    %\geteventName & : & \FPHeaps \times \FPHeaps \to \powerset{\Events} \\
    %\getevent{\fph, \fph'} & \defeq & 
    %\begin{array}[t]{@{}l@{}}
        %\Setcon{ (\etW, \addr, \val ) }{ \exsts{ \fp } \fph(\addr) = ( \val, \fp ) \land \fpW \in \fp} \\
        %\quad {} \uplus \Setcon{ (\etR, \addr, \val ) }{ \exsts{ \fp } \fph(\addr) = (\val, \stub) \land \fph(\addr) = ( \stub, \fp ) \land \fpR \in \fp} \\ 
    %\end{array} \\
%
%
    \func{extend\_thread}{\aexecrun, \thid, \thid'} & \defeq & (\aexecrun\prjT, \aexecrun\prjI \uplus \Set{\thid'}, \aexecrun\prjP \uplus \Setcon{(\txid, \thid')}{ (\txid, \thid) \in \aexecrun\prjP}, \aexecrun\prjV, \aexecrun\prjA) \\
    \func{erase\_thread}{\aexecrun, \thid} & \defeq & (\aexecrun\prjT, \aexecrun\prjI \setminus \Set{\thid}, \aexecrun\prjP \setminus \Setcon{(\txid, \thid)}{ \txid \in \dom(\aexecrun\prjT)}, \aexecrun\prjV, \aexecrun\prjA)                                                                                                                                                                                                                   
    \end{rclarray}
\]
\hrule
\caption{Per-thread operational semantics}
\label{fig:thread_semantics}
\end{figure}

In order to model concurrency, we use thread pools.
A \emph{thread pool} is a finite partial function from thread identifiers to triples of the form \((\thstk, \iprog)\). That is, each thread is associated with a thread stack \(\thstk\) and an intermediate program \(\iprog\) to be executed. 

\begin{defn}[Thread pools]
\label{def:thread_pools}
Given the set of thread stacks $\ThdStacks$ (\defref{def:stacks}) and intermediate programs $\IntermediatePrograms$ (\defref{def:thread_semantics}), a \emph{thread pool} is a a finite partial function from thread identifiers to triples of thread stacks and intermediate programs, \(\thpl \in \TPool \eqdef \ThreadID \parfinfun \ThdStacks \times \IntermediatePrograms\).
\end{defn}
 
\begin{defn}[Thread pool semantics] 
\label{def:thread_pool_semantics}
Given the set of consistent models \( \ConsisModels \) (\defref{def:consistency-models}), runtime abstract executions \(\Aexecrun\) (\defref{def:abs-exec}), transition labels \( \Translabel \) (\defref{def:label}) and thread pools  \( \TPool \) (\defref{def:thread_pools}), the \emph{thread pool semantics}, 
\[
	\toG{} : \Como \times (\Aexecrun \times \TPool) \times \Translabel \times (\Aexecrun \times \TPool) 
\]
is defined in \figref{fig:thread_pool_semantics}.
\end{defn}
 
The thread pool operational semantics is given in \figref{fig:thread_pool_semantics}, where an arbitrary thread in the pool \(\thpl\) is picked to run for one step.
If the next execution step is a thread fork, then a new thread \(\thid'\) is allocated in the pool to be executed with its thread stack copied from its parent (forking) thread.
Conversely, when the next execution step is the joining of thread \(\thid'\), then \(\thid'\) is removed from the thread pool and the stack from the child thread merges into the parent thread.

\begin{figure}
\hrule\vspace{5pt}
%
\[
    \infer[\rl{PSingle}]{%
        \como \vdash ( \aexecrun, \thpl \uplus \Set{ \thid \mapsto (\thstk, \iprog) } ) \ \toG{\lb} \  ( \aexecrun, \thpl \uplus \Set{ \thid \mapsto (\thstk', {\iprog}') } ) 
    }{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \iprog \ \toT{\lb} \  ( \thstk', \aexecrun ' ) , {\iprog}' 
        \quad \lb \in \Set{ \lbID, \lbC{\stub} }
    }
\]

\[
    \infer[\rl{PFork}]{%
        \como \vdash ( \aexecrun, \thpl \uplus \Set{ \thid \mapsto (\thstk, \iprog) } ) \ \toG{\lbF{\thid', \prog}} \  ( \aexecrun', \thpl \uplus \Set{ \thid \mapsto (\thstk, {\iprog}'), \thid' \mapsto (\thstk, \prog) } )
    }{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \iprog \ \toT{\lbF{\thid', \prog}} \  ( \thstk, \aexecrun' ) , {\iprog}' 
    }
\]

\[
    \infer[\rl{PJoin}]{%
        \como \vdash ( \aexecrun, \thpl \uplus \Set{ \thid \mapsto (\thstk, \iprog), \thid' \mapsto (\thstk', \pskip) } )  \ \toG{\lbJ{\thid',\thstk''}} \ ( \aexecrun', \thpl \uplus \Set{ \thid \mapsto (\thstk'', {\iprog}')} )
    }{%
        \como, \thid \vdash ( \thstk, \aexecrun ) , \iprog \ \toT{\lbJ{\thid',\thstk'}} \  ( \thstk'', \aexecrun' ) , {\iprog}' 
    }
\]
%
\hrule\vspace{5pt}
\caption{Thread pool semantics}
\label{fig:thread_pool_semantics}
\end{figure}

\subsection{Soundness and Completeness}

Given a consistency model, we can define the set of abstract executions that satisfy a consistency model (\defref{def:valid-aexec}) \cite{cerone:snapshot,cerone_et_al:lipics:2017:7794,cerone_et_al:LIPIcs:2015:5375}.
The \lemref{lem:consistency-monotonicity} is for sanity check.

\begin{defn}[Valid abstract executions]
\label{def:valid-aexec}
Given a consistency model \( (\respo, \conguar) = \como \in \Como \) (\defref{def:consistency-models}), the set of valid abstract executions under the model, denoted by \( \evalCOM{\como} \),  is defined as the follows,
\[
    \begin{rclarray}
        \evalCOM{(\respo, \conguar)} & \defeq & 
        \Setcon{%
            \aexec = (\tx, \po, \vis, \ar)
        }{%
            \conguar(\aexec) \subseteq \vis 
            \land \for{\txid, \addr, \val}  \\
            \qquad (\etR, \addr, \val) \in \tx(\txid) 
            \implies \val \in \respo(\aexec, \aexec\prjV(\txid), \addr)
        }
    \end{rclarray}
\]
where \( \aexec\prjV(\txid) \) returns all the predecessors of \( \txid \) with respect to the visibility relation.
This is, for any relation \( R \),
\[
\begin{rclarray}
    R(x) & \defeq & \Setcon{ x' }{ (x', x) \in R}
\end{rclarray}
\]
\end{defn}    
 
\begin{lem}[Consistency models monotonicity]
\label{lem:consistency-include}
\label{lem:consistency-monotonicity}
The abstract executions allowed by a stronger consistency model is allowed by a weaker consistency model, this is,
\[
    \como_{1} \ordCOM \como_{2} \implies \evalCOM{\como_{2}} \subseteq \evalCOM{\como_{1}}
\]
\end{lem}
\begin{proof}
For any abstract execution \( \aexec \) that satisfies the stronger consistency model \( \como_{2} = (\respo_{2}, \conguar_{2}) \), first, it has \( \conguar_{2}(\aexec) \subseteq \aexec\prjV \) by the \defref{def:valid-aexec}.
Given the hypothesis \( \como_{1} \ordAEX \como_{2} \) and the order definition (\defref{def:consistency-models}), we know \( \conguar_{1}(\aexec)  \subseteq \conguar_{2}(\aexec)  \) so that \( \conguar_{1}(\aexec) \subseteq \aexec\prjV \).
Second, assume a transaction \( \txid \) and any of its read event with an address \( \addr \) and a \( \val \) such that \( (\etR, \addr, \val) \in \tx(\txid) \) therefore \( \val \in \respo_{2}(\aexec, \aexec\prjV(\txid), \addr) \).
Similarly by the hypothesis \( \como_{1} \ordAEX \como_{2} \), we know \( \respo_{2}(\aexec, \aexec\prjV(\txid), \addr) \subseteq \respo_{1}(\aexec, \aexec\prjV(\txid), \addr)\), thus \( \val \in \respo_{1}(\aexec, \aexec\prjV(\txid), \addr)\).
Therefore we have \( \aexec \in \evalCOM{\como_{1}} \).
\end{proof}

\begin{thm}[Soundness of the semantics]
For any runtime abstract abstract execution \( \aexecrun \) that satisfies a consistency model \( \como \), if the semantics under consistency model \( \como \) take one step  to  a new abstract execution \( \aexecrun' \), the new execution should satisfy the consistency model.
This is,
 \[
 \begin{array}{@{}l@{}}
    \for{\como, \thid, \aexecrun, \aexecrun', \thstk, \thstk', \iprog, {\iprog}', \lb} \\
    \qquad \eraseAEX{\aexecrun} \in \evalCOM{\como}
    \land \como, \thid \vdash (\aexecrun, \thstk), \iprog \toT{\lb} (\aexecrun', \thstk'), {\iprog}' 
    \implies \eraseAEX{\aexecrun'} \in \evalCOM{\como}
 \end{array}
 \]
\end{thm}
\begin{proof}
We prove it by induction on the derivations.

\caseB{\rl{PCommit}}

By the \rl{PCommit} rule, it has \( \iprog = \ptrans{\trans} \), \( \iprog' = \pskip \) and \( \lb = \lbC{\txid} \), for some transaction code \( \trans \) and identifier \( \txid \).
Let variables \( \aexec = \eraseAEX{\aexecrun} \) and \( \aexec' = \eraseAEX{\aexecrun'} \) in the following discussion.
We need to prove the follows,
\begin{align}
    & \for{ \txid', \txid'', \addr, \val}  \nonumber \\
    & \quad (\etR, \addr, \val) \in \aexec'\prjT(\txid') \implies \val \in \respo(\aexec',\aexec'\prjV(\txid'), \addr) \label{equ:res_policy}\\
    & \quad (\txid', \txid'') \in \conguar(\aexec') \implies (\txid', \txid'') \in \aexec'\prjV \label{equ:con_guarantee}
\end{align}
First for the \equref{equ:res_policy}, it only needs to check the new transaction \( \txid \) as others are proved directly from the hypothesis.
Given an initial heap \( \h \), a set of events \( \evset \) associated with the new transaction \( \txid \), a set of transactions \( \txidset \) observed by the new transaction \( \txid \), assume these variables satisfy the follows,
\[
\begin{array}{@{}l@{}}
    \exsts{\thstk, \txstk, \h'} \nonumber \\
    \quad \thstk \vdash (\emptyset, \h, \emptyset), \trans \toL^{*} (\txstk, \h', \evset), \pskip 
    \land \h \in \obsstate{\aexecrun, \txidset, \respo} \nonumber \\
\end{array}
\]
therefore the following hold,
\[
    (\etR, \addr, \val) \in \evset \implies \h(\addr) = \val
\]
Because by the transaction semantics (\figref{fig:transaction_semantics}), a transaction only records the first read event for each address.
It can be proved by induction on the derivations for transaction operational semantics, where the only rule that involves read event is \rl{TRead}.
If the new read event is included in the events set after flushing read (\defref{def:transaction-event}), \ie \( (\etR, \addr, \val) \in ( \evset \flushR (\etR, \addr, \val) ) \), this means there is no other read and write to the same address before, so that the value \( \val  \) associate with the address \( \addr \) is the initial value, \ie \( \h(\addr)\), and after that no other read event can over-write.
By the \( \obsstateName \) function (\figref{fig:thread_semantics}), where \( \h(\addr) = \val \iff \respo(\aexec, \txidset, \addr) \), the following hold,
\[
    (\etR, \addr, \val) \in \evset \implies \respo(\aexec, \txidset, \addr)
\]
Since the \( \newaexecName \) function only extends abstract execution, which means \( \aexec \ordAEX \aexec' \), so that,
\[
    (\etR, \addr, \val) \in \evset \implies \respo(\aexec', \txidset, \addr)
\]
By the \( \obsstateName \) function, we have \( \evset = \aexec'\prjT(\txid)\) and \( \txidset = \aexec'\prjV(\txid)\) therefore we prove \equref{equ:res_policy}.

Second for \equref{equ:con_guarantee}, the visibility relation of the new abstract execution \( \aexec'\prjV \) contains the minimum relation required by the consistency guarantee.
Similarly, it is sufficient to consider those visibility edges related to the new transaction \( \txid \).
Note that for any transaction \( \txid'' \in \dom(\aexec'\prjT) \), it has \( (\tsid, \tsid'') \notin \conguar(\aexec') \).
Given \( \newaexecName \) function, so that \( (\tsid'', \tsid) \in \aexec'\prjA \).
Then, given the consistency guarantee (\defref{def:consistency-models}), it cannot violate arbitration order, this is, \( \conguar(\aexec') \subseteq \aexec'\prjA\).
Thus, it is safe to assume a transaction \( \tsid' \in \dom(\aexec'\prjT) \) such that \( (\tsid', \tsid) \in \conguar(\aexec') \).
By the \( \predn{consis}\) predicate, we have \( (\tsid', \tsid) \in \conguar(\aexec') \implies (\tsid', \tsid) \in \aexec'\prjV\), so that we prove \equref{equ:con_guarantee}.

\caseB{\rl{PAssign}, \rl{PAssume}, \rl{PChoice}, \rl{PLoop}, \rl{PSeqSkipS}}

For these base cases, the runtime abstract execution remains the same, \ie \( \aexecrun = \aexecrun' \), so they trivially hold because of the hypothesis.

\caseB{\rl{PPar}, \rl{PWait}}

For these two base cases, since the \( \funcn{extend\_thread} \)  and \( \funcn{erase\_thread} \) functions only change relations related to the corresponding threads, therefore \ie \( \eraseAEX{\aexecrun} = \eraseAEX{\aexecrun'} \), so they hold because of the hypothesis.

\caseI{\rl{PSeq}}

It is proved directly by applying the \ih
\end{proof}

For sanity check and also proving the completeness of this semantics, we first prove the semantics is monotonic (\lemref{lem:semantics-monotonicity}), which means that for any reduction that can happen in the stronger consistency model, it can also happen in the weaker one.

\begin{lem}[Semantics monotonicity]
\label{lem:semantics-monotonicity}
Given an initial runtime abstract execution \( \aexecrun \), if it can transfer to an abstract execution \( \aexecrun' \) by reducing one step of the semantics under stronger consistency model \( \como_{2}\), it is also possible by reducing one step of the semantics under a weaker consistency model \( \como_{1} \).
\[
\begin{array}{@{}l@{}}
    \for{\como_{1}, \como_{2}, \thid, \aexecrun, \aexecrun', \iprog, \iprog', \thstk, \thstk', \lb}  \\
    \quad \como_{2}, \thid \vdash ( \aexecrun, \thstk ), \iprog \toT{\lb} ( \aexecrun', \thstk' ), \iprog'
    \land \como_{1} \ordCOM \como_{2} \\
    \quad \implies \como_{1}, \thid \vdash ( \aexecrun, \thstk ), \iprog \toT{\lb} ( \aexecrun', \thstk' ), \iprog'
\end{array}
\]
\end{lem}
\begin{proof}
We prove it by induction on the derivations.
The only interesting case is the \rl{PCommit} rule.

\caseB{\rl{PCommit}}

Let variables \( (\respo_{1}, \conguar_{1}) = \como_{1} \) and  \( (\respo_{2}, \conguar_{2}) = \como_{2} \) respectively.
Given an initial runtime abstract execution \( \aexecrun \), a set of observable transactions \( \txidset \), a new transaction identifier \( \txid \) and a thread identifier \( \thid \), by the \rl{PCommit} rule (\figref{fig:thread_pool_semantics}), it is sufficient to prove, first, all the observable states under the stronger consistency model can also be observed under the weaker one,
\begin{equation}
    \label{equ:obs-state-included}
    \obsstate{\aexecrun, \txidset, \respo_{2}} \subseteq  \obsstate{\aexecrun, \txidset, \respo_{1}} 
\end{equation}
and second if the new runtime abstract execution \( \aexecrun' \) exists under the stronger concurrency model, it should also exist under weaker one,
\begin{equation}
    \label{equ:consis-both-exist}
    \consis{\aexecrun', \txid, \thid, \conguar_{2}} \implies \consis{\aexecrun', \txid, \thid, \conguar_{1}}
\end{equation}
To prove \equref{equ:obs-state-included}, assume an observable heap \( \h \) under stronger consistency model \( \como_{2}\), which means \( \h \in \obsstate{\aexecrun, \txidset, \respo_{2}} \).
Then, assume an address \( \addr\) and the corresponding value \( \val \) such that \(  \h(\addr) = \val \).
By the \( \obsstateName \) function  (\figref{fig:thread_semantics}) and resolution policy (\defref{def:consistency-models}), it is known that \( \val \in \respo_{2}(\eraseAEX{\aexecrun}, \txidset, \addr)  \).
Because of \( \respo_{2}(\eraseAEX{\aexecrun}, \txidset, \addr) \subseteq \respo_{1}(\eraseAEX{\aexecrun}, \txidset, \addr) \) (\defref{def:consistency-models}), we have \(  \val \in \respo_{1}(\eraseAEX{\aexecrun}, \txidset, \addr) \), so \( \h \in \obsstate{\aexecrun, \txidset, \respo_{1}} \).
For \equref{equ:consis-both-exist}, assume the \( \consis{\aexecrun, \txid, \thid, \conguar_{2}} \) predicate holds and assume an edge \( (\txid', \txid) \in \conguar_{2}(\eraseAEX{\aexecrun'}) \) for some \( \txid' \).
Thus, the edge \( (\txid', \txid) \) will be included in the visibility relation of the new runtime abstract execution, \ie \( (\txid', \txid) \in \aexecrun'\prjV \).
Since \( \conguar_{1}(\eraseAEX{\aexecrun}) \subseteq \conguar_{2}(\eraseAEX{\aexecrun})\), so \( (\txid', \txid) \in \conguar_{1}(\eraseAEX{\aexecrun'}) \implies (\txid', \txid) \in \aexecrun'\prjV \) holds.
This means for any edges that satisfy the consistency guarantee for stronger model, they also satisfy the weaker consistency guarantee, thus the \equref{equ:consis-both-exist} holds.
Combining \equref{equ:obs-state-included} and \equref{equ:consis-both-exist}, we prove \rl{PCommit}.

\caseB{\rl{PAssign}, \rl{PAssume}, \rl{PChoice}, \rl{PLoop}, \rl{PSeqSkipS}, \rl{PPar}, \rl{PWait}}

These base cases do not depend on the consistency model, so they trivial hold because of the hypothesis.

\caseI{\rl{PSeq}}

It is proved directly by applying the \ih
\end{proof}

\begin{lem}[Preservation of the consistency model]
\label{lem:preserve-of-consistency}
\[
 \begin{array}{@{}l@{}}
    \for{\como_{1}, \como_{2}, \thid, \aexecrun, \aexecrun', \thstk, \thstk', \iprog, {\iprog}', \lb} \\
    \qquad \como_{1}, \thid \vdash (\aexecrun, \thstk), \iprog \toT{\lb} (\aexecrun', \thstk'), {\iprog}'
    \land \eraseAEX{\aexecrun'} \in \evalCOM{\como_{2}}
    \implies \eraseAEX{\aexecrun} \in \evalCOM{\como_{2}}
 \end{array}
\]
\end{lem}
\begin{proof}
We prove it by induction on the derivations.
The only interesting case is the \rl{Commit}.

\caseB{\rl{Commit}}

By the rule it has \( \iprog = \ptrans{\trans} \), \( \iprog' = \pskip \) and \( \lb = \lbC{\txid} \).
We prove this case by deriving contradiction.
Assume \( \eraseAEX{\aexecrun} \notin \evalCOM{\como_{2}} \), which means that there exists an edge \( (\txid', \txid'') \) such that it is in the consistency guarantee, \( (\txid', \txid'') \in \conguar_{2}(\eraseAEX{\aexecrun}) \) but not is not included in the visibility relation.
\begin{equation}
    \label{equ:not-in-vis}
    (\txid', \txid'') \notin \aexecrun\prjV 
\end{equation}
Another possibility is that there is a read event from a transaction, \( (\etW, \addr, \val) \in \aexecrun\prjT(\txid') \) where the value is not observable under the stronger consistency model, \ie
\begin{equation}
    \label{equ:not-observable}
    \val \notin \respo_{2}(\eraseAEX{\aexecrun}, \aexecrun\prjV(\txid'), \addr) 
\end{equation}
Because the rule only extend the runtime abstract execution \( \aexecrun \ordAEXRUN \aexecrun'\), this means the edge \( (\txid', \txid'') \) is not in the runtime abstract execution after reduction \( \aexecrun'\), or the transaction \( \txid' \) reads a unobservable value, 
\[
    (\txid', \txid'') \notin \aexecrun'\prjV \lor \val \notin \respo_{2}(\eraseAEX{\aexecrun'}, \aexecrun'\prjV(\txid'), \addr) 
\]
Both cases lead to \( \aexecrun' \notin \evalCOM{\como_{2}} \) so there is contradiction to the hypothesis.
Therefore we have the proof for this base case.

\caseB{\rl{PAssign}, \rl{PAssume}, \rl{PChoice}, \rl{PLoop}, \rl{PSeqSkipS}}

For these base cases, the runtime abstract execution remains the same, \ie \( \aexecrun = \aexecrun' \), so they trivially hold because of the hypothesis.

\caseB{\rl{PPar}, \rl{PWait}}

For these two base cases, since the \( \funcn{extend\_thread} \)  and \( \funcn{erase\_thread} \) functions change edges only related to the corresponding threads, therefore \ie \( \eraseAEX{\aexecrun} = \eraseAEX{\aexecrun'} \), so it holds because of the hypothesis.

\caseI{\rl{PSeq}}

It is proved directly by applying the \ih
\end{proof}

The completeness means that if an abstract execution \( \aexecrun \) satisfies a consistency model, it always is possible to produce such execution through the semantics under the corresponding consistency model for some initial configurations.
To define the completeness, we introduce \emph{anarchic semantics}, which is the semantics under the bottom element for consistency model \( \btmCOM \) as for the fact that there is no constraint for the visibility relations and for the observable value for each address.
\sx{citation for anarchic semantics?}
The \thmref{thm:semantics-completeness} says, given some initial configurations, after one step under the anarchic semantics, if one is ``lucky'' that it ends up with a runtime abstract execution \( \aexecrun'\) that satisfies a consistency model \( \como \), it is possible to get the same result using the semantics specifically for the consistency model \( \como \).

\begin{thm}[Completeness of the semantics]
\label{thm:semantics-completeness}
For any initial configuration \( ( (\aexecrun, \thstk), \iprog ) \), after one step under the \emph{anarchic semantics}, \ie the semantics under the bottom element \( \btmCOM \), it ends up with \( \aexecrun' \), and if the new runtime abstract execution \( \aexecrun' \) satisfies a consistency model \( \como \), then there is a corresponding step using semantics under consistency model \( \como \).
 \[
 \begin{array}{@{}l@{}}
    \for{\como, \thid, \aexecrun, \aexecrun', \thstk, \thstk', \iprog, {\iprog}', \lb} \\
    \qquad \btmCOM, \thid \vdash (\aexecrun, \thstk), \iprog \toT{\lb} (\aexecrun', \thstk'), {\iprog}' \land \eraseAEX{\aexecrun'} \in \evalCOM{\como} \\
    \qqquad \implies \como, \thid \vdash (\aexecrun, \thstk), \iprog \toT{\lb} (\aexecrun', \thstk'), {\iprog}' 
 \end{array}
 \]
\end{thm}
\begin{proof}
For any runtime abstract execution after one step such that \( \eraseAEX{\aexecrun'} \in \evalCOM{\como} \), by the \lemref{lem:preserve-of-consistency}, it is known that the initial configuration also satisfies the consistency model, this is, \( \eraseAEX{\aexecrun} \in \evalCOM{\como} \).
Since \( \btmCOM \) is the bottom element such that \( \btmCOM \ordCOM \como \), because the semantics are monotonic with respect to the order of consistency model (\lemref{lem:semantics-monotonicity}), we have the proof.
\end{proof}
