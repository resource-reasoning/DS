\section{semantics\label{sec:semantics}}

We model the state of a database by a time-stamp heap that is a partial function from locations to their histories.
The history is a partial function from times to a set of events.
A event is a triple consisting of the value being read or written, the operation, i.e. either read or write, and the transaction identifier.
We use thread pool to model the concurrency.
Each thread has a local stack and a local time, but a globally shared time-stamp heap.
Therefore a thread pool is a partial functions from thread identifiers to the corresponding stack, time and transactions.
The state of each transaction, i.e.\ local state, are a stack which is shared between transactions from the same thread, a heap that is a  snapshot of the time-stamp heap, and fingerprints that are the heap locations being read and written.

\[
    \begin{rclarray}
        \loc \in \Loc & \defeq & \Nat \\
        \val \in \Val & \defeq & \Nat \cup \Loc \\
        \Var & \defeq & \Set{ \vx, \vy, \dots } \\
        \ts \in \Timestamp & \defeq & \texttt{rational number or real number} \\
        \hp \in \Heap & \defeq & \Loc \parfun \Val \\
        \stk \in \Stack & \defeq & \Var \to \Val \\
        \op \in \Operation & \defeq & \Set{\opr, \opw, \ops, \ope} \\
        \settrans \subseteq \TransID & \defeq & \Set{ \alpha , \beta, \dots } \\
        \ThreadID & \defeq & \Set{ i , j, \dots } \\
        \rs \in \Readset, \ws \in \Writeset & \defeq & \powerset{\Loc} \\
        %\tshp \in \Timestampheap & \defeq & \Loc \parfun ( \Timestamp \parfun \powerset{\Val \times \Operation \times \TransID}) \\
        \tshp \in \Timestampheap & \defeq & \Loc \parfun ( \Timestamp \parfun ( \Val \times \Operation \times \TransID ) ) \\
        (\stk, \tshp, \ts) \in \Threadstate & \defeq & \Stack \times \Timestampheap \times \Timestamp \\
        \tdpl \in \Threadpool & \defeq & \ThreadID \parfun \Stack \times \Timestamp \times \prog \\
        \stt \in \State & \defeq & \Timestampheap \times \Threadpool \\
        \lstt = (\stk, \hp, \rs, \ws ) \in \Localstate & \defeq & \Stack \times \Heap \times \Readset \times \Writeset \\
    \end{rclarray}
\]

The arithmetic expression and boolean expression are standard and have no side effect.

\[
    \begin{syntax}{\expr}
              \val \quad          |
        \quad \var \quad          |
        \quad \expr + \expr \quad |
        \quad \expr * \expr \quad |
        \quad \dots 
    \end{syntax}
\]

\[
    \begin{rclarray}
        \eval{\val}_{\stk} & \defeq & \val \\
        \eval{\var}_{\stk} & \defeq & \stk(\val) \\
        \eval{\expr_{1} + \expr_{2}}_{\stk} & \defeq & \eval{\expr_{1}}_{\stk} + \eval{\expr_{2}}_{\stk}   \\
        \eval{\expr_{1} * \expr_{2}}_{\stk} & \defeq & \eval{\expr_{1}}_{\stk} * \eval{\expr_{2}}_{\stk}  
    \end{rclarray}
\]

\[
    \begin{syntax}{\bool}
              \true \quad                |
        \quad \false \quad               |
        \quad \expr = \expr \quad        |
        \quad \expr < \expr \quad        |
        \quad \boolnot \bool \quad       |
        \quad \bool \booland \bool \quad |
        \quad \bool \boolor \bool \quad  |
        \quad \dots 
    \end{syntax}
\]

\[
    \begin{rclarray}
        \eval{\true}_{\stk}& \defeq & \true \\
        \eval{\false}_{\stk} & \defeq & \false \\
        \eval{\expr_{1} = \expr_{2}}_{\stk} & \defeq & \eval{\expr_{1}}_{\stk} = \eval{\expr_{2}}_{\stk}   \\
        \eval{\expr_{1} < \expr_{2}}_{\stk} & \defeq & \eval{\expr_{1}}_{\stk} < \eval{\expr_{2}}_{\stk}   \\
        \eval{\boolnot \bool}_{\stk} & \defeq & \neg \eval{\bool}_{\stk} \\
        \eval{\bool_{1} \booland \bool_{2}}_{\stk} & \defeq & \eval{\bool_{1}}_{\stk} \land \eval{\bool_{2}}_{\stk}  \\
        \eval{\bool_{1} \boolor \bool_{2}}_{\stk}& \defeq & \eval{\bool_{1}}_{\stk} \lor \eval{\bool_{2}}_{\stk}  
    \end{rclarray}
\]

\[
    \begin{syntax}{\cmd}
              \pskip \quad                  |
        \quad \pass{\vx}{\expr} \quad       |
        \quad \pmutate{\expr}{\expr} \quad  |
        \quad \pderef{\vx}{\expr} \quad     |
        \quad \pif{\bool}{\cmd}{\cmd} \quad | \\
              \ploop{\bool}{\cmd} \quad     |
        \quad \cmd \pseq \cmd
    \end{syntax}
\]

The syntax and semantics of a single transaction are standard except \emph{mutate} and \emph{deref}.
The \emph{mutate} also adds the location being written to the write fingerprint set \( \ws \) and the \emph{deref} adds the location to \( \rs \).
Note that there is no parallel composition, because it is within a transaction.

\[
    \begin{rclarray}
        ( \dontcare, \dontcare ) \ \localtransfer \  ( \dontcare, \dontcare ) & \defeq &  ( \Localstate \times \cmd ) \times ( \Localstate \times \cmd ) \\
    \end{rclarray}
\]

\[
    \infer[ass]{%
        ( \stk, \hp, \rs, \ws ) , \pass{\var}{\expr} \ \localtransfer \  ( \stk \remapsto{\var}{\val}, \hp, \rs, \ws ) , \pskip
    }{%
    \eval{\expr}_{\stk} = \val
    }
\]

\[
    \infer[mutate]{%
        ( \stk, \hp, \rs, \ws ) , \pmutate{\expr_{1}}{\expr_{2}} \ \localtransfer \  ( \stk, \hp \remapsto{\loc}{\val}, \rs, \ws \cup \Set{\loc} ) , \pskip
    }{%
        \eval{\expr_{1}}_{\stk} = \loc \quad 
        \eval{\expr_{2}}_{\stk} = \val \quad 
        \loc \in \dom(\hp)
    }
\]

\[
    \infer[deref]{%
        ( \stk, \hp, \rs, \ws ) , \pderef{\var}{\expr} \ \localtransfer \  ( \stk \remapsto{\var}{\val}, \hp, \rs \cup \Set{\loc}, \ws ) , \pskip
    }{%
        \eval{\expr}_{\stk} = \loc \quad 
        \val = \hp(\loc) \quad
        \loc \in \dom(\hp)
    }
\]

\[
    \infer[ifelsetrue]{%
        ( \stk, \hp, \rs, \ws ) , \pif{\bool}{\cmd_{1}}{\cmd_{2}} \ \localtransfer \  ( \stk, \hp, \rs, \ws ) , \cmd_{1}
    }{%
        \eval{\bool}_{\stk} = \true
    }
\]

\[
    \infer[ifelsefalse]{%
        ( \stk, \hp, \rs, \ws ) , \pif{\bool}{\cmd_{1}}{\cmd_{2}} \ \localtransfer \  ( \stk, \hp, \rs, \ws ) , \cmd_{2}
    }{%
        \eval{\bool}_{\stk} = \false
    }
\]

\[
    \infer[whiletrue]{%
        ( \stk, \hp, \rs, \ws ) , \ploop{\bool} \cmd \ \localtransfer \  ( \stk, \hp, \rs, \ws ) , \cmd \pseq \ploop{\bool} \cmd
    }{%
        \eval{\bool}_{\stk} = \true
    }
\]

\[
    \infer[whilefalse]{%
        ( \stk, \hp, \rs, \ws ) , \ploop{\bool} \cmd \ \localtransfer \  ( \stk, \hp, \rs, \ws ) , \pskip
    }{%
        \eval{\bool}_{\stk} = \false \quad
    }
\]

\[
    \infer[seqskip]{%
        ( \stk, \hp, \rs, \ws ) , \pskip \pseq \cmd_{2} \ \localtransfer \  ( \stk, \hp, \rs, \ws ) , \cmd_{2}
    }{%
    }
\]

\[
    \infer[seqnonskip]{%
        ( \stk, \hp, \rs, \ws ) , \cmd_{1} \pseq \cmd_{2} \ \localtransfer \  ( \stk', \hp', \rs', \ws' ) , \cmd_{1}' \pseq \cmd_{2}
    }{%
        ( \stk, \hp, \rs, \ws ) , \cmd_{1} \ \localtransfer \  ( \stk', \hp', \rs', \ws' ) , \cmd_{1}'
    }
\]

A program is sequential and parallel composition of transactions.
To give semantics for a program, we extend the syntax by adding an extra waiting command, \( \pwait{\thid} \), as suffix.
Intuitively, this \( \pwait{\thid} \) indicates that current thread is waiting another thread identified by \( \thid \) until it commits all its transactions and then join the thread.

\[
    \begin{syntax}{\prog}
              \pskip \quad                    |
        \quad \ptrans{\cmd} \quad             |
        \quad \prog \pseq \prog \quad         |
        \quad \pif{\bool}{\prog}{\prog} \quad | 
        \quad \ploop{\bool}{\prog} \quad      |
        \quad \prog \ppar \prog 
    \end{syntax}
\]

\[
    \begin{syntax}{\progext}
              \pwait{\thid} \quad                |
        \quad \prog \quad                        |
        \quad \progext \pseq \pwait{\thid} \quad |
    \end{syntax}
\]

We will explain the \emph{commit}, \emph{par} and \emph{wait}, and the rest are straightforward.
We give label to each transition, and these labels are only usefully for parallel composition.

The \emph{commit} rule says that a transaction prophesies a starting time when this transaction takes a snapshot \( \hp_{s} \) and runs locally, and an ending time when it successfully commits ensured by the \texttt{allowcommit}.

The \emph{par} rule forks a new thread and appends a \( \pwait{\thid} \), parametrised by the new thread identifier \( \thid \), at the merging point.
The \emph{wait} rule waits the thread \( \thid \) until it finishes, then joins the thread and updates the time to the maximum between the two threads.
Note that these two rules are labelled with \( \lfork{\thid, \prog} \) or \( \ljoin{\thid, \ts} \) which are used by the semantics of a top level theadpool.

\[
    \begin{rclarray}
        \tll \in \Translabel & \defeq & 
              \lid \quad                |
        \quad \lcmt{\tsid} \quad        |
        \quad \lfork{\thid,\prog} \quad |
        \quad \ljoin{\thid,\ts} \\
        ( \dontcare, \dontcare ) \ \threadtransfer{ \dontcare } \ ( \dontcare, \dontcare ) & \defeq &  ( \Threadstate \times \progext ) \times \Translabel \times  ( \Threadstate \times \progext )  \\
    \end{rclarray}
\]

\[
    \begin{rclarray}
        \func{startstate}(\tshp,\ts) & \defeq & \lambda \loc \ldotp \val \\
                                     & & \texttt{where} \ \exists \ts' \leq \ts \ldotp \tshp(\loc)(\ts') = (\val,\wop, \dontcare) \land \forall \ts'' \in ( \ts', \ts) \ldotp \tshp(\loc)(\ts'') = (\dontcare,\wop,\dontcare) \\
        \pred{allowcommit}{\tshp,\ws,\rs,\ts_{s},\ts_{e}} & \defeq & 
        \pred{wellformhist}{\tshp,\ws,\rs,\ts_{s},\ts_{e}} \land \pred{consistent}{\tshp,\ws,\rs,\ts_{s},\ts_{e}} \\
        \pred{wellformhist}{\tshp,\ws,\rs,\ts_{s},\ts_{e}} & \defeq  & \forall \ts \in \Set{\ts_{s},\ts_{e}}, \loc \in \ws \cup \rs \ldotp \tshp(\loc)(\ts)\undef \\
        \pred{consistent}{\tshp,\ws,\rs,\ts_{s},\ts_{e}} & \defeq & \forall \loc_{w} \in \ws , \ts \in (\ts_{s},\ts_{e}) \ldotp \tshp(\loc_{w})(\ts) \neq (\dontcare, \wop, \dontcare) \land {} \\
                                                         & & \forall \tsid \ldotp \nexists \ts_{\tsid s} < \ts_{e}, \ts_{\tsid e} > \ts_{e} \ldotp \tshp(\loc_{w})(\ts_{\tsid s}) = (\dontcare, \dontcare, \tsid) \land \tshp(\loc_{w})(\ts_{\tsid e}) = (\dontcare, \wop, \tsid) \land {} \\
                                                         & & \exists \ts_{min} = \min(\Set{\ts'' \ \middle| \ \ts'' > \ts_{e} \land \tshp(\loc_{w})(\ts'')\isdef}) \ldotp  \tshp(\loc_{w})(\ts_{min}) \neq (\dontcare, \rop, \dontcare) \\
        \func{commitTrans}(\tshp,\hp_{s},\hp_{e},\ws,\rs, \tsid, \ts_{s},\ts_{e}) & \defeq &
        \lambda \loc \ldotp
        \begin{funcarray}
            \tshp(\loc) & \loc \notin \ws \cup \rs \\
            \tshp(\loc)\remapsto{\ts_{s}}{(\hp_{s}(\loc),\sop,\tsid)}\remapsto{\ts_{e}}{(\hp_{e}(\loc),\wop,\tsid)} & \loc \in \ws \setminus \rs \\
            \tshp(\loc)\remapsto{\ts_{s}}{(\hp_{s}(\loc),\rop,\tsid)}\remapsto{\ts_{e}}{(\hp_{e}(\loc),\eop,\tsid)} & \loc \in \rs \setminus \ws \\
            \tshp(\loc)\remapsto{\ts_{s}}{(\hp_{s}(\loc),\rop,\tsid)}\remapsto{\ts_{e}}{(\hp_{e}(\loc),\wop,\tsid)} & \loc \in \rs \cap \ws \\
        \end{funcarray} \\
        \func{freshTransId}(\tshp)  & \defeq & \tsid \ \texttt{where} \ \tsid \notin \Set{\tsid' \ \middle| \ (\dontcare,\dontcare,\tsid') \in \bigcup\limits_{\loc,\ts}\tshp(\loc)(\ts)} \\
    \end{rclarray}
\]

\[
    \infer[commit]{%
        ( \stk, \tshp, \ts ) , \ptrans{\cmd} \ \threadtransfer{\lcmt{\tsid}} \ ( \stk', \tshp', \ts_{e} ) , \pskip
    }{%
        \begin{array}{c}
            \ts_{s} \geq \ts
            \quad \ts_{e} > \ts_{s} 
            \quad \hp_{s} = \func{startstate}(\tshp, \ts_{s}) 
            \quad ( \stk, \hp_{s}, \emptyset, \emptyset ) , \cmd \localtransfer^{*} ( \stk', \hp_{e}, \rs, \ws ) , \pskip \\
            \pred{allowcommit}{\tshp,\ws,\rs,\ts_{s},\ts_{e}} 
            \quad \tsid = \func{freshTransId}(\tshp)
            \quad \tshp' = \func{commitTrans}(\tshp,\hp_{s},\hp_{e},\ws,\rs,\tsid,\ts_{s},\ts_{e})
        \end{array}
    }
\]

\[
    \infer[conditiontrue]{%
        ( \stk, \tshp, \ts ) , \pif{\bool}{\prog_{1}}{\prog_{2}} \ \threadtransfer{\lid} \  ( \stk, \tshp, \ts ) , \prog_{1}
    }{%
        \eval{\bool}_{s} = \true
    }
\]

\[
    \infer[conditionfalse]{%
        ( \stk, \tshp, \ts ) , \pif{\bool}{\prog_{1}}{\prog_{2}} \ \threadtransfer{\lid} \  ( \stk, \tshp, \ts ) , \prog_{2}
    }{%
        \eval{\bool}_{s} = \false
    }
\]

\[
    \infer[norep]{%
        ( \stk, \tshp, \ts ) , \ploop{\bool}{\prog} \ \threadtransfer{\lid} \ ( \stk, \tshp, \ts ) , \pskip
    }{%
        \eval{\bool}_{s} = \false
    }
\]

\[
    \infer[rep]{%
        ( \stk, \tshp, \ts ) , \ploop{\bool}{\prog} \ \threadtransfer{\lid} \  ( \stk, \tshp, \ts ) , \prog \pseq \ploop{\bool}{\prog}
    }{%
        \eval{\bool}_{s} = \true
    }
\]

\[
    \infer[seqskip]{%
        ( \stk, \tshp, \ts ) , \pskip \pseq \progext \ \threadtransfer{\lid} \  ( \stk, \tshp, \ts ) , \progext
    }{%
    }
\]

\[
    \infer[seqnoskip]{%
        ( \stk, \tshp, \ts ) , \progext_{1} \pseq \progext_{2} \ \threadtransfer{\tll} \ ( \stk', \tshp', \ts' ) , {\progext_{1}}' \pseq \progext_{2}
    }{%
        ( \stk, \tshp, \ts ) , \progext_{1} \ \threadtransfer{\tll} \  ( \stk', \tshp', \ts' ) , {\progext_{1}}' 
    }
\]

\[
    \infer[par]{%
        ( \stk, \tshp, \ts ) , \prog_{1} \ppar \prog_{2} \ \threadtransfer{\lfork{\thid, \prog_{2}}} \  ( \stk, \tshp, \ts ) , \prog_{1} \pseq \pwait{\thid}
    }{%
    }
\]

\[
    \infer[wait]{%
        ( \stk, \tshp, \ts ) , \pwait{\thid} \ \threadtransfer{\ljoin{\thid,\ts'}} \  ( \stk, \tshp , \max\Set{\ts,\ts'} ) , \pskip 
    }{%
    }
\]

\[
    \begin{rclarray}
        \dontcare \ \globaltransfer{\dontcare} \ \dontcare & \defeq & \State \times \Translabel \times \State  \\
    \end{rclarray}
\]

The semantics of theadpool picks a thread to run one step.
If the step is a fork, it generates a new thread with a new stack and a local time that is the same as its parent thread.
If it is a join, the threadpool passes the child's local time to its parent thread.

\[
    \infer[single]{%
        ( \tshp, \tdpl \uplus \Set{ \thid \mapsto (\stk, \ts, \progext) } ) \ \globaltransfer{\tll} \  ( \tshp', \tdpl \uplus \Set{ \thid \mapsto (\stk', \ts', {\progext}') } ) 
    }{%
        ( \stk, \tshp, \ts ) , \progext \ \threadtransfer{\tll} \  ( \stk', \tshp', \ts' ) , {\progext}' 
        \quad \tll \in \Set{ \lid, \lcmt{\dontcare} }
    }
\]

\[
    \infer[par]{%
        ( \tshp, \tdpl \uplus \Set{ \thid \mapsto (\stk, \ts, \progext) } ) \ \globaltransfer{\lfork{\thid', \prog''}} \  ( \tshp', \tdpl \uplus \Set{ \thid \mapsto (\stk', \ts', {\progext}'), \thid' \mapsto (\lambda \var \ldotp 0, \ts', \prog'') } )
    }{%
        ( \stk, \tshp, \ts ) , \progext \ \threadtransfer{\lfork{\thid', \prog''}} \  ( \stk', \tshp', \ts' ) , {\progext}' 
    }
\]

\[
    \infer[wait]{%
        ( \tshp, \tdpl \uplus \Set{ \thid \mapsto (\stk, \ts, \progext), \thid' \mapsto (\stk', \ts'', \pskip) } )  \ \globaltransfer{\ljoin{\thid',\ts''}} \ ( \tshp', \tdpl \uplus \Set{ \thid \mapsto (\stk', \ts', {\progext}')} )
    }{%
        ( \stk, \tshp, \ts ) , \progext \ \threadtransfer{\ljoin{\thid',\ts''}} \  ( \stk', \tshp', \ts' ) , {\progext}' 
    }
\]


A program to check 

\[
    \begin{session}
        \begin{array}{@{}c || c || c || c@{}}
            \begin{transaction}
                \pderef{\vx}{\loc_x}; \\
                \pifs{\vx=0} \\
                \quad \pmutate{\loc_y}{1}
            \end{transaction} & 
            \begin{transaction}
                \pderef{\vy}{\loc_y}; \\
                \pifs{\vx=0} \\
                \quad \pmutate{\loc_x}{1}
            \end{transaction} & 
            \begin{transaction}
                \pmutate{\loc_x}{2}
            \end{transaction} & 
            \begin{transaction}
                \pmutate{\loc_y}{2}
            \end{transaction} \\
        \end{array}
    \end{session}
\]
