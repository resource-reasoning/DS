\section{Semantics\label{sec:semantics}}
\begin{defn}[Program values]
\label{def:prgram_values}
Assume a countably infinite set of \emph{addresses}, $\addr \in \Addr$, and a countably infinite set of \emph{program variables} $\vx \in {\Var}$. The set of \emph{program values} is $\val \in \Val \eqdef \Nat \cup \Addr$, where $\Nat$ denotes the set of natural numbers.
\end{defn}
%
\begin{defn}[Stacks]
\label{def:stacks}
Given the set of program variables $\Var$ and the set of program values $\Val$ (\defin\ref{def:prgram_values}), the set of variable stacks is $\stk \in \Stack \eqdef \Var \parfinfun \Val$.
\end{defn}
%
Our programs (ranged over by $\prog$) are defined by an inductive grammar comprising the standard constructs of $\pskip$, sequential composition ($\prog; \prog$), non-deterministic choice ($\prog+\prog$), loops ($\prog^*$) and parallel composition ($\prog \ppar \prog$). Additionally, our programming language contains the \emph{transaction} construct $\ptrans{\trans}$ denoting the \emph{atomic} execution of the transaction $\trans$. The atomicity guarantees of this execution are dictated by the underlying consistency model (snapshot isolation in this case).
Transactions (ranged over by $\trans$) are defined by a similar inductive grammar comprising $\pskip$, non-deterministic choice, loops and sequential composition, as well as constructs for assignment, lookup and update. Transactions do \emph{not} contain the \emph{parallel} composition construct ($\ppar$) as they are to be executed atomically.

\begin{defn}[Programming language]
\label{def:language}
The set of \emph{programs}, $\prog \in \Programs$, is defined by the following grammar:
\[
    \begin{rclarray}
    \prog & ::= &
        \pskip \mid 
        \ptrans{\trans} \mid 
        \prog \pseq \prog \mid 
        \prog \pchoice \prog \mid 
        \prog\prepeat \mid
        \prog \ppar \prog
    \end{rclarray}
\]
%
The $\trans \in \Transactions$ in the grammar above denotes a \emph{transaction} defined by the following grammar:
%
\[
    \begin{rclarray}
        \trans & ::= &
        \pskip \mid
        \pass{\vx}{\expr} \mid
        \pmutate{\expr}{\expr} \mid
        \pderef{\vx}{\expr} \mid
        \trans \pseq \trans \mid
        \trans \pchoice \trans \mid
        \trans\prepeat
    \end{rclarray}
\]
%
where $\expr \in \Expressions$ denotes an \emph{arithmetic expression} defined by the grammar below with $\val \in \Val$ and $\vx \in \Var$ (\defin\ref{def:prgram_values}).
%
\[
    \begin{rclarray}
        \expr & ::= &
        \val \mid
        \var \mid
        \expr + \expr \mid
        \expr * \expr \mid
        \dots 
    \end{rclarray}
\]
%
Given a stack $\stk \in \Stack$ (\defin\ref{def:stacks}), the \emph{expression evaluation} function, $\evalE[.]{.}:\Expressions \times \Stack \parfun \Val$, is defined inductively over the structure of expressions as follows: 
%
\[
    \begin{rclarray}
        \evalE{\val} & \defeq & \val \\
        \evalE{\var} & \defeq & \stk(\var) \\
        \evalE{\expr_{1} + \expr_{2}} & \defeq & \evalE{\expr_{1}} + \evalE{\expr_{2}} \\
        \evalE{\expr_{1} * \expr_{2}} & \defeq & \evalE{\expr_{1}} * \evalE{\expr_{2}} \\
\\
    \end{rclarray}
\]
%
\end{defn}
%

We model the global database state as a \emph{timestamp heap}. A timestamp heap is a partial function from addresses to \emph{histories}.
A history is a partial function from timestamps to a set of \emph{events}.
An event is a triple comprising the value read or written, the identifier of the transaction carrying out the event, and an \emph{event tag} denoting a \emph{start event} ($\etS$), an \emph{end} event ($\etE$), a \emph{read} event ($\etR$) or a \emph{write} event ($\etW$).
We model our timestamps, $\ts \in \Timestamp$, as elements of an (uncountably) infinite set with a total order relation $<$. To ensure the availability of an appropriate timestamp, we assume that the timestamp set $\Timestamp$ is \emph{dense}. That is, given any two timestamps $\ts_1$ and $\ts_2$ such that $\ts_1 < \ts_2$, an intermediate timestamp $\ts$ can be found such that $\ts_1 < \ts < \ts_2$.

\begin{defn}[Event tags]
\label{ref:event-tag}
The set of \emph{event tags} is $\etag \in \ETags \eqdef \{\etS, \etE, \etR, \etW \}$.
\end{defn}
%
\begin{defn}[Timestamps]
\label{def:timestamp}
The set of \emph{timestamps}, $\Timestamp$, is a infinitely countable set, and there is a \emph{total order} relation on it, $<\ : \Timestamp \times \Timestamp$, such that:
%
\[
	\for{\ts_1, \ts_2 \in \Timestamp} \ts_1 < \ts_2 \lor \ts_2 < \ts_1
\]
%
This timestamp set $\Timestamp$ is \emph{dense} with respect to the ordering relation $<$. 
That is,
\[
	\for{\ts_1, \ts_2} \ts_1 < \ts_2 
	\implies 
	\exsts{\ts} \ts_1 < \ts < \ts_2	
\]
\end{defn}
%
We write $\ts_1 \leq \ts_2$ as a shorthand for $\ts_1 < \ts_2 \lor \ts_1 = \ts_2$.
We write $\ts_1 \oplus \ts \odot \ts_2 $ for $\ts_1 \oplus \ts \land \ts \odot \ts_2 $, where $\oplus, \odot \in \{<, \leq\}$.
We often use the mirrored symbols and write $\ts_1 > \ts_2$ (resp.~$\ts_1 \geq \ts_2$) for $\ts_2 < \ts_1$ (resp.~$\ts_2 \leq \ts_1$).
Lastly, we use the standard interval notation and write:
%
\[
\begin{rclarray}
	(\ts_1, \ts_2) & \text{for} & \Set{\ts \mid \ts_1 < \ts < \ts_2 } \\
	(\ts_1, \ts_2] & \text{for} & \Set{\ts \mid \ts_1 < \ts \leq \ts_2 } \\
	{[\ts_1, \ts_2)} & \text{for} & \Set{\ts \mid \ts_1 \leq \ts < \ts_2 } \\	
	{[\ts_1, \ts_2]} & \text{for} & \Set{\ts \mid \ts_1 \leq \ts \leq \ts_2 } 
\end{rclarray}
\]
\begin{defn}[Timestamp heaps]
\label{def:timestamp_heaps}
Assume a countably infinite set of \emph{transaction identifiers} $\tsid, \beta \in \TransID$.
Given the set of event tags $\ETags$ (\defin\ref{ref:event-tag}), program values $\Val$ (\defin\ref{def:prgram_values}), program addresses $\Addr$ (\defin\ref{def:prgram_values}) and timestamps \(\Timestamp\) (\defin\ref{def:timestamp}), the set of \emph{timestamp heaps} is defined as $\tshp \in \TSHeaps \eqdef \Addr \parfinfun (\Val \times \TransID \times \ETags)$.
The \emph{timestamp heap composition function}, $\composeTS: \TSHeaps \times \TSHeaps \parfun \TSHeaps$, is defined as follows, for all $\addr \in \Addr$, where $\uplus$ denotes the standard disjoint function union:
%
\[
	(\tshp_1 \composeTS \tshp_2)(\addr) \defeq 
	\begin{cases}
		\tshp_1(\addr) \uplus \tshp_2(\addr) & \text{if } \addr \in \dom(\tshp_1) \text{ and } \addr \in \dom(\tshp_2) \\
		\tshp_1(\rid) & \text{if } \addr \in \dom(\tshp_1) \text{ and } \addr \not\in \dom(\tshp_2) \\
		\tshp_2(\rid) & \text{if } \addr \not\in \dom(\tshp_1) \text{ and } \addr \in \dom(\tshp_2) \\
		\text{undefined} & \text{otherwise}
	\end{cases}
\]
%
The \emph{timestamp heap unit element} is $\unitTS \eqdef \emptyset$, denoting a function with an empty domain.
The \emph{partial commutative monoid of timestamp heaps} is $(\TSHeaps, \composeTS, \{\unitTS\})$. 
\end{defn}
 
Whilst the state of the database is given by globally-accessed (by all threads) timestamp heaps, we use \emph{fingerprint heaps} to model a \emph{local snapshot} of the global timestamp heaps made available to transactions during their execution. 
In order to successfully commit a transaction and avoid conflicts, we must track the \emph{fingerprint} of a transaction, namely those addresses read from or written to by the transaction.
As such, we model fingerprint heaps as finite partial maps from addresses to pairs comprising a value and a fingerprint.
The fingerprint of an address may be 1) $\emptyset$ denoting that the address has not been touched;
2) $\Set{\fpR}$ denoting that the address has been read;
3) $\Set{\fpW}$ denoting that the address has been mutated (written to);
and 4) $\Set{\fpR, \fpW}$ denoting that the address has been initially read and subsequently mutated.   
%
%
\begin{definition}[Heaps]\label{def:heaps}
Given the sets of program values $\Val$ (\defin\ref{def:prgram_values}) and  addresses $\Addr$ (\defin\ref{def:timestamp_heaps}), the set of \emph{ heaps} is: $\h \in \Heaps \eqdef \Addr \parfinfun \Val$.
The \emph{heap composition function}, $\composeH: \Heaps \times \Heaps \parfun \Heaps$, is defined as $\composeH \eqdef \uplus$, where $\uplus$ denotes the standard disjoint function union. The \emph{ heap unit element} is $\unitH \eqdef \emptyset$, denoting a function with an empty domain.
The \emph{partial commutative monoid of  heaps} is $(\Heaps, \composeH, \{\unitH\})$.
\end{definition}
%
\begin{defn}[Fingerprints]
\label{def:fingerprint}
The set of \emph{fingerprints} is $\fp \in \Fingerprint \eqdef \powerset{\Set{\fpR,\fpW}}$.
\end{defn}
%
\begin{defn}[Fingerprint heaps]
\label{def:fingerprint_heaps}
Given the sets of program values $\Val$ (\defin\ref{def:prgram_values}), addresses $\Addr$ (\defin\ref{def:timestamp_heaps}) and fingerprints $\Fingerprint$ (\defin\ref{def:fingerprint}), the set of \emph{fingerprint heaps} is: $\fph \in \FPHeaps \eqdef \Addr \parfinfun (\Val \times \Fingerprint)$.
The \emph{fingerprint heap composition function}, $\composeFP: \FPHeaps \times \FPHeaps \parfun \FPHeaps$, is defined as $\composeFP \eqdef \uplus$, where $\uplus$ denotes the standard disjoint function union. The \emph{fingerprint heap unit element} is $\unitFP \eqdef \emptyset$, denoting a function with an empty domain.
The \emph{partial commutative monoid of fingerprint heaps} is $(\FPHeaps, \composeFP, \{\unitFP\})$.  
\end{defn}
%
Given a fingerprint heap $\fph$ and an address $\addr$, we write $\fphVal(\addr)$ and $\fphFP(\addr)$ for the first and second projections of $\fph(\addr)$, respectively. We write $\unitFP$ for a fingerprint heap with an empty domain. We write $\fph_1 \uplus \fph_2$ for the standard disjoint function union of $\fph_1$ and $\fph_2$. 

We introduce two update functions on fingerprints, $\addFPR{\fp}$ and $\addFPW{\fp}$, for updating a fingerprint $\fp$. Intuitively, the $\addFPW{\fp}$ always \emph{extends} $\fp$ with the $\fpW$ fingerprint. On the other hand, the $\addFPR{\fp}$ extends $\fp$ with $\fpR$ \emph{only if} $\fp$ does not already contain the $\fpW$ fingerprint (i.e.~$\fpW \not\in \fp$). This is to capture the fact that once an address is written to and thus the fingerprint contains $\fpW$, the following reads from the same address are considered local and need not be recorded in the fingerprint.
 
\begin{defn}[Fingerprint extension]
\label{def:fingerprint-extension}
Given the set of fingerprints $\Fingerprint$ (\defin\ref{def:fingerprint}), the \emph{read fingerprint extension} function, $\addFPR{(.)}{.}: \Fingerprint \rightarrow \Fingerprint$, and the \emph{write fingerprint extension} function, $\addFPW{(.)}{.}: \Fingerprint \rightarrow \Fingerprint$, are defined as follows, for all $\fp \in \Fingerprint$:
\[
\begin{rclarray}
	\addFPW{\fp} & \eqdef & \fp \cup \{\fpW\} \\
	\addFPR{\fp} & \eqdef &
	\begin{cases}
		\fp \cup \{\fpR\}  & \text{if } \fpW \not\in \fp \\
		\fp & \text{otherwise}
	\end{cases}
\end{rclarray}	
\]
\end{defn}

\begin{defn}[Read and write sets]
\label{def:rs-ws}
Given the set of fingerprints $\Fingerprint$ (\defin\ref{def:fingerprint}), the \emph{read set} and \emph{write set} function, $\rsName, \wsName: \Fingerprint \to \powerset{\Addr}$ is defined as follows:
\[
\begin{rclarray}
    \ws{\fph} & \defeq & \myset{\loc}{ \exsts{\fp} \fph(\loc) = (\stub, \fp) \land \fpW \in \fp} \\
    \rs{\fph} & \defeq & \myset{\loc}{ \exsts{\fp} \fph(\loc) = (\stub, \fp) \land \fpR \in \fp} \\
\end{rclarray}	
\]
\end{defn}

\subsection{Local/Transaction Semantics}

We define the operational semantics of transactions $\trans$ with respect to a pair of the form $(\stk, \fph)$ comprising a (local) stack and a (local) fingerprint heap corresponding to a snapshot of the global timestamp heap. The operational semantics of transactions is given in \fig\ref{fig:transaction_semantics}.
The operational semantics of transactions is standard with the exception of the \rl{TRead} and \rl{TWrite} rules where the fingerprint of the address read from (resp.~written to) is extended with $\fpR$ (resp.~$\fpW$).


\begin{defn}[Transaction semantics]
Given the sets of stacks (\defin\ref{def:stacks}), fingerprint heaps (\defin\ref{def:fingerprint_heaps}) and transactions (\defin\ref{def:language}), the \emph{operational semantics of transactions}, $\toL : ((\Stack \times \FPHeaps) \times \Transactions) \times ((\Stack \times \FPHeaps) \times \Transactions)$, is given in \fig\ref{fig:transaction_semantics}.
\end{defn}

\begin{figure}
\hrule\vspace{5pt}
\[	
    \infer[\rl{TAss}]{%
        ( \stk, \fph) , \pass{\var}{\expr} \ \toL \  (\stk \remapsto{\var}{\val}, \fph) , \pskip
    }{%
    \evalE{\expr} = \val
    }
\]

\[
    \infer[\rl{TWrite}]{%
        ( \stk, \fph), \pmutate{\expr_{1}}{\expr_{2}} \ \toL \  ( \stk, \fph \remapsto{\addr}{(\val, \addFPW{\fp})}) , \pskip
    }{%
        \evalE{\expr_{1}} = \addr && 
        \evalE{\expr_{2}} = \val && 
        \fph(l) {=} (\stub, \fp)
    }
\]

\[
    \infer[\rl{TRead}]{
        ( \stk, \fph) , \pderef{\var}{\expr} \ \toL \  (\stk \remapsto{\var}{\val}, \fph \remapsto{\addr}{(\val, \addFPR{\fp})}), \pskip
    }{
        \evalE{\expr} = \addr && 
        \fph(\addr) {=} (\val, \fp) 
    }
\]

\[
    \infer[\rl{TChoiseL}]{%
        (\stk, \fph) , \trans_{1} \pchoice \trans_{2} \ \toL \  (\stk, \fph) , \trans_{1}
    }{}
\]

\[
    \infer[\rl{TChoiseR}]{%
        (\stk, \fph) , \trans_{1} \pchoice \trans_{2} \ \toL \  (\stk, \fph), \trans_{2}
    }{%
    }
\]

\[
    \infer[\rl{TLoop}]{%
        (\stk, \fph),  \trans\prepeat \ \toL \  (\stk, \fph), \pskip \pchoice (\trans \pseq \trans\prepeat)
    }{%
    }
\]


\[
    \infer[\rl{TSeqSkip}]{%
        (\stk, \fph), \pskip \pseq \trans_{2} \ \toL \  (\stk, \fph), \trans_{2}
    }{%
    }
\]

\[
    \infer[\rl{TSeq}]{%
        (\stk, \fph), \trans_{1} \pseq \trans_{2} \ \toL \  (\stk', \fph'), \trans_{1}' ; \trans_{2}
    }{%
        (\stk, \fph), \trans_{1} \ \toL \  (\stk', \fph'), \trans_{1}'
    }
\]
\hrule\vspace{5pt}
\caption{The transaction operational semantics}
\label{fig:transaction_semantics}
\end{figure}

In order to formulate the operational semantics of a program $\prog$, we extend the programming language with an auxiliary wait construct, \(\pwait{\thid} \), added to programs as a suffix to denote thread joining points.
Intuitively, the \( \pwait{\thid} \) construct indicates that the current thread is waiting on the thread identified by \( \thid \) to finish its execution and join the current thread. We refer to the programs produced by this extended syntax as \emph{intermediate programs}. This is because the $\pwait{.}$ construct yields additional programs that cannot be written by the clients of the database and is merely used to capture intermediate steps during parallel execution. 
%

We define the per-thread operational semantics of programs with respect to a triple of the form $(\stk, \tshp, \ts)$ comprising a (locally-accessed) stack, a (globally-accessed) timestamp heap, and a (locally-recorded) timestamp. 
Each step of the per-thread operational semantics is decorated with a \emph{label} recording the action taken by the thread. In particular, a label may be $\lbID$, denoting an identity transition; $\lbC{\tsid}$, denoting the committing of transaction $\tsid$; $\lbF{\thid, \prog}$, denoting the forking a new thread $\thid$ the execute program $\prog$; or $\lbJ{\thid, \ts}$, denoting the joining of thread $\thid$ with the local timestamp $\ts$.
  
The per-thread operational semantics of programs is given in \fig\ref{fig:thread_semantics}.
With the exception of the \rl{PCommit}, \rl{PPar} and \rl{PWait}, the remaining rules are straightforward.

\begin{defn}[Thread transition labels]
\label{def:label}
Assume a countably infinite set of thread identifiers $\thid,j \in \ThreadID$.
The set of \emph{thread transition labels}, $\lb \in \Translabel$, is defined by the following grammar, where $\prog$ denotes a program (\defin\ref{def:language}), the $\tsid$ demotes a transaction identifier and $\ts$ denotes a timestamp (\defin\ref{def:timestamp_heaps}):
\[
	\iota \in \Translabel ::= \lbID \mid \lbC{\tsid} \mid \lbF{\thid,\prog} \mid \lbJ{\thid,\ts}
\]
\end{defn}


\begin{defn}[Thread semantics]
\label{def:thread_semantics}
Assume a countably infinite set of thread identifiers $\thid,j \in \ThreadID$.
The set of \emph{intermediate programs}, $\iprog \in \IntermediatePrograms$, is defined by the following grammar:
%
\[
    \iprog ::= \prog \mid \iprog \pseq \pwait{\thid}
\]
%
Given the set of stacks $\Stack$ (\defin\ref{def:stacks}), timestamp heaps $\TSHeaps$ and timestamps $\Timestamp$ (\defin\ref{def:timestamp}), the \emph{per-thread operational semantics} of programs:
%
\[
	\toT{} : 
	\left((\Stack \times \TSHeaps \times \Timestamp) \times \IntermediatePrograms \right) 
	\times \Translabel \times  
	\left((\Stack \times \TSHeaps \times \Timestamp) \times \IntermediatePrograms \right) 
\]
%
is defined in \fig\ref{fig:thread_semantics}.
\end{defn}

The \rl{PCommit} rule states that a transaction prophesies a starting timestamp $\ts_s$ (at which point it takes a snapshot $\fph_s$ and runs locally), and an ending timestamp $\ts_e$ (at which point the transaction is successfully committed as ensured by the $\cancommitName$ predicate).

The \rl{Par} rule forks a new thread and inserts the appropriate joining point by appending the auxiliary \( \pwait{\thid} \) operation, where $\thid$ denotes the identifier of the newly forked thread. 
The \rl{Wait} rule dually awaits the termination of thread $\thid$ and subsequently updates its timestamp to the maximum value between its own timestamp and that of $\thid$.
Note that these two rules are labelled with the $\lbF{\thid, \prog}$ and $\lbJ{\thid, \ts}$ which are used by the semantics of the thread pool described shortly.

\begin{figure}
%
\hrule\vspace{5pt}
%
\[
    \infer[\rl{Commit}]{%
        ( \stk, \tshp, \ts ) , \ptrans{\trans} \ \toT{\lbC{\tsid}} \ ( \stk', \tshp', \ts_{e} ) , \pskip
    }{%
        \begin{array}{c}
            \ts \leq \ts_s < \ts_e 
            \qquad \fph_s = \snapshot{\tshp}{\ts_s}
            \qquad ( \stk, \fph_s) , \trans \toL^{*} ( \stk', \fph_e) , \pskip \\
            \cancommit{\tshp}{\fph_e}{\ts_s}{\ts_e} 
            \quad \pred{fresh}{\tshp, \tsid}
            \quad \tshp' = \commit{\tshp}{\fph_s}{\fph_e}{\tsid}{\ts_s}{\ts_e}
        \end{array}
    }
\]

\[
    \infer[\rl{PChoiseL}]{%
        ( \stk, \tshp, \ts ) , \prog_{1} \pchoice \prog_{2} \ \toT{\lbID} \  ( \stk, \tshp, \ts ) , \prog_{1}
    }{%
    }
\]

\[
    \infer[\rl{PChoiseR}]{%
        ( \stk, \tshp, \ts ) , \prog_{1} \pchoice \prog_{2} \ \toT{\lbID} \  ( \stk, \tshp, \ts ) , \prog_{2}
    }{%
    }
\]

\[
    \infer[\rl{PLoop}]{%
        ( \stk, \tshp, \ts ) , \prog\prepeat \ \toT{\lbID} \  ( \stk, \tshp, \ts ) , \pskip \pchoice (\prog \pseq \prog\prepeat)
    }{%
    }
\]

\[
    \infer[\rl{PSeqSkip}]{%
        ( \stk, \tshp, \ts ) , \pskip \pseq \iprog \ \toT{\lbID} \  ( \stk, \tshp, \ts ) , \iprog
    }{%
    }
\]

\[
    \infer[\rl{PSeq}]{%
        ( \stk, \tshp, \ts ) , \iprog_{1} \pseq \iprog_{2} \ \toT{\lb} \ ( \stk', \tshp', \ts' ) , {\iprog_{1}}' \pseq \iprog_{2}
    }{%
        ( \stk, \tshp, \ts ) , \iprog_{1} \ \toT{\lb} \  ( \stk', \tshp', \ts' ) , {\iprog_{1}}' 
    }
\]

\[
    \infer[\rl{PPar}]{%
        ( \stk, \tshp, \ts ) , \prog_{1} \ppar \prog_{2} \ \toT{\lbF{\thid, \prog_{2}}} \  ( \stk, \tshp, \ts ) , \prog_{1} \pseq \pwait{\thid}
    }{%
    }
\]

\[
    \infer[\rl{PWait}]{%
        ( \stk, \tshp, \ts ) , \pwait{\thid} \ \toT{\lbJ{\thid,\ts'}} \  ( \stk, \tshp , \max\Set{\ts,\ts'} ) , \pskip 
    }{%
    }
\]
 
where,
\[
\begin{rclarray}
	\snapshot{.}{.} & : & \TSHeaps \times \Timestamp \parfun \FPHeaps \\
%	
	\snapshot{\tshp}{\ts} & \defeq & 
	\lambda \addr \ldotp
	\begin{cases} 
		(\val, \emptyset) & 
		\exsts{\ts' \leq \ts} \tshp(\addr)(\ts') {=} (\val,\etW, \stub) 
		\land \for{\ts'' \in ( \ts', \ts)} \tshp(\addr)(\ts'') {=} (\stub,\etR,\stub) \\
        \text{undefined} & \text{otherwise}
	\end{cases} 
	\vspace{3pt}\\
	\commit{.}{.}{.}{.}{.}{.} & : & \TSHeaps \times \FPHeaps \times \FPHeaps \times \TransID \times \Timestamp \times \Timestamp \to \TSHeaps \\
%	
	\commit{\tshp}{\fph_s}{\fph_e}{\tsid}{\ts_s}{\ts_e} & \defeq &
	\lambda \addr \ldotp
	\begin{cases}
		\tshp(\addr)\remapsto{\ts_s}{(\fphVal[\fph_s](\addr),\etS,\tsid)}\remapsto{\ts_e}{(\fphVal[\fph_e](\addr),\etW,\tsid)} 
		& \text{if \;} \fphFP[\fph_e](\addr) {=} \{\fpW\} \\
		\tshp(\addr)\remapsto{\ts_s}{(\fphVal[\fph_s](\addr),\etR,\tsid)}\remapsto{\ts_e}{(\fphVal[\fph_e](\addr),\etE,\tsid)} 
		& \text{if \;} \fphFP[\fph_e](\addr) {=} \{\fpR\} \\
		\tshp(\addr)\remapsto{\ts_s}{(\fphVal[\fph_s](\addr),\etR,\tsid)}\remapsto{\ts_e}{(\fphVal[\fph_e](\addr),\etW,\tsid)} & \text{if \;} \fphFP[\fph_e](\addr) {=} \{\fpR, \fpW\} \\
		\tshp(\addr) & \text{otherwise}
	\end{cases} 
	\vspace{3pt}\\
%
%              
	\cancommit{\tshp}{\fph}{\ts_s}{\ts_e} 
	& \defeq & 
	\wfhist{\tshp}{\fph}{\ts_s}{\ts_e} \land \consistent{\tshp}{\fph}{\ts_s}{\ts_e} 
	\vspace{3pt}\\
%
%        
	\wfhist{\tshp}{\fph}{\ts_s}{\ts_e} 
	& \defeq  & 
 	\for{\addr} \for{\ts \in \Set{\ts_{s},\ts_{e}}} \fphFP(\addr) {\ne} \emptyset \implies \tshp(\addr)(\ts)\undef 
	\vspace{3pt}\\
%
%        
	\consistent{\tshp}{\fph}{\ts_s}{\ts_e}
	& \defeq & 
	\for{\addr} \fpW \in \fphFP(\addr) \implies \\
	&& \quad \for{\ts \in (\ts_s,\ts_e)} \tshp(\addr)(\ts) {\ne} (\stub, \etW, \stub) \\
	&& \quad \land\ \neg\exsts{\tsid, \ts'_s, \ts'_e} \ts'_s < \ts_e \land
       \ts'_e > \ts_e \land \tshp(\addr)(\ts'_s) = (\stub, \stub, \tsid) \land 
       \tshp(\addr)(\ts'_e) = (\stub, \etW, \tsid) \\
	&& \quad \land\ \for{\ts_m} \ts_m {=} \min(\Setcon{\ts'' }{ \ts'' > \ts_{e} \land
       \tshp(\addr)(\ts'')\isdef}) \implies \tshp(\addr)(\ts_{min}) \neq (\stub, \etR, \stub) 
	\vspace{3pt}\\
%
%        
	\pred{fresh}{\tshp, \tsid}  & \defeq & \neg\exsts{\addr, \ts} \tshp(\addr)(\ts) {=} (\stub, \stub, \tsid)
    \end{rclarray}
\]
\hrule\vspace{5pt}
\caption{Per-thread operational semantics}
\label{fig:thread_semantics}
\end{figure}

In order to model concurrency, we use thread pools.
A thread pool is modelled as a finite partial map from thread identifiers to triples of the form $(\stk, \ts, \prog)$. That is, each thread is associated with a stack $\stk$,a timestamp $\ts$ and a program $\prog$ to be executed. 

\begin{defn}[Thread pools]
\label{def:thread_pools}
Given the sets of stacks $\Stack$ (\defin\ref{def:stacks}), timestamps $\Timestamp$ (\defin\ref{def:timestamp_heaps}) and programs $\Programs$ (\defin\ref{def:language}), the set of \emph{thread pools} is: $\thpl \in \TPool \eqdef \ThreadID \parfinfun \Stack \times \Timestamp \times \Programs$.
\end{defn}
 
\begin{defn}[Thread pool semantics] 
\label{def:thread_pool_semantics}
Given the sets of timestamp heaps $\TSHeaps$ (\defin\ref{def:timestamp_heaps}), transition labels \( \Translabel \) (\defin\ref{def:label}) and thread pools $\TPool$ (\defin\ref{def:thread_pools}), the \emph{thread pool semantics}, 
%
\[
	\toG{} : (\TSHeaps \times \TPool) \times \Translabel \times (\TSHeaps \times \TPool) 
\]
%
is defined in \fig\ref{fig:thread_pool_semantics}.
%
\end{defn}
%
The thread pool operational semantics is given in \fig\ref{fig:thread_pool_semantics}, where an arbitrary thread in the pool $\thpl$ is picked to run for one step.
If the next execution step is a thread fork, then a new thread $\thid$ is allocated in the pool to be executed with its stack and timestamp copied from those of the parent (forking) thread.
Conversely, when the next execution step is the joining of thread $\thid'$, then $\thid'$ is removed from the thread pool and the local time stamp is accordingly updated to the maximum timestamp between the parent thread and that of $\thid'$ (as guaranteed by the per-thread semantic relation $\toT{}$ in the premise).
%
\begin{figure}
\hrule\vspace{5pt}
%
\[
    \infer[\rl{PSingle}]{%
        ( \tshp, \thpl \uplus \Set{ \thid \mapsto (\stk, \ts, \iprog) } ) \ \toG{\lb} \  ( \tshp', \thpl \uplus \Set{ \thid \mapsto (\stk', \ts', {\iprog}') } ) 
    }{%
        ( \stk, \tshp, \ts ) , \iprog \ \toT{\lb} \  ( \stk', \tshp', \ts' ) , {\iprog}' 
        \quad \lb \in \Set{ \lbID, \lbC{\stub} }
    }
\]

\[
    \infer[\rl{PFork}]{%
        ( \tshp, \thpl \uplus \Set{ \thid \mapsto (\stk, \ts, \iprog) } ) \ \toG{\lbF{\thid', \prog''}} \  ( \tshp', \thpl \uplus \Set{ \thid \mapsto (\stk', \ts', {\iprog}'), \thid' \mapsto (\lambda \var \ldotp 0, \ts', \prog'') } )
    }{%
        ( \stk, \tshp, \ts ) , \iprog \ \toT{\lbF{\thid', \prog''}} \  ( \stk', \tshp', \ts' ) , {\iprog}' 
    }
\]

\[
    \infer[\rl{PJoin}]{%
        ( \tshp, \thpl \uplus \Set{ \thid \mapsto (\stk, \ts, \iprog), \thid' \mapsto (\stk', \ts'', \pskip) } )  \ \toG{\lbJ{\thid',\ts''}} \ ( \tshp', \thpl \uplus \Set{ \thid \mapsto (\stk', \ts', {\iprog}')} )
    }{%
        ( \stk, \tshp, \ts ) , \iprog \ \toT{\lbJ{\thid',\ts''}} \  ( \stk', \tshp', \ts' ) , {\iprog}' 
    }
\]
%
\hrule\vspace{5pt}
\caption{Thread pool semantics}
\label{fig:thread_pool_semantics}
\end{figure}
