\section{semantics\label{sec:semantics}}

Assume that heap and stack are initialised to zero.

\[
    \begin{rclarray}
        \loc \in \Loc & \defeq & \Nat \\
        \val \in \Val & \defeq & \Nat \uplus \Loc \\
        \Var & \defeq & \Set{ \vx, \vy, \dots } \\
        \ts \in \Timestamp & \defeq & \Nat \\
        \hp \in \Heap & \defeq & \Loc \parfun \Val \\
        \stk \in \Stack & \defeq & \Var \to \Val \\
        \rs \in \Readset, \ws \in \Writeset & \defeq & \powerset{\Loc} \\
        \lstt = (\hp, \stk, \rs, \ws ) \in \Localstate & \defeq & \Stack \times \Heap \times \Readset \times \Writeset \\
        \op \in \Operation & \defeq & \Set{\opr, \opw} \\
        \settrans \subseteq \TransID & \defeq & \Set{ \alpha , \beta, \dots } \\
        \tshp \in \Timestampheap & \defeq & \Loc \parfun ( \Timestamp \parfun \Val \times \Operation \times \TransID) \\
        \ThreadID & \defeq & \Set{ i , j, \dots } \\
        (\tshp, \stk, \ts) \in \Threadstate & \defeq & \Timestampheap \times \Stack \times \Timestamp \\
        \tdpl \in \Threadpool & \defeq & \ThreadID \parfun \Stack \times \Timestamp \times \prog \\
        \stt \in \State & \defeq & \Timestampheap \times \Threadpool \\
    \end{rclarray}
\]

No side effect of evaluation of arithmetic expression.

\[
    \begin{syntax}{\texpr}
              \val \quad            |
        \quad \var \quad            |
        \quad \texpr + \texpr \quad |
        \quad \texpr * \texpr \quad |
        \quad \dots 
    \end{syntax}
\]

No side effect of evaluation of boolean expression.

\[
    \begin{rclarray}
        \eval{\val}_{\stk} & \defeq & \val \\
        \eval{\var}_{\stk} & \defeq & \stk(\val) \\
        \eval{\texpr_{1} + \texpr_{2}}_{\stk} & \defeq & \eval{\texpr_{1}}_{\stk} + \eval{\texpr_{2}}_{\stk}   \\
        \eval{\texpr_{1} * \texpr_{2}}_{\stk} & \defeq & \eval{\texpr_{1}}_{\stk} * \eval{\texpr_{2}}_{\stk}  
    \end{rclarray}
\]

\[
    \begin{syntax}{\tbool}
              \true \quad                  |
        \quad \false \quad                 |
        \quad \texpr = \texpr \quad        |
        \quad \texpr < \texpr \quad        |
        \quad \boolnot \tbool \quad        |
        \quad \tbool \booland \tbool \quad |
        \quad \tbool \boolor \tbool \quad  |
        \quad \dots 
    \end{syntax}
\]

\[
    \begin{rclarray}
        \eval{\true}_{\stk}& \defeq & \true \\
        \eval{\false}_{\stk} & \defeq & \false \\
        \eval{\texpr_{1} = \texpr_{2}}_{\stk} & \defeq & \eval{\texpr_{1}}_{\stk} = \eval{\texpr_{2}}_{\stk}   \\
        \eval{\texpr_{1} < \texpr_{2}}_{\stk} & \defeq & \eval{\texpr_{1}}_{\stk} < \eval{\texpr_{2}}_{\stk}   \\
        \eval{\boolnot \tbool}_{\stk} & \defeq & \neg \eval{\tbool}_{\stk} \\
        \eval{\tbool_{1} \booland \tbool_{2}}_{\stk} & \defeq & \eval{\tbool_{1}}_{\stk} \land \eval{\tbool_{2}}_{\stk}  \\
        \eval{\tbool_{1} \boolor \tbool_{2}}_{\stk}& \defeq & \eval{\tbool_{1}}_{\stk} \lor \eval{\tbool_{2}}_{\stk}  
    \end{rclarray}
\]

\[
    \begin{syntax}{\tcmd}
              \tskip \quad                     |
        \quad \tass{\vx}{\texpr} \quad         |
        \quad \tmutate{\texpr}{\texpr} \quad   |
        \quad \tderef{\vx}{\texpr} \quad       |
        \quad \tif{\tbool}{\tcmd}{\tcmd} \quad | \\
              \tloop{\tbool}{\tcmd} \quad      |
        \quad \tcmd \tseq \tcmd
    \end{syntax}
\]

\[
    \begin{rclarray}
        \dontcare, \dontcare, \dontcare, \dontcare, \dontcare \ \localtransfer \ \dontcare, \dontcare, \dontcare, \dontcare, \dontcare & \defeq & \Localstate \times \tcmd \times \Localstate \times \tcmd \\
    \end{rclarray}
\]

\[
    \infer[ass]{%
        \stk, \hp, \rs, \ws, \tass{\var}{\texpr} \ \localtransfer \  \stk \remapsto{\var}{\val}, \hp, \rs, \ws, \tskip
    }{%
    \eval{\texpr}_{\stk} = \val
    }
\]

\[
    \infer[mutate]{%
        \stk, \hp, \rs, \ws, \tmutate{\texpr_{1}}{\texpr_{2}} \ \localtransfer \  \stk, \hp \remapsto{\loc}{\val}, \rs, \ws \cup \Set{\loc}, \tskip
    }{%
        \eval{\texpr_{1}}_{\stk} = \loc \quad 
        \eval{\texpr_{2}}_{\stk} = \val \quad 
        \loc \in \dom(\hp)
    }
\]

\[
    \infer[deref]{%
        \stk, \hp, \rs, \ws, \tderef{\var}{\texpr} \ \localtransfer \  \stk \remapsto{\var}{\val}, \hp, \rs \cup \Set{\loc}, \ws, \tskip
    }{%
        \eval{\texpr}_{\stk} = \loc \quad 
        \val = \hp(\loc) \quad
        \loc \in \dom(\hp)
    }
\]

\[
    \infer[ifelsetrue]{%
        \stk, \hp, \tif{\tbool}{\tcmd_{1}}{\tcmd_{2}} \ \localtransfer \  \stk, \hp, \tcmd_{1}
    }{%
        \eval{\tbool}_{\stk} = \true
    }
\]

\[
    \infer[ifelsefalse]{%
        \stk, \hp, \tif{\tbool}{\tcmd_{1}}{\tcmd_{2}} \ \localtransfer \  \stk, \hp, \tcmd_{2}
    }{%
        \eval{\tbool}_{\stk} = \false
    }
\]

\[
    \infer[whiletrue]{%
        \stk, \hp, \tloop{\tbool} \tcmd \ \localtransfer \  \stk, \hp,  \tcmd \tseq \tloop{\tbool} \tcmd
    }{%
        \eval{\tbool}_{\stk} = \true
    }
\]

\[
    \infer[whilefalse]{%
        \stk, \hp, \tloop{\tbool} \tcmd \ \localtransfer \  \stk, \hp, \tskip
    }{%
        \eval{\tbool}_{\stk} = \false \quad
    }
\]

\[
    \infer[seqskip]{%
        \stk, \hp, \tskip \tseq \tcmd_{2} \ \localtransfer \  \stk, \hp, \tcmd_{2}
    }{%
    }
\]

\[
    \infer[seqnonskip]{%
        \stk, \hp, \tcmd_{1} \tseq \tcmd_{2} \ \localtransfer \  \stk', \hp', \tcmd_{1}' \tseq \tcmd_{2}
    }{%
        \stk, \hp, \tcmd_{1} \ \localtransfer \  \stk', \hp', \tcmd_{1}'
    }
\]

The semantics of transaction are interleaving of start, commit, and restart.

\[
    \begin{syntax}{\prog}
              \pemp \quad               |
        \quad \ptrans{\tcmd} \quad      |
        \quad \prog \pcond \prog \quad  |
        \quad \prept{\prog} \quad       |
        \quad \prog \pseq \prog \quad   |
        \quad \pfork{\var}{\prog} \quad |
        \quad \pjoin{\texpr}   
    \end{syntax}
\]

\[
    \begin{rclarray}
        \prog_{1} \ppar \prog_{2} & \equiv & \pfork{\var}{\prog_{1}} \pseq \prog_{2} \pseq \pjoin{\var} \\
        \tll \in \Translabel & \defeq & 
              \lid \quad                |
              \quad \lfork{\prog} \quad |
        \quad \ljoin{\thid,\ts} \\
        \dontcare, \dontcare, \dontcare, \dontcare \ \threadtransfer{ \dontcare } \ \dontcare, \dontcare, \dontcare, \dontcare & \defeq & \Threadstate \times \prog \times \Translabel \times \Threadstate \times \prog \\
    \end{rclarray}
\]

\[
    \begin{rclarray}
        \func{startstate}(\tshp,\ts) & \defeq & \lambda \loc \ldotp \tshp(\loc)(\max(\Set{\ \ts' \ \middle| \ \ts' \leq \ts \land \tshp(\ts') = (\dontcare,\wop, \dontcare) }))
    \end{rclarray}
\]

\[
    \begin{rclarray}
        \pred{allowcommit}(\tshp,\ws,\rs,\ts_{s},\ts_{e}) & \defeq & 
        \pred{atomicop}(\tshp,\ws,\rs,\ts_{s},\ts_{e}) \land {} \\
        & & \pred{consistent}(\tshp,\ws,\rs,\ts_{s},\ts_{e}) \\
        \pred{atomicop}(\tshp,\ws,\rs,\ts_{s},\ts_{e}) & \defeq  & \forall \loc \in \ws \cup \rs \ldotp \tshp(\loc)(\ts_{s})\undef \land \tshp(\loc)(\ts_{e})\undef \\
        \pred{consistent}(\tshp,\ws,\rs,\ts_{s},\ts_{e}) & \defeq & \forall \ts \in [\ts_{s},\ts_{e}], \loc \in \ws \ldotp \tshp(\loc)(\ts) \neq (\dontcare, \wop, \dontcare) \land {} \\
                                                       & & \exists \ts_{min} = \min(\Set{\ts'' \ \middle| \ \ts'' \geq \ts_{e} \land \tshp(l)(\ts'')\isdef}) \ldotp \\
                                                       & & \ts_{min} \neq \bot \implies \tshp(\loc)(\ts_{min}) = (\dontcare, \wop, \dontcare) \\
        \func{commit}(\tshp,\hp,\ws,\rs,\ts_{s},\ts_{e}) & \defeq &
        \lambda \loc \ldotp
        \begin{funcarray}
            \tshp(\loc) & \loc \notin \ws \cup \rs \\
            \tshp(\loc) \uplus \Set{ \ts_{e} \mapsto (\hp(\loc),\wop,\tsid)} & \loc \in \ws \\
            \tshp(\loc) \uplus \Set{ \ts_{s} \mapsto (\hp(\loc),\rop,\tsid)} & \loc \in \rs \\
        \end{funcarray} \\
        & & \texttt{where} \  \tsid \notin \Set{\tshp(\loc)(\ts)\projection{3} \ \middle| \ \loc \in \dom(\tshp) \land \ts \in \dom(\tshp(\loc))} \\
    \end{rclarray}
\]

\[
    \infer[commit]{%
        \tshp, \stk, \ts, \ptrans{\tcmd} \ \threadtransfer{\lid} \  \tshp', \stk', \ts_{e}, \pemp
    }{%
        \begin{array}{c}
            \ts_{s} \geq \ts \quad \stk, \func{startstate}(\tshp, \ts_{s}), \emptyset, \emptyset \localtransfer^{*} \stk', \hp, \rs, \ws \\
            \pred{allowcommit}(\tshp,\ws,\rs,\ts_{s},\ts_{e}) \quad \ts_{e} > \ts_{s} \quad \tshp' = \func{commit}(\tshp,\hp,\ws,\rs,\ts_{s},\ts_{e})
        \end{array}
    }
\]

\[
    \infer[choiceleft]{%
        \tshp, \stk, \ts, \prog_{1} \pcond \prog_{2} \ \threadtransfer{\lid} \  \tshp, \stk, \ts, \prog_{1}
    }{%
    }
\]

\[
    \infer[choiceright]{%
        \tshp, \stk, \ts, \prog_{1} \pcond \prog_{2} \ \threadtransfer{\lid} \  \tshp, \stk, \ts, \prog_{2}
    }{%
    }
\]

\[
    \infer[norep]{%
        \tshp, \stk, \ts, \prept{\prog} \ \threadtransfer{\lid} \  \tshp, \stk, \ts, \pemp
    }{%
    }
\]

\[
    \infer[rep]{%
        \tshp, \stk, \ts, \prept{\prog} \ \threadtransfer{\lid} \  \tshp, \stk, \ts, \prog \pseq \prept{\prog}
    }{%
    }
\]

\[
    \infer[seqskip]{%
        \tshp, \stk, \ts, \pemp \pseq \prog \ \threadtransfer{\lid} \  \tshp, \stk, \ts, \prog
    }{%
    }
\]

\[
    \infer[seqnoskip]{%
        \tshp, \stk, \ts, \prog_{1} \pseq \prog_{2} \ \threadtransfer{\tll} \  \tshp', \stk', \ts', \prog_{1}' \pseq \prog_{2}
    }{%
        \tshp, \stk, \ts, \prog_{1} \ \threadtransfer{\tll} \  \tshp', \stk', \ts', \prog_{1}' 
    }
\]

\[
    \infer[fork]{%
        \tshp, \stk, \ts, \pfork{\var}{\prog} \ \threadtransfer{\lfork{\thid,\prog}} \  \tshp, \stk\remapsto{\var}{\thid}, \ts, \pemp 
    }{%
    }
\]

\[
    \infer[join]{%
        \tshp, \stk, \ts, \pjoin{\texpr} \ \threadtransfer{\ljoin{\eval{\texpr}_{\stk},\ts'}} \  \tshp, \max\Set{\ts,\ts'}, \pemp 
    }{%
    }
\]

\[
    \begin{rclarray}
        \dontcare, \dontcare \ \globaltransfer{ \dontcare } \ \dontcare, \dontcare & \defeq & \State \times \Translabel \times \State  \\
    \end{rclarray}
\]

\[
    \infer[single]{%
        \tshp, \tdpl \uplus \Set{ \thid \mapsto (\stk, \ts, \prog) } \ \globaltransfer{\tll} \  \tshp', \tdpl \uplus \Set{ \thid \mapsto (\stk', \ts', \prog') }
    }{%
        \tshp, \stk, \ts, \prog \ \threadtransfer{\tll} \  \tshp', \stk', \ts', \prog' 
        \quad \tll \notin \Set{\lfork{\dontcare,\dontcare},\ljoin{\dontcare,\dontcare}}
    }
\]

\[
    \infer[fork]{%
        \tshp, \tdpl \uplus \Set{ \thid \mapsto (\stk, \ts, \prog) } \ \globaltransfer{\lfork{\thid',\prog''}} \  \tshp', \tdpl \uplus \Set{ \thid \mapsto (\stk', \ts', \prog'), \thid' \mapsto (\lambda \var \ldotp 0, \ts', \prog'') }
    }{%
        \tshp, \stk, \ts, \prog \ \threadtransfer{\lfork{\thid',\prog''}} \  \tshp', \stk', \ts', \prog' 
    }
\]

\[
    \infer[join]{%
        \tshp, \tdpl \uplus \Set{ \thid \mapsto (\stk, \ts, \prog), \thid' \mapsto (\stk', \ts'', \pemp) } \ \globaltransfer{\ljoin{\thid',\ts''}} \  \tshp', \tdpl \uplus \Set{ \thid \mapsto (\stk', \ts', \prog')}
    }{%
        \tshp, \stk, \ts, \prog \ \threadtransfer{\ljoin{\thid',\ts''}} \  \tshp', \stk', \ts', \prog' 
    }
\]

\begin{lem}
    A history cannot be overwritten, i.e.\ \( \forall \tshp, \tshp', \loc,\ts \ldotp \tshp, \dontcare \globaltransfer{\dontcare} \tshp', \dontcare \land \tshp(\loc)(\ts)\isdef \implies \tshp(\loc)(\ts) = \tshp'(\loc)(\ts)\)
\end{lem}
\begin{proof}
    From the \( \pred{allowcommit} \).
\end{proof}

\begin{lem}
    \label{lem:read-before-write}
    All the reads of a transaction happen before all the writes. This is 
    \( \forall \tshp, \loc, \loc', \ts, \ts', \tsid \ldotp \tshp(\loc)(\ts) = (\dontcare, \rop, \tsid) \land \tshp(\loc')(\ts') = (\dontcare, \wop, \tsid) \implies \ts < \ts' \).
\end{lem}
\begin{proof}
    From the semantics that \( \ts_{s} < \ts_{e} \).
\end{proof}

\begin{lem}
    \label{lem:atoic-rw}
    All the reads of a transaction happen in the same time, so do all the writes. This is 
    \( \forall \tshp, \loc, \loc', \ts, \ts', \tsid, \op \in \Set{\rop, \wop} \ldotp \tshp(\loc)(\ts) =  \tshp(\loc')(\ts') = (\dontcare, \op, \tsid) \implies \ts = \ts' \).
\end{lem}
\begin{proof}
    From the \( \func{commit} \).
\end{proof}

Now we need to recover \( \vis \) and \( \ar \) from \( \tshp \).
First we need to extend the \( \tshp \) because there are some transactions that only have reads or writes.
We stretch the time by 3, and add extra operation for those transactions.
For a transaction \( \tsid \) that only has reads event, says in time \( \ts \), we add end operations \( (\bot, \tsid, \eop ) \) to the heap cells it reads in time \( (\ts + 1 ) \).
Similarly for a transaction that only has writes event, we add end operations \( (\bot, \tsid, \sop ) \) in time \( (\ts-1) \).

\[
\begin{rclarray}
    \func{stretch}(\tshp) & \defeq & \lambda \loc \ldotp \lambda \ts \ldotp
    \begin{funcarray}
        \tshp(\loc)(\ts') & \ts = 3 * \ts' \\
        \texttt{undef} & o.w. \\
    \end{funcarray} \\
    \func{extend}(\tshp) & \defeq & \lambda \loc \ldotp \tshp(\loc) \uplus \Set{\ts + 1 \mapsto (\bot, \tsid, \eop ) \ \middle| \ \tshp(\loc)(\ts) = (\dontcare, \tsid, \rop) \land \forall \loc', \ts' \ldotp \tshp(\loc')(\ts') = (\dontcare, \tsid, \wop)} \\
                         & & \quad \quad \quad \uplus \Set{\ts - 1 \mapsto (\bot, \tsid, \sop ) \ \middle| \ \tshp(\loc)(\ts) = (\dontcare, \tsid, \wop) \land \forall \loc', \ts' \ldotp \tshp(\loc')(\ts') = (\dontcare, \tsid, \rop)}
\end{rclarray}
\]

\begin{lem}
    After stretching the time by 3, there is no record in time \( 3 * \nat + 1 \) and \( 3 * \nat - 1 \).
    Therefore after extending, there are only \( (\dontcare, \tsid, \eop) \) in time \( 3 * \ts + 1 \) and only \( (\dontcare, \tsid, \sop) \) in time \( 3 * \ts - 1 \).
    This is \( \forall \tshp \ldotp \exists \tshp' = \func{extend} \circ \func{stetch}(\tshp) \ldotp \forall \loc, \ts \ldotp (\tshp'(\loc)(3 * \ts + 1)\isdef \implies \tshp'(\loc)(3 * \ts + 1) = (\dontcare, \dontcare, \eop) ) \land (\tshp'(\loc)(2 * \ts - 1)\isdef \implies \tshp'(\loc)(3 * \ts - 1) = (\dontcare, \dontcare, \sop) ) \).
\end{lem}
\begin{proof}
    trivial.
\end{proof}

\begin{lem}
    \label{lem:start-before-end}
    In the extended heap, all the reads or starts of a transaction happen before all the writes or end. This is 
    \( \forall \tshp, \loc, \loc', \ts, \ts', \op \in \Set{\rop, \sop}, \op' \in \Set{\wop, \eop}, \tsid \ldotp \tshp(\loc)(\ts) = (\dontcare, \op, \tsid) \land \tshp(\loc')(\ts') = (\dontcare, \op', \tsid) \implies \ts < \ts' \).
\end{lem}
\begin{proof}
    From Lemma \ref{lem:read-before-write} and the definition of \func{strech} and \func{extend}.
\end{proof}

\begin{lem}
    \label{lem:happen-in-same-time}
    For an extended heap, all the reads of a transaction happen in the same time, so do all the writes, starts and ends. This is 
    \( \forall \tshp, \loc, \loc', \ts, \ts', \tsid, \op \ldotp \tshp(\loc)(\ts) =  \tshp(\loc')(\ts') = (\dontcare, \op, \tsid) \implies \ts = \ts' \).
\end{lem}
\begin{proof}
    From Lemma \ref{lem:atoic-rw} and the definition of \func{strech} and \func{extend}.
\end{proof}

\begin{lem}
    \label{lem:unique-label}
    A transaction in an extended heap, must have either starts or reads, and either ends or writes.
\end{lem}
\begin{proof}
    From the definition of \func{extend}.
\end{proof}

\[
\begin{rclarray}
    (\settrans, \tvis, \tar) = \func{graph}(\tshp) & \defeq & (\Set{ \tsid \ \middle| \ \forall \loc \ldotp \tshp(\loc) = (\dontcare, \tsid, \dontcare)}, \\
                                                   & & \Set{(\tsid, \tsid') \ \middle| \ 
    \begin{array}{@{}l@{}}
        \exists \loc, \loc', \ts, \ts', \op \in \Set{\wop, \eop}, \op' \in \Set{\rop, \sop} \ldotp \\
        \ts < \ts' \land \tshp(\loc)(\ts) = (\dontcare, \tsid, \op) \land \tshp(\loc')(\ts') = (\dontcare, \tsid', \op')
    \end{array}
}, \\
                                                   & & \Set{(\tsid, \tsid') \ \middle| \ 
    \begin{array}{@{}l@{}}
        \exists \loc, \loc', \ts, \ts', \op, \op' \in \Set{\wop, \eop} \ldotp \\
        \ts < \ts' \land \tshp(\loc)(\ts) = (\dontcare, \tsid, \op) \land \tshp(\loc')(\ts') = (\dontcare, \tsid', \op')
    \end{array}
}, \\
\end{rclarray}
\]

\begin{lem}
    For an extended heap, the corresponding \tvis\ and \tar\ have no circle.
\end{lem}
\begin{proof}
    Assume there is a circle in \(\rvis\), says, \( \tsid_{1} \rvis \tsid_{2} \rvis \dots \rvis \tsid_{n} \rvis \tsid_{n+1} \), where \( \tsid_{1} = \tsid_{n+1} \).
    Therefore, \( \bigwedge\limits_{ 1 \leq i \leq n} \exists \loc, \loc', \ts, \ts', \op \in \Set{\wop, \eop}, \op' \in \Set{\rop, \sop} \ldotp \ts < \ts' \land \tshp(\loc)(\ts) = (\dontcare, \tsid_{i}, \op) \land \tshp(\loc')(\ts') = (\dontcare, \tsid_{i+1}, \op')\).
    By Lemma \ref{lem:unique-label} we can relabel read to start and write to end.
    Then by Lemma \ref{lem:happen-in-same-time}, we can define a list of starts and ends events that is ordered by time: \( \List{ (\tsid_{1},\eop), (\tsid_{2},\sop), (\tsid_{2},\eop), \dots, (\tsid_{n},\eop), (\tsid_{n+1},\sop) } \).
    By the assumption, we have \( \tsid_{1} = \tsid_{n+1} \), thus this contradict Lemma \ref{lem:start-before-end}.

    Similarly for \(\rtar\), the list of write events  \( \List{ (\tsid_{1},\eop), (\tsid_{2},\eop), (\tsid_{2},\eop), \dots, (\tsid_{n},\eop), (\tsid_{n+1},\eop) } \) contradict Lemma \ref{lem:happen-in-same-time}.
\end{proof}

\begin{lem}
    Given a \( \tshp \), the corresponding \((\settrans, \tvis, \tar)\) can be extended to \((\settrans, \vis, \ar)\) so that it is a valid dependency graph of snapshot isolation.
\end{lem}
\begin{proof}
    First, we extend the relations \( \tar \) to a total order \( \ar \).
    Initially, \( \ar \) includes all relations in \( \tar \).
    Given the definition, only if the ends or writes of transactions happen in the same time, those transactions are not ordered by \( \tar \).
    To simplify, we introduce an initial event, i.e.\ \( \forall \tsid \in \settrans \ldotp \tsid_{init} \rar \tsid \).
    From \( \tsid_{init} \), we pick the first two transactions \( \tsid_{1} \) and \( \tsid_{2} \) that are not ordered, this is, \( \forall \tsid, \tsid' \in \Set{\tsid'' \ \middle| \ \tsid'' \rar \tsid_{1} \lor \tsid'' \rar \tsid_{2} } \ldotp \tsid \rar \tsid' \lor \tsid' \rar \tsid \).
    Therefore, there exists an unique \( \tsid_{pre} \) where branching happens, i.e.\ \( \tsid_{pre} \rar \tsid_{1} \land \tsid_{pre} \rar \tsid_{2} \land \nexists \tsid \ldotp \tsid_{pre} \rar \tsid \rar \tsid_{1} \lor \tsid_{pre} \rar \tsid \rar \tsid_{2} \).
\end{proof}
