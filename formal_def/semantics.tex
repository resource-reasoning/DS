\section{Semantics\label{sec:semantics}}
\begin{defn}[Program values]
\label{def:prgram_values}
Assume a countably infinite set of \emph{addresses}, $\addr \in \Addr$, and a countably infinite set of \emph{program variables} $\vx \in {\Var}$. The set of \emph{program values} is $\val \in \Val \eqdef \Nat \cup \Addr$, where $\Nat$ denotes the set of natural numbers.
\end{defn}
%
\begin{defn}[Stacks]
\label{def:stacks}
Given the set of program variables $\Var$ and the set of program values $\Val$ (\defin\ref{def:prgram_values}), the set of variable stacks is \( \thstk, \txstk \in \Stacks \eqdef \Var \parfinfun \Val$.
\end{defn}
%
\sx{\( \thstk \) is for thread stack and \( \txstk \) is for transactions}
Our programs (ranged over by $\prog$) are defined by an inductive grammar comprising the standard constructs of $\pskip$, sequential composition ($\prog; \prog$), non-deterministic choice ($\prog+\prog$), loops ($\prog^*$) and parallel composition ($\prog \ppar \prog$). Additionally, our programming language contains the \emph{transaction} construct $\ptrans{\trans}$ denoting the \emph{atomic} execution of the transaction $\trans$. The atomicity guarantees of this execution are dictated by the underlying consistency model (snapshot isolation in this case).
Transactions (ranged over by $\trans$) are defined by a similar inductive grammar comprising $\pskip$, non-deterministic choice, loops and sequential composition, as well as constructs for assignment, lookup and update. Transactions do \emph{not} contain the \emph{parallel} composition construct ($\ppar$) as they are to be executed atomically.

\begin{defn}[Programming language]
\label{def:language}
Assume a set of thread variables \( \ThreadVars \defeq \Set{\thvar, \dots }\) which is a subset of \( \Var \), the set of \emph{programs}, $\prog \in \Programs$, is defined by the following grammar:
\[
    \begin{rclarray}
    \prog & ::= &
        \pskip \mid 
        \passign{\thvar}{\expr} \mid
        \passume{\expr} \mid
        \ptrans{\trans} \mid 
        \prog \pseq \prog \mid 
        \prog \pchoice \prog \mid 
        \prog\prepeat \mid
        \prog \ppar \prog 
    \end{rclarray}
\]
\sx{add assume and assign here}
%
Assume a set of transaction variables \( \TxVars \defeq \Set{\txvar, \dots }\) which is a subset of \( \Var \), the $\trans \in \Transactions$ in the grammar above denotes a \emph{transaction} defined by the following grammar:
%
\[
    \begin{rclarray}
        \trans & ::= &
        \pskip \mid
        \pass{\txvar}{\expr} \mid
        \pmutate{\expr}{\expr} \mid
        \pderef{\txvar}{\expr} \mid
        \passume{\expr} \mid
        \preturn{\expr} \mid
        \trans \pseq \trans \mid
        \trans \pchoice \trans \mid
        \trans\prepeat
    \end{rclarray}
\]
\sx{add assume and return}
%
where $\expr \in \Expressions$ denotes an \emph{arithmetic expression} defined by the grammar below with $\val \in \Val$, $\thvar \in \ThdVars$ and \( \txvar \in \TxVars \) (\defin\ref{def:prgram_values}).
%
\[
    \begin{rclarray}
        \expr & ::= &
        \val \mid
        \thvar \mid
        \txvar \mid
        \expr + \expr \mid
        \expr * \expr \mid
        \dots 
    \end{rclarray}
\]
%
Given a stack $\stk \in \Stacks$ (\defin\ref{def:stacks}), the \emph{expression evaluation} function, $\evalE[.]{.}:\Expressions \times \Stacks \parfun \Val$, is defined inductively over the structure of expressions as follows: 
%
\[
    \begin{rclarray}
        \evalE{\val} & \defeq & \val \\
        \evalE{\thvar} & \defeq & \stk(\thvar) \\
        \evalE{\txvar} & \defeq & \stk(\txvar) \\
        \evalE{\expr_{1} + \expr_{2}} & \defeq & \evalE{\expr_{1}} + \evalE{\expr_{2}} \\
        \evalE{\expr_{1} * \expr_{2}} & \defeq & \evalE{\expr_{1}} * \evalE{\expr_{2}} \\
\\
    \end{rclarray}
\]
\end{defn}


\begin{definition}[Heaps]\label{def:heaps}
Given the sets of program values $\Val$ (\defin\ref{def:prgram_values}) and  addresses $\Addr$ (\defin\ref{def:timestamp_heaps}), the set of \emph{ heaps} is: $\h \in \Heaps \eqdef \Addr \parfinfun \Val$.
The \emph{heap composition function}, $\composeH: \Heaps \times \Heaps \parfun \Heaps$, is defined as $\composeH \eqdef \uplus$, where $\uplus$ denotes the standard disjoint function union. The \emph{ heap unit element} is $\unitH \eqdef \emptyset$, denoting a function with an empty domain.
The \emph{partial commutative monoid of  heaps} is $(\Heaps, \composeH, \{\unitH\})$.
\end{definition}
 
\begin{defn}[Fingerprints]
\label{def:fingerprint}
The set of \emph{fingerprints} is $\fp \in \Fingerprint \eqdef \powerset{\Set{\fpR,\fpW}}$.
\end{defn}
 
\begin{defn}[Fingerprint heaps]
\label{def:fingerprint_heaps}
Given the sets of program values $\Val$ (\defin\ref{def:prgram_values}), addresses $\Addr$ (\defin\ref{def:timestamp_heaps}) and fingerprints $\Fingerprint$ (\defin\ref{def:fingerprint}), the set of \emph{fingerprint heaps} is: $\fph \in \FPHeaps \eqdef \Addr \parfinfun (\Val \times \Fingerprint)$.
The \emph{fingerprint heap composition function}, $\composeFPH: \FPHeaps \times \FPHeaps \parfun \FPHeaps$, is defined as $\composeFPH \eqdef \uplus$, where $\uplus$ denotes the standard disjoint function union. The \emph{fingerprint heap unit element} is $\unitFPH \eqdef \emptyset$, denoting a function with an empty domain.
The \emph{partial commutative monoid of fingerprint heaps} is $(\FPHeaps, \composeFPH, \{\unitFPH\})$.  
\end{defn}
 
Given a fingerprint heap $\fph$ and an address $\addr$, we write $\fphVAL(\addr)$ and $\fphFP(\addr)$ for the first and second projections of $\fph(\addr)$, respectively. We write $\unitFPH$ for a fingerprint heap with an empty domain. We write $\fph_1 \uplus \fph_2$ for the standard disjoint function union of $\fph_1$ and $\fph_2$. 

We introduce two update functions on fingerprints, $\addFPR{\fp}$ and $\addFPW{\fp}$, for updating a fingerprint $\fp$. Intuitively, the $\addFPW{\fp}$ always \emph{extends} $\fp$ with the $\fpW$ fingerprint. On the other hand, the $\addFPR{\fp}$ extends $\fp$ with $\fpR$ \emph{only if} $\fp$ does not already contain the $\fpW$ fingerprint (i.e.~$\fpW \not\in \fp$). This is to capture the fact that once an address is written to and thus the fingerprint contains $\fpW$, the following reads from the same address are considered local and need not be recorded in the fingerprint.
 
\begin{defn}[Fingerprint extension]
\label{def:fingerprint-extension}
Given the set of fingerprints $\Fingerprint$ (\defin\ref{def:fingerprint}), the \emph{read fingerprint extension} function, $\addFPR{(.)}{.}: \Fingerprint \rightarrow \Fingerprint$, and the \emph{write fingerprint extension} function, $\addFPW{(.)}{.}: \Fingerprint \rightarrow \Fingerprint$, are defined as follows, for all $\fp \in \Fingerprint$:
\[
\begin{rclarray}
	\addFPW{\fp} & \eqdef & \fp \cup \{\fpW\} \\
	\addFPR{\fp} & \eqdef &
	\begin{cases}
		\fp \cup \{\fpR\}  & \text{if } \fpW \not\in \fp \\
		\fp & \text{otherwise}
	\end{cases}
\end{rclarray}	
\]
\end{defn}

\begin{defn}[Read and write sets]
\label{def:rs-ws}
Given the set of fingerprints $\Fingerprint$ (\defin\ref{def:fingerprint}), the \emph{read set} and \emph{write set} function, $\rsName, \wsName: \FPHeaps \to \powerset{\Addr}$ is defined as follows:
\[
\begin{rclarray}
    \ws{\fph} & \defeq & \myset{\loc}{ \exsts{\fp} \fph(\loc) = (\stub, \fp) \land \fpW \in \fp} \\
    \rs{\fph} & \defeq & \myset{\loc}{ \exsts{\fp} \fph(\loc) = (\stub, \fp) \land \fpR \in \fp} \\
\end{rclarray}	
\]
\end{defn}

\subsection{Local/Transaction Semantics}

We define the operational semantics of transactions $\trans$ with respect to a configuration of the form $(\thstk, \txstk, \fph)$ comprising a thread stack, a transaction stack and a (local) fingerprint heap.
The operational semantics of transactions is given in \fig\ref{fig:transaction_semantics}.
It is standard except the \rl{TRead} and \rl{TWrite} rules where the fingerprint of the address read from (resp.~written to) is extended with $\fpR$ (resp.~$\fpW$).
Also, transactions are not allowed to modify the thread stack.


\begin{defn}[Transaction semantics]
Given the sets of stacks (\defin\ref{def:stacks}), fingerprint heaps (\defin\ref{def:fingerprint_heaps}) and transactions (\defin\ref{def:language}), the \emph{operational semantics of transactions}, $\toL : ((\Stacks \times \FPHeaps) \times \Transactions) \times ((\Stacks \times \FPHeaps) \times \Transactions)$, is given in \fig\ref{fig:transaction_semantics}.
\end{defn}

\begin{figure}
\hrule\vspace{5pt}
\[	
    \infer[\rl{TAss}]{%
        (\thstk, \txstk, \fph) , \pass{\txvar}{\expr} \ \toL \  (\thstk, \txstk \remapsto{\txvar}{\val}, \fph) , \pskip
    }{%
    \evalE[\thstk \uplus \txstk]{\expr} = \val
    && \txvar \in \dom(\txstk)
    }
\]

\[
    \infer[\rl{TWrite}]{%
        ( \thstk, \txstk, \fph), \pmutate{\expr_{1}}{\expr_{2}} \ \toL \  ( \thstk, \txstk, \fph \remapsto{\addr}{(\val, \addFPW{\fp})}) , \pskip
    }{%
        \evalE[\thstk \uplus \txstk]{\expr_{1}} = \addr && 
        \evalE[\thstk \uplus \txstk]{\expr_{2}} = \val && 
        \fph(l) {=} (\stub, \fp)
    }
\]

\[
    \infer[\rl{TRead}]{
        ( \txstk, \fph) , \pderef{\txvar}{\expr} \ \toL \  (\txstk \remapsto{\var}{\val}, \fph \remapsto{\addr}{(\val, \addFPR{\fp})}), \pskip
    }{
        \evalE[\thstk \uplus \txstk]{\expr} = \addr
        && \txvar \in \dom(\txstk)
        && \fph(\addr) {=} (\val, \fp) 
    }
\]

\[
    \infer[\rl{TAssume}]{%
        (\thstk, \txstk, \fph), \passume{\expr} \ \toL \  (\thstk, \txstk, \fph), \pskip
    }{%
        \evalE[\thstk \uplus \txstk]{\expr} = 0
    }
\]

\[
    \infer[\rl{TChoiseL}]{%
        (\thstk, \txstk, \fph) , \trans_{1} \pchoice \trans_{2} \ \toL \  (\thstk, \txstk, \fph) , \trans_{1}
    }{}
\]

\[
    \infer[\rl{TChoiseR}]{%
        (\thstk, \txstk, \fph) , \trans_{1} \pchoice \trans_{2} \ \toL \  (\thstk, \txstk, \fph), \trans_{2}
    }{%
    }
\]

\[
    \infer[\rl{TLoop}]{%
        (\thstk, \txstk, \fph),  \trans\prepeat \ \toL \  (\thstk, \txstk, \fph), \pskip \pchoice (\trans \pseq \trans\prepeat)
    }{%
    }
\]


\[
    \infer[\rl{TSeqSkip}]{%
        (\thstk, \txstk, \fph), \pskip \pseq \trans_{2} \ \toL \  (\thstk, \txstk, \fph), \trans_{2}
    }{%
    }
\]

\[
    \infer[\rl{TSeq}]{%
        (\thstk, \txstk, \fph), \trans_{1} \pseq \trans_{2} \ \toL \  (\thstk, \txstk', \fph'), \trans_{1}' ; \trans_{2}
    }{%
        (\thstk, \txstk, \fph), \trans_{1} \ \toL \  (\thstk, \txstk', \fph'), \trans_{1}'
    }
\]

\hrule\vspace{5pt}
\caption{The transaction operational semantics}
\label{fig:transaction_semantics}
\end{figure}

In order to formulate the operational semantics of a program $\prog$, we extend the programming language with an auxiliary wait construct, \(\pwait{\thid} \), added to programs as a suffix to denote thread joining points.
Intuitively, the \( \pwait{\thid} \) construct indicates that the current thread is waiting on the thread identified by \( \thid \) to finish its execution and join the current thread. We refer to the programs produced by this extended syntax as \emph{intermediate programs}. This is because the $\pwait{.}$ construct yields additional programs that cannot be written by the clients of the database and is merely used to capture intermediate steps during parallel execution. 
%

We define the per-thread operational semantics of programs with respect to a triple of the form $(\stk, \tshp, \ts)$ comprising a (locally-accessed) stack, a (globally-accessed) timestamp heap, and a (locally-recorded) timestamp. 
Each step of the per-thread operational semantics is decorated with a \emph{label} recording the action taken by the thread. In particular, a label may be $\lbID$, denoting an identity transition; $\lbC{\tsid}$, denoting the committing of transaction $\tsid$; $\lbF{\thid, \prog}$, denoting the forking a new thread $\thid$ the execute program $\prog$; or $\lbJ{\thid, \ts}$, denoting the joining of thread $\thid$ with the local timestamp $\ts$.
  
The per-thread operational semantics of programs is given in \fig\ref{fig:thread_semantics}.
With the exception of the \rl{PCommit}, \rl{PPar} and \rl{PWait}, the remaining rules are straightforward.


\begin{defn}[transactions]
Assume a set of transactions identifiers \( \TxID \defeq \Set{\txid, \dots}\).
The set of transactions events \( \Events \) is as the follows,
\[
\begin{rclarray}
\ETags & \defeq & \Set{\etR, \etW} \\
\ev \in \Events & \defeq  & \ETags \times \Addr \times \Val
\end{rclarray}
\]
The transactions are defined as a finite partial function from transactions identifiers \( \TxID \) to a set of events \( \powerset{\Events} \),
\[
\begin{rclarray}
\tx \in \Tx & \defeq & \TxID \parfinfun \powerset{\Events}
\end{rclarray}
\]
\end{defn}


\begin{defn}[Abstract executions]
An abstract execution is a tuple $\aexec = (\tx, \po, \vis, \ar) \in \Aexecs$, where the follows hold,

\begin{itemize}
\item
the \emph{program order} $\po \subseteq \tx \times \tx$ is the union of disjoint, strict total orders \( \po_{i} \).
That is, there exists a partition $\Set{ \tx_{i} }_{i \in I}$ of $\tx$ such that $\po = \bigcup_{i \in I} \po_{i}$, where $\po_{i}$ is a strict, total order over $\tx_i$%
\footnote{Recall that a relation $R \subseteq A \times A$ is a strict partial order if it is irreflexive and transitive.
It is a strict total order if for any $a_1, a_2 \in A$, either $a_1 = a_2$, $(a_1, a_2) \in R$ or $(a_2, a_1) \in R$.}

\item 
$\vis \subseteq \tx \times \tx$ is a strict, partial and transitive%
\footnote{Recall that a relation $R \subseteq A \times A$ is transitive if for any \( a_{1}, a_{2}, a_{3}\) such that \( (a_{1}, a_{2} ) \in R\) and \( (a_{2}, a_{3} ) \in R \) then \( (a_{1}, a_{3} ) \in R \)}
order such that $\po \subseteq \vis$. 

\item 
$\ar \subseteq \tx \times \tx$ is a strict, total order such that $\vis \subseteq \ar$.

\item 
For any address $\addr \in \Addr$, given $\tsid \in \dom(\tx)$, let $\func{before\_writes}{\aexec, \addr, \txid} = \Setcon{\txid' }{ \txid' \in \vis^{-1}(\txid) \land (\etW, \stub, \stub) \in \tx(\txid')}$. 
Whenever $( \etR, \addr, \val) \in \tx(\txid)$ for some address $\addr \in \Addr$ and value $\val \in \Val$, then either $\func{before\_writes}{\aexec, \addr, \txid} = \emptyset$ and $\val = 0$, or \( ( \etW, \addr, \val) \in \max_{\ar}(\func{before\_writes}{\aexec, \addr, \txid}) \).
\end{itemize}
\end{defn}


\begin{defn}[Thread transition labels]
\label{def:label}
Assume a countably infinite set of thread identifiers $\thid,j \in \ThreadID$.
The set of \emph{thread transition labels}, $\lb \in \Translabel$, is defined by the following grammar, where $\prog$ denotes a program (\defin\ref{def:language}), the $\tsid$ demotes a transaction identifier and $\ts$ denotes a timestamp (\defin\ref{def:timestamp_heaps}):
\[
	\iota \in \Translabel ::= \lbID \mid \lbC{\tsid} \mid \lbF{\thid,\prog} \mid \lbJ{\thid,\ts}
\]
\end{defn}








\begin{defn}[Thread semantics]
\label{def:thread_semantics}
Assume a countably infinite set of thread identifiers $\thid,j \in \ThreadID$.
The set of \emph{intermediate programs}, $\iprog \in \IntermediatePrograms$, is defined by the following grammar:
%
\[
    \iprog ::= \prog \mid \iprog \pseq \pwait{\thid}
\]
%
Given the set of stacks $\Stacks$ (\defin\ref{def:stacks}), timestamp heaps $\TSHeaps$ and timestamps $\Timestamp$ (\defin\ref{def:timestamp}), the \emph{per-thread operational semantics} of programs:
%
\[
	\toT{} : 
	\left((\Stacks \times \TSHeaps \times \Timestamp) \times \IntermediatePrograms \right) 
	\times \Translabel \times  
	\left((\Stacks \times \TSHeaps \times \Timestamp) \times \IntermediatePrograms \right) 
\]
%
is defined in \fig\ref{fig:thread_semantics}.
\end{defn}

The \rl{PCommit} rule states that a transaction prophesies a starting timestamp $\ts_s$ (at which point it takes a snapshot $\fph_s$ and runs locally), and an ending timestamp $\ts_e$ (at which point the transaction is successfully committed as ensured by the $\cancommitName$ predicate).

The \rl{Par} rule forks a new thread and inserts the appropriate joining point by appending the auxiliary \( \pwait{\thid} \) operation, where $\thid$ denotes the identifier of the newly forked thread. 
The \rl{Wait} rule dually awaits the termination of thread $\thid$ and subsequently updates its timestamp to the maximum value between its own timestamp and that of $\thid$.
Note that these two rules are labelled with the $\lbF{\thid, \prog}$ and $\lbJ{\thid, \ts}$ which are used by the semantics of the thread pool described shortly.

\begin{figure}
%
\hrule\vspace{5pt}
%
\[
    \infer[\rl{Commit}]{%
        ( \stk, \tshp, \ts_{s} ) , \ptrans{\trans} \ \toT{\lbC{\tsid}} \ ( \stk', \tshp', \ts_{e} ) , \pskip
    }{%
        \begin{array}{c}
            \ts_s < \ts_e 
            \qquad \fph_s = \snapshot{\tshp}{\ts_s}
            \qquad ( \stk, \fph_s) , \trans \toL^{*} ( \stk', \fph_e) , \pskip \\
            \cancommit{\tshp}{\fph_e}{\ts_s}{\ts_e} 
            \quad \pred{fresh}{\tshp, \tsid}
            \quad \tshp' = \commit{\tshp}{\fph_s}{\fph_e}{\tsid}{\ts_s}{\ts_e}
        \end{array}
    }
\]

\[
    \infer[\rl{PChoiseL}]{%
        ( \stk, \tshp, \ts ) , \prog_{1} \pchoice \prog_{2} \ \toT{\lbID} \  ( \stk, \tshp, \ts ) , \prog_{1}
    }{%
    }
\]

\[
    \infer[\rl{PChoiseR}]{%
        ( \stk, \tshp, \ts ) , \prog_{1} \pchoice \prog_{2} \ \toT{\lbID} \  ( \stk, \tshp, \ts ) , \prog_{2}
    }{%
    }
\]

\[
    \infer[\rl{PLoop}]{%
        ( \stk, \tshp, \ts ) , \prog\prepeat \ \toT{\lbID} \  ( \stk, \tshp, \ts ) , \pskip \pchoice (\prog \pseq \prog\prepeat)
    }{%
    }
\]

\[
    \infer[\rl{PSeqSkip}]{%
        ( \stk, \tshp, \ts ) , \pskip \pseq \iprog \ \toT{\lbID} \  ( \stk, \tshp, \ts ) , \iprog
    }{%
    }
\]

\[
    \infer[\rl{PSeq}]{%
        ( \stk, \tshp, \ts ) , \iprog_{1} \pseq \iprog_{2} \ \toT{\lb} \ ( \stk', \tshp', \ts' ) , {\iprog_{1}}' \pseq \iprog_{2}
    }{%
        ( \stk, \tshp, \ts ) , \iprog_{1} \ \toT{\lb} \  ( \stk', \tshp', \ts' ) , {\iprog_{1}}' 
    }
\]

\[
    \infer[\rl{PPar}]{%
        ( \stk, \tshp, \ts ) , \prog_{1} \ppar \prog_{2} \ \toT{\lbF{\thid, \prog_{2}}} \  ( \stk, \tshp, \ts ) , \prog_{1} \pseq \pwait{\thid}
    }{%
    }
\]

\[
    \infer[\rl{PWait}]{%
        ( \stk, \tshp, \ts ) , \pwait{\thid} \ \toT{\lbJ{\thid,\ts'}} \  ( \stk, \tshp , \max\Set{\ts,\ts'} ) , \pskip 
    }{%
    }
\]

\[
    \infer[\rl{PIncTime}]{%
        ( \stk, \tshp, \ts ) , \iprog \ \toT{\lbID} \  ( \stk, \tshp , \ts' ) , \iprog 
    }{%
       \ts' > \ts
    }
\]
 
where,
\[
\begin{rclarray}
	\snapshot{.}{.} & : & \TSHeaps \times \Timestamp \parfun \FPHeaps \\
%	
	\snapshot{\tshp}{\ts} & \defeq & 
	\lambda \addr \ldotp
	\begin{cases} 
		(\val, \emptyset) & 
		\exsts{\ts' \leq \ts} \tshp(\addr)(\ts') {=} (\val,\etW, \stub) \\
		& \quad {} \land \for{\ts'' \in ( \ts', \ts), \etag} \tshp(\addr)(\ts'') {=} (\stub,\etag,\stub) \implies \etag \in \Set{\etR, \etE}\\
        \text{undefined} & \text{otherwise}
	\end{cases} 
	\vspace{3pt}\\
	\commit{.}{.}{.}{.}{.}{.} & : & \TSHeaps \times \FPHeaps \times \FPHeaps \times \TransID \times \Timestamp \times \Timestamp \to \TSHeaps \\
%	
	\commit{\tshp}{\fph_s}{\fph_e}{\tsid}{\ts_s}{\ts_e} & \defeq &
	\lambda \addr \ldotp
	\begin{cases}
		\tshp(\addr)\remapsto{\ts_s}{(\fphVAL[\fph_s](\addr),\etS,\tsid)}\remapsto{\ts_e}{(\fphVAL[\fph_e](\addr),\etW,\tsid)} 
		& \text{if \;} \fphFP[\fph_e](\addr) {=} \{\fpW\} \\
		\tshp(\addr)\remapsto{\ts_s}{(\fphVAL[\fph_s](\addr),\etR,\tsid)}\remapsto{\ts_e}{(\fphVAL[\fph_e](\addr),\etE,\tsid)} 
		& \text{if \;} \fphFP[\fph_e](\addr) {=} \{\fpR\} \\
		\tshp(\addr)\remapsto{\ts_s}{(\fphVAL[\fph_s](\addr),\etR,\tsid)}\remapsto{\ts_e}{(\fphVAL[\fph_e](\addr),\etW,\tsid)} & \text{if \;} \fphFP[\fph_e](\addr) {=} \{\fpR, \fpW\} \\
		\tshp(\addr)\remapsto{\ts_s}{(\fphVAL[\fph_s](\addr),\etS,\tsid)}\remapsto{\ts_e}{(\fphVAL[\fph_e](\addr),\etE,\tsid)} & \text{otherwise}
	\end{cases} 
	\vspace{3pt}\\
%
%              
	\cancommit{\tshp}{\fph}{\ts_s}{\ts_e} 
	& \defeq & 
	\wfhist{\tshp}{\fph}{\ts_s}{\ts_e} \land \consistent{\tshp}{\fph}{\ts_s}{\ts_e} 
	\vspace{3pt}\\
%
%        
	\wfhist{\tshp}{\fph}{\ts_s}{\ts_e} 
	& \defeq  & 
 	\for{\addr} \for{\ts \in \Set{\ts_{s},\ts_{e}}} \fphFP(\addr) {\ne} \emptyset \implies \tshp(\addr)(\ts)\isundef 
	\vspace{3pt}\\
%
%        
	\consistent{\tshp}{\fph}{\ts_s}{\ts_e}
	& \defeq & 
	\for{\addr} \fpW \in \fphFP(\addr) \implies \\
	&& \quad \for{\ts \in (\ts_s,\ts_e)} \tshp(\addr)(\ts) {\ne} (\stub, \etW, \stub) \\
	&& \quad \land\ \neg\exsts{\tsid, \ts'_s, \ts'_e} \ts'_s < \ts_e \land
       \ts'_e > \ts_e \land \tshp(\addr)(\ts'_s) = (\stub, \stub, \tsid) \land 
       \tshp(\addr)(\ts'_e) = (\stub, \etW, \tsid) \\
	&& \quad \land\ \for{\ts_m} \ts_m {=} \min(\Setcon{\ts'' }{ \ts'' > \ts_{e} \land
       \tshp(\addr)(\ts'')\isdef}) \implies \tshp(\addr)(\ts_{min}) \neq (\stub, \etR, \stub) 
	\vspace{3pt}\\
%
%        
	\pred{fresh}{\tshp, \tsid}  & \defeq & \neg\exsts{\addr, \ts} \tshp(\addr)(\ts) {=} (\stub, \stub, \tsid)
    \end{rclarray}
\]
\hrule\vspace{5pt}
\caption{Per-thread operational semantics}
\label{fig:thread_semantics}
\end{figure}

In order to model concurrency, we use thread pools.
A thread pool is modelled as a finite partial map from thread identifiers to triples of the form $(\stk, \ts, \prog)$. That is, each thread is associated with a stack $\stk$,a timestamp $\ts$ and a program $\prog$ to be executed. 

\begin{defn}[Thread pools]
\label{def:thread_pools}
Given the sets of stacks $\Stacks$ (\defin\ref{def:stacks}), timestamps $\Timestamp$ (\defin\ref{def:timestamp_heaps}) and programs $\Programs$ (\defin\ref{def:language}), the set of \emph{thread pools} is: $\thpl \in \TPool \eqdef \ThreadID \parfinfun \Stacks \times \Timestamp \times \Programs$.
\end{defn}
 
\begin{defn}[Thread pool semantics] 
\label{def:thread_pool_semantics}
Given the sets of timestamp heaps $\TSHeaps$ (\defin\ref{def:timestamp_heaps}), transition labels \( \Translabel \) (\defin\ref{def:label}) and thread pools $\TPool$ (\defin\ref{def:thread_pools}), the \emph{thread pool semantics}, 
%
\[
	\toG{} : (\TSHeaps \times \TPool) \times \Translabel \times (\TSHeaps \times \TPool) 
\]
%
is defined in \fig\ref{fig:thread_pool_semantics}.
%
\end{defn}
%
The thread pool operational semantics is given in \fig\ref{fig:thread_pool_semantics}, where an arbitrary thread in the pool $\thpl$ is picked to run for one step.
If the next execution step is a thread fork, then a new thread $\thid$ is allocated in the pool to be executed with its stack and timestamp copied from those of the parent (forking) thread.
Conversely, when the next execution step is the joining of thread $\thid'$, then $\thid'$ is removed from the thread pool and the local time stamp is accordingly updated to the maximum timestamp between the parent thread and that of $\thid'$ (as guaranteed by the per-thread semantic relation $\toT{}$ in the premise).
%
\begin{figure}
\hrule\vspace{5pt}
%
\[
    \infer[\rl{PSingle}]{%
        ( \tshp, \thpl \uplus \Set{ \thid \mapsto (\stk, \ts, \iprog) } ) \ \toG{\lb} \  ( \tshp', \thpl \uplus \Set{ \thid \mapsto (\stk', \ts', {\iprog}') } ) 
    }{%
        ( \stk, \tshp, \ts ) , \iprog \ \toT{\lb} \  ( \stk', \tshp', \ts' ) , {\iprog}' 
        \quad \lb \in \Set{ \lbID, \lbC{\stub} }
    }
\]

\[
    \infer[\rl{PFork}]{%
        ( \tshp, \thpl \uplus \Set{ \thid \mapsto (\stk, \ts, \iprog) } ) \ \toG{\lbF{\thid', \prog''}} \  ( \tshp', \thpl \uplus \Set{ \thid \mapsto (\stk', \ts', {\iprog}'), \thid' \mapsto (\lambda \var \ldotp 0, \ts', \prog'') } )
    }{%
        ( \stk, \tshp, \ts ) , \iprog \ \toT{\lbF{\thid', \prog''}} \  ( \stk', \tshp', \ts' ) , {\iprog}' 
    }
\]

\[
    \infer[\rl{PJoin}]{%
        ( \tshp, \thpl \uplus \Set{ \thid \mapsto (\stk, \ts, \iprog), \thid' \mapsto (\stk', \ts'', \pskip) } )  \ \toG{\lbJ{\thid',\ts''}} \ ( \tshp', \thpl \uplus \Set{ \thid \mapsto (\stk', \ts', {\iprog}')} )
    }{%
        ( \stk, \tshp, \ts ) , \iprog \ \toT{\lbJ{\thid',\ts''}} \  ( \stk', \tshp', \ts' ) , {\iprog}' 
    }
\]
%
\hrule\vspace{5pt}
\caption{Thread pool semantics}
\label{fig:thread_pool_semantics}
\end{figure}
