\section{Rules}

\subsection{Rules for Local}

The proof rules are standard except \rl{TRDeref} and \rl{TRMutate}.
The \rl{TRDeref} rule add read fingerprint in finger-tracking set, only if there is no write finger-print.
This is because once a location has been re-written, the rest read are considered as local operations, while the finger-print only records those operations might have effect on global state.
%
\[
    \infer[\rl{TRDeref}]{%
        \judgeL{\expr \fpt{\fp} \lexpr}{ \pderef{\var}{\expr} }{\var \dot= \lexpr \sep \expr \fpt{\addFPR{\fp}} \lexpr }
    }{%
        \var \notin \func{fv}{\expr} &&
        \var \notin \func{fv}{\lexpr}  
    }
\]
 
\[
    \infer[\rl{TRMutate}]{%
        \judgeL{\expr_1 \fpt{\fp} \stub }{ \pmutate{\expr_1}{\expr_2} }{ \expr_1 \fpt{\addFPW{\fp}} \expr_2} 
    }{}
\]

\subsection{Chain of Actions and Merge}

\begin{defn}[Merge fingerprint heaps]
\label{def:merge-finger-heap}
The \emph{merge of fingerprint heaps}, written \(\fph_{l} \mopFP \fph_{r}\), is defined as follows:
\[
    \begin{rclarray}
        \fph_{l} \mopFP \fph_{r} & \defeq & \lambda \addr \ldotp 
            \begin{cases}
                \fph_{l}(\addr) & a \in \dom(\fph_{l}) \setminus \dom(\fph_{r})  \\
                \fph_{r}(\addr) & a \in \dom(\fph_{r}) \setminus \dom(\fph_{l}) \\
                \fph_{l}(\addr) \mopVAL \fph_{r}(\addr)  & a \in \dom(\fph_{l}) \cap \dom(\fph_{r}) \\
            \end{cases}
    \end{rclarray}
\]
where the \emph{merge of fingerprint heap values} is defined: \[ \begin{rclarray}
        (\val_{l}, \fp_{l}) \mopVAL (\val_{r}, \fp_{r}) & \defeq & 
            \begin{cases}
                (\val_{l}, \fp_{l} \cup \fp_{r} ) & \val_{l} = \val_{r} \land \fpW \notin \fp_{l} \cup \fp_{r} \\
                (\val_{l}, \fp_{l} \cup \fp_{r} ) & \fpW \in \fp_{l} \land \fpW \notin \fp_{r} \\
                (\val_{r}, \fp_{l} \cup \fp_{r} ) & \fpW \notin \fp_{l} \land \fpW \in \fp_{r} \\
            \end{cases}
    \end{rclarray}
\]
\end{defn}

\begin{defn}[Fingerprint heap agreement]
Given two fingerprint heaps, the \emph{fingerprint heap agreement} is defined as follows:
\[
    \begin{rclarray}
        \pred{agree\_heap}{\fph_{l},\fph_{r}} & \defeq  & (\fph_{l} \mopFP \fph_{r} ) \isdef
    \end{rclarray}
\]
where, the agreement between two fingerprint heaps means that, if there is overlap, the overlapped part must be at the same state.
\end{defn}

\sx{
    Andrea gives a better idea to do this by defining merging fingerprint heaps first.
    Big thanks. :)))
}
\azalea{This is a bit strong! For instance, according to this definition the heaps $\pv x \pt_{\emptyset} 1$ and $\pv x \pt_{\{\fpR\}} 1$ do not agree! Is that what you want?

Perhaps you can define this as:
\[
\begin{rclarray}
	\agree{\fph_l}{\fph_r} & \defeq  & \ws{\fph_l} \cap \ws{\fph_r} = \emptyset \\
        && \land\ \exsts{\h_1, \h_2, \h} \heapOnly{\readOnly{\fph_l}} = \h_1 \composeH \h \land \heapOnly{\readOnly{\fph_r}} = \h \composeFP \h_2 
        \land \h_1 \composeH \h \composeH \h_2 \isdef
\end{rclarray}        
\]
where
\[
\begin{rclarray}
	\func{ws}{\fph} & \defeq & \myset{\loc}{ \exsts{\fp} \fph(\loc) = (\stub, \fp) \land \fpW \in \fp} \\\\
%
	\readOnly{.} & : & \FPHeaps \rightarrow \FPHeaps\\	
	\readOnly{\fph}(\loc) & \defeq & 
	\begin{cases}
		\fph(\loc) & \text{if } \loc \not\in \ws{\fph} \\
		\text{undefined} & \text{otherwise}
	\end{cases}\\\\
%	
	\heapOnly{.} & : & \FPHeaps \rightarrow \Heaps\\	
	\heapOnly{\fph}(\loc) & \defeq & 
	\begin{cases}
		\val  & \text{if } \exsts{\val} \fph(\loc) = (\val, -) \\
		\text{undefined} & \text{otherwise}
	\end{cases}
\end{rclarray}
\]
}

\begin{defn}[Chain of interference]
    \label{def:chain-intf}  
    The \emph{chain of interference}, \( \predn{chain}  : \Interference \parfun \Interference \) is defined as follows:
    \[
        \begin{rclarray}
            \pred{chain}{\intf} & \defeq & \bigcup\limits_{\nat \in \Nat} \intf_{\nat} \\
        \end{rclarray}
    \]
    where,
    \[
        \begin{rclarray}
            \intf_0 & \defeq & \intf \\
            \intf_{\nat + 1} & \defeq & 
            \bigcup\limits_{\kap_{l}, \kap_{r} \in \dom(\intf_{\nat})} \Setcon{\kap_{l} \composeK \kap_{r} \mapsto (\ls^{p}, \ls^{q})}{\exsts{ \ls_{l}^{p}, \ls_{l}^{m}, \ls_{l}^{q}, \ls_{r}^{p}, \ls_{r}^{m}, \ls_{r}^{q} } \intf_{\nat}(\kap_{l}) = (\ls_{l}^{p}, \ls_{l}^{q}) \land \intf_{\nat}(\kap_{r}) = (\ls_{r}^{p}, \ls_{r}^{q}) \land {} \\
            \ls^{p} = \ls_{l}^{p} \composeLS \ls_{l}^{m} \land \ls_{l}^{q} \composeLS \ls_{l}^{m} = \ls_{r}^{p} \composeLS \ls_{r}^{m} \land \ls_{r}^{q} \composeLS \ls_{r}^{m}= \ls^{q}  }\\
        \end{rclarray}
    \]
\end{defn}

\sx{
    It is a transitive closure but labelled by \( \kap \).
    And when we really use the \( \intf \) we only use those where the pre-condition are only tagged with emptyset fingerprint.

    Should carefully consider the following cases:
    \[
        \begin{array}{r c l l}
        \vx \fptEMP 0 \transfersto \vx \fptR 0 & \text{then} & \vx \fptR 0 \transfersto \vx \fptRW 1 & yes \\
        \vx \fptEMP 0 \transfersto \vx \fptW 1 & \text{then} & \vx \fptW 1 \transfersto \vx \fpt{\addFPR{\{\fpW\}}} 1 &  yes \\
        \vx \fptEMP 0 \transfersto \vx \fptW 1 & \text{then} & \vx \fptW 1 \transfersto \vx \fptW 2 &  no ? (give \ yes \ for \ now) \\
        \end{array}
    \]
}

The chains of interference describes all the possible transition for a single transaction and its the required capabilities.

\begin{defn}[Action agreement]
The \emph{action agreement} is defined as follows:
\[
    \begin{rclarray}
        \pred{agree\_action}{(\ls_{l}^{p}, \ls_{l}^{q} ),(\ls_{r}^{p}, \ls_{r}^{q} )} & \eqdef & \pred{agree\_local}{\ls_{l}^{p}, \ls_{r}^{p}} \land \pred{agree\_local}{\ls_{l}^{q}, \ls_{r}^{q}} \land {}\\
        & & \pred{agree\_cap\_diff}{\ls_{l}^{p}, \ls_{r}^{q}, \ls_{l}^{q}, \ls_{r}^{p}} \\
        \pred{agree\_local}{(\fph_{l}, \ca_{l} ),(\fph_{r}, \ca_{r})} & \eqdef & \pred{agree\_heap}{\fph_{l}, \fph_{r}} \land ( \ca_{l} \composeC \ca_{r} )\isdef  \\
        \pred{agree\_cap\_diff}{(\stub, \ca_{l}^{p}), (\stub, \ca_{l}^{q}), (\stub, \ca_{r}^{p}), (\stub, \ca_{r}^{q})} & \defeq  & ((\ca_{l}^{p} \setminus \ca_{l}^{q}) \composeC (\ca_{r}^{p} \setminus \ca_{r}^{q} ))\isdef \land ((\ca_{l}^{p} \setminus \ca_{l}^{q}) \composeC (\ca_{r}^{q} \setminus \ca_{r}^{p} ))\isdef \land {} \\
        & & ((\ca_{l}^{q} \setminus \ca_{l}^{p}) \composeC (\ca_{r}^{p} \setminus \ca_{r}^{q} ))\isdef \land ((\ca_{l}^{q} \setminus \ca_{l}^{p}) \composeC (\ca_{r}^{q} \setminus \ca_{r}^{p} ))\isdef \\
    \end{rclarray}
\]
where,
\[
    \begin{rclarray}
        %\funcn{ws} & : & \FPHeaps \to \powerset{\Addr} \\
        \func{ws}{\fph} & \defeq & \Setcon{\loc}{ \exsts{ \fp } \fph(\loc) = (\stub, \addFPW{\fp}, \stub)} \\
        %\funcn{get\_no\_write} & :  & \FPHeaps \to \FPHeaps \\
        \func{get\_no\_write}{\fph } & \defeq & \fph \setminus \Setcon{\loc \mapsto \stub }{ \loc \in \pred{ws}{\fph}} \\
    \end{rclarray}
\]
\sx{
The ``\( \setminus \)'' needs to be defined in a more robust way to include splitting capabilities.
The first line of agreement on actions is to stop merging of the following two actions:
\[
\begin{array}{@{}l@{}}
\cass{A}{}: \vx \pt_{\emptyset} 0 \sep \vy \pt_{\emptyset} 0 \sep \cass{C}{} \transfersto  \vx \pt_{\Set{\fpR}} 0 \sep \vy \pt_{\Set{\fpW}} 1 \\
\cass{B}{}: \vx \pt_{\emptyset} 0 \sep \vy \pt_{\emptyset} 0 \sep \cass{C}{} \transfersto  \vx \pt_{\Set{\fpW}} 1 \sep \vy \pt_{\Set{\fpR}} 0
\end{array}
\]
The second line of agreement on actions is to stop merging of the following two actions:
\[
\begin{array}{@{}l@{}}
\cass{A}{}: \vx \pt_{\emptyset} 0 \sep \vy \pt_{\emptyset} 0 \transfersto  \vx \pt_{\Set{\fpR}} 0 \sep \vy \pt_{\Set{\fpW}} 1 \sep \cass{C}{}\\
\cass{B}{}: \vx \pt_{\emptyset} 0 \sep \vy \pt_{\emptyset} 0 \sep \cass{C}{} \transfersto  \vx \pt_{\Set{\fpW}} 1 \sep \vy \pt_{\Set{\fpR}} 0
\end{array}
\]
Instead of cross-check pre against another's post, we should check the differential.
}
For two actions to agree, their pre- and post-conditions must agree on the heaps and the capabilities.
Additional, the differential of capabilities must agree, so that when merging these two actions, the merged result does not have invalid capabilities transfer.

\azalea{Again, the definition of \texttt{agree\_action} is too strong with respect to capabilities. I have pointed this out before. For instance, assuming that $\cass{C}{} * \cass{C}{}$ is not defined, according to your definition these two actions do not agree (because of the second conjunct in \texttt{agree\_local)}:
\[
	\cass{A}{}: \vx \pt_{\emptyset} 0 \sep \vy \pt_{\emptyset} 0 \sep \cass{C}{} \transfersto  \vx \pt_{\Set{\fpW}} 1 \sep \vy \pt_{\Set{\fpR}} 0 \sep \cass{C}{}
\]
and
\[
	\cass{B}{}: \vx \pt_{\emptyset} 0 \sep \vy \pt_{\emptyset} 0 \sep \cass{C}{} \transfersto  \vx \pt_{\Set{\fpR}} 0 \sep \vy \pt_{\Set{\fpW}} 1 \sep \cass{C}{}
\]
Both actions require $\cass{C}{}$ in the shared state for them to trigger. However, their write set is totally disjoint.\\

There is however a way to correct this. Provided that your PCM satisfies certain conditions, you can monitor resource transfer (on capabilities) and generalise the definition. \\

So you have two choices:\\
1) Keep your capability PCM parametric (user-instantiated) but disallow resource transfer (including on capabilities) completely. Your current definition is too restrictive anyway - as with the example above. We will introduce the generalisation I have in mind at some point to allow resource transfer.\\

2) Define your capability PCM as token sets: $(\powerset{\textsf{Token}}, \uplus, \emptyset)$ and then it is easy to define resource transfer in a more flexible way as follows: for each action, you identify the tokens removed from the state, the tokens added and tokens left unchanged. Then for two actions to agree, their respective removed tokens and added tokens must be disjoint and they should agree on the unchanged tokens. 
Again, when  we generalise the restrictions in our formalism, we will show that this particular capability PCM satisfies the necessary conditions. 
In fact, regardless of generalisation, it'll be easier to write the paper with this simpler construction and hide the generalised form in the tech report. 
}

\sx{
    Yes, I agree with you, I think maybe there there is a way to keep general PCM but allow resource transfer? 
    Gonna have more thought about this entire section.
}

\end{defn}

\begin{defn}[Merge of actions]
\label{def:merge-action}
The \emph{merge of actions}, \( \funcn{merge\_action} : \Actions \times \Actions \parfun \Actions  \), which specifically merges the right-hand side to the left-hand side, is defined as follows:
\[
    \begin{rclarray}
        
        \func{merge\_action}{(\ls_{l}^{p}, \ls_{l}^{q} ),(\ls_{r}^{p}, \ls_{r}^{q} )} & \defeq &
        \begin{cases}
        ( \func{merge\_state}{\ls_{l}^{p}, \ls_{r}^{p}}, \func{merge\_state}{\ls_{l}^{q}, \ls_{r}^{q}} )  &  \pred{agree\_action}{(\ls_{l}^{p}, \ls_{l}^{q} ),(\ls_{r}^{p}, \ls_{r}^{q} )} \\
        \text{undefined} & \text{otherwise} \\
        \end{cases} \\
    \end{rclarray}
\]
where,
\[
    \begin{rclarray}
        \func{merge\_state}{(\fph_{l}, \ca_{l} ),(\fph_{r}, \ca_{r})} & \defeq & (\func{eager\_merge\_heap}{\fph_{l},\fph_{r}}, \ca_{l} \composeC \ca_{r} ) \\
        \func{eager\_merge\_heap}{\fph_{l}, \fph_{r}} & \defeq & \lambda \loc \ldotp 
        \begin{cases}
            \fph_{r}(\loc) & \loc \in \dom(\fph_{l}) \cap \pred{ws}{\fph_{r}} \\
            \fph_{l}(\loc) & \loc \in \dom(\fph_{l}) \setminus \pred{ws}{\fph_{r}} \\
            \text{undefined} & \loc \notin \dom(\fph_{l})
        \end{cases}
        \\
    \end{rclarray}
\]
\end{defn}

\sx{ Remember to include the constraint that the pre should be empty fingerprints to cope with potentially general form of actions  }

\begin{defn}[Merge of interference]
\label{def:merge-intf}
Given the merge of action (\defin\ref{def:merge-action}), the \emph{merge of interference}, \( \funcn{merge\_interference} : \Actions \times \Interference \parfun \powerset{\Actions} \) , is defined as follows:
\[
    \begin{rclarray}
        \func{merge\_action}{(\ls_{l}^{p}, \ls_{l}^{q} ),\intf} & \defeq & \Set{(\ls_{l}^{p}, \ls_{l}^{q}) } \cup \Setcon{\func{merge\_action}{(\ls_{l}^{p}, \ls_{l}^{q}), (\ls_{r}^{p}, \ls_{r}^{q})} }{(\ls_{r}^{p}, \ls_{r}^{q}) \in \intf}
    \end{rclarray}
\]
It merges all possible actions from interference (right-hand side) to an  action (left-hand side).
Note that the final result also include the action itself.
\end{defn}

We will use notation \(  \mergeA{(\ls_{l}^{p}, \ls_{l}^{q} )}{(\ls_{r}^{p}, \ls_{r}^{q} )} \) or \( (\ls_{l}^{p}, \ls_{l}^{q} ) \mopA ( \ls_{r}^{p}, \ls_{r}^{q} ) \) to refer to the \( \predn{merge\_action} \) function.
Similarly, we will use  \(  \mergeI{(\ls_{l}^{p}, \ls_{l}^{q} )}{\intf} \) or \( (\ls_{l}^{p}, \ls_{l}^{q} ) \mopI \intf \) to refer to the \( \predn{merge\_interference} \) function.

\begin{defn}[Merge closure]
Given the merge of interference (\defin\ref{def:merge-intf}), the \emph{merge closure} of a interference is defined as follows:
\[
    \begin{rclarray}
        \intf\mclose & \defeq & \bigcup\limits_{\nat \in \Nat} \intf^{\nat} \\
    \end{rclarray}
\]
where,
\[
    \begin{rclarray}
        \intf^{0} & \defeq & \intf \\
        \intf^{i+1} & \defeq & \bigcup\limits_{(\ls_{l}^{p}, \ls_{l}^{q}) \in \intf^{i}} (\ls_{l}^{p}, \ls_{l}^{q}) \mopI \intf^{i} \\
    \end{rclarray}
\]
\end{defn}

\subsection{Rules for Global}

The \rl{PRCommit} rule lifts the local effect of transaction \( \trans \) to global level by repartition \( \repartition{\gpre}{\gpost}{\lpre}{\lpost} \).
The repartition stripes off the fingerprints but uses the fingerprints to merge the local effect and the interference.
This is, the environment is allowed to write to locations that are different from the ones by transaction \( \trans \).
%
\[
    \infer[\rl{PRCommit}]{%
        \judgeG{\gpre}{ \ptrans{\trans} }{\gpost}
    }{%
        \judgeL{\lpre}{\trans}{\lpost} &&
        \repartition{\gpre}{\gpost}{\lpre}{\lpost}
    }
\]

\begin{defn}[Collapse of fingerprint heaps]
    \label{def:clps-fingerprint-hp}
    The \emph{Collapse of fingerprint heaps}, \( \clpsFP{.} : \FPHeaps \to \PHeap \), is defined as follows:
    \[
    \begin{rclarray}
        \clpsFP{\fph} & \defeq & \lambda \loc \ldotp 
        \begin{cases}
            \val & \fph(\loc) = (\val, \stub, \stub) \\
            \text{undefined} & \text{otherwise}
        \end{cases} \\
    \end{rclarray}
    \]
\end{defn}

\begin{defn}[Repartition]
\[
    \begin{rclarray}
        \repartition{\gpre}{\gpost}{\lpre}{\lpost} & \iffdef & 
        \for{ \lenv, \stk_{p}, \world_{p} \in \evalW[\lenv, \stk_{p}]{\gpre} }  \\
        & & \implies \exsts{ \ca_{p}, \fph_{p} } ( \fph_{p}, \unitC) \in \evalLS[\lenv, \stk_{p}]{\lpre} \land (\clpsFP{\fph_{p}}, \ca_{p} ) = \flattenW{\world_{p}} \\
        & & \implies \for{ \stk_{q}, \ca_{q}, \fph_{q} } ( \fph_{q}, \unitC ) \in \evalLS[\lenv, \stk_{q}]{\lpost} \land ((\fph_{p},\ca_{p}), (\fph_{q}, \ca_{q})) \in \guar  \\
        & & \implies \for{\fph'_{q}, \ca'_{q}}  (\stub, (\fph'_{q}, \ca'_{q})) \in \mergeI{((\fph_{p},\ca_{p}), (\fph_{q}, \ca_{q}))}{ \rely} \\
        & & \implies \exsts{ \world_{q} \in \evalW[\lenv, \stk_{q}]{\gpost} } (\clpsFP{\fph'_{q}}, \ca'_{q} ) = \flattenW{\world_{q}} \\
    \end{rclarray}
\]
\end{defn}
\sx{ I think there might be a problem of quantification of stack \( \stk_{q} \), because the stack of post-condition is not necessary  to be the same as the pre-condition. }

\sx{ Remember to include the constraint that the pre should be empty fingerprints to cope with potentially general form of actions  }
