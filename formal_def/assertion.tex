\section{Assertion and Rules\label{sec:assertion}}

Before introducing assertion, we extend arithmetic expressions with logical variables, ranging over \( \lvar \).

\[
    \begin{syntax}{\expr}
        \lvar \quad | \quad \dots 
    \end{syntax}
\]

Assume a logical environment \( \lenv \), we extend the evaluation of arithmetic expressions.

\[
\begin{rclarray}
    \eval{\lvar}_{\lenv, \stk} & \defeq & \lenv(\lvar)
\end{rclarray}
\]

\subsection{Local/Transaction}
Local assertions, also transaction assertions, describe the state inside transactions.
Note that transactions always work on their own copies of the global memory.
Therefore, one can think the local assertions describe local resources.

\[ 
    \begin{rclarray}
        \fp \subseteq \Fingerprint & \defeq & \Set{\wfp,\rfp} \\
        \lpre , \lpost \in \Localassertion & \defeq & 
                  \assfalse \quad                  |
            \quad \asstrue \quad                   |
            \quad \assemp \quad                    |
            \quad \expr \pt_{\fp} \expr \quad      | 
            \quad \lpre \sep \lpost \quad          | 
            \quad \lpre \land \lpost \quad         | \\
            & &   \lpre \lor \lpost \quad          |
            \quad \exists \lvar \ldotp \lpre \quad |
    \end{rclarray}
\]

Compared with sequential separation logic, we annotated assertions with \emph{fingerprint}.
The \emph{fingerprint} tracks how a transactions access heap.

\begin{tabular}{c | l}
    \hline
    fingerprint & meaning \\ \hline
    \(\emptyset\) & no access \\ 
    \(\Set{\wfp}\) & write \\ 
    \(\Set{\rfp}\) & read before any write \\ 
    \(\Set{\rfp, \wfp}\) & read before any write, and then write \\ \hline
\end{tabular}

We define a order of fingerprint \( \fp \) like follows.

\begin{center}
    \begin{tikzpicture}
        \node (emp) {\(\emptyset\)};
        \node[above right=0.3cm and 0.3cm of emp] (r) {\(\Set{\rfp}\)};
        \node[above left=0.3cm and 0.3cm of emp] (w) {\(\Set{\wfp}\)};
        \node[above=0.3cm of r] (rw) {\(\Set{\rfp, \wfp}\)};
        \draw[->] (emp) -- (r);
        \draw[->] (emp) -- (w);
        \draw[->] (r) -- (rw);
    \end{tikzpicture}
\end{center}

Given the order we define a left merge operator on fingerprints.
It reflects the fact that once a transaction writes to a location, the following reads from the same location are local.

\[
    \begin{rclarray}
        \fp_{1} \bmrg \fp_{2} & \defeq & 
        \begin{funcarray}
            \fp_{1} \cup \fp_{2}  & \fp_{1} \sqsubseteq \fp_{1} \cup \fp_{2} \\
            \fp_{1}  & o.w. \\
        \end{funcarray}
    \end{rclarray}
\]

The local assertions are interrupted as a set of possible heap associated fingerprint.
We use \( \fphp \) to refer to a tuple of of a (plain) heap, a write set and a read set.

\[
    \begin{rclarray}
        \fphp \in \Heapwithfingerprint & \defeq & \Heap \times \Readset \times \Writeset \\
        (\hp_{1}, \rs_{1}, \ws_{1}) \compos_{\fphp} (\hp_{2}, \rs_{2}, \ws_{2}) & \defeq &  (\hp_{1} \uplus \hp_{2}, \rs_{1} \uplus \rs_{2}, \ws_{1} \uplus \ws_{2}) \\
        \unitelem{\fphp} & \defeq & (\emptyset, \emptyset, \emptyset) \\
    \end{rclarray}
\]

\[
    \begin{rclarray}
        \eval{\assfalse}_{\lenv, \stk} & \defeq & \emptyset  \\
        \eval{\asstrue}_{\lenv, \stk} & \defeq & \powerset{ \Heapwithfingerprint}  \\
        \eval{\assemp}_{\lenv, \stk} & \defeq & \Set{\unitelem{\fphp}}  \\
        \eval{\expr_{1} \pt_{\fp} \expr_{2}}_{\lenv, \stk} & \defeq & \Set{(\Set{ \loc \mapsto \val }, \rs, \ws) \middle|
            \begin{array}{@{}l@{}}
                \exists \loc = \eval{\expr_{1}}_{\lenv, \stk}, \val =  \eval{\expr_{2}}_{\lenv, \stk} \ldotp \\
                \fp = \emptyset \implies \rs = \emptyset \land \ws = \emptyset \\
                \fp = \Set{\rfp} \implies \rs = \Set{\loc} \land \ws = \emptyset \\
                \fp = \Set{\wfp} \implies \rs = \emptyset \land \ws = \Set{\loc}  \\
                \fp = \Set{\rfp,\wfp} \implies \rs = \ws = \Set{\loc} \\
            \end{array}
        }  \\
        \eval{\lpre \sep \lpost}_{\lenv, \stk} & \defeq & \Set{ \fphp_{1} \compos_{\fphp} \fphp_{2} \middle| \fphp_{1} \in \eval{\lpre}_{\lenv, \stk} \land \fphp_{2} \in \eval{\lpost}_{\lenv, \stk} }  \\
        \eval{\lpre \land \lpost}_{\lenv, \stk} & \defeq & \eval{\lpre}_{\lenv, \stk} \cap \eval{\lpost}_{\lenv, \stk} \\
        \eval{\lpre \lor \lpost}_{\lenv, \stk} & \defeq & \eval{\lpre}_{\lenv, \stk} \cup \eval{\lpost}_{\lenv, \stk} \\
        \eval{\exists \lvar \ldotp \lpre}_{\lenv, \stk} & \defeq & \eval{\lpre}_{\lenv\remapsto{\lvar}{\val}, \stk}  \\
    \end{rclarray}
\]

The proof rules are standard except \rl{TRDeref} and \rl{TRMutate}.
The \rl{TRDeref} rule add read finger-print in finger-tracking set, only if there is no write finger-print.
This is because once a location has been re-written, the rest read are considered as local operations, while the finger-print only records those operations might have effect on global state.

\[
    \infer[\rl{TRDeref}]{%
        \judgement{}{\var = \dontcare \land \expr_{1} \pt_{\fp} \expr_{2} }{ \pderef{\var}{\expr_{1}} }{\var = \expr_{2} \land \expr_{1} \pt_{\fp \bmrg \Set{\rfp}} \expr_{1} }
    }{%
        \var \notin \func{fv}{\expr_{1}} \quad
        \var \notin \func{fv}{\expr_{2}} \quad 
    }
\]

\[
    \infer[\rl{TRMutate}]{%
        \judgement{}{\expr_{1} \pt_{\fp} \dontcare }{ \pmutate{\expr_{1}}{\expr_{2}} }{ \expr_{1} \pt_{\fp \bmrg \Set{\wfp}} \expr_{1} }
    }{}
\]

\subsection{Global/Program}

The capability assertion are interpreted as a set of tuples of region identifiers, a capability identifiers and values.

\[
    \begin{rclarray}
        \Regionid & \defeq & \Set{\rid, \dots} \\
        \Capabilityid & \defeq & \Set{\capid, \dots } \\
        \capass \in \Capabilityassertion & \defeq & \captk{\capid(\vec{\lvar})}_{\rid}  \\
        \capb \in \cstate \subseteq \Capability & \defeq & \Regionid \times \Capabilityid \times \Val^{*} \\
        \eval{\captk{\capid(\vec{\lvar})}_{\rid}}_{\lenv, \stk} & \defeq & \Set{(\rid, \capid, \lenv(\vec{\lvar}))} \\
    \end{rclarray}
\]

All capabilities associated with a region forms a partial commutative monoid (PCM):

\[
    \begin{rclarray}
        \setcap & \in & \powerset{\Capabilityid \times \Val^{*}} \\
        \func{cap}{\rid} & \defeq & (\setcap, \compos_{\setcap}, \unitelem{\setcap}) \\
    \end{rclarray}
\]

Given that, the composition of  sets of capabilities \( \cstate_{1} \) and \( \cstate_{2} \):

\[
    \begin{rclarray}
        \cstate_{1} \compos_{\cstate} \cstate_{2} & \defeq & 
        \begin{funcarray}
            \cstate_{1} \uplus \cstate_{2} & \forall \capb_{1} \in \cstate_{1}, \capb_{2} \in \cstate_{2} \ldotp \capb_{1}\projection{1} = \capb_{2}\projection{1} \land  ((\capb_{1}\projection{2}, \capb_{1}\projection{3}) \compos_{\setcap} (\capb_{2}\projection{2}, \capb_{2}\projection{3}))\isdef \\
            \texttt{undefined} & o.w. \\
        \end{funcarray} \\
    \end{rclarray}
\]

The box assertion \( \boxass{\gpre}{\rid}{\intass} \) asserts part of heap that can be shared, where \( \rid \) is region identifier and \( \intass \) is the interference, i.e.\ all the possible transitions.
The interference is a set of transitions that are labelled by capabilities.

\[
    \begin{rclarray}
            \gpre , \gpost \in \Globalassertion & \defeq & 
                  \assfalse \quad                   |
            \quad \asstrue \quad                    |
            \quad \assemp \quad                     |
            \quad \expr \pointsto \expr \quad       |
            \quad \boxass{\gpre}{\intass}{\rid} \quad |
            \quad \capass \quad                     | \\
            & &  \gpre \sep \gpost \quad            |
            \quad \gpre \land \gpost \quad          |
            \quad \gpre \lor \gpost \quad           |
            \quad \exists \lvar \ldotp \gpre \quad  | \\
    \end{rclarray}
\]

The global assertions are interpreted as a tuple of a world and a time-stamp.
A world is a pair of shared state and logical state.
The logical state is a pair of time-stamp heap and capability, where capability is a partial finite function from region identifier to a token.
The shared state is a partial finite function from region identifier to logical state and its interference.

\[
    \begin{rclarray}
        \lstate \in \Logicalstate & \defeq & \Timestampheap \times \powerset{\Capability} \\
        \sstate \in \Sharestate & \defeq & \Regionid \parfinfun \Logicalstate \times \Interference \\
        \world \in \World & \defeq & \Sharestate \times \Logicalstate
    \end{rclarray}
\]


The composition of logical states.

\[
    \begin{rclarray}
        \lstate_{1} \compos_{\lstate} \lstate_{2} & \defeq & (\lstate_{1}\projection{1} \ \uplus \ \lstate_{2}\projection{1}, \lstate_{1}\projection{2} \ \compos_{\cstate} \ \lstate_{2}\projection{2}) \\
        \unitelem{\lstate} & \defeq & ( \emptyset, \emptyset ) \\
    \end{rclarray}
\]

The composition of capabilities and worlds.

\[
    \begin{rclarray}
        \world_{1} \compos_{\world} \world_{2} & \defeq & 
        \begin{funcarray}
            (\sstate, \lstate_{1} \compos_{\lstate} \lstate_{2}) & \world_{1} = (\sstate, \lstate_{1}) \land \world_{2} = (\sstate, \lstate_{2}) \\
            \texttt{undefined} & o.w. \\
        \end{funcarray} \\
        \unitelem{\world} & \defeq & ( \emptyset, \unitelem{\lstate} ) \\
    \end{rclarray}
\]

The global assertions are interpreted as a set of worlds and their corresponding times.

\[
    \begin{rclarray}
        \eval{\assfalse}_{\lenv, \stk} & \defeq & \emptyset \\
        \eval{\asstrue}_{\lenv, \stk} & \defeq & \powerset{\World \times \Timestamp } \\
        \eval{\assemp}_{\lenv, \stk} & \defeq & \Set{(\emptyset, \ts)} \\
        \eval{\expr_{1} \pt \expr_{2}}_{\lenv, \stk} & \defeq & \Set{ ( ( \emptyset, ( \tshp, \emptyset ) ), \ts ) \middle| 
            \begin{array}{@{}l@{}}
                \exists \loc = \eval{\expr_{1}}_{\lenv, \stk}, \val = \eval{\expr_{2}}_{\lenv, \stk}, \ts' \ldotp \ts' \leq \ts \land 
                \dom(\tshp) = \Set{ \loc } \land \tshp(\loc)(\ts') =  \val \\
                \tshp(\loc)(\ts') = (\val,\dontcare, \dontcare) \land \forall \ts'' \in ( \ts', \ts) \ldotp \tshp(\loc)(\ts'')\undef \\
            \end{array}
        } \\
        \eval{\boxass{\gpre}{\intass}{\rid}}_{\lenv, \stk} & \defeq & \Set{ ( ( \sstate, \lstate ), \ts ) \middle| \exists \sstate', \lstate' \ldotp ( ( \sstate', \lstate \compos_{\lstate} \lstate' ), \ts ) \in \eval{\gpre}_{\lenv, \stk, \ts} \land \sstate = \sstate' \uplus \Set{\rid \mapsto ( \lstate', \eval{\intass}_{\lenv,\stk} ) } } \\
        \eval{ \capass }_{\lenv, \stk} & \defeq & \Set{ ( ( \sstate, ( \tshp, \cstate ) ), \ts ) \middle| \sstate = \emptyset \land \tshp = \emptyset \land \cstate = \eval{ \capass }_{\lenv, \stk} } \\
        \eval{ \gpre \sep \gpost }_{\lenv, \stk} & \defeq & \Set{ ( \world_{1} \compos_{\world} \world_{2}, \ts ) \middle| ( \world_{1}, \ts ) \in \eval{\gpre}_{\lenv, \stk, \ts} \land ( \world_{2}, \ts ) \in \eval{\gpost}_{\lenv, \stk, \ts} } \\
        \eval{\gpre \land \gpost}_{\lenv, \stk} & \defeq & \eval{\gpre}_{\lenv, \stk} \cap \eval{\gpost}_{\lenv, \stk} \\
        \eval{\gpre \lor \gpost}_{\lenv, \stk} & \defeq & \eval{\gpre}_{\lenv, \stk} \cup \eval{\gpost}_{\lenv, \stk} \\
        \eval{\exists \lvar \ldotp \gpre}_{\lenv, \stk} & \defeq & \eval{\gpre}_{\lenv\remapsto{\lvar}{\val}, \stk} \\
    \end{rclarray}
\]

We define \emph{merge} with respect to two heaps associated with their read sets and write sets.
The operation \( \wmrg \) eagerly merge the left-hand side to the right-hand side.
This means that, first, the domain of the result is the same as the domain of left-hand side.
Second, the result takes left-hand side but propagate all the write effects from right-hand side.

\[
    \begin{rclarray}
        \dom(\fphp) & \defeq & \dom(\fphp\projection{1}) \\
        \fphp \wmrg \fphp' & \defeq & 
        \left( \begin{array}{@{}l@{}}
        \lambda \loc \ldotp  
        \begin{funcarray}
            \hp'(\loc) & \loc \in \ws' \cap \dom(\hp) \\
            \hp(\loc) & \loc \notin \ws' \land \loc \in \dom(\hp) \\
            \texttt{undefined} & o.w. \\
        \end{funcarray},\ 
        \rs \cup ( \dom(\hp) \cap \rs' ),\ 
        \ws \cup ( \dom(\hp) \cap \ws')
        \end{array} \right)\\
        & & \texttt{where} \ \fphp = (\hp, \rs, \ws) \land \fphp' = (\hp', \rs', \ws') \\
    \end{rclarray}
\]

The first element, also pre-condition \( \lpreext \), only contains empty label, \( \dontcare \pt_{\emptyset} \dontcare \), because the semantics requires the pre-condition interpreted as a heap with empty write set and empty read set.
The second element, also called post-condition \( \lpostext \), should contain the same resources as pre-condition.
If a location has only been read, the value should remain the same pre-condition.
\sx{For resource moving in can be tagged with write but don't know how to tag resource move out. This is not very right.}

\[
    \begin{rclarray}
        \lpreext, \lpostext & \in & \Localassertion \uplus \Capabilityassertion \\
        \fphpcap \in \Heapwithfingerprintcapability & \defeq & \Heapwithfingerprint \times \powerset{\Capability} \\
        \intass \in \Interferenceassertion & \defeq & 
              \emptyset \quad |
              \quad \Set{ \captk{\capid(\vec{\lvar})} : \exists \vec{y} \ldotp \lpreext \transfersto \lpostext } \uplus \intass \quad \\
        \eval{\emptyset}_{ \lenv, \stk} & \defeq & \emptyset \\
        \eval{\Set{\captk{\capid(\vec{\lvar})}_{r} : \exists \vec{y} \ldotp \lpre \transfersto \lpost} \uplus \intass}_{\lenv, \stk} & \defeq & \lambda (\rid',\capid',\vec{\val}) \ldotp \\
                                                                                                                                     & & \begin{funcarray}
            \Set{(\fphpcap,\fphpcap') \middle| 
            \begin{array}{@{}l@{}}
                \exists \fphp, \fphp', \setcap, \setcap', \vec{\val}', \lenv' = \lenv[\vec{\lvar} \mapsto \vec{\val}, \vec{y} \mapsto \vec{\val}'] \ldotp \\
                \fphpcap = (\fphp, \cstate) \land \fphpcap = (\fphp', \cstate') \land \\
                \fphp \in \eval{\lpre}_{\lenv', \stk} \land  \fphp' \in \eval{\lpost}_{\lenv', \stk} \land {} \\
                \fphp\projection{2} = \fphp\projection{3} = \emptyset \land \fphp \wmrg \fphp' = \fphp'
            \end{array}} & \rid = \rid' \land \capid = \capid' \\ 
            \eval{\intass}_{\lenv, \stk}(\rid', \capid', \vec{\val}) & o.w.
        \end{funcarray} \\
    \end{rclarray}
\]

The \rl{PRCommit} rule looks the same but the repartition is much more complicated by  merging all possible transitions from the environment that are allowed to run concurrently and commit in the same time.
Note that after the merging, one still need to check stabilisation.

\[
    \infer[\rl{PRCommit}]{%
        \judgement{}{\gpre}{ \ptrans{\cmd} }{\gpost}
    }{%
        \begin{array}{l}
            \judgement{}{\lpre}{\cmd}{\lpost} \quad 
            \vdash \gpre \Rrightarrow^{\{\lpre\}\{\lpost\}} \gpost
        \end{array}
    }
\]

Given the \emph{merge}for \( \fphp \), we can define \emph{merge} on transitions.
The predicate \( \predn{noFingerPrint} \) asserts the read set and write set are empty sets, and \( \predn{noWriteConflict} \) asserts the write sets are disjointed.
The predicate \( \predn{agree} \) has similar meaning as overlapped separation found in CoLoSL, which means that the state of the overlapped parts must agree.
To merge two transactions, if the pre-conditions agree and both of them have no fingerprint, and if the post-conditions agree and they write to different locations, the merged result is a set of transitions including the left-hand side and another transition by merging the post-condition of right-hand side to left-hand side.
Otherwise, the merge only returns a singleton set of left-hand side.

\[
    \begin{rclarray}
        \pred{noFingerPrint}{\fphp} & \defeq & \exists \rs, \ws, \ldotp \fphp = (\dontcare, \rs, \ws) \land \rs = \ws = \emptyset \\
        \pred{noWriteConflict}{\fphp_{l}, \fphp_{r}} & \defeq & \exists \ws_{l} = \fphp_{l}\projection{3}, \ws_{r} = \fphp_{r}\projection{3} \ldotp \ws_{l} \cap \ws_{r} = \emptyset \\
        \pred{agreeState}{\fphp_{l}, \fphp_{r}} & \defeq & \exists \fphp'_{l}, \fphp_{m}, \fphp'_{r}, \fphp \ldotp \fphp_{l} = \fphp'_{l} \compos_{\fphp} \fphp_{m} \land \fphp_{r} = \fphp'_{r} \compos_{\fphp} \fphp_{m} \land \fphp = \fphp'_{l} \compos_{\fphp} \fphp_{m} \compos_{\fphp} \fphp'_{r} \\
        \pred{agreeCapability}{\cstate_{l}, \cstate_{r}} & \defeq & \exists \cstate'_{l}, \cstate_{m}, \cstate'_{r}, \fphp \ldotp \cstate_{l} = \cstate'_{l} \compos_{\cstate} \cstate_{m} \land \cstate_{r} = \cstate'_{r} \compos_{\cstate} \cstate_{m} \land \cstate = \cstate'_{l} \compos_{\cstate} \cstate_{m} \compos_{\cstate} \cstate'_{r} \\
        \pred{agree}{\fphpcap_{l},\fphpcap_{r}} & \defeq & \pred{agreeState}{\fphpcap_{l}\projection{1}, \fphpcap_{r}\projection{1}} \land \pred{agreeCapability}{\fphpcap_{l}\projection{2}, \fphpcap_{r}\projection{2}} \\
        ( \fphpcap_{\lpre}, \fphpcap_{\lpost} ) \bmrg ( \fphpcap'_{\lpre}, \fphpcap'_{\lpost} ) & \defeq & \Set{( \fphpcap_{\lpre}, \fphpcap_{\lpost} )} \cup \Set{(\fphpcap_{\lpre}, ( \fphp_{\lpost} \wmrg \fphp'_{\lpost}, \cstate_{q} \compos_{\cstate} \cstate'_{q} ) ) \middle| 
        \begin{array}{@{}l@{}}
            \pred{noWriteConflict}{\fphp'_{\lpre}, \fphp'_{\lpost} } \land {} \\
            \pred{agree}{\fphpcap_{\lpre}, \fphpcap_{\lpost}} \land \pred{agree}{\fphpcap'_{\lpre}, \fphpcap'_{\lpost}} 
        \end{array}
    } \\
    \end{rclarray}
\]

The repartition is redefined by adding a merging process.
The notation \( \clps{\world} \) collapses a world to a time-stamp heap and capabilities by compositing the private logical state \( \lstate' \) and all the shared logical states \( \sstate(\rid_{i}) \).
To simplify we reuse the same notation for \( \clps{( \world, \ts) } \), it further collapses the time-stamp heap to a plain heap by taking a snapshot at the time \( \ts \).
The lift of a plain heap is a set of all possible worlds with their times that collapse to the plain heap with any possible capabilities, and similarly the lift of a plain heap with its read and write sets is the lift of the plain heap but lose the information about read and write sets.
Given that \( \fphpcap \) talks about interference, either pre- or post-condition, of a certain region, the lift of \( \fphpcap \) is all possible worlds with their times where the lift of the plain heap, i.e.\ the first projection of \( \hphpcap \) is subset of the time-stamp heap corresponding to the region \( \rid \) and the capabilities of \( \fphpcap \), the second projection, is the subset of the capabilities of region \( \rid \).

The repartition means, for all possible world and time, (\world, \ts), that satisfies global assertion \( \gpre \), there exist a heap with its read set and write set, \( \fphp \), that satisfies local assertion \( \lpre \), \( \fphp' \) for assertion \( \lpost \) and a transition \( (\fphpcap, \fphpcap' ) \) that is allowed by the guarantees.
The \( \fphp \) should agree with \( \fphpcap \), which means \( \fphp = \fphpcap\projection{1} \) and similarly \( \fphp' = \fphpcap'\projection{1} \).
Also, the \( (\world, \ts) \) corresponding to \( \gpre \) should agree with the pre-condition of the transition, i.e.\ \( (\world, \ts) \in \lift{\fphpcap} \).
Then for all possible merging between transition \( (\fphpcap, \fphpcap' ) \) and relies, there must exist a corresponding world and its time satisfies the global assertion \( \gpost \).
It means that the world and its time \( (\world', \ts') \) is in the lift of post-condition of the merging result \( \fphpcap'' \).
At last the worlds \( \world \) and \( \world' \) should be balanced, meaning no creation or destruction of resources.

%Given the \( \fphp \), if there exists a \( \fphp' \) that associated with \( \lpost \) and the transition \( (\fphp, \fphp') \)  is allowed by the guarantees \( \grte(\world) \), then for all the possible post-state \( \fphp'' \) by merging the transition \( (\fphp, \fphp') \) with relies, there must exist a world and its time \( (\world', \ts') \) that satisfies global post-condition \( \gpost \) and their collation equals to the first projection of \( \fphp'' \) which is the plain heap.

\[
    \begin{rclarray}
        \clps{\world} & \defeq & (\tshp, \cstate) \ \texttt{where} \ \exists \sstate, \lstate, \lstate', \rid_{0}, \dots, \rid_{n} \ldotp \\
                      & & \qquad \qquad \world = (\sstate, \lstate') \land \Set{\rid_{0}, \dots, \rid_{n}} = \dom(\sstate) \land \lstate = \lstate' \compos_{\lstate} \sstate(\rid_{1}) \compos_{\lstate} \dots \compos_{\lstate} \sstate(\rid_{n})\\
                             & & \qquad \qquad \tshp = \lstate\projection{1} \land \cstate = \lstate\projection{2} \\
        \clps{(\world, \ts)} & \defeq & ( \hp,\cstate ) \ \texttt{where} \ \hp = \func{startstate}{\clps{\world}\projection{1}, \ts} \land \cstate = \clps{\world}\projection{2} \\
        \clps{\fphpcap} & \defeq & ( \hp,\cstate ) \ \texttt{where} \ \hp = \fphp\projection{1}\projection{1} \land \cstate = \fphpcap\projection{2} \\
        %\lift{\hp} & \defeq & \Set{(\world, \ts) \middle| ( \hp , \cstate ) = \clps{(\world, \ts)}}\\
        %\lift{\fphp} & \defeq & \lift{\fphp\projection{1}} \\
        %\lift{\fphpcap} & \defeq &  \Set{(\world, \ts) \middle| \exists \rid, \tshp, \cstate \ldotp \world\projection{1}(\rid) = ((\tshp, \cstate), \dontcare) \land \lift{\fphpcap\projection{1}} \subseteq \tshp \land \fphpcap\projection{2} \subseteq \cstate}\\
        \pred{balance}{\world_{1}, \world_{2}} & \defeq & \exists \tshp_{1}, \cstate_{1}, \tshp_{2}, \cstate_{2} \ldotp (\tshp_{1}, \cstate_{1}) = \clps{\world_{1} } \land  (\tshp_{2}, \cstate_{2}) = \clps{\world_{2} } \land \dom(\tshp_{1}) = \dom(\tshp_{2} ) \land \cstate_{1} = \cstate_{2} \\
        \repartition{\gpre}{\gpost}{\lpre}{\lpost} & \iff & \forall \lenv, \stk, \world, \ts  \ldotp (\world, \ts) \in \eval{\gpre}_{\lenv, \stk} \ldotp \\
                                                   & & \implies \exists \lenv', \stk', \fphp \in \eval{\lpre}_{\lenv, \stk}, \hpfp' \in \eval{\lpost}_{\lenv', \stk'}, \fphpcap, \fphpcap', \fphpcap_{r} \ldotp \\
                                                   & & \qquad (\fphpcap, \fphpcap' ) \in \grte(\world) \land \fphp = \fphpcap\projection{1} \land \fphp' = \fphpcap'\projection{1} \land \clps{(\world, \ts)} = \clps{\fphpcap \compos_{\fphpcap} \fphpcap_{r}}\\ 
                                                   & & \implies \forall \fphpcap'' \ \ldotp ( \dontcare, \fphpcap'') \in ( (\fphpcap, \fphpcap') \bmrg \rely(\world) ) \\
                                                   & & \exists \world',\ts' \ldotp  \ts < ts' \land (\world',\ts') \in \eval{\gpost}_{\lenv', \stk'} \land \clps{(\world', \ts' )} = \clps{\fphpcap''\compos_{\fphpcap} \fphpcap_{r}} \land \pred{balance}{\world, \world'}
    \end{rclarray}
\]

The relies and guarantees.

\[
    \begin{rclarray}
        \grte & \defeq & \lambda \world \ldotp \Set{(\fphpcap, \fphpcap') \middle| \forall \capb \in \world\projection{2}\projection{2} \land (\fphpcap, \fphpcap') \in \world\projection{1}(\capb\projection{1})\projection{2}(\capb)}\\
        \rely & \defeq & \lambda \world \ldotp \Set{(\fphpcap, \fphpcap') \middle| \forall \capb \ldotp \exists \capb' \in \world\projection{2}\projection{2} \ldotp \capb\projection{1} = \capb'\projection{1} \land ((\capb\projection{2}, \capb\projection{3}) \compos_{\setcap} (\capb'\projection{2}, \capb'\projection{3}))\isdef \land (\fphpcap, \fphpcap') \in \world\projection{1}(\capb\projection{1})\projection{2}(\capb')}
    \end{rclarray}
\]

\section{temp}

To merge two actions \( \lpre \transfersto \lpost \) and \( \lpre' \transfersto \lpost' \), it requires the pre-conditions agrees, which means that if they describe some common heaps, the state of the common part should be consistent.
Then if the post-conditions write to different locations, the \emph{merge} (to the left) operator \( \wmrg \) returns a new action where the effect of right hands side propagate to the left hand side.
\sx{Not sure how to do it properly considering there is \(\vec{x}\) binder and extension \(\vec{y}\) }.

\[
    \begin{rclarray}
        \func{writeSet}{\lvar \pointsto_{\fp \cup \Set{\wfp}} \dontcare } & \defeq & \Set{\lvar} \\
        \func{writeSet}{\lvar \pointsto_{\fp \setminus \Set{\wfp}} \dontcare } & \defeq & \emptyset \\
        \func{writeSet}{ \lpre \sep \lpost } & \defeq & \func{writeSet}{\lpre} \uplus \func{writeSet}{\lpost} \\
        \lpre \bmrg \lpost & \defeq & 
        \begin{funcarray}
            ( \lpre' \bmrg \lpost' ) \sep \lvar \pointsto_{\fp \cup \Set{\wfp}} \dontcare  &  ( \lpre = \lpre' \sep \lvar \pointsto_{\dontcare} \dontcare ) \land  ( \lpost = \lpost' \sep \lvar \pointsto_{\fp \cup \Set{\wfp}} \dontcare ) \\
            \lpre & o.w. \\
        \end{funcarray} \\
        \pred{agree}{\lpre , \lpost} & \defeq & \exists \lpre', \lpost', \lframe, m \ldotp ( \lpre = \lpre \sep \lframe ) \land ( \lpost = \lpost' \sep \lframe)  \land ( m = \lpre' \sep \lpost' \sep \lframe ) \\
        ( \lpre \transfersto \lpost ) \wmrg ( \lpre' \transfersto \lpost' ) & \defeq & \Set{ \lpre \transfersto \lpost } \cup \Set{\lpre \transfersto (\lpost \bmrg \lpost') \middle| \pred{agree}{\lpre , \lpre'} \land \func{writeSet}{\lpost} \cap \func{writeSet}{\lpost'} = \emptyset}
    \end{rclarray}
\]

