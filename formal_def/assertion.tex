\section{Assertion and Rules\label{sec:assertion}}

Before introducing assertion, we extend arithmetic expressions with logical variables, ranging over \( \lvar \).

\[
    \begin{syntax}{\expr}
        \lvar \quad | \quad \dots 
    \end{syntax}
\]

Assume a logical environment \( \lenv \), we extend the evaluation of arithmetic expressions.

\[
\begin{rclarray}
    \eval{\lvar}_{\lenv, \stk} & \defeq & \lenv(\lvar)
\end{rclarray}
\]

\subsection{Local/Transaction}

Local assertions, also transaction assertions, describe the state inside transactions.

\[ 
    \begin{rclarray}
        \lpre , \lpost \in \Localassertion & \defeq & 
        \begin{array}{l}
                  \assfalse \quad                  |
            \quad \asstrue \quad                   |
            \quad \assemp \quad                    |
            %\quad \expr \pt_{\uop} \expr \quad     |
            \quad \expr \pt_{\rop} \expr \quad     |
            \quad \expr \pt_{\wop} \expr \quad     | \\
                  \lpre \sep \lpost \quad          | 
            \quad \lpre \land \lpost \quad         |
            \quad \lpre \lor \lpost \quad          |
            \quad \exists \lvar \ldotp \lpre \quad |
            %\quad \forall \lvar \ldotp \lpre \quad |
            \quad \lpre \implies \lpost
        \end{array}
    \end{rclarray}
\]                                  

The semantics of local assertions, where \( \rs \) and \( \ws \) represent the read and write sets respectively.

\[
    \begin{array}{l c l}
        \lenv, \stk, \hp, \rs, \ws \models_{l} \assfalse & \iff & \texttt{never} \\
        \lenv, \stk, \hp, \rs, \ws \models_{l} \asstrue & \iff & \texttt{always} \\
        \lenv, \stk, \hp, \rs, \ws \models_{l} \assemp & \iff & \hp = \emptyset \land \rs = \emptyset \land \ws = \emptyset \\
        %\lenv, \stk, \hp, \rs, \ws \models_{l} \expr_{1} \pt_{\uop} \expr_{2} & \iff & \hp = \Set{\eval{\expr_{1}}_{\lenv, \stk} \mapsto \eval{\expr_{2}}_{\lenv, \stk}} \land \rs = \emptyset \land \ws = \emptyset \\
        \lenv, \stk, \hp, \rs, \ws \models_{l} \expr_{1} \pt_{\rop} \expr_{2} & \iff & \hp = \Set{\eval{\expr_{1}}_{\lenv, \stk} \mapsto \eval{\expr_{2}}_{\lenv, \stk}} \land \rs \subseteq \Set{\eval{\expr_{1}}_{\lenv, \stk}} \land \ws = \emptyset \\
        \lenv, \stk, \hp, \rs, \ws \models_{l} \expr_{1} \pt_{\wop} \expr_{2} & \iff & \hp = \Set{\eval{\expr_{1}}_{\lenv, \stk} \mapsto \eval{\expr_{2}}_{\lenv, \stk}} \land \rs = \emptyset \land \ws = \Set{\eval{\expr_{1}}_{\lenv, \stk}}  \\
        \lenv, \stk, \hp, \rs, \ws \models_{l} \lpre \sep \lpost & \iff & \exists \hp_{1}, \hp_{2}, \rs_{1}, \rs_{2}, \ws_{1}, \ws_{2} \ldotp \\
                                                                 & & \hp = \hp_{1} \uplus \hp_{2} \land \rs = \rs_{1} \uplus \rs_{2} \land \ws = \ws_{1} \uplus \ws_{2} \land {} \\
                                                                 & &  ( \lenv, \stk, \hp_{1}, \rs_{1}, \ws_{1} \models_{l} \lpre ) \land ( \lenv, \stk, \hp_{2}, \rs_{2}, \ws_{2} \models_{l} \lpost ) \\
        \lenv, \stk, \hp, \rs, \ws \models_{l} \lpre \land \lpost & \iff & ( \lenv, \stk, \hp, \rs, \ws \models_{l} \lpre ) \land ( \lenv, \stk, \hp, \rs, \ws \models_{l} \lpost ) \\
        \lenv, \stk, \hp, \rs, \ws \models_{l} \lpre \lor \lpost & \iff & ( \lenv, \stk, \hp, \rs, \ws \models_{l} \lpre ) \lor ( \lenv, \stk, \hp, \rs, \ws \models_{l} \lpost ) \\
        \lenv, \stk, \hp, \rs, \ws \models_{l} \exists \lvar \ldotp \lpre & \iff & \exists \val \ldotp \lenv\remapsto{\lvar}{\val}, \stk, \hp, \rs, \ws \models_{l} \lpre \\
        \lenv, \stk, \hp, \rs, \ws \models_{l} \lpre \implies \lpost & \iff & ( \lenv, \stk, \hp, \rs, \ws \models_{l} \lpre ) \implies ( \lenv, \stk, \hp, \rs, \ws \models_{l} \lpost ) \\
    \end{array}
\]

The proof rules are standard except \rl{TRDeref} and \rl{TRMutate}.

\[
    \infer[\rl{TRDeref}]{%
        \judgement{}{\var = \dontcare \land \expr_{1} \pt_{\op} \expr_{2} }{ \pderef{\var}{\expr_{1}} }{\var = \expr_{2} \land \expr_{1} \pt_{\op} \expr_{2} }
    }{%
        \expr_{1} \ \texttt{and} \ \expr_{2} \ \texttt{do not contain} \ \var
    }
\]

\[
    \infer[\rl{TRMutate}]{%
        \judgement{}{\expr_{1} \pt_{\op} \dontcare }{ \pmutate{\expr_{1}}{\expr_{2}} }{ \expr_{1} \pt_{\wop} \expr_{1} }
    }{}
\]

\subsection{Global/Program}

How to form a negative assertion?

\[
    \begin{rclarray}
        \gpre , \gpost \in \Globalassertion & \defeq & 
        \begin{array}{l}
                  \assfalse \quad                  |
            \quad \asstrue \quad                   |
            \quad \assemp \quad                    |
            \quad \expr \pointsto \expr \quad      |
            \quad \gpre \sep \gpost \quad          | \\
                  \gpre \land \gpost \quad         |
            \quad \gpre \lor \gpost \quad          |
            \quad \exists \lvar \ldotp \gpre \quad |
            \quad \gpre \implies \gpost
        \end{array}
    \end{rclarray}
\]

The semantics of global assertions.
How to give semantics to a negative assertion?


\[
    \begin{array}{l c l}
        \lenv, \stk, \tshp, \ts \models_{g} \assfalse & \iff & \texttt{never} \\
        \lenv, \stk, \tshp, \ts \models_{g} \asstrue & \iff & \texttt{always} \\
        \lenv, \stk, \tshp, \ts \models_{g} \assemp & \iff & \hp = \emptyset \\
        \lenv, \stk, \tshp, \ts \models_{g} \expr_{1} \pt \expr_{2} & \iff & \dom(\tshp) = \Set{ \loc } \land \tshp(\loc)(\ts') =   \\
                                                             & & \texttt{where} \ \loc = \eval{\expr_{1}}_{\lenv, \stk} \land \val = \eval{\expr_{2}}_{\lenv, \stk} \land \ts' \leq \ts \land {} \\
                                                             & & \tshp(\loc)(\ts') = (\val,\dontcare, \dontcare) \land \forall \ts'' \in ( \ts', \ts) \ldotp \tshp(\loc)(\ts'')\undef \\
        \lenv, \stk, \tshp, \ts \models_{g} \gpre \sep \gpost & \iff & \exists \tshp_{1}, \tshp_{2} \ldotp \tshp = \tshp_{1} \uplus \tshp_{2} \land ( \lenv, \stk, \tshp_{1}, \ts \models_{g} \gpre ) \land ( \lenv, \stk, \tshp_{2}, \ts \models_{g} \gpost ) \\
        \lenv, \stk, \tshp, \ts \models_{g} \gpre \land \gpost & \iff & ( \lenv, \stk, \tshp, \ts  \models_{g} \gpre ) \land ( \lenv, \stk, \tshp, \ts \models_{g} \gpost ) \\
        \lenv, \stk, \tshp, \ts \models_{g} \gpre \lor \gpost & \iff & ( \lenv, \stk, \tshp, \ts  \models_{g} \gpre ) \lor ( \lenv, \stk, \tshp, \ts \models_{g} \gpost ) \\
        \lenv, \stk, \tshp, \ts \models_{g} \exists \lvar \ldotp \lpre & \iff & \exists \val \ldotp \lenv\remapsto{\lvar}{\val}, \stk, \tshp, \ts \models_{g} \gpre \\
        \lenv, \stk, \tshp, \ts \models_{g} \lpre \implies \lpost & \iff & ( \lenv, \stk, \tshp, \ts \models_{l} \gpre ) \implies ( \lenv, \stk, \tshp, \ts \models_{l} \gpost ) 
    \end{array}
\]

Action is pair of local assertions, where the first element cannot contain any write label, \( \dontcare \pt_{\wop} \dontcare \).

\[
    \begin{rclarray}
        \action \in \Action & \defeq & \Set{ \lpre \transfersto \lpost \ \middle| \ \lpre , \lpost \in \Localassertion \land \lpre \ \texttt{has no write tag} } \\
        \eval{\lpre \transfersto \lpost }_{\lenv, \stk} & \defeq & \Set{(\hp, \hp') \middle| 
        \begin{array}{@{}l@{}}
            \exists \rs, \ws_{1}, \ws_{2} \ldotp \lenv, \stk, \hp, \rs, \ws_{1} \models_{l} \lpre \land {} \\
            \lenv, \stk, \hp, \rs, \ws_{2} \models_{l}\lpost \land \ws_{1}  = \emptyset \land \ws_{2} \subseteq \rs
        \end{array}} 
    \end{rclarray}
\]


%Rule, \( \efsep \) will propagate write to read assertions.

\[
    \infer[\rl{PRCommit}]{%
        \judgement{\rely, \grte}{\gpre}{ \ptrans{\cmd} }{\gpost}
    }{%
        \begin{array}{l}
            \gpre \overset{\texttt{tag} \ r}{\implies} \lpre \quad 
            \judgement{}{\lpre}{\cmd}{\lpost} \quad 
            ( \lpre \transfersto \lpost ) \in \close{\grte} \\
            \mergable{\rely}{\lpre}{\lpost}{\lpost'} \quad 
            \stable{\rely}{\lpost'} \quad 
            \lpost' \overset{\texttt{notag}}{\implies} \gpost \quad
        \end{array}
    }
\]

\[
    \infer[\rl{PRPar}]{%
        \judgement{\rely, \grte_{1} \cup \grte_{2}}{\gpre_{1} \sep \gpre_{2}}{ \prog_{1} \ppar \prog_{2} }{\gpost_{1} \sep \gpost_{2}}
    }{%
        \begin{array}{l}
            \judgement{\rely \cup \grte_{2}, \grte_{1}}{\gpre_{1}}{ \prog_{1} }{\gpost_{1}} \quad 
            \judgement{\rely \cup \grte_{1}, \grte_{2}}{\gpre_{2}}{ \prog_{2} }{\gpost_{2}}  \\
            \stable{\rely \cup \grte_{2}}{\gpre_{1}} \quad
            \stable{\rely \cup \grte_{1}}{\gpre_{2}} 
        \end{array}
    }
\]
