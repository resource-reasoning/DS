\section{Assertion and Rules\label{sec:assertion}}

\subsection{Local/Transaction}

\begin{definition}[capabilities]
\label{def:capabilities}
Assume a partial commutative monoid for \emph{primitive capabilities} $(\Kaps, \composeK, \unitK)$ with $\kap \in \Kaps$.
Assume a countably infinite set of region identifiers $\rid \in \RegionID$. The set of \emph{capabilities} is $\ca \in \Caps \eqdef \RegionID \rightharpoonup \Kaps$.
The \emph{capability composition function}, $\composeC: \Caps \times \Caps \rightharpoonup \Caps$, is defined as follows:
%
\[
    \begin{rclarray}
	(\ca_1 \composeC \ca_2)(\rid) & \defeq  &
	\begin{cases}
		\ca_1(\rid) \composeK \ca_2(\rid) & \text{if } \rid \in \dom(\ca_1) \text{ and } \rid \in \dom(\ca_2) \\
		\ca_1(\rid) & \text{if } \rid \in \dom(\ca_1) \text{ and } \rid \not\in \dom(\ca_2) \\
		\ca_2(\rid) & \text{if } \rid \not\in \dom(\ca_1) \text{ and } \rid \in \dom(\ca_2) \\
		\text{undefined} & \text{otherwise}
	\end{cases}
    \end{rclarray}
\]
%
The \emph{capability unit element}, $\unitC$, denotes a function with an empty domain.
The \emph{capability partial commutative monoid} is $(\Caps, \composeC, \unitC)$. 
\end{definition}
 
\begin{definition}[Local state]
\label{def:local_state}
Given the set of fingerprint heaps $\FPHeaps$ (\defin\ref{def:fingerprint_heaps}) and the set of capabilities $\Caps$ (\defin\ref{def:capabilities}), the set of \emph{local states} is $\ls \in \LStates \eqdef \FPHeaps \times \Caps$.
The \emph{local state composition function}, $\composeLS: \LStates \times \LStates \parfun \LStates$, is defined component-wise as: $\composeLS \eqdef (\composeFP, \composeC)$.
The \emph{local state unit element} is $\unitLS \eqdef (\unitFP, \unitC)$.
The \emph{partial commutative monoid of local states} is $(\LStates, \composeLS, \unitLS)$.
\end{definition}
 
Given a local state $\ls$, we write $\lsFPH{\ls}$ and $\lsCAP{\ls}$ for the first and second projections of $\ls$, respectively.
 
\begin{definition}[Logical Expressions]
\label{def:logical-expr}
Assume a countably infinite set of \emph{logical variables} $\V x \in \LVar$.
The set of \emph{logical expressions}, $ \lexpr \in \LExpr$ is defined by the following inductive grammar, where $\val \in \Val$, $\vx \in \Var$ (\defin\ref{def:prgram_values}) and $\V x \in \LVar$:
%
\[
\begin{rclarray}
   \lexpr & ::= & \val \mid \var \mid \lvar \mid \lexpr + \lexpr \mid \lexpr * \lexpr \mid \dots 
\end{rclarray}
\]
Given the set of values $\Val$ (\defin\ref{def:prgram_values}), assume a set of \emph{logical environments} $\lenv \in \LEnv: \LVar \parfun \Val$.
Given a stack $\stk \in \Stack$ (\defin\ref{def:stacks}) and a logical environment $\lenv: \LEnv$, the \emph{logical expression evaluation} function, $\evalLE[(., .)]{.}:\LExpr \times \Stack \times \LEnv\rightharpoonup \Val$, is defined inductively over the structure of logical expressions as follows: 
%
\[
    \begin{rclarray}
        \evalLE{\val} & \defeq & \val \\
        \evalLE{\var} & \defeq & \stk(\var) \\
        \evalLE{\lvar} & \defeq & \lenv(\lvar) \\
        \evalLE{\lexpr_1 + \lexpr_2} & \defeq & \evalLE{\lexpr_1} + \evalLE{\lexpr_2}   \\
        \evalLE{\lexpr_1 * \lexpr_2} & \defeq & \evalLE{\lexpr_1} * \evalLE{\lexpr_2}  
    \end{rclarray}
\]
\end{definition}

\begin{definition}[Local assertions]
\label{def:local_assertions}
Given the set of logical expressions \( \LExpr \) (\defin\ref{def:logical-expr}), the set of \emph{local assertions}, $\lpre,  \lpost \in \LAst$, is defined inductively by the following grammar, where $\fp \in \Fingerprint$ denotes a fingerprint (\defin\ref{def:fingerprint_heaps}) and $\lvar, \lrid \in \LVar$: 
%
\[
\begin{rclarray}
	\lpre, \lpost  & ::= & \False \mid \True \mid \lpre \land \lpost \mid \lpre \lor \lpost \mid \exsts{\lvar} \lpre \mid \Emp \mid \lexpr \fpt{\fp} \lexpr \mid \cass{\kap}{\lrid} \mid \lpre \sep \lpost 
\end{rclarray}	 
\]
%
Given a logical environment $\lenv \in \LEnv$, the \emph{local interpretation function}, $\evalLC[(.,.)]{.}: \LAst \times \LEnv \rightarrow \powerset{\LStates}$, is defined over the structure of local assertions as follows:
%
\[
\begin{rclarray}
	\evalLC{\assfalse} & \eqdef & \emptyset  \\
	\evalLC{\asstrue} & \defeq & \LStates  \\
	\evalLC{\lpre \land \lpost} & \defeq & \evalLC{\lpre} \cap \evalLC{\lpost} \\
	\evalLC{\lpre \lor \lpost} & \defeq & \evalLC{\lpre} \cup \evalLC{\lpost} \\
	\evalLC{\exsts{\lvar} \lpre} & \defeq & \bigcup\limits_{\val \in \textnormal{\Val}}\evalLC[\lenv\remapsto{\lvar}{\val}, \stk]{\lpre}  \\
	\evalLC{\assemp} & \defeq & \Set{\unitLS}  \\
	\evalLC{\lexpr_1 \fpt{\fp} \lexpr_2} & \defeq & 
    \Setcon{
		(\fph, \unitC) 
    }{
	   \exsts{\addr = \evalLE{\lexpr_1}, \val = \evalLE{\lexpr_2}} 
	   \fph {=} \Set{\addr \mapsto (\val, \fp) }
	} \\
%
	\evalLC{\cass{\kap}{\lrid}} & \eqdef & 
    \Setcon{
		(\unitFP, \ca) 
    }{
	   \exsts{\rid = \evalLE{\lrid}} 
       \ca = \Set{\rid \mapsto \kap } 
	} \\
	\evalLC{\lpre \sep \lpost} & \defeq & 
    \Setcon{ \ls_1 \composeLS \ls_2 }{ \ls_1 \in \evalLC{\lpre} \land \ls_2 \in \evalLC{\lpost} } 
\end{rclarray}
\]
\end{definition}

Observe that program expressions ($\expr \in \Expr$ in \defin\ref{def:language}) are contained in logical expressions ($\lexpr \in \LExpr$ in \defin\ref{def:local_assertions} above). That is, $\Expr \subset \LExpr$. 



\subsection{Global/Program}
\begin{definition}[Actions]
\label{def:action}
Given the set of local states $\LStates$ (\defin\ref{def:local_state}), the set of \emph{actions}, $\action \in \Actions$, is defined as follows:
%
\[
\begin{rclarray}
	\Actions & \eqdef  &
	\Setcon{
		((\fph, \ca), (\fph', \ca'))
	}{
		((\fph, \ca), (\fph', \ca')) \in \LStates \times \LStates \land \dom(\fph) = \dom(\fph') \land {} \\
        \for{\loc} \fph(\loc) = (\val, \fp) \implies ( \fp = \emptyset \land (\fpW \in \fphFP[\fph'](\addr) \lor \fph'(\loc) = (\val, \Set{\fpR}) ) )
	}
\end{rclarray}
\] 
Given the set of primitive capabilities $\Kaps$ (\defin\ref{def:capabilities}), the set of \emph{interference environments} is $\inter \in \Interference \eqdef \Kaps \parfun \powerset{\Actions}$.
\end{definition}
\sx{ The pre-condition must be empty set.  }
\sx{Ignore the name clash for now}

\begin{definition}[Logical states]
\label{def:logical_states}
Assume a partial commutative monoid of (plain) heaps \( (\PHeap, \composeH, \unitH) \), where \(\PHeap \defeq \Loc \parfinfun \Val \), \( \composeH \defeq \uplus \) and \( \unitH \defeq \emptyset \).
Then given the partial commutative monoid of capabilities ($\Caps$, \composeC, \unitC) in \defin\ref{def:capabilities}, the set of \emph{logical states} is: \(\lgs \in \LGStates \eqdef \PHeap \times \Caps\).
The \emph{logical state composition function}, $\composeLGS: \LGStates \times \LGStates \parfun \LGStates$, is defined component-wise as: $\composeLGS \eqdef (\composeH, \composeC)$.
The \emph{logical state unit element} is $\unitLGS \eqdef (\unitH, \unitC)$.
The \emph{partial commutative monoid of logical states} is $(\LGStates, \composeLGS, \unitLGS)$.
\end{definition}

\begin{definition}[Worlds]
\label{def:world}
Given the set of region identifiers $\RegionID$ (\defin\ref{def:capabilities}) and the partial commutative monoid of logical states $(\LGStates, \composeLGS, \unitLGS)$ (\defin\ref{def:logical_states}), the set of \emph{shared states} is $\SStates \eqdef \RegionID \parfinfun \LGStates$.
The \emph{shared state composition function}, $\composeS: \SStates \times \SStates \parfun \SStates$, is defined as: $\composeS \eqdef \composeEq$, where for all domains $\sort M$ and all $m, m' \in \sort M$: 
%
\[
\begin{rclarray}
	m \composeEq m' &  \eqdef  &
	\begin{cases}
		m & \text{if } m = m'\\
		\text{undefined} & \text{otherwise}
	\end{cases}
\end{rclarray}
\]
%
The \emph{flattening} function for worlds, $\flattenW{.}: \World \parfun \LGStates$, is defined as follows, for all $\lgs \in \LGStates$ and $\gs \in \SStates$:
%
\[
\begin{rclarray}
	\flattenS{(\lgs, \gs)}  & \eqdef & \lgs \composeLGS \prod\limits_{\rid \in \dom(\gs)}^{\composeLGS} \gs(\rid)
\end{rclarray}
\]
%
Given the set of timestamps $\Timestamp$ (\defin\ref{def:timestamp_heaps}), 
a triple $(\lgs, \gs, \ts) \in \LGStates \times \SStates \times \Timestamp$ is \emph{well-formed}, written $\wf{\lgs, \gs}$:
%
\[
\begin{rclarray}
	\wf{\lgs, \gs} & \defeq & \exsts{\php, \ca}\flattenS{(\lgs, \gs)} {=} (\php, \ca) \land\ \dom(\ca) \subseteq \dom(\gs) \\
\end{rclarray}
\]
%
\azalea{Shale, check  the last condition of $\wf{.}$ with regards to the timestamps.}
\sx{  Here is my understanding.
The first line says a world that is able to collapse down to a TSheap and a time, which is the most important part for proving soundness.
The second line means all capabilities must have existed corresponding regions, which is similar to all other logics.
The third line I think says a location must at least be initialised?
Since we don't have allocation and we make assumption all resources initialised, but I think it is fine we still make this constrains?
}
%
The set of \emph{worlds}, $\world \in \World$, is defined as follows:
%
\[
\begin{rclarray}
	\world \in \World  & \eqdef  & \Setcon{(\lgs, \gs)}{(\lgs, \gs) \in \LGStates \times \SStates \land \wf{\lgs, \gs}}
\end{rclarray}
\]
% 
The \emph{world composition function}, $\composeW: \World \times \World \parfun \World$, is defined component-wise as: $\composeW \eqdef (\composeH, \composeS)$.
The \emph{world unit set} is $\unitW \eqdef \Setcon{(\unitH, \gs)}{(\unitH, \gs) \in \World}$.
The \emph{partial commutative monoid of worlds} is $(\World, \composeW, \unitW)$.
\end{definition}
 
\begin{defn}[Interference]
\label{def:intf}
The set of \emph{interference assertions}, \( \intass \in \IAst \), are defined by the following grammar:
\[
\begin{rclarray}
	\intass & \eqdef  &
	\emptyset \mid \Set{ \perm{\kap} : \exsts{\vec{\lvar}} \lpre \transfersto \lpost } \cup \intass 
\end{rclarray}
\]
Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stack$, the \emph{interference interpretation} function, $\evalI[(., .)]{.}: \IAst \times \LEnv \times \Stack \parfun \Interference$, is defined as follows, for all $\kap \in \Kaps$:
%
\[
\begin{rclarray}
	\evalI{\emptyset}(\kap) & \eqdef & \emptyset \\
	\evalI{\Set{ \perm{\kap} : \exsts{\vec{\lvar}} \lpre \transfersto \lpost } \cup \intass }(\kap) & \eqdef &
	\Setcon{
		(\ls_\lpre, \ls_\lpost)	 
    }{
		(\ls_\lpre, \ls_\lpost)	\in \Actions \land \exsts{\rid, \vec{v}, \lenv'} \land \lenv' = \lenv \remapsto{\vec{\lvar}}{\vec v} \land {} \\
			\ls_\lpre \in \evalLC[\lenv', \stk]{\lpre} \land \ls_\lpost \in \evalLC[\lenv', \stk]{\lpost}
	}
	\cup 
	\evalI{\intass}(\kap)
\end{rclarray}
\] 
\end{defn}

\begin{definition}[Assertions]
The set of \emph{assertions}, $\gpre, \gpost \in \Ast$, are defined by the following inductive grammar:
\[
\begin{rclarray}
	\gpre , \gpost & \defeq & \False \mid \True \mid \gpre \land \gpost \mid \gpre \lor \gpost  \mid \exsts{\lvar}\gpre \mid \Emp \mid \lexpr_1 \pointsto \lexpr_2 \mid \cass{\kap}{\lrid} \mid \boxass{\gpre}{\lrid}{\intass} \mid \gpre \sep \gpost \\
\end{rclarray}
\]
%
where $\lvar, \lrid \in \LVar$, $\lexpr_1, \lexpr_2 \in \LExpr$ (\defin\ref{def:local_assertions}), $\kap \in \Kaps$ (\defin\ref{def:capabilities}) and $\intass \in \IAst$ (\defin\ref{def:intf}).
Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stack$, the \emph{assertion interpretation} function, $\evalW[(., .)]{.}: \Ast \times \LEnv \times \Stack \rightarrow \World$, is defined as follows:
%
\[
\begin{rclarray}
	\evalW{\False} & \defeq & \emptyset \\
	\evalW{\True} & \defeq & \World \\
	\evalW{\emp} & \defeq & \unitW \\
	\evalW{\gpre \land \gpost} & \defeq & \evalW{\gpre} \cap \evalW{\gpost} \\
	\evalW{\gpre \lor \gpost} & \defeq & \evalW{\gpre} \cup \evalW{\gpost} \\
	\evalW{\exsts{\lvar}  \gpre} & \defeq 
	& \bigcup\limits_{\val \in \textnormal{\Val}} \evalW[\lenv\remapsto{\lvar}{\val}, \stk]{\gpre} \\
	\evalW{\lexpr_1 \pt \lexpr_2} & \defeq & 
    \Setcon{
		((\php, \unitC), \gs) 
    }{
		\php = \Set{\evalLE{\lexpr_1} \mapsto \evalLE{\lexpr_2} } \land \gs \in \SStates
	} \\
	\evalW{\cass{\kap}{\lrid}} & \defeq & 
    \Setcon{
		((\unitH, \ca), \gs) 
    }{
		\exsts{\rid = \lenv(\lrid)}  \ca = \Set{\rid \mapsto \kap }
	} \\
	\evalW{\boxass{\gpre}{\lrid}{\intass}} & \defeq &
    \Setcon{
		(\unitLGS, \gs) 
    }{
        \exsts{\rid, \lgs} \lenv(\lrid) = \rid \land \gs(\rid) = (\lgs, \evalI{I})\land (\lgs, \gs) \in \evalAUX{P} 
	} \\
	\evalW{ \gpre \sep \gpost } & \defeq & 
	\Setcon{
	   (\world_1 \composeW \world_2) 
    }{
       \world_1 \in \evalW{\gpre} \land \world_2 \in \evalW{\gpost}
	}   
\end{rclarray}
\]
%
with the \emph{auxiliary interpretation function}, $\evalAUX[(., .)]{.}: \Ast \times \LEnv \times \Stack \times \to \powerset{\LGStates \times \SStates}$, defined as follows:
%
\[
\begin{rclarray}
	\evalAUX{\False} & \defeq & \emptyset \\
	\evalAUX{\True} & \defeq & \LGStates \times \SStates  \\
	\evalAUX{\emp} & \defeq & \Setcon{(\unitLGS, \gs)  }{ \gs \in \SStates} \\
	\evalAUX{\gpre \land \gpost} & \defeq & \evalAUX{\gpre} \cap \evalAUX{\gpost} \\
	\evalAUX{\gpre \lor \gpost} & \defeq & \evalAUX{\gpre} \cup \evalAUX{\gpost} \\
	\evalAUX{\exsts{\lvar} \gpre} & \defeq & \bigcup\limits_{\val \in \textnormal{\Val}} \evalAUX[\lenv\remapsto{\lvar}{\val}, \stk]{\gpre} \\
	\evalAUX{\lexpr_1 \pt \lexpr_2} & \defeq &
    \Setcon{
		((\php, \unitC), \gs) 
    }{
       \php = \Set{\eval{\lexpr_1}{\lenv, \stk} \mapsto \eval{\lexpr_1}{\lenv, \stk} } \land \gs \in \SStates
	} \\
	\evalAUX{\cass{\kap}{\lrid}} & \defeq & 
    \Setcon{
		((\unitH, \ca), \gs) 
    }{
	   \exsts{\rid = \lenv(\lrid)}  \ca = \Set{\rid \mapsto \kap }
	} \\
	\evalAUX{\boxass{\gpre}{\lrid}{\intass}} & \defeq & 
    \Setcon{
		(\lgs, \gs) 
    }{
		(\lgs, \gs) \in \evalW{\boxass{\gpre}{\lrid}{\intass}}
	}\\
	\evalAUX{ \gpre \sep \gpost } & \defeq & 
	\Setcon{
		((\lgs_1 \composeLGS \lgs_2), (\gs_1 \composeS \gs_2)) 
    }{
		(\lgs_1, \gs_1) \in \evalAUX{\gpre} \land (\lgs_2, \gs_2) \in \evalAUX{\gpost}
	}   
\end{rclarray}
\]
\end{definition}
