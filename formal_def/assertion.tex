\section{Assertion and Rules\label{sec:assertion}}

\subsection{Local/Transaction}

\begin{definition}[capabilities]
\label{def:capabilities}
Assume a partial commutative monoid for \emph{primitive capabilities} $(\Kaps, \composeK, \unitK)$ with $\kap \in \Kaps$.
Assume a countably infinite set of region identifiers $\rid \in \RegionID$. The set of \emph{capabilities} is $\ca \in \Caps \eqdef \RegionID \rightharpoonup \Kaps$.
The \emph{capability composition function}, $\composeC: \Caps \times \Caps \rightharpoonup \Caps$, is defined as follows:
%
\[
    \begin{rclarray}
	(\ca_1 \composeC \ca_2)(\rid) & \defeq  &
	\begin{cases}
		\ca_1(\rid) \composeK \ca_2(\rid) & \text{if } \rid \in \dom(\ca_1) \text{ and } \rid \in \dom(\ca_2) \\
		\ca_1(\rid) & \text{if } \rid \in \dom(\ca_1) \text{ and } \rid \not\in \dom(\ca_2) \\
		\ca_2(\rid) & \text{if } \rid \not\in \dom(\ca_1) \text{ and } \rid \in \dom(\ca_2) \\
		\text{undefined} & \text{otherwise}
	\end{cases}
    \end{rclarray}
\]
%
The \emph{capability unit element}, $\unitC$, denotes a function with an empty domain.
The \emph{capability partial commutative monoid} is $(\Caps, \composeC, \{\unitC\})$. 
\end{definition}
 
\begin{definition}[Local state]
\label{def:local_state}
Given the partial commutative monoids of fingerprint heaps $(\FPHeaps, \composeFP, \{\unitFP\})$ in \defin\ref{def:fingerprint_heaps} and capabilities $(\Caps, \composeC, \{\unitC\})$ in \defin\ref{def:capabilities}, the set of \emph{local states} is $\ls \in \LStates \eqdef \FPHeaps \times \Caps$.
The \emph{local state composition function}, $\composeLS: \LStates \times \LStates \parfun \LStates$, is defined component-wise as: $\composeLS \eqdef (\composeFP, \composeC)$.
The \emph{local state unit element} is $\unitLS \eqdef (\unitFP, \unitC)$.
The \emph{partial commutative monoid of local states} is $(\LStates, \composeLS, \{\unitLS\})$.
\end{definition}
 
Given a local state $\ls$, we write $\lsFPH{\ls}$ and $\lsCAP{\ls}$ for the first and second projections of $\ls$, respectively.
 
\begin{definition}[Logical Expressions]
\label{def:logical-expr}
Assume a countably infinite set of \emph{logical variables} $\V x \in \LVar$.
The set of \emph{logical expressions}, $ \lexpr \in \LExpr$ is defined by the following inductive grammar, where $\val \in \Val$, $\vx \in \Var$ (\defin\ref{def:prgram_values}) and $\V x \in \LVar$:
%
\[
\begin{rclarray}
   \lexpr & ::= & \val \mid \var \mid \lvar \mid \lexpr + \lexpr \mid \lexpr * \lexpr \mid \dots 
\end{rclarray}
\]
Given the set of values $\Val$ (\defin\ref{def:prgram_values}), assume a set of \emph{logical environments} $\lenv \in \LEnv: \LVar \parfun \Val$.
Given a stack $\stk \in \Stack$ (\defin\ref{def:stacks}) and a logical environment $\lenv: \LEnv$, the \emph{logical expression evaluation} function, $\evalLE[(., .)]{.}:\LExpr \times \Stack \times \LEnv\rightharpoonup \Val$, is defined inductively over the structure of logical expressions as follows: 
%
\[
    \begin{rclarray}
        \evalLE{\val} & \defeq & \val \\
        \evalLE{\var} & \defeq & \stk(\var) \\
        \evalLE{\lvar} & \defeq & \lenv(\lvar) \\
        \evalLE{\lexpr_1 + \lexpr_2} & \defeq & \evalLE{\lexpr_1} + \evalLE{\lexpr_2}   \\
        \evalLE{\lexpr_1 * \lexpr_2} & \defeq & \evalLE{\lexpr_1} * \evalLE{\lexpr_2}  
    \end{rclarray}
\]
\end{definition}

\begin{definition}[Local assertions]
\label{def:local_assertions}
Given the set of logical expressions \( \LExpr \) (\defin\ref{def:logical-expr}), the set of \emph{local assertions}, $\lpre,  \lpost \in \LAst$, is defined inductively by the following grammar, where $\fp \in \Fingerprint$ denotes a fingerprint (\defin\ref{def:fingerprint_heaps}) and $\lvar, \lrid \in \LVar$: 
%
\[
\begin{rclarray}
	\lpre, \lpost  & ::= & \False \mid \True \mid \lpre \land \lpost \mid \lpre \lor \lpost \mid \exsts{\lvar} \lpre \mid \Emp \mid \lexpr \fpt{\fp} \lexpr \mid \cass{\kap}{\lrid} \mid \lpre \sep \lpost 
\end{rclarray}	 
\]
%
Given a logical environment $\lenv \in \LEnv$, the \emph{local interpretation function}, $\evalLS[(.,.)]{.}: \LAst \times \LEnv \rightarrow \powerset{\LStates}$, is defined over the structure of local assertions as follows:
%
\[
\begin{rclarray}
	\evalLS{\assfalse} & \eqdef & \emptyset  \\
	\evalLS{\asstrue} & \defeq & \LStates  \\
	\evalLS{\lpre \land \lpost} & \defeq & \evalLS{\lpre} \cap \evalLS{\lpost} \\
	\evalLS{\lpre \lor \lpost} & \defeq & \evalLS{\lpre} \cup \evalLS{\lpost} \\
	\evalLS{\exsts{\lvar} \lpre} & \defeq & \bigcup\limits_{\val \in \textnormal{\Val}}\evalLS[\lenv\remapsto{\lvar}{\val}, \stk]{\lpre}  \\
	\evalLS{\assemp} & \defeq & \Set{\unitLS}  \\
	\evalLS{\lexpr_1 \fpt{\fp} \lexpr_2} & \defeq & 
    \Setcon{
		(\fph, \unitC) 
    }{
	   \exsts{\addr = \evalLE{\lexpr_1}, \val = \evalLE{\lexpr_2}} 
	   \fph {=} \Set{\addr \mapsto (\val, \fp) }
	} \\
%
	\evalLS{\cass{\kap}{\lrid}} & \eqdef & 
    \Setcon{
		(\unitFP, \ca) 
    }{
	   \exsts{\rid = \evalLE{\lrid}} 
       \ca = \Set{\rid \mapsto \kap } 
	} \\
	\evalLS{\lpre \sep \lpost} & \defeq & 
    \Setcon{ \ls_1 \composeLS \ls_2 }{ \ls_1 \in \evalLS{\lpre} \land \ls_2 \in \evalLS{\lpost} } 
\end{rclarray}
\]
\end{definition}

Observe that program expressions ($\expr \in \Expr$ in \defin\ref{def:language}) are contained in logical expressions ($\lexpr \in \LExpr$ in \defin\ref{def:local_assertions} above). That is, $\Expr \subset \LExpr$. 



\subsection{Global/Program}
\begin{definition}[Actions]
\label{def:action}
Given the set of local states $\LStates$ (\defin\ref{def:local_state}), the set of \emph{actions}, $\action \in \Actions$, is defined as follows:
%
\[
    \begin{rclarray}
	\Actions & \eqdef &
	\Setcon{
		((\fph, \ca), (\fph', \ca'))
	}{
		((\fph, \ca), (\fph', \ca')) \in \LStates \times \LStates \land \orth{(\fph, \ca)} = \orth{(\fph', \ca')}\\
		%\land\ \dom(\fph) = \dom(\fph') \\
		\land\ \for{\loc} \fph(\loc) = (\val, \fp) \implies \\
			\quad 	\big(\fph'(\loc) = (-, \fp') \land \addFPW{\fp} \subseteq  \fp' \big)
			\lor
			\big(\fph'(\loc) = (\val, \fp') \land \fp' = \addFPR{\fp} \big)
	}
    \end{rclarray}
\] 
where, the \emph{orthogonal} \(\orth{(.)} : \LStates \to \powerset{\LStates} \) is defined as follows:
\[
    \begin{rclarray}
    \orth{\ls} & \eqdef & \Setcon{\ls'}{\ls \composeLS \ls' \isdef} \\
    \end{rclarray}
\]
Given the set of primitive capabilities $\Kaps$ (\defin\ref{def:capabilities}), the set of \emph{interference environments} is $\inter \in \Interference \eqdef \Kaps \parfun \powerset{\Actions}$.
\end{definition}
%\sx{ The pre-condition must be empty set.  }
%\azalea{No shale! The precondition fingerprint need not necessarily be empty. You want to be able to chain these actions together and potentially apply many of these actions in succession. That is, we want to write actions in a general form, e.g.
%%
%\begin{align*}
	%& \vx \pt_{f} 1 * \vy \pt_{f'} 2 \transfersto \vx \pt_{\addFPR f} 1 * \vy \pt_{\addFPW{f'}} 3 \\
	%& \vx \pt_{f} 1  \transfersto \vx \pt_{\addFPW f} 2
%\end{align*}
%%
%Then using action chaining, we want to start from $\pt_{\emptyset} 1 * \vy \pt_{\emptyset} 2$ and get to $\pt_{\{\fpR, \fpW\}} 2 * \vy \pt_{\fpW} 3$.\\

%Indeed you need to ensure that in an atomic [.] section, you start with an empty fingerprint. But this can be enforced in the definition of repartitioning. That is, when you convert a heap to a fingerprint heap in repartitioning, you give it an empty fingerprint.

%So I suggest you revert the definition of actions to what we had before:
%\[
	%\Actions \eqdef 
	%\myset{
		%((\fph, \ca), (\fph', \ca'))
	%}{
		%((\fph, \ca), (\fph', \ca')) \in \LStates \times \LStates \\
		%\land\ \dom(\fph) = \dom(\fph') \\
		%\land\ \for{\loc} \fph(\loc) = (\val, \fp) \implies \\
			%\quad 	\big(\fph'(\loc) = (-, \fp') \land \addFPW{\fp} \subseteq  \fp' \big)
			%\lor
			%\big(\fph'(\loc) = (\val, \fp') \land \fp' = \addFPR{\fp} \big)
	%}
%\] 
%}
%\sx{ \( \addFPW{\fp} \subseteq  \fp' \) to be more precise as \( \fp = \emptyset\) and \(\fp' = \Set{\fpR, \fpW} \) to be more precise.
%I want to wait until we agree on the merge and repartition and make decision here. }

\begin{definition}[Logical states]
\label{def:logical_states}
Given the partial commutative monoids of heaps \( (\PHeap, \composeH, \{\unitH\}) \) in \defin\ref{def:heaps} and capabilities $(\Caps, \composeC, \{\unitC\})$ in \defin\ref{def:capabilities}, the set of \emph{logical states} is: \(\lgs \in \LGStates \eqdef \PHeap \times \Caps\).
The \emph{logical state composition function}, $\composeLGS: \LGStates \times \LGStates \parfun \LGStates$, is defined component-wise as: $\composeLGS \eqdef (\composeH, \composeC)$.
The \emph{logical state unit element} is $\unitLGS \eqdef (\unitH, \unitC)$.
The \emph{partial commutative monoid of logical states} is $(\LGStates, \composeLGS,\{\unitLGS\})$.
\end{definition}

\begin{definition}[Worlds]
\label{def:world}
Given the set of region identifiers $\RegionID$ (\defin\ref{def:capabilities}) and the partial commutative monoid of logical states $(\LGStates, \composeLGS, \{\unitLGS\})$ in \defin\ref{def:logical_states}, the set of \emph{shared states} is $\SStates \eqdef \RegionID \parfinfun \LGStates \times \Interference$.
The \emph{shared state composition function}, $\composeS: \SStates \times \SStates \parfun \SStates$, is defined as: $\composeS \eqdef \composeEq$, where for all domains $\sort M$ and all $m, m' \in \sort M$: 
%
\[
\begin{rclarray}
	m \composeEq m' &  \eqdef  &
	\begin{cases}
		m & \text{if } m = m'\\
		\text{undefined} & \text{otherwise}
	\end{cases}
\end{rclarray}
\]
%
The \emph{flattening} function for worlds, $\flattenW{.}: \World \parfun \LGStates$, is defined as follows, for all $\lgs \in \LGStates$ and $\gs \in \SStates$:
%
\[
\begin{rclarray}
	\flattenW{(\lgs, \gs)}  & \eqdef & \lgs \composeLGS \prod\limits_{\rid \in \dom(\gs)}^{\composeLGS} \gs(\rid)\downarrow_1
\end{rclarray}
\]
%
A pair $(\lgs, \gs) \in \LGStates \times \SStates$ is \emph{well-formed}, written $\wfW{\lgs, \gs}$:
%
\[
\begin{rclarray}
	\wfW{\lgs, \gs} & \defeq & \exsts{\php, \ca}\flattenW{(\lgs, \gs)} {=} (\php, \ca) \land\ \dom(\ca) \subseteq \dom(\gs) \\
\end{rclarray}
\]
%
The set of \emph{worlds}, $\world \in \World$, is defined as follows:
%
\[
\begin{rclarray}
	\world \in \World  & \eqdef  
	& \myset{
		(\lgs, \gs)
	}{
		(\lgs, \gs) \in \LGStates \times \SStates \land \wfW{\lgs, \gs}
	}
\end{rclarray}
\]
% 
The \emph{world composition function}, $\composeW: \World \times \World \parfun \World$, is defined component-wise as: $\composeW \eqdef (\composeH, \composeS)$.
The \emph{world unit set} is $\unitW \eqdef \Setcon{(\unitH, \gs)}{(\unitH, \gs) \in \World}$.
The \emph{partial commutative monoid of worlds} is $(\World, \composeW, \unitW)$.
\end{definition}
 
\begin{defn}[Interference]
\label{def:intf}
The set of \emph{interference assertions}, \( \intass \in \IAst \), are defined by the following grammar:
\[
\begin{rclarray}
	\intass & \eqdef  &
	\emptyset \mid \Set{ \perm{\kap} : \exsts{\vec{\lvar}} \lpre \transfersto \lpost } \cup \intass 
\end{rclarray}
\]
Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stack$, the \emph{interference interpretation} function, $\evalI[(., .)]{.}: \IAst \times \LEnv \times \Stack \parfun \Interference$, is defined as follows, for all $\kap \in \Kaps$:
%
\[
\begin{rclarray}
	\evalI{\emptyset}(\kap) & \eqdef & \emptyset \\
	\evalI{\Set{ \perm{\kap} : \exsts{\vec{\lvar}} \lpre \transfersto \lpost } \cup \intass }(\kap) & \eqdef &
	\Setcon{
		(\ls_\lpre, \ls_\lpost)	 
    }{
		(\ls_\lpre, \ls_\lpost)	\in \Actions \land \exsts{\rid, \vec{v}, \lenv'} \land \lenv' = \lenv \remapsto{\vec{\lvar}}{\vec v} \land {} \\
			\ls_\lpre \in \evalLS[\lenv', \stk]{\lpre} \land \ls_\lpost \in \evalLS[\lenv', \stk]{\lpost}
	}
	\cup 
	\evalI{\intass}(\kap)
\end{rclarray}
\] 
\end{defn}

\begin{defn}[Transitions interference]
    \label{def:intf-for-trans}  
    Given an interference environment \( \intf \in \Interference \) (\defin \ref{def:action}), the \emph{transitions interference}, \( (.)^{[]} : \Interference \to \Interference \), is defined by closing and filter it.
    \[
        \begin{rclarray}
            \intf^{[]} & \defeq & \pred{filter\_inter}{ \closure{\intf} } \\
        \end{rclarray}
        \
    \]
    The \emph{closure of interference environment}, \(  \closure{(.)} : \Interference \to \Interference \) is defined as follows:
    \[
        \begin{rclarray}
            \closure{\intf} & \defeq & \bigcup\limits_{\nat \in \Nat} \intf_{\nat} \\
        \end{rclarray}
    \]
    where,
    \[
        \begin{rclarray}
            \intf_0 & \defeq & \intf \\
            \intf_{\nat + 1}(\kap_{l} \composeK \kap_{r}) & \defeq & 
            \Setcon{%
                (\ls_{l}^{p} \composeLS \ls_{l}^{f}, \ls_{r}^{q} \composeLS \ls_{r}^{f})
            }{%
                \for{ \ls_{l}^{q}, \ls_{r}^{p} } 
                \ls_{l}^{q} \composeLS \ls_{l}^{f} = \ls_{r}^{p} \composeLS \ls_{r}^{f} \land 
                (\ls_{l}^{p}, \ls_{l}^{q}) \in \intf_{\nat}(\kap_{l}) \land 
                (\ls_{r}^{p}, \ls_{r}^{q}) \in \intf_{\nat}(\kap_{r}) \\
            }\\
        \end{rclarray}
    \]
    The \emph{filter of interference environment} function \( \predn{filter\_inter}: \Interference \to \Interference \), for filtering out transitions that do not starts with empty fingerprint, is defined as follows.
    To recall, the notation \( \fphFP[\lsFPH{\ls}](\addr) \) is the fingerprint at address \( \addr \) in the fingerprint heap \( \lsFPH{\ls} \), which is the first projection of the local state \( \ls \).
    \[
        \begin{rclarray}
            \pred{filter\_inter}{\intf} & \defeq & \lambda \kap \ldotp 
                \Setcon{ 
                    (\ls, \ls')
                }{
                    \for{\addr} \fphFP[\lsFPH{\ls}](\addr) = \emptyset \land
                    (\ls, \ls') \in \intf(\kap)
                }
        \end{rclarray}
    \]
\end{defn}

For brevity, when we write \( \intf \) or \( \evalI{\intass} \), we implicitly apply \( (.)^{[]} \) to extract all possible transitions for a transaction.
%\sx{
    %It is a transitive closure but labelled by \( \kap \).
    %And when we really use the \( \intf \) we only use those where the pre-condition are only tagged with emptyset fingerprint.

    %Should carefully consider the following cases:
    %\[
        %\begin{array}{r c l l}
        %\vx \fptEMP 0 \transfersto \vx \fptR 0 & \text{then} & \vx \fptR 0 \transfersto \vx \fptRW 1 & yes \\
        %\vx \fptEMP 0 \transfersto \vx \fptW 1 & \text{then} & \vx \fptW 1 \transfersto \vx \fpt{\addFPR{\{\fpW\}}} 1 &  yes \\
        %\vx \fptEMP 0 \transfersto \vx \fptW 1 & \text{then} & \vx \fptW 1 \transfersto \vx \fptW 2 &  no ? (give \ yes \ for \ now) \\
        %\end{array}
    %\]
%}


\begin{definition}[Assertions]
The set of \emph{assertions}, $\gpre, \gpost \in \Ast$, are defined by the following inductive grammar:
\[
\begin{rclarray}
	\gpre , \gpost & \defeq & \False \mid \True \mid \gpre \land \gpost \mid \gpre \lor \gpost  \mid \exsts{\lvar}\gpre \mid \Emp \mid \lexpr_1 \pointsto \lexpr_2 \mid \cass{\kap}{\lrid} \mid \boxass{\gpre}{\lrid}{\intass} \mid \gpre \sep \gpost \\
\end{rclarray}
\]
%
where $\lvar, \lrid \in \LVar$, $\lexpr_1, \lexpr_2 \in \LExpr$ (\defin\ref{def:local_assertions}), $\kap \in \Kaps$ (\defin\ref{def:capabilities}) and $\intass \in \IAst$ (\defin\ref{def:intf}).
Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stack$, the \emph{assertion interpretation} function, $\evalW[(., .)]{.}: \Ast \times \LEnv \times \Stack \rightarrow \World$, is defined as follows:
%
\[
\begin{rclarray}
	\evalW{\False} & \defeq & \emptyset \\
	\evalW{\True} & \defeq & \World \\
	\evalW{\emp} & \defeq & \unitW \\
	\evalW{\gpre \land \gpost} & \defeq & \evalW{\gpre} \cap \evalW{\gpost} \\
	\evalW{\gpre \lor \gpost} & \defeq & \evalW{\gpre} \cup \evalW{\gpost} \\
	\evalW{\exsts{\lvar}  \gpre} & \defeq 
	& \bigcup\limits_{\val \in \textnormal{\Val}} \evalW[\lenv\remapsto{\lvar}{\val}, \stk]{\gpre} \\
	\evalW{\lexpr_1 \pt \lexpr_2} & \defeq & 
    \Setcon{
		((\php, \unitC), \gs) 
    }{
		\php = \Set{\evalLE{\lexpr_1} \mapsto \evalLE{\lexpr_2} } \land \gs \in \SStates
	} \\
	\evalW{\cass{\kap}{\lrid}} & \defeq & 
    \Setcon{
		((\unitH, \ca), \gs) 
    }{
		\exsts{\rid = \lenv(\lrid)}  \ca = \Set{\rid \mapsto \kap }
	} \\
	\evalW{\boxass{\gpre}{\lrid}{\intass}} & \defeq &
    \Setcon{
		(\unitLGS, \gs) 
    }{
        \exsts{\rid, \lgs} \lenv(\lrid) = \rid \land \gs(\rid) = (\lgs, \evalI{I})\land (\lgs, \gs) \in \evalAUX{P} 
	} \\
	\evalW{ \gpre \sep \gpost } & \defeq & 
	\Setcon{
	   (\world_1 \composeW \world_2) 
    }{
       \world_1 \in \evalW{\gpre} \land \world_2 \in \evalW{\gpost}
	}   
\end{rclarray}
\]
%
with the \emph{auxiliary interpretation function}, $\evalAUX[(., .)]{.}: \Ast \times \LEnv \times \Stack \times \to \powerset{\LGStates \times \SStates}$, defined as follows:
%
\[
\begin{rclarray}
	\evalAUX{\False} & \defeq & \emptyset \\
	\evalAUX{\True} & \defeq & \LGStates \times \SStates  \\
	\evalAUX{\emp} & \defeq & \Setcon{(\unitLGS, \gs)  }{ \gs \in \SStates} \\
	\evalAUX{\gpre \land \gpost} & \defeq & \evalAUX{\gpre} \cap \evalAUX{\gpost} \\
	\evalAUX{\gpre \lor \gpost} & \defeq & \evalAUX{\gpre} \cup \evalAUX{\gpost} \\
	\evalAUX{\exsts{\lvar} \gpre} & \defeq & \bigcup\limits_{\val \in \textnormal{\Val}} \evalAUX[\lenv\remapsto{\lvar}{\val}, \stk]{\gpre} \\
	\evalAUX{\lexpr_1 \pt \lexpr_2} & \defeq &
    \Setcon{
		((\php, \unitC), \gs) 
    }{
       \php = \Set{\eval{\lexpr_1}{\lenv, \stk} \mapsto \eval{\lexpr_1}{\lenv, \stk} } \land \gs \in \SStates
	} \\
	\evalAUX{\cass{\kap}{\lrid}} & \defeq & 
    \Setcon{
		((\unitH, \ca), \gs) 
    }{
	   \exsts{\rid = \lenv(\lrid)}  \ca = \Set{\rid \mapsto \kap }
	} \\
	\evalAUX{\boxass{\gpre}{\lrid}{\intass}} & \defeq & 
    \Setcon{
		(\lgs, \gs) 
    }{
		(\lgs, \gs) \in \evalW{\boxass{\gpre}{\lrid}{\intass}}
	}\\
	\evalAUX{ \gpre \sep \gpost } & \defeq & 
	\Setcon{
		((\lgs_1 \composeLGS \lgs_2), (\gs_1 \composeS \gs_2)) 
    }{
		(\lgs_1, \gs_1) \in \evalAUX{\gpre} \land (\lgs_2, \gs_2) \in \evalAUX{\gpost}
	}   
\end{rclarray}
\]
\end{definition}
