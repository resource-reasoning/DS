\section{blablabla\label{sec:assertion}}

\[
    \begin{rclarray}
        \gpre , \gpost \in \Globalassertion & \defeq & 
        \begin{array}{l}
                  \assfalse \quad                  |
            \quad \asstrue \quad                   |
            \quad \assemp \quad                    |
            \quad \lvar \pointsto \val \quad       |
            \quad \gpre \sep \gpost \quad          | \\
                  \gpre \land \gpost \quad         |
            \quad \gpre \lor \gpost \quad          |
            \quad \exists \lvar \ldotp \gpre \quad |
            \quad \gpre \implies \gpost
        \end{array}
    \end{rclarray}
\]

\[ 
    \begin{rclarray}
        \lpre , \lpost \in \Localassertion & \defeq & 
        \begin{array}{l}
                  \assfalse \quad                  |
            \quad \asstrue \quad                   |
            \quad \assemp \quad                    |
            \quad \lvar \pointsto[w] \val \quad    |
            \quad \lvar \pointsto[r] \val \quad    |
            \quad \lpre \sep \lpost \quad          | \\
                  \lpre \land \lpost \quad         |
            \quad \lpre \lor \lpost \quad          |
            \quad \exists \lvar \ldotp \lpre \quad |
            \quad \lpre \implies \lpost
        \end{array}
    \end{rclarray}
\]                                  

\[
    \begin{rclarray}
        \action \in \Action & \defeq & \Set{ \lpre \transfersto \lpost \ | \ \lpre , \lpost \in \Localassertion \land \lpre \ \texttt{has no write tag} } \\
        \action \in \Action & \defeq &   
              \lpre \transfersto \lpost \quad |  \quad \action ; \Action
    \end{rclarray}
\]


Logic expression

\[
    \eval[\lenv]{e}
\]

Assume there are special logical variables, ranging \( \loc[1], \loc[2], \dots \), that point to the corresponding locations in the global heap.

\[
    \begin{rclarray}
        \denote[\lenv]{\assfalse} & \defeq & \emptyset \\
        \denote[\lenv]{\asstrue} & \defeq &  \Heap \\
        \denote[\lenv]{\lvar \pointsto \val } & \defeq & \Set{ \hp \ | \ \exists \ts \ldotp \hp(\eval[\lenv]{\lvar}) = (\eval[\lenv]{\val}, \ts) } \\
        \denote[\lenv]{\gpre \sep \gpost } & \defeq & \Set{ \hp[\gpre] \uplus \hp[\gpost] \ | \  \hp[\gpre] \in \denote[\lenv]{\gpre} \land \hp[\gpost] \in \denote[\lenv]{\gpost} } \\
        \denote[\lenv]{\gpre \land \gpost } & \defeq & \Set{ \hp \ | \  \hp \in \denote[\lenv]{\gpre} \land \hp \in \denote[\lenv]{\gpost} } \\
        \denote[\lenv]{\gpre \lor \gpost } & \defeq & \Set{ \hp \ | \  \hp \in \denote[\lenv]{\gpre} \lor \hp \in \denote[\lenv]{\gpost} } \\
        \denote[\lenv]{\exists \lvar \ldotp \gpre } & \defeq & \Set{ \hp \ | \ \exists \val \ldotp \hp \in \denote[\lenv\remapsto{\lvar}{\val}]{\gpre} } \\
        \denote[\lenv]{\gpre \implies \gpost } & \defeq & \Set{ \hp \ | \  \hp \in \denote[\lenv]{\gpre} \implies  \hp \in \denote[\lenv]{\gpost} } \\
    \end{rclarray}
\]


\[
    \begin{rclarray}
        \denote[\stk, \lenv]{\assfalse} & \defeq &  \emptyset \\
        \denote[\stk, \lenv]{\asstrue} & \defeq &  \Heap \times \Heap \\
        \denote[\stk, \lenv]{\assemp} & \defeq &  \Set{(\emptyset, \emptyset)} \\
        \denote[\stk, \lenv]{\lvar \pointsto[r] \val } & \defeq & \Set{ ( \hp[s],\hp[e]) \ | \  \exists \ts \ldotp \hp[s](\eval[\stk, \lenv]{\lvar}) = (\eval[\stk, \lenv]{\val}, \ts) \land \hp[e] = (\eval[\stk, \lenv]{\val}, \ts)} \\
        \denote[\stk, \lenv]{\lvar \pointsto[w] \val } & \defeq & \Set{ ( \hp[s],\hp[e]) \ | \  \exists \val[s], \ts[s],\ts[e] \ldotp \hp[s](\eval[\stk, \lenv]{\lvar}) = (\val[s], \ts[s]) \land \hp[e] = (\eval[\stk, \lenv]{\val}, \ts[e]) \land \ts[s] < \ts[e]} \\
        \denote[\stk, \lenv]{\lpre \sep \lpost } & \defeq & \Set{ ( \hp[\lpre s] \uplus \hp[\lpost s], \hp[\lpre e] \uplus \hp[\lpost e] ) \ | \ ( \hp[\lpre s], \hp[\lpre e] ) \in \denote[\stk, \lenv]{\lpre} \land ( \hp[\lpost s] , \hp[\lpost e] ) \in \denote[\stk, \lenv]{\lpost} } \\
        \denote[\stk, \lenv]{\lpre \land \lpost } & \defeq & \Set{ ( \hp[s], \hp[e] ) \ | \ ( \hp[s], \hp[e] ) \in \denote[\stk, \lenv]{\lpre} \land ( \hp[s] , \hp[e] ) \in \denote[\stk, \lenv]{\lpost} } \\
        \denote[\stk, \lenv]{\lpre \lor \lpost } & \defeq & \Set{ ( \hp[s], \hp[e] ) \ | \ ( \hp[s], \hp[e] ) \in \denote[\stk, \lenv]{\lpre} \lor ( \hp[s] , \hp[e] ) \in \denote[\stk, \lenv]{\lpost} } \\
        \denote[\stk, \lenv]{\exists \lvar \ldotp \lpre } & \defeq & \Set{ ( \hp[s], \hp[e] ) \ | \ \exists \val \ldotp ( \hp[s], \hp[e] ) \in \denote[\stk, \lenv\remapsto{\lvar}{\val}]{\lpre} } \\
        \denote[\stk, \lenv]{\lpre \implies \lpost } & \defeq & \Set{ ( \hp[s], \hp[e] ) \ | \ ( \hp[s], \hp[e] ) \in \denote[\stk, \lenv]{\lpre} \implies ( \hp[s] , \hp[e] ) \in \denote[\stk, \lenv]{\lpost} } \\
    \end{rclarray}
\]

%Rule, \( \efsep \) will propagate write to read assertions.

\[
    \begin{rclarray}
        \asstrue \efsep \lpre & \defeq & \lpre \\
        \assfalse \efsep \dontcare & \defeq & \assfalse \\
        \lvar \pointsto[r] \val \efsep \lvar \pointsto[r] \val & \defeq & \lvar \pointsto[r] \val \\
        \lvar \pointsto[r] \dontcare \efsep \lvar \pointsto[w] \val & \defeq & \lvar \pointsto[w] \val \\
        ( \lpre[1] \sep \lpost[1] ) \efsep ( \lpre[2] \sep \lpost[2] ) & \defeq & (\lpre[1] \efsep \lpre[2] ) \sep (\lpost[1] \efsep \lpost[2] ) \\
        ( \lpre \land \lpost ) \efsep \lframe & \defeq & (\lpre \efsep \lframe ) \land (\lpost \efsep \lframe ) \\
        ( \lpre \lor \lpost ) \efsep \lframe & \defeq & (\lpre \efsep \lframe ) \lor (\lpost \efsep \lframe ) \\
        ( \lpre \lor \lpost ) \efsep \lframe & \defeq & (\lpre \efsep \lframe ) \lor (\lpost \efsep \lframe ) \\
        \exists \lvar \ldotp \lpre  \efsep \lpre & \defeq & \exists \lvar \ldotp (\lpre \efsep \lframe ) \\
        ( \lpre \implies \lpost ) \efsep \lframe & \defeq & (\lpre \efsep \lframe ) \implies (\lpost \efsep \lframe ) \\
        %\propagate{\lvar \pointsto[r] \val }{\lvar \pointsto[r] \val }{\lvar \pointsto[r] \val } & \iff & \true \\
        %\propagate{\lvar \pointsto[w] \val }{\lvar \pointsto[r] \val }{\lvar \pointsto[w] \val } & \iff & \true \\
        %\propagate{\lpre }{\lpost }{\lframe } & \iff & \exists \lpre', \lpre'', \lpost', \lpost'', \lframe' \ldotp \lpre = \lpre' \sep \lpre'' \land {} \\
                                              %& & \lpost = \lpost' \sep \lpost'' \land \lframe = \lpre'' \sep \lpost'' \sep \lframe' \land \propagate{ \lpre' }{\lpost' }{ \lframe' } \\
        \agree{p}{p'} & \iff & \exists \lframe, \lframe', \lframe'' \neq \assfalse \ldotp \lpre \sep \lframe \efsep \lpre' \sep \lframe' = \lframe'' \\
        \mergable{\rely}{\lpre}{\lpost}{\lpost'}  & \iff & \forall \lpre[\rely] \transfersto \lpost[\rely] \in \rely \ldotp \agree{\lpre}{\lpre[\rely]} \land \agree{\lpost}{\lpost[\rely]} \\
                                                  & & \implies ( \exists \lframe, \lframe', \lframe[\rely] \ldotp ( \lpost \sep \lframe ) \efsep ( \lpost[\rely] \sep \lframe[\rely] ) \implies \lpost' \sep \lframe' \land \lpost \implies \lpost') \\
        \stable{\rely}{\lpost} & \iff & \forall \lpre[\rely] \transfersto \lpost[\rely] \in \rely \ldotp \exists \lpre \ldotp \lpost \overset{\texttt{retag} \ r}{\implies} \lpre \land \agree{\lpre}{\lpre[\rely]} \land {} \\
                               & & \exists \lframe,  \lframe[\rely] \ldotp ( \lpost \sep \lframe ) \efsep ( \lpost[\rely] \sep \lframe[\rely] ) = \lpost \sep \lframe
    \end{rclarray}
\]

\[
    \infer[commit]{%
        \judgement{\rely, \grte}{\gpre}{ \ptrans{\tcmd} }{\gpost}
    }{%
        \begin{array}{l}
            \gpre \overset{\texttt{tag} \ r}{\implies} \lpre \quad 
            \judgement{}{\lpre}{\tcmd}{\lpost} \quad 
            ( \lpre \transfersto \lpost ) \in \close{\grte} \\
            \mergable{\rely}{\lpre}{\lpost}{\lpost'} \quad 
            \stable{\rely}{\lpost'} \quad 
            \lpost' \overset{\texttt{notag}}{\implies} \gpost \quad
        \end{array}
    }
\]

\[
    \infer[choice]{%
        \judgement{\rely, \grte}{\gpre}{ \prog[1] \pcond \prog[2] }{\gpost}
    }{%
        \judgement{\rely, \grte}{\gpre}{ \prog[1] }{\gpost} \quad 
        \judgement{\rely, \grte}{\gpre}{ \prog[2] }{\gpost} 
    }
\]

\[
    \infer[seq]{%
        \judgement{\rely, \grte}{\gpre}{ \prog[1] \pseq \prog[2] }{\gpost}
    }{%
        \judgement{\rely, \grte}{\gpre}{ \prog[1] }{\gpost'} \quad 
        \gpost' \implies \gpre' \quad
        \judgement{\rely, \grte}{\gpre'}{ \prog[2] }{\gpost} 
    }
\]

\[
    \infer[concur]{%
        \judgement{\rely, \grte[1] \cup \grte[2]}{\gpre[1] \sep \gpre[2]}{ \prog[1] \ppar \prog[2] }{\gpost[1] \sep \gpost[2]}
    }{%
        \begin{array}{l}
            \judgement{\rely \cup \grte[2], \grte[1]}{\gpre[1]}{ \prog[1] }{\gpost[1]} \quad 
            \judgement{\rely \cup \grte[1], \grte[2]}{\gpre[2]}{ \prog[2] }{\gpost[2]}  \\
            \stable{\rely \cup \grte[2]}{\gpre[1]} \quad
            \stable{\rely \cup \grte[1]}{\gpre[2]} 
        \end{array}
    }
\]

\[
    \infer[repeat]{%
        \judgement{\rely, \grte}{\gpre}{ \prept{\prog} }{\gpre}
    }{%
        \judgement{\rely, \grte}{\gpre}{ \prog }{\gpre}
    }
\]


