\section{Assertion and Rules\label{sec:assertion}}

Before introducing assertion, we extend arithmetic expressions with logical variables, ranging over \( \lvar \).

\[
    \begin{syntax}{\expr}
        \lvar \quad | \quad \dots 
    \end{syntax}
\]

Assume a logical environment \( \lenv \), we extend the evaluation of arithmetic expressions.

\[
\begin{rclarray}
    \eval{\lvar}_{\lenv, \stk} & \defeq & \lenv(\lvar)
\end{rclarray}
\]

\subsection{Local/Transaction}

Local assertions, also transaction assertions, describe the state inside transactions.

\[ 
    \begin{rclarray}
        \lpre , \lpost \in \Localassertion & \defeq & 
        \begin{array}{l}
                  \assfalse \quad                  |
            \quad \asstrue \quad                   |
            \quad \assemp \quad                    |
            \quad \expr \pt_{\op} \expr \quad      | \\
                  \lpre \sep \lpost \quad          | 
            \quad \lpre \land \lpost \quad         |
            \quad \lpre \lor \lpost \quad          |
            \quad \exists \lvar \ldotp \lpre \quad |
        \end{array}
    \end{rclarray}
\]                                  

where,

\[
    \op \subseteq \Set{\wop,\rop}
\]

We also define the order of \( \op \) like follows,

\begin{tikzpicture}
    \node (emp) {\(\emptyset\)};
    \node[above right=0.3cm and 0.3cm of emp] (r) {\(\Set{\rop}\)};
    \node[above left=0.3cm and 0.3cm of emp] (w) {\(\Set{\wop}\)};
    \node[above=0.3cm of r] (rw) {\(\Set{\rop, \wop}\)};
    
    \draw[->] (emp) -- (r);
    \draw[->] (emp) -- (w);
    \draw[->] (r) -- (rw);
\end{tikzpicture}



The semantics of local assertions, where \( \rs \) and \( \ws \) represent the read and write sets respectively.

\[
    \begin{array}{l c l}
        \lenv, \stk, \hp, \rs, \ws \models_{l} \assfalse & \iff & \texttt{never} \\
        \lenv, \stk, \hp, \rs, \ws \models_{l} \asstrue & \iff & \texttt{always} \\
        \lenv, \stk, \hp, \rs, \ws \models_{l} \assemp & \iff & \hp = \emptyset \land \rs = \emptyset \land \ws = \emptyset \\
        \lenv, \stk, \hp, \rs, \ws \models_{l} \expr_{1} \pt_{\op} \expr_{2} & \iff & \hp = \Set{\eval{\expr_{1}}_{\lenv, \stk} \mapsto \eval{\expr_{2}}_{\lenv, \stk}} \land {} \\
                                                                             & & \op = \emptyset \implies \rs = \emptyset \land \ws = \emptyset \\
                                                                             & & \op = \Set{\rop} \implies \rs = \Set{\eval{\expr_{1}}_{\lenv, \stk}} \land \ws = \emptyset \\
                                                                             & & \op = \Set{\wop} \implies \rs = \emptyset \land \ws = \Set{\eval{\expr_{1}}_{\lenv, \stk}}  \\
                                                                             & & \op = \Set{\rop,\wop} \implies \rs = \Set{\eval{\expr_{1}}_{\lenv, \stk}} \land \ws = \Set{\eval{\expr_{1}}_{\lenv, \stk}}  \\
        \lenv, \stk, \hp, \rs, \ws \models_{l} \lpre \sep \lpost & \iff &  \exists \hp_{1}, \hp_{2}, \rs_{1}, \rs_{2}, \ws_{1}, \ws_{2} \ldotp \\
                                                                 & & \hp = \hp_{1} \uplus \hp_{2} \land \rs = \rs_{1} \uplus \rs_{2} \land \ws = \ws_{1} \uplus \ws_{2} \land {} \\
                                                                 & &  ( \lenv, \stk, \hp_{1}, \rs_{1}, \ws_{1} \models_{l} \lpre ) \land ( \lenv, \stk, \hp_{2}, \rs_{2}, \ws_{2} \models_{l} \lpost ) \\
        \lenv, \stk, \hp, \rs, \ws \models_{l} \lpre \land \lpost & \iff & ( \lenv, \stk, \hp, \rs, \ws \models_{l} \lpre ) \land ( \lenv, \stk, \hp, \rs, \ws \models_{l} \lpost ) \\
        \lenv, \stk, \hp, \rs, \ws \models_{l} \lpre \lor \lpost & \iff & ( \lenv, \stk, \hp, \rs, \ws \models_{l} \lpre ) \lor ( \lenv, \stk, \hp, \rs, \ws \models_{l} \lpost ) \\
        \lenv, \stk, \hp, \rs, \ws \models_{l} \exists \lvar \ldotp \lpre & \iff & \exists \val \ldotp \lenv\remapsto{\lvar}{\val}, \stk, \hp, \rs, \ws \models_{l} \lpre \\
    \end{array}
\]

The proof rules are standard except \rl{TRDeref} and \rl{TRMutate}.

\[
    \infer[\rl{TRDeref}]{%
        \judgement{}{\var = \dontcare \land \expr_{1} \pt_{\op} \expr_{2} }{ \pderef{\var}{\expr_{1}} }{\var = \expr_{2} \land \expr_{1} \pt_{\op'} \expr_{1} }
    }{%
        \var \notin \func{fv}(\expr_{1}) \quad
        \var \notin \func{fv}(\expr_{2}) \quad 
        \op = \op' = \Set{\wop} \lor \op' = \op \cup \Set{\rop}
    }
\]

\[
    \infer[\rl{TRMutate}]{%
        \judgement{}{\expr_{1} \pt_{\op} \dontcare }{ \pmutate{\expr_{1}}{\expr_{2}} }{ \expr_{1} \pt_{\op \cup \Set{\wop}} \expr_{1} }
    }{}
\]

\subsection{Global/Program}

How to form a negative assertion?

\[
    \begin{rclarray}
        \gpre , \gpost \in \Globalassertion & \defeq & 
        \begin{array}{l}
                  \assfalse \quad                  |
            \quad \asstrue \quad                   |
            \quad \assemp \quad                    |
            \quad \expr \pointsto \expr \quad      |
            \quad \gpre \sep \gpost \quad          | \\
                  \gpre \land \gpost \quad         |
            \quad \gpre \lor \gpost \quad          |
            \quad \exists \lvar \ldotp \gpre \quad |
        \end{array}
    \end{rclarray}
\]

The semantics of global assertions.
How to give semantics to a negative assertion?


\[
    \begin{array}{l c l}
        \lenv, \stk, \tshp, \ts \models_{g} \assfalse & \iff & \texttt{never} \\
        \lenv, \stk, \tshp, \ts \models_{g} \asstrue & \iff & \texttt{always} \\
        \lenv, \stk, \tshp, \ts \models_{g} \assemp & \iff & \hp = \emptyset \\
        \lenv, \stk, \tshp, \ts \models_{g} \expr_{1} \pt \expr_{2} & \iff & \dom(\tshp) = \Set{ \loc } \land \tshp(\loc)(\ts') =  \val \\
                                                             & & \texttt{where} \ \loc = \eval{\expr_{1}}_{\lenv, \stk} \land \val = \eval{\expr_{2}}_{\lenv, \stk} \land \ts' \leq \ts \land {} \\
                                                             & & \tshp(\loc)(\ts') = (\val,\dontcare, \dontcare) \land \forall \ts'' \in ( \ts', \ts) \ldotp \tshp(\loc)(\ts'')\undef \\
        \lenv, \stk, \tshp, \ts \models_{g} \gpre \sep \gpost & \iff & \exists \tshp_{1}, \tshp_{2} \ldotp \tshp = \tshp_{1} \uplus \tshp_{2} \land ( \lenv, \stk, \tshp_{1}, \ts \models_{g} \gpre ) \land ( \lenv, \stk, \tshp_{2}, \ts \models_{g} \gpost ) \\
        \lenv, \stk, \tshp, \ts \models_{g} \gpre \land \gpost & \iff & ( \lenv, \stk, \tshp, \ts  \models_{g} \gpre ) \land ( \lenv, \stk, \tshp, \ts \models_{g} \gpost ) \\
        \lenv, \stk, \tshp, \ts \models_{g} \gpre \lor \gpost & \iff & ( \lenv, \stk, \tshp, \ts  \models_{g} \gpre ) \lor ( \lenv, \stk, \tshp, \ts \models_{g} \gpost ) \\
        \lenv, \stk, \tshp, \ts \models_{g} \exists \lvar \ldotp \gpre & \iff & \exists \val \ldotp \lenv\remapsto{\lvar}{\val}, \stk, \tshp, \ts \models_{g} \gpre \\
    \end{array}
\]

Action is pair of local assertions, where the first element cannot contain any write label, \( \dontcare \pt_{\wop} \dontcare \).

\[
    \begin{rclarray}
        \action \in \Action & \defeq & \Set{ \lpre \transfersto \lpost \ \middle| \ \lpre , \lpost \in \Localassertion } \\
        \eval{\lpre \transfersto \lpost }_{\lenv, \stk} & \defeq & \Set{(\hp, \hp') \middle| 
        \begin{array}{@{}l@{}}
            \exists \rs, \ws \ldotp \lenv, \stk, \hp, \emptyset,\emptyset \models_{l} \lpre \land \lenv, \stk, \hp, \rs, \ws \models_{l}\lpost 
        \end{array}} 
    \end{rclarray}
\]


%Rule, \( \efsep \) will propagate write to read assertions.

\[
    \infer[\rl{PRCommit}]{%
        \judgement{\rely, \grte}{\gpre}{ \ptrans{\cmd} }{\gpost}
    }{%
        \begin{array}{l}
            \judgement{}{\lpre}{\cmd}{\lpost} \quad 
            ( \lpre \transfersto \lpost ) \in \grte \quad 
            \rely \vdash \gpre \Rrightarrow^{\{\lpre\}\{\lpost\}} \gpost
        \end{array}
    }
\]

\[
    \begin{rclarray}
        \rely \vdash \gpre \Rrightarrow^{\{\lpre\}\{\lpost\}} \gpost & \iff & \exists \lenv, \lenv', \stk, \stk', \tshp, \tshp', \ts, \ts' \ldotp   \lenv, \stk, \tshp, \ts \models_{g} \gpre \land \lenv', \stk', \tshp', \ts' \models_{g} \gpost \land \ts < \ts' \\
                                                                     & & \implies \exists \hp = \func{startstate}(\tshp, \ts), \hp' = \func{startstate}(\tshp', \ts'), \hp'', \ws',\rs' \ldotp \\
                                                                     & & \lenv, \stk, \hp, \emptyset, \emptyset \models_{l} \lpre \land \lenv', \stk', \hp'', \rs', \ws' \models_{l} \lpost \land {} \Set{\loc \mapsto \val \middle| \loc \in \ws' \land \hp''(\loc) = \val} \subseteq \hp' \land {} \\
                                                                     & & \forall \lpre_{r}, \lpost_{r} \ldotp (\lpre_{r} \transfersto \lpost_{r}) \in \rely \land \pred{compatible}{\lpre,\lpost, \lpre_{r}, \lpost_{r}} \land \exists \lenv_{r}, \stk_{r}, \hp_{r}, \rs_{r}, \ws_{r} \ldotp \\
                                                                     & & \lenv_{r}, \stk_{r}, \hp_{r}, \rs_{r}, \ws_{r} \models_{l} \lpost_{r} \land \Set{\loc \mapsto \val \middle| \loc \in \ws_{r} \cap \dom(\hp'') \land \hp_{r}(\loc) = \val} \subseteq \hp' \\
        \pred{compatible}{\lpre_{1},\lpost_{1}, \lpre_{2}, \lpost_{2}} & \defeq & \pred{pre}{\lpre_{1}, \lpre_{2}} \land \pred{post}{\lpost_{1},\lpost_{2}} \\
        \pred{pre}{\lpre_{1},\lpre_{2}} & \defeq & \forall \lenv_{1}, \lenv_{2}, \stk_{1}, \stk_{2}, \hp, \hp_{1}, \hp_{2} \ldotp \lenv_{1}, \stk_{1}, \hp \uplus \hp_{1}, \emptyset, \emptyset \models_{l} \lpre_{1} \land {} \\
                                        & & \lenv_{2}, \stk_{2}, \hp \uplus \hp_{2}, \emptyset, \emptyset \models_{l} \lpre_{2} \land ( \hp \uplus \hp_{1} \uplus \hp_{2} )\isdef \\
        \pred{post}{\lpost_{1},\lpost_{2}} & \defeq & \forall \lenv_{1}, \lenv_{2}, \stk_{1}, \stk_{2}, \hp_{1}, \hp_{2}, \rs_{1}, \rs_{2}, \ws_{1}, \ws_{2} \ldotp \lenv_{1}, \stk_{1}, \hp \uplus \hp_{1}, \rs_{1}, \ws_{1} \models_{l} \lpre_{1} \land {} \\
                                          & & \lenv_{2}, \stk_{2}, \hp \uplus \hp_{2}, \ws_{2}, \rs_{2} \models_{l} \lpre_{1} \land \ws_{1} \cap \ws_{2} = \emptyset \\
    \end{rclarray}
\]

