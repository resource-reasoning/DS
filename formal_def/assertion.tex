\section{Assertion and Rules\label{sec:assertion}}

Before introducing assertion, we extend arithmetic expressions with logical variables, ranging over \( \lvar \).

\[
    \begin{syntax}{\expr}
        \lvar \quad | \quad \dots 
    \end{syntax}
\]

Assume a logical environment \( \lenv \), we extend the evaluation of arithmetic expressions.

\[
\begin{rclarray}
    \eval{\lvar}_{\lenv, \stk} & \defeq & \lenv(\lvar)
\end{rclarray}
\]

\subsection{Local/Transaction}

Local assertions, also transaction assertions, describe the state inside transactions.

\[ 
    \begin{rclarray}
        \fp \subseteq \Fingerprint & \defeq & \Set{\wfp,\rfp} \\
        \lpre , \lpost \in \Localassertion & \defeq & 
                  \assfalse \quad                  |
            \quad \asstrue \quad                   |
            \quad \assemp \quad                    |
            \quad \expr \pt_{\fp} \expr \quad      | 
            \quad \lpre \sep \lpost \quad          | 
            \quad \lpre \land \lpost \quad         | \\
            & &   \lpre \lor \lpost \quad          |
            \quad \exists \lvar \ldotp \lpre \quad |
    \end{rclarray}
\]

We define the order of fingerprint \( \fp \) like follows.
\begin{center}
    \begin{tikzpicture}
        \node (emp) {\(\emptyset\)};
        \node[above right=0.3cm and 0.3cm of emp] (r) {\(\Set{\rfp}\)};
        \node[above left=0.3cm and 0.3cm of emp] (w) {\(\Set{\wfp}\)};
        \node[above=0.3cm of r] (rw) {\(\Set{\rfp, \wfp}\)};
        
        \draw[->] (emp) -- (r);
        \draw[->] (emp) -- (w);
        \draw[->] (r) -- (rw);
    \end{tikzpicture}
\end{center}

Given the order we define a left merge operator on fingerprints.

\[
    \begin{rclarray}
        \fp_{1} \bmrg \fp_{2} & \defeq & 
        \begin{funcarray}
            \fp_{1} \cup \fp_{2}  & \exists \fp \ldotp \fp_{1} \sqsubseteq \fp \land  \fp_{2} \sqsubseteq \fp \\
            \fp_{1}  & o.w. \\
        \end{funcarray}
    \end{rclarray}
\]


\[
    \begin{rclarray}
        \fphp \in \Heapwithfingerprint & \defeq & \Heap \times \Readset \times \Writeset \\
        (\hp_{1}, \rs_{1}, \ws_{1}) \compos_{\fphp} (\hp_{2}, \rs_{2}, \ws_{2}) & \defeq &  (\hp_{1} \uplus \hp_{2}, \rs_{1} \uplus \rs_{2}, \ws_{1} \uplus \ws_{2}) \\
        \unitelem{\fphp} & \defeq & (\emptyset, \emptyset, \emptyset) \\
    \end{rclarray}
\]

The semantics of local assertions, where \( \rs \) and \( \ws \) represent the read and write sets respectively.

\[
    \begin{array}{l c l}
        \eval{\assfalse}_{\lenv, \stk} & \defeq & \emptyset  \\
        \eval{\asstrue}_{\lenv, \stk} & \defeq & \powerset{ \Heapwithfingerprint}  \\
        \eval{\assemp}_{\lenv, \stk} & \defeq & \Set{\unitelem{\fphp}}  \\
        \eval{\expr_{1} \pt_{\fp} \expr_{2}}_{\lenv, \stk} & \defeq & \Set{(\Set{ \loc \mapsto \val }, \rs, \ws) \middle|
            \begin{array}{@{}l@{}}
                \exists \loc = \eval{\expr_{1}}_{\lenv, \stk}, \val =  \eval{\expr_{2}}_{\lenv, \stk} \ldotp \\
                \fp = \emptyset \implies \rs = \emptyset \land \ws = \emptyset \\
                \fp = \Set{\rfp} \implies \rs = \Set{\loc} \land \ws = \emptyset \\
                \fp = \Set{\wfp} \implies \rs = \emptyset \land \ws = \Set{\loc}  \\
                \fp = \Set{\rfp,\wfp} \implies \rs = \ws = \Set{\loc} \\
            \end{array}
        }  \\
        \eval{\lpre \sep \lpost}_{\lenv, \stk} & \defeq & \Set{ \fphp_{1} \compos_{\fphp} \fphp_{2} \middle| \fphp_{1} \in \eval{\lpre}_{\lenv, \stk} \land \fphp_{2} \in \eval{\lpost}_{\lenv, \stk} }  \\
        \eval{\lpre \land \lpost}{\lenv, \stk} & \defeq & \Set{\fphp \middle| \fphp \in \eval{\lpre}_{\lenv, \stk} \land \fphp \in \eval{\lpost}_{\lenv, \stk}}  \\
        \eval{\lpre \lor \lpost}{\lenv, \stk} & \defeq & \Set{\fphp \middle| \fphp \in \eval{\lpre}_{\lenv, \stk} \lor \fphp \in \eval{\lpost}_{\lenv, \stk}}  \\
        \eval{\exists \lvar \ldotp \lpre}{\lenv, \stk} & \defeq & \Set{\fphp \middle| \fphp \in \eval{\lpre}_{\lenv\remapsto{\lvar}{\val}, \stk}}  \\
    \end{array}
\]

The proof rules are standard except \rl{TRDeref} and \rl{TRMutate}.
The \rl{TRDeref} rule add read finger-print in finger-tracking set, only if there is no write finger-print.
This is because once a location has been re-written, the rest read are considered as local operations, while the finger-print only records those operations might have effect on global state.

\[
    \infer[\rl{TRDeref}]{%
        \judgement{}{\var = \dontcare \land \expr_{1} \pt_{\fp} \expr_{2} }{ \pderef{\var}{\expr_{1}} }{\var = \expr_{2} \land \expr_{1} \pt_{\fp \bmrg \Set{\rfp}} \expr_{1} }
    }{%
        \var \notin \func{fv}{\expr_{1}} \quad
        \var \notin \func{fv}{\expr_{2}} \quad 
    }
\]

\[
    \infer[\rl{TRMutate}]{%
        \judgement{}{\expr_{1} \pt_{\fp} \dontcare }{ \pmutate{\expr_{1}}{\expr_{2}} }{ \expr_{1} \pt_{\fp \bmrg \Set{\wfp}} \expr_{1} }
    }{}
\]

\subsection{Global/Program}

\[
    \begin{rclarray}
        \Regionid & \defeq & \Set{\rid, \dots} \\
        \Capabilityid & \defeq & \Set{\capid, \dots } \\
            \gpre , \gpost \in \Globalassertion & \defeq & 
                  \assfalse \quad                         |
            \quad \asstrue \quad                          |
            \quad \assemp \quad                           |
            \quad \expr \pointsto \expr \quad             |
            \quad \boxass{\gpre}{\intf}{\rid} \quad       |
            \quad \capb{\capid(\vec{\lvar})}_{\rid} \quad | \\
            & &  \gpre \sep \gpost \quad                  |
            \quad \gpre \land \gpost \quad                |
            \quad \gpre \lor \gpost \quad                 |
            \quad \exists \lvar \ldotp \gpre \quad        | \\
            \intf \in \InterferenceAssertion & \defeq & 
                  \emptyset \quad |
                  \quad \Set{ \capb{\capid(\vec{\lvar})} : \exists \vec{y} \ldotp \lpre \transfersto \lpost } \uplus \intf \quad | 
    \end{rclarray}
\]

The global assertion should be interpreted as a tuple consisting of world and a set of owned capabilities.
A capability is a pair of capability identifier and a vector of values as parameters.
\textbf{How to give semantics to a negative assertion?}

\[
    \begin{rclarray}
        \cstate \in \Capability & \defeq & \Regionid \parfinfun \Capabilityid \times \Val^{*} \\
        \lstate \in \Logicalstate & \defeq & \Timestampheap \times \Capability \\
        \sstate \in \Sharestate & \defeq & \Regionid \parfinfun \Logicalstate \times \Interference \\
        \world \in \World & \defeq & \Sharestate \times \Logicalstate
    \end{rclarray}
\]

Assume each region \( \rid \) associates capabilities, which forms a PCM:

\[
    \begin{rclarray}
        \setcap & \in & \powerset{\Capabilityid \times \Val^{*}} \\
        \func{cap}{\rid} & \defeq & (\setcap, \compos_{\setcap}, \unitelem{\setcap}) \\
    \end{rclarray}
\]

Given that, the composition of capabilities:

\[
    \begin{rclarray}
        \cstate_{1} \compos_{\cstate} \cstate_{2} & \defeq & 
        \begin{funcarray}
        \lambda \rid \ldotp 
            \begin{funcarray}
                \cstate_{1}(\rid) & \rid \in \cstate_{1} \land \rid \notin \cstate_{2} \\
                \cstate_{2}(\rid) & \rid \notin \cstate_{1} \land \rid \in \cstate_{2} \\
                \cstate_{1}(\rid) \compos_{\cstate} \cstate_{2}(\rid) & \rid \in \cstate_{1} \cap \cstate_{2} \\
            \end{funcarray} & \forall \rid \in \cstate_{1} \cap \cstate_{2} \ldotp ( \cstate_{1}(\rid) \compos_{\cstate} \cstate_{2}(\rid) )\isdef \\
            \texttt{undefined} & o.w. \\
        \end{funcarray} \\
    \end{rclarray}
\]

The composition of logical states.

\[
    \begin{rclarray}
        \lstate_{1} \compos_{\lstate} \lstate_{2} & \defeq & (\lstate_{1}\projection{1} \ \uplus \ \lstate_{2}\projection{1}, \lstate_{1}\projection{2} \ \compos_{\cstate} \ \lstate_{2}\projection{2}) \\
        \unitelem{\lstate} & \defeq & ( \emptyset, \emptyset ) \\
    \end{rclarray}
\]

The composition of capabilities and worlds.

\[
    \begin{rclarray}
        \world_{1} \compos_{\world} \world_{2} & \defeq & 
        \begin{funcarray}
            (\sstate, \lstate_{1} \compos_{\lstate} \lstate_{2}) & \world_{1} = (\sstate, \lstate_{1}) \land \world_{2} = (\sstate, \lstate_{2}) \\
            \texttt{undefined} & o.w. \\
        \end{funcarray} \\
        \unitelem{\world} & \defeq & ( \emptyset, \unitelem{\lstate} ) \\
    \end{rclarray}
\]

\textbf{HOW TO INTERPRET TIME?}

\[
    \begin{array}{l c l}
        \eval{\assfalse}_{\lenv, \stk} & \defeq & \emptyset \\
        \eval{\asstrue}_{\lenv, \stk} & \defeq & \powerset{\World \times \Timestamp } \\
        \eval{\assemp}_{\lenv, \stk} & \defeq & \Set{(\emptyset, \ts)} \\
        \eval{\expr_{1} \pt \expr_{2}}_{\lenv, \stk} & \defeq & \Set{ ( ( \emptyset, ( \tshp, \emptyset ) ), \ts ) \middle| 
            \begin{array}{@{}l@{}}
                \exists \loc = \eval{\expr_{1}}_{\lenv, \stk}, \val = \eval{\expr_{2}}_{\lenv, \stk}, \ts' \ldotp \ts' \leq \ts \land 
                \dom(\tshp) = \Set{ \loc } \land \tshp(\loc)(\ts') =  \val \\
                \tshp(\loc)(\ts') = (\val,\dontcare, \dontcare) \land \forall \ts'' \in ( \ts', \ts) \ldotp \tshp(\loc)(\ts'')\undef \\
            \end{array}
        } \\
        \eval{\boxass{\gpre}{\intf}{\rid}}_{\lenv, \stk} & \defeq & \Set{ ( ( \sstate, \lstate ), \ts ) \middle| \exists \sstate', \lstate' \ldotp ( ( \sstate', \lstate \compos_{\lstate} \lstate' ), \ts ) \in \eval{\gpre}_{\lenv, \stk, \ts} \land \sstate = \sstate' \uplus \Set{\rid \mapsto ( \lstate', \eval{\intf}_{\lenv,\stk} ) } } \\
        \eval{ \capb{\capid(\vec{\lvar})}_{\rid} }_{\lenv, \stk} & \defeq & \Set{ ( ( \sstate, ( \tshp, \cstate ) ), \ts ) \middle| \sstate = \emptyset \land \tshp = \emptyset \land \cstate = \Set{\rid \mapsto (\capid, \vec{\val}) } } \\
        \eval{ \gpre \sep \gpost }_{\lenv, \stk} & \defeq & \Set{ ( \world_{1} \compos_{\world} \world_{2}, \ts ) \middle| ( \world_{1}, \ts ) \in \eval{\gpre}_{\lenv, \stk, \ts} \land ( \world_{2}, \ts ) \in \eval{\gpost}_{\lenv, \stk, \ts} } \\
        \eval{\gpre \land \gpost}_{\lenv, \stk} & \defeq & \Set{ ( \world, \ts ) \middle| ( \world, \ts ) \in \eval{\gpre}_{\lenv, \stk, \ts} \land ( \world, \ts ) \in \eval{\gpost}_{\lenv, \stk, \ts} } \\
        \eval{\gpre \lor \gpost}_{\lenv, \stk} & \defeq & \Set{( \world, \ts ) \middle| ( \world, \ts ) \in \eval{\gpre}_{\lenv, \stk, \ts} \lor ( \world, \ts ) \in \eval{\gpost}_{\lenv, \stk, \ts} } \\
        \eval{\exists \lvar \ldotp \gpre}_{\lenv, \stk} & \defeq & \Set{( \world, \ts ) \middle| ( \world, \ts )\in \eval{\gpre}_{\lenv\remapsto{\lvar}{\val}, \stk, \ts} } \\
    \end{array}
\]

The first element, also pre-condition, only contains empty label, \( \dontcare \pt_{\emptyset} \dontcare \).
The second element, also called post-condition, should contain the same resource as pre-condition and if locations have been updated, they must be tagged with \( \wfp \).

\[
    \begin{rclarray}
        \eval{\capb{\capid(\vec{\lvar})}_{r} : \exists \vec{y} \ldotp \lpre \transfersto \lpost }_{\lenv, \stk}(\rid,\capid,\vec{\val}) & \defeq & \Set{(\hp, \hp') \middle| 
        \begin{array}{@{}l@{}}
            \exists \rs', \ws', \vec{\val}', \lenv' = \lenv[\vec{\lvar} \mapsto \vec{\val}, \vec{y} \mapsto \vec{\val}'] \ldotp ( \hp, \emptyset,\emptyset ) \in \eval{\lpre}_{\lenv, \stk} \land  {} \\
            ( \hp', \rs', \ws' ) \in \eval{\lpost}_{\lenv, \stk} \land \dom(\hp) = \dom(\hp') \land {} \\
            \hp \setminus \Set{\loc \mapsto \dontcare | \loc \in \ws} = \hp' \setminus \Set{\loc \mapsto \dontcare | \loc \in \ws}  
        \end{array}} 
    \end{rclarray}
\]

The repartition is redefined by adding a merging process.

\[
    \infer[\rl{PRCommit}]{%
        \judgement{}{\gpre}{ \ptrans{\cmd} }{\gpost}
    }{%
        \begin{array}{l}
            \judgement{}{\lpre}{\cmd}{\lpost} \quad 
            \vdash \gpre \Rrightarrow^{\{\lpre\}\{\lpost\}} \gpost
        \end{array}
    }
\]

Before defining repartition, we define the meaning of \emph{merge}.
The merge with respect to \( \fphp \).

\[
    \begin{rclarray}
        \pred{noFingerPrint}{\fphp_{l}, \fphp_{r}} & \defeq & \exists \rs_{l}, \rs_{r}, \ws_{l}, \ws_{r} \ldotp \\ 
                                                   & & \fphp_{l} = (\dontcare, \rs_{l}, \ws_{l}) \land \fphp_{r} = (\dontcare, \rs_{r}, \ws_{r}) \land \rs_{l} = \rs_{r} = \ws_{l} = \ws_{r} = \emptyset \\
        \pred{noWriteConflict}{\fphp_{l}, \fphp_{r}} & \defeq & \exists \ws_{l} = \fphp_{l}\projection{3}, \ws_{r} = \fphp_{r}\projection{3} \ldotp \ws_{l} \cap \ws_{r} = \emptyset \\
        \pred{agree}{\fphp_{l}, \fphp_{r}} & \defeq & \exists \fphp'_{l}, \fphp_{m}, \fphp'_{r}, \fphp \ldotp \fphp_{l} = \fphp'_{l} \compos_{\fphp} \fphp_{m} \land \fphp_{r} = \fphp'_{r} \compos_{\fphp} \fphp_{m} \land \fphp = \fphp'_{l} \compos_{\fphp} \fphp_{m} \compos_{\fphp} \fphp'_{r} \\
        \fphp \wmrg \fphp' & \defeq & \lambda \loc \ldotp  
        \begin{funcarray}
            \hp'(\loc) & \loc \in \ws' \\
            \hp(\loc) & \loc \in \ws \land \loc \notin \ws \\
            \texttt{undefined} & o.w. \\
        \end{funcarray} \\
        & & \texttt{where} \ \fphp = (\hp, \dontcare, \ws) \land \fphp' = (\hp', \dontcare, \ws') \\
        ( \fphp_{\lpre}, \fphp_{\lpost} ) \bmrg ( \fphp'_{\lpre}, \fphp'_{\lpost} ) & \defeq & \Set{( \fphp_{\lpre}, \fphp_{\lpost} )} \cup \Set{(\fphp_{\lpre}, \fphp_{\lpost} \bmrg \fphp'_{\lpost}) \middle| 
        \begin{array}{@{}l@{}}
            \pred{noFingerPrint}{\fphp_{\lpre}, \fphp_{\lpost}} \land \pred{agree}{\fphp_{\lpre}, \fphp_{\lpost}} \land {} \\
            \pred{noWriteConflict}{\fphp'_{\lpre}, \fphp'_{\lpost}} \land \pred{agree}{\fphp'_{\lpre}, \fphp'_{\lpost}} 
        \end{array}
    }
    \end{rclarray}
\]


\[
    \begin{rclarray}
        \repartition{\gpre}{\gpost}{\lpre}{\lpost} & \iff & \exists \lenv, \lenv', \stk, \stk', \world, \world', \ts, \ts' \ldotp  \world \in \eval{\gpre}_{\lenv, \stk, \ts} \land \world' \in \eval{\gpost}_{\lenv', \stk', \ts'} \land \ts < \ts' \\
                                                                     & & \implies \exists \hp = \func{startstate}{\tshp, \ts}, \hp' = \func{startstate}{\tshp', \ts'}, \hp'', \ws',\rs' \ldotp \\
                                                   & & ( \hp, \emptyset, \emptyset ) \in \eval{\lpre}_{\lenv, \stk} \land ( \hp'', \rs', \ws' ) \in \eval{\lpost}_{\lenv', \stk'} \land {} \Set{\loc \mapsto \val \middle| \loc \in \ws' \land \hp''(\loc) = \val} \subseteq \hp' \land {} \\
                                                                     & & \forall \lpre_{r}, \lpost_{r} \ldotp (\lpre_{r} \transfersto \lpost_{r}) \in \rely \land \pred{compatible}{\lpre,\lpost, \lpre_{r}, \lpost_{r}} \land \exists \lenv_{r}, \stk_{r}, \hp_{r}, \rs_{r}, \ws_{r} \ldotp \\
                                                                     & & \lenv_{r}, \stk_{r}, \hp_{r}, \rs_{r}, \ws_{r} \models_{l} \lpost_{r} \land \Set{\loc \mapsto \val \middle| \loc \in \ws_{r} \cap \dom(\hp'') \land \hp_{r}(\loc) = \val} \subseteq \hp' \\
    \end{rclarray}
\]

The \predn{compatible}, intuitively, means all the assertions within the pre-conditions \( \lpre_{1} \) and \( \lpre_{2} \) must be tagged with empty-set and if they assert overlapped heap, the overlapped part must agree.
Then, the post-conditions \( \lpost_{1} \) and \( \lpost_{2} \) write to different locations.
Note that for post-conditions, it is enough to only check the finger-print because of the constraint of actions and the constraint of pre-conditions.

\[
    \begin{rclarray}
        \pred{compatible}{\lpre_{1},\lpost_{1}, \lpre_{2}, \lpost_{2}} & \defeq & \pred{pre}{\lpre_{1}, \lpre_{2}} \land \pred{post}{\lpost_{1},\lpost_{2}} \\
        \pred{pre}{\lpre_{1},\lpre_{2}} & \defeq & \forall \lenv_{1}, \lenv_{2}, \stk_{1}, \stk_{2}, \hp, \hp_{1}, \hp_{2} \ldotp \lenv_{1}, \stk_{1}, \hp \uplus \hp_{1}, \emptyset, \emptyset \models_{l} \lpre_{1} \land {} \\
                                        & & \lenv_{2}, \stk_{2}, \hp \uplus \hp_{2}, \emptyset, \emptyset \models_{l} \lpre_{2} \land ( \hp \uplus \hp_{1} \uplus \hp_{2} )\isdef \\
        \pred{post}{\lpost_{1},\lpost_{2}} & \defeq & \forall \lenv_{1}, \lenv_{2}, \stk_{1}, \stk_{2}, \hp_{1}, \hp_{2}, \rs_{1}, \rs_{2}, \ws_{1}, \ws_{2} \ldotp \lenv_{1}, \stk_{1}, \hp \uplus \hp_{1}, \rs_{1}, \ws_{1} \models_{l} \lpre_{1} \land {} \\
                                          & & \lenv_{2}, \stk_{2}, \hp \uplus \hp_{2}, \ws_{2}, \rs_{2} \models_{l} \lpre_{1} \land \ws_{1} \cap \ws_{2} = \emptyset \\
    \end{rclarray}
\]


\section{temp}

To merge two actions \( \lpre \transfersto \lpost \) and \( \lpre' \transfersto \lpost' \), it requires the pre-conditions agrees, which means that if they describe some common heaps, the state of the common part should be consistent.
Then if the post-conditions write to different locations, the \emph{merge} (to the left) operator \( \wmrg \) returns a new action where the effect of right hands side propagate to the left hand side.
\textbf{Not sure how to do it properly considering there is \(\vec{x}\) binder and extension \(\vec{y}\) }.

\[
    \begin{rclarray}
        \func{writeSet}{\lvar \pointsto_{\fp \cup \Set{\wfp}} \dontcare } & \defeq & \Set{\lvar} \\
        \func{writeSet}{\lvar \pointsto_{\fp \setminus \Set{\wfp}} \dontcare } & \defeq & \emptyset \\
        \func{writeSet}{ \lpre \sep \lpost } & \defeq & \func{writeSet}{\lpre} \uplus \func{writeSet}{\lpost} \\
        \lpre \bmrg \lpost & \defeq & 
        \begin{funcarray}
            ( \lpre' \bmrg \lpost' ) \sep \lvar \pointsto_{\fp \cup \Set{\wfp}} \dontcare  &  ( \lpre = \lpre' \sep \lvar \pointsto_{\dontcare} \dontcare ) \land  ( \lpost = \lpost' \sep \lvar \pointsto_{\fp \cup \Set{\wfp}} \dontcare ) \\
            \lpre & o.w. \\
        \end{funcarray} \\
        \pred{agree}{\lpre , \lpost} & \defeq & \exists \lpre', \lpost', \lframe, m \ldotp ( \lpre = \lpre \sep \lframe ) \land ( \lpost = \lpost' \sep \lframe)  \land ( m = \lpre' \sep \lpost' \sep \lframe ) \\
        ( \lpre \transfersto \lpost ) \wmrg ( \lpre' \transfersto \lpost' ) & \defeq & \Set{ \lpre \transfersto \lpost } \cup \Set{\lpre \transfersto (\lpost \bmrg \lpost') \middle| \pred{agree}{\lpre , \lpre'} \land \func{writeSet}{\lpost} \cap \func{writeSet}{\lpost'} = \emptyset}
    \end{rclarray}
\]

