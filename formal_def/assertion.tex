\section{Assertion and Rules\label{sec:assertion}}

\subsection{Local/Transaction}

\begin{definition}[capabilities]
\label{def:capabilities}
Assume a partial commutative monoid for \emph{primitive capabilities} $(\Kaps, \composeK, \unitK)$ with $\kap \in \Kaps$.
Assume a countably infinite set of region identifiers $\rid \in \RegionID$. The set of \emph{capabilities} is $\ca \in \Caps \eqdef \RegionID \rightharpoonup \Kaps$.
The \emph{capability composition function}, $\composeC: \Caps \times \Caps \rightharpoonup \Caps$, is defined as follows:
%
\[
    \begin{rclarray}
	(\ca_1 \composeC \ca_2)(\rid) & \defeq  &
	\begin{cases}
		\ca_1(\rid) \composeK \ca_2(\rid) & \text{if } \rid \in \dom(\ca_1) \text{ and } \rid \in \dom(\ca_2) \\
		\ca_1(\rid) & \text{if } \rid \in \dom(\ca_1) \text{ and } \rid \not\in \dom(\ca_2) \\
		\ca_2(\rid) & \text{if } \rid \not\in \dom(\ca_1) \text{ and } \rid \in \dom(\ca_2) \\
		\text{undefined} & \text{otherwise}
	\end{cases}
    \end{rclarray}
\]
%
The \emph{capability unit element}, $\unitC$, denotes a function with an empty domain.
The \emph{capability partial commutative monoid} is $(\Caps, \composeC, \unitC)$. 
\end{definition}
 
\begin{definition}[Local state]
\label{def:local_state}
Given the set of fingerprint heaps $\FPHeaps$ (\defin\ref{def:fingerprint_heaps}) and the set of capabilities $\Caps$ (\defin\ref{def:capabilities}), the set of \emph{local states} is $\ls \in \LStates \eqdef \FPHeaps \times \Caps$.
The \emph{local state composition function}, $\composeLS: \LStates \times \LStates \parfun \LStates$, is defined component-wise as: $\composeLS \eqdef (\composeFP, \composeC)$.
The \emph{local state unit element} is $\unitLS \eqdef (\unitFP, \unitC)$.
The \emph{partial commutative monoid of local states} is $(\LStates, \composeLS, \unitLS)$.
\end{definition}
 
Given a local state $\ls$, we write $\lsFPH{\ls}$ and $\lsCAP{\ls}$ for the first and second projections of $\ls$, respectively.
 
\begin{definition}[Logical Expressions]
\label{def:logical-expr}
Assume a countably infinite set of \emph{logical variables} $\V x \in \LVar$.
The set of \emph{logical expressions}, $ \lexpr \in \LExpr$ is defined by the following inductive grammar, where $\val \in \Val$, $\vx \in \Var$ (\defin\ref{def:prgram_values}) and $\V x \in \LVar$:
%
\[
\begin{rclarray}
   \lexpr & ::= & \val \mid \var \mid \lvar \mid \lexpr + \lexpr \mid \lexpr * \lexpr \mid \dots 
\end{rclarray}
\]
Given the set of values $\Val$ (\defin\ref{def:prgram_values}), assume a set of \emph{logical environments} $\lenv \in \LEnv: \LVar \parfun \Val$.
Given a stack $\stk \in \Stack$ (\defin\ref{def:stacks}) and a logical environment $\lenv: \LEnv$, the \emph{logical expression evaluation} function, $\evalLE[(., .)]{.}:\LExpr \times \Stack \times \LEnv\rightharpoonup \Val$, is defined inductively over the structure of logical expressions as follows: 
%
\[
    \begin{rclarray}
        \evalLE{\val} & \defeq & \val \\
        \evalLE{\var} & \defeq & \stk(\var) \\
        \evalLE{\lvar} & \defeq & \lenv(\lvar) \\
        \evalLE{\lexpr_1 + \lexpr_2} & \defeq & \evalLE{\lexpr_1} + \evalLE{\lexpr_2}   \\
        \evalLE{\lexpr_1 * \lexpr_2} & \defeq & \evalLE{\lexpr_1} * \evalLE{\lexpr_2}  
    \end{rclarray}
\]
\end{definition}

\begin{definition}[Local assertions]
\label{def:local_assertions}
Given the set of logical expressions \( \LExpr \) (\defin\ref{def:logical-expr}), the set of \emph{local assertions}, $\lpre,  \lpost \in \LAst$, is defined inductively by the following grammar, where $\fp \in \Fingerprint$ denotes a fingerprint (\defin\ref{def:fingerprint_heaps}) and $\lvar, \lrid \in \LVar$: 
%
\[
\begin{rclarray}
	\lpre, \lpost  & ::= & \False \mid \True \mid \lpre \land \lpost \mid \lpre \lor \lpost \mid \exsts{\lvar} \lpre \mid \Emp \mid \lexpr \fpt{\fp} \lexpr \mid \cass{\kap}{\lrid} \mid \lpre \sep \lpost 
\end{rclarray}	 
\]
%
Given a logical environment $\lenv \in \LEnv$, the \emph{local interpretation function}, $\evalLC[(.,.)]{.}: \LAst \times \LEnv \rightarrow \powerset{\LStates}$, is defined over the structure of local assertions as follows:
%
\[
\begin{rclarray}
	\evalLC{\assfalse} & \eqdef & \emptyset  \\
	\evalLC{\asstrue} & \defeq & \LStates  \\
	\evalLC{\lpre \land \lpost} & \defeq & \evalLC{\lpre} \cap \evalLC{\lpost} \\
	\evalLC{\lpre \lor \lpost} & \defeq & \evalLC{\lpre} \cup \evalLC{\lpost} \\
	\evalLC{\exsts{\lvar} \lpre} & \defeq & \bigcup\limits_{\val \in \textnormal{\Val}}\evalLC[\lenv\remapsto{\lvar}{\val}, \stk]{\lpre}  \\
	\evalLC{\assemp} & \defeq & \Set{\unitLS}  \\
	\evalLC{\lexpr_1 \fpt{\fp} \lexpr_2} & \defeq & 
    \Setcon{
		(\fph, \unitC) 
    }{
	   \exsts{\addr = \evalLE{\lexpr_1}, \val = \evalLE{\lexpr_2}} 
	   \fph {=} \Set{\addr \mapsto (\val, \fp) }
	} \\
%
	\evalLC{\cass{\kap}{\lrid}} & \eqdef & 
    \Setcon{
		(\unitFP, \ca) 
    }{
	   \exsts{\rid = \evalLE{\lrid}} 
       \ca = \Set{\rid \mapsto \kap } 
	} \\
	\evalLC{\lpre \sep \lpost} & \defeq & 
    \Setcon{ \ls_1 \composeLS \ls_2 }{ \ls_1 \in \evalLC{\lpre} \land \ls_2 \in \evalLC{\lpost} } 
\end{rclarray}
\]
\end{definition}

Observe that program expressions ($\expr \in \Expr$ in \defin\ref{def:language}) are contained in logical expressions ($\lexpr \in \LExpr$ in \defin\ref{def:local_assertions} above). That is, $\Expr \subset \LExpr$. 



\subsection{Global/Program}
\begin{definition}[Actions]
\label{def:action}
Given the set of local states $\LStates$ (\defin\ref{def:local_state}), the set of \emph{actions}, $\action \in \Actions$, is defined as follows:
%
\[
\begin{rclarray}
	\Actions & \eqdef  &
	\Setcon{
		((\fph, \ca), (\fph', \ca'))
	}{
		((\fph, \ca), (\fph', \ca')) \in \LStates \times \LStates \land \dom(\fph) = \dom(\fph') \land {} \\
        \for{\loc} \fph(\loc) = (\val, \fp) \implies ( \fp = \emptyset \land (\fpW \in \fphFP[\fph'](\addr) \lor \fph'(\loc) = (\val, \Set{\fpR}) ) )
	}
\end{rclarray}
\] 
Given the set of primitive capabilities $\Kaps$ (\defin\ref{def:capabilities}), the set of \emph{interference environments} is $\inter \in \Interference \eqdef \Kaps \parfun \powerset{\Actions}$.
\end{definition}
\sx{ The pre-condition must be empty set.  }
\sx{Ignore the name clash for now}

\begin{definition}[Logical states]
\label{def:logical_states}
Assume a partial commutative monoid of (plain) heaps \( (\PHeap, \composeH, \unitH) \), where \(\PHeap \defeq \Loc \parfinfun \Val \), \( \composeH \defeq \uplus \) and \( \unitH \defeq \emptyset \).
Then given the partial commutative monoid of capabilities ($\Caps$, \composeC, \unitC) in \defin\ref{def:capabilities}, the set of \emph{logical states} is: \(\lgs \in \LGStates \eqdef \PHeap \times \Caps\).
The \emph{logical state composition function}, $\composeLGS: \LGStates \times \LGStates \parfun \LGStates$, is defined component-wise as: $\composeLGS \eqdef (\composeH, \composeC)$.
The \emph{logical state unit element} is $\unitLGS \eqdef (\unitH, \unitC)$.
The \emph{partial commutative monoid of logical states} is $(\LGStates, \composeLGS, \unitLGS)$.
\end{definition}

\begin{definition}[Worlds]
\label{def:world}
Given the set of region identifiers $\RegionID$ (\defin\ref{def:capabilities}) and the partial commutative monoid of logical states $(\LGStates, \composeLGS, \unitLGS)$ (\defin\ref{def:logical_states}), the set of \emph{shared states} is $\SStates \eqdef \RegionID \parfinfun \LGStates$.
The \emph{shared state composition function}, $\composeS: \SStates \times \SStates \parfun \SStates$, is defined as: $\composeS \eqdef \composeEq$, where for all domains $\sort M$ and all $m, m' \in \sort M$: 
%
\[
\begin{rclarray}
	m \composeEq m' &  \eqdef  &
	\begin{cases}
		m & \text{if } m = m'\\
		\text{undefined} & \text{otherwise}
	\end{cases}
\end{rclarray}
\]
%
The \emph{flattening} function for worlds, $\flattenW{.}: \World \parfun \LGStates$, is defined as follows, for all $\lgs \in \LGStates$ and $\gs \in \SStates$:
%
\[
\begin{rclarray}
	\flattenS{(\lgs, \gs)}  & \eqdef & \lgs \composeLGS \prod\limits_{\rid \in \dom(\gs)}^{\composeLGS} \gs(\rid)
\end{rclarray}
\]
%
Given the set of timestamps $\Timestamp$ (\defin\ref{def:timestamp_heaps}), 
a triple $(\lgs, \gs, \ts) \in \LGStates \times \SStates \times \Timestamp$ is \emph{well-formed}, written $\wf{\lgs, \gs}$:
%
\[
\begin{rclarray}
	\wf{\lgs, \gs} & \defeq & \exsts{\php, \ca}\flattenS{(\lgs, \gs)} {=} (\php, \ca) \land\ \dom(\ca) \subseteq \dom(\gs) \\
\end{rclarray}
\]
%
\azalea{Shale, check  the last condition of $\wf{.}$ with regards to the timestamps.}
\sx{  Here is my understanding.
The first line says a world that is able to collapse down to a TSheap and a time, which is the most important part for proving soundness.
The second line means all capabilities must have existed corresponding regions, which is similar to all other logics.
The third line I think says a location must at least be initialised?
Since we don't have allocation and we make assumption all resources initialised, but I think it is fine we still make this constrains?
}
%
The set of \emph{worlds}, $\world \in \World$, is defined as follows:
%
\[
\begin{rclarray}
	\world \in \World  & \eqdef  & \Setcon{(\lgs, \gs)}{(\lgs, \gs) \in \LGStates \times \SStates \land \wf{\lgs, \gs}}
\end{rclarray}
\]
% 
The \emph{world composition function}, $\composeW: \World \times \World \parfun \World$, is defined component-wise as: $\composeW \eqdef (\composeH, \composeS)$.
The \emph{world unit set} is $\unitW \eqdef \Setcon{(\unitH, \gs)}{(\unitH, \gs) \in \World}$.
The \emph{partial commutative monoid of worlds} is $(\World, \composeW, \unitW)$.
\end{definition}
 
\begin{defn}[Interference]
\label{def:intf}
The set of \emph{interference assertions}, \( \intass \in \IAst \), are defined by the following grammar:
\[
\begin{rclarray}
	\intass & \eqdef  &
	\emptyset \mid \Set{ \perm{\kap} : \exsts{\vec{\lvar}} \lpre \transfersto \lpost } \cup \intass 
\end{rclarray}
\]
Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stack$, the \emph{interference interpretation} function, $\evalI[(., .)]{.}: \IAst \times \LEnv \times \Stack \parfun \Interference$, is defined as follows, for all $\kap \in \Kaps$:
%
\[
\begin{rclarray}
	\evalI{\emptyset}(\kap) & \eqdef & \emptyset \\
	\evalI{\Set{ \perm{\kap} : \exsts{\vec{\lvar}} \lpre \transfersto \lpost } \cup \intass }(\kap) & \eqdef &
	\Setcon{
		(\ls_\lpre, \ls_\lpost)	 
    }{
		(\ls_\lpre, \ls_\lpost)	\in \Actions \land \exsts{\rid, \vec{v}, \lenv'} \land \lenv' = \lenv \remapsto{\vec{\lvar}}{\vec v} \land {} \\
			\ls_\lpre \in \evalLC[\lenv', \stk]{\lpre} \land \ls_\lpost \in \evalLC[\lenv', \stk]{\lpost}
	}
	\cup 
	\evalI{\intass}(\kap)
\end{rclarray}
\] 
\end{defn}

\begin{definition}[Assertions]
The set of \emph{assertions}, $\gpre, \gpost \in \Ast$, are defined by the following inductive grammar:
\[
\begin{rclarray}
	\gpre , \gpost & \defeq & \False \mid \True \mid \gpre \land \gpost \mid \gpre \lor \gpost  \mid \exsts{\lvar}\gpre \mid \Emp \mid \lexpr_1 \pointsto \lexpr_2 \mid \cass{\kap}{\lrid} \mid \boxass{\gpre}{\lrid}{\intass} \mid \gpre \sep \gpost \\
\end{rclarray}
\]
%
where $\lvar, \lrid \in \LVar$, $\lexpr_1, \lexpr_2 \in \LExpr$ (\defin\ref{def:local_assertions}), $\kap \in \Kaps$ (\defin\ref{def:capabilities}) and $\intass \in \IAst$ (\defin\ref{def:intf}).
Given a logical environment $\lenv \in \LEnv$ and a stack $\stk \in \Stack$, the \emph{assertion interpretation} function, $\evalW[(., .)]{.}: \Ast \times \LEnv \times \Stack \rightarrow \World$, is defined as follows:
%
\[
\begin{rclarray}
	\evalW{\False} & \defeq & \emptyset \\
	\evalW{\True} & \defeq & \World \\
	\evalW{\emp} & \defeq & \unitW \\
	\evalW{\gpre \land \gpost} & \defeq & \evalW{\gpre} \cap \evalW{\gpost} \\
	\evalW{\gpre \lor \gpost} & \defeq & \evalW{\gpre} \cup \evalW{\gpost} \\
	\evalW{\exsts{\lvar}  \gpre} & \defeq 
	& \bigcup\limits_{\val \in \textnormal{\Val}} \evalW[\lenv\remapsto{\lvar}{\val}, \stk]{\gpre} \\
	\evalW{\lexpr_1 \pt \lexpr_2} & \defeq & 
    \Setcon{
		((\php, \unitC), \gs) 
    }{
		\php = \Set{\evalLE{\lexpr_1} \mapsto \evalLE{\lexpr_2} } \land \gs \in \SStates
	} \\
	\evalW{\cass{\kap}{\lrid}} & \defeq & 
    \Setcon{
		((\unitH, \ca), \gs) 
    }{
		\exsts{\rid = \lenv(\lrid)}  \ca = \Set{\rid \mapsto \kap }
	} \\
	\evalW{\boxass{\gpre}{\lrid}{\intass}} & \defeq &
    \Setcon{
		(\unitLGS, \gs) 
    }{
        \exsts{\rid, \lgs} \lenv(\lrid) = \rid \land \gs(\rid) = (\lgs, \evalI{I})\land (\lgs, \gs) \in \evalAUX{P} 
	} \\
	\evalW{ \gpre \sep \gpost } & \defeq & 
	\Setcon{
	   (\world_1 \composeW \world_2) 
    }{
       \world_1 \in \evalW{\gpre} \land \world_2 \in \evalW{\gpost}
	}   
\end{rclarray}
\]
%
with the \emph{auxiliary interpretation function}, $\evalAUX[(., .)]{.}: \Ast \times \LEnv \times \Stack \times \to \powerset{\LGStates \times \SStates}$, defined as follows:
%
\[
\begin{rclarray}
	\evalAUX{\False} & \defeq & \emptyset \\
	\evalAUX{\True} & \defeq & \LGStates \times \SStates  \\
	\evalAUX{\emp} & \defeq & \Setcon{(\unitLGS, \gs)  }{ \gs \in \SStates} \\
	\evalAUX{\gpre \land \gpost} & \defeq & \evalAUX{\gpre} \cap \evalAUX{\gpost} \\
	\evalAUX{\gpre \lor \gpost} & \defeq & \evalAUX{\gpre} \cup \evalAUX{\gpost} \\
	\evalAUX{\exsts{\lvar} \gpre} & \defeq & \bigcup\limits_{\val \in \textnormal{\Val}} \evalAUX[\lenv\remapsto{\lvar}{\val}, \stk]{\gpre} \\
	\evalAUX{\lexpr_1 \pt \lexpr_2} & \defeq &
    \Setcon{
		((\php, \unitC), \gs) 
    }{
       \php = \Set{\eval{\lexpr_1}{\lenv, \stk} \mapsto \eval{\lexpr_1}{\lenv, \stk} } \land \gs \in \SStates
	} \\
	\evalAUX{\cass{\kap}{\lrid}} & \defeq & 
    \Setcon{
		((\unitH, \ca), \gs) 
    }{
	   \exsts{\rid = \lenv(\lrid)}  \ca = \Set{\rid \mapsto \kap }
	} \\
	\evalAUX{\boxass{\gpre}{\lrid}{\intass}} & \defeq & 
    \Setcon{
		(\lgs, \gs) 
    }{
		(\lgs, \gs) \in \evalW{\boxass{\gpre}{\lrid}{\intass}}
	}\\
	\evalAUX{ \gpre \sep \gpost } & \defeq & 
	\Setcon{
		((\lgs_1 \composeLGS \lgs_2), (\gs_1 \composeS \gs_2)) 
    }{
		(\lgs_1, \gs_1) \in \evalAUX{\gpre} \land (\lgs_2, \gs_2) \in \evalAUX{\gpost}
	}   
\end{rclarray}
\]
\end{definition}

\subsection{Merge - shale}

\begin{defn}[Fingerprint heap agreement]
Given tw fingerprint heaps, the \emph{fingerprint heap agreement} is defined as follows:
\[
    \begin{rclarray}
        \pred{agree\_heap}{\fph_{l},\fph_{r}} & \defeq  & \exsts{ \fph_{l}' = \func{get\_no\_write}{\fph_{l}}, \fph_{l}'', \fph_{r}' = \func{get\_no\_write}{\fph_{r}}, \fph_{r}'', \fph_{m} } \\
        & & \pred{ws}{\fph_{l}} \cap \pred{ws}{\fph_{r}} = \emptyset  \land \fph_{l}' = \fph_{l}'' \composeFP \fph_{m} \land \fph_{r}' = \fph_{r}'' \composeFP \fph_{m} \land ( \fph_{l} \composeFP \fph_{r} \composeFP \fph_{m}  )\isdef \\
    \end{rclarray}
\]
where,
\[
    \begin{rclarray}
        %\funcn{ws} & : & \FPHeaps \to \powerset{\Addr} \\
        \func{ws}{\fph} & \defeq & \Setcon{\loc}{ \exsts{ \fp } \fph(\loc) = (\stub, \addFPW{\fp}, \stub)} \\
        %\funcn{get\_no\_write} & :  & \FPHeaps \to \FPHeaps \\
        \func{get\_no\_write}{\fph } & \defeq & \fph \setminus \Setcon{\loc \mapsto \stub }{ \loc \in \pred{ws}{\fph}} \\
    \end{rclarray}
\]
The agreement between two fingerprint heaps means that they write different locations, and for the rest parts, if there is overlap, the overlapped part must be at the same state.
\end{defn}

\begin{defn}[Action agreement]
The \emph{action agreement} is defined as follows:
\[
    \begin{rclarray}
        \pred{agree\_action}{(\ls_{l}^{p}, \ls_{l}^{q} ),(\ls_{r}^{p}, \ls_{r}^{q} )} & \eqdef & \pred{agree\_local}{\ls_{l}^{p}, \ls_{r}^{p}} \land \pred{agree\_local}{\ls_{l}^{q}, \ls_{r}^{q}} \land {}\\
        & & \pred{agree\_cap\_diff}{\ls_{l}^{p}, \ls_{r}^{q}, \ls_{l}^{q}, \ls_{r}^{p}} \\
        \pred{agree\_local}{(\fph_{l}, \ca_{l} ),(\fph_{r}, \ca_{r})} & \eqdef & \pred{agree\_heap}{\fph_{l}, \fph_{r}} \land ( \ca_{l} \composeC \ca_{r} )\isdef  \\
        \pred{agree\_cap\_diff}{(\stub, \ca_{l}^{p}), (\stub, \ca_{l}^{q}), (\stub, \ca_{r}^{p}), (\stub, \ca_{r}^{q})} & \defeq  & ((\ca_{l}^{p} \setminus \ca_{l}^{q}) \composeC (\ca_{r}^{p} \setminus \ca_{r}^{q} ))\isdef \land ((\ca_{l}^{p} \setminus \ca_{l}^{q}) \composeC (\ca_{r}^{q} \setminus \ca_{r}^{p} ))\isdef \land {} \\
        & & ((\ca_{l}^{q} \setminus \ca_{l}^{p}) \composeC (\ca_{r}^{p} \setminus \ca_{r}^{q} ))\isdef \land ((\ca_{l}^{q} \setminus \ca_{l}^{p}) \composeC (\ca_{r}^{q} \setminus \ca_{r}^{p} ))\isdef \\
    \end{rclarray}
\]
\sx{
The first line of agreement on actions is to stop merging of the following two actions:
\[
\begin{array}{@{}l@{}}
\cass{A}{}: \vx \pt_{\emptyset} 0 \sep \vy \pt_{\emptyset} 0 \sep \cass{C}{} \transfersto  \vx \pt_{\Set{\fpR}} 0 \sep \vy \pt_{\Set{\fpW}} 1 \\
\cass{B}{}: \vx \pt_{\emptyset} 0 \sep \vy \pt_{\emptyset} 0 \sep \cass{C}{} \transfersto  \vx \pt_{\Set{\fpW}} 1 \sep \vy \pt_{\Set{\fpR}} 0
\end{array}
\]
The second line of agreement on actions is to stop merging of the following two actions:
\[
\begin{array}{@{}l@{}}
\cass{A}{}: \vx \pt_{\emptyset} 0 \sep \vy \pt_{\emptyset} 0 \transfersto  \vx \pt_{\Set{\fpR}} 0 \sep \vy \pt_{\Set{\fpW}} 1 \sep \cass{C}{}\\
\cass{B}{}: \vx \pt_{\emptyset} 0 \sep \vy \pt_{\emptyset} 0 \sep \cass{C}{} \transfersto  \vx \pt_{\Set{\fpW}} 1 \sep \vy \pt_{\Set{\fpR}} 0
\end{array}
\]
Instead of cross-check pre against another's post, we should check the differential.
}
For two actions to agree, their pre- and post-conditions must agree on the heaps and the capabilities.
Additional, the differential of capabilities of these two actions should also agree, so that when merging these two actions, the merged result does not have invalid capabilities transfer.
\end{defn}

\begin{defn}[Merge actions]
The \emph{merge actions}, specifically merge the right-hand side to the left-hand side, is defined as follows:
\[
    \begin{rclarray}
        \funcn{merge\_action} & : & \Actions \times \Actions \parfun \Actions \\
        \func{merge\_action}{(\ls_{l}^{p}, \ls_{l}^{q} ),(\ls_{r}^{p}, \ls_{r}^{q} )} & \defeq &
        \begin{cases}
        ( \func{merge\_state}{\ls_{l}^{p}, \ls_{r}^{p}}, \func{merge\_state}{\ls_{l}^{q}, \ls_{r}^{q}} )  &  \pred{agree\_action}{(\ls_{l}^{p}, \ls_{l}^{q} ),(\ls_{r}^{p}, \ls_{r}^{q} )} \\
        \text{undefined} & \text{otherwise} \\
        \end{cases} \\
    \end{rclarray}
\]
where,
\[
    \begin{rclarray}
        \func{merge\_state}{(\fph_{l}, \ca_{l} ),(\fph_{r}, \ca_{r})} & \defeq & (\func{eager\_merge\_heap}{\fph_{l},\fph_{r}}, \ca_{l} \composeC \ca_{r} ) \\
        \func{eager\_merge\_heap}{\fph_{l}, \fph_{r}} & \defeq & \lambda \loc \ldotp 
        \begin{cases}
            \fph_{r}(\loc) & \loc \in \dom(\fph_{l}) \cap \pred{ws}{\fph_{r}} \\
            \fph_{l}(\loc) & \loc \in \dom(\fph_{l}) \setminus \pred{ws}{\fph_{r}} \\
            \text{undefined} & \loc \notin \dom(\fph_{l})
        \end{cases}
        \\
    \end{rclarray}
\]
\end{defn}





%Given the \emph{merge}for \( \fphp \), we can define \emph{merge} on transitions.
%The predicate \( \predn{noFingerPrint} \) asserts the read set and write set are empty sets, and \( \predn{noWriteConflict} \) asserts the write sets are disjointed.
%The predicate \( \predn{agree} \) has similar meaning as overlapped separation found in CoLoSL, which means that the state of the overlapped parts must agree.
%To merge two transactions, if the pre-conditions agree and both of them have no fingerprint, and if the post-conditions agree and they write to different locations, the merged result is a set of transitions including the left-hand side and another transition by merging the post-condition of right-hand side to left-hand side.
%Otherwise, the merge only returns a singleton set of left-hand side.

%\[
    %\begin{rclarray}
        %\pred{noFingerPrint}{\fphp} & \defeq & \exists \rs, \ws, \ldotp \fphp = (\stub, \rs, \ws) \land \rs = \ws = \emptyset \\
        %\pred{noWriteConflict}{\fphp_{l}, \fphp_{r}} & \defeq & \exists \ws_{l} = \fphp_{l}\projection{3}, \ws_{r} = \fphp_{r}\projection{3} \ldotp \ws_{l} \cap \ws_{r} = \emptyset \\
        %\pred{agreeState}{\fphp_{l}, \fphp_{r}} & \defeq & \exists \fphp'_{l}, \fphp_{m}, \fphp'_{r}, \fphp \ldotp \fphp_{l} = \fphp'_{l} \compose_{\fphp} \fphp_{m} \land \fphp_{r} = \fphp'_{r} \compose_{\fphp} \fphp_{m} \land \fphp = \fphp'_{l} \compose_{\fphp} \fphp_{m} \compose_{\fphp} \fphp'_{r} \\
        %\pred{agreeCapability}{\cstate_{l}, \cstate_{r}} & \defeq & \exists \cstate'_{l}, \cstate_{m}, \cstate'_{r}, \fphp \ldotp \cstate_{l} = \cstate'_{l} \compose_{\cstate} \cstate_{m} \land \cstate_{r} = \cstate'_{r} \compose_{\cstate} \cstate_{m} \land \cstate = \cstate'_{l} \compose_{\cstate} \cstate_{m} \compose_{\cstate} \cstate'_{r} \\
        %\pred{agree}{\fphpcap_{l},\fphpcap_{r}} & \defeq & \pred{agreeState}{\fphpcap_{l}\projection{1}, \fphpcap_{r}\projection{1}} \land \pred{agreeCapability}{\fphpcap_{l}\projection{2}, \fphpcap_{r}\projection{2}} \\
        %( \fphpcap_{\lpre}, \fphpcap_{\lpost} ) \bmrg ( \fphpcap'_{\lpre}, \fphpcap'_{\lpost} ) & \defeq & \Set{( \fphpcap_{\lpre}, \fphpcap_{\lpost} )} \cup \Set{(\fphpcap_{\lpre}, ( \fphp_{\lpost} \wmrg \fphp'_{\lpost}, \cstate_{q} \compose_{\cstate} \cstate'_{q} ) ) \middle| 
        %\begin{array}{@{}l@{}}
            %\pred{noWriteConflict}{\fphp'_{\lpre}, \fphp'_{\lpost} } \land {} \\
            %\pred{agree}{\fphpcap_{\lpre}, \fphpcap_{\lpost}} \land \pred{agree}{\fphpcap'_{\lpre}, \fphpcap'_{\lpost}} 
        %\end{array}
    %} \\
    %\end{rclarray}
%\]

%The repartition is redefined by adding a merging process.
%The notation \( \clps{\world} \) collapses a world to a time-stamp heap and capabilities by compositing the private logical state \( \lstate' \) and all the shared logical states \( \sstate(\rid_{i}) \).
%To simplify we reuse the same notation for \( \clps{( \world, \ts) } \), it further collapses the time-stamp heap to a plain heap by taking a snapshot at the time \( \ts \).
%The lift of a plain heap is a set of all possible worlds with their times that collapse to the plain heap with any possible capabilities, and similarly the lift of a plain heap with its read and write sets is the lift of the plain heap but lose the information about read and write sets.
%Given that \( \fphpcap \) talks about interference, either pre- or post-condition, of a certain region, the lift of \( \fphpcap \) is all possible worlds with their times where the lift of the plain heap, i.e.\ the first projection of \( \fphpcap \) is subset of the time-stamp heap corresponding to the region \( \rid \) and the capabilities of \( \fphpcap \), the second projection, is the subset of the capabilities of region \( \rid \).

%The repartition means, for all possible world and time, (\world, \ts), that satisfies global assertion \( \gpre \), there exist a heap with its read set and write set, \( \fphp \), that satisfies local assertion \( \lpre \), \( \fphp' \) for assertion \( \lpost \) and a transition \( (\fphpcap, \fphpcap' ) \) that is allowed by the guarantees.
%The \( \fphp \) should agree with \( \fphpcap \), which means \( \fphp = \fphpcap\projection{1} \) and similarly \( \fphp' = \fphpcap'\projection{1} \).
%Also, the \( (\world, \ts) \) corresponding to \( \gpre \) should agree with the pre-condition of the transition, i.e.\ \( (\world, \ts) \in \lift{\fphpcap} \).
%Then for all possible merging between transition \( (\fphpcap, \fphpcap' ) \) and relies, there must exist a corresponding world and its time satisfies the global assertion \( \gpost \).
%It means that the world and its time \( (\world', \ts') \) is in the lift of post-condition of the merging result \( \fphpcap'' \).
%At last the worlds \( \world \) and \( \world' \) should be balanced, meaning no creation or destruction of resources.

%%Given the \( \fphp \), if there exists a \( \fphp' \) that associated with \( \lpost \) and the transition \( (\fphp, \fphp') \)  is allowed by the guarantees \( \grte(\world) \), then for all the possible post-state \( \fphp'' \) by merging the transition \( (\fphp, \fphp') \) with relies, there must exist a world and its time \( (\world', \ts') \) that satisfies global post-condition \( \gpost \) and their collation equals to the first projection of \( \fphp'' \) which is the plain heap.

%\[
    %\begin{rclarray}
        %\clps{\world} & \defeq & (\tshp, \cstate) \ \texttt{where} \ \exists \sstate, \lstate, \lstate', \rid_{0}, \dots, \rid_{n} \ldotp \\
                      %& & \qquad \qquad \world = (\sstate, \lstate') \land \Set{\rid_{0}, \dots, \rid_{n}} = \dom(\sstate) \land \lstate = \lstate' \compose_{\lstate} \sstate(\rid_{1}) \compose_{\lstate} \dots \compose_{\lstate} \sstate(\rid_{n})\\
                             %& & \qquad \qquad \tshp = \lstate\projection{1} \land \cstate = \lstate\projection{2} \\
        %\clps{(\world, \ts)} & \defeq & ( \hp,\cstate ) \ \texttt{where} \ \hp = \func{startstate}{\clps{\world}\projection{1}, \ts} \land \cstate = \clps{\world}\projection{2} \\
        %\clps{\fphpcap} & \defeq & ( \hp,\cstate ) \ \texttt{where} \ \hp = \fphp\projection{1}\projection{1} \land \cstate = \fphpcap\projection{2} \\
        %%\lift{\hp} & \defeq & \Set{(\world, \ts) \middle| ( \hp , \cstate ) = \clps{(\world, \ts)}}\\
        %%\lift{\fphp} & \defeq & \lift{\fphp\projection{1}} \\
        %%\lift{\fphpcap} & \defeq &  \Set{(\world, \ts) \middle| \exists \rid, \tshp, \cstate \ldotp \world\projection{1}(\rid) = ((\tshp, \cstate), \stub) \land \lift{\fphpcap\projection{1}} \subseteq \tshp \land \fphpcap\projection{2} \subseteq \cstate}\\
        %\pred{balance}{\world_{1}, \world_{2}} & \defeq & \exists \tshp_{1}, \cstate_{1}, \tshp_{2}, \cstate_{2} \ldotp (\tshp_{1}, \cstate_{1}) = \clps{\world_{1} } \land  (\tshp_{2}, \cstate_{2}) = \clps{\world_{2} } \land \dom(\tshp_{1}) = \dom(\tshp_{2} ) \land \cstate_{1} = \cstate_{2} \\
        %\repartition{\gpre}{\gpost}{\lpre}{\lpost} & \iff & \forall \lenv, \stk, \world, \ts  \ldotp (\world, \ts) \in \eval{\gpre}_{\lenv, \stk} \ldotp \\
                                                   %& & \implies \exists \lenv', \stk', \fphp \in \eval{\lpre}_{\lenv, \stk}, \hpfp' \in \eval{\lpost}_{\lenv', \stk'}, \fphpcap, \fphpcap', \fphpcap_{r} \ldotp \\
                                                   %& & \qquad (\fphpcap, \fphpcap' ) \in \grte(\world) \land \fphp = \fphpcap\projection{1} \land \fphp' = \fphpcap'\projection{1} \land \clps{(\world, \ts)} = \clps{\fphpcap \compose_{\fphpcap} \fphpcap_{r}}\\ 
                                                   %& & \implies \forall \fphpcap'' \ \ldotp ( \stub, \fphpcap'') \in ( (\fphpcap, \fphpcap') \bmrg \rely(\world) ) \\
                                                   %& & \exists \world',\ts' \ldotp  \ts < ts' \land (\world',\ts') \in \eval{\gpost}_{\lenv', \stk'} \land \clps{(\world', \ts' )} = \clps{\fphpcap''\compose_{\fphpcap} \fphpcap_{r}} \land \pred{balance}{\world, \world'}
    %\end{rclarray}
%\]

%The relies and guarantees.

%\[
    %\begin{rclarray}
        %\grte & \defeq & \lambda \world \ldotp \Set{(\fphpcap, \fphpcap') \middle| \forall \capb \in \world\projection{2}\projection{2} \land (\fphpcap, \fphpcap') \in \world\projection{1}(\capb\projection{1})\projection{2}(\capb)}\\
        %\rely & \defeq & \lambda \world \ldotp \Set{(\fphpcap, \fphpcap') \middle| \forall \capb \ldotp \exists \capb' \in \world\projection{2}\projection{2} \ldotp \capb\projection{1} = \capb'\projection{1} \land ((\capb\projection{2}, \capb\projection{3}) \compose_{\setcap} (\capb'\projection{2}, \capb'\projection{3}))\isdef \land (\fphpcap, \fphpcap') \in \world\projection{1}(\capb\projection{1})\projection{2}(\capb')}
    %\end{rclarray}
%\]

%\section{temp}

%To merge two actions \( \lpre \transfersto \lpost \) and \( \lpre' \transfersto \lpost' \), it requires the pre-conditions agrees, which means that if they describe some common heaps, the state of the common part should be consistent.
%Then if the post-conditions write to different locations, the \emph{merge} (to the left) operator \( \wmrg \) returns a new action where the effect of right hands side propagate to the left hand side.
%\sx{Not sure how to do it properly considering there is \(\vec{x}\) binder and extension \(\vec{y}\) }.

%\[
    %\begin{rclarray}
        %\func{writeSet}{\lvar \pointsto_{\fp \cup \Set{\fpW}} \stub } & \defeq & \Set{\lvar} \\
        %\func{writeSet}{\lvar \pointsto_{\fp \setminus \Set{\fpW}} \stub } & \defeq & \emptyset \\
        %\func{writeSet}{ \lpre \sep \lpost } & \defeq & \func{writeSet}{\lpre} \uplus \func{writeSet}{\lpost} \\
        %\lpre \bmrg \lpost & \defeq & 
        %\begin{cases}
            %( \lpre' \bmrg \lpost' ) \sep \lvar \pointsto_{\fp \cup \Set{\fpW}} \stub  &  ( \lpre = \lpre' \sep \lvar \pointsto_{\stub} \stub ) \land  ( \lpost = \lpost' \sep \lvar \pointsto_{\fp \cup \Set{\fpW}} \stub ) \\
            %\lpre & o.w. \\
        %\end{cases} \\
        %\pred{agree}{\lpre , \lpost} & \defeq & \exists \lpre', \lpost', \lframe, m \ldotp ( \lpre = \lpre \sep \lframe ) \land ( \lpost = \lpost' \sep \lframe)  \land ( m = \lpre' \sep \lpost' \sep \lframe ) \\
        %( \lpre \transfersto \lpost ) \wmrg ( \lpre' \transfersto \lpost' ) & \defeq & \Set{ \lpre \transfersto \lpost } \cup \Set{\lpre \transfersto (\lpost \bmrg \lpost') \middle| \pred{agree}{\lpre , \lpre'} \land \func{writeSet}{\lpost} \cap \func{writeSet}{\lpost'} = \emptyset}
    %\end{rclarray}
%\]

