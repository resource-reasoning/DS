\section{Assertion and Rules\label{sec:assertion}}

Before introducing assertion, we extend arithmetic expressions with logical variables, ranging over \( \lvar \).

\[
    \begin{syntax}{\expr}
        \lvar \quad | \quad \dots 
    \end{syntax}
\]

Assume a logical environment \( \lenv \), we extend the evaluation of arithmetic expressions.

\[
\begin{rclarray}
    \eval{\lvar}_{\lenv, \stk} & \defeq & \lenv(\lvar)
\end{rclarray}
\]

\subsection{Local/Transaction}

Local assertions, also transaction assertions, describe the state inside transactions.

\[ 
    \begin{rclarray}
        \fp \subseteq \Fingerprint & \defeq & \Set{\wfp,\rfp} \\
        \lpre , \lpost \in \Localassertion & \defeq & 
                  \assfalse \quad                  |
            \quad \asstrue \quad                   |
            \quad \assemp \quad                    |
            \quad \expr \pt_{\fp} \expr \quad      | 
            \quad \lpre \sep \lpost \quad          | 
            \quad \lpre \land \lpost \quad         | \\
            & &   \lpre \lor \lpost \quad          |
            \quad \exists \lvar \ldotp \lpre \quad |
    \end{rclarray}
\]

We define the order of fingerprint \( \fp \) like follows.
\begin{center}
    \begin{tikzpicture}
        \node (emp) {\(\emptyset\)};
        \node[above right=0.3cm and 0.3cm of emp] (r) {\(\Set{\rfp}\)};
        \node[above left=0.3cm and 0.3cm of emp] (w) {\(\Set{\wfp}\)};
        \node[above=0.3cm of r] (rw) {\(\Set{\rfp, \wfp}\)};
        
        \draw[->] (emp) -- (r);
        \draw[->] (emp) -- (w);
        \draw[->] (r) -- (rw);
    \end{tikzpicture}
\end{center}
Given the order we define a left merge operator on fingerprints.
\[
    \begin{rclarray}
        \fp_{1} \fpmrg \fp_{2} & \defeq & 
        \begin{funcarray}
            \fp_{1} \cup \fp_{2}  & \exists \fp \ldotp \fp_{1} \sqsubseteq \fp \land  \fp_{2} \sqsubseteq \fp \\
            \fp_{1}  & o.w. \\
        \end{funcarray}
    \end{rclarray}
\]



The semantics of local assertions, where \( \rs \) and \( \ws \) represent the read and write sets respectively.

\[
    \begin{array}{l c l}
        \lenv, \stk, \hp, \rs, \ws \models_{l} \assfalse & \iff & \texttt{never} \\
        \lenv, \stk, \hp, \rs, \ws \models_{l} \asstrue & \iff & \texttt{always} \\
        \lenv, \stk, \hp, \rs, \ws \models_{l} \assemp & \iff & \hp = \emptyset \land \rs = \emptyset \land \ws = \emptyset \\
        \lenv, \stk, \hp, \rs, \ws \models_{l} \expr_{1} \pt_{\fp} \expr_{2} & \iff & \hp = \Set{\eval{\expr_{1}}_{\lenv, \stk} \mapsto \eval{\expr_{2}}_{\lenv, \stk}} \land {} \\
                                                                             & & \fp = \emptyset \implies \rs = \emptyset \land \ws = \emptyset \\
                                                                             & & \fp = \Set{\rfp} \implies \rs = \Set{\eval{\expr_{1}}_{\lenv, \stk}} \land \ws = \emptyset \\
                                                                             & & \fp = \Set{\wfp} \implies \rs = \emptyset \land \ws = \Set{\eval{\expr_{1}}_{\lenv, \stk}}  \\
                                                                             & & \fp = \Set{\rfp,\wfp} \implies \rs = \Set{\eval{\expr_{1}}_{\lenv, \stk}} \land \ws = \Set{\eval{\expr_{1}}_{\lenv, \stk}}  \\
        \lenv, \stk, \hp, \rs, \ws \models_{l} \lpre \sep \lpost & \iff &  \exists \hp_{1}, \hp_{2}, \rs_{1}, \rs_{2}, \ws_{1}, \ws_{2} \ldotp \\
                                                                 & & \hp = \hp_{1} \uplus \hp_{2} \land \rs = \rs_{1} \uplus \rs_{2} \land \ws = \ws_{1} \uplus \ws_{2} \land {} \\
                                                                 & &  ( \lenv, \stk, \hp_{1}, \rs_{1}, \ws_{1} \models_{l} \lpre ) \land ( \lenv, \stk, \hp_{2}, \rs_{2}, \ws_{2} \models_{l} \lpost ) \\
        \lenv, \stk, \hp, \rs, \ws \models_{l} \lpre \land \lpost & \iff & ( \lenv, \stk, \hp, \rs, \ws \models_{l} \lpre ) \land ( \lenv, \stk, \hp, \rs, \ws \models_{l} \lpost ) \\
        \lenv, \stk, \hp, \rs, \ws \models_{l} \lpre \lor \lpost & \iff & ( \lenv, \stk, \hp, \rs, \ws \models_{l} \lpre ) \lor ( \lenv, \stk, \hp, \rs, \ws \models_{l} \lpost ) \\
        \lenv, \stk, \hp, \rs, \ws \models_{l} \exists \lvar \ldotp \lpre & \iff & \exists \val \ldotp \lenv\remapsto{\lvar}{\val}, \stk, \hp, \rs, \ws \models_{l} \lpre \\
    \end{array}
\]

The proof rules are standard except \rl{TRDeref} and \rl{TRMutate}.
The \rl{TRDeref} rule add read finger-print in finger-tracking set, only if there is no write finger-print.
This is because once a location has been re-written, the rest read are considered as local operations, while the finger-print only records those operations might have effect on global state.

\[
    \infer[\rl{TRDeref}]{%
        \judgement{}{\var = \dontcare \land \expr_{1} \pt_{\fp} \expr_{2} }{ \pderef{\var}{\expr_{1}} }{\var = \expr_{2} \land \expr_{1} \pt_{\fp \fpmrg \Set{\rfp}} \expr_{1} }
    }{%
        \var \notin \func{fv}{\expr_{1}} \quad
        \var \notin \func{fv}{\expr_{2}} \quad 
    }
\]

\[
    \infer[\rl{TRMutate}]{%
        \judgement{}{\expr_{1} \pt_{\fp} \dontcare }{ \pmutate{\expr_{1}}{\expr_{2}} }{ \expr_{1} \pt_{\fp \fpmrg \Set{\wfp}} \expr_{1} }
    }{}
\]

\subsection{Global/Program}

\[
    \begin{rclarray}
        \Regionid & \defeq & \Set{\rid, \dots} \\
        \Capabilityid & \defeq & \Set{\capid, \dots } \\
            \gpre , \gpost \in \Globalassertion & \defeq & 
                  \assfalse \quad                         |
            \quad \asstrue \quad                          |
            \quad \assemp \quad                           |
            \quad \expr \pointsto \expr \quad             |
            \quad \boxass{\gpre}{\intf}{\rid} \quad       |
            \quad \capb{\capid(\vec{\lvar})}_{\rid} \quad | \\
            & &  \gpre \sep \gpost \quad                  |
            \quad \gpre \land \gpost \quad                |
            \quad \gpre \lor \gpost \quad                 |
            \quad \exists \lvar \ldotp \gpre \quad        | \\
            \intf \in \Interference & \defeq & 
                  \emptyset \quad |
                  \quad \Set{ \capb{\capid(\vec{\lvar})} : \exists \vec{y} \ldotp \lpre \transfersto \lpost } \uplus \intf \quad | 
    \end{rclarray}
\]

The global assertion should be interpreted as a tuple consisting of world and a set of owned capabilities.
A capability is a pair of capability identifier and a vector of values as parameters.
\textbf{How to give semantics to a negative assertion?}

\[
    \begin{rclarray}
        \captuple \in \Capability & \defeq & \Capabilityid \times \Val^{*} \\
        \world = (\rstate, \wcap) \in \World & \defeq & ( \Regionid \parfinfun \Timestampheap \times \Capabilityid ) \times ( \Regionid \parfinfun \Capability )
    \end{rclarray}
\]

The composition of capabilities and worlds.
\[
    \begin{rclarray}
        \wcap_{1} \compos \wcap_{2} & \defeq & 
        \begin{funcarray}
        \lambda \rid \ldotp 
            \begin{funcarray}
                \cstate_{1}(\rid) & \rid \in \wcap_{1} \land \rid \notin \wcap_{2} \\
                \cstate_{2}(\rid) & \rid \notin \wcap_{1} \land \rid \in \wcap_{2} \\
                \cstate_{1}(\rid) \compos \wcap_{2}(\rid) & \rid \in \wcap_{1} \cap \wcap_{2} \\
            \end{funcarray} & \forall \rid \in \wcap_{1} \cap \wcap_{2} \ldotp ( \wcap_{1}(\rid) \compos \wcap_{2}(\rid) )\isdef \\
            \texttt{undefined} & o.w. \\
        \end{funcarray} \\
        \world_{1} \compos \world_{2} & \defeq & 
        \begin{funcarray}
            (\rstate, \wcap_{1} \compos \wcap_{2}) & \world_{1} = (\rstate, \wcap_{1}) \land \world_{2} = (\rstate, \wcap_{2}) \land (\wcap_{1} \compos \wcap_{2} )\isdef \\
            \texttt{undefined} & o.w. \\
        \end{funcarray}
    \end{rclarray}
\]


\[
    \begin{array}{l c l}
        \lenv, \stk, \tshp, \ts, \rstate, \cstate \models_{g} \assfalse & \iff & \texttt{never} \\
        \lenv, \stk, \tshp, \ts, \rstate, \cstate \models_{g} \asstrue & \iff & \texttt{always} \\
        \lenv, \stk, \tshp, \ts, \rstate, \cstate \models_{g} \assemp & \iff & \tshp = \emptyset \land \rstate = \emptyset \land \cstate = \emptyset \\
        \lenv, \stk, \tshp, \ts, \rstate, \cstate \models_{g} \expr_{1} \pt \expr_{2} & \iff & \dom(\tshp) = \Set{ \loc } \land \tshp(\loc)(\ts') =  \val \land \rstate = \emptyset \land \cstate = \emptyset \\
                                                             & & \texttt{where} \ \loc = \eval{\expr_{1}}_{\lenv, \stk} \land \val = \eval{\expr_{2}}_{\lenv, \stk} \land \ts' \leq \ts \land {} \\
                                                             & & \tshp(\loc)(\ts') = (\val,\dontcare, \dontcare) \land \forall \ts'' \in ( \ts', \ts) \ldotp \tshp(\loc)(\ts'')\undef \\
        \lenv, \stk, \tshp, \ts, \rstate, \wcap \models_{g} \boxass{\gpre}{\intf}{\rid} & \iff & \exists \tshp', \rstate', \cstate' \ldotp \lenv, \stk, \tshp \uplus \tshp' , \ts, \rstate', \cstate \compos \cstate' \models_{g} \gpre \land \rstate = \rstate' \uplus \Set{\rid \mapsto ( \tshp', \cstate' ) }\\
        \lenv, \stk, \tshp, \ts, \rstate, \cstate \models_{g} \capb{\capid(\vec{\lvar})}_{\rid} & \iff & \tshp = \emptyset \land \rstate = \emptyset \land \cstate = \Set{\rid \mapsto (\capid, \vec{\val}) } \\
        \lenv, \stk, \tshp, \ts, \rstate, \cstate \models_{g} \gpre \sep \gpost & \iff & \exists \tshp_{1}, \tshp_{2}, \rstate_{1}, \rstate_{2}, \cstate_{1}, \cstate_{2} \ldotp \tshp = \tshp_{1} \uplus \tshp_{2} \land \rstate = \rstate_{1} \compos \rstate_{2} \land \cstate = \cstate_{1} \compos \cstate_{2} \land {} \\
                                                                               & & ( \lenv, \stk, \tshp_{1}, \ts, \rstate_{1}, \cstate_{1} \models_{g} \gpre ) \land ( \lenv, \stk, \ts, \tshp_{2}, \rstate_{2}, \cstate_{2} \models_{g} \gpost ) \\
        \lenv, \stk, \tshp, \ts, \rstate, \cstate  \models_{g} \gpre \land \gpost & \iff & ( \lenv, \stk, \tshp, \ts, \rstate, \cstate \models_{g} \gpre ) \land ( \lenv, \stk, \tshp, \ts, \rstate, \cstate \models_{g} \gpost ) \\
        \lenv, \stk, \tshp, \ts, \rstate, \cstate \models_{g} \gpre \lor \gpost & \iff & ( \lenv, \stk, \tshp, \ts, \rstate, \cstate \models_{g} \gpre ) \lor ( \lenv, \stk, \tshp, \ts, \rstate, \cstate \models_{g} \gpost ) \\
        \lenv, \stk, \tshp, \ts, \rstate, \cstate \models_{g} \exists \lvar \ldotp \gpre & \iff & \exists \val \ldotp \lenv\remapsto{\lvar}{\val}, \stk, \tshp, \ts, \rstate, \cstate \models_{g} \gpre \\
    \end{array}
\]

The first element, also pre-condition, only contains empty label, \( \dontcare \pt_{\emptyset} \dontcare \).
The second element, also called post-condition, should contain the same resource as pre-condition and if locations have been updated, they must be tagged with \( \wfp \).

\[
    \begin{rclarray}
        \eval{\capb{\capid(\vec{\lvar})}_{r} : \exists \vec{y} \ldotp \lpre \transfersto \lpost }_{\lenv, \stk} & \defeq & \lambda \vec{\val} \ldotp \Set{(\hp, \hp') \middle| 
        \begin{array}{@{}l@{}}
            \exists \rs', \ws', \vec{\val}', \lenv' = \lenv[\vec{\var} \mapsto \vec{\val}, \vec{y} \mapsto \vec{\val}'] \ldotp \\
            \lenv', \stk, \hp, \emptyset,\emptyset \models_{l} \lpre \land \lenv', \stk, \hp', \rs', \ws' \models_{l}\lpost \land {}\\
            \dom(\hp) = \dom(\hp') \land \hp \setminus \Set{\loc \mapsto \dontcare | \loc \in \ws} = \hp' \setminus \Set{\loc \mapsto \dontcare | \loc \in \ws}  
        \end{array}} 
    \end{rclarray}
\]

The repartition is redefined by adding a merging process.

\[
    \infer[\rl{PRCommit}]{%
        \judgement{}{\gpre}{ \ptrans{\cmd} }{\gpost}
    }{%
        \begin{array}{l}
            \judgement{}{\lpre}{\cmd}{\lpost} \quad 
            \vdash \gpre \Rrightarrow^{\{\lpre\}\{\lpost\}} \gpost
        \end{array}
    }
\]

Before defining repartition, we define the meaning of \emph{merge} by first giving a syntactic rule.
To merge two actions \( \lpre \transfersto \lpost \) and \( \lpre' \transfersto \lpost' \), it requires the pre-conditions agrees, which means that if they describe some common heaps, the state of the common part should be consistent.
Then if the post-conditions write to different locations, the \emph{merge} (to the left) operator \( \actmrg \) returns a new action where the effect of right hands side propagate to the left hand side.

\[
    \begin{rclarray}
        \func{writeSet}{\lvar \pointsto_{\fp \cup \Set{\wfp}} \dontcare } & \defeq & \Set{\lvar} \\
        \func{writeSet}{\lvar \pointsto_{\fp \setminus \Set{\wfp}} \dontcare } & \defeq & \emptyset \\
        \func{writeSet}{ \lpre \sep \lpost } & \defeq & \func{writeSet}{\lpre} \uplus \func{writeSet}{\lpost} \\
        \lpre \assmrg \lpost & \defeq & 
        \begin{funcarray}
            ( \lpre' \assmrg \lpost' ) \sep \lvar \pointsto_{\fp \cup \Set{\wfp}} \dontcare  &  ( \lpre = \lpre' \sep \lvar \pointsto_{\dontcare} \dontcare ) \land  ( \lpost = \lpost' \sep \lvar \pointsto_{\fp \cup \Set{\wfp}} \dontcare ) \\
            \lpre & o.w. \\
        \end{funcarray} \\
        \pred{agree}{\lpre , \lpost} & \iff & \exists \lpre', \lpost', \lframe \ldotp ( \lpre = \lpre \sep \lframe ) \land ( \lpost = \lpost' \sep \lframe)  \land (\lpre' \sep \lpost' \sep \lframe)\isdef \\
        ( \lpre \transfersto \lpost ) \actmrg ( \lpre' \transfersto \lpost' ) & \defeq & 
        \begin{funcarray}
            \lpre \transfersto (\lpost \assmrg \lpost') & \pred{agree}{\lpre , \lpre'} \land \func{writeSet}{\lpost} \cap \func{writeSet}{\lpost'} = \emptyset \\
            \texttt{undefined} & o.w.
        \end{funcarray}
    \end{rclarray}
\]

\[
    \begin{rclarray}
        \rely \vdash \gpre \Rrightarrow^{\{\lpre\}\{\lpost\}} \gpost & \iff & \exists \lenv, \lenv', \stk, \stk', \tshp, \tshp', \ts, \ts' \ldotp   \lenv, \stk, \tshp, \ts \models_{g} \gpre \land \lenv', \stk', \tshp', \ts' \models_{g} \gpost \land \ts < \ts' \\
                                                                     & & \implies \exists \hp = \func{startstate}{\tshp, \ts}, \hp' = \func{startstate}{\tshp', \ts'}, \hp'', \ws',\rs' \ldotp \\
                                                                     & & \lenv, \stk, \hp, \emptyset, \emptyset \models_{l} \lpre \land \lenv', \stk', \hp'', \rs', \ws' \models_{l} \lpost \land {} \Set{\loc \mapsto \val \middle| \loc \in \ws' \land \hp''(\loc) = \val} \subseteq \hp' \land {} \\
                                                                     & & \forall \lpre_{r}, \lpost_{r} \ldotp (\lpre_{r} \transfersto \lpost_{r}) \in \rely \land \pred{compatible}{\lpre,\lpost, \lpre_{r}, \lpost_{r}} \land \exists \lenv_{r}, \stk_{r}, \hp_{r}, \rs_{r}, \ws_{r} \ldotp \\
                                                                     & & \lenv_{r}, \stk_{r}, \hp_{r}, \rs_{r}, \ws_{r} \models_{l} \lpost_{r} \land \Set{\loc \mapsto \val \middle| \loc \in \ws_{r} \cap \dom(\hp'') \land \hp_{r}(\loc) = \val} \subseteq \hp' \\
    \end{rclarray}
\]

The \predn{compatible}, intuitively, means all the assertions within the pre-conditions \( \lpre_{1} \) and \( \lpre_{2} \) must be tagged with empty-set and if they assert overlapped heap, the overlapped part must agree.
Then, the post-conditions \( \lpost_{1} \) and \( \lpost_{2} \) write to different locations.
Note that for post-conditions, it is enough to only check the finger-print because of the constraint of actions and the constraint of pre-conditions.

\[
    \begin{rclarray}
        \pred{compatible}{\lpre_{1},\lpost_{1}, \lpre_{2}, \lpost_{2}} & \defeq & \pred{pre}{\lpre_{1}, \lpre_{2}} \land \pred{post}{\lpost_{1},\lpost_{2}} \\
        \pred{pre}{\lpre_{1},\lpre_{2}} & \defeq & \forall \lenv_{1}, \lenv_{2}, \stk_{1}, \stk_{2}, \hp, \hp_{1}, \hp_{2} \ldotp \lenv_{1}, \stk_{1}, \hp \uplus \hp_{1}, \emptyset, \emptyset \models_{l} \lpre_{1} \land {} \\
                                        & & \lenv_{2}, \stk_{2}, \hp \uplus \hp_{2}, \emptyset, \emptyset \models_{l} \lpre_{2} \land ( \hp \uplus \hp_{1} \uplus \hp_{2} )\isdef \\
        \pred{post}{\lpost_{1},\lpost_{2}} & \defeq & \forall \lenv_{1}, \lenv_{2}, \stk_{1}, \stk_{2}, \hp_{1}, \hp_{2}, \rs_{1}, \rs_{2}, \ws_{1}, \ws_{2} \ldotp \lenv_{1}, \stk_{1}, \hp \uplus \hp_{1}, \rs_{1}, \ws_{1} \models_{l} \lpre_{1} \land {} \\
                                          & & \lenv_{2}, \stk_{2}, \hp \uplus \hp_{2}, \ws_{2}, \rs_{2} \models_{l} \lpre_{1} \land \ws_{1} \cap \ws_{2} = \emptyset \\
    \end{rclarray}
\]
