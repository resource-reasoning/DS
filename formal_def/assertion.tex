\section{Assertion and Rules\label{sec:assertion}}

Before introducing assertion, we extend arithmetic expressions with logical variables, ranging over \( \lvar \).

\[
    \begin{syntax}{\expr}
        \lvar \quad | \quad \dots 
    \end{syntax}
\]

Assume a logical environment \( \lenv \), we extend the evaluation of arithmetic expressions.

\[
\begin{rclarray}
    \eval{\lvar}_{\lenv, \stk} & \defeq & \lenv(\lvar)
\end{rclarray}
\]

\subsection{Local/Transaction}

Local assertions, also transaction assertions, describe the state inside transactions.

\[ 
    \begin{rclarray}
        \lpre , \lpost \in \Localassertion & \defeq & 
                  \assfalse \quad                  |
            \quad \asstrue \quad                   |
            \quad \assemp \quad                    |
            \quad \expr \pt_{\op} \expr \quad      | 
            \quad \lpre \sep \lpost \quad          | 
            \quad \lpre \land \lpost \quad         | \\
            & &   \lpre \lor \lpost \quad          |
            \quad \exists \lvar \ldotp \lpre \quad |
    \end{rclarray}
\]                                  

where,

\[
    \op \subseteq \Set{\wop,\rop}
\]

We also define the order of \( \op \) like follows,

\begin{tikzpicture}
    \node (emp) {\(\emptyset\)};
    \node[above right=0.3cm and 0.3cm of emp] (r) {\(\Set{\rop}\)};
    \node[above left=0.3cm and 0.3cm of emp] (w) {\(\Set{\wop}\)};
    \node[above=0.3cm of r] (rw) {\(\Set{\rop, \wop}\)};
    
    \draw[->] (emp) -- (r);
    \draw[->] (emp) -- (w);
    \draw[->] (r) -- (rw);
\end{tikzpicture}



The semantics of local assertions, where \( \rs \) and \( \ws \) represent the read and write sets respectively.

\[
    \begin{array}{l c l}
        \lenv, \stk, \hp, \rs, \ws \models_{l} \assfalse & \iff & \texttt{never} \\
        \lenv, \stk, \hp, \rs, \ws \models_{l} \asstrue & \iff & \texttt{always} \\
        \lenv, \stk, \hp, \rs, \ws \models_{l} \assemp & \iff & \hp = \emptyset \land \rs = \emptyset \land \ws = \emptyset \\
        \lenv, \stk, \hp, \rs, \ws \models_{l} \expr_{1} \pt_{\op} \expr_{2} & \iff & \hp = \Set{\eval{\expr_{1}}_{\lenv, \stk} \mapsto \eval{\expr_{2}}_{\lenv, \stk}} \land {} \\
                                                                             & & \op = \emptyset \implies \rs = \emptyset \land \ws = \emptyset \\
                                                                             & & \op = \Set{\rop} \implies \rs = \Set{\eval{\expr_{1}}_{\lenv, \stk}} \land \ws = \emptyset \\
                                                                             & & \op = \Set{\wop} \implies \rs = \emptyset \land \ws = \Set{\eval{\expr_{1}}_{\lenv, \stk}}  \\
                                                                             & & \op = \Set{\rop,\wop} \implies \rs = \Set{\eval{\expr_{1}}_{\lenv, \stk}} \land \ws = \Set{\eval{\expr_{1}}_{\lenv, \stk}}  \\
        \lenv, \stk, \hp, \rs, \ws \models_{l} \lpre \sep \lpost & \iff &  \exists \hp_{1}, \hp_{2}, \rs_{1}, \rs_{2}, \ws_{1}, \ws_{2} \ldotp \\
                                                                 & & \hp = \hp_{1} \uplus \hp_{2} \land \rs = \rs_{1} \uplus \rs_{2} \land \ws = \ws_{1} \uplus \ws_{2} \land {} \\
                                                                 & &  ( \lenv, \stk, \hp_{1}, \rs_{1}, \ws_{1} \models_{l} \lpre ) \land ( \lenv, \stk, \hp_{2}, \rs_{2}, \ws_{2} \models_{l} \lpost ) \\
        \lenv, \stk, \hp, \rs, \ws \models_{l} \lpre \land \lpost & \iff & ( \lenv, \stk, \hp, \rs, \ws \models_{l} \lpre ) \land ( \lenv, \stk, \hp, \rs, \ws \models_{l} \lpost ) \\
        \lenv, \stk, \hp, \rs, \ws \models_{l} \lpre \lor \lpost & \iff & ( \lenv, \stk, \hp, \rs, \ws \models_{l} \lpre ) \lor ( \lenv, \stk, \hp, \rs, \ws \models_{l} \lpost ) \\
        \lenv, \stk, \hp, \rs, \ws \models_{l} \exists \lvar \ldotp \lpre & \iff & \exists \val \ldotp \lenv\remapsto{\lvar}{\val}, \stk, \hp, \rs, \ws \models_{l} \lpre \\
    \end{array}
\]

The proof rules are standard except \rl{TRDeref} and \rl{TRMutate}.
The \rf{TRDeref} rule add read finger-print in finger-tracking set, only if there is no write finger-print.
This is because once a location has been re-written, the rest read are considered as local operations, while the finger-print only records those operations might have effect on global state.

\[
    \infer[\rl{TRDeref}]{%
        \judgement{}{\var = \dontcare \land \expr_{1} \pt_{\op} \expr_{2} }{ \pderef{\var}{\expr_{1}} }{\var = \expr_{2} \land \expr_{1} \pt_{\op'} \expr_{1} }
    }{%
        \var \notin \func{fv}{\expr_{1}} \quad
        \var \notin \func{fv}{\expr_{2}} \quad 
        ( \op = \op' \land \wop \in \op ) \lor \op' = \op \cup \Set{\rop}
    }
\]

\[
    \infer[\rl{TRMutate}]{%
        \judgement{}{\expr_{1} \pt_{\op} \dontcare }{ \pmutate{\expr_{1}}{\expr_{2}} }{ \expr_{1} \pt_{\op \cup \Set{\wop}} \expr_{1} }
    }{}
\]

\subsection{Global/Program}

\[
    \begin{rclarray}
        \bpre , \bpost \in \texttt{InBoxAssertion} & \defeq & 
                  \assfalse \quad                     |
            \quad \asstrue \quad                      |
            \quad \assemp \quad                       |
            \quad \expr \pointsto \expr \quad         |
            \quad \bpre \sep \bpost \quad             | 
            \quad \bpre \land \bpost \quad            | \\
            & &   \bpre \lor \bpost \quad             | 
            \quad \exists \lvar \ldotp \bpre \quad    | \\
            \gpre , \gpost \in \Globalassertion & \defeq & 
                  \assfalse \quad                         |
            \quad \asstrue \quad                          |
            \quad \assemp \quad                           |
            \quad \boxass{\bpre}_{\intf}^{\rid} \quad     |
            \quad \capb{\capid(\vec{\lvar})}_{\rid} \quad |
            \quad \gpre \sep \gpost \quad                 |
            \quad \gpre \land \gpost \quad                | \\
            & &   \gpre \lor \gpost \quad                 |
            \quad \exists \lvar \ldotp \gpre \quad        | \\
            \intf_{1}, \intf_{2} \in \Interference & \defeq & 
                  \capb{\capid(\vec{\lvar})} : \exists \vec{y} \ldotp \lpre \transfersto \lpost \quad | 
            \quad \intf_{1}, \intf_{2}
    \end{rclarray}
\]

The semantics of in-box assertions.
\textbf{How to give semantics to a negative assertion?}

\[
    \begin{array}{l c l}
        \lenv, \stk, \tshp, \ts \models_{b} \assfalse & \iff & \texttt{never} \\
        \lenv, \stk, \tshp, \ts \models_{b} \asstrue & \iff & \texttt{always} \\
        \lenv, \stk, \tshp, \ts \models_{b} \assemp & \iff & \hp = \emptyset \\
        \lenv, \stk, \tshp, \ts \models_{b} \expr_{1} \pt \expr_{2} & \iff & \dom(\tshp) = \Set{ \loc } \land \tshp(\loc)(\ts') =  \val \\
                                                             & & \texttt{where} \ \loc = \eval{\expr_{1}}_{\lenv, \stk} \land \val = \eval{\expr_{2}}_{\lenv, \stk} \land \ts' \leq \ts \land {} \\
                                                             & & \tshp(\loc)(\ts') = (\val,\dontcare, \dontcare) \land \forall \ts'' \in ( \ts', \ts) \ldotp \tshp(\loc)(\ts'')\undef \\
        \lenv, \stk, \tshp, \ts \models_{b} \bpre \sep \bpost & \iff & \exists \tshp_{1}, \tshp_{2} \ldotp \tshp = \tshp_{1} \uplus \tshp_{2} \land ( \lenv, \stk, \tshp_{1}, \ts \models_{b} \bpre ) \land ( \lenv, \stk, \tshp_{2}, \ts \models_{b} \bpost ) \\
        \lenv, \stk, \tshp, \ts \models_{b} \bpre \land \bpost & \iff & ( \lenv, \stk, \tshp, \ts  \models_{g} \bpre ) \land ( \lenv, \stk, \tshp, \ts \models_{b} \bpost ) \\
        \lenv, \stk, \tshp, \ts \models_{b} \bpre \lor \bpost & \iff & ( \lenv, \stk, \tshp, \ts  \models_{g} \bpre ) \lor ( \lenv, \stk, \tshp, \ts \models_{b} \bpost ) \\
        \lenv, \stk, \tshp, \ts \models_{b} \exists \lvar \ldotp \bpre & \iff & \exists \val \ldotp \lenv\remapsto{\lvar}{\val}, \stk, \tshp, \ts \models_{b} \bpre \\
    \end{array}
\]

The global assertion should be interpreted as a tuple consisting of world and a set of owned capabilities.
A capability 
\[
    \begin{rclarray}
        \Regionid & \defeq & \Set{\rid, \dots} \\
        \Capabilityid & \defeq & \Set{\capid, \dots } \\
        \captuple \in \Capability & \defeq & \Capabilityid \times \Val^{*} \\
        \world = (\wstate, \wcap) \in \World & \defeq & ( \Regionid \parfinfun \Timestampheap \times \Capabilityid ) \times ( \Regionid \parfinfun \Capability )
    \end{rclarray}
\]

The composition of capabilities and worlds.
\[
    \begin{rclarray}
        \wcap_{1} \compos \wcap_{2} & \defeq & 
        \begin{funcarray}
        \lambda \rid \ldotp 
            \begin{funcarray}
                \wcap_{1}(\rid) & \rid \in \wcap_{1} \land \rid \notin \wcap_{2} \\
                \wcap_{2}(\rid) & \rid \notin \wcap_{1} \land \rid \in \wcap_{2} \\
                \wcap_{1}(\rid) \compos \wcap_{2}(\rid) & \rid \in \wcap_{1} \cap \wcap_{2} \\
            \end{funcarray} & \forall \rid \in \wcap_{1} \cap \wcap_{2} \ldotp ( \wcap_{1}(\rid) \compos \wcap_{2}(\rid) )\isdef \\
            \texttt{undefined} & o.w. \\
        \end{funcarray} \\
        \world_{1} \compos \world_{2} & \defeq & 
        \begin{funcarray}
            (\wstate, \wcap_{1} \compos \wcap_{2}) & \world_{1} = (\wstate, \wcap_{1}) \land \world_{2} = (\wstate, \wcap_{2}) \land (\wcap_{1} \compos \wcap_{2} )\isdef \\
            \texttt{undefined} & o.w. \\
        \end{funcarray}
    \end{rclarray}
\]

The first element, also pre-condition, only contains empty label, \( \dontcare \pt_{\emptyset} \dontcare \).
The second element, also called post-condition, should contain the same resource as pre-condition and if locations have been updated, they must be tagged with \( \wop \).

\[
    \begin{rclarray}
        %\action \in \Action & \defeq & \Set{ \lpre \transfersto \lpost \ \middle| \ \lpre , \lpost \in \Localassertion } \\
        \eval{\capb{\capid(\vec{\lvar})} : \exists \vec{y} \ldotp \lpre \transfersto \lpost }_{\lenv, \stk} & \defeq & \Set{(\hp, \hp') \middle| 
        \begin{array}{@{}l@{}}
            \exists \rs, \ws \ldotp \lenv, \stk, \hp, \emptyset,\emptyset \models_{l} \lpre \land \lenv, \stk, \hp, \rs, \ws \models_{l}\lpost \land {}\\
            \dom(\hp') = \dom(\hp') \land \hp \setminus \Set{\loc \mapsto \dontcare | \loc \in \ws} = \hp' \setminus \Set{\loc \mapsto \dontcare | \loc \in \ws}  
        \end{array}} 
    \end{rclarray}
\]

The repartition is redefined by adding a merging process.

\[
    \infer[\rl{PRCommit}]{%
        \judgement{}{\gpre}{ \ptrans{\cmd} }{\gpost}
    }{%
        \begin{array}{l}
            \judgement{}{\lpre}{\cmd}{\lpost} \quad 
            \vdash \gpre \Rrightarrow^{\{\lpre\}\{\lpost\}} \gpost
        \end{array}
    }
\]

Before defining repartition, we define the meaning of \emph{merge} by first giving a syntactic rule.
To merge two actions \( \lpre \transfersto \lpost \) and \( \lpre' \transfersto \lpost' \), it requires the pre-conditions agrees, which means that if they describe some common heaps, the state of the common part should be consistent.
Then if the post-conditions write to different locations, the \emph{merge} (to the left) operator \( \actmrg \) returns a new action where the effect of right hands side propagate to the left hand side.

\[
    \begin{rclarray}
        \func{writeSet}{\lvar \pointsto_{\op \cup \Set{\wop}} \dontcare } & \defeq & \Set{\lvar} \\
        \func{writeSet}{\lvar \pointsto_{\op \setminus \Set{\wop}} \dontcare } & \defeq & \emptyset \\
        \func{writeSet}{ \lpre \sep \lpost } & \defeq & \func{writeSet}{\lpre} \uplus \func{writeSet}{\lpost} \\
        \lpre \mrg \lpost & \defeq & 
        \begin{funcarray}
            ( \lpre' \mrg \lpost' ) \sep \lvar \pointsto_{\op \cup \Set{\wop}} \dontcare  &  ( \lpre = \lpre' \sep \lvar \pointsto_{\dontcare} \dontcare ) \land  ( \lpost = \lpost' \sep \lvar \pointsto_{\op \cup \Set{\wop}} \dontcare ) \\
            \lpre & o.w. \\
        \end{funcarray} \\
        \pred{agree}{\lpre , \lpost} & \iff & \exists \lpre', \lpost', \lframe \ldotp ( \lpre = \lpre \sep \lframe ) \land ( \lpost = \lpost' \sep \lframe)  \land (\lpre' \sep \lpost' \sep \lframe)\isdef \\
        ( \lpre \transfersto \lpost ) \actmrg ( \lpre' \transfersto \lpost' ) & \defeq & 
        \begin{funcarray}
            \lpre \transfersto (\lpost \mrg \lpost') & \pred{agree}{\lpre , \lpre'} \land \func{writeSet}{\lpost} \cap \func{writeSet}{\lpost'} = \emptyset \\
            \texttt{undefined} & o.w.
        \end{funcarray}
    \end{rclarray}
\]

\[
    \begin{rclarray}
        \rely \vdash \gpre \Rrightarrow^{\{\lpre\}\{\lpost\}} \gpost & \iff & \exists \lenv, \lenv', \stk, \stk', \tshp, \tshp', \ts, \ts' \ldotp   \lenv, \stk, \tshp, \ts \models_{g} \gpre \land \lenv', \stk', \tshp', \ts' \models_{g} \gpost \land \ts < \ts' \\
                                                                     & & \implies \exists \hp = \func{startstate}{\tshp, \ts}, \hp' = \func{startstate}{\tshp', \ts'}, \hp'', \ws',\rs' \ldotp \\
                                                                     & & \lenv, \stk, \hp, \emptyset, \emptyset \models_{l} \lpre \land \lenv', \stk', \hp'', \rs', \ws' \models_{l} \lpost \land {} \Set{\loc \mapsto \val \middle| \loc \in \ws' \land \hp''(\loc) = \val} \subseteq \hp' \land {} \\
                                                                     & & \forall \lpre_{r}, \lpost_{r} \ldotp (\lpre_{r} \transfersto \lpost_{r}) \in \rely \land \pred{compatible}{\lpre,\lpost, \lpre_{r}, \lpost_{r}} \land \exists \lenv_{r}, \stk_{r}, \hp_{r}, \rs_{r}, \ws_{r} \ldotp \\
                                                                     & & \lenv_{r}, \stk_{r}, \hp_{r}, \rs_{r}, \ws_{r} \models_{l} \lpost_{r} \land \Set{\loc \mapsto \val \middle| \loc \in \ws_{r} \cap \dom(\hp'') \land \hp_{r}(\loc) = \val} \subseteq \hp' \\
    \end{rclarray}
\]

The \predn{compatible}, intuitively, means all the assertions within the pre-conditions \( \lpre_{1} \) and \( \lpre_{2} \) must be tagged with empty-set and if they assert overlapped heap, the overlapped part must agree.
Then, the post-conditions \( \post_{1} \) and \( \post_{2} \) write to different locations.
Note that for post-conditions, it is enough to only check the finger-print because of the constraint of actions and the constraint of pre-conditions.

\[
    \begin{rclarray}
        \pred{compatible}{\lpre_{1},\lpost_{1}, \lpre_{2}, \lpost_{2}} & \defeq & \pred{pre}{\lpre_{1}, \lpre_{2}} \land \pred{post}{\lpost_{1},\lpost_{2}} \\
        \pred{pre}{\lpre_{1},\lpre_{2}} & \defeq & \forall \lenv_{1}, \lenv_{2}, \stk_{1}, \stk_{2}, \hp, \hp_{1}, \hp_{2} \ldotp \lenv_{1}, \stk_{1}, \hp \uplus \hp_{1}, \emptyset, \emptyset \models_{l} \lpre_{1} \land {} \\
                                        & & \lenv_{2}, \stk_{2}, \hp \uplus \hp_{2}, \emptyset, \emptyset \models_{l} \lpre_{2} \land ( \hp \uplus \hp_{1} \uplus \hp_{2} )\isdef \\
        \pred{post}{\lpost_{1},\lpost_{2}} & \defeq & \forall \lenv_{1}, \lenv_{2}, \stk_{1}, \stk_{2}, \hp_{1}, \hp_{2}, \rs_{1}, \rs_{2}, \ws_{1}, \ws_{2} \ldotp \lenv_{1}, \stk_{1}, \hp \uplus \hp_{1}, \rs_{1}, \ws_{1} \models_{l} \lpre_{1} \land {} \\
                                          & & \lenv_{2}, \stk_{2}, \hp \uplus \hp_{2}, \ws_{2}, \rs_{2} \models_{l} \lpre_{1} \land \ws_{1} \cap \ws_{2} = \emptyset \\
    \end{rclarray}
\]

