\section{Operational Model}
\label{sec:model}

\pg{Remember: section 3 is all about technical definitions; section 2
 is  about definitions. This saves space and clarifies the purpose of
 each section.}

We give the technical definitions of our operational model: 
the global, centralised key-value stores; the partial client views;  and the
operational semantics. 

\mypar{Notation}
Given a set $\sort A$, we write $\sort A \ni a$ to denote that elements of $\sort A$ are ranged over by $a$ and its variants (\eg $a', a_1, \cdots$). 
Given a relation $\mathsf r \subseteq \sort A \times \sort A$,
we write $\mathsf r^?$, $\mathsf r^+$ and $\mathsf r^*$ for its reflexive, transitive and reflexive-transitive closures, respectively;
and write $a_1 \xrightarrow{\mathsf r} a_2$ for $(a_1, a_2) \in \mathsf r$.
\subsection{Key-value Stores}

Key-value stores are defined using client and transaction identifiers.
We assume a countably infinite set of \emph{client identifiers} $\Clients \ni \cl$. 
%$\Clients \defeq \Set{\cl, \cl',\cdots}$.
The set of \emph{transaction identifiers} is  
$\TxID \defeq  \Set{\txid_{0}} \uplus \Set{ \txid_{\cl}^{n} \mid \cl
  \in \Clients \wedge n \geq 0 }$, 
where  $\txid_0$ denotes  an \emph{initialisation transaction}, 
%and for each $n \in \mathbb{N}$, the $\txid_{\cl}^{n}$ identifies a transaction  committed by client $\cl$.
and $\txid_{\cl}^{n}$ identifies a transaction committed by client $\cl$. 
Elements of $\TxID$ are ranged over by
$\txid, \txid', \cdots$, and subsets by $\txidset, \txidset', \cdots$. 
Let $\TxID_{0} \defeq \TxID \setminus \{ \txid_0\}$. 
For each $n \in \mathbb{N}$, the $\txid_{\cl}^{n}$ identifies the $n$\textsuperscript{th} transaction  committed by $\cl$.
That is, the $n$ records  the \emph{session order}, $\PO$, associated with
the client: 
$\PO \defeq \Set{ (\txid, \txid') \mid \exsts{ \cl, n,m } \txid =
  \txid_{\cl}^{n} \wedge \txid' = \txid_{\cl}^{m} \wedge n < m}$.
%We write $\txid \xrightarrow{\PO} \txid'$ for
%$(\txid, \txid') \in \PO$, and $\txid \xrightarrow{\PO ?} \txid'$ for
%for its reflexive closure. 


\begin{definition}[Key-value stores]
\label{def:his_heap}
\label{def:mkvs}
Assume a countably infinite set of \emph{keys} $\Keys \ni \ke$, 
%$\Keys = \Set{\ke, \ke', \cdots}$
and a countably infinite set of  \emph{values} $\Val \ni \val$, 
% $\Val = \{\val, \val', \cdots\}$, 
including an \emph{initialisation value} $\val_0 $.
The set of \emph{versions}, $\Versions \ni \ver$, is: $\Versions \defeq \Val \times \TxID \times \powerset{\TxID_{0}}$. 
A \emph{key-value store}, abbreviated to kv-store,  is a function $\hh: \Keys \rightarrow \Versions^{\ast}$, 
where $\Versions^{\ast}$ is the free monoid on $\Versions$. 
The \emph{initial key-value store} is given by $\hh_0$, where 
$\hh_{0}(\ke)\defeq  (\val_0, \txid_0, \emptyset)$ for
all $\ke \in \Keys$.



\end{definition}


A \emph{version} $\ver {=} (\val, \txid, \txidset)$ comprises  a value $\val$
and meta-data about the transactions that accessed it: the \emph{writer} $\txid$ identifies the transaction that wrote $\ver$;
and the set of \emph{readers} $\txidset$ identifies  the  transactions
that read from  $\ver$.
We define $\valueOf(\ver) \defeq \val$,
$\WTx(\ver) \defeq \txid$ and $\RTx(\ver) \defeq \txidset$. 
%Elements of $\Versions$ are ranged over by
%$\ver, \ver',  \cdots$, 
Lists of versions (elements of $\Versions^{\ast}$) are ranged over by $\vilist, \vilist',\cdots$.
Given a kv-store $\hh$ and a transaction $\txid$, we write 
$\txid \in \hh$ when $\txid$ appears as either the writer or amongst the readers of a version in the range of $\hh$.
%%%%
%%%%I don't think this technical detail is needed, it's clear
%%:  $\txid \in \hh \defeq 
%\exists \ke, i. 0 \leq i < \lvert \hh(\ke) \rvert \wedge (\txid \in
%\RTx(\hh(\ke, i)) \cup \{\WTx(\hh(\ke, i))\})$.
We write  $\lvert \hh(\ke) \rvert$ for the length of $\hh(\ke)$, 
and write $\hh(\ke, i)$ for the $i$\textsuperscript{th} version (indexed from 0) of $\ke$ when defined, with $i \geq 0$.




We focus on key-value stores whose consistency model enforces the \emph{atomic visibility} of transactions~\cite{framework-concur}. 
This ensures that 
\begin{enumerate*}
	\item a transaction reads and writes at most one version for each key.
We also assume that 
	\item the list of versions for each key has an initial version 
carrying the initialisation value $\val_0$,  written by the designated initialisation transaction $\txid_0$ 
with an initial empty set of readers.
Finally, we assume that 
	\item the state of a kv-store is consistent with 
the session order of clients: a client cannot read a version of a key that has 
been installed by a future transaction within the same session;  and 
the order in which versions are installed by a single client must agree 
with its session order. 
\end{enumerate*}
When a kv-store satisfies these three conditions, we say that it is \emph{well-formed} (defined formally in \todo). 
Henceforth, we assume kv-stores are well-formed, and write  $\HisHeaps$ to denote 
the set of well-formed kv-stores.
%The formal definition of well-formedness can be found in \todo.
\azalea{
Give a formal definition of well-formedness in the appendix and move the below commented out bit to there. Reference it above.
%We focus on key-value stores whose consistency model enforces the
%\emph{atomic visibility} of transactions~\cite{framework-concur}.
%This amounts to requiring that a transaction reads and writes at most
%one version of each key: \textbf{(i)}
%$\fora{\ke, i, j} (o \leq i, j \leq \abs{ \hh(\ke) } \land
%\RTx(\hh(\ke, i)) \cap \RTx(\hh(\ke, j)) \neq \emptyset ) \implies i =
%j$, \textbf{(ii)}
%$\fora{\ke, i, j} (0 \leq i,j < \abs{ \hh(\ke) } \wedge \WTx(\hh(\ke,
%i)) = \WTx(\hh(\ke, j)) ) \implies i = j$.  We also assume that the
%list of versions for each key has an initial version carrying a
%default value $\val_0$, written by the designated initialisation
%transaction $\txid_0$: \textbf{(iii)}
%$\fora{\ke} \hh(\ke, 0) = (\val_0, \txid_0, \stub)$.  Finally, we
%assume that the state of a key-value store is consistent with the
%session order of clients: \textbf{(iv)}
%$\fora{ \ke, \cl, i,j, n, m} 0 \leq i < j < \abs{\hh(\ke)} \land
%\txid_{\cl}^{n} = \WTx(\hh(\ke,i)) {} \wedge \txid_{\cl}^{m} \in
%\Set{\WTx(\hh(\ke,j))} \cup \RTx(\hh(\ke, i)) \implies n < m $.  We
%say that kv-stores that satisfy the conditions
%\textbf{(i)}-\textbf{(iv)} above are \emph{well-formed}.  Henceforth,
%we always assume kv-stores are  well-formed, and  write 
%$\HisHeaps$ to denote the set of well-formed kv-stores.
}

%\pg{Above, I've got rid of the technical details to make it more
%  readable. I've also done a technical version, commented out, which
%  should probably go in the appendix.}




\subsection{Client Views}

Clients often have partial views of kv-stores, 
with different clients observing 
different versions of the same key.
%To keep track of the versions observed by clients,
%we introduce the notion of \emph{client views} (\cref{def:view}). 

\begin{definition}[Views]
\label{def:view}
\label{def:cuts}
\label{def:views}
\label{def:configuration}
A \emph{view} of a kv-store $\hh$ is a function
$\vi \in \Views(\hh) \defeq \Keys \to\powerset{\Nat}$ such that for all $i, i', \ke, \ke'$:
\begin{align}
    & \hspace*{-8pt}
%    \fora{ \ke } 
    0 \in \vi(\ke) 
    \wedge (i \in \vi(\ke) \Rightarrow i < \abs{ \hh(\ke) }) 
    \tag{wf}
    \label{eq:view.wf}\\
    & \hspace*{-8pt}
    \begin{array}{@{}l@{}}
%    \fora{ \ke_1,\ke_2, i_1, i_2} 
	i \in \vi(\ke)  
  	\land \WTx(\hh(\ke, i)) {=} \WTx(\hh(\ke', i'))  
  	\Rightarrow i' \in \vi(\ke')
    \end{array}
	\tag{atomic}
	\label{eq:view.atomic}
\end{align}
The \emph{initial view} is denoted by $\vi_{0}$, where $\vi_{0}(\ke) = \{0\}$ for all $\ke \in \Keys$. 
A \emph{configuration}, $\conf \in \Confs$,  is a pair $ (\hh, \viewFun)$
with $\hh \in \HisHeaps$ and
$\viewFun : \Clients \parfinfun \Views(\hh)$. A configuration is an 
\emph{initial} configuration when $\hh$ is the initial kv-store
$\hh_{0}$. 
\end{definition}
%


Given a configuration $(\hh, \viewFun)$, when the view of client 
$\cl$ is defined, \ie there exists $\vi = \viewFun(\cl)$, then for each key $\ke \in \Keys$, 
$\vi$ determines the sublist of versions in $\hh$ that client $\cl$ can observe. 
If $i,j \in \vi(\ke)$ and $i < j$, then $\cl$ knows about the values and 
transaction meta-data associated with versions $\hh(\ke, i)$ and  $\hh(\ke, j)$, 
and  knows that these versions are contained in $\hh$ with  $\hh(\ke, j)$ more 
up-to-date than $\hh(\ke, i)$. 
Let $\Views \eqdef \bigcup_{\hh \in \HisHeaps} \Views(\hh)$ be the set of all views. 
Given a kv-store $\hh$ and two views $\vi, \vi' \in \Views(\hh)$, 
we define: $\vi \viewleq \vi' \iffdef \for{\ke \in \dom(\hh)} \vi(k) \subseteq \vi'(\ke)$.

Given a configuration $(\hh, \viewFun)$ and a client $\cl$ such that $\viewFun(\cl)$ is
defined, it is possible to define a \emph{snapshot} of the
view $\viewFun  (\cl)$, which identifies the last write of a client
view. This definition assumes that the database satisfies the \emph{last write wins}
resolution policy~\cite{}. It  is straightforward to generalise our work
to other resolution policies~\cite{.}.

%\azalea{$\ss$ has negative (Nazi) connotations. I would rename it if possible.}
\begin{definition}[Snapshots]
\label{def:heaps}
\label{def:snapshot}
A \emph{snapshot}, \( \ss \in \Snapshots  \defeq \Keys \to
\Val\),  is a function  from keys to values.
Given $\hh \in \HisHeaps$ and $\vi \in \Views(\hh)$, the \emph{snapshot} of $\vi$ in 
$\hh$ is defined by  $\snapshot(\hh, \vi) \defeq \lambda \ke \ldotp \valueOf(\hh(\ke, \max_{<}(\vi(\ke)))$, 
where $\max_{<}(\vi(\ke))$ is the maximum element in $\vi(\ke)$ with respect to the natural 
order $<$ over $\mathbb{N}$.
\end{definition}
Given a kv-store $\hh$, a key $\ke$ and a view $\vi$, 
%we abuse
%notation, writing 
we write 
$\hh(\ke, \vi)$ as a shorthand for 
$\hh(\ke, \max_{<}(\vi(\ke))$. Thus, $\snapshot(\hh, \vi) = \lambda \ke \ldotp \valueOf(\hh(\ke, \vi))$. 

\begin{remark}
The client view describes the partial history of the database observed by the client. 
The client snapshot describes the most up-to-date state of the database known to the client (based on its view). 
It is not possible to work with the snapshot alone. 
The client view is essential to express several standard consistency models (see~\cref{subsec:cm_examples}). 
\end{remark}


\subsection{Operational Semantics}

\noindent {\bf Programming Language} A 
\emph{program} \( \prog \) comprises a finite number of clients,
where each client is associated with a unique identifier \( \thid \in \ThreadID \), 
and executes a sequential \emph{command} $\cmd$, given by the following grammar:
\begin{align*}
\cmd & ::=  
\pskip \mid 
\cmdpri \mid  
\ptrans{\trans} \mid 
\cmd \pseq \cmd \mid 
\cmd \pchoice \cmd \mid 
\cmd \prepeat  
\\
\cmdpri & ::=  
\pass{\txvar}{\expr} \mid 
\passume{\expr} 
\\
\trans & ::=
\pskip \mid
\transpri \mid 
\trans \pseq \trans \mid
\trans \pchoice \trans \mid
\trans\prepeat    
\\
\transpri & ::= 
\cmdpri \mid
\pderef{\txvar}{\expr} \mid
\pmutate{\expr}{\expr} 
\end{align*} 
%

\pg{Why are you using $a$ for variable. Later you use $x$. Just be
  consistent. I'm happy with $x$.} 
Sequential commands  comprise $\pskip$,  primitive commands $\cmdpri
$, atomic transactions
$\ptrans{\trans}$,  and standard
compound commands. 
Primitive commands--the variable assignment
$\pass{\txvar}{\expr}$ and the assume statement $\passume{\expr}$
used to encode conditionals--are used for computations based on 
client-local variables 
and can hence be invoked without restriction. The 
transaction commands, $T$, 
comprise primitive commands, 
primitive transactional commands $\transpri$,  and standard compound commands. 
Primitive transactional commands---the lookup $\pderef{\txvar}{\expr}$ and the mutation 
$\pmutate{\expr}{\expr}$---are used for reading and writing to kv-stores respectively and 
can be invoked  as part of an atomic transaction $\ptrans{\trans}$.

A {\em program} is a finite partial function from client identifiers to sequential
commands.
%%%%I don't think this is needed. 
%$\prog = \Set{\thid_{1} \mapsto \cmd_{1}, \dots, \thid_{n} \mapsto \cmd_{n} $.
For clarity, we often write \( \cmd_{1}\ppar \dots \ppar \cmd_{n}\) as syntactic sugar 
for a program \( \prog \) with $n$ clients associated with identifiers
$\thid_1 \dots \thid_n$, where each client $\thid_i$ executes
$\cmd_i$. Each client is associated with its own client-local stack,  \emph{stack} 
$\stk \in \Stacks \defeq \Vars \to \Val$,  mapping program variables
ranged over by $\pvar{x}, \pvar{y}, \cdots$
to values. 
We assume a language of expressions built from values
and program variables, 
\( \expr ::= \val \mid \var \mid \expr + \expr \mid \dots  \).
The evaluation $\evalE{\expr}$ of  expression $\expr$ is parametric in
the client-local stack:
\begin{gather*}
\evalE{\val} \defeq
\val
\quad
\evalE{\var} \defeq
\stk(\var)
\quad
\evalE{\expr_{1} + \expr_{2}} \defeq
\evalE{\expr_{1}} + \evalE{\expr_{2}}
\quad
\dots
\end{gather*}
\pg{In above, you could define stack  $s_i$ for client $cl_i$.}

\noindent {\bf Transaction Semantics}  
In our framework, transactions are executed atomically. 
Roughly speaking, given a configuration $\conf = (\hh, \viewFun)$, 
when a client $\cl$ executes some transactional code $\ptrans{\trans}$, 
 it performs the following steps: 
it constructs a snapshot of $\hh$ from the view $\viewFun(\cl)$ that 
the client has over $\hh$;  it executes the code $\trans$ in isolation, using the 
snapshot constructed in the previous step as the initial, local state
of the client, and it determines the observable 
effects that such an execution has on the key-value store; and  it incorporates 
the effects of executing the code $\trans$ in the initial state determined by the snapshot into 
the key-value store.

We capture  the behaviour of a  transaction,
$\trans$,
by describing how it updates the client stack and snapshot of 
the kv-store and by  identifying   its {\em fingerprint set}.
A fingerprint of a transaction
is a set of read and write operations that describes  the 
reads of a snapshot of the kv-store taken  at the beginning of
the invocation of the transaction, and the writes to be
commited to the kv-store  as long as certain
consistency conditions are met. A transaction can have more than one fingerprint due to
non-determinism. 




\pg{Above  might need to dovetail with what we say in section 2. 
Maybe give an example that relates to
section 2 that shows intuitively how fingerprint works, maybnot not
and instead jsut refer to section 2}




\begin{definition}[Read-Write Set]
\label{beebop}
Let 
%The set of \emph{operations} is
$\Ops \defeq \{(l, \ke, \val) \mid$ $ l \in \Set{\otW, \otR} \land \ke \in \Keys \wedge \val \in \Val \}$ 
be a set of operations. 
A \emph{Read-Write Set} $\opset$ is a subset of operations, $\opset \subseteq \Ops$,
such that, for all $\ke \in \Keys$ and \( l  \in \Set{\otW, \otR} \),
if $(l, \ke, \val_1), (l, \ke, \val_2) \in \opset$ then $\val_1 = \val_2$.
\end{definition}
Note that we have placed a constraint that, per key, a read-write set
contains at most one read operation and at most one write operation.
This reflects the fact that we work with transactions that are
atomically visible~\cite{laws} meaning here that the reads are taken
from a snapshot of the kv-store and, since clients observe either none
or all effects of a transaction, only the last writes are 
committed.

We provide an operational description of the behaviour of a transaction command, $T$,
starting 
from an intial client stack
$s$, a snapshot $ss$  and the empty read-write set. 
%Intuitively,  a fingerprint of a transaction  records, for each key $\ke$,
%the first value a transaction reads (before a subsequent write) for $\ke$, 
%and the last value the transaction writes for $\ke$.
First, we define a transition system which describes how the stack and snapshot are updated  using the
primitive transaction commands.


\begin{definition}
\label{foo}
The transition system, $\toLTS{\transpri}\; \subseteq (\Stacks \times \Heaps) \times (\Stacks \times \Heaps)$, 
is defined by:
\[
\begin{rclarray}
(\stk, \h)  & \toLTS{\passign{\var}{\expr}}          & (\stk\rmto{\var}{\evalE{\expr}}, \h)                  \\
(\stk, \h)  & \toLTS{\passume{\expr}}                & (\stk, \h) \text{ where } \evalE{\expr} \neq 0        \\
(\stk, \h)  
& \toLTS{ \pderef{\var}{\expr} } 
& (\stk\rmto{\var}{\h(\evalE{\expr})}, \h) 
\\
(\stk, \h)
& \toLTS{\pmutate{\expr_{1}}{\expr_{2}}  }
& (\stk, \h\rmto{\evalE{\expr_{1}}}{\evalE{\expr_{2}}}) \\
\end{rclarray}                                                                                               
\]
\end{definition}
%Second, we define the basic actions of the primitive commands and
%primitive transactional commands using  function
% I don't like this name fingerprint function, it's not, the action
% might not be in the fingerprint. we only begin to get the
% fingerprint intruition with the composition operator. 
%we define a \emph{fingerprint function}, 
%$\func{fp}{\stub} \; : \Stacks \times \Heaps \times \transpri \rightarrow \Ops \cup \{\varepsilon\}$:
%

%Note that  the primitive commands are associated with the empty operation $\varepsilon$,
%as they only access the local stack and do not access the kv-store.

\noindent Second, we provide a 
function, $\mathsf{op}$,  connecting the  primitive transaction commands to the
basic read and write operations given in Definition~\ref{beebop}: 
\[
\begin{array}{rcl @{\quad} rcl}
\func{op}{\stk, \h, \passign{\var}{\expr}}          & \defeq & \emptyop                                     \\
\func{op}{\stk, \h, \passume{\expr}}                & \defeq & \emptyop                                     \\
\func{op}{\stk, \h,  \pderef{\var}{\expr}}           & \defeq & (\etR, \evalE{\expr}, \h(\evalE{\expr}))    \\
\func{op}{\stk,  \h, \pmutate{\expr_{1}}{\expr_{2}}} & \defeq & (\etW, \evalE{\expr_{1}}, \evalE{\expr_{2}})\\
\end{array}
\]
The  empty operation $\emptyop$ is used for the primitive commands which do not
contribute to the fingerprint.

Third, we define an operator,
$\addO  : {\cal P}(\Ops)\times \Ops\rightarrow {\cal P}(\Ops)$,  which
adds a  basic
operation to  a read-write set and ignores the empty operation: 
%For instance, when executing $ \ptrans{\trans}$ with $\trans \eqdef \transpri^1; \cdots ; \transpri^n$,
%the effect of each $\transpri^i$ is calculated via the $\op_i = \func{fp}{-, -, \transpri^i}$ function, 
%with the overall fingerprint given as the $\addO$-composition of the constituent effects: $\op_1 \addO \cdots \addO \op_n$. 
\begin{align*}
    \opset \addO (\etR, \addr, \val)  
    & \defeq
    \begin{cases}
        \opset \cup \{(\etR, \addr, \val)\} & \text{if } \for{l, v'} (l, \addr, v') \notin \opset \\
        \opset &  \text{otherwise} \\
    \end{cases}  \\
    \opset \addO (\etW, \addr, \val) 
    & \defeq 
    \left( \opset \setminus \setcomp{(\etW, \addr, v')}{v' \in \Val} \right) 
    \cup \Set{(\etW, \addr, \val)}  \\
    \opset \addO \emptyop  & \defeq  \opset  \\
\end{align*}
A read gets added to the read-write set if there is no read or
write there already, thus only  recording the reads of the
original snapshot of the kv-store at invocation. 
A write always updates the read-write set, corresponding to a
transaction only commiting the final writes. 


%
\begin{figure*}[!t]
\hrulefill
\begin{mathpar}
    \inferrule[\rl{TPrimitive}]{%
        (\stk, \h) \toLTS{\transpri} (\stk', \h')
        \\ \op = \func{op}{\stk, \h, \transpri}
    }{%
        (\stk, \h, \opset) , \transpri \ \toL \  (\stk', \h', \opset \addO \op) , \pskip 
    }
    \\
    \inferrule[\rl{TChoice}]{
        i \in \Set{1,2}
    }{%
        (\stk, \h, \opset) , \trans_{1} \pchoice \trans_{2} \ \toL \  (\stk, \h, \opset) , \trans_{i}
    }
    \and
    \inferrule[\rl{TIter}]{ }{%
        (\stk, \h, \opset),  \trans\prepeat \ \toL \  (\stk, \h, \opset), \pskip \pchoice (\trans \pseq \trans\prepeat)
    } 
    \and
    \inferrule[\rl{TSeqSkip}]{ }{%
        (\stk, \h, \opset), \pskip \pseq \trans \ \toL \  (\stk, \h, \opset), \trans
    }
    \and
    \inferrule[\rl{TSeq}]{%
        (\stk, \h, \opset), \trans_{1} \ \toL \  (\stk', \h', \opset'), \trans_{1}'
    }{%
        (\stk, \h, \opset), \trans_{1} \pseq \trans_{2} \ \toL \  (\stk', \h', \opset'), \trans_{1}' \pseq \trans_{2}
    }
\end{mathpar}
\hrulefill
\caption{Transaction semantics.}
\label{fig:semantics-trans}
\end{figure*}

Finally, we have all the ingredients to describe the behaviour of  a
transaction command.  \cref{fig:semantics-trans} provides the
one-step transaction semantics: the  interesting rule is the \rl{TPrimitive}
rule which describes how a primitive transactional command updates
the client stack, the snapshot and the read-write set; the other
rules are standard rules for compound commands. 



\begin{definition}[Fingerprint Set]
Given client stack $s$
and snapshot $ss$, the \emph{fingerprint set } of $T$ is given by 
\[F \defeq
\{\opset : (\stk, \h, \emptyset), T \toL^* (\stk', \h', \opset),
\pskip \}
\]
 where $\toL^*$ is the transitive closure of $\toL$ given
 in~\cref{fig:semantics-trans}.  A set $\opset$ in $F$ is called a
 \emph{fingerprint} of $T$. 
\end{definition}
\noindent It is straightforward to prove that the  fingerprints of $T$ contain at most one read operation per key and
one write operation per key. \\

\pg{Below, there were some minor inconsistences. Needs checking.I've
  made lots of changes. It's a bit difficult to assess by laptop,
  really needs a paper copy. Hope ok.}

\noindent {\bf Operational Semantics.} We give the operational
semantics of commands and programs. The command semantics describes
transitions of the form
$(\hh, \vi, \stk), \cmd \ \toT{\lambda}_{\ET} \ (\hh', \vi', \stk') ,
\cmd'$, stating that, given the kv-store $\hh$, view $\vi$ and stack
$\stk$, a client $\cl$ may execute command $\cmd$ for one step, updating the
kv-store to $\hh'$, the stack to $\stk'$, and the command to its
continuation $\cmd'$.  The label $\lambda$ is either of the form
$(\cl, \iota)$ denoting that client $\cl$ used a primitive command
that did not require access to the kv-store, or
$(\cl, \vi'', \opset)$ denoting that client $\cl$ commited an atomic
transaction with fingerprint $\opset$ under the view $\vi''$.
Transitions are parametric in the choice of \emph{execution test},
$\ET$,  used to capture well-known consisitency models studied in the literature
(Sections~\ref{4}
and~\ref{5}). 

\pg{Sorry, I think it's better to revert back to the judgement $cl
  \vdash (\hh, \vi, \stk), \cmd \ \toT{\lambda}_{\ET} \ (\hh', \vi', \stk') ,
\cmd'$, please change everywhere. Why is the label needed? It's not clear.}



\begin{figure*}[t]
\hrulefill
\[
    \inferrule[\rl{CPrimitive}]{
        (\stk, \h)  \toLTS{\cmdpri} (\stk', \h)
        \qquad \h = \clpsHH{\hh,\vi}
    }{%
        ( \hh, \vi, \stk ) , \cmdpri \ \toT{(\cl,\iota)}_{\como} \  ( \hh, \vi, \stk' ) , \pskip
    }
\]
\[
    \inferrule[\rl{CAtomicTrans}]{%
        \vi \orderVI  \vi''
        \qquad \h = \clpsHH{\hh,\vi''}
        \qquad \txid \in \nextTxId(\cl, \hh)
        \\\\ (\stk, \h, \emptyset), \trans \ \toL^{*} \  (\stk', \stub,  \opset) , \pskip
        \\ \ET \vdash (\hh, \vi'') \triangleright \opset : \vi'
    }{%
        ( \hh, \vi, \stk ), \ptrans{\trans} \ \toT{(\cl, \vi'', \opset)}_{\ET} \ (\updateKV(\hh, \vi, \txid, \opset),\vi', \stk' ) , \pskip
    }
\]
%\hrulefill
\[
    \inferrule[\rl{PProg}]{%
        ( \mkvs, \vi, \thdenv(\thid) ) , \prog(\thid), \
        \toT{\lambda}_{\ET} \  ( \mkvs', \vi', \stk' ) , \cmd'  \qquad 
\viewFun (\thid) = \vi
    }{%
        (\mkvs, \viewFun, \thdenv ), \prog  \ \toT{\lambda}_{\ET} \  ( \mkvs', \viewFun, \thdenv\rmto{\thid}{\stk'} ) , \prog\rmto{\thid}{\cmd'} ) 
    }
\]
\hrulefill
\caption{Rules for primitive  commands, atomic
  transactions and programs.}
\label{fig:semantics}
\end{figure*}



Figure~\ref{.} contains the rules for primitive commands and atomic
transactions.  The rules for the compound commands are straightforward
and given in the appendix.
The rule for primtive commands, $\rl{CPrimitive}$,  uses the transition
system
 $\toLTS{\transpri}$, given in  Definition~\ref{foo}, applied to the primitive
commands which just affect the client stack. The rule for atomic
transactions, \rl{CAtomicTrans}, describes the execution of an atomic 
transaction under execution test $\ET$.  The first premise
states that the current view $\vi$ of the executing command maybe advanced to a newer atomic view $\vi''$ (see \cref{def:views}). 
The semantics only allows to advance the view to later versions, which corresponds to \emph{monotonic read} \cite{.......}.
Given the new view $\vi''$, the transaction proceeds by obtaining a snapshot $\sn$ of the kv-store $\hh$, and executing $\trans$ locally to completion ($\pskip$), updating the stack to $\stack'$, while accumulating the fingerprint $\opset$. Note that the resulting snapshot is ignored (denoted by $\stub$) as the effect of the transaction is recorded in the fingerprint $\opset$. 
%

The transaction is now ready to commit. The rule picks a fresh
transaction identifier using $\txid \in \nextTxId(\cl, \hh)$, judges
whether the commit is permitted by $\ET$ using the relation
$\ET \vdash (\hh, \vi'') \triangleright \opset : \vi'$, and updates
the kv-store using $\updKV{\hh, \vi, \txid, \opset}$.  The
set $\nextTxId(\cl, \hh)$ provides the  transactions identifiers
associated with $\cl$ that are fresh for  $\hh$:
$
\nextTxId(\cl, \hh) \defeq \Setcon{\txid_{\cl}^{n}}{\fora{m}
  \txid_{\cl}^{m} \in \hh \Rightarrow m < n }.
$
 By construction, all
elements of $\nextTxId(\cl, \hh)$ are greater, with respect to session
order $\xrightarrow{\PO}$,  than any transaction identifier previously
used by $\cl$. The judgement $\ET \vdash (\hh, \vi'') \triangleright
\opset : \vi'$
states that the fingerprint $\opset$ is compatible with kv-store $\hh$
and client view $\vi''$, and the resulting view  is $\vi'$. In
Section~\ref{4}, 
we give many examples of such relations.
Finally, we need to address how a fingerprint  $\opset$ of a
transaction executed
by client $\cl$  with view $\vi$  update a  key-value store $\hh$. 




Having selected a suitable transaction identifier $t$, we push the
fingerprint $\opset$ 
into $\hh$ as follows: for each read operation $(\otR, \ke, \_) \in \opset$, we add $t$ 
to the set of readers of the last version of $\ke$ that is included in the view $\vi$ of the client; 
for each write operation $(\otW, \ke, \val)$, we append a new version $(\val, t, \emptyset)$ 
to the tail of $\hh(\ke)$.
In the definition below, we use $\lcat$ to denote the concatenation of two lists; 
if $\vilist = \ver_0, \cdots, \ver_n$ and $i=0,\cdots,n$, 
$\vilist\rmto{i}{\ver}$ denotes the updated list 
$\vilist' = \ver_0, \cdots, \ver_{i-1}, \ver, \ver_{i+1}, \cdots,
\ver_{n}$. 

\begin{definition}[Transaction Update]
\label{eq:updatekv}
\label{def:updatekv}
Let $\hh \in \HisHeaps, \vi \in \Views(\hh)$, $t \in
\TxID_{0}$ and 
$\opset \subseteq \powerset{\Ops} $.  
The transaction update function,  $\updateKV(\hh, \vi, \txid, \opset) $,  is
defined by:
\begin{align*}         
    & \updateKV(\hh, \vi, \txid, \emptyset) \defeq  \hh \\
    & \updateKV(\hh, \vi, \txid, \opset \uplus \Set{(\otR, \ke, \val)}) \\
    & \quad \defeq 
    \begin{array}[t]{@{}l}
        \texttt{let} \ (\val, \txid', \txidset) = \hh(\ke, \max_{<}(\vi(\ke))), \\
        \vilist = \hh(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val, \txid', \txidset \uplus \{ t \})}\\
        \quad \texttt{in} \ \updateKV(\hh\rmto{\ke}{\vilist}, \vi, \txid, \opset)
    \end{array} \\
    & \updateKV(\hh, \vi, \txid, \opset \uplus \Set{(\otW, \ke, \val)} ) \\
    & \quad \defeq 
    \begin{array}[t]{@{}l}
        \texttt{let } \hh' = \hh\rmto{\ke}{ ( \hh(\ke) \lcat (\val, \txid, \emptyset) ) } \\
        \quad \texttt{in } \updateKV(\hh', \vi, \txid, \opset)
    \end{array}  
\end{align*}
For client $\cl$, given $\hh \in \HisHeaps$, $\vi \in \Views(\hh)$ and 
$\opset \subseteq \powerset{\Ops} $, the transaction update set 
for $\cl$ is 
\begin{align*}
&\updateKV(\hh, \vi, \cl, \opset)  \\
 & \quad \defeq \Setcon{\updateKV(\hh, \vi, \txid, \opset)}{\txid \in
    \nextTxId(\hh, \cl)}
\end{align*}
\end{definition}

\pg{In above, can the layout be better? I would like to put the transaction identifier $t$ at the
  end of the arguments, since this is what's happening in the
  premises. I also don't like $\cl$ where it is.}

\pg{There is a disconnect. $\ET \vdash (\hh, \vi'') \triangleright
  \opset : \vi'$ says $\vi'$ makes sense with respect to $\hh, \vi'',
  \opset$. Nothing says that $\vi'$ makes sense with $\updateKV(\hh,
  \vi, \txid, \opset)$. I always find myself concerned about $\ET \vdash (\hh, \vi'') \triangleright
  \opset : \vi'$ because $\vi'$ is a view of an updated store which is
not part of the $\ET$ relation. I would add it.}


Note that,  under the assumption that read-write set  $\opset$ contains at most one read and one write 
operation per key and the identifier is fresh for $\hh$, 
the transaction update function and the transaction update set for
$\cl$ are well-defined. 


\pg{This is out of place here. It could go after ET-traces.Two read-write sets $\opset_1, \opset_2$ are \emph{conflict-free} if 
$\forall \ke \in \Keys.\; (\otW,\ke, \_) \in \opset_1 \implies \forall
\val \in \Val.\; (\otW, \ke, \val) \notin \opset_2$, and vice versa.
The commitment of two  conflict-free read-write sets 
$\opset_1, \opset_2$ into a key-value store $\hh$ does not depend on the order in which the commits 
are performed. }

Figure~\ref{.} also contains the rule for programs. 
A \emph{client environment}, $\thdenv \in \ThdEnv$, is a function  from client identifiers to stacks. 
We assume that the domain of client environments  is the same as the
the domain of the program throughout the execution: 
that is,
$\dom(\thdenv) = \dom(\prog)$.
Program transitions are simply defined in terms of the transitions of
their constituent client commands. 
This  yields a  standard interleaving semantics for concurrent
programs:
that is, 
a client performs a reduction in an atomic step without
affecting other clients. 
\pg{ I
  don't like the notation $\thdenv $, nothing else looks like this and
it's not as important as the notation suggests.}








\section{Consistency Guarantees}

Traditional concistency guarantees for distributed databases capture
what it means for distributed data to be consistent. They have been
formally described by axiomatic conditions associated with 
 dependency graphs~\cite{.} and abstract
execution graphs~\cite{.}. We provide consistency guarantees for our
centralised kv-stores by defining a {\em consistency model}, which is
a set of kv-stores representing the possible outcomes that can be
obtained as the result of multiple clients committing several
transactions each.  The set of such transactions of the client are  restricted
to those whose effects comply with the consistency guarantee of the model. To
achieve this, we define consistency models induced by an {\em
  execution test}, which is a relation which determines whether a
client may commit a transaction into a kv-store.  We demontrate in
Section~\ref{.} that our consistency models for kv-stores correspond
to the traditional consistency guarantees for distributed databases,
with different execution tests corresponding to different graph
axioms.




An execution test, formally a set $\ET$ of quadruples of the form $(\mkvs, \vi, \opset, \vi')$,
determines when a client with view $\vi$ on kv-store $\hh$ 
is allowed to commit an atomic  transaction with fingerprint
$\opset$  and obtain an updated view $\vi'$. 


\begin{definition}
\label{def:execution.test}
An \emph{execution test} is a set of tuples $\ET \subseteq \HisHeaps \times \Views \times \powerset{\Ops} \times \Views$ 
such that for all $(\hh, \vi, \opset, \vi') \in \ET$:
\begin{align}
    & 
    \begin{array}{@{}l@{}}
    \fora{\otR, \ke, \val} (\otR, \ke, \val) \in \opset \\
    \quad {} \implies 
    \hh(\ke, \max{}_{<}(\vi(\ke))) = \val  
    \end{array}
    \tag{Ext} \label{eq:read-external} \\
    & 
    \begin{array}{@{}l@{}}
    \fora{\ke} \vi(\ke) \neq \vi'(\ke) \\
    \quad {} \implies
    ( (\otR, \ke, \_) \in \opset \vee (\otW, \ke, \_)) \in \opset) 
    \end{array}
    \tag{ValidViewUpd} \label{eq:valid-view-update}
\end{align}
\end{definition}

\noindent 
The first condition enforces the last-write-wins policy~\cite{}: that
is, a transaction always reads the most recent writes from the initial
view.  The second condition states that a transaction is only allowed
to update the view for those keys that have been recorded in the
fingerprint.  We often write
$\ET \vdash (\hh, \vi) \triangleright \opset: \vi'$ for
$(\mkvs, \vi, \opset, \vi') \in \ET$.

\pg{I am uncomfortable about u' having a potential index to k due to a 
write in F that is not in K, but is in the updated, but  not
mentioned,  store.}

\pg{Just thoughts. I find ValidViewUpd to be very confusing. I understand that if the
  views are different on k then k has to be mentioned in the 
  fingerprint. Apart from this condition, it seems as if anything can happen to the
  view. If fact, what `should' a transaction be able to do. It
  can certainly update the store in two ways: either through reading
  and hence extending a version of  the
  snapshot; or writing at the end of the store. Now what `should'
  happen to the view. At the moment pretty much anything for the ks
mentioned in F. }


\noindent Given an execution set  $\ET$, we define the $\ET$-trace which is a
sequence of $\ET$-reductions on configutations that either moves the
client view to be a more up-to-date view, or commits a fingerprint of
a transaction. 

\begin{definition}[$\ET$-trace]
\label{def:reduction}
An \emph{action} $\alpha \in \Act$ has either the form $(\cl, \varepsilon)$, 
or $(\cl, \opset)$, for client 
$\cl$ and fingerprint $\opset$. 
Given an execution test $\ET$, the $\ET$-\emph{reduction relation},
$\xrightarrowtriangle{}_{\ET} \subseteq \Confs \times \Act \times \Confs$, 
is the smallest relation such that for all $\vi, \vi', \cl, \hh, \hh', \viewFun, \opset$:
\begin{enumerate}
	\item 
    $
    \viewFun(\cl) = \vi 
    \wedge \vi \sqsubseteq \vi' 
    \implies (\hh, \viewFun) \xrightarrowtriangle{(\cl, \varepsilon)}_{\ET} 
    (\hh, \viewFun\rmto{\cl}{\vi'})$; and
	\item 
    $\viewFun(\cl) = \vi
        \wedge ((\mkvs, \vi,
\opset, \vi') \in \ET
        \wedge \hh' \in \updateKV(\hh, \vi, \cl, \opset) \implies
	$  \\
	\phantom{a} \hfill 
	$(\hh, \viewFun) \xrightarrowtriangle{(\cl, \opset)}_{\ET} (\hh', \viewFun\rmto{\cl}{\vi'})$
\end{enumerate}
Given an execution test $\ET$, an \emph{$\ET$-trace} is a sequence of $\ET$-reductions of the form $\conf_{0} \xrightarrowtriangle{\alpha_{0}}_{\ET} \cdots 
\xrightarrow{\alpha_{n-1}} \conf_{n}$.
\end{definition}


\pg{In 2, how do we know that $\hh'$ and $\vi'$ are compatible?}



\noindent A consistency model induced by $\ET$ is a set of kv-stores
that  result from
an $\ET$-trace starting from the 
initial configuration (Definition~\ref{views??}). 

\begin{definition}[Consistency Model]
\label{def:cm}
Given an execution test $\ET$ and initial configuration $\conf_0$ (Definition~\ref{view??}),
the set of configurations $\Confs(\ET) $   induced by $\ET$ is   given by: 
\[
\Confs(\ET)\defeq \Setcon{ \conf_n}{ \exsts{\conf_0} \conf_0 \text{ 
    initial}  \wedge \conf_0 \xrightarrowtriangle{\stub}_{\ET} \cdots
  \xrightarrowtriangle{\stub}_{\ET} \conf_n }
\]
The \emph{consistency model} induced by $\ET$ is:
\( 
\CMs(\ET) \defeq \Setcon{ \hh }{ (\hh, \stub) \in \Confs(\ET) }
\)
\end{definition}
\pg{Above  definition of $\Confs(\ET) $ seems a slightly informal definition. Layout needs attention.}

\noindent In~\cref{sec:mono-et}, we prove that consistency models are 
\emph{monotonic}: 
if  $\ET_1 \subseteq \ET_2$ then $\CMs(\ET_1) \subseteq \CMs(\ET_2)$.
In~\cref{sec:et-comm}, we also prove that  $\CMs(\ET_1 \cap \ET_2) = \CMs(\ET_1) \cap
\CMs(\ET_2)$ under certain conditions on the $\ET_i$.


\pg{Theorem  commented out below must be incorrect. I think you will
  need both  $\ET_1$ and $\ET_2$ commutative.}



%\begin{definition}
%Two triples $(\cl_1, \opset_1)$ and $(\cl_2, \opset_2)$ are 
%conflicting if either $\cl_1 = \cl_2$, or there exists a key $\ke$ such that 
%$(\otW, \ke, \_) \in \opset_1, (\otW, \ke, \_) \in \opset_2$. 

%%An execution test is $\ET$ is \emph{commutative} if, whenever $(\cl_1, \vi_1, \opset_1)$, 
%$(\cl_2, \vi_2, \opset_2)$ are non-conflicting, and $\vi_1, \vi_2 \in \Views(\hh_0)$,  
%then for any $\hh_0, \hh', \viewFun, \viewFun'$ we have that 
%\[
%\begin{array}{lr}
%(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} 
%\_ \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} (\hh', \viewFun') &\implies \\
% (\hh_0, \viewFun) \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} 
%\_ \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} (\hh', \viewFun')
%\end{array}
%\]
%%%%%\end{definition}

%\begin{definition}
%An execution test $\ET$ has \emph{no blind writes} if, whenever $\ET \vdash (\hh, \vi) \triangleright \opset \cup \{(\otW, \ke, \_)%\} : \vi'$, 
%then $(\otR, \ke, \_) \in \opset$.
%\end{definition}

%\begin{definition}
%An execution test $\ET$ has \emph{minimum footprints} if for any key-value store \( \hh \)
%views \( \vi, \vi',\vi''\) and fingerprint \( \f \),
%\[
%\begin{array}{@{}l@{}}
 %   ( \fora{ \ke} (\stub, \ke, \stub) \in \f \implies \vi(\ke) = \vi'(\ke) ) \land {} \\
 %   \quad \ET \vdash (\hh, \vi) \triangleright \opset : \vi'' \implies \ET \vdash (\hh, \vi') \triangleright \opset : \vi''
%\end{array}
%\]
%\end{definition}

%\begin{definition}
%An execution test $\ET$ has \emph{continuous post-views} if for any key-value store \( \hh \)
%views \( \vi, \vi',\vi''\) and fingerprint \( \f \), 
%\[
%\begin{array}{@{}l@{}}
 %   \quad \ET \vdash (\hh, \vi) \triangleright \opset : \vi' \land \vi' \sqsubseteq \vi'' \implies \ET \vdash (\hh, \vi) \triangleright \o%pset : \vi''
%\end{array}
%\]
%\end{definition}


%\begin{theorem}                                                                            
%Let $\ET_1, \ET_2$ be two execution tests has no blind writes, minimum footprints and continuous post-views.
%If $\ET_1$ is commutative, 
%then $\CMs(\ET_1 \cap \ET_2) = \CMs(\ET_1) \cap \CMs(\ET_2)$. 
%Furthermore, if $\ET_1, \ET_2$ are commutative, then $\ET_1 \cap \ET_2$ 
%is commutative.
%\end{theorem}
%\begin{proof}
  %  See \cref{sec:et-comm}.
%\end{proof}



\subsection{Examples}

\pg{Layout of fig. 5 needs lots of attention to make it look less scary.}

\begin{figure*}
\begin{tabular}{ l @{} r }
\hline
Consistency Model & Execution Test: \((\hh, \vi) \csat \opset : \vi'\)\\
\hline
\MRd & $\vi \viewleq \vi'$\\
\MW & 
$j \in \vi(\ke) \wedge \WTx(\hh(\ke', i)) \xrightarrow{\PO?} \WTx(\hh(\ke, j)) 
\implies i \in \vi(\ke')$
\\
\RYW & $ \mkvs' = \updateKV(\hh, \vi, \txid, \opset) \wedge \WTx(
       \mkvs'(\ke, i) ) \xrightarrow{\PO?}  \txid \implies i \in \vi'(\ke) $\\
\WFR & $j \in \vi(\ke) \wedge \txid \in \RTx(\hh(\ke', i)) \wedge \txid {\xrightarrow{\PO?}}
\WTx(\ke, j)  \implies i \in \vi(\ke')$\\
\CC & $\ET_{\CC} = \ET_{\MRd} \cap \ET_{\MW} \cap \ET_{\RYW} \cap \ET_{\WFR}$\\
\hline
\hline
\UA & $(\otW, \ke,  \stub) \in \opset \land 0 \leq i < \lvert \hh(\ke)
      \rvert \implies i \in \vi(\ke) $\\
\PSI & $\ET_{\PSI} = \ET_{\CC} \cap \ET_{\UA}$\\
\CP & \( \Setcon{(\mkvs, \vi, \f, \vi')}{\ddagger} \cap \ET_\MRd \cap \ET_\RYW \) \\
$\SI$ & $\Setcon{(\mkvs, \vi, \f, \vi')}{\dagger} \cap \ET_\MRd \cap \ET_\RYW  \cap \ET_\UA $\\
\SER & $ 0 \leq i < \lvert \hh(\ke) \rvert \implies i \in \vi(\ke) $\\
\hline
\end{tabular}
\\

where
\[
        \dagger \equiv 
        \fora{\ke, \ke', i, j}
                i \in \vi(\ke)  \wedge \WTx(\hh(\ke', j)) \toEdge{((\PO \cup \RF_{\hh} \cup \VO_{\hh}) ; \AD_{\hh}?)^{+}} \WTx(\hh(\ke, i))
          \implies j \in \vi(\ke')    
\]
\[  \ddagger  \equiv 
        \fora{\ke, \ke', i, j}
             i \in \vi(\ke)  \wedge \WTx(\hh(\ke', j)) \toEdge{(((\PO \cup \RF_{\hh}) ; \AD_{\hh}?) \cup \VO_{\hh})^{+}} \WTx(\hh(\ke, i))
         \implies j \in \vi(\ke') 
\]
and :
\[
    \begin{rclarray}
       \RF_{\hh} &\defeq& \{ (\txid, \txid') \mid \exists \ke, i.\; \txid = \WTx(\hh(\ke, i)) \wedge \txid' \in \RTx(\hh(\ke, i))\}\\
      \VO_{\hh} &\defeq& \{ (\txid, \txid') \mid \exists \ke, i, j.\; \txid = \WTx(\hh(\ke, i)) \wedge \txid' = \WTx(\hh(\ke, j)) \wedge i < j\}\\
        \AD_{\hh}&\defeq& \{ (\txid, \txid') \mid \exists \ke, i,
        j.\; \txid \in \RTx(\hh(\ke, i)) \wedge \txid' = \WTx(\hh(\ke,
        j)) \wedge i < j\}
%\\
 %  \PO &\defeq& \{ (t,t') \mid \exists cl, m, n. t = t^m_{cl} \wedge
  %  t' = t^n_{cl} \wedge m<n\}
\end{rclarray}
\]
\caption{Execution tests for  client-centric (top) and data-centric 
 (bottom) consistency models. Recall $\PO$ from Section~\ref{}. 
$?$ denotes the reflexive closure of a relation
  and 
  and $+$ denotes the transitive closure.
All the free variables are universally quantified.
}
\pg{Have I got + correct}
\label{fig:execution.tests}
\label{fig:execution-tests}
\end{figure*}

\input{\RootPath/specs/anomalies-fig.tex}

\pg{I am using distributed databases to mean replicated or sharded
  databases. This will be made clear, once and for all, in the
  introduction and ever afterwards we just refer to distributed databases.}

We now give examples of execution tests in~\cref{fig:execution.tests},
where the associated consistency models for kv-stores correspond to
widely adopted consistency guaranteees for distributed databases.
Following \cite{distrprinciples}, we distinguish between
client-centric and data-centric consistency models: the former
constrain the client views; and the latter impose conditions on the
structure of the kv-store.  In Figure~\ref{.}, we give illustrative
examples of allowed and disallowed key-value stores for our
consistency models.

\pg{Below is great, got lots of information in short space. There's a bit  of
  imprecision in the English description of the consistency
  models, especially the first sentences. I've tried my best and have
  left the original commented out. I'm sure you can do much
  better. Please will somebody do this properly, unifying language as
  much as possible so that there are not many different phrases that
  say the same thing.}


\noindent {\bf Monotonic Reads ($\MRd$).}
%It ensures that read operations from subsequent transactions always
%return a more up-to-date versions.
It states that a client  can never loose information from the
view, hence the read operations can only read increasingly
more up-to-date versions. This prevents, for example,  the kv-store of \cref{fig:mr-disallowed},
since the client $\cl$ first observes the
latest version of $\ke$ using $\txid_{\cl}^{1}$ and then it observes
the older, initial version of $\ke$ using $\txid_{\cl}^{2}$.  The
execution test $\ET_{\MRd}$ ensures that clients  can only extend
their views. 

\noindent {\bf Monotonic Writes ($\MW$).}
It states that whenever a transaction observes a version installed by some client $\cl$,
then the transaction observes all versions installed by the client $\cl$. This prevents the kv-store of 
\cref{fig:mw-disallowed}, since 
transaction $\txid'$ observes the second version of $\ke_2$, carrying
value $\val_2$ and written by client $\cl$, 
but it does not observe the second version of $\ke_1$, carrying value
$\val_1$ and previously written by the same client.
The execution test $\ET_{\MW}$  ensures that, prior to executing a transaction,
the set of versions included in the view of the client must be write 
prefix-closed with respect to the relation $\PO ?$.

\pg{I've rewritten RYW execution test to use SO?.}

\pg{Below uses $\hh'$, makes me wonder more about whether $(\hh',
  \vi') $ should be the result of the execution test?}

\noindent {\bf Read Your Writes (\RYW).}
It states that a client must always be able to read any version of a
key that was previously written by the same client.
\pg{Is the above imprecise? It could be that the client reads a
  different version of the key as the view has moved forward? I think
  it should be about views.}
This prevents the key-value store of \cref{fig:ryw-disallowed},
since the initial version of $\ke$ carries value $0$
and the client $\cl$ tries to increment the value of $\ke$ by $1$
twice.  For its first transaction, it reads the initial value $0$ and then
installs  a new version carrying  value $1$. For its second
transaction, since the client  need not  read its own writes, 
it might read the initial value $0$ again
and install a new version carrying value $1$.
The execution test $\RYW$ ensures  that, after committing a transaction, 
the  client view includes all the versions it wrote.  

\pg{Below, not well explained at all, I  keep thinking I'm saying
  the same thing again and again.}
\noindent {\bf Write Follows Reads (\WFR).}
%It states that if a client \( \cl \) writes some version $\ver$ in a transaction,
%following  another transaction (or in the same transaction of) who reads of some version $\ver'$, 
%then a transaction may observe version $\ver$ only if it also
%observes $\ver'$. 
It states that, if a transaction observes a version written by a
client, then it must also observe the versions previously read by the
client using  the $\PO?$ relation.
This prevents the kv-store of \cref{fig:wfr-disallowed},
since  a transaction $\txid$ observes a version written by $\cl$ but
not a version  previously read by $\cl$.
% the version $\ver_2$ of $\ke_2$ carrying value $\val_2$ written by client $\cl$,
%but the same transaction $\txid$ does not observe the version of $\ke_1$ carrying value $\val_1$, read by $\cl$ prior to writing $\%ver$. 
The execution test $\ET_{\WFR}$  ensures
that a view includes all the versions previously read by a client 
if the view already includes a write from that client. 

\noindent {\bf Causal Consistency (\CC).}
Causal Consistency requires that if a client observes a version $\ver$, 
then it must also observe any version from which $\ver$ potentially depends \cite{cops}. 
The dependency here means $\PO?$  and $    \RF_{\hh}$, defined  in
figure~\ref{.}. For $\PO?$, it means that, when a view includes some effect from a client, 
it must include the previous effects  from the same client.

\pg{Above sentence, I don't know what to write here as I don't understand what it is
  saying.  For $    \RF_{\hh}$, it means when a view includes a transaction (the versions it write),
it must include all the writes that the transaction read from.}

A necessary and sufficient condition is to enforce the four session
guarantees $\MRd, \MW, \RYW$ and $\WFR$ \cite{session2causal}:
$\ET_{\CC} = \ET_{\MRd} \cap \ET_{\MW} \cap \ET_{\RYW} \cap
\ET_{\WFR}$.

\pg{Above, we should mention that in Section~\ref{.} we show that the
  COPS implementation is CC.}

\noindent {\bf Update Atomic ($\UA$).}
This consistency model has been proposed in \cite{framework-concur}, 
though we are not aware of any implementation that directly works with
this consistency guarantee. 
However, many implemented consistency models can be obtained by
strengthening Update Atomic.
It disallows concurrent transactions writing to the same key,
a property is known as \emph{write conflict detection}.
This prevents the kv-store of \cref{fig:ua-disallowed},
sicne two transactions $\txid, \txid'$ concurrently increment the initial version of $\ke$ by $1$.
Not that $\UA$ generalises $\RYW$, 
since we do not require $\txid, \txid'$ to be executed by the same client.
The execution test $\ET_\UA$  ensures that 
a client $\cl$ can write to a key 
only if its view includes the last version of
the key. 

\pg{Above, this last sentence seems imprecise as the view includes all
  versions of the key. }

\noindent {\bf Parallel Snapshot Isolation (\PSI).} 
It combines  causal consistency and update atomic:
$\ET_{\PSI} = \ET_{\CC} \cap \ET_{\UA}$.
%, and $\ET_{\SI} = \ET_{\CC}\cap \ET_{\UA}$.

\pg{Above, you should mention that you show that Clock.SI satisfies
  PSI (if it does or SI below, can't remember).}

\pg{Now I've totally lost it. I'm making comments to try to help you
  explain it better.}




\noindent {\bf Consistent Prefix ($\CP$).}
\label{para:cp}
In centralised databases, where there is a total order in which transactions commit, 
$\CP$ is described by the following property: 
if a client observes the effect of a transaction $\txid$,
then it also observe the effect of any transaction that commits before
$\txid$.

\pg{Above, I am confused by this sentence. In particular, with SI we
  have WW; RW, which is a write that's definitely happened before $t$.
I understand the difference between CP and SI from looking at the
relations, not from reading the English.}



\pg{Below, I don't understand this example, it does not fit with the
  figure. The figure example is also an example os something that
  doesn't fit RYW, so it is not great. I would have thought an example
  using SO; RW would have been good.}
Intuitively, the \( \CP \) disallows that a transaction observes updates in different order (\cref{fig:cp-disallowed-1}).
In \cref{fig:cp-disallowed-1}, transactions $\txid_{3}$ and \( \txid_4 \) observes updates in different order.
That is, \( \txid_3 \) observes that the update of $\ke_2$ carrying value $\val_2$ happens before the update of $\ke_1$ carrying value $\val_2$,
yet $\txid_{4}$ observes that the update of $\ke_1$ carrying value
$\val_1$ happens before the update of $\ke_2$ carrying value
$\val_2$. 

\pg{Below, first sentence, comment earlier when you first define kv-store that this
  information is missing.}

\pg{Below paragraph, I have had a go at rewriting the explanation. I have left 
the previous explanation after that, I believe that mine is
better.  I do believe I am not quite accurate and we have to be really
careful to write the English to explain the different between CP and SI.}

\pg{I believe $\RF_{\hh} ; \AD_{\hh} \subseteq \VO_{\hh}$ so I have
  not used it below as it does not add extra writes.}

Inspired by work connecting dependency graphs and abstract execution~\cite{..}, we can formulate the CP property using kv-stores, despite not having
full information about the total order in which transactions commit.
Given key $k$ and transaction $t$ that writes to index $i$, the task
is to identify the writes that occured before $t$. The relations
$\RF_{\hh}$, $\VO_{\hh}$ and $\AD_{\hh} $ in Figure~\ref{.} and the
relation $\PO$ defined in Section~\ref{.}  can be used to identify
the direct writes that have occured before $t$. The interesting
case is the use of the $\AD_{\hh}$ relation: by itself, this relation
only identifies reads happening before writes; however, used in the
relations $\PO ;
\AD_{\hh}$, it identifies further  writes happening
before $t$. The $\dagger$ relation
\[
\WTx(\hh(\ke', j)) \toEdge{((\PO ; \AD_{\hh}? )\cup \RF_{\hh} \cup \VO_{\hh})^{+}} t
\]
identifies all the writes that occur before $t$, where $+$ is the
transitive closure. 
The execution test $\ET_{\CP}$ ensures that the initial view is 
closed with respect to this $\ddagger$  relation, and the updated view 
increases ($ \ET_\MRd $) and 
includes the writes associated with the fingerprint using the
session order ($\ET_\RYW $).

\pg{Above, presumably, with Section 5 you have proved somewhere that \[
\WTx(\hh(\ke', j)) \toEdge{((\PO ; \AD_{\hh}? )\cup \RF_{\hh} \cup \VO_{\hh})^{+}} t
\]
identifies all the writes that occur before $t$? Can you reference
this? All we know from here is that the writes happen before $t$, we
do not know that we have all of them.

We coupld perhaps justify transitivity and $\ET_{\CP}$ more. }


\pg{Do we know that the CM relation commutes with union and ;? I
  presume so and   we should say so in previous section. }

\pg{Below are my old comments when I had lost it.  I like above much
  better than below because it's explained in terms of kv-stores
  alone. Here we are justifying kv-stores, next section we are linking
  to dependency graphs and abstract execution.}

Inspired by dependency graph \cite{.....},
there are minimum observable transactions for each transaction derived from the following:
\[
    \SO  \subseteq  \VIS \qquad
    ( ( ( \SO \cup \WR ) ; \RW? )^* \cup \WW ) ; \VIS \subseteq \VIS
\]

%define earlier so not explained here, get rid of all but essential
%detail as difficult enough, people do not need to be reminded what
%composition is
%where the \( R? \) is the reflexive closure of the relation \( R \) 
%and \( R_1 ; R_2 \defeq \Setcon{(a,b)}{\exsts{c} (a,c) \in R_1 \land
%(c,b) \in R_2 } \) is the composition of the two relation.
\pg{What are the minimum observable transitions?}
Given the minimum observable transactions, we can specify $\CP$. 
\pg{Next sentence, the  English and formal relation $
  \ET_\RYW $ do not match.}
First, \( \SO \subseteq \VIS \) means a transaction observes all previous transactions from the same client,
and it is enforced by \( \ET_\RYW \).
\pg{At this point, I previously gave up.}
Then the combination of \( \ddagger\) (\cref{fig:execution-tests}) and \( \ET_\MRd \) gives us \( ( ( ( \SO \cup \WR ) ; \RW? )^* \cup \WW ) ; \VIS \subseteq \VIS \).
Let consider a client \( \cl \) and the view \( \vi \).
Assume two transactions \( \txid, \txid' \)  such that \( \txid' \) is in the view \( \vi \) and \( \txid \toEdge{( ( ( \SO \cup \WR ) ; \RW? )^* \cup \WW )} \txid' \).
If \( \txid' \) is a transaction already observable by some previous transaction from the client \( \cl \), 
the transaction \( \txid \) must be observable by that time,
therefore by the \( \ET_\MRd \), the transaction \( \txid \) is in the current view \( \vi \).
Otherwise, if \( \txid' \) is a transaction that is first time observed by the client \( \cl \),
the \( \dagger \) predicate enforces \( \txid \) is also in the view
\( \vi \).



\noindent {\bf Snapshot Isolation (\SI).}
When the total order in which transactions commit is known,
then $\SI = \CP \cap \UA$~\cite{gsi,framework-concur}. 
This equality does not hold using kv-stores, since transactions are not totally
ordered. For example, the kv-store of \cref{fig:si-disallowed} is included in both $\CMs(\ET_{\CP})$ and $\CMs(\ET_{\UA})$, 
but is forbidden by snapshot isolation in general.
As briefly mentioned  after Definition~\ref{4.3} and proved in~\cref{sec:et-comp},  the equality \( \CMs(\ET_1
\cap \ET_2) = \CMs(\ET_1) \cap \CMs(\ET_2) \) only holds 
under certain conditions on the \( \ET_1 \) and \( \ET_2 \)\footnote{%
    This issue also arises with dependency graphs~\cite{.}, see  Section~\ref{5}.
} .


Again inspired by~\cite{.}, we can formulate the  $\SI $ property
without having full knowledge of the total order on transactions.
The additional component in the $\dagger$ relation for $\SI$, compared
with the $\ddagger$ relation of $\CP$, is the use of the relation
$\VO_{\hh}; \AD_{\hh} $....
\pg{And now I don't know what to say, because this clearly gives more
  writes than CP before $t$, so I've got the English of CP wrong. This
  needs to be subtly explained.}
The execution test $\ET_{\CP}$ ensures that the initial view is 
closed with respect to this $\dagger$  relation and 
sees all the whole history of keys associated with the fingerprint
($\ET_{\UA}$, and the updated view 
increases ($ \ET_\MRd $) and 
includes the writes associated with the fingerprint using the
session order ($\ET_\RYW $).


\pg{Below, I had previously given  up. I think the above style is
  better. Now definitely out of time.}
We are inspired by the following constraint that has been proven satisfying \( \SI \) \cite{cerone:snapshot}:
\[
    (\SO \cup \WW) \subseteq \VIS \quad  ( (\SO \cup \WW \cup \WR) ; \RW? ) ; \VIS \subseteq \VIS
\]
where write-write relation \( (\txid, \txid') \in \WW \) means the transaction \( \txid \) installs a version for a key \( \ke \) following by \( \txid' \) installing a new version for the key \( \ke \).
The constraint \( \SO \subseteq \VIS \) coincides with \( \ET_\RYW \).
The \( \WW \subseteq \VIS \) means two transactions cannot concurrently write to the same key,
which is enforced by \( \ET_\UA \).
Let consider \( ( (\SO \cup \WW \cup \WR) ; \RW? ) ; \VIS \subseteq \VIS \).
Similar to the argument we made in Consistent Prefix (\pageref{para:cp}), 
let assume a client \( \cl \), its view \( \vi \) and two transactions \( \txid, \txid' \) such that 
\( \txid' \) is in the view \( \vi \)
and \( \txid \toEdge{(\SO \cup \WW \cup \WR) ; \RW?} \txid' \).
If \( \txid' \) is observable by any previous transaction of the client \( \cl \),
then \( \txid \) is also observable before.
By \( \ET_\MRd\), it is the case \( \txid \) is in the view \( \vi \).
If \( \txid' \) is a new transaction observed by the client \( \cl \),
the \( \dagger \) enforces that \( \txid \) should be included \( \vi \).

\noindent {\bf (Strict) serialisability (\SER).}
Serialisability is the strongest consistency model, 
requiring that there exists a sequential schedule of transactions. 
This prevents  the  kv-store in  \cref{fig:ser-disallowed}, since
whichever transaction writes first ($t_1$ or $t_2$) should be in the
view of the other. This example is allowed by all the other execution
tests in Figure~\ref{.}
The execution test $\ET_{\SER}$ requires 
clients to execute transactions only when their view of the kv-store 
store is complete.


%\input{\RootPath/model/kvstore-view.tex}
%\input{\RootPath/model/exec-test.tex}
