\section{Operational Model and Consistency Guarantees}
\label{sec:model}

\subsection{Key-value Stores and Client Views}

\paragraph{{\bf Key-value Stores}} Let $\Clients \defeq \Set{\cl, \cl',\cdots}$ be a 
countably infinite set of \emph{client identifiers}. 
The set of \emph{transaction identifiers}, 
$\TxID \defeq  \Set{\txid_{0}} \uplus \Set{ \txid_{\cl}^{n} \mid \cl
  \in \Clients \wedge n \geq 0 }$, 
comprises an initialisation transaction 
 $\txid_0$ 
 and, for each $n \in \mathbb{N}$, an identifier $\txid_{\cl}^{n}$
which  identifies a transaction 
 committed by client $\cl$. Elements of $\TxID$ are ranged over by
$\txid, \txid', \cdots$, and subsets by $\txidset, \txidset', \cdots$. 
Let $\TxID_{0} \defeq \TxID \setminus \{ \txid_0\}$. 
The superscript $n$ records  the session order, $\PO$, associated with
the transaction and client: that is, 
$\PO \defeq \Set{ (\txid, \txid') \mid \exsts{ \cl, n,m } \txid =
  \txid_{\cl}^{n} \wedge \txid' = \txid_{\cl}^{m} \wedge n < m}$.
We write $\txid \xrightarrow{\PO} \txid'$ for
$(\txid, \txid') \in \PO$, and $\txid \xrightarrow{\PO} \txid'$ for
for its reflexive closure. 


\begin{definition}[Key-value Stores]
\label{def:his_heap}
\label{def:mkvs}
Assume a countably infinite set of \emph{keys} $\Keys = \Set{\ke, \ke', \cdots}$
and \emph{values} $\Val = \{\val, \val', \cdots\}$, including an
initialisation value    $\val_0 $.
A \emph{version} is a triple $\ver \in \Versions \defeq \Val \times \TxID \times \powerset{\TxID_{0}}$. 
A \emph{key-value store}, abbreviated to kv-store,  is a function $\hh: \Keys \rightarrow \Versions^{\ast}$, 
where $\Versions^{\ast}$ is the free monoid generated by $\Versions$.


\end{definition}


A \emph{version} $\ver = (\val, \txid, \txidset)$ comprises  a value $\val$
and meta-data about the transactions that accessed it: \emph{writer} $\txid$ identifies the transaction that wrote $\ver$;
and the set of \emph{readers} $\txidset$ identifies  the  transactions
that read from  $\ver$.
We write $\valueOf(\ver) \defeq \val$,
$\WTx(\ver) \defeq \txid$ and $\RTx(\ver) \defeq \txidset$. 
 Elements of $\Versions$ are ranged over by
$\ver, \ver',  \cdots$, and lists of versions (elements of $\Versions^{\ast}$) by $\vilist, \vilist',\cdots$.
Given kv-store $\hh$ and a transaction identifier $\txid$, we write 
$\txid \in \hh$ when $\txid$ appears as either the writer or reader of 
some version included in $\hh$.
%%%%
%%%%I don't think this technical detail is needed, it's clear
%%:  $\txid \in \hh \defeq 
%\exists \ke, i. 0 \leq i < \lvert \hh(\ke) \rvert \wedge (\txid \in
%\RTx(\hh(\ke, i)) \cup \{\WTx(\hh(\ke, i))\})$.
We also write 
$\hh(\ke, i)$ for the   $i$-th version of $\ke$ when defined (starting
from $0$ with  $i \geq 0$)  and $\lvert \hh(\ke) \rvert$ for   the length of
$\hh(\ke)$. 

\pg{I don't understand what should be capital (V, KVS) and what curly
  ($\hh, \txidset$). Maybe V curly?
  \sx{$\txidset$ is a set of transactions}
  }


We focus on key-value stores whose consistency model enforces the \emph{atomic visibility} of transactions~\cite{framework-concur}. 
This amounts to requiring that a transaction reads and writes at most
one version of each key.
We also assume that the list of versions for each key has an initial version carrying a default value $\val_0$, 
written by the designated initialisation transaction $\txid_0$ with an initial
empty set of readers.
Finally, we assume that the state of a key-value store is consistent with 
the session order of clients: a client cannot read a version of a key that has 
been installed by a future transactions within the same session;  and 
the order in which versions are installed by a single client must agree 
with its session order. When a 
kv-store satisfies  these conditions, we say that it is
\emph{well-formed}. 
Henceforth, we assume kv-stores are well-formed, and write  $\HisHeaps$ to denote 
the set of well-formed kv-stores.


\pg{Above, I've got rid of the technical details to make it more
  readable. I've also done a technical version, commented out.PLease
  choose.}

%We focus on key-value stores whose consistency model enforces the
%\emph{atomic visibility} of transactions~\cite{framework-concur}.
%This amounts to requiring that a transaction reads and writes at most
%one version of each key: \textbf{(i)}
%$\fora{\ke, i, j} (o \leq i, j \leq \abs{ \hh(\ke) } \land
%\RTx(\hh(\ke, i)) \cap \RTx(\hh(\ke, j)) \neq \emptyset ) \implies i =
%j$, \textbf{(ii)}
%$\fora{\ke, i, j} (0 \leq i,j < \abs{ \hh(\ke) } \wedge \WTx(\hh(\ke,
%i)) = \WTx(\hh(\ke, j)) ) \implies i = j$.  We also assume that the
%list of versions for each key has an initial version carrying a
%default value $\val_0$, written by the designated initialisation
%transaction $\txid_0$: \textbf{(iii)}
%$\fora{\ke} \hh(\ke, 0) = (\val_0, \txid_0, \stub)$.  Finally, we
%assume that the state of a key-value store is consistent with the
%session order of clients: \textbf{(iv)}
%$\fora{ \ke, \cl, i,j, n, m} 0 \leq i < j < \abs{\hh(\ke)} \land
%\txid_{\cl}^{n} = \WTx(\hh(\ke,i)) {} \wedge \txid_{\cl}^{m} \in
%\Set{\WTx(\hh(\ke,j))} \cup \RTx(\hh(\ke, i)) \implies n < m $.  We
%say that kv-stores that satisfy the conditions
%\textbf{(i)}-\textbf{(iv)} above are \emph{well-formed}.  Henceforth,
%we always assume kv-stores are  well-formed, and  write 
%$\HisHeaps$ to denote the set of well-formed kv-stores.


\paragraph{{\bf Client Views}} Key-value stores provide  a
centralised, global  view of the distributed
database. However, clients often only have a partial view,
with different clients observing 
different version subsets  of the same key.
%To keep track of the versions observed by clients,
%we introduce the notion of \emph{client views} (\cref{def:view}). 

\begin{definition}[View]
\label{def:view}
\label{def:cuts}
\label{def:views}
\label{def:configuration}
A \emph{view} of a kv-store $\hh$ is a function
$\vi \in \Views(\hh) \defeq \Keys \to\powerset{\Nat}$ such that:
\begin{align}
    & \fora{ \ke } 
    0 \in \vi(\ke) 
    \wedge \fora{ i \in \vi(\ke) } 
    i < \abs{ \hh(\ke) } 
    \tag{well-formed}
    \label{eq:view.wf}\\
    & 
    \begin{array}{@{}l@{}}
    \fora{ \ke_1,\ke_2, i_1, i_2} 
	i_1 \in \vi(\ke_1)  \\
    \quad {} \land \WTx(\hh(\ke_1, i_1)) = \WTx(\hh(\ke_2, i_2))  \\
    \qquad {} \implies i_2 \in \vi(\ke_2)
    \end{array}
	\tag{atomic}
	\label{eq:view.atomic}
\end{align}
A \emph{configuration} is a pair $(\hh, \viewFun)$, 
with $\hh \in \HisHeaps$ and
$\viewFun : \Clients \parfinfun \Views(\hh)$. 
\end{definition}
%
\pg{I've removed $\conf \in \Confs$, as I think  we often work with
explicit $\hh$ and $\viewFun$. It can return if necessary.}
%
\pg{Below will probably be explained in section 2, so not needed
  here. The purpose of section 2 is to explain. The purpose of section
  3 is to provide the technical definitions. Of course, there will be
  some back and forth on this. ....Configurations extend key-value stores with the information of 
the views of each client. In a configuration $\conf = (\hh, \viewFun)$, the view of client 
$\cl$, $\vi = \viewFun(\cl)$ (if defined) determines for each key $\ke \in \Keys$ the sub-list of versions in $\hh$ 
that the client is aware of, or equivalently that it can observe. If $i,j \in \vi(\ke)$ and $i < j$, then the client is 
aware of the fact that $\hh$ contains the versions $\hh(\ke, i)$, $\hh(\ke, j)$, and that $\hh(\ke, j)$ is more 
up-to-date than $\hh(\ke, i)$. The client also observes the information relative to the versions $\hh(\ke, i)$ and 
$\hh(\ke, j)$, i.e. the value they carry and the meta-data relative to writing and reading transactions of such 
versions. }
%
Let $\Views = \bigcup_{\hh \in \HisHeaps} \Views(\hh)$ be the set of all view. 
Given a kv-store $\hh$ and two views $\vi, \vi' \in \Views(\hh)$, 
we write $\vi \viewleq \vi'$ when $\vi(k) \subseteq \vi'(\ke)$ for all $\ke \in \dom(\hh)$. 
The initial view $\vi_{0}$ is defined as $\vi_{0}(\ke) = \{0\}$ for each $\ke \in \Keys$.



\pg{I don't think we need this as well as the initial kv-store, now
  defined in defn 2.....A configuration $ (\hh_{0}, \viewFun_{0})$ is
\emph{initial} if $\hh_{0}(\ke) = (\val_0, \txid_0, \emptyset)$ for
all $\ke \in \Keys$.}


We assume that the database satisfies the \emph{last writer wins}
\cite{} resolution policy.  This means that, given configuration
$(\hh, \viewFun)$ and client $\cl$ such that $\viewFun(\cl)$ is
defined, it is possible to define a \emph{snapshot} of the
view $\vi(\cl)$.  It is straightforward to generalise our work
to other resolution policies~\cite{.}.

\begin{definition}[Snapshot]
\label{def:heaps}
\label{def:snapshot}
A \emph{snapshot}, \( \ss \in \Snapshots  \defeq \Keys \to
\Val\),  is a function  from keys to values.
Given $\hh \in \HisHeaps$ and $\vi \in \Views(\hh)$, the \emph{snapshot} of $\vi$ in 
$\hh$ is defined by  $\snapshot(\hh, \vi) \defeq \lambda \ke \ldotp \valueOf(\hh(\ke, \max_{<}(\vi(\ke)))$, 
where $\max_{<}(\vi(\ke))$ is the maximum element in $\vi(\ke)$ with respect to the natural 
order $<$ over $\mathbb{N}$.
\end{definition}
Given a kv-store $\hh$, key $\ke$ and view $\vi$, we abuse
notation, writing 
$\hh(\ke, \vi)$ as a shorthand for 
$\hh(\ke, \max_{<}(\vi(\ke))$. Thus, $\snapshot(\hh, \vi) = \lambda \ke \ldotp \valueOf(\hh(\ke, \vi))$. 

\begin{remark}
The client view describes the partial history of  the database that is
observed  by
the client. The client snapshot describes the most up-to-date
information about the state of the databse known to the client. 
It is not possible to work with just the 
snapshot. The client view is essential to 
to express some standard consistency models (see
Section~\cref{........}). 
\end{remark}

\pg{Above remark might be covered by section 2, we'll see.}


\subsection{Operational Semantics}

\subsubsection{Programming Language}

\emph{A program} \( \prog \) comprises a finite number of clients,
where each client is associated with a unique identifier \( \thid \in \ThreadID \), 
and executes a sequential \emph{command} $\cmd$, given by the following grammar:
\begin{align*}
\cmd & ::=  
\pskip \mid 
\cmdpri \mid  
\ptrans{\trans} \mid 
\cmd \pseq \cmd \mid 
\cmd \pchoice \cmd \mid 
\cmd \prepeat  
\\
\cmdpri & ::=  
\pass{\txvar}{\expr} \mid 
\passume{\expr} 
\\
\trans & ::=
\pskip \mid
\transpri \mid 
\trans \pseq \trans \mid
\trans \pchoice \trans \mid
\trans\prepeat    
\\
\transpri & ::= 
\cmdpri \mid
\pderef{\txvar}{\expr} \mid
\pmutate{\expr}{\expr} 
\end{align*} 
%
Sequential commands  comprise $\pskip$,  primitive commands $\cmdpri $, \emph{transactions}
$\ptrans{\trans}$,  and standard
compound commands. 
Primitive commands--the variable assignment
$\pass{\txvar}{\expr}$ and the assume statement $\passume{\expr}$
used to encode conditionals--are used for computations based on 
client-local variables 
and can hence be invoked without restrictions.
Transactions comprise primitive commands, 
primitive transactional commands $\transpri$ and standard compound transactions. 
Transactional primitive commands---the lookup $\pderef{\txvar}{\expr}$ and the mutation 
$\pmutate{\expr}{\expr}$---are used for reading and writing to kv-stores respectively and 
can be invoked only within the boundaries of transactions (the $\ptrans{\trans}$ clause).

A {\em program} is is a finite partial function from client identifiers to sequential
commands.
%%%%I don't think this is needed. 
%$\prog = \Set{\thid_{1} \mapsto \cmd_{1}, \dots, \thid_{n} \mapsto \cmd_{n} $.
For clarity, we often write \( \cmd_{1}\ppar \dots \ppar \cmd_{n}\) as syntactic sugar 
for a program \( \prog \) with $n$ clients associated with identifiers
$\thid_1 \dots \thid_n$, where each client $\thid_i$ executes
$\cmd_i$. Each client is associated with its own client-local stack,  \emph{stack} 
$\stk \in \Stacks \defeq \Vars \to \Val$ mapping program variables,
ranged over by $\pvar{x}, \pvar{y}, \cdots$, 
to values. 
We assume a language of expressions built from values
and \emph{program variables} 
\( \expr ::= \val \mid \var \mid \expr + \expr \mid \dots  \).
The evaluation $\evalE{\expr}$ of  expression $\expr$ is parametric in
the client-local stack:
\begin{gather*}
\evalE{\val} \defeq
\val
\quad
\evalE{\var} \defeq
\stk(\var)
\quad
\evalE{\expr_{1} + \expr_{2}} \defeq
\evalE{\expr_{1}} + \evalE{\expr_{2}}
\quad
\dots
\end{gather*}



\subsubsection{Atomic Transactions}  
We describe  the behaviour of an atomic transaction $\ptrans{\trans}$  by
identifying its {\em fingerprint} which captures  the 
reads of the kv-store at the beginning of
the invocation of the transaction and the writes to the kv-store  at the
commit point. 

\pg{Above  needs to dovetail with what we say in section 2. 
Maybe give an example that relates to
section 2 that shows intuitively how fingerprint works, maybnot not
and instead jsut refer to section 2}




\begin{definition}[Read-Write Sets]
Let 
%The set of \emph{operations} is
$\Ops \defeq \{(l, \ke, \val) \mid$ $ l \in \Set{\otW, \otR} \land \ke \in \Keys \wedge \val \in \Val \}$ 
be a set of operations. 
A \emph{Read-Write Set} $\opset$ is a subset of operations, $\opset \subseteq \Ops$,
such that for all $\ke \in \Keys$ and \( l  \in \Set{\otW, \otR} \),
if $(l, \ke, \val_1), (l, \ke, \val_2) \in \opset$, then $\val_1 = \val_2$.
\end{definition}
Note that we have placed a constraint that read-write sets contains at most one value read, 
and at most one value written, per key.  This reflects the fact that we only consider transactions 
that are atomically visible \cite{laws}.
In particular, for each key $\ke$, 
only the first read from $\ke$ fetches its value from the kv-store,
and since clients observe either none or all effects of a transaction, 
only the last write to $\ke$ is committed.

We now construct the fingerprint of a transaction of a client operationally, parametrised by a client  stack $\stk$ and  snapshot
$\h$. First, we define a transition system for primitive transaction
commands, 
$\toLTS{o} \; \subseteq (\Stacks \times \Heaps) \times (\Stacks \times \Heaps)$, 
which describes how the stack and snapshot evolve upon executing
$\transpri$ using basic operation  $o \in \opset$:
\[
\begin{rclarray}
%(\stk, \h)  & \toLTS{\passign{\var}{\expr}}          & (\stk\rmto{\var}{\evalE{\expr}}, \h)                  &
%(\stk, \h)  & \toLTS{\passume{\expr}}                & (\stk, \h) \text{ where } \evalE{\expr} \neq 0        \\
(\stk, \h)  
& \toLTS{ (\etR, \evalE{\expr}, \h(\evalE{\expr})) } 
& (\stk\rmto{\var}{\h(\evalE{\expr})}, \h) 
\\
(\stk, \h)
& \toLTS{(\etW, \evalE{\expr_{1}}, \evalE{\expr_{2}})} 
& (\stk, \h\rmto{\evalE{\expr_{1}}}{\evalE{\expr_{2}}}) \\
\end{rclarray}                                                                                               
\]
%Second, we define the basic actions of the primitive commands and
%primitive transactional commands using  function
% I don't like this name fingerprint function, it's not, the action
% might not be in the fingerprint. we only begin to get the
% fingerprint intruition with the composition operator. 
%we define a \emph{fingerprint function}, 
%$\func{fp}{\stub} \; : \Stacks \times \Heaps \times \transpri \rightarrow \Ops \cup \{\varepsilon\}$:
%
%\[
%\begin{array}{rcl @{\quad} rcl}
%\func{fp}{\stk, \h, \passign{\var}{\expr}}          & \defeq & \emptyop                                     &
%\func{fp}{\stk, \h, \passume{\expr}}                & \defeq & \emptyop                                     \\
%\func{fp}{\stk, \h, \pderef{\var}{\expr}}           & \defeq & (\etR, \evalE{\expr}, \h(\evalE{\expr}))     &
%\func{fp}{\stk, \h, \pmutate{\expr_{1}}{\expr_{2}}} & \defeq & (\etW, \evalE{\expr_{1}}, \evalE{\expr_{2}})\\
%\end{array}
%\]
%Note that  the primitive commands are associated with the empty operation $\varepsilon$,
%as they only access the local stack and do not access the kv-store.
\sx{The definition has connection between \( \transpri \) and the transition.
We need such thing in the \(\rl{TPrimitive}\) rule.%
}


Second, we define a \emph{composition operator} on the read-write set,
$\addO  : {\cal P}(\Ops)\times \Ops\rightarrow {\cal P}(\Ops)$ which,
starting from the empty set, is used to incrementally add basic
operations to the fingerprint set:
%For instance, when executing $ \ptrans{\trans}$ with $\trans \eqdef \transpri^1; \cdots ; \transpri^n$,
%the effect of each $\transpri^i$ is calculated via the $\op_i = \func{fp}{-, -, \transpri^i}$ function, 
%with the overall fingerprint given as the $\addO$-composition of the constituent effects: $\op_1 \addO \cdots \addO \op_n$. 
\begin{align*}
    \opset \addO (\etR, \addr, \val)  
    & \defeq
    \begin{cases}
        \opset \cup \{(\etR, \addr, \val)\} & \text{if } \for{l, v'} (l, \addr, v') \notin \opset \\
        \opset &  \text{otherwise} \\
    \end{cases}  \\
    \opset \addO (\etW, \addr, \val) 
    & \defeq 
    \left( \opset \setminus \setcomp{(\etW, \addr, v')}{v' \in \Val} \right) 
    \cup \Set{(\etW, \addr, \val)}  \\
    \opset \addO \emptyop  & \defeq  \opset  \\
\end{align*}
Intuitively, for each key $\ke$, the composition operator \( \addO \) records
the first value a transaction reads (before a subsequent write) for $\ke$, 
and the last value the transaction writes for $\ke$.



%
\begin{figure*}[!t]
\hrulefill
\begin{mathpar}
    \inferrule[\rl{TPrimitive}]{%
        (\stk, \h) \toLTS{\op} (\stk', \h')
        %\\ \op = \func{fp}{\stk, \h, \transpri}
    }{%
        (\stk, \h, \opset) , \transpri \ \toL \  (\stk', \h', \opset \addO \op) , \pskip 
    }
    \\
    \inferrule[\rl{TChoice}]{
        i \in \Set{1,2}
    }{%
        (\stk, \h, \opset) , \trans_{1} \pchoice \trans_{2} \ \toL \  (\stk, \h, \opset) , \trans_{i}
    }
    \and
    \inferrule[\rl{TIter}]{ }{%
        (\stk, \h, \opset),  \trans\prepeat \ \toL \  (\stk, \h, \opset), \pskip \pchoice (\trans \pseq \trans\prepeat)
    } 
    \and
    \inferrule[\rl{TSeqSkip}]{ }{%
        (\stk, \h, \opset), \pskip \pseq \trans \ \toL \  (\stk, \h, \opset), \trans
    }
    \and
    \inferrule[\rl{TSeq}]{%
        (\stk, \h, \opset), \trans_{1} \ \toL \  (\stk', \h', \opset'), \trans_{1}'
    }{%
        (\stk, \h, \opset), \trans_{1} \pseq \trans_{2} \ \toL \  (\stk', \h', \opset'), \trans_{1}' \pseq \trans_{2}
    }
\end{mathpar}
\hrulefill
\caption{Selected operational semantics rules for atomic transactions}
\label{fig:semantics-trans}
\end{figure*}

\pg{Not done from here.}

In the top part of \cref{fig:semantics} we present a few selected rules of the operational semantics of transactional code (within the transaction boundaries in $\ptrans{}$). 
We refer the reader to \cref{sec:full-semantics} for the full operational semantics.
Transactional rules are of the form $(\stk, \h, \opset), \toL (\stk', \h', \opset'), \trans'$, 
stating that when the fingerprint accumulated so far is recorded in $\opset$, 
executing $\trans$ for one step transforms the client-local stack $\stk$ 
and snapshot $\h$ to $\stk'$ and $\h'$, respectively, with the extended fingerprint $\opset'$, and continuation $\trans'$.
The \rl{TSeq} rule is in a standard format; 
the \rl{TPrimitive}  models the execution of primitive transactional commands.
When $(\stk, \h)$ is transformed to $(\stk', \h')$ via the transition system $\toLTS{\transpri}$,
$\func{fp}{\stk, \h, \transpri} = \op$, and the fingerprint recorded so far is given by $\opset$, 
then executing $\transpri$ transforms $(\stk, \h)$ to $(\stk', \h')$, with the fingerprint updated to $\opset \addO \op$ (to incorporate the effect of $\transpri$), with continuation $\pskip$. 

\subsubsection{Operational Semantics of Commands}


\paragraph{Committing a Transaction.}
Until now we have only discussed the structure of key-value stores. 
Next, we describe how the state of a key-value store changes, when 
one client executes a transaction. 
In our framework, transactions are executed atomically. 
Roughly speaking, given a configuration $\conf = (\hh, \viewFun)$, 
when a client $\cl$ executes some transactional code $\ptrans{\trans}$, 
then it performs the following steps: 
\textbf{(i)} it constructs a snapshot of $\hh$ from the view $\viewFun(\cl)$ that 
the client has over $\hh$; \textbf{(ii)} it executes the code $\trans$ in isolation, using the 
snapshot constructed in the previous step as the initial, local state of the client, and it determines the visible 
effects that such an execution has on the key-value store; \textbf{(iii)} it incorporates 
the effects of executing the code $\trans$ in the initial state determined by the snapshot into 
the key-value store.

We have already discussed how to construct a snapshot of the key-value store. 
We represent the \emph{visible effects} of the execution of a transaction as \emph{Read-Write Sets}. 
Roughly speaking, a read-write set is a labelling of the operations that the client performs on  
the key-value store when executing a transaction: each of these labelling includes the kind of 
operation performed (either a $\mathsf{R}$ead or a $\mathsf{W}$rite), 
the key on which the operation has been performed, and either the value hat has been fetched from 
(in the case of a read operation), or the value that has been inserted into the key-value store.
We defer the discussion of how to determine the read-write set $\ptrans{\trans}$, 
when executing from some initial client-local state, formalised as a
function  from keys to values, to \cref{........}. 

--------------------------


\begin{figure*}[t]
\hrulefill
\[
    \inferrule[\rl{PCommit}]{%
        \vi \orderVI  \vi''
        \qquad \h = \clpsHH{\hh,\vi''}
        \qquad \txid \in \nextTxId(\cl, \hh)
        \\\\ (\stk, \h, \emptyset), \trans \ \toL^{*} \  (\stk', \stub,  \opset) , \pskip
        \\ \ET \vdash (\hh, \vi'') \triangleright \opset : \vi'
    }{%
        ( \hh, \vi, \stk ), \ptrans{\trans} \ \toT{(\cl, \vi'', \opset)}_{\ET} \ ( \updateKV(\hh, \vi, \txid, \opset),\vi', \stk' ) , \pskip
    }
\]
\[
    \inferrule[\rl{PPrimitive}]{
        \stk \toLTS{\cmdpri} \stk'
    }{%
        ( \hh, \vi, \stk ) , \cmdpri \ \toT{(\cl,\iota)}_{\como} \  ( \hh, \vi, \stk' ) , \pskip
    }
\]
\hrulefill
\[
    \inferrule[\rl{PProg}]{%
        ( \mkvs, \vi, \thdenv(\thid) ) , \prog(\thid), \ \toT{\lambda}_{\ET} \  ( \mkvs', \vi', \stk' ) , \cmd'  
    }{%
        (\mkvs, \viewFun\rmto{\thid}{\vi}, \thdenv ), \prog  \ \toT{\lambda}_{\ET} \  ( \mkvs', \viewFun\rmto{\thid}{\vi'}, \thdenv\rmto{\thid}{\stk'} ) , \prog\rmto{\thid}{\cmd'} ) 
    }
\]
\hrulefill
\caption{Selected operational semantics rules for sequential commands (top); and programs (below)}
\label{fig:semantics}
\end{figure*}




In \cref{fig:semantics} we present a select number of \emph{(sequential) command operational semantics}.
We refer the reader to \cref{sec:full-semantics} for the full operational semantics.
Command transitions are of the form $\cl \vdash (\hh, \vi, \stk), \cmd \ \toT{\lambda}_{\ET} \ (\hh', \vi', \stk') , \cmd'$, 
stating that given the kv-store $\hh$, view $\vi$ and stack $\stk$, client $\cl$ may execute command $\cmd$ for one step under $\ET$, update the kv-store to $\hh'$, the stack to $\stk'$, and the command to its continuation $\cmd'$, with label $\lambda$.
A transition label $\lambda$ is either
\begin{enumerate*}
	\item of the form $(\cl, \iota)$, denoting that the transition involved 
client-local computation that did not require access to the kv-store (\eg primitive commands $\cmdpri$; or
	\item of the form $(\cl, \vi, \opset)$, denoting that client $\cl$ commits a transaction with fingerprint $\opset$ under the view $\vi$.
\end{enumerate*}
Note that the operational semantics of commands are parametric in the choice of execution test $\ET$, 
and thus the choice of the underlying consistency model.


With the exception of the \rl{PCommit} rule, the remaining command transitions are standard and behave as expected. 
For instance, the \rl{PPrimitive} rule models the execution of a non-transactional primitive command $\cmdpri$, where the $\stk \toLTS{\cmdpri} \stk'$ transition describes how the stack of a client evolves upon executing $\cmdpri$:
\[
\begin{rclarray}
\stk  & \toLTS{\passign{\var}{\expr}} & \stk\rmto{\var}{\evalE{\expr}} \\
\stk  & \toLTS{\passume{\expr}} & \stk \text{ where } \evalE{\expr} \neq 0 \\
\end{rclarray}
\]

The \rl{PCommit} rule models the execution of a transaction $\ptrans{\trans}$, under the execution test $\ET$. 
The first premise of \rl{PCommit} states that the current view $\vi$ of the executing command maybe advanced to a newer atomic view $\vi''$ (see \cref{def:views}). 
The semantics only allows to advance the view to later versions, which corresponds to \emph{monotonic read} \cite{.......}.
Given the new view $\vi''$, the transaction proceeds by obtaining a snapshot $\sn$ of the kv-store $\hh$, and executing $\trans$ locally to completion ($\pskip$), updating the stack to $\stack'$, while accumulating the fingerprint $\opset$. Note that the resulting snapshot is ignored (denoted by $\stub$) as the effect of the transaction is recorded in the fingerprint $\opset$. 
%

The transaction is now ready to commit and may propagate its changes to $\hh$.
To this end, a \emph{fresh} transaction identifier $\txid \in \nextTxId(\cl, \hh)$ (defined shortly) is picked
to identify the completed transaction, and the changes performed by $\txid$ are propagated to $\hh$. 
This is done via the $\updKV{\hh, \vi, \txid, \opset}$ function (defined shortly) to update $\hh$. 
Once the kv-store is updated, the client subsequently updates its view to $\vi'$ with respect to its fingerprint. 
Lastly, to ensure that the effect of the transaction (its fingerprint  $\opset$) is permitted by the underlying consistency model, 
the last premise requires that the updates be permitted by the execution test $\ET$, \ie \( (\hh, \vi'') \etto \opset : \vi'\).

The $\nextTxId(\cl, \hh)$ returns the set of transactions identifiers associated with $\cl$ that are fresh with respect to $\hh$: 
$\nextTxId(\cl, \hh) \defeq \Setcon{\txid_{\cl}^{n}}{\fora{m} \txid_{\cl}^{m} \in \hh \Rightarrow m < n }$.
Note that when $\txid_\cl^n = \nextTxId(\cl, \hh)$ in the premise of \rl{PCommit}, then $\txid_\cl^n$ is greater than any transaction identifier 
(with respect to session order $\xrightarrow{\PO}$) 
of the form $\txid_{\cl}^{i}$ appearing in $\hh$,
as to reflect the fact that $\txid_\cl^n$ is the most recent transaction executed by $\cl$.


--------------------------

Finally, we need to address how the effects of a transaction executed by client $\cl$, formalised 
as a read-write set $\opset$, are pushed into a key-value store $\hh$. To this end, we also 
need to know the view $\vi$ that the client has on $\hh$.
First, we must associate the read-write set $\opset$ with a transaction identifier $\txid$.  
Because we are assuming that the read-write set is being merged into the key-value store from client $\cl$, 
it is natural to choose $\txid$ from the set $\{\txid_{\cl}^{n} \mid n \in \mathbb{N}\}$. 
Furthermore, we must choose a transaction identifier of the form 
$\txid_{\cl}^{n}$, where $n$ is greater than any index $m$ such that 
$\txid_{\cl}^{m} \in \hh$: because such transaction identifiers are already present 
in the key-value store, they correspond to transactions that have been previously executed 
by $\cl$, and thus they must precede the transaction identifier $\txid_{\cl}^{n}$ in the session 
order. Formally, we define the set $\nextTxId(\cl, \hh) = \{ \txid_{\cl}^{n} \mid \forall m \in \mathbb{N}. \; 
\txid_{\cl}^{m} \in \hh \implies m < n\}$, and we require that $\txid_{\cl}^{n} \in \nextTxId(\cl,\hh)$. 
Having selected a suitable transaction identifier $\txid_{\cl}^{n}$, we push the read-write set $\opset$ 
into $\hh$ as follows: for each read operation $(\otR, \ke, \_) \in \opset$, we add $\txid_{\cl}^{n}$ 
to the set of readers to the last version of $\ke$ that is included in the view $\vi$ of the client; 
for each write operation $(\otW, \ke, \val)$, we append a new version $(\val, \txid_{\cl}^{n}, \emptyset)$ 
to the tail of $\hh(\ke)$.
In the definition below, we use $\lcat$ to denote the concatenation of two lists; 
if $\vilist = \ver_0, \cdots, \ver_n$ and $i=0,\cdots,n$, 
$\vilist\rmto{i}{\ver}$ denotes the updated list 
$\vilist' = \ver_0, \cdots, \ver_{i-1}, \ver, \ver_{i+1}, \cdots, \ver_{n}$. 
\begin{definition}[Transaction Commit]
Let $\hh \in \HisHeaps, \vi \in \Views(\hh)$, $\cl \in \ClSet$, and $\opset \subseteq \powerset{\Ops}$. 
Then the set of possible key-value stores obtained by letting client $\cl$ with view $\vi$ pushing $\opset$ into $\hh$, 
is defined inductively on $\opset$ as follows: let $\txid$ be a transaction identifier;  
\begin{align*}         
    & \updateKV(\hh, \vi, \txid, \emptyset) \defeq  \hh \\
    & \updateKV(\hh, \vi, \txid, \opset \uplus \Set{(\otR, \ke, \val)}) \\
    & \quad \defeq 
    \begin{array}[t]{@{}l}
        \texttt{let} \ (\val, \txid', \txidset) = \hh(\ke, \max_{<}(\vi(\ke))), \\
        \vilist = \hh(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val, \txid', \txidset \uplus \{ t \})}\\
        \quad \texttt{in} \ \updateKV(\hh\rmto{\ke}{\vilist}, \vi, \txid, \opset)
    \end{array} \\
    & \updateKV(\hh, \vi, \txid, \opset \uplus \Set{(\otW, \ke, \val)} ) \\
    & \quad \defeq 
    \begin{array}[t]{@{}l}
        \texttt{let } \hh' = \hh\rmto{\ke}{ ( \hh(\ke) \lcat (\val, \txid, \emptyset) ) } \\
        \quad \texttt{in } \updateKV(\hh', \vi, \txid, \opset)
    \end{array}  \\
    & \updateKV(\hh, \vi, \cl, \opset)  \\
    & \quad \defeq \Setcon{\updateKV(\hh, \vi, \txid, \opset)}{\txid \in \nextTxId(\hh, \cl)}
\end{align*}
\end{definition}

---------------------------

	Note that all the key-value stores in $\updateKV(\hh, \vi, \cl, \opset)$ are equivalent, up-to the transaction 
	identifier $\txid_{\cl}^{n} \in \nextTxId(\hh, \cl)$ that is associated with the read-write set $\opset$.

The set $\HisHeaps$ is closed with respect to applications of the operator $\updateKV$. Furthermore, 
let us say that two read-write sets $\opset_1, \opset_2$ are \emph{conflict-free} if 
$\forall \ke \in \Keys.\; (\otW,\ke, \_) \in \opset_1 \implies \forall \val \in \Val.\; (\otW, \ke, \val) \notin \opset_2$: 
then the set of key-value stores obtained by letting two different clients $\cl_1, \cl_2$ committing the read-write sets 
$\opset_1, \opset_2$ into a key-value store $\hh$, respectively, does not depend on the order in which the commits 
are performed. 

----------------------------

For every read operation $(\otR, \ke, \stub)$ in fingerprint $\opset$,
since a transaction reads the values of keys from 
the atomic snapshot determined by the view of the client, 
the version read by $\txid$ for key $\ke$ corresponds to $\hh(\ke, \max_{<}(\vi(\ke)))$.
As such, to commit the transaction, 
the reader set of the version $\hh(\ke, \max_{<}(\vi(\ke)))$ is extended with a new reader $\txid_\cl^n$.
Similarly, for every write operation $(\otW, \ke, \val)$ in fingerprint $\opset$, 
the list of versions $\hh(\ke)$ is extended with a new version $(\val, \txid, \emptyset)$, 
denoting that $\txid_\cl^n$ is the writer of this version which has no readers as of yet. 

---------------------------

Note that the assumption that 
versions of a given key are totally ordered and consistent with the order in which 
transactions commit is standard, 
which corresponds to last-write-win resolution policy \cite{adya,framework-concur,seebelieve}. 
Moreover, under the assumption that fingerprints contain at most one read and one write 
operation per key, and the identifier is fresh $\txid \notin \hh$%
\footnote{%
We write $\txid \in \hh$ when there exists a key 
$\ke$ and an index $i=0,\cdots, \lvert \hh(\ke) \rvert -1$ such that $\txid \in \{\WTx(\hh(\ke, i)\} \cup \RTx(\hh(\ke, i))$.}, 
the $\updateKV$ is well-defined.


\subsubsection{Programs}
The \emph{operational semantics of programs} are given at the bottom of \cref{fig:semantics}. 
Programs transitions are of the form $(\conf,  \thdenv, \prog) \ \toG{\lambda}_{\ET} (\conf',  \thdenv', \prog')$,
stating that given the configuration $\conf$ and the \emph{client environment} $\thdenv$, executing program $\prog$ for one step under $\ET$, updates the configuration to $\conf'$, the client environment to $\thdenv'$, and the program to its continuation $\prog'$. 
A \emph{client environment}, $\thdenv \in \ThdEnv$, is a mapping from client identifiers to pairs of stacks and views. 
We assume that the clients in the domain of client environments are are those in the domain of the program throughout the execution: 
$\dom(\thdenv) = \dom(\prog)$.
Program transitions are simply defined in terms of the transitions of their constituent client commands.
This in turn yields the standard interleaving semantics for concurrent programs. 
That is, a client performs a reduction in an atomic step, without affecting other clients.


\subsection{Consistency Guarantees}


Intuitively, a consistency model can be thought as a property on key-value stores 
defining the degree of consistency of the data stored in it.
From a formal point of view, we define a consistency model 
$\CMs$ to be a set of key-value stores.  
Each $\hh \in \CMs$ represents a possible outcome that 
can be obtained as the result of multiple clients committing several transactions each. 
However, depending on the particular consistency model being considered, the set of transactions that a client is allowed to commit  
from a configuration $\conf$, must be restricted to those whose effects comply with the data-consistency guarantee associated with 
the consistency model. 
To this end, we introduce the notion of \emph{execution tests}, 
execution tests are used to determine whether a client may commit a transaction into a key-value store.

\subsubsection{Execution Tests}
An execution test of a transaction is a quadruple $(\hh, \vi, \opset, \vi')$, where $\hh$ denotes a kv-store;
the $\vi$ denotes the \emph{initial} view, recorded at the beginning of the transaction; 
the $\opset$ denotes the fingerprint of the transaction; and 
$\vi'$ demotes the \emph{final} view of the transaction, obtained after committing the transaction. 
An execution test $(\mkvs, \vi, \opset, \vi')$ states that when the kv-store is described by $\hh$, a client with view $\vi$ is allowed to execute a single transaction with fingerprint $\opset$, commit the transaction and obtain an updated view $\vi'$. 

\begin{definition}
\label{def:execution.test}
An \emph{execution test} is a set of tuples $\ET \subseteq \HisHeaps \times \Views \times \powerset{\Ops} \times \Views$ 
such that for all $(\hh, \vi, \opset, \vi') \in \ET$:
\begin{align}
    & 
    \begin{array}{@{}l@{}}
    \fora{\otR, \ke, \val} (\otR, \ke, \val) \in \opset \\
    \quad {} \implies 
    \hh(\ke, \max{}_{<}(\vi(\ke))) = \val  
    \end{array}
    \tag{Ext} \label{eq:read-external} \\
    & 
    \begin{array}{@{}l@{}}
    \fora{\ke} \vi(\ke) \neq \vi'(\ke) \\
    \quad {} \implies
    ( (\otR, \ke, \_) \in \opset \vee (\otW, \ke, \_)) \in \opset) 
    \end{array}
    \tag{ValidViewUpd} \label{eq:valid-view-update}
\end{align}
\end{definition}

Execution tests enforce last write win,
\ie a transaction always reads the most recent writes from the initial view (\cref{eq:read-external}).
For minimum footprint on the views, a transaction is only allowed to update the view for those keys that have been read or overwritten (\cref{eq:valid-view-update}).


Hereafter, we adopt a more suggestive notation and write $\ET \vdash (\hh, \vi) \triangleright \opset: \vi'$ 
for $(\hh, \vi, \opset, \vi') \in \ET$.
Execution tests induce \emph{consistency models} \( \CMs(\ET) \) as defined in \cref{def:reduction,def:cm}.

An example of execution test is serialisability (\SER).
The execution test for \( \SER \) requires the initial view  \( \vi \) contains all the versions in the key-value store \( \mkvs \), that is, \( \fora{\ke, i < \abs{\mkvs(\ke)} } i \in \vi(\ke)\).
It matches the intuition that a transaction should observe the up-to-date state of the database.
Later in \cref{sec:spec} we present more examples of execution tests of well-known consistency models in the literature. 


------------------


\subsection{Consistency Guarantees}
\begin{figure*}
\begin{tabular}{ l @{} r }
\hline
Consistency Model & Execution Test: \((\hh, \vi) \csat \opset : \vi'\)\\
\hline
\MRd & $\vi \viewleq \vi'$\\
\MW & 
$j \in \vi(\ke) \wedge \WTx(\hh(\ke', i)) \xrightarrow{\PO?} \WTx(\hh(\ke, j)) 
\implies i \in \vi(\ke')$
\\
\RYW & $ \mkvs' = \updateKV(\hh, \vi, \txid, \opset) \implies \WTx( \mkvs'(\ke, i) ) \leq \txid \implies i \in \vi'(\ke) $\\
\WFR & $j \in \vi(\ke) \wedge \txid \in \RTx(\hh(\ke', i)) \wedge \txid {\xrightarrow{\PO?}}
\WTx(\ke, j) ) \implies i \in \vi(\ke')$\\
\CC & $\ET_{\CC} = \ET_{\MRd} \cap \ET_{\MW} \cap \ET_{\RYW} \cap \ET_{\WFR}$\\
\hline
\hline
\UA & $(\otW, \ke,  \stub) \in \opset \land 0 \leq i < \lvert \hh(\ke) \rvert \implies i \in \vi(\ke) $\\
\CP & \( \Setcon{(\mkvs, \vi, \f, \vi')}{\ddagger} \cap \ET_\MRd \cap \ET_\RYW \) \\
\PSI & $\ET_{\PSI} = \ET_{\CC} \cap \ET_{\UA}$\\
$\SI$ & $\Setcon{(\mkvs, \vi, \f, \vi')}{\dagger} \cap \ET_\MRd \cap \ET_\RYW  \cap \ET_\UA $\\
\SER & $ 0 \leq i < \lvert \hh(\ke) \rvert \implies  \in \vi(\ke) $\\
\hline
\end{tabular}

\[
    \begin{rclarray}
        \RF_{\hh} &\defeq& \{ (\txid, \txid') \mid \exists \ke, i.\; \txid = \WTx(\hh(\ke, i)) \wedge \txid' \in \RTx(\hh(\ke, i))\}\\
        \VO_{\hh} &\defeq& \{ (\txid, \txid') \mid \exists \ke, i, j.\; \txid = \WTx(\hh(\ke, i)) \wedge \txid' = \WTx(\hh(\ke, j)) \wedge i < j\}\\
        \AD_{\hh} &\defeq& \{ (\txid, \txid') \mid \exists \ke, i, j.\; \txid \in \RTx(\hh(\ke, i)) \wedge \txid' = \WTx(\hh(\ke, j)) \wedge i < j\}\\
        \PO &\defeq& \{ (\txid, \txid') \mid \exists \cl, m, n.\; \txid = \txid_{\cl}^{m} \wedge \txid' = \txid_{\cl}^{n} \wedge m < n \}\\
        \dagger & \equiv &
        \begin{array}[t]{@{}l@{}}
               \fora{\ke, \ke', i, j} \\
            \begin{array}{@{}l@{}}
                i \in \vi(\ke)  \wedge \WTx(\hh(\ke', j)) \toEdge{((\PO \cup \RF_{\hh} \cup \VO_{\hh}) ; \AD_{\hh}?)^{+}} \WTx(\hh(\ke, i))\\
            \qquad \implies j \in \vi(\ke') 
            \end{array}
        \end{array} \\

      \ddagger & \equiv &
        \begin{array}[t]{@{}l@{}}
               \fora{\ke, \ke', i, j} \\
            \begin{array}{@{}l@{}}
            i \in \vi(\ke)  \wedge \WTx(\hh(\ke', j)) \toEdge{(((\PO \cup \RF_{\hh}) ; \AD_{\hh}?) \cup \VO_{\hh})^{+}} \WTx(\hh(\ke, i))\\
              \end{array}\\
                \qquad \implies j \in \vi(\ke') 
        \end{array} \\
    \end{rclarray}
\]
\caption{Execution tests for both client-centric (top) and data-centric consistency (bottom) models. 
All the free variables are universally quantified.
}
\label{fig:execution.tests}
\label{fig:execution-tests}
\end{figure*}

\input{\RootPath/specs/anomalies-fig.tex}

We now give the execution tests for widely adopted consistency models of distributed and replicated databases. 
These are summarised in \cref{fig:execution.tests}.
Following \cite{distrprinciples}, we distinguish between client-centric and data-centric consistency models. 
The former constrain the versions of keys that individual clients can observe. 
The latter impose conditions on the shape of the state of the database, in our case the structure of the kv-store.
In \cref{sec:spec-proof} we prove that specification of consistency models using execution tests
are both sound and complete with respect to alternative specifications from the literature.
Due to space constraints, we only give examples of allowed and disallowed key-value stores for relevant consistency models. 

\paragraph{Monotonic Reads ($\MRd$).}
It ensures that read operations from subsequent transactions always return a more up-to-date versions.
For example, the key-value store of \cref{fig:mr-disallowed} is disallowed by $\MRd$.
Because the client $\cl$ first observes the latest version of $\ke$ in $\txid_{\cl}^{1}$,
then it observes the initial version of $\ke$ in $\txid_{\cl}^{2}$.
The execution test $\ET_{\MRd}$ prevents this scenario by forcing clients to always update their views to newer ones. 

\paragraph{Monotonic Writes ($\MW$).}
It states that whenever a transaction observes the effects of a version installed by some client $\cl$,
then the transaction observes all the transactions executed by the client. 
It prevents the scenario of \cref{fig:mw-disallowed}, 
where transaction $\txid'$ observes the second version of $\ke_2$ carrying value $\val_2$, written by client $\cl$;
but it does not observe the second version of $\ke_1$ carrying value $\val_1$, previously written by the same client.
The execution test $\ET_{\MW}$ (\cref{fig:execution.tests}) ensures that, prior to executing a transaction,
the set of versions included in the view of the client must be prefix-closed with respect to the relation $\xrightarrow{\PO}$.

\paragraph{Read Your Writes (\RYW).}
It states that a client must always be able to read any version of a key that was previously written by the same client.
This prevents the key-value store of \cref{fig:ryw-disallowed}. 
In the \cref{fig:ryw-disallowed}, the initial version of $\ke$ carries value $0$, 
and the client $\cl$ tries to increment the value of $\ke$ by $1$ twice.
For the first time, it reads the initial value $0$ and then installing a new version carrying  value $1$ within a single transaction.
However, since the client does not need to read its own writes, 
the client might read the initial value $0$ again in the second increment transaction \( \txid_\cl^2 \),
and install a new version carrying value $1$.
The Read Your Writes ($\RYW$) (\cref{fig:execution.tests}) enforces that after committing a transaction, 
a client includes all the versions it wrote.  

\paragraph{Write Follows Reads (\WFR).}
It states that if a client \( \cl \) writes some version $\ver$ in a transaction,
following  another transaction (or in the same transaction of) who reads of some version $\ver'$, 
then a transaction may observe version $\ver$ only if it also observes $\ver'$. 
The Write Follow Reads ($\WFR$) disallows the scenario of \cref{fig:wfr-disallowed} 
where a transaction $\txid$ observes the version $\ver_2$ of $\ke_2$ carrying value $\val_2$ written by client $\cl$,
but the same transaction $\txid$ does not observe the version of $\ke_1$ carrying value $\val_1$, read by $\cl$ prior to writing $\ver$. 
The execution test $\ET_{\WFR}$ (\cref{fig:execution.tests}) prevents this scenarios 
by enforcing a view includes all the versions previous read by some client \( \cl \), 
if the view already include a write from that client \( \cl \).

\paragraph{Causal Consistency (\CC).}
Causal Consistency requires that if a client observes a version $\ver$, 
then it must also observe any version $\ver'$ from which $\ver$ potentially depends \cite{cops}. 
The dependency here means session order and write-read relation.
For session order, it means when a view includes some effect from a client, 
it must include previous effect from the same client.
For write-read relation, it means when a view includes a transaction (the versions it write),
it must include all the writes that the transaction read from.
A necessary and sufficient condition is to enforce the four session guarantees $\MRd, \MW, \RYW$ and $\WFR$ \cite{session2causal}.
Therefore, we let $\ET_{\CC} = \ET_{\MRd} \cap \ET_{\MW} \cap \ET_{\RYW} \cap \ET_{\WFR}$. 

\paragraph{Update Atomic ($\UA$).}
This consistency model has been proposed in \cite{framework-concur}, 
though we are not aware of any implementation. 
However, many implemented consistency models can be obtained by strengthening Update Atomic.
Update Atomic disallows concurrent transactions writing to the same key. 
This property is known as \emph{write conflict detection}.
For example, $\UA$ prevents the key-value store of \cref{fig:ua-disallowed},
where two transactions $\txid, \txid'$ concurrently increment the initial version of $\ke$ by $1$.
Note that this scenario generalises the one exhibited by $\RYW$, 
since we do not require $\txid, \txid'$ to be executed by the same client.
To prevent this scenario, the execution test $\ET_\UA$ requires that 
a client $\cl$ can write to key $\ke$ in a transaction,
only if its view prior to the execution includes the last version of $\ke$.

\paragraph{Consistent Prefix ($\CP$).}
\label{para:cp}
In centralised databases, where there is a total order in which transactions commit, 
Consistent Prefix is described by the following property: 
if a client observes the effect of a transaction $\txid$,
then it also observe the effect of any transaction $\txid'$ that commits before $\txid$.
It is difficult to formulate in key-value store,
because key-value stores do not contain the full information about the total order in which transactions committed. 
Inspired by dependency graph \cite{.....},
there are minimum observable transactions for each transaction derived from the following:
\[
    \SO  \subseteq  \VIS \qquad
    ( ( ( \SO \cup \WR ) ; \RW? )^* \cup \WW ) ; \VIS \subseteq \VIS
\]
where the \( R? \) is the reflexive closure of the relation \( R \) 
and \( R_1 ; R_2 \defeq \Setcon{(a,b)}{\exsts{c} (a,c) \in R_1 \land (c,b) \in R_2 } \) is the composition of the two relation.
The session order relation \( (\txid, \txid') \in \SO \) means the session order;
write-read relation \( (\txid, \txid') \in \WR \) means \( \txid' \) reads the write of \( \txid \);
read-write relation \( (\txid, \txid') \in \RW \) means \( \txid' \) read a old version of a key 
and \( \txid' \) installs a new version for the same key;
and \( (\txid, \txid') \in \VIS \) means the view exactly before \( \txid' \) should include all effect \( \txid \).
Given the minimum observable transactions, we can specify $\CP$. 
First, \( \SO \subseteq \VIS \) means a transaction observes all previous transactions from the same client,
and it is enforced by \( \ET_\RYW \).
Then the combination of \( \ddagger\) (\cref{fig:execution-tests}) and \( \ET_\MRd \) gives us \( ( ( ( \SO \cup \WR ) ; \RW? )^* \cup \WW ) ; \VIS \subseteq \VIS \).
Let consider a client \( \cl \) and the view \( \vi \).
Assume two transactions \( \txid, \txid' \)  such that \( \txid' \) is in the view \( \vi \) and \( \txid \toEdge{( ( ( \SO \cup \WR ) ; \RW? )^* \cup \WW )} \txid' \).
If \( \txid' \) is a transaction already observable by some previous transaction from the client \( \cl \), 
the transaction \( \txid \) must be observable by that time,
therefore by the \( \ET_\MRd \), the transaction \( \txid \) is in the current view \( \vi \).
Otherwise, if \( \txid' \) is a transaction that is first time observed by the client \( \cl \),
the \( \dagger \) predicate enforces \( \txid \) is also in the view \( \vi \).
Intuitively, the \( \CP \) disallows that a transaction observes updates in different order (\cref{fig:cp-disallowed-1}).
In \cref{fig:cp-disallowed-1}, transactions $\txid_{3}$ and \( \txid_4 \) observes updates in different order.
That is, \( \txid_3 \) observes that the update of $\ke_2$ carrying value $\val_2$ happens before the update of $\ke_1$ carrying value $\val_2$,
yet $\txid_{4}$ observes that the update of $\ke_1$ carrying value $\val_1$ happens before the update of $\ke_2$ carrying value $\val_2$. 
\paragraph{Parallel Snapshot Isolation (\PSI)} 
Parallel Snapshot Isolation (\PSI) can be obtained by combining causal consistency with update atomic, 
$\ET_{\PSI} = \ET_{\CC} \cap \ET_{\UA}$, and $\ET_{\SI} = \ET_{\CC} \cap \ET_{\UA}$.

\paragraph{Snapshot Isolation (\SI)}
When the total order in which transactions commit is known,
SI can be specified as the weakest consistency model that guarantees both 
Consistency Prefix and Update Atomic \cite{gsi,framework-concur}. 
Yet, it is not true in our framework, since transactions are not totally ordered.
For example, the kv-store of \cref{fig:si-disallowed} is included in both $\CMs(\ET_{\CP})$ and $\CMs(\ET_{\UA})$, 
but it is forbidden by snapshot isolation in general.
The reason is \( \CMs(\ET_1 \cap \ET_2) = \CMs(\ET_1) \cap \CMs(\ET_2) \) holds 
only under some conditions of the \( \ET_1 \) and \( \ET_2 \) (more detail in \cref{thm:et-comm} \cref{sec:et-comp}).
\footnote{%
    This problem is not limited to our setting: 
    because kv-stores are isomorphic to Adya's dependency 
    graph, the same problem arises there.%
} 
We are inspired by the following constraint that has been proven satisfying \( \SI \) \cite{cerone:snapshot}:
\[
    (\SO \cup \WW) \subseteq \VIS \quad  ( (\SO \cup \WW \cup \WR) ; \RW? ) ; \VIS \subseteq \VIS
\]
where write-write relation \( (\txid, \txid') \in \WW \) means the transaction \( \txid \) installs a version for a key \( \ke \) following by \( \txid' \) installing a new version for the key \( \ke \).
The constraint \( \SO \subseteq \VIS \) coincides with \( \ET_\RYW \).
The \( \WW \subseteq \VIS \) means two transactions cannot concurrently write to the same key,
which is enforced by \( \ET_\UA \).
Let consider \( ( (\SO \cup \WW \cup \WR) ; \RW? ) ; \VIS \subseteq \VIS \).
Similar to the argument we made in Consistent Prefix (\pageref{para:cp}), 
let assume a client \( \cl \), its view \( \vi \) and two transactions \( \txid, \txid' \) such that 
\( \txid' \) is in the view \( \vi \)
and \( \txid \toEdge{(\SO \cup \WW \cup \WR) ; \RW?} \txid' \).
If \( \txid' \) is observable by any previous transaction of the client \( \cl \),
then \( \txid \) is also observable before.
By \( \ET_\MRd\), it is the case \( \txid \) is in the view \( \vi \).
If \( \txid' \) is a new transaction observed by the client \( \cl \),
the \( \dagger \) enforces that \( \txid \) should be included \( \vi \).

\paragraph{(Strict) serialisability (\SER)}
Serialisability is the strongest consistency model, 
which requires that there exists a serial or sequential schedule of transaction. 
This prevents scenarios of \cref{fig:ser-disallowed},
which is instead allowed by all the other execution tests that we have presented.
The execution test $\ET_{\SER}$ requires 
clients to execute transactions only when their view of the key-value store is up-to-date.


------------------

\begin{definition}[$\ET$-reductions]
\label{def:reduction}
An \emph{action} $\alpha \in \Act$ has either the form $(\cl, \varepsilon)$, 
or $(\cl, \opset)$, 
where $\cl$ is a client and $\opset$ is a fingerprint. 
Given an execution test $\ET$, the $\ET$-\emph{reduction}, 
$\xrightarrowtriangle{}_{\ET} \subseteq \Confs \times \Act \times \Confs$, 
is the smallest relation such that for all $\vi, \vi', \cl, \hh, \hh', \viewFun, \opset$:
\begin{enumerate}
	\item 
    $
    \viewFun(\cl) = \vi 
    \wedge \vi \sqsubseteq \vi' 
    \implies (\hh, \viewFun) \xrightarrowtriangle{(\cl, \varepsilon)}_{\ET} 
    (\hh, \viewFun\rmto{\cl}{\vi'})$; and
	\item 
    $\viewFun(\cl) = \vi
        \wedge (\ET \vdash (\hh, \vi) \triangleright \opset: \vi')  
        \wedge \hh' \in \updateKV(\hh, \vi, \cl, \opset) \implies
	$  \\
	\phantom{a} \hfill 
	$(\hh, \viewFun) \xrightarrowtriangle{(\cl, \opset)}_{\ET} (\hh', \viewFun\rmto{\cl}{\vi'})$
\end{enumerate}
Given an execution test $\ET$, an \emph{$\ET$-trace} is a sequence of $\ET$-reductions of the form $\conf_{0} \xrightarrowtriangle{\alpha_{0}}_{\ET} \cdots 
\xrightarrow{\alpha_{n-1}} \conf_{n}$.
\end{definition}

\subsubsection{Consistency Models}
Consistency models are computed from execution tests by closing the set of initial key-value stores with respect to two operations: 
\begin{enumerate*}[label=(\arabic*)]
	\item advancing the view of a client; and 
	\item committing a fingerprint of a transaction. 
\end{enumerate*}
Lastly, consistency models induced by execution tests are \emph{monotonic} (\cref{prop:mono-et}).

\begin{definition}[Consistency Models]
\label{def:cm}
Given an execution test $\ET$, the set of configurations induced by $\ET$ is given by:
\[
\Confs(\ET) \defeq \Setcon{ \conf}{ \exsts{\conf_0} \conf_0 \text{ is initial } \wedge \conf_0 \xrightarrowtriangle{\stub}_{\ET} \cdots \xrightarrowtriangle{\stub}_{\ET} \conf }
\]
The \emph{consistency model} induced by $\ET$ is:
\( 
\CMs(\ET) \defeq \Setcon{ \hh }{ (\hh, \stub) \in \Confs(\ET) }
\)
\end{definition}



\begin{proposition}
\label{prop:mono-et}
Let $\ET_1 \subseteq \ET_2$. Then $\CMs(\ET_1) \subseteq \CMs(\ET_2)$.
\end{proposition}
\begin{proof}
    \ifTechReport
    \input{\RootPath/semantics/et-mono.tex}
    \else
    See \cref{sec:mono-et}.
    \fi
\end{proof}

\begin{definition}
Two triples $(\cl_1, \opset_1)$ and $(\cl_2, \opset_2)$ are 
conflicting if either $\cl_1 = \cl_2$, or there exists a key $\ke$ such that 
$(\otW, \ke, \_) \in \opset_1, (\otW, \ke, \_) \in \opset_2$. 

An execution test is $\ET$ is \emph{commutative} if, whenever $(\cl_1, \vi_1, \opset_1)$, 
$(\cl_2, \vi_2, \opset_2)$ are non-conflicting, and $\vi_1, \vi_2 \in \Views(\hh_0)$,  
then for any $\hh_0, \hh', \viewFun, \viewFun'$ we have that 
\[
\begin{array}{lr}
(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} 
\_ \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} (\hh', \viewFun') &\implies \\
(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} 
\_ \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} (\hh', \viewFun')
\end{array}
\]
\end{definition}

\begin{definition}
An execution test $\ET$ has \emph{no blind writes} if, whenever $\ET \vdash (\hh, \vi) \triangleright \opset \cup \{(\otW, \ke, \_)\} : \vi'$, 
then $(\otR, \ke, \_) \in \opset$.
\end{definition}

\begin{definition}
An execution test $\ET$ has \emph{minimum footprints} if for any key-value store \( \hh \)
views \( \vi, \vi',\vi''\) and fingerprint \( \f \),
\[
\begin{array}{@{}l@{}}
    ( \fora{ \ke} (\stub, \ke, \stub) \in \f \implies \vi(\ke) = \vi'(\ke) ) \land {} \\
    \quad \ET \vdash (\hh, \vi) \triangleright \opset : \vi'' \implies \ET \vdash (\hh, \vi') \triangleright \opset : \vi''
\end{array}
\]
\end{definition}

\begin{definition}
An execution test $\ET$ has \emph{continuous post-views} if for any key-value store \( \hh \)
views \( \vi, \vi',\vi''\) and fingerprint \( \f \), 
\[
\begin{array}{@{}l@{}}
    \quad \ET \vdash (\hh, \vi) \triangleright \opset : \vi' \land \vi' \sqsubseteq \vi'' \implies \ET \vdash (\hh, \vi) \triangleright \opset : \vi''
\end{array}
\]
\end{definition}

\begin{theorem}                                                                            
Let $\ET_1, \ET_2$ be two execution tests has no blind writes, minimum footprints and continuous post-views.
If $\ET_1$ is commutative, 
then $\CMs(\ET_1 \cap \ET_2) = \CMs(\ET_1) \cap \CMs(\ET_2)$. 
Furthermore, if $\ET_1, \ET_2$ are commutative, then $\ET_1 \cap \ET_2$ 
is commutative.
\end{theorem}
\begin{proof}
    See \cref{sec:et-comm}.
\end{proof}


%\input{\RootPath/model/kvstore-view.tex}
%\input{\RootPath/model/exec-test.tex}
