\section{Operational Model}
\label{sec:model}

We define an interleaving operational semantics for atomic transactions over
global, centralised kv-stores and partial client views. 

\sx{
\mypar{Notation}
Given a set $\sort A$, we write $\sort A \ni a$ to denote that elements of $\sort A$ are ranged over by $a$ and its variants (\eg $a', a_1, \cdots$). 
Given relations $\mathsf r, \mathsf r' \subseteq \sort A \times \sort A$,
we write $\mathsf r\rflx$, $\mathsf r^+$ and $\mathsf r^*$ for its reflexive, transitive and reflexive-transitive closures of $\mathsf r$, respectively;
write $a_1 \toEDGE{\mathsf r} a_2$ for $(a_1, a_2) \in \mathsf r$;
and write \( \mathsf r; \mathsf r'\) for \( \Set{(a_1,a_2)}[\exsts{a} (a_1,a) \in \mathsf r\land (a,a_2) \in \mathsf r']\).
\sx{The first sentence is in the footnote. The rest can go to the beginning of sec 4.1 example of execution tests}
}


\subsection{Key-Value Stores and Client Views}
\label{subsec:kvstores}
\label{sec:mkvs-view}
%Kv-stores are defined using client and transaction identifiers.
Our global, centralised key-value stores and partial client views
provide the abstract memory model for our operational semantics. A
key-value store comprises key-indexed lists of versions which record
the history of the key update using meta-data of the
transactions that accessed it: that is,  the client identifiers;
the transaction identifiers; and the session order associated with
clients. 





We assume a countably infinite set of \emph{client identifiers}\footnote{ We use the notation
 $\sort A \ni a$ to denote that elements of $\sort A$ are ranged over
  by $a$ and its variants such as $a', a_1, \cdots$.},
$\Clients \ni \cl$.
The set of \emph{transaction identifiers}, $\TxID \ni t$, 
 is defined by
$\TxID \defeq  \Set{\txid_{0}} \uplus \Set{ \txid_{\cl}^{n} \mid \cl
  \in \Clients \land n \geq 0 }$, 
where  $\txid_0$ denotes  the  \emph{initialisation transaction}
and $\txid_{\cl}^{n}$ identifies a transaction committed by client
$\cl$ with $n$  determining  the client session order: that is, $\SO \defeq \Set{ (\txid, \txid') \mid \exsts{ \cl, n,m } \txid =
\txid_{\cl}^{n} \land \txid' = \txid_{\cl}^{m} \land n < m}$.
Subsets of $\TxID$  are ranged over by $\txidset, \txidset', \cdots$. 
We let $\TxID_{0} \defeq \TxID \setminus \Set{\txid_0}$. 
%For each $n \in \mathbb{N}$, $\txid_{\cl}^{n}$ identifies the $n$\textsuperscript{th} transaction  committed by $\cl$.
%We assume each client is associated with a session, 
%and the order of transactions within a single session is determined by the superscript 
%$n$ in transaction identifiers of the form $\txid_{\cl}^{n}$: we define the session order 
%as 
%$\SO \defeq \Set{ (\txid, \txid') \mid \exsts{ \cl, n,m } \txid =
%\txid_{\cl}^{n} \land \txid' = \txid_{\cl}^{m} \land n < m}$.

\begin{definition}[Kv-stores]
\label{def:his_heap}
\label{def:mkvs}
Assume a countably infinite set of \emph{keys}, $\Keys \ni \key$, 
and a countably infinite set of  \emph{values}, $\Val \ni \val$, 
which includes the keys and an \emph{initialisation value} $\val_0$.
The set of \emph{versions}, $\Versions \ni \ver$, is defined by $\Versions \defeq \Val \times \TxID \times \pset{\TxID_{0}}$. 
A \emph{kv-store} 
is a function $\mkvs: \Keys \to \func{List}[\Versions]$, 
where $\func{List}[\Versions] \ni \vilist$ is the set of lists of versions. %$\Versions$. 
\end{definition}

Each version has the form 
$\ver {=} (\val, \txid, \txidset)$, where $\val$ is
a value, the \emph{writer} $\txid$ identifies the transaction that
wrote $\val$,  and the \emph{reader set} $\txidset$ identifies the
transactions that read $\val$. We use the notation 
$\valueOf(\ver)$,
$\wtOf(\ver)$ and $\rsOf(\ver)$ to project
the individual components of $\ver$.
%Lists of versions (elements of $\Versions^{\ast}$) are ranged over by $\vilist, \vilist',\cdots$.
Given a kv-store $\mkvs$ and a transaction $\txid$, we write 
$\txid \in \mkvs$ if $\txid$ 
%appears as 
is either the writer or 
%amongst 
one of the readers of a version included in $\mkvs$, 
$\lvert \mkvs(\key) \rvert$ for the length of the version
list $\mkvs(\key)$,
and write $\mkvs(\key, i)$ for the $i$\textsuperscript{th} version of $\key$, 
%when defined, 
with $0 \leq i < \lvert \mkvs(\key) \rvert$.


We focus on kv-stores whose consistency model satisfies the
\emph{snapshot property}, ensuring that
a transaction reads and writes at most one version for each key.
This is a normal assumption for distributed databases, \eg in~\cite{ramp,rola,cops,wren,redblue,PSI,NMSI,gdur,clocksi,distrsi}.
We also assume that 
the version list for each key has an initial version 
carrying the initialisation value $\val_0$,  written by the 
%designated 
initialisation transaction $\txid_0$ with an initial empty reader set.
Finally, we assume that the kv-store agrees with the session order of clients: 
a client cannot read a
version of a key that has been written by a future transaction within
the same session; and the order in which versions are written by a
client must agree with its session order.  A kv-store is
\emph{well-formed} if it satisfies these three assumptions, defined
formally in \cref{def:mkvs-appendix}.  Henceforth, we assume kv-stores
are well-formed, and write $\MKVSs$ to denote the set of well-formed
kv-stores.

A global kv-store provides an abstract centralised description of
updates associated with distributed kv-stores that is \emph{complete} in 
that no update has been lost in the description. By contrast, in
both replicated and partitioned distributed databases, a client may
have incomplete information about updates distributed between
machines.  We model this incomplete information by
defining a {\em view} of the kv-store which provides a {\em
  partial} record of the updates observed by a client. We require that a client view be {\em atomic} in that it can
see either all or none of the updates of a transaction.


\pg{This makes sense for replicated databases. It is not at all clear
  to me that this makes sense for partitioned databases.}

\begin{definition}[Views]
\label{def:view}
\label{def:cuts}
\label{def:views}
\label{def:configuration}
A \emph{view} of a kv-store $\mkvs \in \MKVSs$ is a function
$\vi \in \Views(\mkvs) \defeq \Keys \to\pset{\Nat}$ such that, for all $i, i', \key, \key'$:
%
%\noindent\begin{minipage}{0.5\linewidth}
%\begin{equation}
%    0 \in \vi(\key) 
%    \land (i \in \vi(\key) \implies i < \abs{ \mkvs(\key) }) 
%    \tag{wf}
%    \label{eq:view.wf}
%\end{equation}
%\end{minipage}%
%\begin{minipage}{0.5\linewidth}
%\begin{equation}
% 	i \in \vi(\key)  
%  	\land \wtOf(\mkvs(\key, i)) {=} \wtOf(\mkvs(\key', i'))  
%  	\implies i' \in \vi(\key')
%	\tag{atomic}
%	\label{eq:view.atomic}
%\end{equation}
%\end{minipage}\par\vspace{\belowdisplayskip}

\vspace{-5pt}
{%
\displaymathfont
\begin{align*}
    & 
    0 \in \vi(\key) 
    \land (i \in \vi(\key) \implies 0 \leq i < \abs{ \mkvs(\key) }) 
    \tag{well-formed}
    \label{eq:view.wf}\\
    & 
    \begin{array}{@{}l@{}}
	i \in \vi(\key)  
  	\land \wtOf(\mkvs(\key, i)) {=} \wtOf(\mkvs(\key', i'))  
  	\implies i' \in \vi(\key')
    \end{array}
	\tag{atomic}
	\label{eq:view.atomic}
\end{align*}
}%
Given two views $\vi, \vi' \in \Views(\mkvs)$, 
the order between them is defined by $\vi \viewleq \vi' \defiff \fora{\key \in \dom(\mkvs)} \vi(k) \subseteq \vi'(\key)$.
The set of views is $\Views \defeq \bigcup_{\mkvs \in \MKVSs} \Views(\mkvs)$.
%
\noindent The \emph{initial view}, $\vi_{0}$,  is defined by
$\vi_{0}(\key) = \Set{0}$ for every $\key \in \Keys$. 
\end{definition}

Our operational semantics updates {\em configurations},  which are pairs
comprising a kv-store and a function describing the
views of a finite set of clients. 

\begin{definition}
A \emph{configuration}, $\conf \in \Confs $,  is a pair $ (\mkvs, \vienv)$
with $\mkvs \in \MKVSs$ and
$\vienv : \Clients \parfinfun \Views(\mkvs)$. 
The set of \emph{initial configurations}, $\Confs_0 \subseteq \Confs$,
contains configurations of the form $ (\mkvs_0, \vienv_0)$, where
$\mkvs_0$ is the { initial kv-store}
defined by
$\mkvs_{0}(\key)\defeq  (\val_0, \txid_0, \emptyset)$ for
all $\key \in \Keys$. 
\end{definition}


Given a configuration $(\mkvs, \vienv)$ and a client $\cl$, 
%when the view of client 
%$\cl$ is defined, that is, there exists $\vi = \vienv(\cl)$ such that for each key $\key \in \Keys$, 
%$\vi$ determines the sublist of versions in $\mkvs$ that client $\cl$ sees. 
if $\vi = \vienv(\cl)$ is defined then, for each $k$,  the
configuration determines the sub-list of versions in $\mkvs$ that $\cl$ sees.
If $i,j \in \vi(\key)$ and $i < j$, then $\cl$ sees the values 
carried by versions $\mkvs(\key, i)$ and  $\mkvs(\key, j)$, 
and it also sees that the version 
%these versions are contained in $\mkvs$ with 
$\mkvs(\key, j)$ is more 
up-to-date than $\mkvs(\key, i)$. 
%Given a configuration $(\mkvs, \vienv)$ and a client $\cl$ such that $\vienv(\cl)$ is
%defined, 
It is therefore possible to associate a \emph{snapshot}
with 
the view $\vienv(\cl)$, 
%of theview $\vienv(\cl)$, 
which identifies, for each key $\key$, the last write of a client view. 
This definition assumes that the database satisfies the \emph{last-write-wins}
resolution policy, employed by many distributed kv-stores.
%adopt this policy~\cite{ramp,rola,cops,wren,redblue,PSI,NMSI,gdur,clocksi,distrsi}, 
However, our formalism can be adapted straightforwardly  to capture other resolution policies. 

\begin{definition}[View Snapshots]
\label{def:snapshot}
Given $\mkvs \in \MKVSs$ and $\vi \in \Views(\mkvs)$, the \emph{snapshot} of $\vi$ in 
$\mkvs$ is afunction, $\snapshot[\mkvs, \vi] : \Keys \to
\Val$,   defined by $\snapshot[\mkvs, \vi] \defeq \lambda \key \ldotp \valueOf(\mkvs(\key, \max_{<}(\vi(\key)))$, 
where $\max_{<}(\vi(\key))$ is the maximum element in $\vi(\key)$ with respect to the natural 
order $<$ over $\mathbb{N}$.
\end{definition}

%\begin{remark}
%The client view describes the partial history of the database seen by the client. 
%The client snapshot describes the most up-to-date state of the database known to the client (based on its view). 
%It is not possible to work with the snapshot alone. 
%The client view is essential to express several standard consistency models (see~\cref{subsec:cm_examples}). 
%\ac{This remark is extremely vague at this point.}
%\end{remark}



\pg{This should go somewhere  where relevant: Given a relation $\mathsf r, \mathsf r_1, \mathsf r_2 \subseteq \sort A \times \sort A$,
we write $\mathsf r\rflx$, $\mathsf r^+$ and $\mathsf r^*$ for its reflexive, transitive and reflexive-transitive closures, respectively;
write $a_1 \toEDGE{\mathsf r} a_2$ for $(a_1, a_2) \in \mathsf r$;
and write \( \mathsf r_1 ; \mathsf r_2\) for \( \Set{(a_1,a_2)}[\exsts{a} (a_1,a) \in \mathsf r_1 \land (a,a_2) \in \mathsf r_2]\).}

\subsection{Operational Semantics}

\vspace{5pt}
\mypar{Programming Language}
A \emph{program} \( \prog \) comprises a finite number of clients,
where each client is associated with a unique identifier \( \cl \in \Clients \), 
and executes a sequential \emph{command} $\cmd$, given by the following grammar:

\vspace{-5pt}
{%
\[
\displaymathfont
\begin{aligned}
\cmd & ::=  
\pskip \!\mid\!
\cmdpri \!\mid\!  
\ptrans{\trans} \!\mid\! 
\cmd \pseq \cmd \!\mid\! 
\cmd \pchoice \cmd \!\mid\! 
\cmd \prepeat
&
 \cmdpri & ::=  
\passign{\var}{\expr} \!\mid\! 
\passume{\expr} 
\\
\trans & ::=
\pskip \!\mid\!
\transpri \!\mid\! 
\trans \pseq \trans \!\mid\!
\trans \pchoice \trans \!\mid\!
\trans\prepeat    
&
\transpri & ::= 
\cmdpri \!\mid\!
\plookup{\var}{\expr} \!\mid\!
\pmutate{\expr}{\expr} 
\end{aligned}%
\]
}%
%
%
Sequential commands ($\cmd$) comprise $\pskip$, primitive commands
($\cmdpri $), atomic transactions $\ptrans{\trans}$, and standard
compound constructs: sequential composition (\( ; \)), non-deterministic
choice (\( + \)) and iteration (\( * \)). 
Primitive commands include variable assignment
($\passign{\var}{\expr}$) and assume statements ($\passume{\expr}$)
which can be used to encode conditionals. They  are used for computations based on client-local variables and can hence be invoked
without restriction.  Transactional commands ($\trans$) comprise
$\pskip$, primitive transactional commands ($\transpri$), and the
standard compound constructs.  Primitive transactional commands comprise
primitive commands, lookup ($\plookup{\var}{\expr}$) and mutation
($\pmutate{\expr}{\expr}$) used for reading and writing to kv-stores
respectively, which can only be invoked as part of an atomic
transaction.



A {\em program} is a finite partial function from client identifiers to sequential
commands.
For clarity, we often write \( \cmd_{1}\ppar \dots \ppar \cmd_{n}\) as syntactic sugar 
for a program \( \prog \) with $n$ clients associated with identifiers
$\cl_1 \dots \cl_n$, where each client $\cl_i$ executes
$\cmd_i$. 
Each client $\cl_i$ is associated with its own client-local  \emph{stack}, 
$\stk_i \in \Stacks \defeq \Vars \to \Val$,  mapping program variables
(ranged over by $\pvar{x}, \pvar{y}, \cdots$)
to values. 
We assume a language of expressions built from values \( \val \)
and program variables \( \var \):
$\expr ::= \val \mid \var \mid \expr + \expr \mid \cdots$.
The \emph{evaluation} $\evalE{\expr}$ of expression $\expr$ is parametric in
the client-local stack \( \stk \):%

\vspace{-5pt}
{%
\[
\displaymathfont
\begin{gathered}
\evalE{\val} \defeq
\val
\quad
\evalE{\var} \defeq
\stk(\var)
\quad
\evalE{\expr_{1} + \expr_{2}} \defeq
\evalE{\expr_{1}} + \evalE{\expr_{2}}
\quad
\dots
\end{gathered}%
\]
}%

\mypar{Transactional Semantics} \pg{I understand that in replicated
  databases it is probably normal for transactions to be executed
  atomically. I am not so sure about partitioned databases. It seems
  odd.
  \sx{The implementation of replicated or partitioned databases, 
      does not guarantee the actual execution of a transaction is atomic at all.
      But many databases want transactions appear as if it ruined atomically,
      because this is what people feel familiar with 
      and it lifts burden for programmers from dealing with very chaotic behaviours.
  }
  }  In our operational semantics, transactions are executed
\emph{atomically}. It is still possible for an underlying
implementation, such as COPS, to update the distributed kv-store while
the transaction is in progress. It just means that, given the
abstractions captured by our global kv-stores and partial views, 
such an update is modelled as  an instantaneous  atomic
update.
Intuitively, given a configuration $\conf = (\mkvs, \vienv)$, 
when a client $\cl$ executes a transaction $\ptrans{\trans}$, 
it performs the following steps: 
\begin{enumerate*}
	\item it constructs an initial \emph{snapshot} $\sn$ of $\mkvs$ using its view $\vienv(\cl)$ as defined in \cref{def:snapshot};  
	\item it executes $\trans$ in isolation over $\sn$
        accumulating the effects (the reads and writes) of executing $\trans$; and
	\item it commits $\trans$ by incorporating these effects into $\mkvs$.
\end{enumerate*}

\begin{definition}[Transactional Snapshots]
\label{def:heaps}
A \emph{transactional snapshot}, \( \sn \in \Snapshots \defeq \Keys \to
\Val\),  is a function from keys to values. When the meaning is clear,
it is just called a {\em snapshot}. 
\end{definition}

The rules for transactional commands will be defined  using an arbitrary 
transactional snapshot. The rules for sequential
commands and programs will be defined  using a transactional
snapshot given by a view snapshot. 
To capture the effects of executing a transaction $\trans$ on a snapshot $\sn$ of kv-store $\mkvs$, 
we identify a \emph{fingerprint}  of $\trans$ on $\sn$ which captures
 the values $\trans$ reads from $\sn$, and
%the write operations capture 
the values $\trans$ writes to $\sn$ and intends to commit to $\mkvs$. 
%so long as certain consistency conditions are met.  
Execution of a transaction in a given configuration may result in more than one fingerprint due to non-determinism. 

\begin{definition}[Fingerprints]
\label{beebop}
\label{def:fingerprint}
Let \( \Ops\) denote the set of read (\( \otR\)) and write (\(\otW\)) \emph{operations} defined by 
$\Ops \defeq \Set{(l, \key, \val) }[ l \in \Set{\otR, \otW} \land \key \in \Keys \land \val \in \Val ]$.
A \emph{fingerprint} $\fp$ is a set of operations, $\fp \subseteq \Ops$,
such that: 
$\fora{\key \in \Keys, l  \in \Set{\otR, \otW}}
	(l, \key, \val_1), (l, \key, \val_2) \in \fp \implies \val_1 = \val_2$.
\end{definition}
\noindent 
%The last constraint ensure that for each key, 
According to \cref{def:fingerprint}, a fingerprint contains at most one read operation and at most one write operation. 
This reflects our assumption regarding transactions that satisfy the snapshot property: reads are taken from a single snapshot of the kv-store;
and 
%since clients see either none or all the writes of a transaction, only the last write to each key is 
only the last write of a transaction to each key is committed to the kv-store.
\begin{figure*}[!t]
\begin{center}
\scalebox{.9}{%
\begin{tabular}{@{}c@{\hspace{20pt}}c@{}}
    $
    \inferrule[\rl{TPrimitive}]{%
        (\stk, \sn) \toLTS{\transpri} (\stk', \sn') 
       \\
        \op = \func{op}[\stk, \sn, \transpri]
    }{%
        (\stk, \sn, \fp) , \transpri  \toTRANS   (\stk', \sn', \fp \addO \op) , \pskip 
    }%
    $
    &
    $
 \begin{array}{ll}
    \fp \addO (\otR, \key, \val)  
    & \defeq
    \begin{cases}
        \fp \cup \Set{(\otR, \key, \val)} & \text{if } \fora{l, v'} (l, \key, v') \! \notin \! \fp \\
        \fp &  \text{otherwise} \\
    \end{cases}  \\
    \fp \addO (\otW, \key, \val) 
    & \defeq 
    \left( \fp \! \setminus \! \Set{(\otW, \key, v')}[v' \in \Val] \right)  \!
    \cup \! \Set{(\otW, \key, \val)} \\
    \fp \addO \emptyop  & \defeq \fp 
\end{array}
$
    \\
    $
     \inferrule[\rl{TChoice}]{%
		i \in \Set{1,2}
    }{%
		(\stk, \sn, \fp) , \trans_{1} \pchoice \trans_{2}  \toTRANS  (\stk, \sn, \fp) , \trans_{i}
    }
    $
    &
    $
    \inferrule[\rl{TIter}]{ }{%
        (\stk, \sn, \fp),  \trans\prepeat \toTRANS  (\stk, \sn, \fp), \pskip \pchoice (\trans \pseq \trans\prepeat)
    }%
    $
    \\[20pt]
    $
    \inferrule[\rl{TSeqSkip}]{ }{%
        (\stk, \sn, \fp), \pskip \pseq \trans \toTRANS  (\stk, \sn, \fp), \trans
    }%
    $
    &
    $
    \inferrule[\rl{TSeq}]{%
		(\stk, \sn, \fp), \trans_{1} \toTRANS  (\stk', \sn', \fp'), \trans_{1}'
    }{%
		(\stk, \sn, \fp), \trans_{1} \pseq \trans_{2} \toTRANS  (\stk', \sn', \fp'), \trans_{1}' \pseq \trans_{2}
    }%
    $\\[10pt]
\end{tabular}
}

\hrulefill

\end{center}
%\captionsetup{belowskip=-5pt}
\caption{Rules for transactional commands.}
\label{fig:semantics-trans}
\end{figure*}

\Cref{fig:semantics-trans} presents the rules for transactional commands. 
The only non-standard rule is \( \rl{TPrimitive} \), which updates 
the snapshot and the fingerprint of a transaction: the premise 
$(\stk, \sn) \toLTS{\transpri} (\stk', \sn')$ describes how executing
$\transpri$ affects the local state (the client stack and the snapshot)
of a transaction; and the premise $o =\func{op}(\stk, \sn, \transpri)$ identifies the operation on the 
kv-store associated with $\transpri$. 
%let \( \mathsf f\rmto{\mathsf d}{\mathsf r} \) denotes a new function 
%where \( \mathsf f\rmto{\mathsf d}{\mathsf r}(\mathsf d') = {\mathsf r} \) if \( \mathsf d = \mathsf d' \), 
%otherwise \( \mathsf f\rmto{\mathsf d}{\mathsf r}(\mathsf d') = \mathsf f(\mathsf d') \).
%, used in the second premise of the rule  identifies 
%the action 
%Except for Rule \( \rl{TPrimitive} \) rule that updates transactional state and accumulates fingerprint,
%the rules for compound commands are standard.
%We provide an operational description of the behaviour of a transactional command, $\trans$,
%starting from an initial client stack, a transactional state and the empty fingerprint $\emptyset$. 
%For \( \rl{TPrimitive} \) rule, first, we define a transition system describing 
%how client stack and transactional state are updated via primitive transactional commands.

\begin{definition}
\label{def:primitive_semantics}
The relation $\toLTS{\transpri}\; \subseteq (\Stacks \times \Snapshots) \times (\Stacks \times \Snapshots)$ 
is defined by\footnote{ 
For any function \( \mathsf f \), the function \( \mathsf f
\rmto{\mathsf d}{\mathsf r}\) 
is defined by 
\( \mathsf f
\rmto{\mathsf d}{\mathsf r}
( {\mathsf d}) = {\mathsf r}$, and \( 
\mathsf f
\rmto{\mathsf d}{\mathsf r}
({\mathsf d}') = {\mathsf f}({\mathsf d}')$ if \( 
{\mathsf d}' \neq {\mathsf d}\). } :
%
{%
\[
\displaymathfont
    \begin{array}{@{} r @{\ } c @{\ } l @{\quad} r @{\ } c @{\ } l@{}}
(\stk, \sn)  & \toLTS{\passign{\var}{\expr}}
             & (\stk\rmto{\var}{\evalE{\expr}}, \sn) 
&
(\stk, \sn)  & \toLTS{\passume{\expr}}  
             & (\stk, \sn) \text{ where } \evalE{\expr} \neq 0
\\
(\stk, \sn)  & \toLTS{ \plookup{\var}{\expr} } 
             & (\stk\rmto{\var}{\sn(\evalE{\expr})}, \sn) 
&
(\stk, \sn) & \! \toLTS{\pmutate{\expr_{1}}{\expr_{2}}} \!
            & (\stk, \sn\rmto{\evalE{\expr_{1}}}{\evalE{\expr_{2}}}) \ 
\end{array}
\]%
}%
%
%
%Second, we define 

The function  $\mathsf{op}$, computing the fingerprint of primitive
transactional 
commands,  is defined by:
%
\[%
\displaymathfont
\begin{aligned}
    \func{op}[\stk, \sn, \passign{\var}{\expr}] & \defeq  \emptyop 
    & 
    \func{op}[\stk, \sn, \passume{\expr}] & \defeq \emptyop 
    \\
    \func{op}[\stk, \sn,  \plookup{\var}{\expr}] & \defeq (\otR, \evalE{\expr}, \sn(\evalE{\expr})) 
    &
    \func{op}[\stk,  \sn, \pmutate{\expr_{1}}{\expr_{2}}] & \defeq (\otW, \evalE{\expr_{1}}, \evalE{\expr_{2}})
\end{aligned}
\]%
The  empty operation $\emptyop$ is used for those primitive commands that do not
contribute to the fingerprint.
\end{definition}
The conclusion of the \( \rl{TPrimitive}\)  rule uses the \emph{combination operator} $\addO: 
\pset{\Ops} \times (\Ops \uplus \Set{\emptyop}) \to \pset{\Ops}$, defined 
in \cref{fig:semantics-trans}, to extend the fingerprint $\fp$ accumulated thus far with
operation $o$ associated with $\transpri$, as
appropriate: it adds  a read from $\key$  if $\fp$ does not already
contain an entry for $\key$; and it always updates the  write for 
$\key$ to $\fp$, removing previous writes to $\key$.


%Third, we define a \emph{combination} operator,
%$\addO  : \pset{\Ops} \times \Ops \uplus \Set{\emptyop} \to \pset{\Ops}$ which
%adds a read/write operation to a fingerprint and ignores the empty operation $\emptyop$:%
%\[
%\begin{aligned}
%    \fp \addO (\otR, \key, \val)  
%    & \defeq
%    \begin{cases}
%        \fp \cup \Set{(\otR, \key, \val)} & \text{if } \fora{l, v'} (l, \key, v') \! \notin \! \fp \\
%        \fp &  \text{otherwise} \\
%    \end{cases}  \\
%    \fp \addO (\otW, \key, \val) 
%    & \defeq 
%    \left( \fp \! \setminus \! \Set{(\otW, \key, v')}[v' \in \Val] \right)  \!
%    \cup \! \Set{(\otW, \key, \val)} \\
%    \fp \addO \emptyop  & \defeq \fp 
%\end{aligned}
%\]
%Note that a read from $\key$ is added to a fingerprint $\fp$ only if $\fp$ does not contain an entry for $\key$, thus only recording the first value read for $\key$ (before a subsequent write). 
%In contrast, a write to $\key$ is always added to $\fp$ by removing the existing writes, thus only recording the last write to $\key$. 
%
%\begin{figure*}[!t]
%\begin{mathpar}
%    \inferrule[\rl{TPrimitive}]{%
%        (\stk, \sn) \toLTS{\transpri} (\stk', \sn') 
%        \\
%        \op = \func{op}[\stk, \sn, \transpri]
%    }{%
%        (\stk, \sn, \fp) , \transpri  \toTRANS   (\stk', \sn', \fp \addO \op) , \pskip 
%    }%
%    \and
% \begin{array}{ll}
%    \fp \addO (\otR, \key, \val)  
%    & \defeq
%    \begin{cases}
%        \fp \cup \Set{(\otR, \key, \val)} & \text{if } \fora{l, v'} (l, \key, v') \! \notin \! \fp \\
%        \fp &  \text{otherwise} \\
%    \end{cases}  \\
%    \fp \addO (\otW, \key, \val) 
%    & \defeq 
%    \left( \fp \! \setminus \! \Set{(\otW, \key, v')}[v' \in \Val] \right)  \!
%    \cup \! \Set{(\otW, \key, \val)} \\
%    \fp \addO \emptyop  & \defeq \fp 
%\end{array}
%    \\
%     \inferrule[\rl{TChoice}]{%
%		i \in \Set{1,2}
%    }{%
%		(\stk, \sn, \fp) , \trans_{1} \pchoice \trans_{2}  \toTRANS  (\stk, \sn, \fp) , \trans_{i}
%    }
%    \and
%    \inferrule[\rl{TIter}]{ }{%
%        (\stk, \sn, \fp),  \trans\prepeat \toTRANS  (\stk, \sn, \fp), \pskip \pchoice (\trans \pseq \trans\prepeat)
%    }%
%    \and
%    \inferrule[\rl{TSeqSkip}]{ }{%
%        (\stk, \sn, \fp), \pskip \pseq \trans \toTRANS  (\stk, \sn, \fp), \trans
%    }%
%    \and
%    \inferrule[\rl{TSeq}]{%
%		(\stk, \sn, \fp), \trans_{1} \toTRANS  (\stk', \sn', \fp'), \trans_{1}'
%    }{%
%		(\stk, \sn, \fp), \trans_{1} \pseq \trans_{2} \toTRANS  (\stk', \sn', \fp'), \trans_{1}' \pseq \trans_{2}
%    }%
%\end{mathpar}
%\hrulefill
%%\captionsetup{belowskip=-5pt}
%\caption{Semantics rules for transactional commands}
%\label{fig:semantics-trans}
%\end{figure*}

%Finally, we have all the ingredients to describe the behaviour of a transactional command.  \Cref{fig:semantics-trans} provides the one-step transactional semantics; 
%the interesting rule is the \rl{TPrimitive} rule which describes how a primitive transactional command updates the client stack, the snapshot and the fingerprint; 
%the remaining rules are standard.

\begin{definition}[Fingerprint Set]
Given a client stack $\stk$ and a snapshot $\sn$, the \emph{fingerprint set} of a transaction $\trans$ is:
\(
\Fingerprints \defeq \Set{\fp \mid (\stk, \sn, \emptyset), \trans \toTRANS^* (\stk', \sn', \fp), \pskip }
\)
where $\toTRANS^*$ denotes the reflexive, transitive closure of $\toTRANS$ given in \cref{fig:semantics-trans}.  
A set $\fp \in \Fingerprints$ is called a \emph{final fingerprint} of $\trans$. 
\end{definition}
\noindent 
%It is immediate to see that final fingerprints of $\trans$ 
%A final fingerprint of $\trans$ contains at most one read (resp.\ one write) operation per key.

\mypar{Operational Semantics}
We give the operational semantics of commands and programs in
\cref{fig:semantics-commands}.  
%
\begin{figure*}[!t]
\begin{center}
\scalebox{.9}{%
\begin{tabular}{@{}c@{\hspace{20pt}}c@{}}
    $
    \inferrule[\rl{CPrimitive}]{
		\stk \toLTS{\cmdpri} \stk'
    }{
        \cl \vdash 
        ( \mkvs, \vi, \stk ) , \cmdpri 
        \toCMD{(\cl,\iota)}_{\ET} 
        ( \mkvs, \vi, \stk' ) , \pskip
    }%
    $
    &
    $
 \begin{array}{r @{\ }c @{\ } l}
        \stk & \toLTS{\passign{\var}{\expr}} & \stk\rmto{\var}{\evalE{\expr}} \\
        \stk & \toLTS{\passume{\expr}} & \stk \ \text{where} \ \evalE{\expr} \neq 0
\end{array}
$
\\[30pt]
\multicolumn{2}{c}{
    $
     \inferrule[\rl{CAtomicTrans}]{%
        \vi \viewleq  \vi'' 
        \\
        \sn = \snapshot[\mkvs,\vi''] 
        \\
        (\stk, \sn, \emptyset), \trans \toTRANS^{*}   (\stk', \stub,
  \fp) , \pskip
  \\
   \txid \in \nextTxid[\cl, \mkvs] 
    \\\\
     \mkvs' = \updateKV[\mkvs, \vi'', \fp, \txid] 
\\
	\cancommit{\mkvs}{\vi''}{\fp}
\\
	\vshift{\mkvs}{\vi''}{\mkvs'}{\vi'}	
    }{%
        \cl \vdash 
        ( \mkvs, \vi, \stk ), \ptrans{\trans} 
        \toCMD{(\cl, \vi'', \fp)}_{\ET}
        (\mkvs',\vi', \stk' ) , \pskip
    }%
    $
    }




    \\[20pt]
    \multicolumn{2}{c}{
    $
    \inferrule[\rl{PProg}]{%
	    \vi = \vienv (\cl)
        \\
        \stk = \thdenv(\cl)
        \\
        \cmd = \prog(\cl)
        \\
		\cl \vdash 
		( \mkvs, \vi, \stk ) , \cmd
		\toCMD{\lambda}_{\ET} 
		( \mkvs', \vi', \stk' ) , \cmd'  
    }{%
		\vdash 
		(\mkvs, \vienv, \thdenv ), \prog
		\toCMD{\lambda}_{\ET} 
		( \mkvs', \vienv\rmto{\cl}{\vi'}, \thdenv\rmto{\cl}{\stk'} ) , \prog\rmto{\cl}{\cmd'} ) 
    }%
    $
    }\\[10pt]
\end{tabular}
}
\end{center}

\hrulefill

\caption{Rules for  sequential commands and programs.}
\label{fig:semantics-commands}
\end{figure*}
%
The command semantics describes transitions of the form
$\cl \vdash (\mkvs, \vi, \stk), \cmd \ \toCMD{\lambda}_{\ET} \ (\mkvs', \vi', \stk') ,
\cmd'$, stating that given the kv-store $\mkvs$, view $\vi$ and stack $\stk$, 
a client $\cl$ may execute command $\cmd$ for one step, updating 
the kv-store to $\mkvs'$, the stack to $\stk'$, and the command to its continuation $\cmd'$.
The label $\lambda$ is either of the form $(\cl, \iota)$ denoting that $\cl$ executed a primitive command
that required no access to $\mkvs$, 
or $(\cl, \vi'', \fp)$ denoting that $\cl$ committed an atomic transaction with final fingerprint $\fp$ under the view $\vi''$.
The semantics is parametric in the choice of \emph{execution test}
$\ET$ for kv-stores, which is used to generate 
the \emph{consistency model} on kv-stores
under which a 
transaction can execute.
In \cref{sec:cm}, we give many examples of execution tests for
well-known consistency models.
In \cref{sec:other_formalisms} and the technical appendix, we prove that our execution tests (using kv-stores) generate consistency models that are equivalent to existing definitions of
consistency models (using execution graphs). 

%\begin{figure*}[t]
%\begin{mathpar}
    %\inferrule[\rl{CPrimitive}]{
		%\stk \toLTS{\cmdpri} \stk'
    %}{
        %\cl \vdash 
        %( \mkvs, \vi, \stk ) , \cmdpri 
        %\toCMD{(\cl,\iota)}_{\ET} 
        %( \mkvs, \vi, \stk' ) , \pskip
    %}%
    %\\
    %\inferrule[\rl{CAtomicTrans}]{%
        %\vi \viewleq  \vi'' 
        %\\
        %\sn = \snapshot[\mkvs,\vi''] 
        %\\\\
        %(\stk, \sn, \emptyset), \trans \toTRANS^{*}   (\stk', \stub,  \fp) , \pskip
        %\\\\
        %\txid \in \nextTxid[\cl, \mkvs] 
        %\\
        %\mkvs' = \updateKV[\mkvs, \vi'', \fp, \txid] 
        %\\\\
        %\ET \vdash (\mkvs, \vi'') \csat \fp : (\mkvs',\vi')
    %}{%
        %\cl \vdash 
        %( \mkvs, \vi, \stk ), \ptrans{\trans} 
        %\toCMD{(\cl, \vi'', \fp)}_{\ET}
        %(\mkvs',\vi', \stk' ) , \pskip
    %}%
    %\and
    %\inferrule[\rl{PProg}]{%
		%\ \vi = \vienv (\cl)
        %\\
        %\! \vienv' = \vienv\rmto{\cl}{\vi'}
        %\\\\
        %\ \stk = \thdenv(\cl)
        %\\
        %\thdenv' = \thdenv\rmto{\cl}{\stk'}
        %\\\\
        %\cmd = \prog(\cl)
        %\\
        %\prog' = \prog\rmto{\cl}{\cmd'}
        %\\\\
		%\cl \vdash 
		%( \mkvs, \vi, \stk ) , \cmd
		%\toCMD{\lambda}_{\ET} 
		%( \mkvs', \vi', \stk' ) , \cmd'  
    %}{%
		%\vdash 
		%(\mkvs, \vienv, \thdenv ), \prog
		%\toCMD{\lambda}_{\ET} 
		%( \mkvs', \vienv', \thdenv' ) , \prog' ) 
    %}%
%\end{mathpar}
%\hrulefill

%\caption{Semantic rules for primitive  commands, atomic transactions and programs}
%\label{fig:semantics}
%\end{figure*}


%\cref{fig:semantics} contains the rules for primitive commands and

The rules for the compound constructs are straightforward and given in \cref{sec:full-semantics}.
The rule for primitive commands, $\rl{CPrimitive}$, 
depends on the 
transition system $\toLTS{\cmdpri} \subseteq \Stacks \times \Stacks$ 
%shown below, which 
which simply describes how the primitive command $\cmdpri$ affects the local state of a client.
%(\cref{def:primitive_semantics}) to all primitive commands. %that only affect the client stack.
%\begin{mathpar}
%    \inferrule[\rl{CPrimitive}]{
%		\stk \toLTS{\cmdpri} \stk'
%    }{
%        \cl \vdash 
%        ( \mkvs, \vi, \stk ) , \cmdpri 
%        \toCMD{(\cl,\iota)}_{\ET} 
%        ( \mkvs, \vi, \stk' ) , \pskip
%    }%
%    \and
%    \begin{array}{r @{\ }c @{\ } l}
%        \stk & \toLTS{\passign{\var}{\expr}} & \stk\rmto{\var}{\evalE{\expr}} \\
%        \stk & \toLTS{\passume{\expr}} & \stk \ \text{where} \ \evalE{\expr} \neq 0
%\end{array}
%\end{mathpar}
The rule \rl{CAtomicTrans}  describes the execution of an atomic 
transaction under the execution test $\ET$. 
%\begin{mathpar}
%    \inferrule[\rl{CAtomicTrans}]{%
%        \vi \viewleq  \vi'' 
%        \\
%        \sn = \snapshot[\mkvs,\vi''] 
%        \\
%        (\stk, \sn, \emptyset), \trans \toTRANS^{*}   (\stk', \stub,  \fp) , \pskip
%        \\\\
%        \txid \in \nextTxid[\cl, \mkvs] 
%        \\
%        \mkvs' = \updateKV[\mkvs, \vi'', \fp, \txid] 
%        \\
%        \ET \vdash (\mkvs, \vi'') \csat \fp : (\mkvs',\vi')
%    }{%
%        \cl \vdash 
%        ( \mkvs, \vi, \stk ), \ptrans{\trans} 
%        \toCMD{(\cl, \vi'', \fp)}_{\ET}
%        (\mkvs',\vi', \stk' ) , \pskip
%    }%
%\end{mathpar}


We describe the \rl{CAtomicTrans} rule in detail. 
The first premise 
states that the current view $\vi$ of the executing command may be advanced to a newer  view $\vi''$ (see \cref{def:views}). 
%This corresponds to the client receiving new updates.
Given the new view $\vi''$, the transaction obtains a snapshot $\sn$ of the kv-store $\mkvs$, 
and executes $\trans$ locally to completion ($\pskip$), updating the stack to $\stk'$, while accumulating the fingerprint $\fp$; 
this behaviour  is modelled in the second and third premises of \rl{CAtomicTrans}.
Note that the resulting snapshot is ignored 
%(denoted by $\stub$) 
as the effect of the transaction is recorded in the fingerprint $\fp$. 
%
%%The transaction is now ready to commit. 
%%The \( \rl{CAtomicTrans} \) rule
%Rule \(\rl{CAtomincTrans} \) models a client $\cl$ with view $\vi$ committing a transaction 
%with fingerprint $\fp$ in $\mkvs$. 
The $\cancommit{\mkvs}{\vi''}{\fp}$ premise ensures that under the execution test $\ET$, 
the final fingerprint $\fp$ of the transaction is compatible with the (original) kv-store
$\mkvs$ and the client view $u''$, and thus the transaction \emph{can commit}. 
Note that the \cancommitname check is parametric in the execution test $\ET$.
This is because the conditions checked upon committing depend on the consistency model under which the transaction is to commit. 
In \cref{sec:cm}, we define \cancommitname for several execution tests associated with well-known consistency models.


Now we are ready for client $\cl$ to commit the transaction resulting 
in the kv-store $\mkvs'$ with the client view $\vi''$ \emph{shifting} to a new view $\vi'$: 
%in an new kv-store $\mkvs'$ and a view $\vi'$ for the client $\cl$ via the following process:  
pick a fresh transaction identifier $\txid \in \nextTxid[\cl,
  \mkvs]$;
compute the new kv-store via $\mkvs' = \updateKV[\mkvs, \vi'',
  \fp, \txid]$; 
and 
check if the \emph{view shift} is permitted under execution test $\ET$ using $\vshift{\mkvs}{\vi''}{\mkvs'}{\vi'}$. 
Observe that as with \cancommitname, the \vshiftname check is parametric in the execution test $\ET$. 
Once again this is because the conditions checked for shifting the client view depend on the consistency model. 
In \cref{sec:cm} we define \vshiftname for several execution tests associated with well-known consistency models.
The set $\nextTxid[\cl, \mkvs]$ is defined by
\(
\nextTxid[\cl, \mkvs] \defeq 
\Set{\txid_{\cl}^{n}}[%
\fora{m} \txid_{\cl}^{m} \in \mkvs \implies m < n ]
\).
%By construction, all elements of $\nextTxid[\cl, \mkvs]$ are greater (with respect to session order $\SO$) 
%than transaction identifiers previously used by $\cl$. 
The function $\updateKV[\mkvs, \vi, \fp, \txid]$
describes how the fingerprint $\fp$ of $\txid$ executed under $\vi$ updates $\mkvs$:
%The function $\updateKV[\mkvs, \vi, \fp, \txid]$ updates $\mkvs$ with $\fp$ as follows: 
for each read $(\otR, \key, \val) \in \fp$, it adds $\txid$ 
to the reader set of the last version of $\key$ in $\vi$; 
for each write $(\otW, \key, \val)$, it appends a new version $(\val, \txid, \emptyset)$ 
to $\mkvs(\key)$. 


\begin{definition}[Transactional update]
\label{eq:updatekv}
\label{def:updatekv}
The function  $\updateKV[\mkvs, \vi, \fp, \txid]$,  is
defined by:
%
%{%
%\[%
%\begin{aligned}
%    \updateKV[\mkvs, \vi, \emptyset, \txid] & \defeq \mkvs 
%    \\[3pt]
%    \updateKV[\mkvs, \vi, \Set{(\otR, \key, \val)} \uplus \fp, \txid]
%    & \defeq \updateKV[\mkvs\rmto{\key}{\vilist},\vi, \fp, \txid] \\
%    \omit\rlap{where \qquad \( i {=} \max_{<}(\vi(\key)) \quad (\val, \txid', \txidset) = \mkvs(\key, i) 
%            \quad \vilist = \mkvs(\key)\rmto{i}{(\val, \txid', \txidset \uplus \Set{ \txid })}\)} 
%    \\[3pt]
%%	
%	\updateKV[\mkvs, \vi, \Set{(\otW, \key, \val)} \uplus \fp, \txid] 
%    & \defeq \updateKV[\mkvs', \vi, \fp, \txid] \quad \text{where} \quad  \mkvs' = \mkvs\rmto{\key}{ \mkvs(\key) \lcat (\val, \txid, \emptyset) } \\
%\end{aligned}
%\]%
%}%
%

\vspace{-5pt}
{%
\displaymathfont
\[%
\begin{array}{lcl}
    \updateKV[\mkvs, \vi, \emptyset, \txid] & \defeq & \mkvs 
    \\
    \updateKV[\mkvs, \vi, \Set{(\otR, \key, \val)} \uplus \fp, \txid]
    & \defeq & \text{let } i = \max_{<}(\vi(\key)), (\val,\txid',\txidset) = \mkvs(\key,i) \text{ in } \\
    && \;\;\;\; \updateKV[\mkvs\rmto{\key}{\mkvs(\key)\rmto{i}{(\val, \txid', \txidset \uplus \Set{\txid})}},\vi, \fp, \txid] \\
%	
	\updateKV[\mkvs, \vi, \Set{(\otW, \key, \val)} \uplus \fp, \txid]
    & \defeq & \text{let } \mkvs' = \mkvs\rmto{\key}{ \mkvs(\key) \lcat (\val, \txid, \emptyset) } \text{ in } \updateKV[\mkvs', \vi, \fp, \txid] 
\end{array}
\]%
}
%
where, given a list of versions $\vilist = \ver_0 \lcat \cdots \lcat \ver_n$ 
and an index $i: 0 \leq i \leq n$, 
then $\vilist\rmto{i}{\ver} \defeq \ver_0 \lcat \cdots \lcat \ver_{i-1} \lcat \ver \lcat \ver_{i+1} \cdots \ver_{n}$,
%then $\vilist\rmto{i}{\ver}$ denotes 
%$\vilist' = \ver_0 \lcat \cdots \lcat \ver_{i-1} \lcat \ver \lcat
%\ver_{i+1} \cdots \ver_{n}$. 

\end{definition}

\pg{Above list notation not great.} 

%
%...now explain OK, this requires care, bringing in ideas from 4.1,
%I've started but not finished.....
%
%\begin{enumerate}
%\item $\mathsf{OKAny}\vdash (\mkvs, \vi) 
%\csat (\mkvs', \vi') $ if and only if $\vi'$ is a view compatible with
%$\mkvs'$. In the Appendix, we describe  execution tests that capture the 
% monotonic writes (\MW)  and write your reads (\WFR) session guarantees 
%where $\OK_{\MR}$ and $\OK_{\RYW}$ are both $\mathsf{OKAny}$. 
%\item $\OK_{\MR} \vdash (\mkvs, \vi) 
%\csat (\mkvs', \vi') $ if and only if $    \vi \viewleq  \vi'\vi $
%(see \cref{def:views}).
%This test states that a client cannot loose information from a view by
%committing a transaction. We shall see that it gives rise to the
%monotonic reads (\MR) session guarantee. 
%\item $\OK_{\RYW}  \vdash (\mkvs, \vi) 
%\csat (\mkvs', \vi') $ if and only if ......We shall see that this
%gives rise to the read your writes (\RYW) session guarantee. 
%\end{enumerate}
%........

%Note that,  under the assumption that 
%When $\fp$ contains at most one read and one write 
%operation per key and the identifier is fresh for $\mkvs$, 
%the transaction update function and the transaction update set for
%$\cl$ are well-defined. 
%(details in \cref{sec:updatekv-well-defined}). 

%Finally, the client \( \cl \) can pick a new view \( \vi' \) as long as 
%the transition from \( (\mkvs, \vi'') \) to \( (\mkvs', \vi') \)  via fingerprint \( \fp \) 
%is permitted by execution test $\ET$ using the judgement $\ET \vdash (\mkvs, \vi'') \csat \fp : (\mkvs', \vi')$.
%Intuitively, the judgement states that 
%\begin{enumerate*}
%    \item the fingerprint $\fp$ is allowed to commit to kv-store $\mkvs$ under view $\vi''$, 
%    and \item the newly picked view $\vi'$ is at least the minimum view on final kv-store \( \mkvs' \) 
%    for future transactions from the same client.
%\end{enumerate*}
%In \cref{sec:cm}, we give several examples of such judgements.
%Finally, having selected a suitable transaction identifier $\txid$,

The last rule, \( \rl{PProg} \), captures the execution of a program step 
given a \emph{client environment} $\thdenv \in \ThdEnv$.
%\begin{mathpar}
%    \inferrule[\rl{PProg}]{%
%	    \vi = \vienv (\cl)
%        \\
%        \stk = \thdenv(\cl)
%        \\
%        \cmd = \prog(\cl)
%        \\
%		\cl \vdash 
%		( \mkvs, \vi, \stk ) , \cmd
%		\toCMD{\lambda}_{\ET} 
%		( \mkvs', \vi', \stk' ) , \cmd'  
%    }{%
%		\vdash 
%		(\mkvs, \vienv, \thdenv ), \prog
%		\toCMD{\lambda}_{\ET} 
%		( \mkvs', \vienv\rmto{\cl}{\vi'}, \thdenv\rmto{\cl}{\stk'} ) , \prog\rmto{\cl}{\cmd'} ) 
%    }%
%\end{mathpar}
A client environment $\thdenv$ is a function from client identifiers to variable stacks, associating each client with its stack. 
We assume that the domain of client environments contains 
the domain of the program throughout the execution: 
$\dom(\prog) \subseteq \dom(\thdenv)$.
Program transitions are simply defined in terms of the transitions of
their constituent client commands. 
This yields an interleaving semantics for transactions of different clients:  
a client executes a transaction in an atomic step without
interference from the  other clients. 
