\section{Operational Model}
\label{sec:model}

\pg{Remember: section 3 is all about technical definitions; section 2
 is  about intuition. This saves space and clarifies the purpose of
 each section.}

We give the technical definitions of our operational model: 
the global, centralised key-value stores; the partial client views;  and the
operational semantics. 

\mypar{Notation}
Given a set $\sort A$, we write $\sort A \ni a$ to denote that elements of $\sort A$ are ranged over by $a$ and its variants (\eg $a', a_1, \cdots$). 
Given a relation $\mathsf r \subseteq \sort A \times \sort A$,
we write $\mathsf r^?$, $\mathsf r^+$ and $\mathsf r^*$ for its reflexive, transitive and reflexive-transitive closures, respectively;
and write $a_1 \xrightarrow{\mathsf r} a_2$ for $(a_1, a_2) \in \mathsf r$.
\subsection{Key-value Stores}
\label{subsec:kvstores}
\label{sec:mkvs-view}
Key-value stores are defined using client and transaction identifiers.
We assume a countably infinite set of \emph{client identifiers} $\Clients \ni \cl$. 
%$\Clients \defeq \Set{\cl, \cl',\cdots}$.
The set of \emph{transaction identifiers} is  
$\TxID \defeq  \Set{\txid_{0}} \uplus \Set{ \txid_{\cl}^{n} \mid \cl
  \in \Clients \wedge n \geq 0 }$, 
where  $\txid_0$ denotes  an \emph{initialisation transaction}, 
%and for each $n \in \mathbb{N}$, the $\txid_{\cl}^{n}$ identifies a transaction  committed by client $\cl$.
and $\txid_{\cl}^{n}$ identifies a transaction committed by client $\cl$. 
Elements of $\TxID$ are ranged over by
$\txid, \txid', \cdots$, and subsets by $\txidset, \txidset', \cdots$. 
Let $\TxID_{0} \defeq \TxID \setminus \{ \txid_0\}$. 
For each $n \in \mathbb{N}$, the $\txid_{\cl}^{n}$ identifies the $n$\textsuperscript{th} transaction  committed by $\cl$.
That is, the $n$ records  the \emph{session order}, $\PO$, associated with
the client: 
$\PO \defeq \Set{ (\txid, \txid') \mid \exsts{ \cl, n,m } \txid =
  \txid_{\cl}^{n} \wedge \txid' = \txid_{\cl}^{m} \wedge n < m}$.
%We write $\txid \xrightarrow{\PO} \txid'$ for
%$(\txid, \txid') \in \PO$, and $\txid \xrightarrow{\PO ?} \txid'$ for
%for its reflexive closure. 


\begin{definition}[Key-value stores]
\label{def:his_heap}
\label{def:mkvs}
Assume a countably infinite set of \emph{keys} $\Keys \ni \ke$, 
%$\Keys = \Set{\ke, \ke', \cdots}$
and a countably infinite set of  \emph{values} $\Val \ni \val$, 
% $\Val = \{\val, \val', \cdots\}$, 
including an \emph{initialisation value} $\val_0 $.
The set of \emph{versions}, $\Versions \ni \ver$, is: $\Versions \defeq \Val \times \TxID \times \powerset{\TxID_{0}}$. 
A \emph{key-value store}, abbreviated to kv-store,  is a function $\hh: \Keys \rightarrow \Versions^{\ast}$, 
where $\Versions^{\ast}$ is the free monoid on $\Versions$. 
The \emph{initial key-value store} is given by $\hh_0$, where 
$\hh_{0}(\ke)\defeq  (\val_0, \txid_0, \emptyset)$ for
all $\ke \in \Keys$.



\end{definition}


A \emph{version} $\ver {=} (\val, \txid, \txidset)$ comprises  a value $\val$
and meta-data about the transactions that accessed it: the \emph{writer} $\txid$ identifies the transaction that wrote $\ver$;
and the set of \emph{readers} $\txidset$ identifies  the  transactions
that read from  $\ver$.
We define $\valueOf(\ver) \defeq \val$,
$\WTx(\ver) \defeq \txid$ and $\RTx(\ver) \defeq \txidset$. 
%Elements of $\Versions$ are ranged over by
%$\ver, \ver',  \cdots$, 
Lists of versions (elements of $\Versions^{\ast}$) are ranged over by $\vilist, \vilist',\cdots$.
Given a kv-store $\hh$ and a transaction $\txid$, we write 
$\txid \in \hh$ when $\txid$ appears as either the writer or amongst the readers of a version in the range of $\hh$.
%%%%
%%%%I don't think this technical detail is needed, it's clear
%%:  $\txid \in \hh \defeq 
%\exists \ke, i. 0 \leq i < \lvert \hh(\ke) \rvert \wedge (\txid \in
%\RTx(\hh(\ke, i)) \cup \{\WTx(\hh(\ke, i))\})$.
We write  $\lvert \hh(\ke) \rvert$ for the length of $\hh(\ke)$, 
and write $\hh(\ke, i)$ for the $i$\textsuperscript{th} version (indexed from 0) of $\ke$ when defined, with $i \geq 0$.




We focus on key-value stores whose consistency model enforces the \emph{atomic visibility} of transactions~\cite{framework-concur}. 
This ensures that 
\begin{enumerate*}
	\item a transaction reads and writes at most one version for each key.
We also assume that 
	\item the list of versions for each key has an initial version 
carrying the initialisation value $\val_0$,  written by the designated initialisation transaction $\txid_0$ 
with an initial empty set of readers.
Finally, we assume that 
	\item the state of a kv-store is consistent with 
the session order of clients: a client cannot read a version of a key that has 
been installed by a future transaction within the same session;  and 
the order in which versions are installed by a single client must agree 
with its session order. 
\end{enumerate*}
A kv-store is \emph{well-formed} if it satisfies these three conditions (defined formally in the appendix -- see \cref{def:mkvs-appendix}). 
Henceforth, we assume kv-stores are well-formed, and write  $\HisHeaps$ to denote 
the set of well-formed kv-stores.
%The formal definition of well-formedness can be found in \todo.
%\azalea{
%Give a formal definition of well-formedness in the appendix and move the below commented out bit to there. Reference it above.
%\sx{done}
%}
%We focus on key-value stores whose consistency model enforces the
%\emph{atomic visibility} of transactions~\cite{framework-concur}.
%This amounts to requiring that a transaction reads and writes at most
%one version of each key: \textbf{(i)}
%$\fora{\ke, i, j} (o \leq i, j \leq \abs{ \hh(\ke) } \land
%\RTx(\hh(\ke, i)) \cap \RTx(\hh(\ke, j)) \neq \emptyset ) \implies i =
%j$, \textbf{(ii)}
%$\fora{\ke, i, j} (0 \leq i,j < \abs{ \hh(\ke) } \wedge \WTx(\hh(\ke,
%i)) = \WTx(\hh(\ke, j)) ) \implies i = j$.  We also assume that the
%list of versions for each key has an initial version carrying a
%default value $\val_0$, written by the designated initialisation
%transaction $\txid_0$: \textbf{(iii)}
%$\fora{\ke} \hh(\ke, 0) = (\val_0, \txid_0, \stub)$.  Finally, we
%assume that the state of a key-value store is consistent with the
%session order of clients: \textbf{(iv)}
%$\fora{ \ke, \cl, i,j, n, m} 0 \leq i < j < \abs{\hh(\ke)} \land
%\txid_{\cl}^{n} = \WTx(\hh(\ke,i)) {} \wedge \txid_{\cl}^{m} \in
%\Set{\WTx(\hh(\ke,j))} \cup \RTx(\hh(\ke, i)) \implies n < m $.  We
%say that kv-stores that satisfy the conditions
%\textbf{(i)}-\textbf{(iv)} above are \emph{well-formed}.  Henceforth,
%we always assume kv-stores are  well-formed, and  write 
%$\HisHeaps$ to denote the set of well-formed kv-stores.


%\pg{Above, I've got rid of the technical details to make it more
%  readable. I've also done a technical version, commented out, which
%  should probably go in the appendix.}




\subsection{Client Views}

Clients often have partial views of kv-stores, 
with different clients observing 
different versions of the same key.
%To keep track of the versions observed by clients,
%we introduce the notion of \emph{client views} (\cref{def:view}). 

\begin{definition}[Views]
\label{def:view}
\label{def:cuts}
\label{def:views}
\label{def:configuration}
A \emph{view} of a kv-store $\hh$ is a function
$\vi \in \Views(\hh) \defeq \Keys \to\powerset{\Nat}$ such that for all $i, i', \ke, \ke'$:
\begin{align}
    & \hspace*{-8pt}
%    \fora{ \ke } 
    0 \in \vi(\ke) 
    \wedge (i \in \vi(\ke) \Rightarrow i < \abs{ \hh(\ke) }) 
    \tag{wf}
    \label{eq:view.wf}\\
    & \hspace*{-8pt}
    \begin{array}{@{}l@{}}
%    \fora{ \ke_1,\ke_2, i_1, i_2} 
	i \in \vi(\ke)  
  	\land \WTx(\hh(\ke, i)) {=} \WTx(\hh(\ke', i'))  
  	\Rightarrow i' \in \vi(\ke')
    \end{array}
	\tag{atomic}
	\label{eq:view.atomic}
\end{align}
The \emph{initial view} is denoted by $\vi_{0}$, where $\vi_{0}(\ke) = \{0\}$ for all $\ke \in \Keys$. 
A \emph{configuration}, $\conf \in \Confs$,  is a pair $ (\hh, \viewFun)$
with $\hh \in \HisHeaps$ and
$\viewFun : \Clients \parfinfun \Views(\hh)$. 
The set of \emph{initial configurations}, $\Confs_0 \subseteq \Confs$, contains configurations of the form $ (\hh_0, \viewFun)$, where $\hh_0$ is the initial kv-store. 
%A configuration is an 
%\emph{initial} configuration when $\hh$ is the initial kv-store
%$\hh_{0}$. 
\end{definition}
%


Given a configuration $(\hh, \viewFun)$, when the view of client 
$\cl$ is defined, \ie there exists $\vi = \viewFun(\cl)$, then for each key $\ke \in \Keys$, 
$\vi$ determines the sublist of versions in $\hh$ that client $\cl$ can observe. 
If $i,j \in \vi(\ke)$ and $i < j$, then $\cl$ knows about the values and 
transaction meta-data associated with versions $\hh(\ke, i)$ and  $\hh(\ke, j)$, 
and  knows that these versions are contained in $\hh$ with  $\hh(\ke, j)$ more 
up-to-date than $\hh(\ke, i)$. 
Let $\Views \eqdef \bigcup_{\hh \in \HisHeaps} \Views(\hh)$ be the set of all views. 
Given a kv-store $\hh$ and two views $\vi, \vi' \in \Views(\hh)$, 
we define: $\vi \viewleq \vi' \iffdef \for{\ke \in \dom(\hh)} \vi(k) \subseteq \vi'(\ke)$.

Given a configuration $(\hh, \viewFun)$ and a client $\cl$ such that $\viewFun(\cl)$ is
defined, it is possible to define a \emph{snapshot} of the
view $\viewFun  (\cl)$, which identifies the last write of a client
view. This definition assumes that the database satisfies the \emph{last write wins}
resolution policy~\cite{}. It  is straightforward to generalise our work
to other resolution policies~\cite{.}.

%\azalea{$\ss$ has negative (Nazi) connotations. I would rename it if possible.}
\begin{definition}[Snapshots]
\label{def:heaps}
\label{def:snapshot}
A \emph{snapshot}, \( \ss \in \Snapshots  \defeq \Keys \to
\Val\),  is a function  from keys to values.
Given $\hh \in \HisHeaps$ and $\vi \in \Views(\hh)$, the \emph{snapshot} of $\vi$ in 
$\hh$ is defined by  $\snapshot(\hh, \vi) \defeq \lambda \ke \ldotp \valueOf(\hh(\ke, \max_{<}(\vi(\ke)))$, 
where $\max_{<}(\vi(\ke))$ is the maximum element in $\vi(\ke)$ with respect to the natural 
order $<$ over $\mathbb{N}$.
\end{definition}
Given a kv-store $\hh$, a key $\ke$ and a view $\vi$, 
%we abuse
%notation, writing 
we write 
$\hh(\ke, \vi)$ as a shorthand for 
$\hh(\ke, \max_{<}(\vi(\ke))$. Thus, $\snapshot(\hh, \vi) = \lambda \ke \ldotp \valueOf(\hh(\ke, \vi))$. 

\begin{remark}
The client view describes the partial history of the database observed by the client. 
The client snapshot describes the most up-to-date state of the database known to the client (based on its view). 
It is not possible to work with the snapshot alone. 
The client view is essential to express several standard consistency models (see~\cref{subsec:cm_examples}). 
\end{remark}


\subsection{Operational Semantics}

\mypar{Programming Language}
A \emph{program} \( \prog \) comprises a finite number of clients,
where each client is associated with a unique identifier \( \thid \in \ThreadID \), 
and executes a sequential \emph{command} $\cmd$, given by the following grammar:
\begin{align*}
\cmd & ::=  
\pskip \mid 
\cmdpri \mid  
\ptrans{\trans} \mid 
\cmd \pseq \cmd \mid 
\cmd \pchoice \cmd \mid 
\cmd \prepeat  
\\
\cmdpri & ::=  
\pass{\txvar}{\expr} \mid 
\passume{\expr} 
\\
\trans & ::=
\pskip \mid
\transpri \mid 
\trans \pseq \trans \mid
\trans \pchoice \trans \mid
\trans\prepeat    
\\
\transpri & ::= 
\cmdpri \mid
\pderef{\txvar}{\expr} \mid
\pmutate{\expr}{\expr} 
\end{align*} 
%
%
\pg{Why are you using $a$ for variable. Later you use $x$. Just be
  consistent. I'm happy with $x$.
  \azalea{Sorted.}
}
%
Sequential commands  comprise $\pskip$,  primitive commands $\cmdpri
$, atomic transactions
$\ptrans{\trans}$,  and standard
compound commands. 
Primitive commands (the variable assignment
$\pass{\txvar}{\expr}$ and the assume statement $\passume{\expr}$
used to encode conditionals) are used for computations based on 
client-local variables 
and can hence be invoked without restriction. 
Transactional commands, $\trans$, 
comprise $\pskip$, primitive commands, 
primitive transactional commands $\transpri$,  and standard compound commands. 
Primitive transactional commands include lookup ($\pderef{\txvar}{\expr}$) and mutation 
($\pmutate{\expr}{\expr}$) used for reading and writing to kv-stores, respectively, and  
can be invoked only as part of an atomic transaction $\ptrans{\trans}$.

A {\em program} is a finite partial function from client identifiers to sequential
commands.
%%%%I don't think this is needed. 
%$\prog = \Set{\thid_{1} \mapsto \cmd_{1}, \dots, \thid_{n} \mapsto \cmd_{n} $.
For clarity, we often write \( \cmd_{1}\ppar \dots \ppar \cmd_{n}\) as syntactic sugar 
for a program \( \prog \) with $n$ clients associated with identifiers
$\thid_1 \dots \thid_n$, where each client $\thid_i$ executes
$\cmd_i$. 
Each client $\cl_i$ is associated with its own client-local  \emph{stack}, 
$\stk_i \in \Stacks \defeq \Vars \to \Val$,  mapping program variables
(ranged over by $\pvar{x}, \pvar{y}, \cdots$)
to values. 
We assume a language of expressions built from values
and program variables:
$\expr ::= \val \mid \var \mid \expr + \expr \mid \cdots$.
The \emph{evaluation} $\evalE{\expr}$ of  expression $\expr$ is parametric in
the client-local stack, where:
\begin{gather*}
\evalE{\val} \defeq
\val
\quad
\evalE{\var} \defeq
\stk(\var)
\quad
\evalE{\expr_{1} + \expr_{2}} \defeq
\evalE{\expr_{1}} + \evalE{\expr_{2}}
\quad
\dots
\end{gather*}
\pg{In above, you could define stack  $s_i$ for client $cl_i$.
\azalea{Done.}}

\mypar{Transactional Semantics}  
In our framework, transactions are executed \emph{atomically}. 
Intuitively, given a configuration $\conf = (\hh, \viewFun)$, 
when a client $\cl$ executes a transaction $\ptrans{\trans}$, 
it performs the following steps: 
\begin{enumerate*}
	\item it constructs a snapshot $\ss$ of $\hh$ using its view $\viewFun(\cl)$ as defined in \cref{def:snapshot};  
	\item it executes $\trans$ in isolation over the snapshot $\ss$, accumulating the observable 
effects of executing $\trans$; and
	\item it commits $\trans$ by incorporating these effects into 
the kv-store $\hh$.
%snapshot constructed in the previous step as the initial, local state
%of the client, and it determines the observable 
%effects that such an execution has on the key-value store; and  it incorporates 
%the effects of executing the code $\trans$ in the initial state determined by the snapshot into 
%the key-value store.
\end{enumerate*}


To capture the observable effects of executing a transaction $\trans$ on a snapshot $\ss$ of kv-store $\hh$, 
we identify the \emph{fingerprint} of $\trans$ on $\ss$ and $\hh$.
A fingerprint of $\trans$ on $\ss$ and $\hh$
is a set of \emph{read and write operations}, where
the read operations capture the values $\trans$ reads from $\ss$ (prior to overwriting them), and
the write operations capture the values $\trans$ writes to $\ss$ and aims to commit them to $\hh$, so long as certain consistency conditions are met.  
%that describes the reads of a snapshot of the kv-store taken at the beginning of 
%the invocation of the transaction, and the writes to be
%commited to the kv-store  as long as certain
%consistency conditions are met. 
A transaction may have more than one fingerprint due to non-determinism. 




\pg{Above  might need to dovetail with what we say in section 2. 
Maybe give an example that relates to
section 2 that shows intuitively how fingerprint works, maybnot not
and instead just refer to section 2
\azalea{We will revisit this when ยง2 is done.}}



\begin{definition}[Fingerprints]
\label{beebop}
The set of \emph{operations} is 
%The set of \emph{operations} is
$\Ops \defeq \{(l, \ke, \val) \mid$ $ l \in \Set{\otW, \otR} \land \ke \in \Keys \wedge \val \in \Val \}$.
A \emph{fingerprint} $\opset$ is a subset of operations, $\opset \subseteq \Ops$,
such that: 
$\for{\ke \in \Keys, l  \in \Set{\otW, \otR}}
	(l, \ke, \val_1), (l, \ke, \val_2) \in \opset \Rightarrow \val_1 = \val_2$.
\end{definition}
Note that the last constraint ensure that for each key, a fingerprint contains at most one read operation and at most one write operation.
This reflects the fact that we work with transactions that are
atomically visible~\cite{laws}; 
that is, reads are taken from a single snapshot of the kv-store, 
and since clients observe either none or all effects of a transaction, only the last write to each key is 
committed.

We provide an operational description of the behaviour of a transactional command, $\trans$,
starting from an initial client stack
%$\stk \eqdef \lambda \var. 0$, 
a snapshot 
%$\ss$  
and the empty fingerprint $\emptyset$. 
%Intuitively,  a fingerprint of a transaction  records, for each key $\ke$,
%the first value a transaction reads (before a subsequent write) for $\ke$, 
%and the last value the transaction writes for $\ke$.
First, we define a transition system describing how client stack and snapshot are updated via
primitive transactional commands.


\begin{definition}
\label{def:primitive_semantics}
The transition system, $\toLTS{\transpri}\; \subseteq (\Stacks \times \Heaps) \times (\Stacks \times \Heaps)$, 
is defined by:
\[
\begin{rclarray}
(\stk, \h)  & \toLTS{\passign{\var}{\expr}}          & (\stk\rmto{\var}{\evalE{\expr}}, \h)                  \\
(\stk, \h)  & \toLTS{\passume{\expr}}                & (\stk, \h) \text{ where } \evalE{\expr} \neq 0        \\
(\stk, \h)  
& \toLTS{ \pderef{\var}{\expr} } 
& (\stk\rmto{\var}{\h(\evalE{\expr})}, \h) 
\\
(\stk, \h)
& \toLTS{\pmutate{\expr_{1}}{\expr_{2}}  }
& (\stk, \h\rmto{\evalE{\expr_{1}}}{\evalE{\expr_{2}}}) \\
\end{rclarray}                                                                                               
\]
\end{definition}
%Second, we define the basic actions of the primitive commands and
%primitive transactional commands using  function
% I don't like this name fingerprint function, it's not, the action
% might not be in the fingerprint. we only begin to get the
% fingerprint intruition with the composition operator. 
%we define a \emph{fingerprint function}, 
%$\func{fp}{\stub} \; : \Stacks \times \Heaps \times \transpri \rightarrow \Ops \cup \{\varepsilon\}$:
%

%Note that  the primitive commands are associated with the empty operation $\varepsilon$,
%as they only access the local stack and do not access the kv-store.

\noindent Second, we define a \emph{fingerprint function}, $\mathsf{op}$, computing the fingerprint of primitive transactional commands:
% to the basic read and write operations given in Definition~\ref{beebop}: 
\[
\begin{array}{rcl @{\quad} rcl}
\func{op}{\stk, \h, \passign{\var}{\expr}}          & \defeq & \emptyop                                     \\
\func{op}{\stk, \h, \passume{\expr}}                & \defeq & \emptyop                                     \\
\func{op}{\stk, \h,  \pderef{\var}{\expr}}           & \defeq & (\etR, \evalE{\expr}, \h(\evalE{\expr}))    \\
\func{op}{\stk,  \h, \pmutate{\expr_{1}}{\expr_{2}}} & \defeq & (\etW, \evalE{\expr_{1}}, \evalE{\expr_{2}})\\
\end{array}
\]
The  empty operation $\emptyop$ is used for those primitive commands that do not
contribute to the fingerprint.

Third, we define a \emph{combination} operator,
$\addO  : \pset{\Ops} \times \Ops \uplus \{\emptyop\} \rightarrow \pset{\Ops}$, 
adding a read/write operation to a fingerprint, and ignoring the empty operation $\emptyop$: 
%For instance, when executing $ \ptrans{\trans}$ with $\trans \eqdef \transpri^1; \cdots ; \transpri^n$,
%the effect of each $\transpri^i$ is calculated via the $\op_i = \func{fp}{-, -, \transpri^i}$ function, 
%with the overall fingerprint given as the $\addO$-composition of the constituent effects: $\op_1 \addO \cdots \addO \op_n$. 
\begin{align*}
    \opset \addO (\etR, \addr, \val)  
    & \defeq
    \begin{cases}
        \opset \cup \{(\etR, \addr, \val)\} & \text{if } \for{l, v'} (l, \addr, v') \notin \opset \\
        \opset &  \text{otherwise} \\
    \end{cases}  \\
    \opset \addO (\etW, \addr, \val) 
    & \defeq 
    \left( \opset \setminus \setcomp{(\etW, \addr, v')}{v' \in \Val} \right) 
    \cup \Set{(\etW, \addr, \val)}  \\
    \opset \addO \emptyop  & \defeq  \opset  \\
\end{align*}
Note that a read from $\ke$ is added to a fingerprint $\opset$ only if $\opset$ does not contain an entry for $\ke$, thus only recording the first value read for $\ke$ (before a subsequent write). 
Analogously, a write to $\ke$ is always added to $\opset$ by removing the existing writes, thus only recording the last write to $\ke$. 

%, the composition operator \( \addO \) records
%the first value a transaction reads (before a subsequent write) for $\ke$, 
%and the last value the transaction writes for $\ke$.
%This is in line with our assumption that transactions read from an atomic snapshot of the kv-store.
%In particular, for each key $\ke$, 
%only the first read from $\ke$ fetches its value from the kv-store,
%and since clients observe either none or all effects of a transaction, 
%only the last write to $\ke$ is committed.

%A read gets added to the read-write set if there is no read or
%write there already, thus only  recording the reads of the
%original snapshot of the kv-store at invocation. 
%A write always updates the read-write set, corresponding to a
%transaction only committing the final writes. 


%
\begin{figure*}[!t]
%\hrule
\begin{mathpar}
    \infer[\rl{TPrimitive}]{%
        (\stk, \h, \opset) , \transpri \ \toL \  (\stk', \h', \opset \addO \op) , \pskip 
    }{%
		(\stk, \h) \toLTS{\transpri} (\stk', \h')
        \\ \op = \func{op}{\stk, \h, \transpri}
    }
    %
    \\
    \infer[\rl{TSeqSkip}]{%
        (\stk, \h, \opset), \pskip \pseq \trans \ \toL \  (\stk, \h, \opset), \trans
    }{}
    \and
    \infer[\rl{TIter}]{%
        (\stk, \h, \opset),  \trans\prepeat \ \toL \  (\stk, \h, \opset), \pskip \pchoice (\trans \pseq \trans\prepeat)
    }{} 
    \and
     \infer[\rl{TChoice}]{
		(\stk, \h, \opset) , \trans_{1} \pchoice \trans_{2} \ \toL \  (\stk, \h, \opset) , \trans_{i}
    }{%
		i \in \Set{1,2}
    }
    \and
    \infer[\rl{TSeq}]{%
		(\stk, \h, \opset), \trans_{1} \pseq \trans_{2} \ \toL \  (\stk', \h', \opset'), \trans_{1}' \pseq \trans_{2}
    }{%
		(\stk, \h, \opset), \trans_{1} \ \toL \  (\stk', \h', \opset'), \trans_{1}'
    }
\end{mathpar}
\hrule\vspace{5pt}
\caption{Transactional semantics rules}
\label{fig:semantics-trans}
\end{figure*}

Finally, we have all the ingredients to describe the behaviour of a transactional command.  \Cref{fig:semantics-trans} provides the one-step transactional semantics; 
the interesting rule is the \rl{TPrimitive} rule which describes how a primitive transactional command updates the client stack, the snapshot and the fingerprint; 
the remaining rules are standard.



\begin{definition}[Fingerprint Set]
Given a client stack $\stk$ and a snapshot $\ss$, the \emph{fingerprint set} of a transaction $\trans$ is:
\[F \defeq
\{\opset : (\stk, \h, \emptyset), \trans \toL^* (\stk', \h', \opset),
\pskip \}
\]
where $\toL^*$ is the transitive closure of $\toL$ given in~\cref{fig:semantics-trans}.  
A set $\opset$ in $F$ is called a \emph{final fingerprint} of $\trans$. 
\end{definition}
\noindent It is straightforward to show that final fingerprints of $\trans$ contain at most one read (resp.\ one write) operation per key. \\

%\pg{Below, there were some minor inconsistences. Needs checking.I've
%  made lots of changes. It's a bit difficult to assess by laptop,
%  really needs a paper copy. Hope ok.}

\mypar{Operational Semantics}
We give the operational semantics of commands and programs. 
The command semantics describes transitions of the form
$\cl \vdash (\hh, \vi, \stk), \cmd \ \toT{\lambda}_{\ET} \ (\hh', \vi', \stk') ,
\cmd'$, stating that given the kv-store $\hh$, view $\vi$ and stack $\stk$, 
a client $\cl$ may execute command $\cmd$ for one step, updating 
the kv-store to $\hh'$, the stack to $\stk'$, and the command to its continuation $\cmd'$.
The label $\lambda$ is either of the form $(\cl, \iota)$ denoting that $\cl$ executed a primitive command
that required no access to $\hh$, 
or $(\cl, \vi'', \opset)$ denoting that $\cl$ committed an atomic transaction with final fingerprint $\opset$ under the view $\vi''$.
Transitions are parametric in the choice of \emph{execution test} $\ET$, defined shortly in \cref{sec:cm}.
Intuitively, an execution test captures the \emph{consistency model} under which a transaction executes.
In \cref{sec:cm} we present the execution tests associated with several well-known consistency models.  %in the literature.

\pg{
Sorry, I think it's better to revert back to the judgement $cl
  \vdash (\hh, \vi, \stk), \cmd \ \toT{\lambda}_{\ET} \ (\hh', \vi', \stk') ,
\cmd'$, please change everywhere. 
\azalea{Done.}
Why is the label needed? It's not clear.
%\sx{For technical reasons, it is needed so we know what happens for each steps in a trace.} 
\sx{The labels are for technical reason so a trace produced by the semantics can easily convert to a \(\ET\)-trace (\cref{def:reduction}) which we will introduce later.}
}



\begin{figure*}[t]
%\hrule
\[
    \infer[\rl{CPrimitive}]{
        \cl \vdash 
        ( \hh, \vi, \stk ) , \cmdpri \ 
        \toT{(\cl,\iota)}_{\como} \  
        ( \hh, \vi, \stk' ) , \pskip
    }{
		(\stk, \h)  \toLTS{\cmdpri} (\stk', \h)
		& \h = \clpsHH{\hh,\vi}    
    }
\]
\[
    \infer[\rl{CAtomicTrans}]{%
        \cl \vdash 
        ( \hh, \vi, \stk ), \ptrans{\trans} \ 
        \toT{(\cl, \vi'', \opset)}_{\ET} \ 
        (\mkvs',\vi', \stk' ) , \pskip
    }{%
		\begin{array}{@{} c @{}}
			\vi \orderVI  \vi''
			\quad \h = \clpsHH{\hh,\vi''}
			\quad \txid \in \nextTxId(\cl, \hh) \\
			(\stk, \h, \emptyset), \trans \toL^{*}   (\stk', \stub,  \opset) , \pskip
            \quad \mkvs' = \updateKV(\hh, \vi'', \opset, \txid) 
            \quad \ET \vdash (\mkvs, \vi'') \csat \f : (\mkvs',\vi')
			%\qquad \ET \vdash (\hh, \vi'') \triangleright \opset : \vi'
		\end{array}
    }
\]
%\hrulefill
\[
    \infer[\rl{PProg}]{%
		\cl \vdash 
		(\mkvs, \viewFun, \thdenv ), \prog  \ 
		\toT{\lambda}_{\ET} \  
		( \mkvs', \viewFun, \thdenv\rmto{\thid}{\stk'} ) , \prog\rmto{\thid}{\cmd'} ) 
    }{%
		\vdash 
		( \mkvs, \vi, \thdenv(\thid) ) , \prog(\thid) \
		\toT{\lambda}_{\ET} \  
		( \mkvs', \vi', \stk' ) , \cmd'  
		\qquad 
		\viewFun (\thid) = \vi
    }
\]
\hrule\vspace{5pt}
\caption{Semantic rules for primitive  commands, atomic transactions and programs}
\label{fig:semantics}
\end{figure*}



\Cref{fig:semantics} contains the rules for primitive commands and atomic transactions.  
The rules for the compound commands are straightforward and are given in the appendix.
The rule for primitive commands, $\rl{CPrimitive}$, lifts the transition system 
$\toLTS{\transpri}$ (\cref{def:primitive_semantics}) to those primitive commands that only affect the client stack. 
The rule for atomic transactions, \rl{CAtomicTrans}, describes the execution of an atomic 
transaction under execution test $\ET$.  
The first premise
states that the current view $\vi$ of the executing command maybe advanced to a newer atomic view $\vi''$ (see \cref{def:views}). 
The semantics only allows to advance the view to later versions, which corresponds to \emph{monotonic read} \cite{.......}.
\sx{This is not true.
The reason for allowing to advance the view:
1) the old view \( \vi \) may cause the transaction having no final fingerprint \( \f \) that is allowed to commit;
2) we choose here to always advance the view before transactions.
It is from the intuition that a replica in distributed database receives a message from other replica.
Yet when a transaction commits, the view after can roll back to a older one than \( \vi \) or \( \vi'' \).
Here is where the monotonic read spec. comes, to only allow to advance a newer view after commit.
Technically, monotonic read is because view can only advance before transactions and after transactions.
}
Given the new view $\vi''$, the transaction obtains a snapshot $\ss$ of the kv-store $\hh$, 
and executes $\trans$ locally to completion ($\pskip$), updating the stack to $\stack'$, while accumulating the fingerprint $\opset$. 
Note that the resulting snapshot is ignored (denoted by $\stub$) as the effect of the transaction is recorded in the fingerprint $\opset$. 
%

The transaction is now ready to commit. The rule picks a fresh transaction identifier $\txid \in \nextTxId(\cl, \hh)$, 
and updates the kv-store via $\mkvs' = \updKV{\hh, \vi, \opset, \txid}$
if the commit is permitted by $\ET$ using the judgement $\ET \vdash (\hh, \vi'') \csat \opset : (\mkvs', \vi')$.
The set $\nextTxId(\cl, \hh)$ provides the transactions identifiers
associated with $\cl$ that are fresh for  $\hh$:
$
\nextTxId(\cl, \hh) \defeq \Setcon{\txid_{\cl}^{n}}{\fora{m}
  \txid_{\cl}^{m} \in \hh \Rightarrow m < n }
$.
By construction, all elements of $\nextTxId(\cl, \hh)$ are greater (with respect to session order $\PO$) 
than transaction identifiers previously used by $\cl$. 
The judgement $\ET \vdash (\hh, \vi'') \csat \opset : (\mkvs', \vi')$
states that the fingerprint $\opset$ is compatible with kv-store $\hh$
and view $\vi''$, and the resulting view $\vi'$ 
is compatible with view \( \vi'' \) and final kv-store \( \mkvs' \).
In \cref{sec:cm}, we give several examples of such judgements.
%Finally, having selected a suitable transaction identifier $\txid$,
%the $\updKV{\hh, \vi, \opset, \txid}$, defined below, describes how the final fingerprint $\opset$ of $\txid$ executed 
%%by $\cl$ 
%under view $\vi$ updates $\hh$. 
%
%
\pg{There is a disconnect. $\ET \vdash (\hh, \vi'') \triangleright
  \opset : \vi'$ says $\vi'$ makes sense with respect to $\hh, \vi'',
  \opset$. Nothing says that $\vi'$ makes sense with $\updateKV(\hh,
  \vi, \txid, \opset)$. I always find myself concerned about $\ET \vdash (\hh, \vi'') \triangleright
  \opset : \vi'$ because $\vi'$ is a view of an updated store which is
not part of the $\ET$ relation. I would add it.
\azalea{Not sure I understand this. Andrea? Shale?}
\sx{Ah, we should include $\updateKV(\hh, \vi, \txid, \opset)$ in the judgement, 
there is a problem in \( \RYW \) I should have notice long time ago. 
We could do something like \(\ET \vdash (\mkvs, \vi) \csat \f : (\mkvs',\vi') \),
Assuming the updated kv-store is \( \mkvs' \), then we have
1) \( \vi \) makes sense with respect to \( \mkvs \) and \( \f \), and
2) \( \vi' \) makes sense with respect to \( \vi \) and \( \mkvs' \).
\sx{sorted}
}
}
%
%
Finally, having selected a suitable transaction identifier $\txid$,
the $\updKV{\hh, \vi, \opset, \txid}$, defined below, describes how the final fingerprint $\opset$ of $\txid$ executed 
%by $\cl$ 
under view $\vi$ updates $\hh$. 
The $\updKV{\hh, \vi, \opset, \txid}$ updates $\hh$ with $\opset$ as follows: 
for each read operation $(\otR, \ke, \_) \in \opset$, it adds $t$ 
to the reader set of the last version of $\ke$ that is included in the view $\vi$ of the client; 
for each write operation $(\otW, \ke, \val)$, it appends a new version $(\val, t, \emptyset)$ 
to $\hh(\ke)$, where $\lcat$ denotes list concatenation.
When $\vilist = \ver_0 \cdots \ver_n$ and $i=0 \cdots n$, 
then $\vilist\rmto{i}{\ver}$ denotes 
$\vilist' = \ver_0 \cdots \ver_{i-1}, \ver, \ver_{i+1} \cdots \ver_{n}$. 

\begin{definition}[Transactional update]
\label{eq:updatekv}
\label{def:updatekv}
%Let $\hh \in \HisHeaps, \vi \in \Views(\hh)$, $t \in
%\TxID_{0}$ and 
%$\opset \subseteq \powerset{\Ops} $.  
The \emph{transactional update function},  $\updateKV(\hh, \vi, \opset, \txid)$,  is
defined as follows:
\[
\begin{array}{@{} l @{}}
	\begin{array}{@{} r @{} l @{}}
		\updateKV(\hh, \vi, \emptyset, \txid) \!\defeq\,  & \hh \vspace{5pt}\\
	    \updateKV(\hh, \vi, \{(\otR, \ke, \val)\} \!\uplus\! \opset, \txid) 
	    \!\eqdef\, & 
	    \updateKV(\hh\rmto{\ke}{\vilist},\vi, \opset, \txid)
	\end{array}\\
%	
	\quad\text{where} 
	\qqquad 
	i {=} \max_{<}(\vi(\ke)) \qquad (\val, \txid', \txidset) = \hh(\ke, i) \\
	\quad\phantom{where} 
	\qqquad 
	\vilist = \hh(\ke)\rmto{i}{(\val, \txid', \txidset \uplus \{ t \})} \vspace{5pt}\\
%	
	\updateKV(\hh, \vi, \{(\otW, \ke, \val)\} \!\uplus\! \opset, \txid) 
    	\eqdef
    \updateKV(\hh', \vi, \opset, \txid) \\
%
 	\quad\text{where} 
	\qqquad 
	\hh' = \hh\rmto{\ke}{ ( \hh(\ke) \lcat (\val, \txid, \emptyset) ) }   
\end{array}
\]
%
Given a client $\cl$, a kv-store $\hh$, a view $\vi$ and a fingerprint $\opset$, 
the \emph{transactional update set} $\updateKV(\hh, \vi, \opset, \cl)$ is defined as:  
$\Setcon{\updateKV(\hh, \vi, \opset, \txid)}{\txid \in \nextTxId(\hh, \cl)}$.
\end{definition}

\pg{In above, can the layout be better? I would like to put the transaction identifier $t$ at the
  end of the arguments, since this is what's happening in the
  premises. I also don't like $\cl$ where it is.
 \azalea{Done.} 
  }




Note that,  under the assumption that $\opset$ contains at most one read and one write 
operation per key and the identifier is fresh for $\hh$, 
the transaction update function and the transaction update set for
$\cl$ are well-defined. 


%\pg{This is out of place here. It could go after ET-traces.Two read-write sets $\opset_1, \opset_2$ are \emph{conflict-free} if 
%$\forall \ke \in \Keys.\; (\otW,\ke, \_) \in \opset_1 \implies \forall
%\val \in \Val.\; (\otW, \ke, \val) \notin \opset_2$, and vice versa.
%The commitment of two  conflict-free read-write sets 
%$\opset_1, \opset_2$ into a key-value store $\hh$ does not depend on the order in which the commits 
%are performed. 
%%\azalea{Will move this when next editing ยง5.}
%\azalea{Where do we actually use this notion of conflict freedom? Do we need it?}
%\sx{in composition of ET trace}
%}

The last rule of \cref{fig:semantics} captures the execution of a program step, 
given a \emph{client environment} $\thdenv \in \ThdEnv$. 
A client environment $\thdenv$ is a function from client identifiers to stacks, associating each client with its stack. 
We assume that the domain of client environments is the same as the
the domain of the program throughout the execution: 
$\dom(\thdenv) = \dom(\prog)$.
Program transitions are simply defined in terms of the transitions of
their constituent client commands. 
This  yields a  standard interleaving semantics for concurrent
programs; 
that is, 
a client performs a reduction in an atomic step without
affecting other clients. 
\pg{ I
  don't like the notation $Env $, nothing else looks like this and
it's not as important as the notation suggests.
\azalea{Changed to $\thdenv$. Better? 
\sx{Let do this} }
}
