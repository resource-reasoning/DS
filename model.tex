\section{Operational Model}
\label{sec:model}

We give the technical definitions of our operational model: 
the global, centralised key-value stores; the partial client views;  and the
operational semantics. 

\mypar{Notation}
Given a set $\sort A$, we write $\sort A \ni a$ to denote that elements of $\sort A$ are ranged over by $a$ and its variants (\eg $a', a_1, \cdots$). 
Given a relation $\mathsf r, \mathsf r_1, \mathsf r_2 \subseteq \sort A \times \sort A$,
we write $\mathsf r\rflx$, $\mathsf r^+$ and $\mathsf r^*$ for its reflexive, transitive and reflexive-transitive closures, respectively;
write $a_1 \toEDGE{\mathsf r} a_2$ for $(a_1, a_2) \in \mathsf r$;
and write \( \mathsf r_1 ; \mathsf r_2\) for \( \Set{(a_1,a_2)}[\exsts{a} (a_1,a) \in \mathsf r_1 \land (a,a_2) \in \mathsf r_2]\).

\subsection{Key-Value Stores and Views}
\label{subsec:kvstores}
\label{sec:mkvs-view}
Kv-stores are defined using client and transaction identifiers.
We assume a countably infinite set of \emph{client identifiers} $\Clients \ni \cl$. 
The set of \emph{transaction identifiers} is defined by
$\TxID \defeq  \Set{\txid_{0}} \uplus \Set{ \txid_{\cl}^{n} \mid \cl
  \in \Clients \land n \geq 0 }$, 
where  $\txid_0$ denotes  an \emph{initialisation transaction}, 
and $\txid_{\cl}^{n}$ identifies a transaction committed by client $\cl$. 
Elements of $\TxID$ are ranged over by
$\txid, \txid', \cdots$, and subsets by $\txidset, \txidset', \cdots$. 
Let $\TxID_{0} \defeq \TxID \setminus \Set{\txid_0}$. 
For each $n \in \mathbb{N}$, $\txid_{\cl}^{n}$ identifies the $n$\textsuperscript{th} transaction  committed by $\cl$.
We assume each client is associated with a session, 
and the order of transactions within a single session is determined by the superscript 
$n$ in transaction identifiers of the form $\txid_{\cl}^{n}$: we define the session order 
as 
$\SO \defeq \Set{ (\txid, \txid') \mid \exsts{ \cl, n,m } \txid =
\txid_{\cl}^{n} \land \txid' = \txid_{\cl}^{m} \land n < m}$.

\begin{definition}[Kv-stores]
\label{def:his_heap}
\label{def:mkvs}
Assume a countably infinite set of \emph{keys} $\Keys \ni \key$, 
and a countably infinite set of  \emph{values} $\Val \ni \val$, 
which includes keys \( \Keys \) and an \emph{initialisation value} $\val_0$.
The set of \emph{versions}, $\Versions \ni \ver$, is defined by $\Versions \defeq \Val \times \TxID \times \pset{\TxID_{0}}$. 
A \emph{kv-store} 
is a function $\mkvs: \Keys \to \Versions^{\ast}$, 
where $\Versions^{\ast} \ni \vilist$ is the free monoid generated by $\Versions$. 
\end{definition}

A \emph{version} $\ver = (\val, \txid, \txidset)$ comprises  a value $\val$
and meta-data about the transactions that accessed it: the \emph{writer} $\txid$ identifies the transaction that wrote $\ver$;
and the set of \emph{readers} $\txidset$ identifies  the  transactions
that read from  $\ver$.
We define $\valueOf(\ver) \defeq \val$,
$\wtOf(\ver) \defeq \txid$ and $\rsOf(\ver) \defeq \txidset$. 
%Lists of versions (elements of $\Versions^{\ast}$) are ranged over by $\vilist, \vilist',\cdots$.
Given a kv-store $\mkvs$ and a transaction $\txid$, we write 
$\txid \in \mkvs$ when $\txid$ appears as either the writer or amongst the readers of a version in the range of $\mkvs$.
We write $\lvert \mkvs(\key) \rvert$ for the length of $\mkvs(\key)$
and $\mkvs(\key, i)$ for the $i$\textsuperscript{th} version (indexed from 0) of $\key$ when defined, with $i \geq 0$.


We focus on kv-stores whose consistency model enforces the \emph{atomic visibility} of transactions,
provided that many modern distributed systems make such assumption~\cite{ramp,rola,cops,wren,redblue,PSI,NMSI,gdur,clocksi,distrsi}.
This ensures that 
\begin{enumerate*}
	\item a transaction reads and writes at most one version for each key.
We also assume that 
	\item the list of versions for each key has an initial version 
carrying the initialisation value $\val_0$,  written by the 
%designated 
initialisation transaction $\txid_0$ 
with an initial empty set of readers.
Finally, we assume that 
	\item the state of a kv-store is consistent with 
the session order of clients: a client cannot read a version of a key that has 
been written by a future transaction within the same session;  and 
the order in which versions are written by a client must agree 
with its session order. 
\end{enumerate*}
A kv-store is \emph{well-formed} if it satisfies these three conditions (defined formally in \cref{def:mkvs-appendix}). 
Henceforth, we assume kv-stores are well-formed, and write  $\MKVSs$ to denote 
the set of well-formed kv-stores.

Clients often have partial views of kv-stores, 
with different clients seeing 
different versions of the same key.
We define \emph{views} to track the versions seen by clients. 

\begin{definition}[Views and Configurations]
\label{def:view}
\label{def:cuts}
\label{def:views}
\label{def:configuration}
A \emph{view} of a kv-store $\mkvs$ is a function
$\vi \in \Views(\mkvs) \defeq \Keys \to\pset{\Nat}$ such that for all $i, i', \key, \key'$:
%
{
\begin{align}
    & 
    0 \in \vi(\key) 
    \land (i \in \vi(\key) \implies i < \abs{ \mkvs(\key) }) 
    \tag{wf}
    \label{eq:view.wf}\\
    & 
    \begin{array}{@{}l@{}}
	i \in \vi(\key)  
  	\land \wtOf(\mkvs(\key, i)) {=} \wtOf(\mkvs(\key', i'))  
  	\implies i' \in \vi(\key')
    \end{array}
	\tag{atomic}
	\label{eq:view.atomic}
\end{align}
}
Given two views $\vi, \vi' \in \Views(\mkvs)$, 
The order between them is defined by $\vi \viewleq \vi' \defiff \fora{\key \in \dom(\mkvs)} \vi(k) \subseteq \vi'(\key)$.
The set of views is defined by $\Views \defeq \bigcup_{\mkvs \in \MKVSs} \Views(\mkvs)$.
%
\noindent The \emph{initial view} is denoted by $\vi_{0}$, where $\vi_{0}(\key) = \Set{0}$ for all $\key \in \Keys$. 
A \emph{configuration}, $\conf \in \Confs$,  is a pair $ (\mkvs, \vienv)$
with $\mkvs \in \MKVSs$ and a partial finite function
$\vienv : \Clients \parfinfun \Views(\mkvs)$. 
The set of \emph{initial configurations}, $\Confs_0 \subseteq \Confs$, contains configurations of the form $ (\mkvs_0, \vienv_0)$, where $\mkvs_0$ is the initial kv-store
that is defined by
$\mkvs_{0}(\key)\defeq  (\val_0, \txid_0, \emptyset)$ for
all $\key \in \Keys$ and an initial value \( \val_0 \).
\end{definition}
%
\sx{split the configuration definition ?}
%
Given a configuration $(\mkvs, \vienv)$, when the view of client 
$\cl$ is defined, that is, there exists $\vi = \vienv(\cl)$ such that for each key $\key \in \Keys$, 
$\vi$ determines the sublist of versions in $\mkvs$ that client $\cl$ sees. 
If $i,j \in \vi(\key)$ and $i < j$, then $\cl$ knows about the values 
carried by versions $\mkvs(\key, i)$ and  $\mkvs(\key, j)$, 
and  knows that these versions are contained in $\mkvs$ with  $\mkvs(\key, j)$ more 
up-to-date than $\mkvs(\key, i)$. 

Given a configuration $(\mkvs, \vienv)$ and a client $\cl$ such that $\vienv(\cl)$ is
defined, it is possible to define a \emph{snapshot} of the
view $\vienv  (\cl)$, which identifies the last write of a client
view. This definition assumes that the database satisfies the \emph{last write wins}
resolution policy as many distributed databases adopt this policy~\cite{ramp,rola,cops,wren,redblue,PSI,NMSI,gdur,clocksi,distrsi}, although our theory can be 
re-adapted to capture other resolution policies. 

\sx{Transaction state.}
\begin{definition}[Snapshots]
\label{def:snapshot}
Given $\mkvs \in \MKVSs$ and $\vi \in \Views(\mkvs)$, the \emph{snapshot} of $\vi$ in 
$\mkvs$ is defined by  $\snapshot[\mkvs, \vi] \defeq \lambda \key \ldotp \valueOf(\mkvs(\key, \max_{<}(\vi(\key)))$, 
where $\max_{<}(\vi(\key))$ is the maximum element in $\vi(\key)$ with respect to the natural 
order $<$ over $\mathbb{N}$.
\end{definition}

%\begin{remark}
%The client view describes the partial history of the database seen by the client. 
%The client snapshot describes the most up-to-date state of the database known to the client (based on its view). 
%It is not possible to work with the snapshot alone. 
%The client view is essential to express several standard consistency models (see~\cref{subsec:cm_examples}). 
%\ac{This remark is extremely vague at this point.}
%\end{remark}

\subsection{Operational Semantics}

\mypar{Programming Language}
A \emph{program} \( \prog \) comprises a finite number of clients,
where each client is associated with a unique identifier \( \cl \in \Clients \), 
and executes a sequential \emph{command} $\cmd$, given by the following grammar:%
%
{%
\begin{align*}
\cmdpri & ::=  
\passign{\var}{\expr} \!\mid\! 
\passume{\expr} 
&
\cmd & ::=  
\pskip \!\mid\!
\cmdpri \!\mid\!  
\ptrans{\trans} \!\mid\! 
\cmd \pseq \cmd \!\mid\! 
\cmd \pchoice \cmd \!\mid\! 
\cmd \prepeat  
\\
\transpri & ::= 
\cmdpri \!\mid\!
\plookup{\var}{\expr} \!\mid\!
\pmutate{\expr}{\expr} 
&
\trans & ::=
\pskip \!\mid\!
\transpri \!\mid\! 
\trans \pseq \trans \!\mid\!
\trans \pchoice \trans \!\mid\!
\trans\prepeat    
\end{align*}%
}%
%
%
Sequential commands comprise $\pskip$, primitive commands $\cmdpri
$, atomic transactions
$\ptrans{\trans}$, and the standard
compound commands:
sequential composition \( ; \), non-deterministic choice \( + \) and iteration \( * \).
Primitive commands (the variable assignment
$\passign{\var}{\expr}$ and the assume statement $\passume{\expr}$
used to encode conditionals) are used for computations based on 
client-local variables 
and can hence be invoked without restriction. 
Transactional commands, $\trans$, 
comprise $\pskip$, primitive commands, 
primitive transactional commands $\transpri$, and the standard compound commands.
Primitive transactional commands include lookup ($\plookup{\var}{\expr}$) and mutation 
($\pmutate{\expr}{\expr}$) used for reading and writing to kv-stores respectively, which
can only be invoked as part of an atomic transaction $\ptrans{\trans}$.

A {\em program} is a finite partial function from client identifiers to sequential
commands.
For clarity, we often write \( \cmd_{1}\ppar \dots \ppar \cmd_{n}\) as syntactic sugar 
for a program \( \prog \) with $n$ clients associated with identifiers
$\cl_1 \dots \cl_n$, where each client $\cl_i$ executes
$\cmd_i$. 
Each client $\cl_i$ is associated with its own client-local  \emph{stack}, 
$\stk_i \in \Stacks \defeq \Vars \to \Val$,  mapping program variables
(ranged over by $\pvar{x}, \pvar{y}, \cdots$)
to values. 
We assume a language of expressions built from values \( \val \)
and program variables \( \var \):
$\expr ::= \val \mid \var \mid \expr + \expr \mid \cdots$.
The \emph{evaluation} $\evalE{\expr}$ of expression $\expr$ is parametric in
the client-local stack \( \stk \), where:%
%
{%
\begin{gather*}
\evalE{\val} \defeq
\val
\quad
\evalE{\var} \defeq
\stk(\var)
\quad
\evalE{\expr_{1} + \expr_{2}} \defeq
\evalE{\expr_{1}} + \evalE{\expr_{2}}
\quad
\dots
\end{gather*}%
}%

\mypar{Transactional Semantics}  
Transactions are executed \emph{atomically}. 
Intuitively, given a configuration $\conf = (\mkvs, \vienv)$, 
when a client $\cl$ executes a transaction $\ptrans{\trans}$, 
it performs the following steps: 
\begin{enumerate*}
	\item it constructs an initial transactional state that is a snapshot of $\mkvs$ using its view $\vienv(\cl)$ as defined in \cref{def:snapshot};  
	\item it executes $\trans$ in isolation over the transactional state $\ss$
        accumulating the effects (the reads and writes) of executing $\trans$; and
	\item it commits $\trans$ by incorporating these effects into $\mkvs$.
\end{enumerate*}

\begin{definition}[Transactional States]
\label{def:heaps}
A \emph{transactional state}, \( \sn \in \Snapshots \defeq \Keys \to
\Val\),  is a function from keys to values.
\end{definition}


To capture the effects of executing a transaction $\trans$ on a snapshot $\ss$ of kv-store $\mkvs$, 
we identify the \emph{fingerprint} of $\trans$ on $\ss$.
A fingerprint of $\trans$ on $\ss$ and $\mkvs$
is a set of \emph{read} and \emph{write operations}, where
the read operations capture the values $\trans$ reads from $\ss$ (prior to overwriting them), and
the write operations capture the values $\trans$ writes to $\ss$ and aims to commit to $\mkvs$, so long as certain consistency conditions are met.  
Execution of a transaction in a given configuration may result in more than one fingerprint due to non-determinism. 

\begin{definition}[Fingerprints]
\label{beebop}
\label{def:fingerprint}
Let \( \Ops\) denotes the set of read (\( \otR\)) and write (\(\otW\)) \emph{operations} defined by 
$\Ops \defeq \Set{(l, \key, \val) }[ l \in \Set{\otR, \otW} \land \key \in \Keys \land \val \in \Val ]$.
A \emph{fingerprint} $\fp$ is a set of operations, $\fp \subseteq \Ops$,
such that: 
$\fora{\key \in \Keys, l  \in \Set{\otR, \otW}}
	(l, \key, \val_1), (l, \key, \val_2) \in \fp \implies \val_1 = \val_2$.
\end{definition}

Note that the last constraint ensure that for each key, a fingerprint contains at most one read operation and at most one write operation 
reflecting the fact that we work with transactions that are
atomically visible~\cite{laws}; 
that is, reads are taken from a single snapshot of the kv-store, 
and since clients see either none or all the writes of a transaction, only the last write to each key is 
committed.

We provide an operational description of the behaviour of a transactional command, $\trans$,
starting from an initial client stack, a transactional state and the empty fingerprint $\emptyset$. 
First, we define a transition system describing how client stack and transactional state are updated via primitive transactional commands.
For any function \( \mathsf f \), let \( \mathsf f\rmto{\mathsf d}{\mathsf r} \) denotes a new function where \( \mathsf f\rmto{\mathsf d}{\mathsf r}(\mathsf d') = {\mathsf r} \) if \( \mathsf d = \mathsf d' \), otherwise \( \mathsf f\rmto{\mathsf d}{\mathsf r}(\mathsf d') = \mathsf f(\mathsf d') \).


\begin{definition}
\label{def:primitive_semantics}
The transition system, $\toLTS{\transpri}\; \subseteq (\Stacks \times \Snapshots) \times (\Stacks \times \Snapshots)$, 
is defined by:
%
{%
\[
    \begin{array}{@{} r @{} c @{} l @{\quad} r @{} c @{} l@{}}
(\stk, \sn)  & \toLTS{\passign{\var}{\expr}}          
             & (\stk\rmto{\var}{\evalE{\expr}}, \sn) 
&
(\stk, \sn)  & \toLTS{\passume{\expr}}  
             & (\stk, \sn) \text{ where } \evalE{\expr} \neq 0
\\
(\stk, \sn)  & \toLTS{ \plookup{\var}{\expr} } 
             & (\stk\rmto{\var}{\sn(\evalE{\expr})}, \sn) 
&
(\stk, \sn) & \toLTS{\pmutate{\expr_{1}}{\expr_{2}}  }
            & (\stk, \sn\rmto{\key}{\val}) \ \text{where} \ \key = \evalE{\expr_{1}} \ \text{and} \ \val = \evalE{\expr_{2}}
\end{array}
\]%
}%
%
\end{definition}
\noindent Second, we define a \emph{fingerprint function}, $\mathsf{op}$, computing the fingerprint of primitive transactional commands:
\[
\begin{aligned}
    \func{op}[\stk, \sn, \passign{\var}{\expr}] & \defeq  \emptyop 
    & 
    \func{op}[\stk, \sn, \passume{\expr}] & \defeq \emptyop 
    \\
    \func{op}[\stk, \sn,  \plookup{\var}{\expr}] & \defeq (\otR, \evalE{\expr}, \sn(\evalE{\expr})) 
    &
    \func{op}[\stk,  \sn, \pmutate{\expr_{1}}{\expr_{2}}] & \defeq (\otW, \evalE{\expr_{1}}, \evalE{\expr_{2}})
\end{aligned}
\]
The  empty operation $\emptyop$ is used for those primitive commands that do not
contribute to the fingerprint.

Third, we define a \emph{combination} operator,
$\addO  : \pset{\Ops} \times \Ops \uplus \Set{\emptyop} \to \pset{\Ops}$ which
adds a read/write operation to a fingerprint and ignores the empty operation $\emptyop$:%
\[
\begin{aligned}
    \fp \addO (\otR, \key, \val)  
    & \defeq
    \begin{cases}
        \fp \cup \Set{(\otR, \key, \val)} & \text{if } \fora{l, v'} (l, \key, v') \! \notin \! \fp \\
        \fp &  \text{otherwise} \\
    \end{cases}  \\
    \fp \addO (\otW, \key, \val) 
    & \defeq 
    \left( \fp \! \setminus \! \Set{(\otW, \key, v')}[v' \in \Val] \right)  \!
    \cup \! \Set{(\otW, \key, \val)} \\
    \fp \addO \emptyop  & \defeq \fp 
\end{aligned}
\]
Note that a read from $\key$ is added to a fingerprint $\fp$ only if $\fp$ does not contain an entry for $\key$, thus only recording the first value read for $\key$ (before a subsequent write). 
In contrast, a write to $\key$ is always added to $\fp$ by removing the existing writes, thus only recording the last write to $\key$. 

%
\begin{figure*}[!t]
\begin{mathpar}
    \inferrule[\rl{TPrimitive}]{%
        (\stk, \sn) \toLTS{\transpri} (\stk', \sn') 
        \\
        \op = \func{op}[\stk, \sn, \transpri]
    }{%
        (\stk, \sn, \fp) , \transpri  \toTRANS   (\stk', \sn', \fp \addO \op) , \pskip 
    }%
    \\
     \inferrule[\rl{TChoice}]{%
		i \in \Set{1,2}
    }{%
		(\stk, \sn, \fp) , \trans_{1} \pchoice \trans_{2}  \toTRANS  (\stk, \sn, \fp) , \trans_{i}
    }
    \and
    \inferrule[\rl{TIter}]{ }{%
        (\stk, \sn, \fp),  \trans\prepeat \toTRANS  (\stk, \sn, \fp), \pskip \pchoice (\trans \pseq \trans\prepeat)
    }%
    \and
    \inferrule[\rl{TSeqSkip}]{ }{%
        (\stk, \sn, \fp), \pskip \pseq \trans \toTRANS  (\stk, \sn, \fp), \trans
    }%
    \and
    \inferrule[\rl{TSeq}]{%
		(\stk, \sn, \fp), \trans_{1} \toTRANS  (\stk', \sn', \fp'), \trans_{1}'
    }{%
		(\stk, \sn, \fp), \trans_{1} \pseq \trans_{2} \toTRANS  (\stk', \sn', \fp'), \trans_{1}' \pseq \trans_{2}
    }%
\end{mathpar}
\hrulefill
%\captionsetup{belowskip=-5pt}
\caption{Semantics rules for transactional commands}
\label{fig:semantics-trans}
\end{figure*}

Finally, we have all the ingredients to describe the behaviour of a transactional command.  \Cref{fig:semantics-trans} provides the one-step transactional semantics; 
the interesting rule is the \rl{TPrimitive} rule which describes how a primitive transactional command updates the client stack, the snapshot and the fingerprint; 
the remaining rules are standard.

\begin{definition}[Fingerprint Set]
Given a client stack $\stk$ and a transactional state $\sn$, the \emph{fingerprint set} of a transaction $\trans$ is:
\(
\Fingerprints \defeq \Set{\fp : (\stk, \sn, \emptyset), \trans \toTRANS^* (\stk', \sn', \fp), \pskip }
\)
where $\toTRANS^*$ is the transitive closure of $\toTRANS$ given in \cref{fig:semantics-trans}.  
A set $\fp$ in $\Fingerprints$ is called a \emph{final fingerprint} of $\trans$. 
\end{definition}
\noindent It is immediate to see that final fingerprints of $\trans$ contain at most one read (resp.\ one write) operation per key.

\mypar{Operational Semantics}
We give the operational semantics of commands and programs. 
The command semantics describes transitions of the form
$\cl \vdash (\mkvs, \vi, \stk), \cmd \ \toCMD{\lambda}_{\ET} \ (\mkvs', \vi', \stk') ,
\cmd'$, stating that given the kv-store $\mkvs$, view $\vi$ and stack $\stk$, 
a client $\cl$ may execute command $\cmd$ for one step, updating 
the kv-store to $\mkvs'$, the stack to $\stk'$, and the command to its continuation $\cmd'$.
The label $\lambda$ is either of the form $(\cl, \iota)$ denoting that $\cl$ executed a primitive command
that required no access to $\mkvs$, 
or $(\cl, \vi'', \fp)$ denoting that $\cl$ committed an atomic transaction with final fingerprint $\fp$ under the view $\vi''$.
Transitions are parametric in the choice of \emph{execution test} $\ET$, defined shortly in \cref{sec:cm}.
Intuitively, an execution test captures the \emph{consistency model} under which a transaction executes.
In \cref{sec:cm} we present the execution tests associated with several well-known consistency models.  %in the literature.

\begin{figure*}[t]
\begin{mathpar}
    \inferrule[\rl{CPrimitive}]{
		\stk \toLTS{\cmdpri} \stk'
    }{
        \cl \vdash 
        ( \mkvs, \vi, \stk ) , \cmdpri 
        \toCMD{(\cl,\iota)}_{\ET} 
        ( \mkvs, \vi, \stk' ) , \pskip
    }%
    \\
    \inferrule[\rl{CAtomicTrans}]{%
        \vi \viewleq  \vi'' 
        \\
        \sn = \snapshot[\mkvs,\vi''] 
        \\\\
        (\stk, \sn, \emptyset), \trans \toTRANS^{*}   (\stk', \stub,  \fp) , \pskip
        \\\\
        \txid \in \nextTxid[\cl, \mkvs] 
        \\
        \mkvs' = \updateKV[\mkvs, \vi'', \fp, \txid] 
        \\\\
        \ET \vdash (\mkvs, \vi'') \csat \fp : (\mkvs',\vi')
    }{%
        \cl \vdash 
        ( \mkvs, \vi, \stk ), \ptrans{\trans} 
        \toCMD{(\cl, \vi'', \fp)}_{\ET}
        (\mkvs',\vi', \stk' ) , \pskip
    }%
    \and
    \inferrule[\rl{PProg}]{%
	    \vi = \vienv (\cl)
        \\
        \vienv' = \vienv\rmto{\cl}{\vi'}
        \\\\
        \stk = \thdenv(\cl)
        \\
        \thdenv' = \thdenv\rmto{\cl}{\stk'}
        \\\\
        \cmd = \prog(\cl)
        \\
        \prog' = \prog\rmto{\cl}{\cmd'}
        \\\\
		\cl \vdash 
		( \mkvs, \vi, \stk ) , \cmd
		\toCMD{\lambda}_{\ET} 
		( \mkvs', \vi', \stk' ) , \cmd'  
    }{%
		\vdash 
		(\mkvs, \vienv, \thdenv ), \prog
		\toCMD{\lambda}_{\ET} 
		( \mkvs', \vienv', \thdenv' ) , \prog' ) 
    }%
\end{mathpar}
\hrulefill

\caption{Semantic rules for primitive  commands, atomic transactions and programs}
\label{fig:semantics}
\end{figure*}


\cref{fig:semantics} contains the rules for primitive commands and atomic transactions.  
The rules for the compound commands are straightforward and are given in \cref{sec:full-semantics}.
The transition system $\toLTS{\cmdpri}\; \subseteq \Stacks \times  \times \Stacks$ in the rule for primitive commands, $\rl{CPrimitive}$, lifts the transition system 
$\toLTS{\transpri}$ (\cref{def:primitive_semantics}) to those primitive commands that only affect the client stack:
\[
\stk \toLTS{\passign{\var}{\expr}} \stk\rmto{\var}{\evalE{\expr}}
\qquad 
\stk \toLTS{\passume{\expr}} \stk \text{ where } \evalE{\expr} \neq 0
\]
The rule for atomic transactions, \rl{CAtomicTrans}, describes the execution of an atomic 
transaction under execution test $\ET$.  
The first premise
states that the current view $\vi$ of the executing command maybe advanced to a newer atomic view $\vi''$ (see \cref{def:views}). 
This corresponds to the client receiving new updates.
Given the new view $\vi''$, the transaction obtains a snapshot $\ss$ of the kv-store $\mkvs$, 
and executes $\trans$ locally to completion ($\pskip$), updating the stack to $\stk'$, while accumulating the fingerprint $\fp$. 
Note that the resulting snapshot is ignored (denoted by $\stub$) as the effect of the transaction is recorded in the fingerprint $\fp$. 
%

The transaction is now ready to commit. The rule picks a fresh transaction identifier $\txid \in \nextTxid[\cl, \mkvs]$, 
and updates the kv-store via $\mkvs' = \updateKV[\mkvs, \vi'', \fp, \txid]$
if the commit is permitted by $\ET$ using the judgement $\ET \vdash (\mkvs, \vi'') \csat \fp : (\mkvs', \vi')$.
The set $\nextTxid[\cl, \mkvs]$ provides the transactions identifiers
associated with $\cl$ that are fresh for  $\mkvs$:
\(
\nextTxid[\cl, \mkvs] \defeq 
\Set{\txid_{\cl}^{n}}[%
\fora{m} \txid_{\cl}^{m} \in \mkvs \implies m < n ]
\).
By construction, all elements of $\nextTxid[\cl, \mkvs]$ are greater (with respect to session order $\SO$) 
than transaction identifiers previously used by $\cl$. 
The judgement $\ET \vdash (\mkvs, \vi'') \csat \fp : (\mkvs', \vi')$
states that the fingerprint $\fp$ is compatible with kv-store $\mkvs$
and view $\vi''$, and the resulting view $\vi'$ 
is compatible with view \( \vi'' \) and final kv-store \( \mkvs' \).
In \cref{sec:cm}, we give several examples of such judgements.
Finally, having selected a suitable transaction identifier $\txid$,
the $\updateKV[\mkvs, \vi, \fp, \txid]$, defined below, describes how the final fingerprint $\fp$ of $\txid$ executed 
under view $\vi$ updates $\mkvs$.
The function $\updateKV[\mkvs, \vi, \fp, \txid]$ updates $\mkvs$ with $\fp$ as follows: 
for each read operation $(\otR, \key, \_) \in \fp$, it adds $t$ 
to the reader set of the last version of $\key$ that is included in the view $\vi$ of the client; 
for each write operation $(\otW, \key, \val)$, it appends a new version $(\val, t, \emptyset)$ 
to $\mkvs(\key)$. 
Given a list of versions $\vilist = \ver_0 \lcat \cdots \lcat \ver_n$ 
and any index $i: 0 \leq i \leq n$, 
then $\vilist\rmto{i}{\ver}$ denotes 
$\vilist' = \ver_0 \lcat \cdots \lcat \ver_{i-1} \lcat \ver \lcat \ver_{i+1} \cdots \ver_{n}$,
where $\lcat$ denotes list concatenation. 

\begin{definition}[Transactional update]
\label{eq:updatekv}
\label{def:updatekv}
The \emph{transactional update function},  $\updateKV[\mkvs, \vi, \fp, \txid]$,  is
defined as follows:
%
{%
\[%
\begin{aligned}
    \updateKV[\mkvs, \vi, \emptyset, \txid] & \defeq \mkvs 
    \\[3pt]
    \updateKV[\mkvs, \vi, \Set{(\otR, \key, \val)} \uplus \fp, \txid]
    & \defeq \updateKV[\mkvs\rmto{\key}{\vilist},\vi, \fp, \txid] \\
    \omit\rlap{where \qquad \( i {=} \max_{<}(\vi(\key)) \quad (\val, \txid', \txidset) = \mkvs(\key, i) 
            \quad \vilist = \mkvs(\key)\rmto{i}{(\val, \txid', \txidset \uplus \Set{ \txid })}\)} 
    \\[3pt]
%	
	\updateKV[\mkvs, \vi, \Set{(\otW, \key, \val)} \uplus \fp, \txid] 
    & \defeq \updateKV[\mkvs', \vi, \fp, \txid] \quad \text{where} \quad  \mkvs' = \mkvs\rmto{\key}{ \mkvs(\key) \lcat (\val, \txid, \emptyset) } \\
\end{aligned}
\]%
}%
\end{definition}

Note that,  under the assumption that $\fp$ contains at most one read and one write 
operation per key and the identifier is fresh for $\mkvs$, 
the transaction update function and the transaction update set for
$\cl$ are well-defined. 

The last rule of \cref{fig:semantics} captures the execution of a program step, 
given a \emph{client environment} $\thdenv \in \ThdEnv$. 
A client environment $\thdenv$ is a function from client identifiers to variable stacks, associating each client with its stack. 
We assume that the domain of client environments contains 
the domain of the program throughout the execution: 
$\dom(\prog) \subseteq \dom(\thdenv)$.
Program transitions are simply defined in terms of the transitions of
their constituent client commands. 
This  yields a  standard interleaving semantics for concurrent
programs; 
that is, 
a client performs a reduction in an atomic step without
affecting other clients. 
