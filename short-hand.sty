\RequirePackage{thesis-macro}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% kv-store and view
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\NewDocumentCommand\Clients{}{\TypeFont{ClientID}\xspace}
\NewDocumentCommand\cl{}{{\MathVar{cl}}\xspace}
\NewDocumentCommand\clset{}{{\SetOf{c\!l}}\xspace}
\NewDocumentCommand\TxIDs{}{\TypeFont{TxID}\xspace}
\NewDocumentCommand\TxIDZs{}{\ensuremath{\TxIDs_0}\xspace}
\NewDocumentCommand\txid{od()}{%
\ensuremath{t%
\IfNoValueTF{#1}{}{_{#1}}%
\IfNoValueTF{#2}{}{^{#2}}%
}\xspace}
\NewDocumentCommand\txidrd{}{\txid[\text{rd}]}
\NewDocumentCommand\txidinit{}{\ensuremath{\txid_0}\xspace}
\NewDocumentCommand\txidset{}{\SetOf{t}}
\NewDocumentCommand\txidsetrd{}{\SetOf{t}_\text{rd}}
\NewDocumentCommand\Values{}{\TypeFont{Value}\xspace}
\NewDocumentCommand\val{}{\MathVar{v}}
\NewDocumentCommand\valset{}{\MathVar{\SetOf{v}}}
\NewDocumentCommand\valinit{}{\ensuremath{\val_0}\xspace}
\NewDocumentCommand\Keys{}{\TypeFont{Keys}\xspace}
\NewDocumentCommand\key{}{\MathVar{k}}
\NewDocumentCommand\keyset{}{\MathVar{\SetOf{k}}}
\NewDocumentCommand\Versions{}{\TypeFont{Version}\xspace}
\NewDocumentCommand\ver{}{\MathVar{\nu}}
\NewDocumentCommand\verlist{}{\MathVar{\mathcal{V}}}
\NewDocumentCommand\KVSs{}{\TypeFont{KVS}\xspace}
\NewDocumentCommand\kvs{d()}{\Func*{\mathcal{K}}(#1)}
\NewDocumentCommand\kvsinit{d()}{\Func*{\mathcal{K}_0}(#1)}
\NewDocumentCommand\Indexs{}{\Nat\xspace}
\NewDocumentCommand\idx{}{\MathVar{i}}
\NewDocumentCommand\Views{d()}{\Func{\TypeFont{Views}}(#1)}
\NewDocumentCommand\ViewEnvs{d()}{\Func*{\TypeFont{ViewEnv}}(#1)\xspace}
\NewDocumentCommand\vi{d()}{\Func*{u}(#1)}
\NewDocumentCommand\viinit{d()}{\Func*{\vi_0}(#1)}
\NewDocumentCommand\vienv{d()}{\Func{\mathcal{U}}(#1)}
\NewDocumentCommand\vienvinit{d()}{\Func*{\vienv_0}(#1)}
\NewDocumentCommand\Confs{}{\TypeFont{Conf}\xspace}
\NewDocumentCommand\ConfInits{}{\ensuremath{\TypeFont{Conf}_0}\xspace}
\NewDocumentCommand\conf{}{\ensuremath{\Gamma}\xspace}
\NewDocumentCommand\confinit{}{\ensuremath{\Gamma_0}\xspace}
\NewDocumentCommand\Snapshots{}{\TypeFont{Snapshot}\xspace}
\NewDocumentCommand\snap{d()}{\Func*{\sigma}(#1)}
\NewDocumentCommand\Stacks{}{\TypeFont{Stack}\xspace}
\NewDocumentCommand\stk{}{\MathVar{s}}
\NewDocumentCommand\Operations{}{\TypeFont{Op}\xspace}
\NewDocumentCommand\op{}{\MathVar{o}}
\NewDocumentCommand\opR{d()}{%
\IfNoValueTF{#1}{%
\MathVar{\PredicateFont{R}}%
}{%
\Tuple{\PredicateFont{R},#1}
}}
\NewDocumentCommand\opW{d()}{%
\IfNoValueTF{#1}{%
\MathVar{\PredicateFont{W}}%
}{%
\Tuple{\PredicateFont{W},#1}
}}
\NewDocumentCommand\opEmp{}{\epsilon}
\NewDocumentCommand\Fingerprints{}{\TypeFont{Fp}\xspace}
\NewDocumentCommand\fp{}{\MathVar{\mathcal{F}}}
\NewDocumentCommand\lib{}{\SetOf{l}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% semantics label
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\NewDocumentCommand\Labels{}{\TypeFont{Labels}\xspace}
\NewDocumentCommand\lb{}{\MathVar{\iota}}
\NewDocumentCommand\lbCl{O{\cl}m}{\MathVar{\Tuple{#1,#2}}}
\NewDocumentCommand\lbPri{O{\cl}}{\MathVar{\Tuple{#1,\bullet}}}
\NewDocumentCommand\lbView{O{\cl}m}{\MathVar{\Tuple{#1,#2}}}
\NewDocumentCommand\lbTrans{O{\cl}m}{\Tuple{#1,#2}}
\NewDocumentCommand\lbFp{O{\cl}m}{\Tuple{#1,#2}}
\NewDocumentCommand\lbCOPSWrite{O{\cl}D(){\repl}m}{\Tuple{#1,#2,#3}}
\NewDocumentCommand\lbCOPSOptRead{O{\cl}D(){\repl}m}{\Tuple{#1,#2,#3,\dagger}}
\NewDocumentCommand\lbCOPSPri{O{\cl}D(){\repl}}{\MathVar{\Tuple{#1,#2,\bullet}}}
\NewDocumentCommand\lbCOPSBound{O{\cl}D(){\repl}}{\MathVar{\Tuple{#1,#2,\dagger}}}
\NewDocumentCommand\lbCOPSRefetch{O{\cl}D(){\repl}m}{\MathVar{\Tuple{#1,#2,#3,\ddagger}}}
\NewDocumentCommand\lbCOPSFinishRead{O{\cl}D(){\repl}m}{\MathVar{\Tuple{#1,#2,#3,\ddagger}}}
\NewDocumentCommand\lbCOPSSync{D(){\repl}m}{\MathVar{\Tuple{#1,#2}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ET relation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\NewDocumentCommand\ExTests{}{\TypeFont{ExecutionTest}\xspace}
\NewDocumentCommand\et{O{}}{\ensuremath{\PredicateFont{ET}_{#1}}}
\NewDocumentCommand\ET{O{}}{{\et[#1]}}
\NewDocumentCommand\ETTraces{d()}{\Func*{\TypeFont{ETTraces}}(#1)}
\NewDocumentCommand\ettrc{}{\MathVar{\tau}}
\NewDocumentCommand\ClientEnvs{}{\TypeFont{ClientEnvs}\xspace}
\NewDocumentCommand\clenv{d()}{\Func{\mathcal{E}}(#1)}
\NewDocumentCommand\TransactionRelations{}{\TypeFont{TransRels}\xspace}
\NewDocumentCommand\rel{O{}d()}{{\Func*{R_{#1}}(#2)}}
\NewDocumentCommand\TOP{}{\ensuremath{\top}\xspace}
\NewDocumentCommand\RA{}{\PredicateFont{RA}\xspace}
\NewDocumentCommand\MR{}{\PredicateFont{MR}\xspace}
\NewDocumentCommand\RYW{}{\PredicateFont{RYW}\xspace}
\NewDocumentCommand\MW{}{\PredicateFont{MW}\xspace}
\NewDocumentCommand\WFR{}{\PredicateFont{WFR}\xspace}
\NewDocumentCommand\CC{}{\PredicateFont{CC}\xspace}
\NewDocumentCommand\UA{}{\PredicateFont{UA}\xspace}
\NewDocumentCommand\PSI{}{\PredicateFont{PSI}\xspace}
\NewDocumentCommand\CP{}{\PredicateFont{CP}\xspace}
\NewDocumentCommand\WSI{}{\PredicateFont{WSI}\xspace}
\NewDocumentCommand\SI{}{\PredicateFont{SI}\xspace}
\NewDocumentCommand\SER{}{\PredicateFont{SER}\xspace}

\NewDocumentCommand\SO{}{\MathVar{\RelationFont{SO}}}
\NewDocumentCommand\WW{O{}d()}{{\Func*{\RelationFont{WW}_{#1}}(#2)}}
\NewDocumentCommand\WWInv{O{}d()}{{\Func*{\RelationFont{WW}^{-1}_{#1}}(#2)}}
\NewDocumentCommand\WR{O{}d()}{{\Func*{\RelationFont{WR}_{#1}}(#2)}}
\NewDocumentCommand\RW{O{}d()}{{\Func*{\RelationFont{RW}_{#1}}(#2)}}
\NewDocumentCommand\VIS{O{}d()}{{\Func*{\RelationFont{VIS}_{#1}}(#2)}}
\NewDocumentCommand\VISInv{O{}d()}{{\Func*{\RelationFont{VIS}^{-1}_{#1}}(#2)}}
\NewDocumentCommand\AR{O{}d()}{{\Func*{\RelationFont{AR}_{#1}}(#2)}}
\NewDocumentCommand\ARInv{O{}d()}{{\Func*{\RelationFont{AR}^{-1}_{#1}}(#2)}}
\NewDocumentCommand\DEP{O{}d()}{{\Func*{\RelationFont{DEP}_{#1}}(#2)}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% graph
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\NewDocumentCommand\DependencyGraphs{}{\TypeFont{DGraphs}\xspace}
\NewDocumentCommand\dgraph{}{\MathVar{\mathcal{G}}\xspace}
\NewDocumentCommand\txidop{d()}{\Func*{\mathcal{T}}(#1)}
\NewDocumentCommand\AbstractExecutions{}{\TypeFont{AExects}\xspace}
\NewDocumentCommand\aexec{}{\MathVar{\mathcal{X}}\xspace}
\NewDocumentCommand\aexecinit{}{\MathVar{\mathcal{X}_0}\xspace}
\NewDocumentCommand\VisAxioms{}{\TypeFont{VisAxioms}\xspace}
\NewDocumentCommand\visaxiom{}{\SetOf{a}\xspace}
\NewDocumentCommand\visaxioms{O{}}{\ensuremath{\SetSetOf{a}_{#1}}\xspace}
\NewDocumentCommand\aexectrc{}{\MathVar{\pi}\xspace}
\NewDocumentCommand\AexecInv{}{\TypeFont{AExectInvs}\xspace}
\NewDocumentCommand\aexecinv{od()}{
\IfNoValueTF{#1}{\Func*{I}(#2)}{\Func*{I_{#1}}(#2)}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% cops
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\NewDocumentCommand\COPSReplicas{}{\TypeFont{COPSReps}\xspace}
\NewDocumentCommand\repl{}{\MathVar{r}}
\NewDocumentCommand\COPSTxIDs{}{\TypeFont{COPSTxIDs}\xspace}
\NewDocumentCommand\copstxid{oO{\repl}d()}{%
\MathVar{\hat{t}%
\IfNoValueTF{#1}{}{_{#1}}%
\IfNoValueTF{#3}{}{%
\setsepchar{,}
\readlist*\numberElems{#3}%
\ifnum\numberElemslen<2%
^{\Tuple{#3,#2,0}}
\else
^{\Tuple{\numberElems[1],#2,\numberElems[2]}}
\fi}}}
\NewDocumentCommand\COPSVersions{}{\TypeFont{COPSVers}\xspace}
\NewDocumentCommand\copsver{}{\MathVar{\hat{\nu}}}
\NewDocumentCommand\copsverlist{}{\MathVar{\hat{\mathcal{V}}}}
\NewDocumentCommand\COPSDependencies{}{\TypeFont{COPSDeps}\xspace}
\NewDocumentCommand\copsdep{}{\MathVar{\hat{d}}}
\NewDocumentCommand\copsdepset{}{\MathVar{\hat{\SetOf{d}}}}
\NewDocumentCommand\COPSKVSs{}{\TypeFont{COPSKVSs}\xspace}
\NewDocumentCommand\copskvs{d()}{\Func*{\hat{\mathcal{K}}}(#1)}
\NewDocumentCommand\COPSs{}{\TypeFont{COPSs}\xspace}
\NewDocumentCommand\cops{d()}{\Func*{\hat{\mathcal{R}}}(#1)}
\NewDocumentCommand\COPSContexts{d()}{\Func*{\TypeFont{COPSCtxs}}(#1)}
\NewDocumentCommand\copsctx{d()}{\Func*{\hat{u}}(#1)}
\NewDocumentCommand\COPSContextEnvs{d()}{\Func*{\TypeFont{COPSCtxEnvs}}(#1)}
\NewDocumentCommand\copsctxenv{d()}{\Func*{\hat{\mathcal{U}}}(#1)}
\NewDocumentCommand\COPSConfs{d()}{\Func*{\TypeFont{COPSConfs}}(#1)}
\NewDocumentCommand\copsconf{d()}{\MathVar{\hat{\Gamma}}}
\NewDocumentCommand\COPSConfInits{d()}{\Func*{\TypeFont{COPSConfs}_0}(#1)}
\NewDocumentCommand\copsconfinit{d()}{\MathVar{\hat{\Gamma}_0}}
\NewDocumentCommand\Times{}{\TypeFont{Times}\xspace}
%%%%%%%%%%% careful
\RenewDocumentCommand\ts{}{\MathVar{n}}
\NewDocumentCommand\COPSCommands{}{\TypeFont{COPSCmds}\xspace}
\NewDocumentCommand\copscmd{}{\MathVar{\hat{\cmd}}}
\NewDocumentCommand\COPSRunCommands{}{\TypeFont{COPSRuntimeCmds}\xspace}
\NewDocumentCommand\copsruncmd{}{\MathVar{\hat{\CodeFont{R}}}}
\NewDocumentCommand\COPSTraces{}{\TypeFont{COPSTraces}\xspace}
\NewDocumentCommand\copstrc{}{\MathVar{\zeta}}
\NewDocumentCommand\COPSPrograms{}{\TypeFont{COPSProgs}\xspace}
\NewDocumentCommand\copsprog{}{\MathVar{\hat{\prog}}}
\NewDocumentCommand\COPSRunPrograms{}{\TypeFont{COPSRuntimeProgs}\xspace}
\NewDocumentCommand\copsrunprog{}{\MathVar{\hat{\CodeFont{I}}}}
\NewDocumentCommand\ExtCOPSTraces{}{\TypeFont{ExtCOPSTraces}\xspace}
\NewDocumentCommand\copsexttrc{}{\MathVar{\hat{\zeta}}}
\NewDocumentCommand\copsclenv{d()}{\Func*{\hat{\mathcal{C}}}(#1)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% program syntax 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\NewDocumentCommand\pskip{}{\MathVar{\CodeFont{skip}}}
\NewDocumentEnvironment{Transaction}{}{%
\left[ 
% check if there are multiple lines
\begin{array}{@{}l@{}}%
}{%
\end{array}%
\right]%
}
\NewDocumentCommand\ptrans{m}{\MathVar{%
\begin{Transaction}%
#1%
\end{Transaction}%
}}
\NewDocumentCommand\pseq{}{\MathVar{\mathbin{;}}}
\NewDocumentCommand\pchoice{}{\MathVar{\mathbin{+}}}
\NewDocumentCommand\ppar{}{\MathVar{\mathbin{\|}}}
\NewDocumentCommand\prepeat{d()}{%
\IfNoValueTF{#1}{%
\MathVar{\mathop{{}^*}}%
}{%
\MathVar{\mathop{{#1}^*}}%
}%
}
\NewDocumentCommand\AssignSymbol{}{\MathVar{\mathrel{:=}}}
\NewDocumentCommand\passign{mm}{\MathVar{#1 \AssignSymbol #2}}
\NewDocumentCommand\passume{d()}{\Func*{\CodeFont{assume}}(#1)}
\NewDocumentCommand\pmutate{mm}{\MathVar{\left[ #1\right] \AssignSymbol #2}}
\NewDocumentCommand\plookup{mm}{\MathVar{#1 \AssignSymbol \left[ #2 \right]}}
\NewDocumentCommand\pif{d()}{\MathVar{%
\CodeFont{if}%
\IfNoValueTF{#1}{}{(#1)}\xspace%
}}
\NewDocumentCommand\pelse{}{\MathVar{\CodeFont{else}}}
\NewDocumentCommand\pwhile{d()}{\MathVar{%
\CodeFont{while}%
\IfNoValueTF{#1}{}{(#1)}\xspace%
}}
\NewDocumentCommand\Expressions{}{\TypeFont{Expressions}}
\NewDocumentCommand\expr{}{\MathVar{\CodeFont{E}}}
\NewDocumentCommand\Booleans{}{\TypeFont{Booleans}}
\NewDocumentCommand\bool{}{\MathVar{\CodeFont{B}}}
\NewDocumentCommand\true{}{\MathVar{\CodeFont{true}}}
\NewDocumentCommand\false{}{\MathVar{\CodeFont{false}}}
\NewDocumentCommand\Programs{}{\TypeFont{Progs}}
\NewDocumentCommand\prog{d()}{\Func*{\CodeFont{P}}(#1)}
\NewDocumentCommand\ProgTraces{d()}{\Func*{\TypeFont{PTraces}}(#1)}
\NewDocumentCommand\progtrc{}{\MathVar{\eta}}
\NewDocumentCommand\Vars{}{\TypeFont{Var}}
\NewDocumentCommand\var{D(){x}}{\MathVar{\CodeFont{#1}}}
\NewDocumentCommand\Commands{}{\TypeFont{Commands}}
\NewDocumentCommand\cmd{}{\MathVar{\CodeFont{C}}}
\NewDocumentCommand\cmdpri{}{\MathVar{\CodeFont{C}_p}}
\NewDocumentCommand\Transactions{}{\TypeFont{Transactions}}
\NewDocumentCommand\trans{}{\MathVar{\CodeFont{T}}}
\NewDocumentCommand\transpri{}{\MathVar{\CodeFont{T}_p}}
\NewDocumentCommand\pcopsput{d()}{\Func*{\CodeFont{put}}(#1)}
\NewDocumentCommand\pcopsread{d()}{\Func*{\CodeFont{read}}(#1)}
\NewDocumentCommand\pk{d()}{\CodeFont{k}\xspace}
\NewDocumentCommand\pks{d()}{\CodeFont{ks}\xspace}
%\NewDocumentCommand\pv{d()}{\CodeFont{v}\xspace}
\NewDocumentCommand\pctx{d()}{\CodeFont{ctx}\xspace}
\NewDocumentCommand\prepl{d()}{\CodeFont{repl}\xspace}
\NewDocumentCommand\ret{}{\CodeFont{ret}}

\NewDocumentCommand\pcounter{sd()}{
\IfNoValueTF{#2}{\CodeFont{Counter}}{%
\IfBooleanTF{#1}{\CodeFont{Counter}\left(#2\right)}{
\CodeFont{Counter\left(#2\right)}}%
}\xspace}
\NewDocumentCommand\pread{sd()}{
\IfNoValueTF{#2}{\CodeFont{Read}}{%
\IfBooleanTF{#1}{\CodeFont{Read}\left(#2\right)}{
\CodeFont{Read\left(#2\right)}}%
}\xspace}
\NewDocumentCommand\pinc{sd()}{
\IfNoValueTF{#2}{\CodeFont{Inc}}{%
\IfBooleanTF{#1}{\CodeFont{Inc}\left(#2\right)}{
\CodeFont{Inc\left(#2\right)}}%
}\xspace}

\NewDocumentCommand\pbank{sd()}{
\IfNoValueTF{#2}{\CodeFont{Bank}}{%
\IfBooleanTF{#1}{\Func{\CodeFont{Bank}}(#2)}{
\Func{\CodeFont{Bank}}(#2)}}}
\NewDocumentCommand\pbalance{sd()}{
\IfNoValueTF{#2}{\CodeFont{Counter}}{%
\IfBooleanTF{#1}{\Func{\CodeFont{Balance}}(#2)}{
\Func{\CodeFont{Balance}}(#2)}}}
\NewDocumentCommand\pcheck{sd()}{
\IfNoValueTF{#2}{\CodeFont{DepositChecking}}{%
\IfBooleanTF{#1}{\Func{\CodeFont{DepositChecking}}(#2)}{
\Func{\CodeFont{DepositChecking}}(#2)}}}
\NewDocumentCommand\psave{sd()}{
\IfNoValueTF{#2}{\CodeFont{TransactSaving}}{%
\IfBooleanTF{#1}{\Func{\CodeFont{TransactSaving}}(#2)}{
\Func{\CodeFont{TransactSaving}}(#2)}}}
\NewDocumentCommand\pamal{sd()}{
\IfNoValueTF{#2}{\CodeFont{Amalgamate}}{%
\IfBooleanTF{#1}{\Func{\CodeFont{Amalgamate}}(#2)}{
\Func{\CodeFont{Amalgamate}}(#2)}}}
\NewDocumentCommand\pwritecheck{sd()}{
\IfNoValueTF{#2}{\CodeFont{WriteCheck}}{%
\IfBooleanTF{#1}{\Func{\CodeFont{WriteCheck}}(#2)}{
\Func{\CodeFont{WriteCheck}}(#2)}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% rule name 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\NewDocumentCommand\rTPrimitive{}{\RuleFont{TPrimitive}\xspace}
\NewDocumentCommand\rTChoice{}{\RuleFont{TChoice}\xspace}
\NewDocumentCommand\rTIter{}{\RuleFont{TIter}\xspace}
\NewDocumentCommand\rTSeqSkip{}{\RuleFont{TSeqSkip}\xspace}
\NewDocumentCommand\rTSeq{}{\RuleFont{TSeq}\xspace}
\NewDocumentCommand\rCAtomicTrans{}{\RuleFont{CAtomicTrans}\xspace}
\NewDocumentCommand\rCPrimitive{}{\RuleFont{CPrimitive}\xspace}
\NewDocumentCommand\rCChoice{}{\RuleFont{CChoice}\xspace}
\NewDocumentCommand\rCIter{}{\RuleFont{CIter}\xspace}
\NewDocumentCommand\rCSeqSkip{}{\RuleFont{CSeqSkip}\xspace}
\NewDocumentCommand\rCSeq{}{\RuleFont{CSeq}\xspace}
\NewDocumentCommand\rProg{}{\RuleFont{Prog}\xspace}
\NewDocumentCommand\rAAtomicTrans{}{\RuleFont{AAtomicTrans}\xspace}
\NewDocumentCommand\rAPrimitive{}{\RuleFont{APrimitive}\xspace}
\NewDocumentCommand\rAChoice{}{\RuleFont{AChoice}\xspace}
\NewDocumentCommand\rAIter{}{\RuleFont{AIter}\xspace}
\NewDocumentCommand\rASeqSkip{}{\RuleFont{ASeqSkip}\xspace}
\NewDocumentCommand\rASeq{}{\RuleFont{ASeq}\xspace}
\NewDocumentCommand\rAProg{}{\RuleFont{AProg}\xspace}
\NewDocumentCommand\rCOPSWrite{}{\RuleFont{COPSWrite}\xspace}
\NewDocumentCommand\rCOPSStartRead{}{\RuleFont{COPSStartRead}\xspace}
\NewDocumentCommand\rCOPSOptRead{}{\RuleFont{COPSOptRead}\xspace}
\NewDocumentCommand\rCOPSLowerBound{}{\RuleFont{COPSLowerBound}\xspace}
\NewDocumentCommand\rCOPSRefetch{}{\RuleFont{COPSRefetch}\xspace}
\NewDocumentCommand\rCOPSFinishRead{}{\RuleFont{COPSFinishRead}\xspace}
\NewDocumentCommand\rCOPSClient{}{\RuleFont{COPSClient}\xspace}
\NewDocumentCommand\rCOPSSync{}{\RuleFont{COPSSync}\xspace}
 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% operator function and predicate
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\RequirePackage{stmaryrd}
\NewDocumentCommand\Evaluation{mO{}}{\MathVar{\llbracket #1 \rrbracket_{#2}}}
\NewDocumentCommand\EvalE{mO{\stk}}{\Evaluation{#1}[#2]}
\NewDocumentCommand\EvalB{mO{\stk}}{\Evaluation{#1}[#2]}
\NewDocumentCommand\EvalET{mO{\et}}{\Evaluation{#1}[#2]}
\NewDocumentCommand\EvalAExec{mO{\visaxioms}}{\Evaluation{#1}[#2]}

\NewDocumentCommand\vileq{}{\ensuremath{\sqsubseteq}\xspace}
\NewDocumentCommand\copstxidle{}{\ensuremath{\sqsubset}\xspace}
\NewDocumentCommand\copstxidleq{}{\ensuremath{\sqsubseteq}\xspace}
\NewDocumentCommand\replleq{}{\ensuremath{\leq}\xspace}
\NewDocumentCommand\copskvsleq{}{\ensuremath{\sqsubseteq}\xspace}
\NewDocumentCommand\ettrceq{}{\ensuremath{\simeq}\xspace}
\NewDocumentCommand\AddOp{}{\ensuremath{\mathbin{<\!\!\!\vartriangleleft}}\xspace}
\NewDocumentCommand\copstrceq{}{\ensuremath{\simeq}\xspace}
\NewDocumentCommand\aexeceq{o}{\ensuremath{\IfNoValueTF{#1}{\simeq}{\simeq_{#1}}}}
\NewDocumentCommand\AKcomp{}{\ensuremath{\sim}\xspace}

\NewDocumentCommand\InitVal{d()}{\Func{InitialValue}(#1)}
\NewDocumentCommand\ValOf{d()}{\Func{ValueOf}(#1)}
\NewDocumentCommand\WtOf{d()}{\Func{WriterOf}(#1)}
\NewDocumentCommand\RsOf{d()}{\Func{ReadersOf}(#1)}
\NewDocumentCommand\Snapshot{d()}{\Func{Snapshot}(#1)}
\NewDocumentCommand\GetOp{d()}{\Func{GetOp}(#1)}
\NewDocumentCommand\NextTxid{d()}{\Func{NextTxID}(#1)}
\NewDocumentCommand\UpdateKV{d()}{\Func{UpdateKV}(#1)}
\NewDocumentCommand\CMET{d()}{\Func{ConsisModelET}(#1)}
\NewDocumentCommand\LastConf{d()}{\Func{LastConf}(#1)}
\NewDocumentCommand\ExtendProgram{d()}{\Func{ExtendProgram}(#1)}
\NewDocumentCommand\TransFp{d()}{\Func{TransFp}(#1)}
\NewDocumentCommand\VisTrans{d()}{\Func{VisTrans}(#1)}
\NewDocumentCommand\DepOf{d()}{\Func{DepSetOf}(#1)}
\NewDocumentCommand\COPSMerge{d()}{\Func{COPSMerge}(#1)}
\NewDocumentCommand\VerOf{d()}{\Func{VerOf}(#1)}
\NewDocumentCommand\VerListOf{d()}{\Func{VerListOf}(#1)}
\NewDocumentCommand\KToD{d()}{\Func{KToD}(#1)}
\NewDocumentCommand\KToT{d()}{\Func{KToT}(#1)}
\NewDocumentCommand\DToK{d()}{\Func{DToK}(#1)}
\NewDocumentCommand\CMA{d()}{\Func{ConsisModelAxioms}(#1)}
\NewDocumentCommand\AexecSnapshot{d()}{\Func{AExecSnapshot}(#1)}
\NewDocumentCommand\MaxVisTrans{d()}{\Func{MaxVisTrans}(#1)}
\NewDocumentCommand\Sort{O{}d()}{\Func{Sort_{#1}}(#2)}
\NewDocumentCommand\NextAExecTxid{d()}{\Func{NextAExecTxID}(#1)}
\NewDocumentCommand\UpdateAExec{d()}{\Func{UpdateAExec}(#1)}
\NewDocumentCommand\XToD{d()}{\Func{XToD}(#1)}
\NewDocumentCommand\XToK{d()}{\Func{XToK}(#1)}
\NewDocumentCommand\GetView{d()}{\Func{GetView}(#1)}
\NewDocumentCommand\TraceToX{d()}{\Func{TraceToX}(#1)}
\NewDocumentCommand\AexecCut{d()}{\Func{AExectCut}(#1)}
\NewDocumentCommand\ARClose{d()}{\Func{ARClose}(#1)}
\NewDocumentCommand\XToTrace{d()}{\Func{XToTrace}(#1)}
\NewDocumentCommand\XToTraceN{d()}{\Func{XToTraceN}(#1)}
\NewDocumentCommand\ApproxView{d()}{\Func{ApproxView}(#1)}
\NewDocumentCommand\VerLower{d()}{\Func{VerLower}(#1)}
\NewDocumentCommand\VerLowerN{d()}{\Func{VerLowerN}(#1)}

\NewDocumentCommand\COPSInsert{d()}{\Func{COPSInsert}(#1)}
\NewDocumentCommand\COPSViews{d()}{\Func{COPSViews}(#1)}
\NewDocumentCommand\COPSVisTrans{d()}{\Func{COPSVisTrans}(#1)}
\NewDocumentCommand\COPSToKVCmd{d()}{\Func{COPSToKVCmd}(#1)}
\NewDocumentCommand\COPSToKVProg{d()}{\Func{COPSToKVProg}(#1)}
\NewDocumentCommand\COPSToExt{d()}{\Func{COPSToExt}(#1)}
\NewDocumentCommand\COPSToKVS{d()}{\Func{COPSToKVS}(#1)}
\NewDocumentCommand\COPSToKVTrace{d()}{\Func{COPSToKVTrace}(#1)}

\NewDocumentCommand\NormalTrace{d()}{\Pred{NormalTrace}(#1)}
\NewDocumentCommand\WfView{d()}{\Pred{WfView}(#1)}
\NewDocumentCommand\WfET{d()}{\Pred{WfET}(#1)}
\NewDocumentCommand\WfKvs{d()}{\Pred{WfKvs}(#1)}
\NewDocumentCommand\CanCommit{O{}d()}{\Pred{CanCommit_{#1}}(#2)}
\NewDocumentCommand\ViewShift{O{}d()}{\Pred{ViewShift_{#1}}(#2)}
\NewDocumentCommand\PreClosed{d()}{\Pred{PreClosed}(#1)}
\NewDocumentCommand\Unique{d()}{\Pred{Unique}(#1)}
\NewDocumentCommand\WfCOPSKvs{d()}{\Pred{WfCOPSKvs}(#1)}
\NewDocumentCommand\COPSNormalTrace{d()}{\Pred{COPSNormalTrace}(#1)}
\NewDocumentCommand\WfDGraph{d()}{\Pred{WfDGraph}(#1)}
\NewDocumentCommand\WfAExec{d()}{\Pred{WfAExec}(#1)}
\NewDocumentCommand\TotalRelation{d()}{\Pred{TotalRelation}(#1)}
\NewDocumentCommand\WfVIS{d()}{\Pred{WfVIS}(#1)}
\NewDocumentCommand\AExecSat{d()}{\Pred{AExecSat}(#1)}
\NewDocumentCommand\WSISafe{d()}{\Pred{WSISafe}(#1)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% arrow
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\NewDocumentCommand\ToTrans{sm}{
\ensuremath{%
\IfBooleanTF{#1}{\rightsquigarrow}{%
% split into segments
\setsepchar{->}%
\readlist*\stepElems{#2}%
\foreachitem\stepElem\in\stepElems{%
% split a segment
\setsepchar{{|}}%
\readlist*\segElems{\stepElem}%
% the base for each segment
\Tuple{\segElems[1],\segElems[2],\segElems[3]}, \segElems[4]%
\ifnum\stepElemcnt<\stepElemslen%
% need an arrow
\ifnum\segElemslen<5%
\ArrowPadding{\rightsquigarrow}%
\else%
\ArrowPadding{\rightsquigarrow^{\segElems[5]}}%
\fi\fi%
}}}\xspace}
\RequirePackage{tikz}
\usetikzlibrary{calc,decorations.pathmorphing,shapes,arrows,positioning}
\NewDocumentCommand\xrightsquigarrow{moO{}}{%
\IfNoValueTF{#2}{%
\begin{tikzpicture}[baseline={([yshift=-2pt]current bounding box.south)}]%
\node[inner sep=.44ex,align=center] (tmp) {$\scriptstyle #1$};
\path[draw,<-,decorate,
decoration={zigzag,amplitude=0.7pt,segment length=1.2mm,pre length=3.5pt}] 
(tmp.south east) -- (tmp.south west);
\end{tikzpicture}
}{%
\begin{tikzpicture}[baseline={([yshift=4pt]current bounding box.south)}]%
\node[inner sep=.44ex,align=center] (tmp) {$\scriptstyle #1$};
\path[draw,<-,decorate,
decoration={zigzag,amplitude=0.7pt,segment length=1.2mm,pre length=3.5pt}] 
(tmp.south east) -- (tmp.south west);
\node[inner sep=0pt, outer sep=0pt, below right = 2pt and 0pt of tmp.south east] (sub) {\scriptsize \(#2\)};
\node[inner sep=0pt, outer sep=0pt, above right = 2pt and 0pt of tmp.south east] (sub) {\scriptsize \(#3\)};
\end{tikzpicture}
}\xspace}
\NewDocumentCommand\ToTransPri{m}{\xrightsquigarrow{#1}}
\NewDocumentCommand\xRightsquigarrow{m}{%
\mathrel{%
\begin{tikzpicture}[baseline= {( $ (current bounding box.south) + (0,-0.5ex) $ )}]
  \node[inner sep=.5ex] (a) {$\scriptstyle #1$};
  \path[draw,implies-,double distance between line centers=1.5pt,decorate,
    decoration={zigzag,amplitude=0.7pt,segment length=1.2mm,pre=lineto,
    pre   length=4pt}] 
    (a.south east) -- (a.south west);
\end{tikzpicture}}}

\NewDocumentCommand\ToCmd{sO{\et}m}{
\ensuremath{%
\IfBooleanTF{#1}{\xrightarrow{#3}_{#2}}{%
% split into segments
\setsepchar{->}%
\readlist*\stepElems{#3}%
\foreachitem\stepElem\in\stepElems{%
% split a segment
\setsepchar{{|}}%
\readlist*\segElems{\stepElem}%
% the base for each segment
% possible pattern $1
% possible pattern $1->$2
% possible pattern $1->$2$3
% possible pattern $1$2$3$4
% possible pattern $1$2$3$4->$5
% possible pattern $1$2$3$4->$5$6
\ifnum\segElemslen<4%
\segElems[1]%
\else%
\Tuple{\segElems[1],\segElems[2],\segElems[3]}, \segElems[4]%
\fi%
\ifnum\stepElemcnt<\stepElemslen%
% need an arrow
\ifnum\segElemslen<3%
\ArrowPadding{\xrightarrow{\segElems[2]}_{#2}}%
\else
\ifnum\segElemslen<4%
\ArrowPadding{\xrightarrow{\segElems[2]}_{#2}^{\segElems[3]}}%
\else
\ifnum\segElemslen<6%
\ArrowPadding{\xrightarrow{\segElems[5]}_{#2}}%
\else%
\ArrowPadding{\xrightarrow{\segElems[5]}_{#2}^{\segElems[6]}}%
\fi\fi\fi\fi%
}}}\xspace}
\NewDocumentCommand\ToCOPSCmd{sm}{
\ensuremath{%
\IfBooleanTF{#1}{\xrightsquigarrow{#2}}{%
% split into segments
\setsepchar{->}%
\readlist*\stepElems{#2}%
\foreachitem\stepElem\in\stepElems{%
% split a segment
\setsepchar{{|}}%
\readlist*\segElems{\stepElem}%
% the base for each segment
% possible pattern $1
% possible pattern $1->$2
% possible pattern $1->$2$3
% possible pattern $1$2$3$4
% possible pattern $1$2$3$4->$5
% possible pattern $1$2$3$4->$5$6
\ifnum\segElemslen<4%
\segElems[1]%
\else%
\Tuple{\segElems[1],\segElems[2],\segElems[3]}, \segElems[4]%
\fi%
\ifnum\stepElemcnt<\stepElemslen%
% need an arrow
\ifnum\segElemslen<3%
\ArrowPadding{\xrightsquigarrow{\segElems[2]}}%
\else
\ifnum\segElemslen<4%
\ArrowPadding{\xrightsquigarrow{\segElems[2]}[][\segElems[3]]}%
\else
\ifnum\segElemslen<6%
\ArrowPadding{\xrightsquigarrow{\segElems[5]}}%
\else%
\ArrowPadding{\xrightsquigarrow{\segElems[5]}[][\segElems[6]]}%
\fi\fi\fi\fi%
}}}\xspace}
\NewDocumentCommand\ToCOPSProg{sm}{
\ensuremath{%
\IfBooleanTF{#1}{\ArrowPadding{\xrightsquigarrow{#2}}}{%
% split into segments
\setsepchar{->}%
\readlist*\stepElems{#2}%
\foreachitem\stepElem\in\stepElems{%
% split a segment
\setsepchar{{|}}%
\readlist*\segElems{\stepElem}%
% the base for each segment
% possible pattern $1
% possible pattern $1$2
% possible pattern $1->$2
% possible pattern $1->$2$3
% possible pattern $1$2$3
% possible pattern $1$2$3->$4
% possible pattern $1$2$3->$4$5
\ifnum\stepElemcnt<\stepElemslen%
% need an arrow
{\ifnum\segElemslen<3%
\segElems[1]\ArrowPadding{\xrightsquigarrow{\segElems[2]}}%
\else
\ifnum\segElemslen<4%
\segElems[1]
\ArrowPadding{\xrightsquigarrow{\segElems[2]}[\phantom{-}][\segElems[3]]}%
\else
\ifnum\segElemslen<5%
\Tuple{\segElems[1],\segElems[2]},\segElems[3]
\ArrowPadding{\xrightsquigarrow{\segElems[4]}}%
\else
\Tuple{\segElems[1],\segElems[2]},\segElems[3]
\ArrowPadding{\xrightsquigarrow{\segElems[4]}[\phantom{-}][\segElems[5]]}%
\fi\fi\fi}
\else
{\ifnum\segElemslen<2%
\segElems[1]%
\else%
\ifnum\segElemslen<3%
\segElems[1],\segElems[2]%
\else%
\Tuple{\segElems[1],\segElems[2]},\segElems[3]%
\fi\fi}\fi%
}}}\xspace}
\NewDocumentCommand\ToCmdPri{m}{\xrightsquigarrow{#1}}
\NewDocumentCommand\ToProg{sO{\et}m}{
\ensuremath{%
\IfBooleanTF{#1}{\xrightarrow{#3}_{#2}}{%
% split into segments
\setsepchar{->}%
\readlist*\stepElems{#3}%
\foreachitem\stepElem\in\stepElems{%
% split a segment
\setsepchar{{|}}%
\readlist*\segElems{\stepElem}%
% the base for each segment
% possible pattern $1
% possible pattern $1$2
% possible pattern $1->$2
% possible pattern $1$2->$3
% possible pattern $1$2->$3$4
% possible pattern $1$2$3$4
% possible pattern $1$2$3$4->$5
% possible pattern $1$2$3$4->$5$6
\ifnum\stepElemcnt<\stepElemslen%
{\ifnum\segElemslen<3%
\segElems[1]%
\else%
\ifnum\segElemslen<5%
\segElems[1],\segElems[2]%
\else%
\Tuple{\segElems[1] , \segElems[2], \segElems[3]}, \segElems[4]%
\fi\fi}%
% need an arrow
{\ifnum\segElemslen<3%
\ArrowPadding{\xrightarrow{\segElems[2]}_{#2}}%
\else%
\ifnum\segElemslen<4%
\ArrowPadding{\xrightarrow{\segElems[3]}_{#2}}%
\else%
\ifnum\segElemslen<5%
\ArrowPadding{\xrightarrow{\segElems[3]}_{#2}^{\segElems[4]}}%
\else%
\ifnum\segElemslen<6%
\ArrowPadding{\xrightarrow{\segElems[5]}_{#2}}%
\else%
\ArrowPadding{\xrightarrow{\segElems[5]}_{#2}^{\segElems[6]}}%
\fi\fi\fi\fi}
\else
{\ifnum\segElemslen<2%
\segElems[1]%
\else%
\ifnum\segElemslen<3%
\segElems[1],\segElems[2]%
\else%
\Tuple{\segElems[1] , \segElems[2], \segElems[3]}, \segElems[4]%
\fi\fi}%
\fi%
}}}\xspace}
\NewDocumentCommand\TOET{mmmmmm}{%
\ensuremath{(#2,#3)\ArrowPadding{\xrightarrow{#4}_{#1}}(#5,#6)}\xspace}
\NewDocumentCommand\ToET{O{\et} >{\SplitArgument{4}{|}} m}{\TOET #1 #2}
\NewDocumentCommand\ToRed{sO{\et}m}{
\ensuremath{%
\IfBooleanTF{#1}{\xrightarrow{#3}_{#2}}{%
% split into segments
\setsepchar{->}%
\readlist*\stepElems{#3}%
\foreachitem\stepElem\in\stepElems{%
% split a segment
\setsepchar{{|}}%
\readlist*\segElems{\stepElem}%
% the base for each segment
% possible pattern $1
% possible pattern $1$2
% possible pattern $1->$2
% possible pattern $1$2->$3
% possible pattern $1$2->$3$4
\ifnum\stepElemcnt<\stepElemslen%
{\ifnum\segElemslen<3%
\segElems[1]%
\else%
\Tuple{\segElems[1] , \segElems[2]}%
\fi}%
% need an arrow
{\ifnum\segElemslen<3%
\ArrowPadding{\xrightarrow{\segElems[2]}_{#2}}%
\else%
\ifnum\segElemslen<4%
\ArrowPadding{\xrightarrow{\segElems[3]}_{#2}}%
\else%
\ArrowPadding{\xrightarrow{\segElems[3]}_{#2}^{\segElems[4]}}%
\fi\fi}
\else
{\ifnum\segElemslen<2%
\segElems[1]%
\else%
\Tuple{\segElems[1] , \segElems[2]}%
\fi}%
\fi%
}}}\xspace}
\NewDocumentCommand\ToEdge{sm}{
\ensuremath{%
\IfBooleanTF{#1}{\rightsquigarrow}{%
% split into segments
\setsepchar{->}%
\readlist*\stepElems{#2}%
\foreachitem\stepElem\in\stepElems{%
% split a segment
\setsepchar{{|}}%
\readlist*\segElems{\stepElem}%
% the base for each segment
\segElems[1]%
\ifnum\stepElemcnt<\stepElemslen%
% need an arrow
\ifnum\segElemslen<2%
\ArrowPadding{\xrightarrow{}}%
\else%
\ArrowPadding{\xrightarrow{\segElems[2]}}%
\fi\fi%
}}}\xspace}
\NewDocumentCommand\ToAexecCmd{sO{\visaxioms}m}{
\ensuremath{%
\IfBooleanTF{#1}{\ArrowPadding{\xrightsquigarrow{#3}[#2]}}{%
% split into segments
\setsepchar{->}%
\readlist*\stepElems{#3}%
\foreachitem\stepElem\in\stepElems{%
% split a segment
\setsepchar{{|}}%
\readlist*\segElems{\stepElem}%
% the base for each segment
% possible pattern $1
% possible pattern $1$2
% possible pattern $1->$2
% possible pattern $1->$2$3
% possible pattern $1$2$3
% possible pattern $1$2$3->$4
% possible pattern $1$2$3->$4$5
\ifnum\stepElemcnt<\stepElemslen%
% need an arrow
{\ifnum\segElemslen<3%
\segElems[1]\ArrowPadding{\xrightsquigarrow{\segElems[2]}[#2]}%
\else
\ifnum\segElemslen<4%
\segElems[1]
\ArrowPadding{\xrightsquigarrow{\segElems[2]}[#2][\segElems[3]]}%
\else
\ifnum\segElemslen<5%
\Tuple{\segElems[1],\segElems[2]},\segElems[3]
\ArrowPadding{\xrightsquigarrow{\segElems[4]}[#2]}%
\else
\Tuple{\segElems[1],\segElems[2]},\segElems[3]
\ArrowPadding{\xrightsquigarrow{\segElems[4]}[#2][\segElems[5]]}%
\fi\fi\fi}
\else
{\ifnum\segElemslen<2%
\segElems[1]%
\else%
\ifnum\segElemslen<3%
\segElems[1],\segElems[2]%
\else%
\Tuple{\segElems[1],\segElems[2]},\segElems[3]%
\fi\fi}\fi%
}}}\xspace}
\NewDocumentCommand\ToAexecProg{sO{\visaxioms}m}{
\ensuremath{%
\IfBooleanTF{#1}{\ArrowPadding{\xrightsquigarrow{#3}[#2]}}{%
% split into segments
\setsepchar{->}%
\readlist*\stepElems{#3}%
\foreachitem\stepElem\in\stepElems{%
% split a segment
\setsepchar{{|}}%
\readlist*\segElems{\stepElem}%
% the base for each segment
% possible pattern $1
% possible pattern $1$2
% possible pattern $1->$2
% possible pattern $1->$2$3
% possible pattern $1$2$3
% possible pattern $1$2$3->$4
% possible pattern $1$2$3->$4$5
\ifnum\stepElemcnt<\stepElemslen%
% need an arrow
{\ifnum\segElemslen<3%
\segElems[1]\ArrowPadding{\xrightsquigarrow{\segElems[2]}[#2]}%
\else
\ifnum\segElemslen<4%
\segElems[1]
\ArrowPadding{\xrightsquigarrow{\segElems[2]}[#2][\segElems[3]]}%
\else
\ifnum\segElemslen<5%
\Tuple{\segElems[1],\segElems[2]},\segElems[3]
\ArrowPadding{\xrightsquigarrow{\segElems[4]}[#2]}%
\else
\Tuple{\segElems[1],\segElems[2]},\segElems[3]
\ArrowPadding{\xrightsquigarrow{\segElems[4]}[#2][\segElems[5]]}%
\fi\fi\fi}
\else
{\ifnum\segElemslen<2%
\segElems[1]%
\else%
\ifnum\segElemslen<3%
\segElems[1],\segElems[2]%
\else%
\Tuple{\segElems[1],\segElems[2]},\segElems[3]%
\fi\fi}\fi%
}}}\xspace}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% text 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\NewDocumentCommand\SOUNDLET{smm}{
We prove that \( \et[#2] \) is sound respective to \( \visaxioms[#2] \).
Assume two kv-stores \(\kvs,\kvs'\), two views \(\vi, \vi'\) and a transaction \( \txid \) for a client \( \cl \), a fingerprint \(\fp\) 
such that \(\ToET[#2]{ \kvs |  \vi | \fp | \kvs' | \vi' } \), the transaction \(\txid \in \NextTxid(\kvs, \cl)\)
and the new kv-sotre \( \kvs' =  \UpdateKV(\kvs,\vi,\fp,\txid) \).
Assume an abstract execution \(\aexec\) such that \(\kvs = \XToK(\aexec)\) and 
\( \aexecinv[\MR](\aexec, \cl') \subseteq \VisTrans(\kvs, \vi) \) for any client \( \cl' \).
Let a set of transactions \( \txidset = \VisTrans(\kvs, \vi) \) and 
a set of read-only transactions \( \txidsetrd \) such that
\IfBooleanTF{#1}{\(#3\)}{\[#3\]}
Let a new abstract execution \( \aexec' = \UpdateAExec(\aexec, \txidset \cup \txidsetrd, \fp, \txid) \).
We now check if \( \aexec' \) satisfies \cref{equ:et-to-visaxioms,equ:aexecinv-preserve}.
}

\NewDocumentCommand\COMPLETELET{m}{
We prove that \( \et[#1] \) is complete respective to \( \visaxioms[#1] \).
Assume an abstract execution \(\aexec\) that satisfies \( \visaxioms[#1] \)
and a transaction \(\txid \in \aexec\). 
Assume \Th{\idx} and \Th{(\idx+1)} cuts, \( \aexec' = (\aexec,\idx) \) and \( \aexec'' = (\aexec,\idx+1) \).
Let a transaction \( \txid[\cl](n) =  \aexec'' \setminus \aexec' \),
a set of transactions \( \txidset = \VISInv[\aexec](\txid[\cl](n)) \)
and a view \( \vi = \GetView(\aexec,\txidset) \).
}
