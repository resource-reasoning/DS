\subsection{Key-value Store to Abstract Executions}
\label{app:aexec2kv}
\label{sec:thm:aexec2kv-compatible-proof}

We introduce the definition of the dependency graph induced an abstract execution:

\begin{definition}
\label{def:aexec2graph}
Given an abstract execution $\aexec$ that satisfies the last write wins policy,
the dependency graph $\graphof(\aexec) \defeq (\TtoOp{T}_{\aexec}, \RF_{\aexec}, 
\VO_{\aexec}, \AD_{\aexec})$ is defined by letting
\begin{itemize}
\item $\txid \xrightarrow{\RF_{\aexec}(\ke)} \txid'$ if and only if 
$\txid = \max_{\AR_{\aexec}}(\visibleWrites_{\aexec}(\ke, \txid'))$, 
\item $\txid \xrightarrow{\VO_{\aexec}(\ke)} \txid'$ if and only 
$\txid, \txid' \in_{\aexec} (\otW, \;\ke, \stub)$ 
and $\txid \xrightarrow{\AR_{\aexec}} \txid'$,
\item $\txid \xrightarrow{\AD_{\aexec}(\ke)} \txid'$ if and only if either 
$(\otR, \ke, \stub) \in_{\aexec} \txid, (\otW, \ke, \stub) \in_{\aexec} \txid'$ and 
whenever $\txid'' \xrightarrow{\RF_{\aexec}(\ke)} \txid$, 
then $\txid'' \xrightarrow{\VO_{\aexec}(\ke)} \txid'$.
\end{itemize}
\end{definition}

Note that each abstract execution $\aexec$ determines a key-value store $\hh_{\aexec}$,
as a result of \cref{def:aexec2graph} and \cref{thm:kv2graph}. 
Let $\hh$ be the unique kv-store such that $\Gr_{\hh} = \graphof(\aexec)$, then $\hh_{\aexec} = \hh$. 
As we will discuss later in this Section,
this mapping $\hh_{(\stub)}$ is NOT a bijection, 
in that several abstract executions may be encoded in the same key-value store.
Because key-value stores abstract away the total arbitration order of transactions.

Upon the relation \( \hh_{\aexec} = \hh \),
there is a deeper link between key-value store plus views and abstract exertions.
This notion, named \emph{compatibility}, bases on the intuition that 
clients can make observations over key-value stores and abstract executions, in terms of snapshots.

In key-value stores, observations are snapshots induced by views. 
While in abstract executions, observations correspond to the snapshots induced by the visible transactions.
Note that it is under the condition that the abstract execution adopts $\RP_{\LWW}$ resolution policy.
This approach is analogous to the one used by operation contexts in \cite{repldatatypes}.
Thus, a key-value store $\hh$ is \emph{compatible} with an abstract execution $\aexec$, written \( \mkvs \simeq \aexec \)
if any observation made on $\hh$ can be replicated by an observation made on $\aexec$, and vice-versa. 

\begin{definition}
\label{def:compatible}
Given a key-value store $\hh$,
an abstract execution $\aexec$ is compatible with $\hh$, written 
$\aexec \compatible \hh$, if and only if there exists a  mapping 
$f: \powerset{\T_{\aexec}} \rightarrow \Views(\hh)$
such that  
\begin{itemize}
\item for any subset $\T \subseteq \T_{\aexec}$, then $\RP_{\LWW}(\aexec, \T) = \{\snapshot(\hh, f(\T))\}$; 
\item for any view $\vi \in \Views(\hh)$, there exists a subset $\T \subseteq \T_{\aexec}$ 
such that $f(\T) = \vi$, and $\RP_{\LWW}(\aexec, \T) = \{\snapshot(\hh_{\aexec}, \vi)\}$.
\end{itemize}
\end{definition}

The function $\getView(\aexec, \T)$ defines the view on \( \mkvs_\aexec \) that corresponds to \( \T \) as the following:
\[
    \getView(\aexec, \T) \defeq \lambda \ke. \{0\} \cup \Setcon{ i }{\WTx(\hh_{\aexec}(\ke, i)) \in \T}
\]
Inversely, the function \( \Tx(\hh, \vi) \) converts a view to a set of observable transactions:
\[
\Tx(\hh, \vi) \defeq \Setcon{ \WTx(\hh(\ke, i)) }{ \ke \in \Keys \wedge i \in \vi(\ke) }
\]
Given \( \getView \), \( \Tx \), \cref{def:compatible}, 
it follows \( \aexec \compatible \hh_{\aexec} \) shown in \cref{thm:aexec2kv.compatible}.

\begin{theorem}
\label{thm:aexec2kv.compatible}
For any abstract execution $\aexec$ that satisfies the last write wins policy, $\aexec \compatible \hh_{\aexec}$.
\end{theorem}
\begin{proof}
Given the function $\getView(\aexec, \cdot )$ from $\powerset{\T_{\aexec}}$ to $\Views(\hh_{\aexec})$,
we prove it satisfies the constraint of \cref{def:compatible}.
Fix a set of transitions \( \T \).
By the \cref{prop:getview.valid}, the view $\getView(\aexec, \T )$  on \( \mkvs_\aexec \) is a valid view,
that is, \( \getView(\aexec, \T ) \in \Views(\mkvs_\aexec) \).
Given that it is a valid view, the \cref{prop:compatible.aexec2kv} proves:
\begin{equation}
    \label{equ:visible-trans-to-view}
    \RP_{\LWW}(\aexec, \T) = \Set{\snapshot(\hh_{\aexec}, \getView(\aexec, \T))} 
\end{equation}

The another way round is more subtle,
because \( \T \) contains any read only transaction.
By \cref{prop:getview.tx}, it is safe to erase read only transactions from \( \T \),
when calculating the view \( \getView(\aexec, \T ) \).
Last, by \cref{prop:compatible.kv2aexec}, we prove the following:
\begin{equation}
    \label{equ:view-to-visible-trans}
    \RP_{\LWW}(\aexec, \T) = \snapshot(\hh_{\aexec}, \vi)
\end{equation}
By \cref{equ:visible-trans-to-view} and \cref{equ:view-to-visible-trans},
it follows \( \aexec \compatible \hh_{\aexec} \).
\end{proof}

\begin{proposition}[Valid views]
\label{prop:getview.valid}
For any abstract execution $\aexec$, and $\T \subseteq \T_{\aexec}$, 
$\getView(\aexec, \T) \in \Views(\hh_{\aexec})$.
\end{proposition}
\begin{proof}
Assume an abstract execution $\aexec$, a set of transactions $\T \subseteq \T_{\aexec}$, and a key \( \ke \).
By the definition of $\getView(\aexec, \T)$, 
then $0 \in \getView(\aexec, \T)(\ke)$, and 
$0 \leq i < \abs{ \hh_{\aexec}(\ke) }$ for any index \( i \) such that $i \in \getView(\aexec, \T)(\ke)$.
Therefore we only need to prove that $\getView(\aexec, \T)$ satisfies \eqref{eq:view.atomic}.
Let $j \in \getView(\aexec, \T)(\ke)$ for some key $\ke$, and let $\txid = 
\WTx(\hh_{\aexec}(\ke, j))$. Let also $\ke', i$ be such that 
$\WTx(\hh_{\aexec}(\ke', i)) = \txid$. We need to show that 
$i \in \getView(\aexec, \T)(\ke')$. Note that it $\txid = \txid_{0}$ 
then $\WTx(\hh_{\aexec}(\ke', i)) = \txid$ only if $i = 0$, and 
$0 \in \getView(\aexec, \T)(\ke')$ by definition. 
Let then $\txid \neq \txid_{0}$. Because $\WTx(\hh_{\aexec}(\ke, j)) = \txid$ 
and $j \in \getView(\aexec, \T)$, then it must be the case that $\txid \in \T$. 
Also, because $\WTx(\hh_{\aexec}(\ke', i)) = \txid$, then $(\otW, \ke, \stub) \in 
\TtoOp{T}_{\aexec}(\txid)$. It follows that there exists an index $i' \in \getView(\aexec, \txid)(\ke')$ 
such that $\WTx(\hh_{\aexec}(\ke', i')) = \txid$. By definition of 
$\hh_{\aexec}$, if $\WTx(\hh_{\aexec}(\ke', i')) = \txid$, then it must 
be $i' = i$, and therefore $i \in \getView(\aexec, \txid)(\ke')$.
\end{proof}


\begin{proposition}[Visible transactions to views]
\label{prop:compatible.aexec2kv}
For any subset $\T \subseteq \T_{\aexec}$, $\RP_{\LWW}(\aexec, \T) = \{\snapshot(\hh_{\aexec}, \getView(\aexec, \T))\}$.
\end{proposition}

\begin{proof}
Fix $\T \subseteq \aexec$, and let $\{\hh\} = \RP_{\LWW}(\aexec, \T)$. We prove that, for any $\ke \in \Keys$, 
$\hh(\ke) = \snapshot(\getView(\aexec, \T))(\ke)$. There are two different cases: 
\begin{enumerate}
\item $\T \cap \{ \txid \mid (\otW, \ke, \stub) \in_{\aexec} \txid \} = \emptyset$. 
In this case $\hh(\ke) = \val_0$. 
We know that $\graphof(\aexec)$ satisfies all the constraints required by the definition of dependency graph 
(\cite{laws}). Together with \cref{thm:kv2graph} it follows that $\hh_{\aexec}(\ke, 0) = (\val_0, \txid_0, \stub)$.
We prove that $\getView(\aexec, \T)(\ke) = \{0\}$, 
hence 
\[ 
\snapshot(\hh_{\aexec}, \getView(\aexec, \T))(\ke) = \valueOf(\hh_{\aexec}(\ke, 0)) = \val_{0}
\]
Note that whenever $(\otW, \ke, \stub) \in_{\aexec} \txid$ for some $\txid$, then 
$\txid \notin \T$. Therefore, whenever $(\val, \txid, \stub) = \hh_{\aexec}(\ke, i)$ for some $i \geq 0$, then 
$\txid \notin \T$.
\[
\getView(\aexec, \T)(\ke) = \{0\} \cup \{i \mid \WTx(\hh_{\aexec}(\ke, i)) \in \T)\} = \{0\} \cup \emptyset = \{0\}
\]
\item Suppose now that $\T \cap \{ \txid \mid (\otW, \ke, \stub) \in_{\aexec} \txid \} \neq \emptyset$. 
Let then $\txid = \max_{\AR_{\aexec}}(\T \cap \{\txid \mid (\otW, \ke, \stub) \in_{\aexec} \txid\})$. 
Then $(\otW, \ke, \val) \in_{\aexec} \txid$ for some $\val \in \Val$. Furthermore, $\RP_{\LWW}(\aexec, \T)(\ke) = \val$.
By definition, $\txid' \in \T \cap \{ \txid \mid (\otW, \ke, \stub) \in_{\aexec} \txid\}$, 
then either $\txid' = \txid$ or $\txid' \xrightarrow{\AR_{\aexec}} \txid$. The definition of 
$\graphof(\aexec)$ gives that $\txid' \xrightarrow{\VO_{\aexec}(\ke)} \txid$. 
Because $(\otW, \ke, \val) \in_{\aexec} \txid$, then there exists an index 
$i \geq 0$ such that $\hh_{\aexec}(\ke, i) = (\val, \txid, \stub)$. Furthermore, 
whenever $\WTx(\ke, j) = \txid'$ for some $\txid'$ and $j > i$, then it must 
be the case that $\txid \xrightarrow{\VO_{\aexec}(\ke)} \txid'$, and because 
$\VO_{\aexec}(\ke)$ is transitive and irreflexive, it must be that  
$\neg( \txid' \xrightarrow{\VO_{\aexec}(\ke)} \txid)$ and $\txid \neq \txid'$: this implies that 
$\txid' \notin \T$. It follows that $\max(\getView(\aexec, \T)(\ke)) = i$, hence 
$\snapshot(\hh_{\aexec}, \getView(\aexec, \T)) = \valueOf(\hh_{\aexec}(\ke, i)) = \val$.
\end{enumerate}
\end{proof}

\begin{proposition}[Read-only transactions erasing]
\label{prop:getview.tx}
Let $\vi \in \Views(\hh_{\aexec})$, and let $\T \subseteq \T_{\aexec}$ be a 
set of read-only transactions in $\aexec$. Then 
$\getView(\aexec, \T \cup \Tx(\hh_{\aexec}, \vi)) = \vi$. 
\end{proposition}

\begin{proof}
Fix a key $\ke$. Suppose that $i \in \getView(\aexec, \T \cup \Tx(\hh_{\aexec}, \vi))(\ke)$. 
By definition, $\hh_{\aexec}(\ke, j) = (\stub, \txid, \stub)$ for some $\txid \in \T \cup \Tx(\hh_{\aexec}, \vi)$. 
Because $\T$ only contains read-only transactions, by definition of $\hh_{\aexec}$ there exists 
no index $j$ such that $\hh_{\aexec}(\ke, j) = (\stub, \txid', \stub)$ for some $\txid' \in \T$, 
hence it must be the case that $\txid \in \Tx(\hh_{\aexec}, \vi)$. By definition of $\Tx$, 
this is possible only if there exist a key $\ke'$ and an index $j$ such that $\hh_{\aexec}(\ke', \vi) = (\stub, \txid, \stub)$. 
Because $\vi$ is atomic by definition, and because $\hh_{\aexec}(\ke, i) = (\stub, \txid, \stub)$, then we have that $i \in \vi(\ke)$. 

Now suppose that $i \in \vi(\ke)$, and let $\hh_{\aexec}(\ke, i) = (\stub, \txid, \stub)$ for some $\txid$. 
This implies that $(\otW, \ke, \stub) \in_{\aexec} \txid$.
By definition $\txid \in \Tx(\hh_{\aexec}, \vi)$, hence $\txid \in \T \cup \Tx(\hh_{\aexec}, \vi))$. 
Because $\txid \in \T \cup \Tx(\hh_{\aexec}, \vi)$, then for any key $\ke'$ such that 
$(\otW, \ke', \stub) \in_{\aexec} \txid$, there exists an index $j \in \getView(\aexec, \T \cup \Tx(\hh_{\aexec}, \vi))$ 
$\hh(\ke', j) = (\stub, \txid, \stub)$; because kv-stores only allow a transaction to write at most one version 
per key, then the index $j$ is uniquely determined. In particular, we know that $(\otW, \ke, \stub) \in_{\aexec} \txid$, 
and $\hh_{\aexec}(\ke, \i) = (\stub, \txid, \stub)$, from which it follows that $i \in \getView(\aexec, \T \cup \Tx(\hh_{\aexec}, \vi))(\ke)$.
\end{proof}


\begin{proposition}[Views to visible transactions]
\label{prop:compatible.kv2aexec}
Given a view $\vi \in \Views(\hh_{\aexec})$, there exists $\T \subseteq \T_{\aexec}$ 
such that $\getView(\aexec, \T) = \vi$, and $\RP_{\LWW}(\aexec, \T) = \snapshot(\hh_{\aexec}, \vi)$.
\end{proposition}

\begin{proof}
We only need to prove that, for any $\vi \in \Views(\hh_{\aexec})$, there exists $\T \subseteq \T_{\aexec}$ such 
that $\getView(\aexec, \T) = \vi$. Then it follows from \cref{prop:compatible.aexec2kv} that 
$\RP_{\LWW}(\aexec, \T) = \snapshot(\hh_{\aexec}, \vi)$. 
It suffices to choose $\T = \bigcup\limits_{\ke \in \Keys}(\Setcon{ \WTx(\hh_{\aexec}(\ke, i)) }{ i > 0 
\wedge i \in \vi(\ke)})$.
Fix a key $\ke$, and let $i \in \vi(\ke)$. We prove that $i \in \getView(\aexec, \T)$. 
If $i = 0$, then $i \in \getView(\aexec, \T)$ by definition. 
Therefore, assume that $i > 0$. Let $\txid = \WTx(\hh_{\aexec}(\ke, i))$.
It must be the case that $\txid \in \T$ and $i \in \getView(\aexec, \T)(\ke)$.

Next, suppose that $i \in \getView(\aexec, \T)(\ke)$. We prove that $i \in \vi(\ke)$.
Note that if $i = 0$, then $i \in \vi(\ke)$ because of the 
definition of views. Let then $i > 0$. Because $i \in \getView(\aexec, \T)(\ke)$, we have that 
$\WTx(\hh_{\aexec}(\ke, i)) \in \T$.  Let $\txid = \WTx(\hh_{\aexec}(\ke, i))$. Because $i > 0$, 
it must be the case that $\txid \neq \txid_0$.
By definition, $\txid \in \T$ only if there 
exists an index $j$ and key $\ke'$, possibly different from $\ke$, such that $\WTx(\hh_{\aexec}(\ke', j)) = \txid$ and $j \in \vi(\ke')$. 
Because $\txid \neq \txid_0$ we have that $j > 0$. Finally, because $\vi$ is atomic by definition, $j \in \vi(\ke')$
$\WTx(\hh_{\aexec}(\ke', j)) = \txid = \WTx(\hh_{\aexec}(\ke, i))$, then it must be the case 
that $i \in \vi(\ke)$, which concludes the proof.
\end{proof}

