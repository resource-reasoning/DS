\subsection{Abstract Execution Traces to Key-value Store Traces}
\label{sec:aexectrace2kv}

We show to construct, given an abstract execution $\aexec$, 
a set of $\ET_{\top}$-traces $\KVtrace(\ET_{\top}, \aexec)$ in normal form such that for any 
$\tr \in \KVtrace(\ET_{\top}, \aexec)$, the trace \( \tr \) satisfies $\lastConf(\tr) = (\hh_{\aexec}, \_)$. 
%To define the function $\KVtrace(\ET_{\top}, \_)$ formally, 
We first define the \( \cut(\aexec,n) \) function in \cref{def:aexec.inductive} 
which gives the prefix of the first \( n \) transactions of the abstract execution \( \aexec \).
The  \( \cut(\aexec,n) \) function is very useful for later discussion.

\begin{definition}
\label{def:aexec.inductive}
Let $\aexec$ be an abstract execution, let $n = \lvert \T_{\aexec} \rvert$, and let 
$\{\txid_{i}\}_{i=1}^{n} \subseteq \T_{\aexec}$ be such that $\txid_{i} \xrightarrow{\AR_{\aexec}} \txid_{i+1}$. 
The \emph{cut} of the first \( n \) transactions from an abstract execution \( \aexec \) is defined as the follows:
\[
\begin{rclarray}
\cut(\aexec, 0) & \defeq & ([], \emptyset, \emptyset)\\
\cut(\aexec , i+1) & \defeq & \extend(\cut(\aexec, i), \txid_{i+1}, \VIS^{-1}_{\aexec}(\txid_{i+1}), \TtoOp{T}_{\aexec}(\txid_{i+1}))
\end{rclarray}
\]
\end{definition}

\begin{proposition}[Well-defined \( \cut \)]
\label{prop:aexec.inductive}
For any abstract execution $\aexec$, $\aexec = \cut(\aexec, \lvert \T_{\aexec} \rvert)$.
\end{proposition}
\begin{proof}
    This is an instantiation of \cref{lem:cut.explicit} by choosing $i = \lvert \T_{\aexec} \rvert$. 
\end{proof}

\begin{lemma}[Prefix]
\label{lem:cut.explicit}
For any abstract execution $\aexec$, and index $i: i \leq j \leq \lvert \T_{\aexec} \rvert$, 
if $\T_{\aexec} = \{\txid_{i}\}_{i=1}^{n}$ be such that 
$\txid_{i} \xrightarrow{\AR_{\aexec}} \txid_{i+1}$, 
then $\cut(\aexec, i) = \aexec_{i}$ where 
\[
\begin{rclarray}
\TtoOp{T}_{\aexec_{i}}(\txid) &=& 
\begin{cases}
\TtoOp{T}_{\aexec}(\txid) & \text{if } \exists j \leq i.\; \txid = \txid_{j}\\
\text{undefined} & \text{otherwise}\\
\end{cases} \\
\VIS_{\aexec_{i}} &=& \{ (\txid, \txid') \in \T_{\aexec_{i}} \mid \txid \xrightarrow{\VIS_{\aexec}} \txid'\} \\
\AR_{\aexec_{i}} &=& \{ (\txid, \txid') \in \T_{\aexec_{i}} \mid \txid \xrightarrow{\AR_{\aexec}} \txid'\}
\end{rclarray}
\]
\end{lemma}

\begin{proof}
Fix an abstract execution $\aexec$. We prove by induction on $i = \lvert \T_{\aexec} \rvert$.
\begin{itemize}
\item \caseB{$i = 0$} Then $\TtoOp{T}_{\aexec'} = [], \VIS_{\aexec'} = \emptyset$, 
$\AR_{\aexec'} = \emptyset$, which leads to $\aexec' = \cut(\aexec, 0)$. 
\item \caseI{$i = i' + 1$} 
Assume that $\cut(\aexec, i') = \aexec_{i'}$. 
We prove the following: 
\begin{itemize}
\item $\TtoOp{T}_{\cut(\aexec, i)} = \TtoOp{T}_{\aexec_i}$. 
By definition, 
\[
    \begin{array}{l}
\TtoOp{T}_{\cut(\aexec,i)} = \TtoOp{T}_{\cut(\aexec, i')}\rmto{\txid_{i}}{\TtoOp{T}_{\aexec}(\txid_{i})} 
\TtoOp{T}_{\aexec_{i'}}\rmto{\txid_{i}}{\TtoOp{T}_{\aexec}}(\txid_{i}) = \TtoOp{T}_{\aexec_{i}}
\end{array}
\]
\item $\VIS_{\cut(\aexec, i)} = \VIS_{\aexec_{i}}$. 
Note that, by inductive hypothesis, $\T_{\cut(\aexec, i')} = \T_{\aexec_{i'}} = \{\txid_{j}\}_{j=1}^{i'}$. 
We have that  
\[
\begin{array}{l}
    \VIS_{\cut(\aexec, i)} \\
    \quad = \VIS_{\cut(\aexec, i')} \cup \Setcon{(\txid_j, \txid_{i}) \in \VIS_{\aexec} }{ j = 1,\cdots, i'} \\ 
    \quad = \VIS_{\aexec_{i'}} \cup \{(\txid_{j}, \txid_{i}) \in \VIS_{\aexec} \mid j=1,\cdots, i'\} \\ 
    \quad = \{(\txid_{j'}, \txid_{j}) \in \VIS_{\aexec} \mid j', j = 0,\cdots, i'\} \cup \{(\txid_{j}, \txid_{i} \in \VIS_{\aexec} \mid j=1,\cdots, i'\} \\
    \quad = \{(\txid_{j'}, \txid_{j} \in \VIS_{\aexec} \mid j',j = 0,\cdots, i\} \\
    \quad = \VIS_{\aexec_{i}}
\end{array}
\]
\item $\AR_{\cut(\aexec, i)} = \AR_{\aexec_{i}}$. It follows the same way 
as the above. 
\end{itemize}
\end{itemize}
\end{proof}

Let $\Clients(\aexec) \defeq \{\cl \mid \exists n.\;\txid_{\cl}^{n} \in \T_{\aexec}\}$.
Given an abstract execution $\aexec$, a client $\cl$ and an index $i : 0 \leq i < \abs{\T_\aexec}$,
the function $\nextTx(\aexec, \cl, i) \defeq \min_{\AR_{\aexec}}\{\txid_{\cl}^{j} \mid \txid_{\cl}^{n} \notin \T_{\cut(\aexec, i)}\}$. 
Note that $\nextTx(\aexec, \cl, i)$ could be undefined. 
The conversion from abstract execution tests to \( \ET \) traces is in \cref{def:aexec2kvtrace}.

\begin{definition}
\label{def:aexec2kvtrace}
Given an abstract execution $\aexec$ and an index $i : 0 \leq i < \abs{\T_\aexec}$, 
the function $\KVtrace(\ET_{\top}, \aexec, i)$ is defined as the smallest set such that:
\begin{itemize}
\item 
$(\hh_{0}, \lambda \cl \in \Clients(\aexec). \lambda \ke.\{0\}) \in \KVtrace(\ET_{\top}, \aexec, 0)$, 
\item suppose that $\tr \in \KVtrace(\ET_{\top}, \aexec, i)$ for some $i$.  
Let
\begin{itemize} 
\item $\txid = \min_{\AR_{\aexec}}(\T_{\aexec} \setminus T_{\cut(\aexec, i)})$, 
\item  $\cl, n$ be such that $\txid = \txid_{\cl}^{n}$, 
\item  $\vi = \getView(\aexec, \VIS^{-1}_{\aexec}(\txid_{\cl}^{n}))$, 
\item $\vi' = \getView(\aexec, \T)$, where $\T$ is an arbitrary subset of $\T_{\aexec}$ if 
$\nextTx(\aexec, \cl, i+1)$ is undefined, or is such that 
$\T \subseteq (\AR_{\aexec}^{-1})?(\txid) \cap \VIS^{-1}_{\aexec}(\nextTx(\cl, i+1))$, 
\item $\opset = \TtoOp{T}_{\aexec}(\txid)$, 
\item $(\hh_{\tr}, \viewFun_{\tr}) = \lastConf(\tr)$, and
\item $\hh = \updateKV(\hh_{\tr}, \vi, \txid, \opset)$.
\end{itemize}
Then
\[
\left( 
\begin{array}{l}
\tr \xrightarrowtriangle{(\cl, \varepsilon)}_{\ET_{\top}} (\hh_{\tr}, \viewFun_{\tr}\rmto{\cl}{\vi}) \\ 
\qquad \xrightarrowtriangle{(\cl, \opset)}_{\ET_{\top}} (\hh, \viewFun_{\tr}\rmto{\cl}{\vi'}) 
\end{array}
\right) \in \KVtrace(\ET_{\top}, \aexec, i+1)
\]
\end{itemize}
Last, the function $\KVtrace(\ET_{\top}, \aexec) \defeq \KVtrace(\ET_{\top}, \aexec, \lvert \T_\aexec \rvert)$.
\end{definition}

\begin{proposition}[Abstract executions to trace \( \ET_\top \)]
\label{prop:aexec2kvtrace}
Given an abstract execution $\aexec$ satisfying $\RP_{\LWW}$, 
and a trace $\tr \in \KVtrace(\ET_{\top}, \aexec)$,
then $\lastConf(\tr) = (\hh_{\aexec}, \_)$ and $\hh_{\aexec} \in \CMs(\ET_{\top})$. 
\end{proposition}
\begin{proof}
Let $\aexec$ be an abstract execution that satisfies the last write wins policy. 
Let $n = \lvert \T_{\aexec} \rvert$. Fix $i =0,\cdots, n$, 
and let $\tr \in \KVtrace(\ET_{\top}, \aexec, i)$. We prove, by 
induction on $i$, that $\tr \in \CMs(\ET_{\top})$, and 
$\lastConf(\tr) = (\hh_{(\cut(\aexec, i)}, \_)$. 
Then the result follows from  \cref{prop:aexec.inductive}.

\begin{itemize}
\item \caseB{$i = 0$} By definition, $\tr = (\mkvs_{0}, \viewFun_{0})$, 
where $\viewFun_{0} = \lambda \cl \in \Clients(\aexec). \lambda \ke.\{0\}$. 
Clearly, we have that $\tr \in \CMs(\ET_{\top})$. 
\item \caseI{$i = i'+1$} Let $\txid_{i} = \min_{\AR_{\aexec}}(\T_{\aexec} \setminus \T_{\cut(\aexec, i')})$, 
and suppose that $\txid_{i} = \txid_{\cl}^{m}$ for some client $\cl$ and index $m$. 
Fix $\vi = \getView(\aexec, \VIS_{\aexec}^{-1}(\txid_{i}))$, and  $\opset = \TtoOp{T}_{\aexec}(\txid_{i})$.
We prove that there exists a trace $\tr' \in \KVtrace(\ET_{\top}, \aexec, i')$ and a set 
$\T$ such that: 
\begin{enumerate}
\item if $\nextTx(\cl, \aexec, i)$ is undefined then $\T \subseteq \T_{\aexec}$, otherwise 
\[
    \T \subseteq \VIS^{-1}_{\aexec}(\nextTx(\cl, \aexec, i)) \cap (\AR_{\aexec}^{-1})?(\txid_{i})
\]
\item the new trace \( \tr \) such that
\[
\tr = \tr' \xrightarrowtriangle{(\cl, \varepsilon)} (\hh_{\tr'}, \viewFun_{\tr'}\rmto{\cl}{\vi}) \xrightarrowtriangle{(\cl, \opset)} 
(\hh,  \viewFun_{\tr'}\rmto{\cl}{\vi'})
\]
where $(\hh_{\tr'}, \viewFun_{\tr'}) = \lastConf(\tr')$, and $\hh = \updateKV(\hh_{\tr'}, \vi, \txid_{i}, \opset)$, 
and $\vi' = \getView(\aexec, \T)$.
\end{enumerate}
By inductive hypothesis, we may assume that $\tr' \in \CMs(\ET_{\top})$, and $\hh_{\tr'} = \hh_{\cut(\aexec, i')}$. 
We prove the following facts: 
\begin{enumerate}
\item $\hh = \hh_{\extend(\cut(\aexec, i))}$. 
Because of \cref{prop:extend.update.sameop} and \cref{prop:aexec.inductive},
we obtain 
\[
\begin{array}{l}
\hh = \updateKV(\hh_{\tr'}, \vi, \txid_{i}, \opset) \\
\quad = \updateKV(\hh_{\cut(\aexec, i')}, \getView(\aexec, \VIS^{-1}_{\aexec}(\txid_{i}), \txid_{i}, \TtoOp{T}_{\aexec}(\txid_{i})) \\
\quad = \hh_{\extend(\cut(\aexec, i'), \VIS^{-1}_{\aexec}(\txid_{i}), \txid_{i}, \TtoOp{T}_{\aexec}(\txid_{i})) } \\
\quad = \hh_{\extend(\cut(\aexec, i))}
\end{array}
\]

\item $(\hh_{\tr'}, \viewFun_{\tr'}) \xrightarrowtriangle{(\cl, \varepsilon)}_{\ET_{\top}} (\hh_{\tr'}, \viewFun_{\tr'}\rmto{\cl}{\vi})$. 
It suffices to prove that $\viewFun_{\tr'}(\cl) \viewleq \vi$ for any key $\ke$.
By \cref{lem:cut.explicit} we have that $\T_{\cut(\aexec, i')} = \{\txid_{j}\}_{j=1}^{i'}$, for 
some $\txid_{1},\cdots, \txid_{i'}$ such that whenever $1 \leq j < j' \leq i'$, then 
$\txid_{j} \xrightarrow{\AR_{\aexec}} \txid_{j'}$. We consider two possible cases: 

\begin{itemize}
\item For all $j : 1 \leq j \leq i'$, and $h \in \Nat$, then $\txid_{j} \neq \txid_{\cl}^{h}$.
In this case we have that no transition contained in $\tr'$ has the form 
$(\_, \_) \xrightarrowtriangle{(\cl, \_)} (\_, \_)$, from which it is possible to infer 
that  $\viewFun_{\tr'}(\cl) = \lambda \ke. \{0\}$. Because $\vi = \getView(\aexec, \VIS^{-1}_{\aexec}(\txid_{i}))$, 
then by definition we have that $0 \in \vi(\ke)$ for all keys $\ke \in \Keys$. It follows that 
$\viewFun_{\tr'}(\cl) \viewleq \vi$. 

\item There exists an index $j : 1 \leq j \leq i'$ and an integer $h \in \Nat$ such that $\txid_{j} = \txid_{\cl}^{h}$. 
Without loss of generality, let $j$ be the largest such index. 
It follows that the last transition in $\tr'$ of the form $(\_, \_) \xrightarrow{(\cl, \opset_{j})} (\_, \viewFun_{\mathsf{pre}})$ 
is such that $\viewFun_{\mathsf{pre}}(\cl) = \getView(\aexec, \T_{\mathsf{pre}})$, 
for some $\T_{\mathsf{pre}} \subseteq \VIS^{-1}_{\aexec}(\txid_{i}) \cap (\AR^{-1}_{\aexec})?(\txid_{j})$.
This is because $\nextTx(\cl, \aexec, j)$  is defined and equal to $\txid_{i}$. 
Furthermore, because the trace $\tr'$ is in normal form by construction, 
in $\tr'$ a transition of the form $(\_, \_) \xrightarrowtriangle{(\cl, \varepsilon)}_{\ET_{\top}} (\_, \_)$ 
is always followed by a transition of the form $(\_, \_) \xrightarrowtriangle{(\cl, \opset')}_{\ET_{\top}} (\_, \_)$. 
Because we assume that the last transition where client $\cl$ executes a transaction in $\tr'$ 
has the form $(\_, \_) \xrightarrowtriangle{(\cl, \opset_{j})}_{\ET_{\top}} (\_, \viewFun_{\mathsf{pre}})$, 
then the latter is also the last transition for client $\cl$ in $\tr'$ 
(i.e. including both execution of transactions and view updates). 
It follows that $\viewFun_{\tr'}(\cl) = \viewFun_{\mathsf{pre}}(\cl)$, and in particular 
$\viewFun_{\tr'}(\cl) = \getView(\aexec, \T_{\mathsf{pre}})$. By definition, 
$\T_{\mathsf{pre}} \subseteq  \VIS^{-1}_{\aexec}(\txid_{i}) \cap (\AR^{-1}_{\aexec})?(\txid_{j}) 
\subseteq \VIS^{-1}_{\aexec}(\txid_{i})$. By  \cref{lem:getView.monotone}, 
we have that $\viewFun_{\tr'}(\cl) = \getView(\aexec, \T_{\mathsf{pre}}) \viewleq 
\getView(\aexec, \VIS^{-1}_{\aexec}(\txid_{i})) = \vi$, as we wanted to prove.
\ac{Note: this is more a sketch, rather than a real proof. A Proposition giving an explicit form to the 
structure of any $\tr \in \KVtrace(\ET_{\top}, \aexec)$ would be helpful for a more rigorous proof here.}
\end{itemize}


\item $(\hh_{\tr'}, \viewFun_{\tr'}\rmto{\cl}{\vi}) \xrightarrowtriangle{(\cl, \opset)}_{\ET_{\top}} (\hh,  \viewFun_{\tr'}\rmto{\cl}{\vi'})$. 
It suffices to show that $\ET_{\top} \vdash (\hh_{\tr'}, \vi) \csat \opset: \vi'$. 
That is, it suffices to show that $\vi \in \Views(\hh_{\tr'})$, $\vi' \in \Views(\hh)$, 
and whenever $(\otR, \ke, \val) \in \opset$, then $\max_{<}(\vi(\ke)) = (\val, \_, \_)$. 
The first two facts are a consequence of \cref{lem:cut.views}, $\hh_{\tr'} = \hh_{\cut(\aexec, i')}$, and  $\hh_{\cut(\aexec, i)}$. 
The last one that if $(\otR, \ke, \val) \in \opset$ then $\max_{<}(\vi(\ke)) = (\val, \_, \_)$ follows the fact that 
$\aexec$ satisfies the last write wins policy and the fact that $\vi = \getView(\VIS^{-1}_{\aexec}(\txid_{i}))$.
\ac{Again, the proof is really loose here, mostly because I got bored.}
\end{enumerate} 

\end{itemize}
\end{proof}

\begin{lemma}[Monotonic \( \getView \)]
\label{lem:getView.monotone}
Let $\aexec$ be an abstract execution, and let $\T_1 \subseteq \T_2 \subseteq \T_{\aexec}$. 
Then $\getView(\aexec, \T_1) \viewleq \getView(\aexec, \T_2)$.
\end{lemma}
\begin{proof}
Fix $\ke \in \Keys$. By definition  
\[
\begin{array}{l}
    \getView(\aexec, \T_1)(\ke) = \Set{0} \cup \Setcon{ i }{\WTx(\hh_{\aexec}(\ke, i)) \in \T_1} \\
    \quad \subseteq \Set{0} \cup \Setcon{i }{ \WTx(\hh_{\aexec}(\ke, i)) \in \T_2} \\
\quad = \getView(\aexec, \T_2)(\ke)
\end{array}
\]
then it follows that  $\getView(\aexec, \T_1) \viewleq \getView(\aexec, \T_2)$.
\end{proof}

\begin{lemma}[Valid view on cut of abstract execution]
\label{lem:cut.views}
Let $\aexec$ be an abstract execution, with $\T_{\aexec} = \{\txid_{i}\}_{i = 1}^{n}$ for 
$n = \lvert \T_{\aexec} \rvert$, and \( i : 0 \leq i < n\) such that $\txid_{i} \xrightarrow{\AR_{\aexec}} \txid_{i+1}$.
Assuming $\T_{0} = \emptyset$, and $\T_{i} \subseteq \AR^{-1}?(\txid_{i})$ for $i : 0 \leq i \leq n$,
then $\getView(\aexec, \T_{i}) \in \Views(\hh_{\cut(\aexec, i)})$.
\end{lemma}

\begin{proof}
We prove by induction on the index $i$. 
\begin{itemize}
\item \caseB{$i = 0$} It follows $\T_{0} = \emptyset$, and $\getView(\aexec, \T_{0}) = \lambda \ke. \{0 \}$. 
We also have that $\hh_{\cut(\aexec, 0)} = \lambda \ke. \List{(\val_0, \txid_{0}, \emptyset)}$, hence 
it is immediate to see that $\getView(\aexec, \T_{0}) \in \Views(\hh_{\cut(\aexec, 0)})$.

\item \caseI{$i = i'+1$}
Suppose that for any $\T \subseteq (\AR_{\aexec}^{-1}?)(\txid_{i'})$, 
then $\getView(\aexec, \T) \in \Views(\hh_{\cut(\aexec, i)})$. 
Let consider the set $\T_{i}$.
Note that, because of \cref{prop:extend.update.sameop}, we have that
\[
\begin{array}{l}
\hh_{\cut(\aexec, i)} =
\hh_{\extend(\cut(\aexec, i'), \txid_{i}, \VIS^{-1}_{\aexec}(\txid_{i}), \TtoOp{T}_{\aexec}(\txid_{i})} \\
\quad = \updateKV(\hh_{\cut(\aexec, i')}, \txid_{i}, \getView(\VIS^{-1}_{\aexec}(\txid_{i}), \TtoOp{T}_{\aexec}(\txid_{i})
\end{array}
\]
There are two possibilities:
\begin{itemize}
\item $\txid_{i} \notin \T_{i}$, where case $\T_{i} \subseteq (\AR_{\aexec}^{-1})?(\txid_{i'})$.
From the inductive hypothesis we get $\getView(\aexec, \T_{i}) \in \Views(\hh_{\cut(\aexec, i')})$. 
Note that $\hh_{\cut(\aexec, i')}$ only contains the transactions identifiers from $\txid_{1}$ to $\txid_{i'}$;
in particular, it does not contain $\txid_{i}$. 
Because $\hh_{\cut(\aexec, i)} = \updateKV(\hh_{\cut(\aexec, i')}, \txid_{i}, \_, \_)$, 
then by \cref{lem:updatekv.preserveviews} we have that $\getView(\aexec, \txid_{i}) \in \Views(\hh_{\cut(\aexec, i)})$.

\item $\txid \in \T_{i}$. Note that for any key $\ke$ such that 
$(\otW, \ke, \_) \notin \TtoOp{T}_{\aexec}(\txid_{i})$, then 
$\getView(\aexec, \T_{i})(\ke) = \getView(\aexec, \T_{i} \setminus \{(\txid_{i})\})(\ke)$; 
and for any key $\ke$ such that $(\otW, \ke, \_) \in \TtoOp{T}_{\aexec}(\txid_{i})$, 
then $\getView(\aexec, \T_{i}(\ke) = \getView(\aexec, \T_{i} \setminus \{\txid_{i}\})(\ke) 
\cup \{j \mid \WTx(\hh_{\aexec}(\ke, i)) = \txid_{j}\}$. 
In the last case, the index $j$ must be such that $j < \lvert \hh_{\cut(\aexec, i)} \rvert - 1$, 
because we know that $\txid_{i} \in \hh_{\cut(\aexec, i)}$. 
It follows from this fact and the inductive hypothesis, 
that $\getView(\aexec, \T_{i}) \in \Views(\mkvs_{\cut(\aexec, i)})$.
\ac{This is a loose proof sketch.} 
\end{itemize}
\end{itemize}
\end{proof}

\begin{lemma}[\(\updateKV \) preserving views]
\label{lem:updatekv.preserveviews}
Given a key-value store $\hh$, a transactions $\txid \notin \hh$, views $\vi, \vi' \in \Views(\hh)$, 
and set of operations $\opset$, then $\vi \in \updateKV(\hh, \txid, \vi', \opset)$.
\end{lemma}

\begin{proof}
Immediate from the definition of $\updateKV$. Note that $\txid \notin \hh$ ensures that 
$\vi$ still satisfies \eqref{eq:view.atomic} with respect to the new key-value store $\updateKV(\hh, \txid, \vi', \opset)$.
\end{proof}
