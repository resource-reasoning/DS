\subsection{Consistency Prefix \( \CP \) }
\label{sec:sound-complete-cp}

Given abstract execution \( \aexec \), we define read-write read-write relation:
\[
    \RW(\aexec,\key) \defeq \Setcon{(\txid, \txid')}{\txid \toEDGE{\AR_\aexec} \txid' \land (\otR,\key, \stub ) \in \txid \land (\otW,\key, \stub ) \in \txid'  } 
\]
It is easy to see \( \RW(\aexec,\key) \)  can be derived from \( \WW(\aexec,\key) \) and \( \WR(\aexec, \key ) \) as the following:
\[
    \RW(\aexec,\key) = \Setcon{(\txid, \txid')}{ \exsts{\txid'' } (\txid'', \txid) \in \WR(\aexec, \key) \land (\txid'', \txid') \in \WW(\aexec, \key) }
\]
Then, the notation \( \RW_\aexec \defeq \bigcup_{\key \in \Keys} \RW(\aexec, \key) \).
Note that for a kv-store \( \mkvs \) such that \( \mkvs = \mkvs_\aexec \),
by the definition of  \(  \mkvs = \mkvs_\aexec \), 
the following holds:
\[
    \RW_\aexec = \Setcon{(\txid, \txid')}{\exsts{\key, i,j } \txid \in \rsOf(\mkvs(\key, i)) \land \txid' = \wtOf(\mkvs(\key, j)) \land i < j}
\]
The \( \RW_\aexec \) also coincides with \( \RW_\Gr \) and \( \RW_\mkvs \).


An abstract execution \( \aexec \) satisfies consistency prefix (\(\CP\)), 
if it satisfies \( \AR_\aexec ; \VIS_\aexec \subseteq \VIS_\aexec \) and \( \SO_\aexec \subseteq \VIS_\aexec \).
Given the definition, there is a corresponding definition on dependency graph by solve the following inequalities:
\[
    \begin{array}{@{}l@{}}
        \WR \subseteq \VIS \\
        \WW \subseteq \AR \\
        \VIS \subseteq \AR \\
        \VIS ; \RW \subseteq \AR \\
        \AR ; \AR \subseteq \AR  \\
        \SO \subseteq \VIS \\
        \AR ; \VIS \subseteq \VIS
    \end{array}
\]
By solving the inequalities the visibility and arbitration relations are:
\[
    \begin{rclarray}
        \AR & \defeq & \left( (\SO \cup \WR ) ; \RW? \cup \WW \cup R \right)^+ \\
        \VIS & \defeq & \left( (\SO \cup \WR ) ; \RW? \cup \WW \cup R \right)^* ; (\SO \cup \WR )
    \end{rclarray}
\]
for some relation \( R \subseteq \AR \).
When \( R = \emptyset \), it is the smallest solution therefore the minimum visibility required.

\sx{A bit verbal}
\begin{lemma}
    \label{lem:cp-eauiv-spec}
    For any abstract execution \( \aexec \),
    if it satisfies 
    \[
        \left( (\SO \cup \WR ) ; \RW? \cup \WW \right)^* ; \VIS_\aexec \subseteq \VIS_\aexec 
        \qquad \SO_\aexec \subseteq \VIS_\aexec
    \]
    then there exists a new \( \aexec' \) such that \( \T_\aexec = \T_{\aexec'} \), 
    under last-write-win \( \TtoOp{T}_{\aexec}(\txid) = \TtoOp{T}_{\aexec'}(\txid) \) for all transactions \( \txid \),
    and the relations satisfy the following:
    \[ 
        \AR_{\aexec'} ; \VIS_{\aexec'} \subseteq \VIS_{\aexec'}  \qquad \SO_{\aexec'} \subseteq \VIS_{\aexec'}
    \]
    and vice versa.
\end{lemma}
\begin{proof}
    Assume abstract execution \( \aexec' \) that
    satisfies \( \AR_{\aexec'} ; \VIS_{\aexec'} \subseteq \VIS_{\aexec'} \)
    and  \( \SO_{\aexec'} \subseteq \VIS_{\aexec'} \).
    We already show that:
\[
    \begin{rclarray}
        \AR_{\aexec'} & = & \left( (\SO_\aexec \cup \WR_\aexec ) ; \RW_\aexec? \cup \WW_\aexec \cup R \right)^+ \\
        \VIS_{\aexec'} & = & \left( (\SO_\aexec \cup \WR_\aexec ) ; \RW_\aexec? \cup \WW_\aexec \cup R \right)^* ; (\SO_\aexec \cup \WR_\aexec )
    \end{rclarray}
\]
for some relation \( R \subseteq \AR_{\aexec'} \).
If we take \( R  = \emptyset \), we have the proof for:
\[
        \SO \subseteq \VIS_\aexec \qquad 
        \left( (\SO_\aexec \cup \WR_\aexec ) ; \RW_\aexec? \cup \WW_\aexec \right)^* ; \VIS_\aexec \subseteq \VIS_\aexec
\]
For another way, we pick the \( R \) that extends
\( \left( (\SO_\aexec \cup \WR_\aexec ) ; \RW_\aexec? \cup \WW_\aexec \cup R \right)^+ \) 
to a total order.
\end{proof}

By \cref{lem:cp-eauiv-spec} to prove soundness and completeness of \( \ET_\CP \), it is sufficient to use the definition:
\[
    (\RP_{\LWW}, \Set{\lambda \aexec. \left( (\SO \cup \WR ) ; \RW? \cup \WW \right)^* ; \VIS_\aexec, \lambda \aexec \ldotp \SO_\aexec }) 
\]

For the soundness, we pick the invariant as the following:
\[  
\begin{rclarray}
    I_1(\aexec, \cl) & = & \left( \bigcup_{\Setcon{\txid_{\cl}^{i} \in \T_{\aexec} }{ i \in \Nat }} \VIS_{\aexec}^{-1}(\txid^i_\cl) \right) \setminus \T_\rd \\
    I_2(\aexec, \cl) & = & \left( \bigcup_{\Setcon{\txid_{\cl}^{i} \in \T_{\aexec} }{ i \in \Nat }} (\SO_{\aexec}^{-1})?(\txid^i_\cl) \right) \setminus \T_\rd
\end{rclarray}
\]
where \( \T_\rd \) is all the read-only transactions included in both 
\( \left( \bigcup_{\Setcon{\txid_{\cl}^{i} \in \T_{\aexec} }{ i \in \Nat }} \VIS_{\aexec}^{-1}(\txid^i_\cl) \right)\) 
and \( \left( \bigcup_{\Setcon{\txid_{\cl}^{i} \in \T_{\aexec} }{ i \in \Nat }} (\SO_{\aexec}^{-1})?(\txid^i_\cl) \right) \).
Assume a key-value store $\mkvs$, an initial and a final view $\vi, \vi'$  a fingerprint $\fp$ 
such that $\ET_{\CP} \vdash (\mkvs, \vi) \csat \fp: ( \mkvs',\vi')$. 
Also choose an arbitrary $\cl$, a transaction identifier $\txid_\cl^n \in \nextTxid(\mkvs, \cl)$, 
and an abstract execution $\aexec$ such that $\mkvs_{\aexec} = \mkvs$ and 
\( I_1(\aexec, \cl) \cup I_2(\aexec, \cl) \subseteq \Tx(\mkvs, \vi) \).
Let a new abstract execution \( \aexec' = \extend(\aexec, \txid_\cl^n, \fp, \Tx(\mkvs, \vi) \cup \T_\rd) \).
We are about to prove that there exists an extra set of read-only transaction \( \T'_\rd \) such that:
\begin{gather}
    \fora{\txid} (\txid, \txid_\cl^n) \in \SO_{\aexec'} \implies \txid \in \Tx(\mkvs, \vi) \cup \T_\rd \cup \T'_\rd \label{equ:cp-sound-update-so}\\
    \begin{array}{l}
    \fora{\txid} (\txid, \txid_\cl^n) \in \left( (\SO_{\aexec'} \cup \WR_{\aexec'} ) ; \RW_{\aexec'}? \cup \WW_{\aexec'} \right)^* ; \VIS_{\aexec'} \\
    \qqquad \implies \txid \in \Tx(\mkvs, \vi) \cup \T_\rd \cup \T'_\rd 
    \end{array}
    \label{equ:cp-sound-update-arvis}\\
    I_1(\aexec',\cl) \cup I_2(\aexec',\cl) \subseteq \Tx(\mkvs_{\aexec'}, \vi') \label{equ:cp-sound-inv} 
\end{gather}
\begin{itemize}
\item the invariant \( I_2 \) implies the \cref{equ:cp-sound-update-so} where the proof is the same as \( \RYW \) in \cref{sec:sound-complete-ryw}.

\item For \cref{equ:cp-sound-update-arvis}, it is sufficient to prove one step inclusion, \ie
\[
    \begin{array}{l}
    \fora{\txid} (\txid, \txid_\cl^n) \in \left( (\SO_{\aexec'} \cup \WR_{\aexec'} ) ; \RW_{\aexec'}? \cup \WW_{\aexec'} \right) ; \VIS_{\aexec'} 
    \implies \txid \in \Tx(\mkvs, \vi) \cup \T_\rd \cup \T'_\rd 
\end{array}
\]
To prove above, let \( \T'_\rd \) initially be empty set.
We will add more read-only transactions until it satisfies \cref{equ:cp-sound-update-arvis}.
Assume a transaction \( \txid \) such that 
\( (\txid, \txid_\cl^n) \in \left( (\SO_{\aexec'} \cup \WR_{\aexec'} ) ; \RW_{\aexec'}? \cup \WW_{\aexec'} \right) ; \VIS_{\aexec'}\).
There exists a transaction \( \txid' \) such that \( \txid \toEDGE{(\SO_{\aexec'} \cup \WR_{\aexec'} ) ; \RW_{\aexec'}? \cup \WW_{\aexec'}} \txid' \toEDGE{\VIS_{\aexec'}}  \txid_\cl^n \).
It follows \( \txid'  \in \Tx(\mkvs, \vi) \cup \T_\rd \cup \T'_\rd  \).
Note that \( \txid \) and \( \txid' \) must exist in the abstract execution \( \aexec \) before update.
There are two cases: \( \txid' \) writes to at least a key; or \( \txid' \) is a read-only transaction.
\begin{itemize}
    \item
    If \( \txid' \) writes to at least a key, then \( \txid' \in \Tx(\mkvs, \vi)\).
    %\[
        %\begin{rclarray}
            %\func{RW^{-1}}{\mkvs, \key, i} & \defeq & \Setcon{\txid}{\exsts{ j \leq i } \txid \in \rsOf(\mkvs(\key,j))} \\
            %\dagger & \equiv &
            %\begin{array}[t]{@{}l@{}}
                %\fora{\key, \key', i, j, m, \txid, \txid', \txid''} \\
                %\left( \begin{array}{@{}l@{}}
                %i \in \vi(\key) 
                %\land \txid \in \Set{\wtOf(\mkvs(\key,i))} \cup \func{RW^{-1}}{\mkvs, \key, i} \land {} \\
                %\quad \left(
                    %\begin{array}{@{}l @{}}
                        %\left( \begin{array}{@{}l@{}}
                                %\txid' \in \func{SO^{-1}}{\txid} \land {} \\
                                %\txid' \in \Set{\wtOf(\mkvs(\key',j))} \cup  \rsOf(\mkvs(\key',j))
                        %\end{array} \right)  \lor {} \\
                        %\left( \begin{array}{@{}l@{}}
                                %\txid \in \rsOf(\mkvs(\key',j)) \land \txid' = \wtOf(\mkvs(\key',j))
                        %\end{array} \right)
                        %\end{array} \right) 
                    %\end{array}
                    %\right)  \\
                    %{} \lor \left( \begin{array}{@{}l@{}}
                            %i \in \vi(\key) \land \key = \key' \land j < i
                    %\end{array} \right) \\
                    %\qquad \implies j \in \vi(\key') 
            %\end{array} \\
        %\end{rclarray}
    %\]
    %We link the conditions in \( \dagger \) to relation:
    %\begin{itemize}
        %\item \( \RW_\aexec\). Assume a key \( \key \),  an index \( i \) and the writer \( \txid  = \wtOf(\mkvs(\key,i))\),
    %then \( \txid' \in \RW^{-1}(\mkvs, \key, i)\) if and only if \( \txid' \toEDGE{\RW_\aexec} \txid\).
        %\item \( \SO_\aexec\). The transaction identifiers encode the \( \SO_\aexec \).
        %That is, \( \txid' \in \SO^{-1}(\txid)\) if and only if \(\txid' \toEDGE{\SO_\aexec} \txid \).
        %\item  \( \WR_\aexec \). It is easy to see \( \txid \in \rsOf(\mkvs(\key',j)) \land \txid' = \wtOf(\mkvs(\key',j)) \) if and only if \( \txid' \toEDGE{\WR_\aexec} \txid \).
        %\item \( \WW_\aexec \). The write-write relation describes the order of write operations for a key which corresponds the version orders in key-value store.
        %That is, \( \txid' = \wtOf(\mkvs(\key,j)) \land \txid = \wtOf(\mkvs(\key,i)) \land j < i\) if and only if
        %\( \txid' \toEDGE{\WW_\aexec} \txid\).
    %\end{itemize}
    %Let assume \( \txid' \) writes to i-\emph{th} version a key \( \key \).
    %Given above and 
    %\[ \txid \toEDGE{(\SO_{\aexec'} \cup \WR_{\aexec'} ) ; \RW_{\aexec'}? \cup \WW_{\aexec'}} \txid' \toEDGE{\VIS_{\aexec'}}  \txid_\cl^n \] we can substitute and rewrite the \( \dagger \) as the following:
    %\begin{gather}
        %\begin{array}{@{}l@{}}
            %\fora{\txid'',\key',j}
            %\wtOf(\mkvs(\key,i)) = \txid' \land {} \\
            %\left( \begin{array}{@{}l@{}}
            %\txid'' \toEDGE{\RW_{\aexec'}?} \txid' \land {} \\
            %\quad \left(
                %\begin{array}{@{}l @{}}
                    %\left( \begin{array}{@{}l@{}}
                            %\txid \toEDGE{\SO_{\aexec'}} \txid'' \land 
                            %\txid \in \Set{\wtOf(\mkvs(\key',j))} \cup  \rsOf(\mkvs(\key',j))
                    %\end{array} \right)  \\
                    %{} \lor 
                    %\left( \begin{array}{@{}l@{}}
                            %\txid \toEDGE{\WR_{\aexec'}} \txid'' \land \txid = \wtOf(\mkvs(\key',j))
                    %\end{array} \right)
                    %\end{array} \right) 
                %\end{array}
                %\right)  \\
                %{} \lor \left( \begin{array}{@{}l@{}}
                        %\txid \toEDGE{\WW_{\aexec'}} \txid'' \land \txid = \wtOf(\mkvs(\key',j))
                %\end{array} \right) \\
                %\qquad \implies j \in \vi(\key') 
        %\end{array} 
        %\label{equ:cp-dagger}
    %\end{gather}
    Now we perform case analysis if \( \txid \) is a read-only transaction.
    \begin{itemize}
        \item if \( \txid \) has write, we prove \( \txid \in \Tx(\mkvs, \vi)\).
        Recall the \( \dagger \) is defined as the following:
        \begin{equation}
        \label{equ:cp-dagger}
        \dagger  \equiv 
            \fora{\key, \key', i, j}
                i \in \vi(\key)  \wedge \wtOf(\mkvs(\key', j)) \toEDGE{(((\SO \cup \WR_{\mkvs}) ; \RW_{\mkvs}?) \cup \WW_{\mkvs})^{+}} \wtOf(\mkvs(\key, i))
            \implies j \in \vi(\key')  
        \end{equation}
        Since \( \WR_\mkvs \), \( \WW_\mkvs \) and \( \RW_\mkvs \) coincide with
        \( \WR_\aexec \), \( \WW_\aexec \) and \( \RW_\aexec \) respectively.
        Also because \( \txid \) write to at least one key,
        it is easy to see there exists some version \( \key'',m\) such that 
        \( \txid = \wtOf(\mkvs(\key'',m))\) and \( m \in \vi(\key'')\).
        By definition of \( \Tx \), it follows \( \txid \in \Tx(\mkvs, \vi) \).
        %Therefore by the definition of \( \Tx \), then \( \txid \in \VIS^{-1}(\txid_\cl^n)\).
        \item if \( \txid \) is a read-only transaction, we add it into \( \T'_\rd \).
    \end{itemize}
    \item 
    if \( \txid' \) is a read-only transaction, then either \( \txid' \in \T_\rd \) or \( \txid' \in \T'_\rd \).
    More specifically we have three cases: \textbf{(i)} \( \txid' \in \bigcup_{\Setcon{\txid_{\cl}^{i} \in \T_{\aexec} }{ i \in \Nat }} \VIS_{\aexec}^{-1}(\txid^i_\cl) \), \textbf{(ii)} \( \txid' \in \bigcup_{\Setcon{\txid_{\cl}^{i} \in \T_{\aexec} }{ i \in \Nat }} (\SO_{\aexec}^{-1})?(\txid^i_\cl) \) or \textbf{(iii)} \( \txid' \in \T'_\rd\).
    \begin{itemize}
        \item
            Assume \( \txid' \in \bigcup_{\Setcon{\txid_{\cl}^{i} \in \T_{\aexec} }{ i \in \Nat }} \VIS_{\aexec}^{-1}(\txid^i_\cl) \).
        It means \( \txid' \) is visible for some previous transaction \( \txid_\cl^m \) (\( m < n \)) from the same client \( cl \), 
        \ie 
        \[ 
            \txid \toEDGE{(\SO_{\aexec'} \cup \WR_{\aexec'} ) ; \RW_{\aexec'}? \cup \WW_{\aexec'}} \txid' \toEDGE{\VIS_{\aexec'}}  \txid_\cl^m 
        \]
        Note that all the edges before \( \txid_\cl^m \) must exist in \( \aexec \).
        Since \( \aexec \) satisfies the \( \left( (\SO \cup \WR ) ; \RW? \cup \WW \right)^* ; \VIS_\aexec \subseteq \VIS_\aexec \),
        we have \( \txid \toEDGE{\VIS_{\aexec'}} \txid_\cl^m \) and then \( \txid \in \bigcup_{\Setcon{\txid_{\cl}^{i} \in \T_{\aexec} }{ i \in \Nat }} \VIS_{\aexec}^{-1}(\txid^i_\cl)\).
        By the invariant \( I_1 \), it means \( \txid \in \Tx(\mkvs, \vi) \cup \T_\rd \).
    \item \( \txid' \in \bigcup_{\Setcon{\txid_{\cl}^{i} \in \T_{\aexec} }{ i \in \Nat }} \SO_{\aexec}^{-1}(\txid^i_\cl) \).
    Since \( \txid' \) is a read-only transaction, 
    the edges can be simplified to \( \txid \toEDGE{(\SO_{\aexec'} \cup \WR_{\aexec'} )} \txid' \toEDGE{\SO_{\aexec'}}  \txid_\cl^n \).
    Given that \( \SO \) is transitive, then  either \( \txid \toEDGE{\SO_{\aexec'}} \txid_\cl^n \) or \( \txid \toEDGE{\WR_{\aexec'} } \txid' \toEDGE{\SO_{\aexec'}}  \txid_\cl^n \).
    \begin{itemize}
        \item \( \txid \toEDGE{\SO_{\aexec'}} \txid_\cl^n \).
            It follows \( \txid \in \bigcup_{\Setcon{\txid_{\cl}^{i} \in \T_{\aexec} }{ i \in \Nat }} \SO_{\aexec}^{-1}(\txid^i_\cl) = \Tx(\mkvs, \vi) \cup \T_\rd \).
        \item \( \txid \toEDGE{\WR_{\aexec'} } \txid' \toEDGE{\SO_{\aexec'}}  \txid_\cl^n \).
            The \( \WR \) edge must exists in \( \aexec \).
            Because \( \WR_\aexec \subseteq \VIS_\aexec \) then  \( \txid \toEDGE{\VIS_{\aexec} } \txid' \toEDGE{\SO_{\aexec'}}  \txid_\cl^n  \).
            It means 
            \[ 
                \txid \in \bigcup_{\Setcon{\txid_{\cl}^{i} \in \T_{\aexec} }{ i \in \Nat }} \VIS_{\aexec}^{-1}(\txid^i_\cl) = \Tx(\mkvs, \vi) \cup \T_\rd 
            \]
    \end{itemize}
    \item 
    Last, \( \txid' \in \T'_\rd \).
    Since \( \T'_\rd \) initially is empty set, there exists another write transaction \( \txid'' \) such that:
    \[
        \txid \toEDGE{(\SO_{\aexec'} \cup \WR_{\aexec'} ) ; \RW_{\aexec'}? \cup \WW_{\aexec'}} \txid' \toEDGE{(\SO_{\aexec'} \cup \WR_{\aexec'} ) ; \RW_{\aexec'}? \cup \WW_{\aexec'}} \txid'' \toEDGE{\VIS_{\aexec'}}  \txid_\cl^n
    \]
    %Given that \( \txid' \) is a read-only and \( \txid'' \) has write, the edges can be simplified:
    %\[
        %\txid \toEDGE{(\SO_{\aexec'} \cup \WR_{\aexec'} )} \txid' \toEDGE{\SO_{\aexec'} ; \RW_{\aexec'}?} \txid'' \toEDGE{\VIS_{\aexec'}}  \txid_\cl^n
    %\]
    %Because transitivity of  \( \SO \), we have the following two cases:
    %\[
        %\begin{array}{@{}l@{}}
            %\txid \toEDGE{ \WR_{\aexec'} } \txid' \toEDGE{\SO_{\aexec'} ; \RW_{\aexec'}?} \txid'' \toEDGE{\VIS_{\aexec'}}  \txid_\cl^n \\
            %\txid \toEDGE{\SO_{\aexec'} ; \RW_{\aexec'}?} \txid'' \toEDGE{\VIS_{\aexec'}}  \txid_\cl^n 
        %\end{array}
    %\]
    %\( \txid \toEDGE{ \WR_{\aexec'} } \txid' \toEDGE{\SO_{\aexec'} ; \RW_{\aexec'}?} \txid'' \toEDGE{\VIS_{\aexec'}}  \txid_\cl^n \).
        If \( \txid \) has write, by \cref{equ:cp-dagger} then \( \txid \in \Tx(\mkvs,\vi) \).
        Otherwise if \( \txid \) is a read only transaction, we add it into \( \T'_\rd \).
            %\( \txid \toEDGE{\SO_{\aexec'} ; \RW_{\aexec'}?} \txid'' \toEDGE{\VIS_{\aexec'}}  \txid_\cl^n \).
            %Similarly by \cref{equ:cp-dagger}, either \( \txid \in \Tx(\mkvs,\vi) \)  or we add it into \( \T'_\rd \).
    \end{itemize}
\end{itemize}

\item Since \( \CP \) satisfies \( \RYW \) and \( \MR \), thus invariants \( I_1 \) and  \( I_2 \) are preserved after update.

\end{itemize}

    
For completeness, we prove the three parts of the execution test separately.
\begin{itemize}
\item Since \( \SO_\aexec \subseteq \VIS_\aexec  \), the prove for \( \ET_\RYW \) is the as in \cref{sec:sound-complete-mr}.
\item For any \( \VIS_\aexec \)  satisfies the constraint for \( \CP \), by \cref{lem:cp-eauiv-spec} it satisfies that 
\[
    \VIS \defeq \left( (\SO \cup \WR ) ; \RW? \cup \WW \cup R \right)^* ; (\SO \cup \WR )
\]
for some relation \( R \).
It means \( \VIS_\aexec ; \SO_\aexec \subseteq \VIS_\aexec \).
Therefore it is complete with respect to \( \ET_\MR \).

\item Let consider the \( \dagger \).
Assume i-\emph{th} transaction \( \txid_i \) in the arbitrary order,
and let view \( \vi_{i} = \getView(\aexec, \VIS^{-1}_{\aexec}(\txid_{i}) ) \).
We also pick any final view such that \( \vi'_{i} \subseteq \getView(\aexec, (\AR^{-1}_{\aexec})?(\txid_{i}) ) \).
Note that there is nothing to prove for \( \vi'_i \) since the \( \dagger \) does not constrain the \( \vi'_i \).
Recall the \( \dagger \):
\[
\dagger  \equiv 
        \fora{\key, \key', m, j}
             m \in \vi(\key)  \wedge \wtOf(\mkvs(\key', j)) \toEDGE{(((\SO \cup \WR_{\mkvs}) ; \RW_{\mkvs}?) \cup \WW_{\mkvs})^{+}} \wtOf(\mkvs(\key, m))
         \implies j \in \vi(\key')  
\]
Assume \( j \in \vi_i(\key) \) for some key \(\key \) and index \( i \).
It means the writer of the version is visible by the transaction \( \txid_i\),
\ie \( \wtOf(\mkvs(\key,i)) \in \VIS^{-1}_{\aexec}(\txid_{i}) \).
Let the \( \mkvs = \mkvs_{\cut(\aexec, i-1)} \).
We need to prove the following:
\begin{gather}
    \label{equ:cp-complete-arvis}
    \begin{array}{@{}l@{}}
        \fora{\key, \key', m, j, \txid, \txid'} 
        m \in \vi(\key) 
        \land \wtOf(\mkvs(\key,m)) \in \VIS_\aexec^{-1}(\txid_i) \\
        \quad {} \land \wtOf(\mkvs(\key', j)) \toEDGE{(((\SO \cup \WR_{\mkvs}) ; \RW_{\mkvs}?) \cup \WW_{\mkvs})^{+}} \wtOf(\mkvs(\key, m)) \\
            \qquad \implies \wtOf(\mkvs(\key',j)) \in \VIS_\aexec^{-1}(\txid_i)
    \end{array}
\end{gather}
%Note that \( \txid \in \Set{\wtOf(\mkvs(\key,i))} \cup \func{RW^{-1}}{\mkvs, \key, i} \) 
%means \( \txid \toEDGE{\RW_{\aexec}?} \wtOf(\mkvs(\key,i)) \),
%the formulae \(\left( \begin{array}{@{}l@{}} \txid \in \rsOf(\mkvs(\key',j)) \land \txid' = \wtOf(\mkvs(\key',j)) \end{array} \right) \) 
%means \( \txid \toEDGE{\WR_\aexec} \txid' \),
%and \( \left( \begin{array}{@{}l@{}} \txid = \wtOf(\mkvs(\key',m)) \land \txid' = \wtOf(\mkvs(\key',j)) \land m > j \end{array} \right) \) 
%means \( \txid \toEDGE{\WW_\aexec} \txid' \).
%Given all the correspondence, the \cref{equ:cp-complete-arvis} holds if the following holds:
%\[
    %\begin{rclarray}
        %\begin{array}[t]{@{}l@{}}
            %\fora{\key, \key', i, j, \txid, \txid'} \\
            %\left( \begin{array}{@{}l@{}}
            %i \in \vi(\key) 
            %\land \wtOf(\mkvs(\key,i)) \in \VIS_\aexec^{-1}(\txid_i) \\
            %{} \land \txid' = \wtOf(\mkvs(\key',j))
            %\land \txid \toEDGE{\RW_{\aexec}?} \wtOf(\mkvs(\key,i)) \land {} \\
            %\left(
                %\begin{array}{@{}l @{}}
                    %\txid' \toEDGE{\WR_\aexec ; \SO_\aexec}\txid \lor
                    %\txid' \toEDGE{\SO_\aexec}\txid \lor
                    %\txid' \toEDGE{\WR_\aexec}\txid
                    %\end{array} \right) 
                %\end{array}
                %\right)  \\
                %{} \lor \txid' \toEDGE{\WW_\aexec} \wtOf(\mkvs(\key,i)) \\
                %\qquad \implies \txid' \in \VIS_\aexec^{-1}(\txid_i)
        %\end{array} \\
    %\end{rclarray}
%\]
%Then the above holds, if the following holds:
%\begin{gather}
    %\label{equ:cp-complete-arvis-2}
    %\begin{rclarray}
        %\begin{array}[t]{@{}l@{}}
            %\fora{\key, i, \txid} \\
            %\left( \begin{array}{@{}l@{}}
            %i \in \vi(\key) 
            %\land \wtOf(\mkvs(\key,i)) \in \VIS_\aexec^{-1}(\txid_i) \\
            %{} \land \txid \toEDGE{( (\WR_\aexec; \SO_\aexec) \cup \SO_\aexec \cup \WR_\aexec) ; \RW_{\aexec}? \cup \WW_\aexec} \wtOf(\mkvs(\key,i)) 
                %\end{array}
                %\right)  \\
                %\qquad \implies \txid \in \VIS_\aexec^{-1}(\txid_i)
        %\end{array} \\
    %\end{rclarray}
%\end{gather}
Since \( \WR_\mkvs \), \( \WW_\mkvs \) and \( \RW_\mkvs \) coincide with
\( \WR_\aexec \), \( \WW_\aexec \) and \( \RW_\aexec \) respectively,
and \( \left( (\SO \cup \WR ) ; \RW? \cup \WW \right)^* ; \VIS_\aexec \subseteq \VIS_\aexec \),
It implies \cref{equ:cp-complete-arvis}.
\end{itemize}
