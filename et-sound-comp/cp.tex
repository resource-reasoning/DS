\subsection{Consistency Prefix \( \CP \) }
\label{sec:sound-complete-cp}

Given abstract execution \( \aexec \), we define read-write read-write relation:
\[
    \RW(\aexec,\key) \defeq \Setcon{(\txid, \txid')}{\txid \toEDGE{\AR_\aexec} \txid' \land (\otR,\key, \stub ) \in \txid \land (\otW,\key, \stub ) \in \txid'  } 
\]
It is easy to see \( \RW(\aexec,\key) \)  can be derived from \( \WW(\aexec,\key) \) and \( \WR(\aexec, \key ) \) as the following:
\[
    \RW(\aexec,\key) = \Setcon{(\txid, \txid')}{ \exsts{\txid'' } (\txid'', \txid) \in \WR(\aexec, \key) \land (\txid'', \txid') \in \WW(\aexec, \key) }
\]
Then, the notation \( \RW_\aexec \defeq \bigcup_{\key \in \Keys} \RW(\aexec, \key) \).
Note that for a kv-store \( \mkvs \) such that \( \mkvs = \mkvs_\aexec \),
by the definition of  \(  \mkvs = \mkvs_\aexec \), 
the following holds:
\[
    \RW_\aexec = \Setcon{(\txid, \txid')}{\exsts{\key, i,j } \txid \in \rsOf(\mkvs(\key, i)) \land \txid' = \wtOf(\mkvs(\key, j)) \land i < j}
\]
The \( \RW_\aexec \) also coincides with \( \RW_\Gr \) and \( \RW_\mkvs \).


An abstract execution \( \aexec \) satisfies consistency prefix (\(\CP\)), 
if it satisfies \( \AR_\aexec ; \VIS_\aexec \subseteq \VIS_\aexec \) and \( \SO_\aexec \subseteq \VIS_\aexec \).
Given the definition, there is a corresponding definition on dependency graph by solve the following inequalities:
\[
    \begin{array}{@{}l@{}}
        \WR \subseteq \VIS \\
        \WW \subseteq \AR \\
        \VIS \subseteq \AR \\
        \VIS ; \RW \subseteq \AR \\
        \AR ; \AR \subseteq \AR  \\
        \SO \subseteq \VIS \\
        \AR ; \VIS \subseteq \VIS
    \end{array}
\]
By solving the inequalities the visibility and arbitration relations are:
\begin{align*}
    \AR  & \defeq \left( (\SO \cup \WR ) ; \RW\rflx \cup \WW \cup R \right)^+ \\
    \VIS & \defeq \left( (\SO \cup \WR ) ; \RW\rflx \cup \WW \cup R \right)^* ; (\SO \cup \WR )
\end{align*}
for some relation \( R \subseteq \AR \).
When \( R = \emptyset \), it is the smallest solution therefore the minimum visibility required.

\sx{A bit verbal}
\begin{lemma}
    \label{lem:cp-eauiv-spec}
    For any abstract execution \( \aexec \),
    if it satisfies 
    \[
        \left( (\SO \cup \WR ) ; \RW\rflx \cup \WW \right)^* ; \VIS_\aexec \subseteq \VIS_\aexec 
        \qquad \SO_\aexec \subseteq \VIS_\aexec
    \]
    then there exists a new \( \aexec' \) such that \( \txidset_\aexec = \txidset_{\aexec'} \), 
    under last-write-win \( \TtoOp{T}_{\aexec}(\txid) = \TtoOp{T}_{\aexec'}(\txid) \) for all transactions \( \txid \),
    and the relations satisfy the following:
    \[ 
        \AR_{\aexec'} ; \VIS_{\aexec'} \subseteq \VIS_{\aexec'}  \qquad \SO_{\aexec'} \subseteq \VIS_{\aexec'}
    \]
    and vice versa.
\end{lemma}
\begin{proof}
Assume abstract execution \( \aexec' \) that satisfies \( \AR_{\aexec'} ; \VIS_{\aexec'} \subseteq \VIS_{\aexec'} \)
and  \( \SO_{\aexec'} \subseteq \VIS_{\aexec'} \).
We already show that:
\begin{align*}
    \AR_{\aexec'} & = \left( (\SO_\aexec \cup \WR_\aexec ) ; \RW_\aexec\rflx \cup \WW_\aexec \cup R \right)^+ \\
    \VIS_{\aexec'} & = \left( (\SO_\aexec \cup \WR_\aexec ) ; \RW_\aexec\rflx \cup \WW_\aexec \cup R \right)^* ; (\SO_\aexec \cup \WR_\aexec )
\end{align*}
for some relation \( R \subseteq \AR_{\aexec'} \).
If we take \( R  = \emptyset \), we have the proof for:
\[
        \SO \subseteq \VIS_\aexec \qquad 
        \left( (\SO_\aexec \cup \WR_\aexec ) ; \RW_\aexec\rflx \cup \WW_\aexec \right)^* ; \VIS_\aexec \subseteq \VIS_\aexec
\]
For another way, we pick the \( R \) that extends
\( \left( (\SO_\aexec \cup \WR_\aexec ) ; \RW_\aexec\rflx \cup \WW_\aexec \cup R \right)^+ \) 
to a total order.
\end{proof}

By \cref{lem:cp-eauiv-spec} to prove soundness and completeness of \( \ET_\CP \), it is sufficient to use the definition:
\[
    (\RP_{\LWW}, \Set{\lambda \aexec. \left( (\SO \cup \WR ) ; \RW\rflx \cup \WW \right)^* ; \VIS_\aexec, \lambda \aexec \ldotp \SO_\aexec }) 
\]

For the soundness, we pick the invariant as the following:
\begin{align*}
    I_1(\aexec, \cl) & = \left( \bigcup_{\Setcon{\txid_{\cl}^{i} \in \txidset_{\aexec} }{ i \in \Nat }} \VIS_{\aexec}^{-1}(\txid^i_\cl) \right) \setminus \txidset_\rd \\
    I_2(\aexec, \cl) & = \left( \bigcup_{\Setcon{\txid_{\cl}^{i} \in \txidset_{\aexec} }{ i \in \Nat }} (\SO_{\aexec}^{-1})\rflx(\txid^i_\cl) \right) \setminus \txidset_\rd
\end{align*}
where \( \txidset_\rd \) is all the read-only transactions included in both 
\( \left( \bigcup_{\Setcon{\txid_{\cl}^{i} \in \txidset_{\aexec} }{ i \in \Nat }} \VIS_{\aexec}^{-1}(\txid^i_\cl) \right)\) 
and \( \left( \bigcup_{\Setcon{\txid_{\cl}^{i} \in \txidset_{\aexec} }{ i \in \Nat }} (\SO_{\aexec}^{-1})\rflx(\txid^i_\cl) \right) \).
Assume a key-value store $\mkvs$, an initial and a final view $\vi, \vi'$  a fingerprint $\fp$ 
such that $\ET_{\CP} \vdash (\mkvs, \vi) \csat \fp: ( \mkvs',\vi')$. 
Also choose an arbitrary $\cl$, a transaction identifier $\txid_\cl^n \in \nextTxid(\mkvs, \cl)$, 
and an abstract execution $\aexec$ such that $\mkvs_{\aexec} = \mkvs$ and 
\( I_1(\aexec, \cl) \cup I_2(\aexec, \cl) \subseteq \Tx(\mkvs, \vi) \).
Let a new abstract execution \( \aexec' = \extend(\aexec, \txid_\cl^n, \fp, \Tx(\mkvs, \vi) \cup \txidset_\rd) \).
We are about to prove that there exists an extra set of read-only transaction \( \txidset'_\rd \) such that:
\begin{gather}
    \fora{\txid} (\txid, \txid_\cl^n) \in \SO_{\aexec'} \implies \txid \in \Tx(\mkvs, \vi) \cup \txidset_\rd \cup \txidset'_\rd \label{equ:cp-sound-update-so}\\
    \begin{array}{l}
    \fora{\txid} (\txid, \txid_\cl^n) \in \left( (\SO_{\aexec'} \cup \WR_{\aexec'} ) ; \RW_{\aexec'}\rflx \cup \WW_{\aexec'} \right)^* ; \VIS_{\aexec'} 
    \implies \txid \in \Tx(\mkvs, \vi) \cup \txidset_\rd \cup \txidset'_\rd 
    \end{array}
    \label{equ:cp-sound-update-arvis}\\
    I_1(\aexec',\cl) \cup I_2(\aexec',\cl) \subseteq \Tx(\mkvs_{\aexec'}, \vi') \label{equ:cp-sound-inv} 
\end{gather}
\begin{itemize}
\item the invariant \( I_2 \) implies the \cref{equ:cp-sound-update-so} where the proof is the same as \( \RYW \) in \cref{sec:sound-complete-ryw}.

\item For \cref{equ:cp-sound-update-arvis}, it is sufficient to prove one step inclusion, \ie
\[
    \begin{array}{l}
    \fora{\txid} (\txid, \txid_\cl^n) \in \left( (\SO_{\aexec'} \cup \WR_{\aexec'} ) ; \RW_{\aexec'}\rflx \cup \WW_{\aexec'} \right) ; \VIS_{\aexec'} 
    \implies \txid \in \Tx(\mkvs, \vi) \cup \txidset_\rd \cup \txidset'_\rd 
\end{array}
\]
To prove above, let \( \txidset'_\rd \) initially be empty set.
We will add more read-only transactions until it satisfies \cref{equ:cp-sound-update-arvis}.
Assume a transaction \( \txid \) such that 
\( (\txid, \txid_\cl^n) \in \left( (\SO_{\aexec'} \cup \WR_{\aexec'} ) ; \RW_{\aexec'}\rflx \cup \WW_{\aexec'} \right) ; \VIS_{\aexec'}\).
There exists a transaction \( \txid' \) such that \( \txid \toEDGE{(\SO_{\aexec'} \cup \WR_{\aexec'} ) ; \RW_{\aexec'}\rflx \cup \WW_{\aexec'}} \txid' \toEDGE{\VIS_{\aexec'}}  \txid_\cl^n \).
It follows \( \txid'  \in \Tx(\mkvs, \vi) \cup \txidset_\rd \cup \txidset'_\rd  \).
Note that \( \txid \) and \( \txid' \) must exist in the abstract execution \( \aexec \) before update.
There are two cases: \( \txid' \) writes to at least a key; or \( \txid' \) is a read-only transaction.
\begin{itemize}
    \item
    If \( \txid' \) writes to at least a key, then \( \txid' \in \Tx(\mkvs, \vi)\).
    Now we perform case analysis if \( \txid \) is a read-only transaction.
    \begin{itemize}
        \item if \( \txid \) has write, we prove \( \txid \in \Tx(\mkvs, \vi)\).
        Recall the \( \dagger \) is defined as the following:
        \begin{equation}
        \label{equ:cp-dagger}
        \dagger  \equiv 
            \fora{\key, \key', i, j}
                i \in \vi(\key)  \wedge \wtOf(\mkvs(\key', j)) \toEDGE{(((\SO \cup \WR_{\mkvs}) ; \RW_{\mkvs}\rflx) \cup \WW_{\mkvs})^{+}} \wtOf(\mkvs(\key, i))
            \implies j \in \vi(\key')  
        \end{equation}
        Since \( \WR_\mkvs \), \( \WW_\mkvs \) and \( \RW_\mkvs \) coincide with
        \( \WR_\aexec \), \( \WW_\aexec \) and \( \RW_\aexec \) respectively.
        Also because \( \txid \) write to at least one key,
        it is easy to see there exists some version \( \key'',m\) such that 
        \( \txid = \wtOf(\mkvs(\key'',m))\) and \( m \in \vi(\key'')\).
        By definition of \( \Tx \), it follows \( \txid \in \Tx(\mkvs, \vi) \).
        \item if \( \txid \) is a read-only transaction, we add it into \( \txidset'_\rd \).
    \end{itemize}
    \item 
    if \( \txid' \) is a read-only transaction, then either \( \txid' \in \txidset_\rd \) or \( \txid' \in \txidset'_\rd \).
    More specifically we have three cases: \textbf{(i)} \( \txid' \in \bigcup_{\Setcon{\txid_{\cl}^{i} \in \txidset_{\aexec} }{ i \in \Nat }} \VIS_{\aexec}^{-1}(\txid^i_\cl) \), \textbf{(ii)} \( \txid' \in \bigcup_{\Setcon{\txid_{\cl}^{i} \in \txidset_{\aexec} }{ i \in \Nat }} (\SO_{\aexec}^{-1})\rflx(\txid^i_\cl) \) or \textbf{(iii)} \( \txid' \in \txidset'_\rd\).
    \begin{itemize}
        \item
            Assume \( \txid' \in \bigcup_{\Setcon{\txid_{\cl}^{i} \in \txidset_{\aexec} }{ i \in \Nat }} \VIS_{\aexec}^{-1}(\txid^i_\cl) \).
        It means \( \txid' \) is visible for some previous transaction \( \txid_\cl^m \) (\( m < n \)) from the same client \( cl \), 
        \ie 
        \[ 
            \txid \toEDGE{(\SO_{\aexec'} \cup \WR_{\aexec'} ) ; \RW_{\aexec'}\rflx \cup \WW_{\aexec'}} \txid' \toEDGE{\VIS_{\aexec'}}  \txid_\cl^m 
        \]
        Note that all the edges before \( \txid_\cl^m \) must exist in \( \aexec \).
        Since \( \aexec \) satisfies the \( \left( (\SO \cup \WR ) ; \RW\rflx \cup \WW \right)^* ; \VIS_\aexec \subseteq \VIS_\aexec \),
        we have \( \txid \toEDGE{\VIS_{\aexec'}} \txid_\cl^m \) and then \( \txid \in \bigcup_{\Setcon{\txid_{\cl}^{i} \in \txidset_{\aexec} }{ i \in \Nat }} \VIS_{\aexec}^{-1}(\txid^i_\cl)\).
        By the invariant \( I_1 \), it means \( \txid \in \Tx(\mkvs, \vi) \cup \txidset_\rd \).
    \item \( \txid' \in \bigcup_{\Setcon{\txid_{\cl}^{i} \in \txidset_{\aexec} }{ i \in \Nat }} \SO_{\aexec}^{-1}(\txid^i_\cl) \).
    Since \( \txid' \) is a read-only transaction, 
    the edges can be simplified to \( \txid \toEDGE{(\SO_{\aexec'} \cup \WR_{\aexec'} )} \txid' \toEDGE{\SO_{\aexec'}}  \txid_\cl^n \).
    Given that \( \SO \) is transitive, then  either \( \txid \toEDGE{\SO_{\aexec'}} \txid_\cl^n \) or \( \txid \toEDGE{\WR_{\aexec'} } \txid' \toEDGE{\SO_{\aexec'}}  \txid_\cl^n \).
    \begin{itemize}
        \item \( \txid \toEDGE{\SO_{\aexec'}} \txid_\cl^n \).
            It follows \( \txid \in \bigcup_{\Setcon{\txid_{\cl}^{i} \in \txidset_{\aexec} }{ i \in \Nat }} \SO_{\aexec}^{-1}(\txid^i_\cl) = \Tx(\mkvs, \vi) \cup \txidset_\rd \).
        \item \( \txid \toEDGE{\WR_{\aexec'} } \txid' \toEDGE{\SO_{\aexec'}}  \txid_\cl^n \).
            The \( \WR \) edge must exists in \( \aexec \).
            Because \( \WR_\aexec \subseteq \VIS_\aexec \) then  \( \txid \toEDGE{\VIS_{\aexec} } \txid' \toEDGE{\SO_{\aexec'}}  \txid_\cl^n  \).
            It means 
            \[ 
                \txid \in \bigcup_{\Setcon{\txid_{\cl}^{i} \in \txidset_{\aexec} }{ i \in \Nat }} \VIS_{\aexec}^{-1}(\txid^i_\cl) = \Tx(\mkvs, \vi) \cup \txidset_\rd 
            \]
    \end{itemize}
    \item 
    Last, \( \txid' \in \txidset'_\rd \).
    Since \( \txidset'_\rd \) initially is empty set, there exists another write transaction \( \txid'' \) such that:
    \[
        \txid \toEDGE{(\SO_{\aexec'} \cup \WR_{\aexec'} ) ; \RW_{\aexec'}\rflx \cup \WW_{\aexec'}} \txid' \toEDGE{(\SO_{\aexec'} \cup \WR_{\aexec'} ) ; \RW_{\aexec'}\rflx \cup \WW_{\aexec'}} \txid'' \toEDGE{\VIS_{\aexec'}}  \txid_\cl^n
    \]
        If \( \txid \) has write, by \cref{equ:cp-dagger} then \( \txid \in \Tx(\mkvs,\vi) \).
        Otherwise if \( \txid \) is a read only transaction, we add it into \( \txidset'_\rd \).
    \end{itemize}
\end{itemize}

\item Since \( \CP \) satisfies \( \RYW \) and \( \MR \), thus invariants \( I_1 \) and  \( I_2 \) are preserved after update.

\end{itemize}

    
For completeness, we prove the three parts of the execution test separately.
\begin{itemize}
\item Since \( \SO_\aexec \subseteq \VIS_\aexec  \), the prove for \( \ET_\RYW \) is the as in \cref{sec:sound-complete-mr}.
\item For any \( \VIS_\aexec \)  satisfies the constraint for \( \CP \), by \cref{lem:cp-eauiv-spec} it satisfies that 
\[
    \VIS \defeq \left( (\SO \cup \WR ) ; \RW\rflx \cup \WW \cup R \right)^* ; (\SO \cup \WR )
\]
for some relation \( R \).
It means \( \VIS_\aexec ; \SO_\aexec \subseteq \VIS_\aexec \).
Therefore it is complete with respect to \( \ET_\MR \).

\item Let consider the \( \dagger \).
Assume i-\emph{th} transaction \( \txid_i \) in the arbitrary order,
and let view \( \vi_{i} = \getView(\aexec, \VIS^{-1}_{\aexec}(\txid_{i}) ) \).
We also pick any final view such that \( \vi'_{i} \subseteq \getView(\aexec, (\AR^{-1}_{\aexec})\rflx(\txid_{i}) ) \).
Note that there is nothing to prove for \( \vi'_i \) since the \( \dagger \) does not constrain the \( \vi'_i \).
Recall the \( \dagger \):
\[
\dagger  \equiv 
        \fora{\key, \key', m, j}
             m \in \vi(\key)  \wedge \wtOf(\mkvs(\key', j)) \toEDGE{(((\SO \cup \WR_{\mkvs}) ; \RW_{\mkvs}\rflx) \cup \WW_{\mkvs})^{+}} \wtOf(\mkvs(\key, m))
         \implies j \in \vi(\key')  
\]
Assume \( j \in \vi_i(\key) \) for some key \(\key \) and index \( i \).
It means the writer of the version is visible by the transaction \( \txid_i\),
\ie \( \wtOf(\mkvs(\key,i)) \in \VIS^{-1}_{\aexec}(\txid_{i}) \).
Let the \( \mkvs = \mkvs_{\cut(\aexec, i-1)} \).
We need to prove the following:
\begin{gather}
    \label{equ:cp-complete-arvis}
    \begin{array}{@{}l@{}}
        \fora{\key, \key', m, j, \txid, \txid'} 
        m \in \vi(\key) 
        \land \wtOf(\mkvs(\key,m)) \in \VIS_\aexec^{-1}(\txid_i) \\
        \quad {} \land \wtOf(\mkvs(\key', j)) \toEDGE{(((\SO \cup \WR_{\mkvs}) ; \RW_{\mkvs}\rflx) \cup \WW_{\mkvs})^{+}} \wtOf(\mkvs(\key, m)) 
            \implies \wtOf(\mkvs(\key',j)) \in \VIS_\aexec^{-1}(\txid_i)
    \end{array}
\end{gather}
Since \( \WR_\mkvs \), \( \WW_\mkvs \) and \( \RW_\mkvs \) coincide with
\( \WR_\aexec \), \( \WW_\aexec \) and \( \RW_\aexec \) respectively,
and \( \left( (\SO \cup \WR ) ; \RW\rflx \cup \WW \right)^* ; \VIS_\aexec \subseteq \VIS_\aexec \),
It implies \cref{equ:cp-complete-arvis}.
\end{itemize}
