\section{Introduction}
Transactions are the \emph{de facto} synchronisation mechanism in modern distributed databases.
To achieve scalability and performance, distributed databases  
often use weak transactional consistency guarantees. 
%
%Modern distributed systems often rely on databases that achieve
%scalability and performance by weakening the consistency guarantees of
%distributed transaction processing. 
%
Much work has been done to formalise the semantics of such consistency guarantees, both
declaratively and operationally.
On the declarative side, several \emph{general} formalisms have been proposed, 
such as dependency graphs~\cite{adya} and abstract executions~\cite{framework-concur}, to provide a unified
semantics for formulating different consistency models.  
On the operational side, the semantics of \emph{specific} consistency models have
been captured using reference implementations~\cite{si,PSI,PSI-RA}. 
However, unlike declarative approaches, there has been
little work on \emph{general} operational semantics for describing a range
of consistency models, and no work on a general operational semantics
in which to both verify protocols of distributed databases and 
enable program analysis for clients.

As discussed in \cref{sec:conclusions}, there are several formalisms for a general operational semantics~\cite{sureshConcur,alonetogether,seebelieve}. 
\citeauthor{alonetogether} \cite{alonetogether} propose an operational
semantics over a global, centralised store  for reasoning about clients using a program logic. 
However, although they can model several isolation levels, they cannot
capture the well-known consistency model called 
parallel snapshot isolation (\PSI). 
Moreover, they do not establish the equivalence of their definitions
of consistency model
with existing declarative definitions in the literature. 
\citeauthor{sureshConcur} \cite{sureshConcur} propose an operational semantics over declarative abstract executions, rather than a concrete centralised store. This semantics captures weaker consistency models
such as \(\PSI\) and has been used to prove robustness results against
a given consistency model.  
However, this semantics cannot model client sessions.
Finally, \citeauthor{seebelieve} \cite{seebelieve} provide a trace semantics over a global
centralised store,  not an operational semantics. 
They focus on proving implementations correct. They do not consider program analysis for clients;
indeed we believe it would be difficult  given their choice to
keep track of the entire system.
%See related work~\cref{sec:conclusions} for further discussion. 




\ac{
\pg{In above, does Nagar et al.  relate their work to the declarative
  definitions?
Does Crooks et al.?}
Nagar et al. use exactly declarative definitions based on abstract executions.
}
\ac{
\pg{In above, can we really make the claim that Crooks et al. cannot
  do prog analysis as  they need to keep track of the total system?
  MAybe for related work?}
Doing program analysis when you track the total order of system changes 
is difficult, that's the reason why I (and also Nagar and the guys above) switch 
to dependency graphs. Suresh in is POPL paper makes the exact claim that 
it's not clear that Crooks. et al can perform program analysis 
}


We introduce a general operational semantics for describing the
user-observable behaviour of distributed {atomic} transactions
(\cref{sec:overview}, \cref{sec:model}). 
Our model comprises a global, centralised
key-value store (kv-store) with {\em multi-versioning},  and
{\em client views}
inspired by the C11 operational semantics
in~\cite{promises}; 
using these mechanisms,
%, which  are explained in detail in \cref{sec:overview}, 
we record all the versions written for each key, and  let clients see only a subset 
of such versions.
%Multi-versioning mandates that we record all versions of each key
%written, together with the meta-data of the transactions that access
%it. This then yields a history of each key, and may be thought as
%projecting the local state of each distributed machine into a global,
%centralised state. 
%Through multi-versioning we record all versions of each key, yielding a complete history for each key.
%Through client views we allow different clients to observe only a subset of versions in the kv-store, 
%enabling different clients to observe different versions of a key and thus capturing the weak behaviours we seek. 
Our  operational semantics  is parametric in the notion of {\em
  execution test},  determining if a client with a given view is
allowed to commit a transaction. Different execution tests give rise
to different consistency models in our semantics. 
  We  are able to capture  most of the  well-known consistency models in a uniform way (\cref{sec:cm}): e.g.,  causal consistency (\CC), \PSI, snapshot isolation (\SI) and serialisability (\SER). 
We define these models using kv-stores and views, 
provide a correspondence between our kv-stores and dependency graphs, 
and introduce novel proof techniques for demonstrating that our
definitions of consistency models 
are equivalent to existing declarative definitions (\cref{sec:other_formalisms}).
%
\pg{For above, is the following too strong: This connection between consistency
  models defined over an operational semantics based on a global,
  centralised state  and the traditional 
consistency models defined over a declarative semantics has not been
done before.} 
%

We showcase  our semantics by verifying database protocols and
analysing client programs  (\cref{sec:applications}). 
For the former, we show that the COPS protocol of a 
replicated database satisfies our definition of $\CC$ and that the Clock-SI protocol of a partitioned database satisfies our definition of $\SI$.  
For the later, we show the robustness of applications against our consistency models: 
we prove that a transactional library comprising a single counter is robust against $\PSI$; 
and  that the library with multiple counters is robust against $\SI$, but not $\PSI$.  
To our knowledge, our robustness results are the first to take into account client sessions.
Without sessions, multiple counters can be proved to be robust against \(\PSI\) using 
the static analysis check from \cite{giovanni_concur16}. 
We verify protocols and analyse clients in the \emph{same} operational
semantics. 
By contrast, in existing declarative literature these two tasks are carried out in \emph{different} semantics: protocols are verified using abstract executions;
clients are analysed using dependency graphs; and equivalence results are used to move between the two.



%\ac{\pg{In above, has someone shown multiple counters are robust against
  %PSI, citation?}
%No, but it is immediate to apply the technique from Giovanni and Alexey's paper 
%\cite{giovanni_concur16}
%to get the robustness of multiple counters under PSI.}

%\cite{...nowwhatshouldthecitationsbeev_transactions,framework-concur,consistency3d,seebelieve,laws,alonetogether}. 


%\mypar{Outline}
%The remainder of this article is organised as follows.
%In \cref{sec:overview} we give an intuitive overview of our ideas. 
%In \cref{sec:model} we present our general operational semantics. 
%In \cref{sec:cm} we show how we encode consistency models in our semantics.
%In \cref{sec:other_formalisms} we relate our formalism to existing declarative formalisms.
%In \cref{sec:applications} we showcase the applications of our semantics.  
%In \cref{sec:conclusions} we discuss related work and conclude. 

