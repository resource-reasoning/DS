\section{Introduction}
\label{sec:intro}

Transactions are the \emph{de facto} synchronisation mechanism in
modern distributed databases. To achieve scalability and performance, distributed databases  
often use weak transactional consistency guarantees. 
These weak  guarantees
pose several challenges: the formalisation of  client-observable
behaviour; and the verification of database protocols and client applications.
Much work has been done to formalise the semantics of such consistency guarantees, both
declaratively and operationally.
On the declarative side, several {general} formalisms have been proposed, 
such as dependency graphs~\cite{adya} and abstract executions~\cite{ev_transactions}, to provide a unified
semantics for formulating different consistency models.  
On the operational side, the semantics of \emph{specific} consistency models have
been captured using reference implementations~\cite{si,PSI,PSI-RA}. 
However, unlike declarative approaches, there has been
little work on {general} operational semantics for describing a range
of consistency models.






%There has been some work on general operational semantics, summarised
We summarise briefly the existing work on general operational semantics;
%here and 
further discussion can be found in \cref{sec:conclusions}.
%~\cite{sureshConcur,alonetogether,seebelieve}. 
%\citeauthor{alonetogether} 
\citet{alonetogether} propose an operational
semantics for SQL transaction programs under the consistency models
given by the standard ANSI/SQL isolation levels~\cite{si}. Their
operational semantics  
accesses a global, centralised store,  and is used to develop 
a program logic  and prototype tool for reasoning about client
programs. They capture consistency models such as snapshot
isolation (\SI)~\cite{si}, but not  weaker ones 
 such as parallel snapshot isolation (\PSI)~\cite{PSI} and causal consistency (\CC)~\cite{cops} 
 which are important 
for distributed databases. 
Following this work, \citet{sureshConcur} propose an operational semantics over abstract
execution graphs, rather than   a concrete centralised store, in order to
prove the robustness of applications against
a given consistency model. They are able to 
capture weaker consistency models
such as \(\PSI\) and \(\CC\) . However, although they focus on consistency models with snapshot 
property\footnote{\emph{Snapshot property}, also known as \emph{atomic visibility},
means that a transaction reads from an atomic snapshot of the database, and commits atomically.},
%\footnote{\emph{Atomic visibility} means that a transaction 
%observes either all or none the updates of another transaction.},
their semantics allows for the fine-grained interleaving of operations in different
transactions. We believe that this results  in an unnecessarily complicated semantics.
%However, this semantics cannot model client sessions.
\citet{seebelieve} provide a trace semantics over a global
centralised store, where the behaviour of clients is formalised by the   
observations they make on the totally-ordered history of states. 
They 
%show  that implementations are correct  with respect to the
%appropriate 
%consistency model, and 
use their semantics to demonstrate  the equivalence of several
implementation-specific definitions of
consistency model. 
%but it does little towards proving the correctness of protocols employed by distributed databases. 
However, the usefulness  of their approach for analysing client programs is not clear, 
%program analysis for clients; in particular, we believe that in their framework the latter task would be 
%difficult,
since observations made by their clients  involve information that is not generally 
available to real-world clients,  such as the total order in which transactions commit.
%or to p
%They focus on proving implementations correct. They do not consider program analysis for clients;
%indeed we believe it would be difficult  given their choice to
%keep track of the entire system.



We introduce an interleaving operational semantics for describing the
client-observable behaviour of atomic transactions on distributed
key-value stores (\cref{sec:overview}, \cref{sec:model}),
successfully abstracting from the internal details of protocols of
geo-replicated and partitioned databases.  In our semantics,
transactions execute atomically, preventing fine-grained interleaving
of the operations they perform.
Our semantics comprises a global, centralised key-value store (kv-store)
with {\em multi-versioning}, which records all the versions of a key,
and partial {\em client views}, which let clients see only a subset of
the versions. Our approach is partly  inspired by the views in the  C11 operational semantics
in~\cite{promises}. 
Our operational semantics is parametric in the notion of \emph{execution test},
which determines if a client with a given view is allowed to commit a transaction.
Just as with standard operational semantics, the  next transaction
step just depends on  the current kv-store and client view. 
Our execution tests resemble  an approach taken  in~\cite{seebelieve}, 
except that the next step requires an analysis of the whole trace. 
%   if a client with a given view is
%allowed to commit a transaction. Unlike \cite{seebelieve},
%our execution tests rely on a partial client view rather than the
%client requiring complete 
%knowledge of the state history. 
%Different execution tests give rise
%to different consistency models in our semantics. In contrast with \cite{seebelieve}, 
%we restrict observations of clients  to the current state of the system: this leads to 
%execution tests being a more faithful abstraction of the behaviour of real distributed databases protocols.
We  capture  most of the well-known consistency models in
a uniform way (\cref{sec:cm}): e.g,  \CC, \PSI, 
\SI\ and serialisability (\SER).
We also identify 
a new consistency model  that sits between \PSI\; and \SI\; and retains good properties of both.
We call this new consistency model \emph{weak snapshot isolation} (\WSI).
Since we focus on
snapshot property,  we are not able to capture popular 
  consistency models such as \emph{read committed}. 
Because our focus is on protocols and applications employed  by distributed databases, 
  most of which  guarantee snapshot property, we do not find this constraint to be a severe
  limitation.
%We define these models using kv-stores and views, 
%provide a correspondence between our kv-stores and dependency graphs, 
%We introduce novel proof techniques for demonstrating that our
%definitions of consistency models 
%are equivalent to existing declarative definitions (\cref{sec:other_formalisms}).
%

We prove that our operational definitions of consistency models for
kv-stores are equivalent to the well-known declarative definitions
of consistency model for execution graphs.  Such results have not
been given in \cite{alonetogether}, but have been given in
\cite{seebelieve}.  We provide a general proof technique which
captures the correspondence between our execution tests and the
axiomatic specifications of consistency models for abstract
executions (\cref{sec:other_formalisms} and \cref{sec:et-sound-complete-constructor}).  Using this
technique, we
%are able to 
prove 
that our  definitions of consistency model for kv-stores are equivalent to the  declarative definitions of
consistency model  for
abstract executions~\cite{framework-concur}, and hence for  dependency
graphs~\cite{adya,laws}. 



We explore two immediate applications of our operational semantics:
the establishment of invariant properties such as robustness for  simple client applications; and the correctness of
specific distributed protocols. By contrast, these tasks  tend to be carried out in
{different} declarative formalisms:  clients are analysed using dependency
graphs~\cite{fekete-tods,SIanalysis,giovanni_concur16,psi-chopping,sureshConcur};
protocols are verified using
abstract execution graphs~\cite{repldatatypes,framework-concur}; and equivalence results are used to move between
the two~\cite{laws}. 
We prove the robustness of a single
counter against \PSI\ and the robustness of multiple counters against
our new model \WSI\ (\cref{sec:applications}).
\citet{bank-example-wsi} present a banking example that is robust against \( \SI \).
We show that it is also robust against \( \WSI \) (\cref{sec:applications}).
%
%For the former, we show that the COPS protocol of a 
%replicated database satisfies our definition of $\CC$ and that the Clock-SI protocol of a partitioned database satisfies our definition of $\SI$
%For the latter, we show the robustness of applications against our consistency models: 
%we prove that a transactional library comprising a single counter is robust against $\PSI$; 
%and  that the library with multiple counters is robust against $\SI$,
%but not $\PSI$. 
To our knowledge, our robustness results are the first to take into
account client sessions. With sessions, we demonstrate that multiple
counters are not robust against \(\PSI\).  Interestingly, without
sessions, it can be shown that multiple counters are robust against
\(\PSI\) using static-analysis techniques~\cite{giovanni_concur16};
these techniques are known not to be applicable to sessions.  We also
establish the correctness of two database protocols against their
consistency models, demonstrating that they can be accurately
expressed in our centralised semantics: the COPS protocol for the
fully replicated kv-stores~\cite{cops} which satisfies \CC\ 
(\cref{sec:applications}); and the Clock-SI protocol for partitioned
kv-stores~\cite{clocksi} which satisfies $\SI$ (\cref{app:implementation-verification}). 

\sx{The reviewer from OOPSLA confused about client sessions here.
    Multi-counters are actually robust against \( \WSI \).
    It immediately gives some idea why \( \WSI \) is a interesting consistency model.
}
