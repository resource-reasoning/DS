jjj\section{Introduction}
Transactions are the \emph{de facto} synchronisation mechanism in modern distributed databases.
To achieve scalability and performance, distributed databases  
often use weak transactional consistency guarantees. 
Much work has been done to formalise the semantics of such consistency guarantees, both
declaratively and operationally.
On the declarative side, several \emph{general} formalisms have been proposed, 
such as dependency graphs~\cite{adya} and abstract executions~\cite{framework-concur}, to provide a unified
semantics for formulating different consistency models.  
On the operational side, the semantics of \emph{specific} consistency models have
been captured using reference implementations~\cite{si,PSI,PSI-RA}. 
However, unlike declarative approaches, there has been
little work on \emph{general} operational semantics for describing a range
of consistency models, and no work on a general operational semantics
in which to both verify protocols of distributed databases and 
enable program analysis for clients.

As discussed in \cref{sec:conclusions}, there are several formalisms for a general operational semantics~\cite{sureshConcur,alonetogether,seebelieve}. 
\citeauthor{alonetogether} \cite{alonetogether} propose an operational
semantics over a global, centralised store  for reasoning about clients using a program logic. 
However, although they can model several isolation levels, they cannot
capture the well-known consistency model called 
parallel snapshot isolation (\PSI). 
Moreover, they do not establish the equivalence of their definitions
of consistency model
with existing declarative definitions in the literature. 
\citeauthor{sureshConcur} \cite{sureshConcur} propose an operational semantics over declarative abstract executions, rather than a concrete centralised store. This semantics captures weaker consistency models
such as \(\PSI\) and has been used to prove robustness results against
a given consistency model.  
However, this semantics cannot model client sessions.
Finally, \citeauthor{seebelieve} \cite{seebelieve} provide a trace semantics over a global
centralised store,  not an operational semantics. 
They focus on proving implementations correct. They do not consider program analysis for clients;
indeed we believe it would be difficult  given their choice to
keep track of the entire system.

We introduce a general operational semantics for describing the
user-observable behaviour of distributed {atomic} transactions
(\cref{sec:overview}, \cref{sec:model}). 
Our model comprises a global, centralised
key-value store (kv-store) with {\em multi-versioning},  and
{\em client views}
inspired by the C11 operational semantics
in~\cite{promises}; 
using these mechanisms,
we record all the versions written for each key, and  let clients see only a subset 
of such versions.
Our  operational semantics  is parametric in the notion of {\em
  execution test},  determining if a client with a given view is
allowed to commit a transaction. Different execution tests give rise
to different consistency models in our semantics. 
  We  are able to capture  most of the  well-known consistency models in a uniform way (\cref{sec:cm}): e.g.,  causal consistency (\CC), \PSI, snapshot isolation (\SI) and serialisability (\SER). 
We define these models using kv-stores and views, 
provide a correspondence between our kv-stores and dependency graphs, 
and introduce novel proof techniques for demonstrating that our
definitions of consistency models 
are equivalent to existing declarative definitions (\cref{sec:other_formalisms}).
%

We showcase  our semantics by verifying database protocols and
analysing client programs  (\cref{sec:applications}). 
For the former, we show that the COPS protocol of a 
replicated database satisfies our definition of $\CC$ and that the Clock-SI protocol of a partitioned database satisfies our definition of $\SI$.  
For the later, we show the robustness of applications against our consistency models: 
we prove that a transactional library comprising a single counter is robust against $\PSI$; 
and  that the library with multiple counters is robust against $\SI$, but not $\PSI$.  
To our knowledge, our robustness results are the first to take into account client sessions.
Without sessions, multiple counters can be proved to be robust against \(\PSI\) using 
the static analysis check from \cite{giovanni_concur16}. 
We verify protocols and analyse clients in the \emph{same} operational
semantics. 
By contrast, in existing declarative literature these two tasks are carried out in \emph{different} semantics: protocols are verified using abstract executions;
clients are analysed using dependency graphs; and equivalence results are used to move between the two.

%\mypar{Outline}
%The remainder of this article is organised as follows.
%In \cref{sec:overview} we give an intuitive overview of our ideas. 
%In \cref{sec:model} we present our general operational semantics. 
%In \cref{sec:cm} we show how we encode consistency models in our semantics.
%In \cref{sec:other_formalisms} we relate our formalism to existing declarative formalisms.
%In \cref{sec:applications} we showcase the applications of our semantics.  
%In \cref{sec:conclusions} we discuss related work and conclude. 

