\section{Introduction}
\label{sec:intro}

Transactions are the \emph{de facto} synchronisation mechanism in
modern distributed databases. To achieve scalability and performance, distributed databases  
often use weak transactional consistency guarantees. 
These weak guarantees
pose several challenges: the formalisation of  client-observable
behaviour; and the verification of database protocols and client applications.
Much work has been done to formalise the semantics of such consistency guarantees, both
declaratively and operationally.
On the declarative side, several {general} formalisms have been proposed, 
such as dependency graphs~\cite{adya} and abstract executions~\cite{ev_transactions}, to provide a unified
semantics for formulating different consistency models.  
On the operational side, the semantics of \emph{specific} consistency models have
been captured using reference implementations~\cite{si,PSI,PSI-RA}. 
However, unlike declarative approaches, there has been
little work on {general} operational semantics for describing a range
of consistency models.


We summarise briefly the existing work on general operational semantics;
further discussion can be found in \cref{sec:conclusions}.
\citet{alonetogether} propose an operational
semantics for SQL transaction programs under the consistency models
given by the standard ANSI/SQL isolation levels~\cite{si}. Their
operational semantics  
accesses a global, centralised store,  and is used to develop 
a program logic  and prototype tool for reasoning about client
programs. They capture consistency models such as snapshot
isolation (\(\SI\))~\cite{si}, but not  weaker ones 
 such as parallel snapshot isolation (\(\PSI\))~\cite{PSI} and causal consistency (\(\CC\))~\cite{cops} 
 which are important 
for distributed databases. 
Following this work, \citet{sureshConcur} propose an operational semantics over abstract
execution graphs, rather than   a concrete centralised store, in order to
prove the robustness of applications against
a given consistency model. They are able to 
capture weaker consistency models
such as \(\PSI\) and \(\CC\) . However, although they focus on consistency models with snapshot 
property\footnote{\emph{Snapshot property}, also known as \emph{atomic visibility},
means that a transaction reads from an atomic snapshot of the database, and commits atomically.},
their semantics allows for the fine-grained interleaving of operations in different
transactions. We believe that this results  in an unnecessarily complicated semantics.
\citet{seebelieve} provide a trace semantics over a global
centralised store, where the behaviour of clients is formalised by the   
observations they make on the totally-ordered history of states. 
They 
use their semantics to demonstrate  the equivalence of several
implementation-specific definitions of
consistency model. 
However, the usefulness  of their approach for analysing client programs is not clear, 
since observations made by their clients  involve information that is not generally 
available to real-world clients,  such as the total order in which transactions commit.


-------

If run out of spaces, we can say something:

there have been several operational semantics including graph-based, state-based and log-based semantics,
yet those semantics focus on one of the two challenges.

-------



We introduce an interleaving operational semantics for describing the
client-observable behaviour of atomic transactions on distributed
key-value stores (\cref{sec:overview}, \cref{sec:model}),
successfully abstracting from the internal details of protocols of distributed databases. 
Our semantics, we believe, is suitable for verifying implementations and reasoning about client programs.
In our semantics, transactions execute atomically, preventing fine-grained interleaving
of the operations they perform.
Our semantics comprises a global, centralised key-value store (kv-store)
with {\em multi-versioning}, which records all the versions of a key,
and partial {\em client views}, which let clients see only a subset of
the versions. Our approach is partly  inspired by the views in the  C11 operational semantics
in~\cite{promises}. 
Our operational semantics is parametric in the notion of \emph{execution test},
which determines if a client with a given view is allowed to commit a transaction.
Just as with standard operational semantics, the  next transaction
step just depends on  the current kv-store and client view. 
Our execution tests resemble  an approach taken  in~\cite{seebelieve}, 
except that the next step requires an analysis of the whole trace. 
We  capture  most of the well-known consistency models in
a uniform way (\cref{sec:cm}): e.g,  \( \CC, \PSI, \SI \) and serialisability (\(\SER\)).
We also identify 
a new consistency model that sits between \(\PSI\) and \(\SI\) and retains good properties of both.
We call this new consistency model \emph{weak snapshot isolation} (\(\WSI)\).
Since we focus on snapshot property,  we are not able to capture popular 
consistency models such as \emph{read committed}. 
Because our focus is on protocols and applications employed  by distributed databases, 
most of which  guarantee snapshot property, we do not find this constraint to be a severe
limitation.

We explore two immediate applications of our operational semantics:
the establishment of invariant properties such as robustness for  simple client applications; 
and the establishment of invariant properties such as robustness for client applications.
By contrast, these tasks tend to be carried out in {different} declarative formalisms: 
protocols are verified using abstract execution graphs~\cite{repldatatypes,framework-concur}; 
clients are analysed using dependency graphs~\cite{fekete-tods,SIanalysis,giovanni_concur16,psi-chopping,sureshConcur};
and equivalence results are used to move between the two~\cite{laws}. 
We establish the correctness of two database protocols against their
consistency models, demonstrating that they can be accurately
expressed in our centralised semantics: the COPS protocol for the
fully replicated kv-stores~\cite{cops} which satisfies \(\CC\)
(\cref{sec:applications}); and the Clock-SI protocol for partitioned
kv-stores~\cite{clocksi} which satisfies $\SI$ (\cref{app:implementation-verification}). 
We prove the robustness of a single counter against \(\PSI\), and 
the robustness of multiple counters against our new model \(\WSI\) (\cref{sec:applications}) 
and henceforth any stronger models such as \( \SI \).
\citet{bank-example-wsi} present a banking example that is robust against \( \SI \).
We show that it is also robust against \( \WSI \) (\cref{sec:applications}).
To our knowledge, our robustness results are the first to take into account client sessions. 
With sessions, we demonstrate that multiple counters are not robust against \(\PSI\). 
Interestingly, without sessions, it can be shown that multiple counters are robust against
\(\PSI\) using static-analysis techniques~\cite{giovanni_concur16};
these techniques are known not to be applicable to sessions. 

We prove that our operational definitions of consistency models for
kv-stores are equivalent to the well-known declarative definitions
of consistency model for execution graphs.  Such results have not
been given in \cite{alonetogether}, but have been given in
\cite{seebelieve}.  We provide a general proof technique which
captures the correspondence between our execution tests and the
axiomatic specifications of consistency models for abstract
executions (\cref{sec:other_formalisms} and \cref{sec:et-sound-complete-constructor}). 
Using this technique, we prove that 
our definitions of consistency model for kv-stores are equivalent to 
the  declarative definitions of consistency model for
abstract executions~\cite{framework-concur}, and hence for dependency graphs~\cite{adya,laws}. 
