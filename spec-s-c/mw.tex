\subsection{Monotonic Write \( \MW \)}
\label{sec:sound-complete-mw}

The execution test $\ET_\MW$ is sound with respect to the axiomatic specification 
$(\RP_{\LWW}, \Set{\lambda \aexec. \PO_{\aexec} ; \VIS_{\aexec} })$.
We pick the invariant as empty set given the fact of no constraint on the view after update:
\[ 
    I( \aexec, \cl ) = \emptyset 
\]
Assume a key-value store $\hh$, an initial and a final view $\vi, \vi'$  a fingerprint $\opset$ 
such that $\ET_{\MW} \vdash (\hh, \vi) \csat \opset: (\hh',\vi')$. 
Also choose an arbitrary $\cl$, a transaction identifier $\txid \in \nextTxId(\hh, \cl)$, 
and an abstract execution $\aexec$ such that $\hh_{\aexec} = \hh$ and 
\( I(\aexec, \cl) =  \emptyset \subseteq \Tx(\hh, \vi) \).
Let \( \aexec' = \extend(\aexec, \txid, \Tx(\mkvs, \vi) \cup \T_\rd, \f ) \).
Note that since the invariant  is empty set, it remains to prove that there exists a set of read-only transactions \( \T_\rd \) such that:
\[
    \begin{array}{@{}l@{}}
        \fora{ \txid' }  (\txid' ,\txid)  \in \PO_{\aexec'} ; \VIS_{\aexec'}
        \implies \txid' \in \Tx(\mkvs, \vi) \cup \T_\rd
    \end{array}
\]
Initially we take \( \T_\rd = \emptyset \), 
and by closing the \( \Tx(\mkvs, \vi) \) with respect to the relation \( \PO_{\aexec'} ; \VIS_{\aexec'} \),
we will add more read-only transactions into the set \( \T_\rd\).
Suppose \( (\txid' ,\txid)  \in \PO_{\aexec'} ; \VIS_{\aexec'} \), 
that is, \( \txid' \toEdge{\SO_{\aexec'}} \txid'' \toEdge{\VIS_{\aexec'}} \txid \).
We perform a case analysis on if \( \txid'' \) has write:
\begin{itemize}
\item If the transaction \( \txid'' \) writes to a key.
For the new abstract execution \( \aexec' \), the visible transactions for \( \txid \) must come from \( \Tx(\mkvs, \vi) \cup \T_\rd \).
It means \( \txid'' \in \Tx(\mkvs, \vi) \cup \T_\rd  \).
Then given that \( \txid'' \) is not a read-only transaction, we have \( \txid'' \in \Tx(\mkvs, \vi) \).
Now there are two cases:
\begin{itemize}
    \item if \( \txid' \) is a read-only transaction, we include \( \txid' \in \T_{\rd} \).
    \item if \( \txid' \) has at least one write, it is easy to see \( \txid' \in \Tx(\mkvs, \vi) \) since \( j \in \vi(\ke) \wedge \WTx(\hh(\ke', i)) \xrightarrow{\PO?} \WTx(\hh(\ke, j)) \implies i \in \vi(\ke') \).
\end{itemize}
\item If the transaction \( \txid'' \in \T_\rd \) is a read-only transaction, 
since \( \T_\rd \) is initial empty, there must exist a later transaction \( \txid''' \) from the same client that writes to a key,
and such transaction \( \txid''' \) is included in \( \Tx(\mkvs, \vi) \):
\[
    \txid' \toEdge{\SO_{\aexec'}} \txid'' 
    \toEdge{\SO_{\aexec'}} \txid''' \toEdge{\VIS_{\aexec'}} \txid 
    \land \txid''' \in \Tx(\mkvs,\vi)
\]
Since \( \SO \) is transitive, 
therefore \( \txid' \toEdge{\SO_{\aexec'}} \txid''' \toEdge{\VIS_{\aexec'}} \txid \),
which we have already proven \( \txid' \in \Tx(\mkvs, \vi) \) or we will include \( \txid' \) in \( \T_\rd \).
Since there are finite transactions from a client in a trace, there must exist a \( \T_\rd \) in the end.
\end{itemize}


The execution test $\ET_{\MW}$ is complete with respect to 
the axiomatic specification $(\RP_{\LWW}, \Set{\lambda \aexec.(\PO_{\aexec} ; \VIS_{\aexec})})$. 
Let $\aexec$ be an abstract execution that satisfies the specification
$\CMa(\RP_{\LWW}, \Set{\lambda \aexec.(\PO_{\aexec} ; \VIS_{\aexec})})$, 
and consider a transaction $\txid \in \T_{\aexec}$. 
Assume i-\emph{th} transaction \( \txid_i \) in the arbitrary order,
and let view \( \vi_{i} = \getView(\aexec, \VIS^{-1}_{\aexec}(\txid_{i}) ) \).
We also pick any final view such that \( \vi'_{i} \subseteq \getView(\aexec, (\AR^{-1}_{\aexec})?(\txid_{i}) ) \).
It suffices to prove \( \ET_\MW \vdash (\hh_{\cut(\aexec, i-1)}, \vi_i ) \csat  \TtoOp{T}_{\aexec}(\txid_{i}) : (\hh_{\cut(\aexec, i-1)}, \vi'_{i}) \).
It means to prove the follows:
\begin{equation}
\label{equ:mw-complete}
\begin{array}{@{}l@{}}
    \fora{j,m,\ke, \ke' } j \in \vi(\ke)  
    \wedge \WTx(\hh_{\cut(\aexec, i-1)}(\ke', m)) \xrightarrow{\PO?} \WTx(\hh_{\cut(\aexec, i-1)}(\ke, j))  
    \implies m \in \vi(\ke')
\end{array}
\end{equation}
Assume \( j \) and \( \ke' \) such that \( j \in \vi(\ke')\), which means \( \WTx(\hh_{\cut(\aexec, i-1)}(\ke', j)) \in \VIS^{-1}_{\aexec}(\txid_{i}) \).
Now let consider transaction \( \txid \) that commits before \( \txid \) from the same session, \ie \( \txid \toEdge{\SO} \WTx(\hh_{\cut(\aexec, i-1)}(\ke, j)) \).
By the constraint \( \lambda \aexec.(\PO_{\aexec} ; \VIS_{\aexec}) \), the transaction \( \txid \in \VIS^{-1}_{\aexec}(\txid_{i}) \).
It means that in the kv-store \(  \hh_{\cut(\aexec, i-1)} \) every version written by \( \txid =  \WTx(\hh_{\cut(\aexec, i-1)}(\ke', m)) \) should be included in the view \( m \in \vi_i(\ke') \).
Thus we have the proof of \cref{equ:mw-complete}.
