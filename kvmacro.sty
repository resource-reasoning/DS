\ProvidesPackage{kvmacro}[2019/02/09 Macros for kv-store semantics, proofs, applications]
%**********************************************************************************************************************************
% Note: this file is shared between several documents, please do not delete any macros.
% Maintained by Shale Xiong <sx14@ic.ac.uk>
%**********************************************************************************************************************************
% Styles, Short-hand, General
%**********************************************************************************************************************************


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Dependency 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% xparse for more powerful macro definition,
% NewDocumentCommand and NewDocumentEnvironment
\RequirePackage{xparse}
% string filter 
\RequirePackage{xstring}
% list parser, e.g. \readlist 
\RequirePackage{listofitems}
% for newenviron
\RequirePackage{environ}

% Honey, mathtool is dark magic after xparse
\RequirePackage{mathtools}

% for xspace
\RequirePackage{xspace}

% math symbol, e.g. triangle equal
% math envrioment, e.g. align
\RequirePackage{amssymb, amsmath}

% for stackrel: put word above math operator
\RequirePackage{stackrel}

% for special brackets
\RequirePackage{stmaryrd}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% always start with capital letter 
% We heavily use | as separators
% We heavily use () as optional parameters instead of {}
% Most macro has star version, which stop the bracket stretching or stop certain font setting

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Fonts
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
\NewDocumentCommand\RuleFont{m}{\textsc{#1}}
\NewDocumentCommand\MataTypeFont{m}{\textsf{#1}}
\NewDocumentCommand\TypeFont{m}{\protect\scalebox{0.9}{\textsc{#1}}}
\NewDocumentCommand\CodeFont{m}{\ensuremath{\mathtt{#1}}\xspace}
\NewDocumentCommand\CommentFont{m}{\ensuremath{\mathtt{#1}}\xspace}
\NewDocumentCommand\FunctionFont{m}{\ensuremath{\mathsf{#1}}\xspace}
\NewDocumentCommand\PredicateFont{m}{\ensuremath{\mathtt{#1}}\xspace}
\NewDocumentCommand\RelationFont{m}{\ensuremath{\mathsf{\uppercase{#1}}}\xspace}
\NewDocumentCommand\LogicFont{m}{\textsc{\lowercase{#1}}\xspace}
\NewDocumentCommand\MathAuxiliaryFont{m}{%
\mathclap{\mathit{\scriptsize\lowercase{#1}}}\xspace%
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Short hands
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\NewDocumentCommand\Th{m}{\ensuremath{#1}\textsuperscript{th}\xspace}
\NewDocumentCommand\ow{}{\ensuremath{\text{otherwise}}\xspace}
\NewDocumentCommand\If{}{\ensuremath{\text{if}\ }\xspace}
\NewDocumentCommand\Undef{}{\ensuremath{\text{undefined}}\xspace}
\NewDocumentCommand\Case{m}{\item \textbf{Case}\xspace #1.\xspace}
\NewDocumentCommand\Cases{m}{\item \textbf{Cases}\xspace #1.\xspace}
\NewDocumentCommand\CaseBase{m}{\item \textbf{Base Case}\xspace #1.\xspace}
\NewDocumentCommand\CaseInd{m}{\item \textbf{Inductive Case}\xspace #1.\xspace}
\NewDocumentCommand\Let{}{\ensuremath{\CodeFont{let}\ }\xspace}
\NewDocumentCommand\LetQuad{}{\ensuremath{\phantom{\CodeFont{let}}\ }\xspace}
\NewDocumentCommand\In{}{\ensuremath{\CodeFont{in}\ }\xspace}
\NewDocumentCommand\AND{}{\ensuremath{\CodeFont{and}\ }\xspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Formulae typesetting
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% a wrap for environment amsmath,
% bypass a compatibility issune for xparse
\NewEnviron{ALIGNS}{\begin{align*}\BODY\end{align*}}

% automatic put array for multi-lines formulae
\NewDocumentCommand{\OPTIONMULTLINE}{m}{
% set separate 
\noexpandarg%
% check if there are multiple lines
\IfSubStr{#1}{\\}{\begin{multlined}#1\end{multlined}}{#1}%
}

% Prefix + extracts multi-lines.
% It put stretchable brackets around a single formula,
% or multline environment then brackets for multi-lines formulae, identified via `\\'
\NewDocumentEnvironment{Bracketed}{ s }{%
% stop argument expansion for checking \\
\IfBooleanTF{#1}{(}{\left(}%
% check if there are multiple lines
\begin{array}{@{}l@{}}%
}{%
\end{array}%
\IfBooleanTF{#1}{)}{\right)}%
}

% wrap for multlined
\NewDocumentEnvironment{Formula}{}{\multlined}{\endmultlined}

% multiple lines formulae with or without label,
% label align to the bottom
\NewDocumentEnvironment{Formulae}{ s }{%
\mathtoolsset{multlined-pos=b}%
% replcae the \label with LABEL
\IfBooleanTF{#1}{\ALIGNS}{\align}%
}{%
\IfBooleanTF{#1}{\endALIGNS}{\endalign}%
\mathtoolsset{multlined-pos=t}%
}

%\NewDocumentEnvironment{Centermultline}{ s +b }{%
%\IfBooleanTF{#1}{\GATHERS}{\GATHER}%
%\OPTIONMULTLINE{#2}%
%}{%
%\IfBooleanTF{#1}{\endGATHERS}{\endGATHER}%
%}

%\NewDocumentEnvironment{Centermultline*}{ +b }{%
%\GATHERS%
%\OPTIONMULTLINE{#1}%
%}{%
%\endGATHERS%
%}

% reduction steps arrow, padding
\NewDocumentCommand\ArrowPadding{m}{\ensuremath{\;\mathrel{#1}\;}\xspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Mathematics structures and operators, 
% e.g. function, predicate, set, list, etc.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%
% Variable and types
%%%%%%%%%%%

\NewDocumentCommand\TypeDef{}{%
\ensuremath{\stackrel{\MathAuxiliaryFont{def}}{=}}\xspace%
}
\NewDocumentCommand\IsTyped{}{%
\ensuremath{\mathrel{:}}\xspace%
}

% lift variable into set, ie upper-case
\NewDocumentCommand\MathVar{m}{\ensuremath{#1}\xspace}

% lift variable into set, ie upper-case
\NewDocumentCommand\SetOf{m}{\ensuremath{\uppercase{#1}}\xspace}

% lift variable into set of set, ie curly upper-case
\NewDocumentCommand\SetSetOf{m}{\ensuremath{\mathcal{\SetOf{#1}}}\xspace}

% nature number, integer, index
\NewDocumentCommand\Int{}{\ensuremath{\mathbb{Z}}\xspace}
\NewDocumentCommand\Index{}{\ensuremath{\mathbb{N}}\xspace}

%%%%%%%%%%%
% Redefine implies and iff with shorter arrows
%%%%%%%%%%%
\RenewDocumentCommand\implies{}{\Rightarrow}
\RenewDocumentCommand\iff{}{\Leftrightarrow}
% provide \centernot
\RequirePackage{centernot}
%\RenewDocumentCommand\not{m}{\centernot{#1}}

%%%%%%%%%%%
% Set 
%%%%%%%%%%%
% depending on the second argument #2,
% if it is concrete value then it produce a stretchable bar | in between.
\NewDocumentCommand\OPTIONSET{mm}{%
\left\{%
\OPTIONMULTLINE{#1}%
\IfValueT{#2}{%
\; \middle| \; \OPTIONMULTLINE{#2}%
}%
\right\}%
}

\NewDocumentCommand\OPTIONSETS{mm}{%
\ensuremath{%
\{%
\OPTIONMULTLINE{#1}%
\IfValueT{#2}{%
\ \mid \ \OPTIONMULTLINE{#2}%
}\}}\xspace%
}

% A set with | as the separator.
% It should have maximum one |.
\NewDocumentCommand\SetBAR{ s >{\SplitArgument{1}{|}} m}{%
\IfBooleanTF{#1}{\ensuremath{ \OPTIONSETS #2 }%
}{\ensuremath{\OPTIONSET #2}}}

\NewDocumentCommand\Set{ s m o}{%
\IfBooleanTF{#1}{
\IfValueTF{#3}{\ensuremath{ \OPTIONSETS{#2}{#3}}}{\SetBAR*{#2}}%
}{
\IfValueTF{#3}{\ensuremath{ \OPTIONSET{#2}{#3}}}{\SetBAR{#2}}%
}\xspace}

%%%%%%%%%%%
% List 
%%%%%%%%%%%
% List concatenation
\NewDocumentCommand\ListConcat{}{\ensuremath{\mathbin{::}}\xspace}

% A list of several segments separated by | and connected by \ListConcat.
\NewDocumentCommand\List{s m}{%
\ensuremath{%
\setsepchar{{|}}%
\readlist*\listElems{#2}%
\foreachitem\listElem\in\listElems{%
\IfBooleanTF{#1}{[}{\left[}%
\OPTIONMULTLINE{\listElem}%
\IfBooleanTF{#1}{]}{\right]}%
\ifnum\listElemcnt<\listElemslen%
\ListConcat%
\fi%
}}\xspace%
}

%%%%%%%%%%%
% Tuple 
%%%%%%%%%%%
% A tuple 
\NewDocumentCommand\Tuple{s m}{%
\ensuremath{%
%cut the element by comma `,'
\IfBooleanTF{#1}{\left(}{\left(}%
\OPTIONMULTLINE{#2}%
\right)
}\xspace%
}


%%%%%%%%%%%
% Function  and mapping
%%%%%%%%%%%
% function definition, 
\NewDocumentCommand\FuncDef{}{%
\ensuremath{\stackrel{\MathAuxiliaryFont{def}}{=}}\xspace%
}

% A function followed by a list of parameter groups.
% Each group is  separated by | and wrapped with stretchable brackets
% The non-star version applies \FuncFont to the function name,
% while the star version does not.
\NewDocumentCommand\Func{s m d()}{%
\ensuremath{%
\IfBooleanTF{#1}{#2}{\FunctionFont{#2}}%
\IfNoValueTF{#3}{}{%
\setsepchar{{|}}%
\readlist*\argumentElems{#3}%
\foreachitem\argumentElem\in\argumentElems{%
\Tuple{\argumentElem}%
}}}\xspace%
}

% function arrows: total, partial, total finite, and partial finite
\NewDocumentCommand\ToTFunc{}{\ensuremath{\rightarrow}\xspace}
\NewDocumentCommand\ToPFunc{}{\ensuremath{\xrightharpoonup{}}\xspace}
\NewDocumentCommand\ToTFFunc{}{%
\ensuremath{\xrightarrow{\MathAuxiliaryFont{fin}}}\xspace}
\NewDocumentCommand\ToPFFunc{}{%
\ensuremath{\xrightharpoonup{\MathAuxiliaryFont{fin}}}\xspace}

% map to
\NewDocumentCommand\MapTo{mm}{%
\ensuremath{#1 \mapsto #2}\xspace%
}

% a single mapping split by `->' as the arrow
\NewDocumentCommand\SINGLEMAP{m}{%
\ensuremath{%
\setsepchar{{->}}%
\readlist*\singlemappingElems{#1}%
\ifnum\singlemappingElemslen=1
\MapTo{\singlemappingElems[1]}{-NoValue-}%
\else%
\MapTo{\singlemappingElems[1]}{\singlemappingElems[2]}%
\fi%
}}

\NewDocumentCommand\Mapping{s m}{%
\noexpandarg
\ensuremath{%
\IfBooleanTF{#1}{\Set*}{\Set}%
{%
\setsepchar{{|}}%
\readlist*\mappingElems{#2}%
\foreachitem\mappingElem\in\mappingElems{%
\SINGLEMAP{\mappingElem}%
% put comma in between
\ifnum\mappingElemcnt<\mappingElemslen,\fi%
}}}\xspace%
}

% update function in the form [d -> r][d' -> r'].
% Split by `|'
\NewDocumentCommand\UpdateFunc{m}{%
\ensuremath{%
\noexpandarg%
\setsepchar{{|}}%
\readlist*\mappingElems{#1}%
\foreachitem\mappingElem\in\mappingElems{%
\left[\SINGLEMAP{\mappingElem}\right]%
}}\xspace%
}

%%%%%%%%%%%
% Predicate 
%%%%%%%%%%%
% predicate definition
\NewDocumentCommand\PredDef{}{\ensuremath{\stackrel{\MathAuxiliaryFont{def}}{\iff}}\xspace}

% A predicate followed by a list of parameter groups.
% Each group is  separated by | and wrapped with stretchable brackets
% The non-star version applies \PredicateFont to the function name,
% while the star version does not.
\NewDocumentCommand\Pred{s m d()}{%
\ensuremath{%
\IfBooleanTF{#1}{#2}{\PredicateFont{#2}}%
\IfNoValueTF{#3}{}{%
\setsepchar{{|}}%
\readlist*\argumentElems{#3}%
\foreachitem\argumentElem\in\argumentElems{%
\Tuple{\argumentElem}%
}}}\xspace%
}

%%%%%%%%%%%
% Quantification 
%%%%%%%%%%%

% for-all and exists, split by `|'
\NewDocumentCommand\Forall{m}{%
\ensuremath{%
\setsepchar{{|}}%
\readlist*\quantificationElems{#1}%
\foreachitem\quantificationElem\in\quantificationElems{%
\forall \quantificationElem \ldotp%
}}\xspace%
}

\NewDocumentCommand\Exists{m}{%
\ensuremath{%
\setsepchar{{|}}%
\readlist*\quantificationElems{#1}%
\foreachitem\quantificationElem\in\quantificationElems{%
\exists \quantificationElem \ldotp%
}}\xspace%
}

%%%%%%%%%%%
% Unary operator
%%%%%%%%%%%

% Power set 
\NewDocumentCommand\PowerSet{d()}{%
\ensuremath{\mathcal{P}(#1)}\xspace%
}

% Projection
\NewDocumentCommand\Proj{o m}{%
\ensuremath{%
\IfNoValueTF{#1}{}{{#1}}_{\left| #2 \right.}%
}\xspace%
}

% Absolute value
\NewDocumentCommand\Abs{m}{\ensuremath{\left| #1 \right|}\xspace}

% Domain and range
\NewDocumentCommand\Dom{d()}{\ensuremath{\Func{Dom}(#1)}\xspace}
\NewDocumentCommand\Range{d()}{\ensuremath{\Func{Range}(#1)}\xspace}
% max and min
\NewDocumentCommand\Max{O{}d()}{\ensuremath{\Func*{\FunctionFont{Max}_{#1}}(#2)}\xspace}
\NewDocumentCommand\Min{O{}d()}{\ensuremath{\Func*{\FunctionFont{Min}_{#1}}(#2)}\xspace}
% relation closure
\NewDocumentCommand\TraRe{d()}{%
\IfNoValueTF{#1}{%
\MathVar{\mathop{{}^*}}%
}{\MathVar{{#1}^*}%
}}
\NewDocumentCommand\Refl{d()}{%
\IfNoValueTF{#1}{%
\MathVar{\mathop{{}^?}}%
}{\MathVar{{#1}^?}%
}}
\NewDocumentCommand\Trasi{d()}{%
\IfNoValueTF{#1}{%
\MathVar{\mathop{{}^+}}%
}{\MathVar{{#1}^+}%
}}
\NewDocumentCommand\Inv{d()}{%
\IfNoValueTF{#1}{%
\MathVar{\mathop{{}^{-1}}}%
}{\MathVar{{#1}^{-1}}%
}}
\NewDocumentCommand\RelConcat{}{\ensuremath{\mathbin{;}}\xspace}
% Denotation
\NewDocumentCommand\Denote{m O{}}{%
\ensuremath{\left\llbracket #1 \right\rrbracket_{#2}}\xspace%
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% kv-store and view
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\NewDocumentCommand\Clients{}{\TypeFont{ClientID}\xspace}
\NewDocumentCommand\cl{}{{\MathVar{cl}}\xspace}
\NewDocumentCommand\clset{}{{\SetOf{c\!l}}\xspace}
\NewDocumentCommand\TxIDs{}{\TypeFont{TxID}\xspace}
\NewDocumentCommand\TxIDZs{}{\ensuremath{\TxIDs_0}\xspace}
\NewDocumentCommand\txid{od()}{%
\ensuremath{t%
\IfNoValueTF{#1}{}{_{#1}}%
\IfNoValueTF{#2}{}{^{#2}}%
}\xspace}
\NewDocumentCommand\txidrd{}{\txid[\text{rd}]}
\NewDocumentCommand\txidinit{}{\ensuremath{\txid_0}\xspace}
\NewDocumentCommand\txidset{o}{\IfNoValueTF{#1}{\SetOf{t}}{\SetOf{t}_{#1}}}
\NewDocumentCommand\txidsetrd{}{\txidset[\text{rd}]}
\NewDocumentCommand\Values{}{\TypeFont{Value}\xspace}
\NewDocumentCommand\val{}{\MathVar{v}}
\NewDocumentCommand\valset{}{\MathVar{\SetOf{v}}}
\NewDocumentCommand\valinit{}{\ensuremath{\val_0}\xspace}
\NewDocumentCommand\Keys{}{\TypeFont{Key}\xspace}
\NewDocumentCommand\key{}{\MathVar{k}}
\NewDocumentCommand\keyset{}{\MathVar{\SetOf{k}}}
\NewDocumentCommand\Versions{}{\TypeFont{Version}\xspace}
\NewDocumentCommand\ver{}{\MathVar{\nu}}
\NewDocumentCommand\verlist{}{\MathVar{\mathcal{V}}}
\NewDocumentCommand\KVSs{}{\TypeFont{KVS}\xspace}
\NewDocumentCommand\kvs{d()}{\Func*{\mathcal{K}}(#1)}
\NewDocumentCommand\kvsinit{d()}{\Func*{\mathcal{K}_0}(#1)}
\NewDocumentCommand\Indexs{}{\Nat\xspace}
\NewDocumentCommand\idx{}{\MathVar{i}}
\NewDocumentCommand\Views{d()}{\Func{\TypeFont{Views}}(#1)}
\NewDocumentCommand\ViewEnvs{d()}{\Func*{\TypeFont{ViewEnv}}(#1)\xspace}
\NewDocumentCommand\vi{d()}{\Func*{u}(#1)}
\NewDocumentCommand\viinit{d()}{\Func*{\vi_0}(#1)}
\NewDocumentCommand\vienv{d()}{\Func{\mathcal{U}}(#1)}
\NewDocumentCommand\vienvinit{d()}{\Func*{\vienv_0}(#1)}
\NewDocumentCommand\Confs{}{\TypeFont{Conf}\xspace}
\NewDocumentCommand\ConfInits{}{\ensuremath{\TypeFont{Conf}_0}\xspace}
\NewDocumentCommand\conf{}{\ensuremath{\Gamma}\xspace}
\NewDocumentCommand\confinit{}{\ensuremath{\Gamma_0}\xspace}
\NewDocumentCommand\Snapshots{}{\TypeFont{Snapshot}\xspace}
\NewDocumentCommand\snap{d()}{\Func*{\sigma}(#1)}
\NewDocumentCommand\Stacks{}{\TypeFont{Stack}\xspace}
\NewDocumentCommand\stk{}{\MathVar{s}}
\NewDocumentCommand\Operations{}{\TypeFont{Op}\xspace}
\NewDocumentCommand\op{}{\MathVar{o}}
\NewDocumentCommand\opS{d()}{%
\IfNoValueTF{#1}{%
\MathVar{\PredicateFont{S}}%
}{%
\Tuple{\PredicateFont{S},#1}
}}
\NewDocumentCommand\opR{d()}{%
\IfNoValueTF{#1}{%
\MathVar{\PredicateFont{R}}%
}{%
\Tuple{\PredicateFont{R},#1}
}}
\NewDocumentCommand\opW{d()}{%
\IfNoValueTF{#1}{%
\MathVar{\PredicateFont{W}}%
}{%
\Tuple{\PredicateFont{W},#1}
}}
\NewDocumentCommand\opP{d()}{%
\IfNoValueTF{#1}{%
\MathVar{\PredicateFont{P}}%
}{%
\Tuple{\PredicateFont{P},#1}
}}
\NewDocumentCommand\opE{d()}{%
\IfNoValueTF{#1}{%
\MathVar{\PredicateFont{E}}%
}{%
\Tuple{\PredicateFont{E},#1}
}}
\NewDocumentCommand\opEmp{}{\epsilon}
\NewDocumentCommand\Fingerprints{}{\TypeFont{Fp}\xspace}
\NewDocumentCommand\fp{}{\MathVar{\mathcal{F}}}
\NewDocumentCommand\lib{}{\SetOf{l}}
\NewDocumentCommand\ClientEnvs{}{\TypeFont{ClientEnvs}\xspace}
\NewDocumentCommand\clenv{d()}{\Func{\mathcal{E}}(#1)}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% semantics label
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\NewDocumentCommand\Labels{}{\TypeFont{Labels}\xspace}
\NewDocumentCommand\PLabels{}{\TypeFont{PLabels}\xspace}
\NewDocumentCommand\COPSLabels{}{\TypeFont{COPSLabels}\xspace}
\NewDocumentCommand\ETLabels{}{\TypeFont{ETLabels}\xspace}
\NewDocumentCommand\AexecLabels{}{\TypeFont{ALabels}\xspace}
\NewDocumentCommand\lb{}{\MathVar{\iota}}
\NewDocumentCommand\lbCl{O{\cl}m}{\MathVar{\Tuple{#1,#2}}}
\NewDocumentCommand\lbPri{O{\cl}}{\MathVar{\Tuple{#1,\bullet}}}
\NewDocumentCommand\lbView{O{\cl}m}{\MathVar{\Tuple{#1,#2}}}
\NewDocumentCommand\lbTrans{O{\cl}m}{\Tuple{#1,#2}}
\NewDocumentCommand\lbFp{O{\cl}m}{\Tuple{#1,#2}}
\NewDocumentCommand\lbCOPSWrite{O{\cl}D(){\repl}m}{\Tuple{#1,#2,#3}}
\NewDocumentCommand\lbCOPSOptRead{O{\cl}D(){\repl}m}{\Tuple{#1,#2,#3,\CodeFont{Opt}}}
\NewDocumentCommand\lbCOPSPri{O{\cl}D(){\repl}}{\MathVar{\Tuple{#1,#2,\opS}}}
\NewDocumentCommand\lbCOPSBound{O{\cl}D(){\repl}}{\MathVar{\Tuple{#1,#2,\CodeFont{P}}}}
\NewDocumentCommand\lbCOPSRefetch{O{\cl}D(){\repl}m}{\MathVar{\Tuple{#1,#2,#3,\CodeFont{Ref}}}}
\NewDocumentCommand\lbCOPSFinishRead{O{\cl}D(){\repl}m}{\MathVar{\Tuple{#1,#2,#3,\opE}}}
\NewDocumentCommand\lbCOPSSync{D(){\repl}m}{\MathVar{\Tuple{#1,#2}}}
\NewDocumentCommand\lbCLOCKStart{O{\cl}D(){\clockshard}m}{\MathVar{\Tuple{#1,#2,#3,\opS}}}
\NewDocumentCommand\lbCLOCKOp{O{\cl}D(){\clockshard}m}{\MathVar{\Tuple{#1,#2,#3}}}
\NewDocumentCommand\lbCLOCKEnd{O{\cl}D(){\clockshard}m}{\MathVar{\Tuple{#1,#2,#3,\opE}}}
\NewDocumentCommand\lbCLOCKTick{D(){\clockshard}m}{\MathVar{\Tuple{#1,#2}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ET relation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\NewDocumentCommand\ExTests{}{\TypeFont{ExecutionTest}\xspace}
\NewDocumentCommand\et{O{}}{\ensuremath{\PredicateFont{ET}_{#1}}}
\NewDocumentCommand\ET{O{}}{\et[#1]}
\NewDocumentCommand\ETTraces{d()}{\Func*{\TypeFont{ETTraces}}(#1)}
\NewDocumentCommand\ETTracesN{d()}{\Func{ETTracesN}(#1)}
\NewDocumentCommand\ettrc{}{\MathVar{\tau}}
\NewDocumentCommand\TransactionRelations{}{\TypeFont{TransRels}\xspace}
\NewDocumentCommand\rel{O{}d()}{\Func*{R_{#1}}(#2)}
\NewDocumentCommand\TOP{}{\ensuremath{\top}\xspace}
\NewDocumentCommand\RA{}{\PredicateFont{RA}\xspace}
\NewDocumentCommand\MR{}{\PredicateFont{MR}\xspace}
\NewDocumentCommand\RYW{}{\PredicateFont{RYW}\xspace}
\NewDocumentCommand\MW{}{\PredicateFont{MW}\xspace}
\NewDocumentCommand\WFR{}{\PredicateFont{WFR}\xspace}
\NewDocumentCommand\CC{}{\PredicateFont{CC}\xspace}
\NewDocumentCommand\UA{}{\PredicateFont{UA}\xspace}
\NewDocumentCommand\PSI{}{\PredicateFont{PSI}\xspace}
\NewDocumentCommand\CP{}{\PredicateFont{CP}\xspace}
\NewDocumentCommand\WSI{}{\PredicateFont{WSI}\xspace}
\NewDocumentCommand\SI{}{\PredicateFont{SI}\xspace}
\NewDocumentCommand\SER{}{\PredicateFont{SER}\xspace}

\NewDocumentCommand\SO{}{\MathVar{\RelationFont{SO}}}
\NewDocumentCommand\WW{O{}d()}{\Func*{\RelationFont{WW}_{#1}}(#2)}
\NewDocumentCommand\WWInv{O{}d()}{\Func*{\RelationFont{WW}^{-1}_{#1}}(#2)}
\NewDocumentCommand\WR{O{}d()}{\Func*{\RelationFont{WR}_{#1}}(#2)}
\NewDocumentCommand\RW{O{}d()}{\Func*{\RelationFont{RW}_{#1}}(#2)}
\NewDocumentCommand\RWInv{O{}d()}{\Func*{\RelationFont{RW}^{-1}_{#1}}(#2)}
\NewDocumentCommand\RWRelf{O{}d()}{\Func*{\RelationFont{RW}^{?}_{#1}}(#2)}
\NewDocumentCommand\VIS{O{}d()}{\Func*{\RelationFont{VIS}_{#1}}(#2)}
\NewDocumentCommand\VISInv{O{}d()}{\Func*{\RelationFont{VIS}^{-1}_{#1}}(#2)}
\NewDocumentCommand\AR{O{}d()}{\Func*{\RelationFont{AR}_{#1}}(#2)}
\NewDocumentCommand\ARInv{O{}d()}{\Func*{\RelationFont{AR}^{-1}_{#1}}(#2)}
\NewDocumentCommand\DEP{O{}d()}{\Func*{\RelationFont{DEP}_{#1}}(#2)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% graph
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\NewDocumentCommand\DependencyGraphs{}{\TypeFont{DGraphs}\xspace}
\NewDocumentCommand\dgraph{}{\MathVar{\mathcal{G}}\xspace}
\NewDocumentCommand\txidop{O{}d()}{\Func*{\mathcal{T}_{#1}}(#2)}
\NewDocumentCommand\AbstractExecutions{}{\TypeFont{AExects}\xspace}
\NewDocumentCommand\aexec{}{\MathVar{\mathcal{X}}\xspace}
\NewDocumentCommand\aexecinit{}{\MathVar{\mathcal{X}_0}\xspace}
\NewDocumentCommand\VisAxioms{}{\TypeFont{VisAxioms}\xspace}
\NewDocumentCommand\visaxiom{}{\SetOf{a}\xspace}
\NewDocumentCommand\visaxioms{O{}}{\ensuremath{\SetSetOf{a}_{#1}}\xspace}
\NewDocumentCommand\aexectrc{}{\MathVar{\pi}\xspace}
\NewDocumentCommand\AexecInv{}{\TypeFont{AExectInvs}\xspace}
\NewDocumentCommand\aexecinv{od()}{
\IfNoValueTF{#1}{\Func*{I}(#2)}{\Func*{I_{#1}}(#2)}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% cops
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\NewDocumentCommand\COPSReplicas{}{\TypeFont{COPSRep}\xspace}
\NewDocumentCommand\repl{}{\MathVar{r}}
\NewDocumentCommand\COPSVerIDs{}{\TypeFont{COPSVerID}\xspace}
\NewDocumentCommand\COPSTxIDs{}{\TypeFont{COPSTxID}\xspace}
\NewDocumentCommand\copsverid{}{\MathVar{id}}
\NewDocumentCommand\copstxid{oO{\repl}d()}{%
\MathVar{\hat{t}%
\IfNoValueTF{#1}{}{_{#1}}%
\IfNoValueTF{#3}{}{%
\setsepchar{,}
\readlist*\numberElems{#3}%
\ifnum\numberElemslen<2%
^{\Tuple{#3,#2,0}}
\else
^{\Tuple{\numberElems[1],#2,\numberElems[2]}}
\fi}}}
\NewDocumentCommand\COPSVersions{}{\TypeFont{COPSVer}\xspace}
\NewDocumentCommand\copsver{}{\MathVar{\hat{\nu}}}
\NewDocumentCommand\copsverlist{}{\MathVar{\hat{\mathcal{V}}}}
\NewDocumentCommand\COPSDependencies{}{\TypeFont{COPSDep}\xspace}
\NewDocumentCommand\copsdep{}{\MathVar{d}}
\NewDocumentCommand\copsdepset{}{\MathVar{\hat{\SetOf{d}}}}
\NewDocumentCommand\COPSKVSs{}{\TypeFont{COPSKVS}\xspace}
\NewDocumentCommand\copskvs{d()}{\Func*{\hat{\mathcal{K}}}(#1)}
\NewDocumentCommand\COPSs{}{\TypeFont{COPSs}\xspace}
\NewDocumentCommand\cops{d()}{\Func*{\hat{\mathcal{R}}}(#1)}
\NewDocumentCommand\COPSContexts{d()}{\Func*{\TypeFont{COPSCtx}}(#1)}
\NewDocumentCommand\copsctx{d()}{\Func*{\hat{u}}(#1)}
\NewDocumentCommand\COPSContextEnvs{d()}{\Func*{\TypeFont{COPSCtxEnv}}(#1)}
\NewDocumentCommand\copsctxenv{d()}{\Func*{\hat{\mathcal{U}}}(#1)}
\NewDocumentCommand\COPSConfs{d()}{\Func*{\TypeFont{COPSConf}}(#1)}
\NewDocumentCommand\copsconf{d()}{\MathVar{\Theta}}
\NewDocumentCommand\COPSConfInits{d()}{\Func*{\TypeFont{COPSConf}_0}(#1)}
\NewDocumentCommand\copsconfinit{d()}{\MathVar{\Theta}_0}
\NewDocumentCommand\Times{}{\TypeFont{Time}\xspace}
\RenewDocumentCommand\ts{}{\MathVar{n}}
\NewDocumentCommand\COPSCommands{}{\TypeFont{COPSCmd}\xspace}
\NewDocumentCommand\copscmd{}{\MathVar{\hat{\cmd}}}
\NewDocumentCommand\COPSRunCommands{}{\TypeFont{COPSRuntimeCmd}\xspace}
\NewDocumentCommand\copsruncmd{}{\MathVar{\hat{\CodeFont{R}}}}
\NewDocumentCommand\COPSTraces{}{\TypeFont{COPSTrace}\xspace}
\NewDocumentCommand\COPSTraceN{d()}{\Func{COPSTraceN}(#1)\xspace}
\NewDocumentCommand\copstrc{}{\MathVar{\zeta}}
\NewDocumentCommand\COPSPrograms{}{\TypeFont{COPSProg}\xspace}
\NewDocumentCommand\copsprog{}{\MathVar{\hat{\prog}}}
\NewDocumentCommand\COPSRunPrograms{}{\TypeFont{COPSRuntimeProg}\xspace}
\NewDocumentCommand\copsrunprog{}{\MathVar{\hat{\CodeFont{I}}}}
\NewDocumentCommand\ExtCOPSTraces{}{\TypeFont{ANCOPSTrace}\xspace}
\NewDocumentCommand\copsexttrc{}{\MathVar{\hat{\zeta}}}
\NewDocumentCommand\copsclenv{d()}{\Func*{\hat{\mathcal{C}}}(#1)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% clock-si
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\NewDocumentCommand\CLOCKTimes{}{\TypeFont{ClockTime}\xspace}
\NewDocumentCommand\CLOCKtimes{}{\CLOCKTimes}
\NewDocumentCommand\clocktime{}{\MathVar{n}\xspace}
\NewDocumentCommand\clocktimeinit{}{\MathVar{\tilde{t_0}}\xspace}
\NewDocumentCommand\CLOCKVersions{}{\TypeFont{ClockVersions}\xspace}
\NewDocumentCommand\clockver{}{\MathVar{\tilde{\nu}}\xspace}
\NewDocumentCommand\CLOCKKVS{}{\TypeFont{ClockKVS}\xspace}
\NewDocumentCommand\clockkvs{d()}{\Func*{\tilde{\mathcal{K}}}(#1)\xspace}
\NewDocumentCommand\CLOCKKVSInit{}{\ensuremath{\TypeFont{ClockKVS}_0}\xspace}
\NewDocumentCommand\clockkvsinit{d()}{\Func*{\tilde{\mathcal{K}_0}}(#1)\xspace}
\NewDocumentCommand\CLOCKSI{}{\TypeFont{ClockSI}\xspace}
\NewDocumentCommand\CLOCKSIInit{}{\ensuremath{\TypeFont{ClockSI}_0}\xspace}
\NewDocumentCommand\clocksi{d()}{\Func*{\tilde{\mathcal{R}}}(#1)\xspace}
\NewDocumentCommand\clocksiinit{d()}{\Func*{\tilde{\mathcal{R}_0}}(#1)\xspace}
\NewDocumentCommand\CLOCKClientEnvs{}{\TypeFont{ClockClientEnv}\xspace}
\NewDocumentCommand\clockclientenv{d()}{\Func*{\tilde{\mathcal{U}}}(#1)\xspace}
\NewDocumentCommand\CLOCKClientEnvInits{}{\ensuremath{\TypeFont{ClockClientEnv}_0}\xspace}
\NewDocumentCommand\clockclientenvinit{d()}{\Func*{\tilde{\mathcal{C}_0}}(#1)\xspace}
\NewDocumentCommand\CLOCKConfs{}{\TypeFont{ClockConf}\xspace}
\NewDocumentCommand\clockconf{d()}{\Func*{\tilde{\Gamma}}(#1)\xspace}
\NewDocumentCommand\CLOCKConfInits{}{\ensuremath{\TypeFont{ClockConf}_0}\xspace}
\NewDocumentCommand\clockconfinit{d()}{\Func*{\tilde{\Gamma_0}}(#1)\xspace}
\NewDocumentCommand\CLOCKCommands{}{\TypeFont{ClockRunCommands}\xspace}
\NewDocumentCommand\clockruncmd{}{\MathVar{\tilde{\CodeFont{R}}}}
\NewDocumentCommand\CLOCKProgs{}{\TypeFont{ClockRunProgs}\xspace}
\NewDocumentCommand\clockrunprog{}{\MathVar{\tilde{\CodeFont{I}}}}
\NewDocumentCommand\pruntrans{mmm}{\MathVar{%
\begin{Transaction}%
#1%
\end{Transaction}^{#2}_{#3}%
}}
\NewDocumentCommand\CLOCKStates{}{\TypeFont{ClockState}\xspace}
\NewDocumentCommand\clockstate{}{\MathVar{\tilde{s}}}
\NewDocumentCommand\clocksiactive{}{\CodeFont{active}}
\NewDocumentCommand\clocksiprepared{}{\CodeFont{prepared}}
\NewDocumentCommand\clocksicommitting{}{\CodeFont{committing}}
\NewDocumentCommand\clocksicommitted{}{\CodeFont{committed}}
\NewDocumentCommand\CLOCKShards{}{\TypeFont{ClockShard}\xspace}
\NewDocumentCommand\clockshard{}{\MathVar{r}\xspace}
\NewDocumentCommand\clockshardset{}{\MathVar{R}\xspace}
\NewDocumentCommand\clockverlist{}{\MathVar{\tilde{\mathcal{V}}}}
\NewDocumentCommand\CLOCKBuffers{}{\TypeFont{ClockBuffer}\xspace}
\NewDocumentCommand\clockbuffer{}{\MathVar{\mathcal{B}}}
\NewDocumentCommand\CLOCKTraces{}{\TypeFont{ClockTrace}\xspace}
\NewDocumentCommand\CLOCKExtTraces{}{\TypeFont{AClockTrace}\xspace}
\NewDocumentCommand\clocktrc{}{\MathVar{\phi}}
\NewDocumentCommand\clockexttrc{}{\MathVar{\tilde{\phi}}}
\NewDocumentCommand\clocktrcstate{}{\MathVar{\tilde{\alpha}}}
\NewDocumentCommand\ClockTxIDs{}{\TypeFont{ClockTxID}\xspace}
\NewDocumentCommand\clocktxid{od()}{%
\ensuremath{\tilde{t}%
\IfNoValueTF{#1}{}{_{#1}}%
\IfNoValueTF{#2}{}{^{(#2)}}%
}\xspace}
\NewDocumentCommand\CLOCKLabels{}{\TypeFont{ClockLabels}\xspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% program syntax 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\NewDocumentCommand\pskip{}{\MathVar{\CodeFont{skip}}}
\NewDocumentEnvironment{Transaction}{}{%
\left[ 
\noexpandarg%
% check if there are multiple lines
\begin{array}{@{}l@{}}%
}{%
\end{array}%
\right]%
}
\NewDocumentCommand\ptrans{m}{\MathVar{%
\begin{Transaction}%
#1%
\end{Transaction}%
}}
\NewDocumentCommand\pseq{}{\MathVar{\mathbin{;}}}
\NewDocumentCommand\pchoice{}{\MathVar{\mathbin{+}}}
\NewDocumentCommand\ppar{}{\MathVar{\mathbin{\|}}}
\NewDocumentCommand\prepeat{d()}{%
\IfNoValueTF{#1}{%
\MathVar{\mathop{{}^*}}%
}{%
\MathVar{\mathop{{#1}^*}}%
}%
}
\NewDocumentCommand\AssignSymbol{}{\MathVar{\mathrel{:=}}}
\NewDocumentCommand\passign{mm}{\MathVar{#1 \AssignSymbol #2}}
\NewDocumentCommand\passume{d()}{\Func*{\CodeFont{assume}}(#1)}
\NewDocumentCommand\pmutate{mm}{\MathVar{\left[ #1\right] \AssignSymbol #2}}
\NewDocumentCommand\plookup{mm}{\MathVar{#1 \AssignSymbol \left[ #2 \right]}}
\NewDocumentCommand\pif{d()}{\MathVar{%
\CodeFont{if}%
\IfNoValueTF{#1}{}{\begin{Bracketed} #1\end{Bracketed}}\xspace%
}}
\NewDocumentCommand\pelse{}{\MathVar{\CodeFont{else}}}
\NewDocumentCommand\pwhile{d()}{\MathVar{%
\CodeFont{while}%
\IfNoValueTF{#1}{}{\begin{Bracketed} #1\end{Bracketed}}\xspace%
}}
\NewDocumentCommand\Expressions{}{\TypeFont{Expressions}}
\NewDocumentCommand\expr{}{\MathVar{\CodeFont{E}}}
\NewDocumentCommand\Booleans{}{\TypeFont{Booleans}}
\NewDocumentCommand\bool{}{\MathVar{\CodeFont{B}}}
\NewDocumentCommand\true{}{\MathVar{\CodeFont{true}}}
\NewDocumentCommand\false{}{\MathVar{\CodeFont{false}}}
\NewDocumentCommand\Programs{}{\TypeFont{Progs}}
\NewDocumentCommand\prog{d()}{\Func*{\CodeFont{P}}(#1)}
\NewDocumentCommand\ProgTraces{d()}{\Func*{\TypeFont{PTraces}}(#1)}
\NewDocumentCommand\progtrc{}{\MathVar{\eta}}
\NewDocumentCommand\Vars{}{\TypeFont{Var}}
\NewDocumentCommand\var{D(){x}}{\MathVar{\CodeFont{#1}}}
\NewDocumentCommand\Commands{}{\TypeFont{Commands}}
\NewDocumentCommand\cmd{}{\MathVar{\CodeFont{C}}}
\NewDocumentCommand\cmdpri{}{\MathVar{\CodeFont{C}_p}}
\NewDocumentCommand\Transactions{}{\TypeFont{Transactions}}
\NewDocumentCommand\trans{}{\MathVar{\CodeFont{T}}}
\NewDocumentCommand\transpri{}{\MathVar{\CodeFont{T}_p}}
\NewDocumentCommand\pcopsput{d()}{\Func*{\CodeFont{put}}(#1)}
\NewDocumentCommand\pcopsread{d()}{\Func*{\CodeFont{read}}(#1)}
\NewDocumentCommand\pclockstart{d()}{\Func*{\CodeFont{transSnapshot}}(#1)}
\NewDocumentCommand\pclockwrite{d()}{\Func*{\CodeFont{transWrite}}(#1)}
\NewDocumentCommand\pclockread{d()}{\Func*{\CodeFont{transRead}}(#1)}
\NewDocumentCommand\pclockcommit{d()}{\Func*{\CodeFont{commitTrans}}(#1)}
\NewDocumentCommand\pk{d()}{\CodeFont{k}\xspace}
\NewDocumentCommand\pks{d()}{\CodeFont{ks}\xspace}
\NewDocumentCommand\pctx{d()}{\CodeFont{ctx}\xspace}
\NewDocumentCommand\prepl{d()}{\CodeFont{repl}\xspace}
\NewDocumentCommand\ret{}{\CodeFont{ret}}
\NewDocumentCommand\plock{d()}{\Func*{\CodeFont{lock}}(#1)}
\NewDocumentCommand\ptrylock{d()}{\Func*{\CodeFont{tryLock}}(#1)}
\NewDocumentCommand\punlock{d()}{\Func*{\CodeFont{unlock}}(#1)}

\NewDocumentCommand\plockpara{d()}{\Func*{\CodeFont{lockPara}}(#1)}

\NewDocumentCommand\pcounter{sd()}{
\IfNoValueTF{#2}{\CodeFont{Counter}}{%
\IfBooleanTF{#1}{\CodeFont{Counter}\left(#2\right)}{
\CodeFont{Counter\left(#2\right)}}%
}\xspace}
\NewDocumentCommand\pcounters{sd()}{
\IfNoValueTF{#2}{\CodeFont{Counters}}{%
\IfBooleanTF{#1}{\CodeFont{Counters}\left(#2\right)}{
\CodeFont{Counter\left(#2\right)}}%
}\xspace}
\NewDocumentCommand\pread{sd()}{
\IfNoValueTF{#2}{\CodeFont{Read}}{%
\IfBooleanTF{#1}{\CodeFont{Read}\left(#2\right)}{
\CodeFont{Read\left(#2\right)}}%
}\xspace}
\NewDocumentCommand\pinc{sd()}{
\IfNoValueTF{#2}{\CodeFont{Inc}}{%
\IfBooleanTF{#1}{\CodeFont{Inc}\left(#2\right)}{
\CodeFont{Inc\left(#2\right)}}%
}\xspace}

\NewDocumentCommand\pbank{sd()}{
\IfNoValueTF{#2}{\CodeFont{Bank}}{%
\IfBooleanTF{#1}{\Func{\CodeFont{Bank}}(#2)}{
\Func{\CodeFont{Bank}}(#2)}}}
\NewDocumentCommand\pbalance{sd()}{
\IfNoValueTF{#2}{\CodeFont{Counter}}{%
\IfBooleanTF{#1}{\Func{\CodeFont{Balance}}(#2)}{
\Func{\CodeFont{Balance}}(#2)}}}
\NewDocumentCommand\pcheck{sd()}{
\IfNoValueTF{#2}{\CodeFont{DepositChecking}}{%
\IfBooleanTF{#1}{\Func{\CodeFont{DepositChecking}}(#2)}{
\Func{\CodeFont{DepositChecking}}(#2)}}}
\NewDocumentCommand\psave{sd()}{
\IfNoValueTF{#2}{\CodeFont{TransactSaving}}{%
\IfBooleanTF{#1}{\Func{\CodeFont{TransactSaving}}(#2)}{
\Func{\CodeFont{TransactSaving}}(#2)}}}
\NewDocumentCommand\pamal{sd()}{
\IfNoValueTF{#2}{\CodeFont{Amalgamate}}{%
\IfBooleanTF{#1}{\Func{\CodeFont{Amalgamate}}(#2)}{
\Func{\CodeFont{Amalgamate}}(#2)}}}
\NewDocumentCommand\pwritecheck{sd()}{
\IfNoValueTF{#2}{\CodeFont{WriteCheck}}{%
\IfBooleanTF{#1}{\Func{\CodeFont{WriteCheck}}(#2)}{
\Func{\CodeFont{WriteCheck}}(#2)}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% rule name 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\NewDocumentCommand\rTPrimitive{}{\RuleFont{TPrimitive}\xspace}
\NewDocumentCommand\rTChoice{}{\RuleFont{TChoice}\xspace}
\NewDocumentCommand\rTIter{}{\RuleFont{TIter}\xspace}
\NewDocumentCommand\rTSeqSkip{}{\RuleFont{TSeqSkip}\xspace}
\NewDocumentCommand\rTSeq{}{\RuleFont{TSeq}\xspace}
\NewDocumentCommand\rCAtomicTrans{}{\RuleFont{CAtomicTrans}\xspace}
\NewDocumentCommand\rCPrimitive{}{\RuleFont{CPrimitive}\xspace}
\NewDocumentCommand\rCChoice{}{\RuleFont{CChoice}\xspace}
\NewDocumentCommand\rCIter{}{\RuleFont{CIter}\xspace}
\NewDocumentCommand\rCSeqSkip{}{\RuleFont{CSeqSkip}\xspace}
\NewDocumentCommand\rCSeq{}{\RuleFont{CSeq}\xspace}
\NewDocumentCommand\rProg{}{\RuleFont{Prog}\xspace}
\NewDocumentCommand\rAAtomicTrans{}{\RuleFont{AAtomicTrans}\xspace}
\NewDocumentCommand\rAPrimitive{}{\RuleFont{APrimitive}\xspace}
\NewDocumentCommand\rAChoice{}{\RuleFont{AChoice}\xspace}
\NewDocumentCommand\rAIter{}{\RuleFont{AIter}\xspace}
\NewDocumentCommand\rASeqSkip{}{\RuleFont{ASeqSkip}\xspace}
\NewDocumentCommand\rASeq{}{\RuleFont{ASeq}\xspace}
\NewDocumentCommand\rAProg{}{\RuleFont{AProg}\xspace}
\NewDocumentCommand\rCOPSWrite{}{\RuleFont{COPSWrite}\xspace}
\NewDocumentCommand\rCOPSStartRead{}{\RuleFont{COPSStartRead}\xspace}
\NewDocumentCommand\rCOPSOptRead{}{\RuleFont{COPSOptRead}\xspace}
\NewDocumentCommand\rCOPSLowerBound{}{\RuleFont{COPSRefetchSet}\xspace}
\NewDocumentCommand\rCOPSRefetch{}{\RuleFont{COPSRefetch}\xspace}
\NewDocumentCommand\rCOPSFinishRead{}{\RuleFont{COPSFinishRead}\xspace}
\NewDocumentCommand\rCOPSClient{}{\RuleFont{COPSClient}\xspace}
\NewDocumentCommand\rCOPSSync{}{\RuleFont{COPSSync}\xspace}
\NewDocumentCommand\rCLOCKStart{}{\RuleFont{CLOCKSISnapshot}\xspace}
\NewDocumentCommand\rCLOCKWrite{}{\RuleFont{CLOCKSIWrite}\xspace}
\NewDocumentCommand\rCLOCKReadLocal{}{\RuleFont{CLOCKSIReadLocal}\xspace}
\NewDocumentCommand\rCLOCKReadShard{}{\RuleFont{CLOCKSIReadShard}\xspace}
\NewDocumentCommand\rCLOCKPrepare{}{\RuleFont{CLOCKSIPrepare}\xspace}
\NewDocumentCommand\rCLOCKCommit{}{\RuleFont{CLOCKSICommit}\xspace}
\NewDocumentCommand\rCLOCKTrans{}{\RuleFont{CLOCKSITrans}\xspace}
\NewDocumentCommand\rCLOCKShardTick{}{\RuleFont{CLOCKSIShardTick}\xspace}
 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% operator function and predicate
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\RequirePackage{stmaryrd}
\NewDocumentCommand\Evaluation{mO{}}{\MathVar{\llbracket #1 \rrbracket_{#2}}}
\NewDocumentCommand\EvalE{mO{\stk}}{\Evaluation{#1}[#2]}
\NewDocumentCommand\EvalB{mO{\stk}}{\Evaluation{#1}[#2]}
\NewDocumentCommand\EvalET{mO{\et}}{\Evaluation{#1}[#2]}
\NewDocumentCommand\AProgTraces{d()}{\Func{ATracesN}(#1)}
\NewDocumentCommand\EvalAExec{mO{\visaxioms}}{\Evaluation{#1}[#2]}

\NewDocumentCommand\vileq{}{\ensuremath{\sqsubseteq}\xspace}
\NewDocumentCommand\copstxidle{}{\ensuremath{\sqsubset}\xspace}
\NewDocumentCommand\copsveridleq{}{\ensuremath{\sqsubseteq}\xspace}
\NewDocumentCommand\copstxidleq{}{\ensuremath{\sqsubseteq}\xspace}
\NewDocumentCommand\replleq{}{\ensuremath{\leq}\xspace}
\NewDocumentCommand\copskvsleq{}{\ensuremath{\sqsubseteq}\xspace}
\NewDocumentCommand\ettrceq{}{\ensuremath{\simeq}\xspace}
\NewDocumentCommand\AddOp{}{\ensuremath{\mathbin{<\!\!\!\vartriangleleft}}\xspace}
\NewDocumentCommand\copstrceq{}{\ensuremath{\simeq}\xspace}
\NewDocumentCommand\aexeceq{o}{\ensuremath{\IfNoValueTF{#1}{\simeq}{\simeq_{#1}}}}
\NewDocumentCommand\AKcomp{}{\ensuremath{\sim}\xspace}
\NewDocumentCommand\clockkvsleq{}{\ensuremath{\sqsubseteq}\xspace}
\NewDocumentCommand\clocksileq{}{\ensuremath{\sqsubseteq}\xspace}
\NewDocumentCommand\clocktrceq{}{\ensuremath{\simeq}\xspace}
\NewDocumentCommand\clockclientenvleq{}{\ensuremath{\sqsubseteq}\xspace}
\NewDocumentCommand\clocktxidleq{}{\ensuremath{\sqsubseteq}\xspace}
\NewDocumentCommand\clockverleq{}{\ensuremath{\sqsubseteq}\xspace}

\NewDocumentCommand\InitVal{d()}{\Func{InitialValue}(#1)}
\NewDocumentCommand\ValOf{d()}{\Func{ValueOf}(#1)}
\NewDocumentCommand\TimeOf{d()}{\Func{TimeOf}(#1)}
\NewDocumentCommand\StateOf{d()}{\Func{StateOf}(#1)}
\NewDocumentCommand\ShardOf{d()}{\Func{ShardOf}(#1)}
\NewDocumentCommand\WtOf{d()}{\Func{WriterOf}(#1)}
\NewDocumentCommand\RsOf{d()}{\Func{ReadersOf}(#1)}
\NewDocumentCommand\Snapshot{d()}{\Func{Snapshot}(#1)}
\NewDocumentCommand\GetOp{d()}{\Func{GetOp}(#1)}
\NewDocumentCommand\NextTxid{d()}{\Func{NextTxID}(#1)}
\NewDocumentCommand\UpdateKV{d()}{\Func{UpdateKV}(#1)}
\NewDocumentCommand\CMET{d()}{\Func{ConsisModel}(#1)}
\NewDocumentCommand\Last{d()}{\Func{Last}(#1)}
\NewDocumentCommand\First{d()}{\Func{First}(#1)}
\NewDocumentCommand\LastConf{d()}{\Last(#1)}
\NewDocumentCommand\FirstConf{d()}{\First(#1)}
\NewDocumentCommand\ExtendProgram{d()}{\Func{ExtendProgram}(#1)}
\NewDocumentCommand\TransFp{d()}{\Func{TransFp}(#1)}
\NewDocumentCommand\VisTrans{d()}{\Func{VisTrans}(#1)}
\NewDocumentCommand\DepOf{d()}{\Func{DepSetOf}(#1)}
\NewDocumentCommand\IdOf{d()}{\Func{IdOf}(#1)}
\NewDocumentCommand\COPSMerge{d()}{\Func{COPSMerge}(#1)}
\NewDocumentCommand\VerOf{d()}{\Func{VerOf}(#1)}
\NewDocumentCommand\VerListOf{d()}{\Func{VerListOf}(#1)}
\NewDocumentCommand\VerListOfN{d()}{\Func{VerListOfN}(#1)}
\NewDocumentCommand\KToD{d()}{\Func{KToD}(#1)}
\NewDocumentCommand\KToT{d()}{\Func{KToT}(#1)}
\NewDocumentCommand\DToK{d()}{\Func{DToK}(#1)}
\NewDocumentCommand\CMA{d()}{\Func{ConsisModelAxioms}(#1)}
\NewDocumentCommand\AexecSnapshot{d()}{\Func{AExecSnapshot}(#1)}
\NewDocumentCommand\MaxVisTrans{d()}{\Func{MaxVisTrans}(#1)}
\NewDocumentCommand\Sort{O{}d()}{\Func{Sort_{#1}}(#2)}
\NewDocumentCommand\NextAExecTxid{d()}{\Func{NextAExecTxID}(#1)}
\NewDocumentCommand\UpdateAExec{d()}{\Func{UpdateAExec}(#1)}
\NewDocumentCommand\XToD{d()}{\Func{XToD}(#1)}
\NewDocumentCommand\XToK{d()}{\Func{XToK}(#1)}
\NewDocumentCommand\GetView{d()}{\Func{GetView}(#1)}
\NewDocumentCommand\TraceToX{d()}{\Func{TraceToX}(#1)}
\NewDocumentCommand\AexecCut{d()}{\Func{AExectCut}(#1)}
\NewDocumentCommand\ARClose{d()}{\Func{ARClose}(#1)}
\NewDocumentCommand\XToTrace{d()}{\Func{XToTrace}(#1)}
\NewDocumentCommand\XToTraceN{d()}{\Func{XToTraceN}(#1)}
\NewDocumentCommand\ApproxView{d()}{\Func{ApproxView}(#1)}
\NewDocumentCommand\VerLower{d()}{\Func{VerLower}(#1)}
\NewDocumentCommand\VerLowerN{d()}{\Func{VerLowerN}(#1)}
\NewDocumentCommand\ClockToExd{d()}{\Func{AnnoClock}(#1)}
\NewDocumentCommand\ClockFirstCommit{d()}{\Func{FirstCommit}(#1)}
\NewDocumentCommand\ClockToKVStore{d()}{\Func{ClockToKVStore}(#1)}
\NewDocumentCommand\FirstTrans{d()}{\Func{FirstTransaction}(#1)}
\NewDocumentCommand\ReadOnlyTrans{d()}{\Func{ReadOnlyTrans}(#1)}

\NewDocumentCommand\COPSInsert{d()}{\Func{COPSInsert}(#1)}
\NewDocumentCommand\COPSViews{d()}{\Func{COPSViews}(#1)}
\NewDocumentCommand\COPSVisTrans{d()}{\Func{COPSVisTrans}(#1)}
\NewDocumentCommand\COPSToKVCmd{d()}{\Func{COPSToKVCmd}(#1)}
\NewDocumentCommand\COPSToKVProg{d()}{\Func{COPSToKVProg}(#1)}
\NewDocumentCommand\COPSToExt{d()}{\Func{COPSToExt}(#1)}
\NewDocumentCommand\COPSToExtW{d()}{\Func{COPSToExtW}(#1)}
\NewDocumentCommand\COPSToKVS{d()}{\Func{COPSToKVS}(#1)}
\NewDocumentCommand\COPSToKVTrace{d()}{\Func{COPSToKVTrace}(#1)}

\NewDocumentCommand\CLOCKTimeTick{d()}{\Func{CLOCKTick}(#1)}
\NewDocumentCommand\CLOCKMaxTime{d()}{\Func{MaxTime}(#1)}
\NewDocumentCommand\CLOCKUpdate{d()}{\Func{CLOCKUpdate}(#1)}
\NewDocumentCommand\CLOCKUpdateKVS{d()}{\Func{CLOCKUpdateKVS}(#1)}
\NewDocumentCommand\ClockStaticProg{d()}{\Func{ClockStaticProg}(#1)}
\NewDocumentCommand\ClockStaticCmd{d()}{\Func{ClockStaticCmd}(#1)}
\NewDocumentCommand\ClockFp{d()}{\Func{ClockFp}(#1)}
\NewDocumentCommand\ClockView{d()}{\Func{ClockView}(#1)}
\NewDocumentCommand\ClockToKVTrace{d()}{\Func{ClockToKVTrace}(#1)}

\NewDocumentCommand\NormalTrace{d()}{\Pred{NormalisedTrace}(#1)}
\NewDocumentCommand\WfView{d()}{\Pred{WfView}(#1)}
\NewDocumentCommand\WfET{d()}{\Pred{WfET}(#1)}
\NewDocumentCommand\WfKvs{d()}{\Pred{WfKvs}(#1)}
\NewDocumentCommand\CanCommit{O{}d()}{\Pred{CanCommit_{#1}}(#2)}
\NewDocumentCommand\ViewShift{O{}d()}{\Pred{ViewShift_{#1}}(#2)}
\NewDocumentCommand\PreClosed{d()}{\Pred{PreClosed}(#1)}
\NewDocumentCommand\Unique{d()}{\Pred{Unique}(#1)}
\NewDocumentCommand\WfCOPSKvs{d()}{\Pred{WfCOPSKvs}(#1)}
\NewDocumentCommand\COPSNormalTrace{d()}{\Pred{NCOPSTrace}(#1)}
\NewDocumentCommand\WfDGraph{d()}{\Pred{WfDGraph}(#1)}
\NewDocumentCommand\WfAExec{d()}{\Pred{WfAExec}(#1)}
\NewDocumentCommand\TotalRelation{d()}{\Pred{TotalRelation}(#1)}
\NewDocumentCommand\WfVIS{d()}{\Pred{WfVIS}(#1)}
\NewDocumentCommand\AExecSat{d()}{\Pred{AExecSat}(#1)}
\NewDocumentCommand\WSISafe{d()}{\Pred{WSISafe}(#1)}
\NewDocumentCommand\WfCLOCKKvs{d()}{\Pred{WfClockSIKvs}(#1)}
\NewDocumentCommand\CLOCKNormalTrace{d()}{\Pred{ANCLOCKTrace}(#1)}
\NewDocumentCommand\CLOCKTimeTickSeg{d()}{\Pred{CLOCKTickAndStartSeg}(#1)}
\NewDocumentCommand\CLOCKAtomic{d()}{\Pred{CLOCKAtomic}(#1)}
\NewDocumentCommand\ClockReadFromShard{d()}{\Pred{ReadFromShard}(#1)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% arrow
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\NewDocumentCommand\ToTrans{sm}{
\ensuremath{%
\IfBooleanTF{#1}{\rightsquigarrow}{%
% split into segments
\setsepchar{->}%
\readlist*\stepElems{#2}%
\foreachitem\stepElem\in\stepElems{%
% split a segment
\setsepchar{{|}}%
\readlist*\segElems{\stepElem}%
% the base for each segment
\Tuple{\segElems[1],\segElems[2],\segElems[3]}, \segElems[4]%
\ifnum\stepElemcnt<\stepElemslen%
% need an arrow
\ifnum\segElemslen<5%
\ArrowPadding{\rightsquigarrow}%
\else%
\ArrowPadding{\rightsquigarrow^{\segElems[5]}}%
\fi\fi%
}}}\xspace}
\RequirePackage{tikz}
\usetikzlibrary{calc,decorations.pathmorphing,shapes,arrows,positioning}
\NewDocumentCommand\xrightsquigarrow{moO{}}{%
\IfNoValueTF{#2}{%
\begin{tikzpicture}[baseline={([yshift=-2pt]current bounding box.south)}]%
\node[inner sep=.44ex,align=center] (tmp) {$\scriptstyle #1$};
\path[draw,<-,decorate,
decoration={zigzag,amplitude=0.7pt,segment length=1.2mm,pre length=3.5pt}] 
(tmp.south east) -- (tmp.south west);
\end{tikzpicture}
}{%
\begin{tikzpicture}[baseline={([yshift=4pt]current bounding box.south)}]%
\node[inner sep=.44ex,align=center] (tmp) {$\scriptstyle #1$};
\path[draw,<-,decorate,
decoration={zigzag,amplitude=0.7pt,segment length=1.2mm,pre length=3.5pt}] 
(tmp.south east) -- (tmp.south west);
\node[inner sep=0pt, outer sep=0pt, below right = 2pt and 0pt of tmp.south east] (sub) {\scriptsize \(#2\)};
\node[inner sep=0pt, outer sep=0pt, above right = 2pt and 0pt of tmp.south east] (sub) {\scriptsize \(#3\)};
\end{tikzpicture}
}\xspace}
\NewDocumentCommand\ToTransPri{m}{\xrightsquigarrow{#1}}
\NewDocumentCommand\xRightsquigarrow{m}{%
\mathrel{%
\begin{tikzpicture}[baseline= {( $ (current bounding box.south) + (0,-0.5ex) $ )}]
  \node[inner sep=.5ex] (a) {$\scriptstyle #1$};
  \path[draw,implies-,double distance between line centers=1.5pt,decorate,
    decoration={zigzag,amplitude=0.7pt,segment length=1.2mm,pre=lineto,
    pre   length=4pt}] 
    (a.south east) -- (a.south west);
\end{tikzpicture}}}

\NewDocumentCommand\ToCmd{sO{\et}m}{
\ensuremath{%
\IfBooleanTF{#1}{\xrightarrow{#3}_{#2}}{%
% split into segments
\setsepchar{->}%
\readlist*\stepElems{#3}%
\foreachitem\stepElem\in\stepElems{%
% split a segment
\setsepchar{{|}}%
\readlist*\segElems{\stepElem}%
% the base for each segment
% possible pattern $1
% possible pattern $1->$2
% possible pattern $1->$2$3
% possible pattern $1$2$3$4
% possible pattern $1$2$3$4->$5
% possible pattern $1$2$3$4->$5$6
\ifnum\segElemslen<4%
\segElems[1]%
\else%
\Tuple{\segElems[1],\segElems[2],\segElems[3]}, \segElems[4]%
\fi%
\ifnum\stepElemcnt<\stepElemslen%
% need an arrow
\ifnum\segElemslen<3%
\ArrowPadding{\xrightarrow{\segElems[2]}_{#2}}%
\else
\ifnum\segElemslen<4%
\ArrowPadding{\xrightarrow{\segElems[2]}_{#2}^{\segElems[3]}}%
\else
\ifnum\segElemslen<6%
\ArrowPadding{\xrightarrow{\segElems[5]}_{#2}}%
\else%
\ArrowPadding{\xrightarrow{\segElems[5]}_{#2}^{\segElems[6]}}%
\fi\fi\fi\fi%
}}}\xspace}
\NewDocumentCommand\ToCOPSCmd{sm}{
\ensuremath{%
\IfBooleanTF{#1}{\xrightsquigarrow{#2}}{%
% split into segments
\setsepchar{->}%
\readlist*\stepElems{#2}%
\foreachitem\stepElem\in\stepElems{%
% split a segment
\setsepchar{{|}}%
\readlist*\segElems{\stepElem}%
% the base for each segment
% possible pattern $1
% possible pattern $1->$2
% possible pattern $1->$2$3
% possible pattern $1$2$3$4
% possible pattern $1$2$3$4->$5
% possible pattern $1$2$3$4->$5$6
\ifnum\segElemslen<4%
\segElems[1]%
\else%
\Tuple{\segElems[1],\segElems[2],\segElems[3]}, \segElems[4]%
\fi%
\ifnum\stepElemcnt<\stepElemslen%
% need an arrow
\ifnum\segElemslen<3%
\ArrowPadding{\xrightarrow{\segElems[2]}}%
\else
\ifnum\segElemslen<4%
\ArrowPadding{\xrightarrow{\segElems[2]}^{\segElems[3]}}%
\else
\ifnum\segElemslen<6%
\ArrowPadding{\xrightarrow{\segElems[5]}}%
\else%
\ArrowPadding{\xrightarrow{\segElems[5]}^{\segElems[6]}}%
\fi\fi\fi\fi%
}}}\xspace}
\NewDocumentCommand\ToCOPSProg{sm}{
\ensuremath{%
\IfBooleanTF{#1}{\ArrowPadding{\xrightarrow{#2}}}{%
% split into segments
\setsepchar{->}%
\readlist*\stepElems{#2}%
\foreachitem\stepElem\in\stepElems{%
% split a segment
\setsepchar{{|}}%
\readlist*\segElems{\stepElem}%
% the base for each segment
% possible pattern $1
% possible pattern $1$2
% possible pattern $1->$2
% possible pattern $1->$2$3
% possible pattern $1$2$3
% possible pattern $1$2$3->$4
% possible pattern $1$2$3->$4$5
\ifnum\stepElemcnt<\stepElemslen%
% need an arrow
{\ifnum\segElemslen<3%
\segElems[1]\ArrowPadding{\xrightarrow{\segElems[2]}}%
\else
\ifnum\segElemslen<4%
\segElems[1]
\ArrowPadding{\xrightarrow{\segElems[2]}^{\segElems[3]}}%
\else
\ifnum\segElemslen<5%
\Tuple{\segElems[1],\segElems[2]},\segElems[3]
\ArrowPadding{\xrightarrow{\segElems[4]}}%
\else
\Tuple{\segElems[1],\segElems[2]},\segElems[3]
\ArrowPadding{\xrightarrow{\segElems[4]}^{\segElems[5]}}%
\fi\fi\fi}
\else
{\ifnum\segElemslen<2%
\segElems[1]%
\else%
\ifnum\segElemslen<3%
\segElems[1],\segElems[2]%
\else%
\Tuple{\segElems[1],\segElems[2]},\segElems[3]%
\fi\fi}\fi%
}}}\xspace}
\NewDocumentCommand\ToClockCmd{sm}{
\ensuremath{%
\IfBooleanTF{#1}{\xrightarrow{#2}}{%
% split into segments
\setsepchar{->}%
\readlist*\stepElems{#2}%
\foreachitem\stepElem\in\stepElems{%
% split a segment
\setsepchar{{|}}%
\readlist*\segElems{\stepElem}%
% the base for each segment
% possible pattern $1
% possible pattern $1$2
% possible pattern $1$2$3$4
% possible pattern $1->$2
% possible pattern $1->$2$3
% possible pattern $1$2$3$4->$5
% possible pattern $1$2$3$4->$5$6
\ifnum\stepElemcnt<\stepElemslen%
{% need an arrow
\ifnum\segElemslen<3%
\segElems[1]%
\ArrowPadding{\xrightarrow{\segElems[2]}}%
\else
\ifnum\segElemslen<4%
\segElems[1]%
\ArrowPadding{\xrightarrow{\segElems[2]}^{\segElems[3]}}%
\else
\ifnum\segElemslen<6%
\Tuple{\segElems[1],\segElems[2],\segElems[3]},\segElems[4]%
\ArrowPadding{\xrightarrow{\segElems[5]}}%
\else%
\Tuple{\segElems[1],\segElems[2],\segElems[3]},\segElems[4]%
\ArrowPadding{\xrightarrow{\segElems[5]}^{\segElems[6]}}%
\fi\fi\fi}
\else
{\ifnum\segElemslen<4%
\segElems[1]%
\else%
\Tuple{\segElems[1],\segElems[2],\segElems[3]}, \segElems[4]%
\fi}\fi%
}}}\xspace}
\NewDocumentCommand\ToCmdPri{m}{\xrightsquigarrow{#1}}
\NewDocumentCommand\ToProg{sO{\et}m}{
\ensuremath{%
\IfBooleanTF{#1}{\xrightarrow{#3}_{#2}}{%
% split into segments
\setsepchar{->}%
\readlist*\stepElems{#3}%
\foreachitem\stepElem\in\stepElems{%
% split a segment
\setsepchar{{|}}%
\readlist*\segElems{\stepElem}%
% the base for each segment
% possible pattern $1
% possible pattern $1$2
% possible pattern $1->$2
% possible pattern $1$2->$3
% possible pattern $1$2->$3$4
% possible pattern $1$2$3$4
% possible pattern $1$2$3$4->$5
% possible pattern $1$2$3$4->$5$6
\ifnum\stepElemcnt<\stepElemslen%
{\ifnum\segElemslen<3%
\segElems[1]%
\else%
\ifnum\segElemslen<5%
\segElems[1],\segElems[2]%
\else%
\Tuple{\segElems[1] , \segElems[2], \segElems[3]}, \segElems[4]%
\fi\fi}%
% need an arrow
{\ifnum\segElemslen<3%
\ArrowPadding{\xrightarrow{\segElems[2]}_{#2}}%
\else%
\ifnum\segElemslen<4%
\ArrowPadding{\xrightarrow{\segElems[3]}_{#2}}%
\else%
\ifnum\segElemslen<5%
\ArrowPadding{\xrightarrow{\segElems[3]}_{#2}^{\segElems[4]}}%
\else%
\ifnum\segElemslen<6%
\ArrowPadding{\xrightarrow{\segElems[5]}_{#2}}%
\else%
\ArrowPadding{\xrightarrow{\segElems[5]}_{#2}^{\segElems[6]}}%
\fi\fi\fi\fi}
\else
{\ifnum\segElemslen<2%
\segElems[1]%
\else%
\ifnum\segElemslen<3%
\segElems[1],\segElems[2]%
\else%
\Tuple{\segElems[1] , \segElems[2], \segElems[3]}, \segElems[4]%
\fi\fi}%
\fi%
}}}\xspace}
\NewDocumentCommand\TOET{mmmmmm}{%
\ensuremath{(#2,#3)\ArrowPadding{\xrightarrow{#4}_{#1}}(#5,#6)}\xspace}
\NewDocumentCommand\ToET{O{\et} >{\SplitArgument{4}{|}} m}{\TOET #1 #2}
\NewDocumentCommand\ToRed{sO{\et}m}{
\ensuremath{%
\IfBooleanTF{#1}{\xrightarrow{#3}_{#2}}{%
% split into segments
\setsepchar{->}%
\readlist*\stepElems{#3}%
\foreachitem\stepElem\in\stepElems{%
% split a segment
\setsepchar{{|}}%
\readlist*\segElems{\stepElem}%
% the base for each segment
% possible pattern $1
% possible pattern $1$2
% possible pattern $1->$2
% possible pattern $1$2->$3
% possible pattern $1$2->$3$4
\ifnum\stepElemcnt<\stepElemslen%
{\ifnum\segElemslen<3%
\segElems[1]%
\else%
\Tuple{\segElems[1] , \segElems[2]}%
\fi}%
% need an arrow
{\ifnum\segElemslen<3%
\ArrowPadding{\xrightarrow{\segElems[2]}_{#2}}%
\else%
\ifnum\segElemslen<4%
\ArrowPadding{\xrightarrow{\segElems[3]}_{#2}}%
\else%
\ArrowPadding{\xrightarrow{\segElems[3]}_{#2}^{\segElems[4]}}%
\fi\fi}
\else
{\ifnum\segElemslen<2%
\segElems[1]%
\else%
\Tuple{\segElems[1] , \segElems[2]}%
\fi}%
\fi%
}}}\xspace}
\NewDocumentCommand\ToEdge{sm}{
\ensuremath{%
\IfBooleanTF{#1}{\rightsquigarrow}{%
% split into segments
\setsepchar{->}%
\readlist*\stepElems{#2}%
\foreachitem\stepElem\in\stepElems{%
% split a segment
\setsepchar{{|}}%
\readlist*\segElems{\stepElem}%
% the base for each segment
\segElems[1]%
\ifnum\stepElemcnt<\stepElemslen%
% need an arrow
\ifnum\segElemslen<2%
\ArrowPadding{\xrightarrow{}}%
\else%
\ArrowPadding{\xrightarrow{\segElems[2]}}%
\fi\fi%
}}}\xspace}
\NewDocumentCommand\ToAexecCmd{sO{\visaxioms}m}{
\ensuremath{%
\IfBooleanTF{#1}{\ArrowPadding{\xrightarrow{#3}_{#2}}}{%
% split into segments
\setsepchar{->}%
\readlist*\stepElems{#3}%
\foreachitem\stepElem\in\stepElems{%
% split a segment
\setsepchar{{|}}%
\readlist*\segElems{\stepElem}%
% the base for each segment
% possible pattern $1
% possible pattern $1$2
% possible pattern $1->$2
% possible pattern $1->$2$3
% possible pattern $1$2$3
% possible pattern $1$2$3->$4
% possible pattern $1$2$3->$4$5
\ifnum\stepElemcnt<\stepElemslen%
% need an arrow
{\ifnum\segElemslen<3%
\segElems[1]\ArrowPadding{\xrightarrow{\segElems[2]}_{#2}}%
\else
\ifnum\segElemslen<4%
\segElems[1]
\ArrowPadding{\xrightarrow{\segElems[2]}_{#2}^{\segElems[3]}}%
\else
\ifnum\segElemslen<5%
\Tuple{\segElems[1],\segElems[2]},\segElems[3]
\ArrowPadding{\xrightarrow{\segElems[4]}_{#2}}%
\else
\Tuple{\segElems[1],\segElems[2]},\segElems[3]
\ArrowPadding{\xrightarrow{\segElems[4]}_{#2}^{\segElems[5]}}%
\fi\fi\fi}
\else
{\ifnum\segElemslen<2%
\segElems[1]%
\else%
\ifnum\segElemslen<3%
\segElems[1],\segElems[2]%
\else%
\Tuple{\segElems[1],\segElems[2]},\segElems[3]%
\fi\fi}\fi%
}}}\xspace}
\NewDocumentCommand\ToAexecProg{sO{\visaxioms}m}{
\ensuremath{%
\IfBooleanTF{#1}{\ArrowPadding{\xrightarrow{#3}_{#2}}}{%
% split into segments
\setsepchar{->}%
\readlist*\stepElems{#3}%
\foreachitem\stepElem\in\stepElems{%
% split a segment
\setsepchar{{|}}%
\readlist*\segElems{\stepElem}%
% the base for each segment
% possible pattern $1
% possible pattern $1$2
% possible pattern $1->$2
% possible pattern $1->$2$3
% possible pattern $1$2$3
% possible pattern $1$2$3->$4
% possible pattern $1$2$3->$4$5
\ifnum\stepElemcnt<\stepElemslen%
% need an arrow
{\ifnum\segElemslen<3%
\segElems[1]\ArrowPadding{\xrightarrow{\segElems[2]}_{#2}}%
\else
\ifnum\segElemslen<4%
\segElems[1]
\ArrowPadding{\xrightarrow{\segElems[2]}_{#2}^{\segElems[3]}}%
\else
\ifnum\segElemslen<5%
\Tuple{\segElems[1],\segElems[2]},\segElems[3]
\ArrowPadding{\xrightarrow{\segElems[4]}_{#2}}%
\else
\Tuple{\segElems[1],\segElems[2]},\segElems[3]
\ArrowPadding{\xrightarrow{\segElems[4]}_{#2}^{\segElems[5]}}%
\fi\fi\fi}
\else
{\ifnum\segElemslen<2%
\segElems[1]%
\else%
\ifnum\segElemslen<3%
\segElems[1],\segElems[2]%
\else%
\Tuple{\segElems[1],\segElems[2]},\segElems[3]%
\fi\fi}\fi%
}}}\xspace}
\NewDocumentCommand\ToClockProg{sm}{
\ensuremath{%
\IfBooleanTF{#1}{\xrightarrow{#2}}{%
% split into segments
\setsepchar{->}%
\readlist*\stepElems{#2}%
\foreachitem\stepElem\in\stepElems{%
% split a segment
\setsepchar{{|}}%
\readlist*\segElems{\stepElem}%
% the base for each segment
% possible pattern $1
% possible pattern $1$2
% possible pattern $1->$2
% possible pattern $1$2->$3
% possible pattern $1$2->$3$4
% possible pattern $1$2$3$4
% possible pattern $1$2$3$4->$5
% possible pattern $1$2$3$4->$5$6
\ifnum\stepElemcnt<\stepElemslen%
{\ifnum\segElemslen<3%
\segElems[1]%
\else%
\ifnum\segElemslen<5%
\segElems[1],\segElems[2]%
\else%
\Tuple{\segElems[1] , \segElems[2], \segElems[3]}, \segElems[4]%
\fi\fi}%
% need an arrow
{\ifnum\segElemslen<3%
\ArrowPadding{\xrightarrow{\segElems[2]}}%
\else%
\ifnum\segElemslen<4%
\ArrowPadding{\xrightarrow{\segElems[3]}}%
\else%
\ifnum\segElemslen<5%
\ArrowPadding{\xrightarrow{\segElems[3]}^{\segElems[4]}}%
\else%
\ifnum\segElemslen<6%
\ArrowPadding{\xrightarrow{\segElems[5]}}%
\else%
\ArrowPadding{\xrightarrow{\segElems[5]}^{\segElems[6]}}%
\fi\fi\fi\fi}
\else
{\ifnum\segElemslen<2%
\segElems[1]%
\else%
\ifnum\segElemslen<3%
\segElems[1],\segElems[2]%
\else%
\Tuple{\segElems[1] , \segElems[2], \segElems[3]}, \segElems[4]%
\fi\fi}%
\fi%
}}}\xspace}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% text 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\NewDocumentCommand\SOUNDLET{smm}{
We prove that \( \et[#2] \) is sound respective to \( \visaxioms[#2] \).
Assume two kv-stores \(\kvs,\kvs'\), two views \(\vi, \vi'\) and a transaction \( \txid \) for a client \( \cl \), a fingerprint \(\fp\) 
such that \(\ToET[#2]{ \kvs |  \vi | \fp | \kvs' | \vi' } \), the transaction \(\txid \in \NextTxid(\kvs, \cl)\)
and the new kv-sotre \( \kvs' =  \UpdateKV(\kvs,\vi,\fp,\txid) \).
Assume an abstract execution \(\aexec\) such that \(\kvs = \XToK(\aexec)\) and 
\( \aexecinv[\MR](\aexec, \cl') \subseteq \VisTrans(\kvs, \vi) \) for any client \( \cl' \).
Let a set of transactions \( \txidset = \VisTrans(\kvs, \vi) \) and 
a set of read-only transactions \( \txidsetrd \) such that
\IfBooleanTF{#1}{\(#3\)}{\[#3\]}
Let a new abstract execution \( \aexec' = \UpdateAExec(\aexec, \txidset \cup \txidsetrd, \fp, \txid) \).
We now check if \( \aexec' \) satisfies \cref{equ:et-to-visaxioms,equ:aexecinv-preserve}.
}

\NewDocumentCommand\COMPLETELET{m}{
We prove that \( \et[#1] \) is complete respective to \( \visaxioms[#1] \).
Assume an abstract execution \(\aexec\) that satisfies \( \visaxioms[#1] \)
and a transaction \(\txid \in \aexec\). 
Assume \Th{\idx} and \Th{(\idx+1)} cuts, \( \aexec' = (\aexec,\idx) \) and \( \aexec'' = (\aexec,\idx+1) \).
Let a transaction \( \txid[\cl](n) =  \aexec'' \setminus \aexec' \),
a set of transactions \( \txidset = \VISInv[\aexec](\txid[\cl](n)) \)
and a view \( \vi = \GetView(\aexec,\txidset) \).
}













%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Text & typesetting
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\rl}[1]{\textsc{#1}}
\newcommand{\sort}[1]{\protect\scalebox{0.9}{\textsc{#1}}}
\newcommand{\codeFont}[1]{\ensuremath{\mathtt{#1}}}
\newcommand{\commentFont}[1]{\ensuremath{\mathtt{#1}}}
\newcommand{\qqquad}{\qquad\quad}
\newcommand{\qqqquad}{\qquad\qquad}
\newenvironment{bracketarray}{%
    \left(
    \begin{array}{@{}l@{}}
}{%
    \end{array}
    \right)
}
\newenvironment{toparray}{%
    \begin{array}[t]{@{}l@{}}
}{%
    \end{array}
}

\NewEnviron{CENTERMULTLINELABEL}[1]{%
    \begin{gather}%
    \label{#1}%
    \begin{multlined}%
    \BODY%
    \end{multlined}%
    \end{gather}%
}

\NewEnviron{CENTERMULTLINENOLABEL}{%
    \begin{gather*}%
    \begin{multlined}%
    \BODY%
    \end{multlined}%
    \end{gather*}%
}
\NewDocumentEnvironment{centermultline}{ o }{%
\IfNoValueTF{#1}{%
    \CENTERMULTLINENOLABEL
}{%             
    \CENTERMULTLINELABEL{#1}
}%end if
}{%
\IfNoValueTF{#1}{%
    \endCENTERMULTLINENOLABEL
}{%             
    \endCENTERMULTLINELABEL
}%end if
}
\NewDocumentCommand{\arrayOrNot}{m}{
\setsepchar{\\}%
\readlist*\TEMPFORCHECKARRAY{#1}%
\IfEq{\TEMPFORCHECKARRAYlen}{1}{#1}{%
    \begin{array}{@{}l@{}} #1 \end{array}%
}
}

\newcommand{\V}[1]{\textsc{\lowercase{#1}}} % for logically expression
%\newcommand{\mypar}[1]{\vspace{\spacingabovemypar}\subsubsection*{\bf #1}}
\newcommand{\mypar}[1]{\subsubsection*{\bf #1}}
%\newcommand{\mypar}[1]{\vspace*{-5pt}\subparagraph*{#1}}
\newcommand{\CASE}[2]{\noindent{#1}: {#2}. }
\newcommand{\caseB}[1]{\CASE{Base case}{#1}}
\newcommand{\caseI}[1]{\CASE{Inductive case}{#1}}
\newcommand{\ih}{\textnormal{I.H.}\xspace}
\newcommand{\ie}{\textnormal{i.e.}\xspace}
\newcommand{\eg}{\textnormal{e.g.}\xspace}
\newcommand{\etal}{\textnormal{et al.}\xspace}
\newcommand{\todo}{{\color{red} TODO}}
\NewDocumentCommand{\func}{ m o }{
\IfNoValueTF{#2}{%
    \ensuremath{\mathsf{#1}}%
}{%
    \ensuremath{\mathsf{#1}\mathopen{}\left(#2\right)\mathclose{}}%
}
}
\NewDocumentCommand{\pred}{ m o }{
\IfNoValueTF{#2}{%
    \ensuremath{\mathtt{#1}}
}{%
    \ensuremath{\mathtt{#1}\mathopen{}\left(#2\right)\mathclose{}}
}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% General notations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\renewcommand{\implies}{\Rightarrow}
\newcommand{\stub}{\ensuremath{\_}}
\newcommand{\anyval}{\stub}
\newcommand{\fora}[1]{\ensuremath{\forall #1 \ldotp \;}}
\newcommand{\exsts}[1]{\ensuremath{\exists #1 \ldotp \;}}
\newcommand{\isundef}{\ensuremath{\uparrow}}
\newcommand{\isdef}{\ensuremath{\downarrow}}
\newcommand{\defiff}{\ensuremath{\mathbin{\stackrel{\textnormal{def}}{\Leftrightarrow}}}}
\newcommand{\defeq}{\ensuremath{\mathbin{\triangleq}}}
\newcommand{\Nat}{\ensuremath{\mathbb{N}}}
\newcommand{\nat}{\ensuremath{n}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Operators and Elements
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\DeclareMathOperator{\dom}{dom}
\NewDocumentCommand{\domOf}{o}{
\IfNoValueTF{#1}{%
    \ensuremath{\dom}%
}{%
    \ensuremath{\dom\left(#1\right)}%
}%
}
\newcommand{\rmto}[2]{\ensuremath{{\left[#1 \mapsto #2\right]}}}
\newcommand{\pset}[1]{\ensuremath{\mathcal{P}\left(#1\right)}}
\newcommand{\parfun}{\ensuremath{\rightharpoonup}}
\newcommand{\parfinfun}{\ensuremath{\xrightharpoonup{\mathit{fin}}}}
\newcommand{\pfm}{\parfinfun}
\newcommand{\compose}[1][]{\ensuremath{\bullet_{#1}}}
\newcommand{\denote}[1]{\ensuremath{\left\llbracket #1 \right\rrbracket}}
\newcommand{\eval}[2]{\ensuremath{\denote{#1}_{#2}}}
\newcommand{\projection}[1]{\ensuremath{\!\!\downharpoonright_{#1}}}
\NewDocumentCommand{\closure}{o}{%
    \IfNoValueTF{#1}{%
        \ensuremath{^{*}}%
    }{%
    \ensuremath{{#1}^{*}}%
    }%
}
\NewDocumentCommand{\rflx}{o}{%
    \IfNoValueTF{#1}{%
        \ensuremath{^{?}}%
    }{%
    \ensuremath{{#1}^{?}}%
    }%
}
\newcommand{\sub}[2]{\ensuremath{\left[ \sfrac{#2}{#1} \right]}}
\newcommand{\unitelem}[1][]{\ensuremath{\textbf{0}_{#1}}}
\newcommand{\lcat}{\ensuremath{\mathbb{::}}}
\newcommand{\abs}[1]{\ensuremath{\lvert #1 \rvert}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% archive
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\myset}[2]{\Set{#1}[#2]}
\newcommand{\Setcon}[2]{\Set{#1}[#2]}
\newcommand{\setcomp}[2]{\Set{#1}[#2]}
\newcommand{\erase}[2][]{\ensuremath{\llfloor #2 \rrfloor_{#1}}}
\newcommand{\clps}[2][]{\ensuremath{\erase[#1]{#2}}}
\newenvironment{rclarray}[1][t]{%
    \begin{array}[#1]{@{}r@{\ } c @{\ } l@{}}
}{%
    \end{array}
}
%\newcommand{\List}[1]{\ensuremath{\left[ #1 \right]}}
%**********************************************************************************************************************************
% For kv-store semantics
%**********************************************************************************************************************************
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Transactions and client
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\TxID}{\sort{TransID}}
\NewDocumentCommand{\Tx}{ o }{%
\IfNoValueTF{#1}{%
    \ensuremath{\visTx}%
}{%
    \ensuremath{\visTx[#1]}%
}
}
\NewDocumentCommand{\visTx}{ o }{%
\IfNoValueTF{#1}{%
    \ensuremath{\func{visTx}}%
}{%
    \ensuremath{\func{visTx}[#1]}%
}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Expressions and Booleans
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\Expr}{\sort{Expr}}
%\newcommand{\expr}{\codeFont{E}}
\newcommand{\evalE}[2][\stk]{\eval{#2}{#1}}
%\newcommand{\Booleans}{\sort{Bool}}
%\newcommand{\bool}{\ensuremath{\mathbb{B}}}
%\newcommand{\true}{\texttt{true}}
%\newcommand{\false}{\texttt{false}}
\newcommand{\boolnot}{\mathop{\texttt{not}}}
\newcommand{\booland}{\ensuremath{\mathbin{\texttt{and}}}}
\newcommand{\boolor}{\ensuremath{\mathbin{\texttt{or}}}}
%\newcommand{\Stacks}{\sort{Stack}}
%\newcommand{\stk}{\ensuremath{s}}
\newcommand{\Val}{\sort{Val}}
%\newcommand{\val}{\ensuremath{v}}
%\newcommand{\Vars}{\sort{Vars}}
%\newcommand{\var}{\pvar{x}}
%\newcommand{\ret}{\pvar{ret}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Syntax Transactions & Programs 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newcommand{\Transactions}{\sort{Trans}}
%\newcommand{\trans}{\codeFont{T}}
%\newcommand{\transpri}{\ensuremath{\trans_{p}}}
%\newcommand{\cmdpri}{\ensuremath{\cmd_{p}}}
\NewEnviron{transaction}{%
\setsepchar{\\}%
\readlist*\TEMPFORCHECKARRAY{\BODY}%
\left\lbrack%
\IfEq{\TEMPFORCHECKARRAYlen}{1}{}{
\begin{array}{@{}l@{}}%
}
\BODY
\IfEq{\TEMPFORCHECKARRAYlen}{1}{}{
\end{array}%
}
\right\rbrack%
}
%\newcommand{\ptrans}[1]{%
%\begin{transaction} #1 \end{transaction}%
%}
%\newcommand{\Commands}{\sort{Cmd}}
%\newcommand{\cmd}{\codeFont{C}}
%\newcommand{\Programs}{\sort{Prog}}
%\newcommand{\prog}{\codeFont{P}}
%\newcommand{\pskip}{\codeFont{skip}}
\newcommand{\pvar}[1]{\codeFont{#1}}
\newcommand{\pv}[1]{\var(#1)}
%\newcommand{\passign}[2]{\ensuremath{#1\mathbin{:=}#2}}
%\newcommand{\pmutate}[2]{\ensuremath{[#1]\mathbin{:=}#2}}
%\newcommand{\plookup}[2]{\ensuremath{#1\mathbin{:=}[#2]}}
\newcommand{\palloc}[2]{#1\mathbin{:=}\codeFont{alloc}(#2)}
%\newcommand{\passume}[1]{\codeFont{assume}(#1)}
\newcommand{\preturn}[1]{\codeFont{return}(#1)}
%\newcommand{\pseq}{\ensuremath{;}}
%\newcommand{\pchoice}{\ensuremath{\mathbin{+}}}
%\newcommand{\prepeat}{\ensuremath{^{*}}}
%\newcommand{\ppar}{\ensuremath{\mathbin{\|}}}
\newcommand{\pifs}[1]{\codeFont{if} \, (#1) \{}
\newcommand{\pifm}{\} \codeFont{else}\{ }
\newcommand{\pife}{\}}
%\newcommand{\pif}[3]{\pifs{#1} \  #2 \  \pifm \  #3 \pife}
\newcommand{\ploops}[1]{\codeFont{while} \, (#1) \{ }
\newcommand{\ploope}[1]{\}}
\newcommand{\ploop}[2]{\ploops{#1} #2 \ploope}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% snapshots
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newcommand{\Snapshots}{\sort{Snapshot}}
\NewDocumentCommand{\snapshot}{ o }{%
\IfNoValueTF{#1}{%
    \ensuremath{\func{snapshot}}%
}{%
    \ensuremath{\func{snapshot}[#1]}%
}
}
\newcommand{\sn}{\ensuremath{\sigma}}
%\renewcommand{\ss}{\sn}
\newcommand{\snset}{\ensuremath{\mathit{SS}}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% version, mkvs
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newcommand{\Versions}{\sort{Version}}
%\newcommand{\ver}{\ensuremath{\nu}}
\newcommand{\vilist}{\ensuremath{\mathcal{V}}}
%\newcommand{\Keys}{\sort{Key}}
%\newcommand{\key}{\ensuremath{k}}
%\newcommand{\keyset}{K}
\newcommand{\MKVSs}{\KVSs}
\newcommand{\mkvs}{\mathcal{K}}
\NewDocumentCommand{\valueOf}{ o }{%
\IfNoValueTF{#1}{%
    \ensuremath{\func{val}}%
}{%
    \ensuremath{\func{val}[#1]}%
}
}
\NewDocumentCommand{\wtOf}{ o }{%
\IfNoValueTF{#1}{%
    \ensuremath{\func{w}}%
}{%
    \ensuremath{\func{w}[#1]}%
}
}
\NewDocumentCommand{\rsOf}{ o }{%
\IfNoValueTF{#1}{%
    \ensuremath{\func{rs}}%
}{%
    \ensuremath{\func{rs}[#1]}%
}
}
\NewDocumentCommand{\updateKV}{ o }{%
\IfNoValueTF{#1}{%
    \ensuremath{\func{update}}%
}{%
    \ensuremath{\func{update}[#1]}%
}
}
\NewDocumentCommand{\nextTxid}{ o }{%
\IfNoValueTF{#1}{%
    \ensuremath{\func{nextTid}}%
}{%
    \ensuremath{\func{nextTid}[#1]}%
}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% views and conf.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newcommand{\Views}{\sort{Views}}
%\newcommand{\vienv}{\ensuremath{\mathcal{U}}}
%\newcommand{\vi}{\ensuremath{u}}
\newcommand{\viewleq}{\ensuremath{\sqsubseteq}}
\newcommand{\viewcup}{\ensuremath{\sqcup}}
\newcommand{\composeVI}{\compose[\vi]}
\newcommand{\unitVI}{\unitelem[\vi]}
%\newcommand{\Confs}{\sort{Conf}}
\NewDocumentCommand{\confOf}{ o }{%
\IfNoValueTF{#1}{%
\func{conf}%
}{%
\func{conf}[#1]%
}%
}
%\newcommand{\conf}{\ensuremath{\Gamma}}
\newcommand{\ThdEnv}{\sort{CEnv}}
\newcommand{\thdenv}{\ensuremath{\mathcal E}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Operations and Fingerprint
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\Ops}{\sort{Ops}}
\newcommand{\emptyop}{\ensuremath{\epsilon}}
%\newcommand{\op}{\ensuremath{o}}
%\newcommand{\Fingerprints}{\sort{Fp}}
%\newcommand{\fp}{\ensuremath{\mathcal{F}}}
\newcommand{\otR}{\textnormal{\texttt r}}
\newcommand{\otW}{\textnormal{\texttt w}}
\newcommand{\addO}{\mathbin{<\!\!\vartriangleleft}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% consistency models
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\ETs}{\ensuremath{\sort{ET}}}
%\newcommand{\ET}{\ensuremath{\mathsf{ET}}}
\newcommand{\OK}{\ensuremath{\mathsf{OK}}}
\newcommand{\etleq}{\ensuremath{\sqsubseteq}}
\newcommand{\csat}[1][]{\ensuremath{\triangleright_{#1}}}
\newcommand{\CM}{\ensuremath{\mathcal{CM}}}
\NewDocumentCommand{\CMs}{ o }{%
\IfNoValueTF{#1}{%
    \ensuremath{\func{CM}}%
}{%
    \ensuremath{\func{CM}[#1]}%
}
}
\NewDocumentCommand{\CMa}{ o }{%
\IfNoValueTF{#1}{%
    \ensuremath{\func{CM}}%
}{%
    \ensuremath{\func{CM}[#1]}%
}
}
\newcommand{\com}[1]{\ensuremath{\pred{com}[#1]}}
\NewDocumentCommand{\allowed}{ o }{%
\IfNoValueTF{#1}{%
    \ensuremath{\pred{allowed}}%
}{%
    \ensuremath{\pred{allowed}[#1]}%
}
}
\NewDocumentCommand{\closed}{ o }{%
\IfNoValueTF{#1}{%
    \ensuremath{\pred{closed}}%
}{%
    \ensuremath{\pred{closed}[#1]}%
}
}
\NewDocumentCommand{\lfpTx}{ o }{%
\IfNoValueTF{#1}{%
    \ensuremath{\func{lfpTx}}%
}{%
    \ensuremath{\func{lfpTx}[#1]}%
}
}
\NewDocumentCommand{\extRead}{ o }{%
\IfNoValueTF{#1}{%
    \ensuremath{\func{extRead}}%
}{%
    \ensuremath{\func{extRead}[#1]}%
}
}
\NewDocumentCommand{\clRead}{ o }{%
\IfNoValueTF{#1}{%
    \ensuremath{\func{clRead}}%
}{%
    \ensuremath{\func{clRead}[#1]}%
}
}
\NewDocumentCommand{\clWrite}{ o }{%
\IfNoValueTF{#1}{%
    \ensuremath{\func{clWrite}}%
}{%
    \ensuremath{\func{clWrite}[#1]}%
}
}
\NewDocumentCommand{\uaWrite}{ o }{%
\IfNoValueTF{#1}{%
    \ensuremath{\func{uaWrite}}%
}{%
    \ensuremath{\func{uaWrite}[#1]}%
}
}
%**********************************************************************************************************************************
% All the arrows
%**********************************************************************************************************************************
\newextarrow{\xrightarrowtriangle}{{5}{5}{5}{20}}{{\relbar}{\relbar}{\rightarrowtriangle}}
\newcommand{\toFP}[1]{\ensuremath{\xrightarrow{#1}}}
\newcommand{\toTRANS}{\ensuremath{\rightarrow}}
\newcommand{\toAEXEC}[1]{\ensuremath{\xrightarrow{#1}}}
\newcommand{\toCMD}[1]{\ensuremath{\xrightarrow{#1}}}
\newcommand{\toPROG}[1]{\ensuremath{\xrightarrow{#1}}}
\NewDocumentCommand{\toET}{ m O{\ET} }{%
\ensuremath{\xrightarrowtriangle{#1}_{#2}}
}
\newcommand{\toEDGE}[1]{\ensuremath{\xrightarrow{#1}}}
\newcommand\xrsquigarrow[1]{%
    \mathrel{%
        \begin{tikzpicture}[%
            baseline={(current bounding box.south)}
            ]
        \node[%
            ,inner sep=.44ex
            ,align=center
            ] (tmp) {$\scriptstyle #1$};
        \path[%
            ,draw,<-
            ,decorate,decoration={%
                ,zigzag
                ,amplitude=0.7pt
                ,segment length=1.2mm,pre length=3.5pt
                }
            ] 
        (tmp.south east) -- (tmp.south west);
        \end{tikzpicture}
        }
    }
\newcommand{\toLTS}[1]{\xrsquigarrow{#1}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% dependency graph
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\Dgraphs}{\ensuremath{\sort{Dgraphs}}}
\newcommand{\TtoOp}[1]{\ensuremath{\mathscr{#1}}}
\NewDocumentCommand{\graphOf}{ o }{%
\IfNoValueTF{#1}{%
    \ensuremath{\func{graphOf}}%
}{%
    \ensuremath{\func{graphOf}[#1]}%
}
}
\newcommand{\Gr}{\ensuremath{\mathcal{G}}}
\newcommand{\rd}{\ensuremath{\mathsf{rd}}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Abstract execution
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\Aexecs}{\sort{AbsExecs}}
%\newcommand{\aexec}{\mathcal{X}}
\newcommand{\Act}{\ensuremath{\sort{Act}}}
\NewDocumentCommand{\aeset}{ o }{%
\IfNoValueTF{#1}{%
    \ensuremath{\func{absExec}}%
}{%
    \ensuremath{\func{absExec}[#1]}%
}
}
\newcommand{\RP}{\func{RP}}
\newcommand{\LWW}{\func{LWW}}
\newcommand{\anarchicCM}{{\raisebox{-1.5pt}{\large \text{\CircledA}}}}
\newcommand{\anarchic}{\raisebox{-1.5pt}{{\small \text{\CircledA}}}}
\newcommand{\Ax}{\ensuremath{\mathcal{A}}}
\newcommand{\A}{\ensuremath{\mathsf{A}}}
\NewDocumentCommand{\cut}{ o }{%
\IfNoValueTF{#1}{%
    \ensuremath{\func{cut}}%
}{%
    \ensuremath{\func{cut}[#1]}%
}
}
\NewDocumentCommand{\getView}{ o }{%
\IfNoValueTF{#1}{%
    \ensuremath{\func{getView}}%
}{%
    \ensuremath{\func{getView}[#1]}%
}
}
\newcommand{\compatible}{\ensuremath{\mathop{\simeq}}}
\NewDocumentCommand{\visibleWrites}{ o }{%
\IfNoValueTF{#1}{%
    \ensuremath{\func{visibleWrites}}%
}{%
    \ensuremath{\func{visibleWrites}[#1]}%
}
}
\NewDocumentCommand{\KVtrace}{ o }{%
\IfNoValueTF{#1}{%
    \ensuremath{\func{KVtrace}}%
}{%
    \ensuremath{\func{KVtrace}[#1]}%
}
}
\NewDocumentCommand{\Ptraces}{ o }{%
\IfNoValueTF{#1}{%
    \ensuremath{\func{Ptraces}}%
}{%
    \ensuremath{\func{Ptraces}[#1]}%
}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% trace of aexec
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\tr}{\ensuremath{\tau}}
\NewDocumentCommand{\extend}{ o }{%
\IfNoValueTF{#1}{%
    \ensuremath{\func{extend}}%
}{%
    \ensuremath{\func{extend}[#1]}%
}
}
\NewDocumentCommand{\lastConf}{ o }{%
\IfNoValueTF{#1}{%
    \ensuremath{\func{lastConf}}%
}{%
    \ensuremath{\func{lastConf}[#1]}%
}
}
\NewDocumentCommand{\execs}{ o }{%
\IfNoValueTF{#1}{%
    \ensuremath{\func{execs}}%
}{%
    \ensuremath{\func{execs}[#1]}%
}
}
\newcommand{\interpr}[1]{\ensuremath{\llbracket #1 \rrbracket}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Achieve Command
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\T}{\txidset}
\newcommand{\MRd}{\MR}
\newcommand{\RF}{\WR}
\newcommand{\VO}{\WW}
\newcommand{\AD}{\RW}
\newcommand{\PO}{\SO}
\NewDocumentCommand{\OPtraces}{ o }{\Ptraces[#1]}
%**********************************************************************************************************************************
% Implementation: COPS, Clock-SI
%**********************************************************************************************************************************
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% For COPS systems
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\Repls}{\sort{Repls}}
%\newcommand{\repl}{r}
\newcommand{\viREPL}[1][\repl]{\ensuremath{\vi_{#1}}}
\NewDocumentCommand{\viCL}{O{\cl}}{\ensuremath{\vi_{#1}}}
\newcommand{\txidCOPS}[4]{\ensuremath{\txid_{(#1,#2)}^{(#3,#1,#4)}}}
\newcommand{\mkvsCOPS}{\ensuremath{\bar{\mkvs}}}
\newcommand{\vienvCOPS}{\ensuremath{\bar{\viewFun}}}
\newcommand{\dep}{dp}
\NewDocumentCommand{\depOf}{ o }{%
\IfNoValueTF{#1}{%
    \ensuremath{\func{deps}}%
}{%
    \ensuremath{\func{deps}[#1]}%
}
}
%**********************************************************************************************************************************
% Programming Logic in general
%**********************************************************************************************************************************
\newcommand{\CB}[1]{\texttt{#1}} % for permission
\newenvironment{parl}{%
    \begin{array}{@{}c || c@{}}
}{%
    \end{array}
}
\newenvironment{session}{%
    \begin{array}{@{}c@{}}
}{%
    \end{array}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Short-hand for programs
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\va}{\var(a)}
\newcommand{\vb}{\var(b)}
\newcommand{\vx}{\var(x)}
\newcommand{\vw}{\var(w)}
\newcommand{\vvx}{\var(vx)}
\newcommand{\vy}{\var(y)}
\newcommand{\vvy}{\var(vy)}
\newcommand{\vz}{\var(z)}
\newcommand{\vtmp}{\var(tmp)}


\newcommand{\vshiftname}{\textsf{vshift}\xspace}
\newcommand{\cancommitname}{\textsf{can-commit}\xspace}
\newcommand{\vshift}[5][\ET]{\ensuremath{\vshiftname_{#1}(#2, #3, #4, #5)}}
\newcommand{\cancommit}[4][\ET]{\ensuremath{\cancommitname_{#1}(#2, #3, #4)}}

\newcommand{\Counter}{\ensuremath{\mathsf{Counter}}}
\newcommand{\ctrinc}{\ensuremath{\mathsf{inc}}}
\newcommand{\ctrread}{\ensuremath{\mathsf{read}}}





