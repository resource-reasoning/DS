\subsection{Commutativity of some specifications in \cref{fig:execution.tests}}
\sx{CHECK LAST}
\begin{lemma}
    \label{lem:mr-comm}
    \(\MRd\) is commutative.
\end{lemma}
\begin{proof}
    Let assume:
    \[
        \mkvs_0, \vienv_0 \toET{\cl, \vi, \fp}[\MRd] \mkvs_1, \vienv_1 \toET{\cl', \vi', \fp'}[\MRd] \mkvs_2, \vienv_2 
    \]
    where \( \cl \neq \cl' \), \( \fora{ \key } (\otW, \key, \stub) \notin \fp \cap \fp' \) and \( \vi, \vi' \in \Views(\mkvs_0)\).
    Given the specification of \(\MRd\) (\cref{fig:execution-tests}), we know \( \vienv_1 = \vienv_0\rmto{\cl}{\vi''}\) for some \( \vi'' \) such that \( \vi \sqsubseteq \vi'' \).
    Similarly \( \vienv_2 = \vienv_1\rmto{\cl'}{\vi'''} \) for some \( \vi''' \) such that \(  \vi' \sqsubseteq \vi''' \). 
    Given that \( \cl \neq \cl' \), we can pick \( \mkvs'_1 \) and \( \vienv'_1 \) such that \( \mkvs'_1 \in \updateKV[\mkvs_0,\vi',\cl',\fp'] \) and \( \vienv'_1 = \vienv_0\rmto{\cl'}{\vi'''} \), so we have:
    \[
        \mkvs_0, \vienv_0 \toET{\cl', \vi', \fp'}[\MRd] \mkvs'_1, \vienv'_1 \toET{\cl, \vi, \fp}[\MRd] \mkvs_2, \vienv_2 
    \]
\end{proof}                                                                                    

\begin{lemma}
    \label{lem:mw-comm}
    \(\MW\) is commutative.
\end{lemma}
\begin{proof}
    Let assume:
    \[
        \mkvs_0, \vienv_0 \toET{\cl, \vi, \fp}[\MW] \mkvs_1, \vienv_1 \toET{\cl', \vi', \fp'}[\MW] \mkvs_2, \vienv_2 
    \]
    where \( \cl \neq \cl' \), \( \fora{ \key } (\otW, \key, \stub) \notin \fp \cap \fp' \) and \( \vi, \vi' \in \Views(\mkvs_0)\).
    Because the client \( \cl' \) can commit the fingerprint \( \fp' \) under \( \vi' \) to the kv-store \( \mkvs_1 \), it can also commit to \( \mkvs_0 \):
    \[
        \begin{array}{@{}l}
            \vi' \in \Views(\mkvs_0) \land \MW \vdash (\mkvs_1, \vi') \csat \fp', \vienv_2(\cl') \implies  \MW \vdash (\mkvs_0, \vi') \csat \fp', \vienv_2(\cl')
        \end{array}
    \]
    Assuming \( \mkvs'_1 \) and \( \vienv'_1 \) such that \( \mkvs'_1 \in \updateKV[\mkvs_0,\vi',\cl',\fp'] \) and \( \vienv'_1 = \vienv_0\rmto{\cl'}{\vienv_2(\vi')} \), we need to prove the specification for \( \MW \) (\cref{fig:execution-tests}):
    \[
        \fora{j,i, \key, \key'} j \leq \vi(\key) \wedge \WTx(\mkvs'_1(\key', i)) \toEDGE{\SO ?} \WTx(\mkvs'_1(\key, j)) \implies i \leq \vi'(\key')  \\
    \]
    For any key written by \( \cl' \), there is a new version of the key in \( \mkvs'_1 \).
    Given \( \vi \in \Views(\mkvs_0)\), those new versions installed by \( \cl' \) do not affect \( \vi \):
    \[
        \fora{j,i, \key} j \leq \vi(\key) \land \mkvs'_1(\key, j)\isdef \implies \mkvs_0(\key, j)\isdef
    \]
    so we have:
    \[
        \begin{array}{@{}l}
            \MW \vdash (\mkvs_0, \vi) \csat \fp, \vienv_2(\cl) \implies  \MW \vdash (\mkvs'_1, \vi) \csat \fp, \vienv_2(\cl)
        \end{array}
    \]
\end{proof}


\begin{lemma}
    \label{lem:ryw-comm}
    \(\RYW\) is commutative.
\end{lemma}
\begin{proof}
    Let assume:
    \[
        \mkvs_0, \vienv_0 \toET{\cl, \vi, \fp}[\RYW] \mkvs_1, \vienv_1 \toET{\cl', \vi', \fp'}[\RYW] \mkvs_2, \vienv_2 
    \]
    where \( \cl \neq \cl' \), \( \fora{ \key } (\otW, \key, \stub) \notin \fp \cap \fp' \) and \( \vi, \vi' \in \Views(\mkvs_0)\).
    %Assume \( \mkvs'_1 \) and \( \vienv'_1 \) such that \( \mkvs'_1 \in \updateKV[\mkvs_0,\vi',\cl',\fp'] \) and \( \vienv'_1 = \vienv_0\rmto{\cl'}{\vienv_2(\vi')} \).
    Given \( \fora{ \key } (\otW, \key, \stub) \notin \fp \cap \fp' \) and the specification for \( \RYW \) (\cref{fig:execution-tests}), we have:
    \[
        \fora{\key} (\otW, \key, \stub) \in \fp \implies \vienv_1(\cl)(\key) = \vienv_2(\cl)(\key) = \lvert \mkvs_1(\key) \rvert - 1 = \lvert \mkvs_2(\key) \rvert - 1
    \]
    We can pick \( \mkvs'_1 \) and \( \vienv'_1 \) such that \( \mkvs'_1 \in \updateKV[\mkvs_0,\vi',\cl',\fp'] \) and \( \vienv'_1 = \vienv_0\rmto{\cl'}{\vienv_2(\cl')} \), so we have:
    \[
        \mkvs_0, \vienv_0 \toET{\cl', \vi', \fp'}[\RYW] \mkvs'_1, \vienv'_1 \toET{\cl, \vi, \fp}[\RYW] \mkvs_2, \vienv_2 
    \]
\end{proof}

\begin{lemma}
    \label{lem:wfr-comm}
    \(\WFR\) is commutative.
\end{lemma}
\begin{proof}
    Let assume:
    \[
        \mkvs_0, \vienv_0 \toET{\cl, \vi, \fp}[\WFR] \mkvs_1, \vienv_1 \toET{\cl', \vi', \fp'}[\WFR] \mkvs_2, \vienv_2 
    \]
    where \( \cl \neq \cl' \), \( \fora{ \key } (\otW, \key, \stub) \notin \fp \cap \fp' \) and \( \vi, \vi' \in \Views(\mkvs_0)\).
    Because the client \( \cl' \) can commit the fingerprint \( \fp' \) under \( \vi' \) to the kv-store \( \mkvs_1 \), it can also commit to \( \mkvs_0 \):
    \[
        \begin{array}{@{}l}
            \vi' \in \Views(\mkvs_0) \land \WFR \vdash (\mkvs_1, \vi') \csat \fp', \vienv_2(\cl') \implies  \WFR \vdash (\mkvs_0, \vi') \csat \fp', \vienv_2(\cl')
        \end{array}
    \]
    Assume \( \mkvs'_1 \) and \( \vienv'_1 \) such that \( \mkvs'_1 \in \updateKV[\mkvs_0,\vi',\cl',\fp'] \) and \( \vienv'_1 = \vienv_0\rmto{\cl'}{\vienv_2(\vi')} \).
    For any key written by \( \cl' \), there is a new version of the key in \( \mkvs'_1 \).
    Given \( \vi \in \Views(\mkvs_0)\), those new versions installed by \( \cl' \) do not affect \( \vi \):
    \[
        \fora{j,i, \key} j \leq \vi(\key) \land \mkvs'_1(\key, j)\isdef \implies \mkvs_0(\key, j)\isdef
    \]
    so we have:
    \[
        \begin{array}{@{}l}
            \WFR \vdash (\mkvs_0, \vi) \csat \fp, \vienv_2(\cl) \implies \WFR \vdash (\mkvs'_1, \vi) \csat \fp, \vienv_2(\cl)
        \end{array}
    \]
\end{proof}

\begin{lemma}
    \label{lem:ua-comm}
    \(\UA\) is commutative.
\end{lemma}
\begin{proof}
    Let assume:
    \[
        \mkvs_0, \vienv_0 \toET{\cl, \vi, \fp}[\WFR] \mkvs_1, \vienv_1 \toET{\cl', \vi', \fp'}[\WFR] \mkvs_2, \vienv_2 
    \]
    where \( \cl \neq \cl' \), \( \fora{ \key } (\otW, \key, \stub) \notin \fp \cap \fp' \) and \( \vi, \vi' \in \Views(\mkvs_0)\).
    Given the specification for \( \UA \) (\cref{fig:execution-tests}) we have:
    \[
        \begin{array}{@{}l}
            \vi' \in \Views(\mkvs_0) \land \fora{ \key } (\otW, \key, \stub) \notin \fp \cap \fp' \land \\ 
            \quad \UA \vdash (\mkvs_1, \vi') \csat \fp', \vienv_2(\cl') \implies  \UA \vdash (\mkvs_0, \vi') \csat \fp', \vienv_2(\cl')
        \end{array}
    \]
    Assume \( \mkvs'_1 \) and \( \vienv'_1 \) such that \( \mkvs'_1 \in \updateKV[\mkvs_0,\vi',\cl',\fp'] \) and \( \vienv'_1 = \vienv_0\rmto{\cl'}{\vienv_2(\vi')} \).
    Because transactions write different keys, It is easy to see that \( \UA \vdash (\mkvs'_1, \vi) \csat \fp, \vienv_2(\cl) \).
\end{proof}

\begin{proposition}
    \( \CC \) and \( \PSI \) are commutative.
\end{proposition}
\begin{proof}
    Because \( \CC = \MR \cap \MW \cap \RYW \cap \WFR \) and all four are commutative (\cref{lem:mr-comm,lem:mw-comm,lem:ryw-comm,lem:wfr-comm}), so \( \CC \) is commutative by the \cref{prop:appendix-et-composition-2}.
    Similarly, since \( \PSI = \CC \cap \UA \) and \( \UA \) is commutative (\cref{lem:ua-comm}), so \( \PSI \) is commutative.
\end{proof}

\( \CP \) is not commutative because the view after update must be up-to-date.

\begin{lemma}
    \label{lem:ser-comm}
    \( \SER \) is commutative.
\end{lemma}
\begin{proof}
    Given the specification for \( \SER \) (\cref{fig:execution-tests}), the hypothesis that \( \vi, \vi' \in \Views(\mkvs_0) \) never holds.
\end{proof}

