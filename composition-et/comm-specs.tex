\subsection{Commutativity of some specifications in \cref{fig:execution.tests}}
\sx{CHECK LAST}
\begin{lemma}
    \label{lem:mr-comm}
    \(\MRd\) is commutative.
\end{lemma}
\begin{proof}
    Let assume:
    \[
        \mkvs_0, \viewFun_0 \toET{\cl, \vi, \opset}{\MRd} \mkvs_1, \viewFun_1 \toET{\cl', \vi', \opset'}{\MRd} \mkvs_2, \viewFun_2 
    \]
    where \( \cl \neq \cl' \), \( \fora{ \ke } (\otW, \ke, \stub) \notin \opset \cap \opset' \) and \( \vi, \vi' \in \Views(\mkvs_0)\).
    Given the specification of \(\MRd\) (\cref{fig:execution-tests}), we know \( \viewFun_1 = \viewFun_0\rmto{\cl}{\vi''}\) for some \( \vi'' \) such that \( \vi \sqsubseteq \vi'' \).
    Similarly \( \viewFun_2 = \viewFun_1\rmto{\cl'}{\vi'''} \) for some \( \vi''' \) such that \(  \vi' \sqsubseteq \vi''' \). 
    Given that \( \cl \neq \cl' \), we can pick \( \mkvs'_1 \) and \( \viewFun'_1 \) such that \( \mkvs'_1 \in \updKV{\mkvs_0,\vi',\cl',\f'} \) and \( \viewFun'_1 = \viewFun_0\rmto{\cl'}{\vi'''} \), so we have:
    \[
        \mkvs_0, \viewFun_0 \toET{\cl', \vi', \opset'}{\MRd} \mkvs'_1, \viewFun'_1 \toET{\cl, \vi, \opset}{\MRd} \mkvs_2, \viewFun_2 
    \]
\end{proof}                                                                                    

\begin{lemma}
    \label{lem:mw-comm}
    \(\MW\) is commutative.
\end{lemma}
\begin{proof}
    Let assume:
    \[
        \mkvs_0, \viewFun_0 \toET{\cl, \vi, \opset}{\MW} \mkvs_1, \viewFun_1 \toET{\cl', \vi', \opset'}{\MW} \mkvs_2, \viewFun_2 
    \]
    where \( \cl \neq \cl' \), \( \fora{ \ke } (\otW, \ke, \stub) \notin \opset \cap \opset' \) and \( \vi, \vi' \in \Views(\mkvs_0)\).
    Because the client \( \cl' \) can commit the fingerprint \( \f' \) under \( \vi' \) to the kv-store \( \mkvs_1 \), it can also commit to \( \mkvs_0 \):
    \[
        \begin{array}{@{}l}
            \vi' \in \Views(\mkvs_0) \land \MW \vdash (\mkvs_1, \vi') \csat \f', \viewFun_2(\cl') \implies  \MW \vdash (\mkvs_0, \vi') \csat \f', \viewFun_2(\cl')
        \end{array}
    \]
    Assuming \( \mkvs'_1 \) and \( \viewFun'_1 \) such that \( \mkvs'_1 \in \updKV{\mkvs_0,\vi',\cl',\f'} \) and \( \viewFun'_1 = \viewFun_0\rmto{\cl'}{\viewFun_2(\vi')} \), we need to prove the specification for \( \MW \) (\cref{fig:execution-tests}):
    \[
        \fora{j,i, \ke, \ke'} j \leq \vi(\ke) \wedge \WTx(\hh'_1(\ke', i)) \xrightarrow{\PO ?} \WTx(\hh'_1(\ke, j)) \implies i \leq \vi'(\ke')  \\
    \]
    For any key written by \( \cl' \), there is a new version of the key in \( \mkvs'_1 \).
    Given \( \vi \in \Views(\mkvs_0)\), those new versions installed by \( \cl' \) do not affect \( \vi \):
    \[
        \fora{j,i, \ke} j \leq \vi(\ke) \land \hh'_1(\ke, j)\isdef \implies \hh_0(\ke, j)\isdef
    \]
    so we have:
    \[
        \begin{array}{@{}l}
            \MW \vdash (\mkvs_0, \vi) \csat \f, \viewFun_2(\cl) \implies  \MW \vdash (\mkvs'_1, \vi) \csat \f, \viewFun_2(\cl)
        \end{array}
    \]
\end{proof}


\begin{lemma}
    \label{lem:ryw-comm}
    \(\RYW\) is commutative.
\end{lemma}
\begin{proof}
    Let assume:
    \[
        \mkvs_0, \viewFun_0 \toET{\cl, \vi, \opset}{\RYW} \mkvs_1, \viewFun_1 \toET{\cl', \vi', \opset'}{\RYW} \mkvs_2, \viewFun_2 
    \]
    where \( \cl \neq \cl' \), \( \fora{ \ke } (\otW, \ke, \stub) \notin \opset \cap \opset' \) and \( \vi, \vi' \in \Views(\mkvs_0)\).
    %Assume \( \mkvs'_1 \) and \( \viewFun'_1 \) such that \( \mkvs'_1 \in \updKV{\mkvs_0,\vi',\cl',\f'} \) and \( \viewFun'_1 = \viewFun_0\rmto{\cl'}{\viewFun_2(\vi')} \).
    Given \( \fora{ \ke } (\otW, \ke, \stub) \notin \opset \cap \opset' \) and the specification for \( \RYW \) (\cref{fig:execution-tests}), we have:
    \[
        \fora{\ke} (\otW, \ke, \stub) \in \f \implies \viewFun_1(\cl)(\ke) = \viewFun_2(\cl)(\ke) = \lvert \mkvs_1(\ke) \rvert - 1 = \lvert \mkvs_2(\ke) \rvert - 1
    \]
    We can pick \( \mkvs'_1 \) and \( \viewFun'_1 \) such that \( \mkvs'_1 \in \updKV{\mkvs_0,\vi',\cl',\f'} \) and \( \viewFun'_1 = \viewFun_0\rmto{\cl'}{\viewFun_2(\cl')} \), so we have:
    \[
        \mkvs_0, \viewFun_0 \toET{\cl', \vi', \opset'}{\RYW} \mkvs'_1, \viewFun'_1 \toET{\cl, \vi, \opset}{\RYW} \mkvs_2, \viewFun_2 
    \]
\end{proof}

\begin{lemma}
    \label{lem:wfr-comm}
    \(\WFR\) is commutative.
\end{lemma}
\begin{proof}
    Let assume:
    \[
        \mkvs_0, \viewFun_0 \toET{\cl, \vi, \opset}{\WFR} \mkvs_1, \viewFun_1 \toET{\cl', \vi', \opset'}{\WFR} \mkvs_2, \viewFun_2 
    \]
    where \( \cl \neq \cl' \), \( \fora{ \ke } (\otW, \ke, \stub) \notin \opset \cap \opset' \) and \( \vi, \vi' \in \Views(\mkvs_0)\).
    Because the client \( \cl' \) can commit the fingerprint \( \f' \) under \( \vi' \) to the kv-store \( \mkvs_1 \), it can also commit to \( \mkvs_0 \):
    \[
        \begin{array}{@{}l}
            \vi' \in \Views(\mkvs_0) \land \WFR \vdash (\mkvs_1, \vi') \csat \f', \viewFun_2(\cl') \implies  \WFR \vdash (\mkvs_0, \vi') \csat \f', \viewFun_2(\cl')
        \end{array}
    \]
    Assume \( \mkvs'_1 \) and \( \viewFun'_1 \) such that \( \mkvs'_1 \in \updKV{\mkvs_0,\vi',\cl',\f'} \) and \( \viewFun'_1 = \viewFun_0\rmto{\cl'}{\viewFun_2(\vi')} \).
    For any key written by \( \cl' \), there is a new version of the key in \( \mkvs'_1 \).
    Given \( \vi \in \Views(\mkvs_0)\), those new versions installed by \( \cl' \) do not affect \( \vi \):
    \[
        \fora{j,i, \ke} j \leq \vi(\ke) \land \hh'_1(\ke, j)\isdef \implies \hh_0(\ke, j)\isdef
    \]
    so we have:
    \[
        \begin{array}{@{}l}
            \WFR \vdash (\mkvs_0, \vi) \csat \f, \viewFun_2(\cl) \implies \WFR \vdash (\mkvs'_1, \vi) \csat \f, \viewFun_2(\cl)
        \end{array}
    \]
\end{proof}

\begin{lemma}
    \label{lem:ua-comm}
    \(\UA\) is commutative.
\end{lemma}
\begin{proof}
    Let assume:
    \[
        \mkvs_0, \viewFun_0 \toET{\cl, \vi, \opset}{\WFR} \mkvs_1, \viewFun_1 \toET{\cl', \vi', \opset'}{\WFR} \mkvs_2, \viewFun_2 
    \]
    where \( \cl \neq \cl' \), \( \fora{ \ke } (\otW, \ke, \stub) \notin \opset \cap \opset' \) and \( \vi, \vi' \in \Views(\mkvs_0)\).
    Given the specification for \( \UA \) (\cref{fig:execution-tests}) we have:
    \[
        \begin{array}{@{}l}
            \vi' \in \Views(\mkvs_0) \land \fora{ \ke } (\otW, \ke, \stub) \notin \opset \cap \opset' \land \\ 
            \quad \UA \vdash (\mkvs_1, \vi') \csat \f', \viewFun_2(\cl') \implies  \UA \vdash (\mkvs_0, \vi') \csat \f', \viewFun_2(\cl')
        \end{array}
    \]
    Assume \( \mkvs'_1 \) and \( \viewFun'_1 \) such that \( \mkvs'_1 \in \updKV{\mkvs_0,\vi',\cl',\f'} \) and \( \viewFun'_1 = \viewFun_0\rmto{\cl'}{\viewFun_2(\vi')} \).
    Because transactions write different keys, It is easy to see that \( \UA \vdash (\mkvs'_1, \vi) \csat \f, \viewFun_2(\cl) \).
\end{proof}

\begin{proposition}
    \( \CC \) and \( \PSI \) are commutative.
\end{proposition}
\begin{proof}
    Because \( \CC = \MRd \cap \MW \cap \RYW \cap \WFR \) and all four are commutative (\cref{lem:mr-comm,lem:mw-comm,lem:ryw-comm,lem:wfr-comm}), so \( \CC \) is commutative by the \cref{prop:appendix-et-composition-2}.
    Similarly, since \( \PSI = \CC \cap \UA \) and \( \UA \) is commutative (\cref{lem:ua-comm}), so \( \PSI \) is commutative.
\end{proof}

\( \CP \) is not commutative because the view after update must be up-to-date.

\begin{lemma}
    \label{lem:ser-comm}
    \( \SER \) is commutative.
\end{lemma}
\begin{proof}
    Given the specification for \( \SER \) (\cref{fig:execution-tests}), the hypothesis that \( \vi, \vi' \in \Views(\mkvs_0) \) never holds.
\end{proof}

