\subsection{Commutativity \( \updateKV \)}

A desirable property that one would request from execution test is compositionality:
the consistency model induced by a composite execution test can be recovered from the consistency 
models generated by each execution test: that is, 
\[ 
\forall \ET_1, \ET_2. \CMs(\ET_1 \cap \ET_2) = \CMs(\ET_1) \cap \CMs(\ET_2).
\]
However, execution tests do not always satisfy this property.
We find that if \( \ET_1 \) and \( \ET_2 \) satisfies certain constraints, 
the above holds (\cref{thm:et-comm}).
Before showing the \cref{thm:et-comm},
we first define \emph{conflict} (\cref{def:conflict-commit})
and composition of \( \updateKV \).

\begin{definition}
\label{def:conflict-commit}
Two triples $(\cl_1, \fp_1)$ and $(\cl_2, \fp_2)$ are 
conflicting if either $\cl_1 = \cl_2$, or there exists a key $\key$ such that 
$(\otW, \key, \stub) \in \fp_1, (\otW, \key, \stub) \in \fp_2$. 

An execution test is $\ET$ is \emph{commutative} if, whenever $(\cl_1, \vi_1, \fp_1)$, 
$(\cl_2, \vi_2, \fp_2)$ are non-conflicting, and $\vi_1, \vi_2 \in \Views(\mkvs_0)$,  
then for any $\mkvs_0, \mkvs', \vienv, \vienv'$ we have that 
\[
\begin{array}{l}
(\mkvs_0, \vienv) \toET{(\cl_1, \fp_1)}
\stub \toET{(\cl_2, \fp_2)} (\mkvs', \vienv') \implies
(\mkvs_0, \vienv) \toET{(\cl_2, \fp_2)} 
\stub \toET{(\cl_1, \fp_1)} (\mkvs', \vienv')
\end{array}
\]
\end{definition}

Given two non-conflict commits, it is possible to swap the commit order as shown in \cref{prop:updatekv.comm}.
The \cref{lem:updatekv.explicit} and then \cref{cor:updatekv.singlecell} shows that
swapping the operations of one key yields the same result.
Given \cref{cor:updatekv.singlecell}, then \cref{prop:updatekv.comm} holds.

\begin{lemma}[Swapping Operation]
\label{lem:updatekv.explicit}
Let $\mkvs$ be a kv-store, $\vi \in \Views(\mkvs)$, $\txid \in \TxID$ and $\fp \in \pset{\Ops}$. 
Let also $\key \in \Keys$. Then
\begin{enumerate}
    \item\label{item:updatekv.explicit.none} 
        $\fora{\val} (\otR, \key, \val) \notin \fp \land (\otW, \key, \val) \notin \fp \implies \updateKV[\mkvs, \vi, \fp, \txid](\key) = \mkvs(\key)$
\item\label{item:updatekv.explicit.rd} 
    $\fora{\val} (\otR, \key, \stub) \in \fp \land (\otW, \key, \val) \notin \fp 
    \implies 
    \updateKV[\mkvs, \vi, \fp, \txid](\key) =
    \begin{array}[t]{@{}l@{}}
    \text{let} \ (\val', \txid', \txidset') = \mkvs(\key, \max<(\vi(\key))) \\
    \text{in} \ \mkvs(\key)\rmto{\max<(\vi(\key))}{(\val', \txid', \txidset' \cup \{\txid\})}
    \end{array}
    $
\item\label{item:updatekv.explicit.wr} 
    $
    \begin{array}[t]{@{}l@{}}
    \fora{ \val, \val'}(\otR, \key, \val) \notin \fp \land (\otW, \key, \val) \in \fp 
    \implies \updateKV[\mkvs, \vi, \fp, \txid](\key) = \mkvs(\key) \lcat (\val, \txid, \emptyset)
    \end{array}
    $
\item\label{item:updatekv.explicit.rdwr}
    $
    \fora{\val} (\otR, \key, \stub) \in \fp \land (\otW, \key, \val) \in \fp 
    \implies 
    \updateKV[\mkvs,\vi,\fp,\txid](\key) = 
    \begin{array}[t]{@{}l@{}}
    \text{let} \ (\val', \txid', \txidset') = \mkvs(\key, \max(\vi(\key)))  \\
    \text{in} \ \mkvs(\key)\rmto{\max(\vi(\key))}{(\val', \txid', \txidset' \cup \{\txid\}) } \lcat (\val, \txid, \emptyset)
    \end{array}
    $
\end{enumerate}
\end{lemma}

\begin{proof}
All the four statements are proved by induction on $\fp$, by keeping the variable $\mkvs$ universally quantified in the inductive hypothesis. 
Statement \cref{item:updatekv.explicit.rd} and \cref{item:updatekv.explicit.wr} requires 
proving \cref{item:updatekv.explicit.none} first, while Statement \cref{item:updatekv.explicit.rdwr} requires proving all the other statements. 
Fix then an arbitrary $\key \in \Keys$.
\begin{enumerate}
	\item 
	Suppose that for any $\val$, $(\otR, \key, \val) \notin \fp$ and $(\otW, \key, \val)) \notin \fp$. We prove that $\updateKV[\mkvs, \vi, \fp, \txid](\key) = 
	\mkvs(\key)$.
	\begin{itemize}
        \item \caseB{$\fp = \emptyset$} in this case we have that 
		\[
		\updateKV[\mkvs, \vi, \emptyset, \txid](\key) \stackrel{\cref{eq:updatekv}}{=} \mkvs(\key).
		\]
    \item  
        Suppose that $\fp = \fp' \uplus \{(\otR, \key', \val')\}$ for some $\key', \val'$. Because we are assuming that 
		$(\otR, \key, \val) \notin \fp$ for any $\val \in \Val$, then it must be the case that 
		\begin{equation}
		\label{eq:updatekv.explicit.none.keneqkepRD}
		\key \neq \key'.
		\end{equation}
		Also, we have that $(\otR,\key, \val) \notin \fp'$ and $(\otW, \key, \val) \notin \fp$ for any $\val \in \Val$. 
		By inductive hypothesis we can assume 
		\begin{equation}
		\forall \mkvs'.\;\updateKV[\mkvs', \vi, \fp', \txid](\key) = \mkvs'(\key)
		\label{eq:updatekv.explicit.none.IHrd}
		\end{equation} 
		Therefore we have 
		\begin{align*}
        \updateKV[\mkvs, \vi, \fp, \txid](\key) 
            & =  
            \updateKV[\mkvs, \vi, \fp' \uplus \Set{(\otR, \key', \val')}, \txid](\key) \\
            & \stackrel{\cref{eq:updatekv}}{=}
            \begin{multlined}[t]
                \text{let} \ (\val', \txid', \txidset') = \mkvs(\key', \max_{<}(\vi(\key))) \\
                \text{in} \ \updateKV[\mkvs\rmto{\key'}{\mkvs(\key')\rmto{\max_{<}(\vi(\key'))}{\left(\val', \txid', \txidset' \cup \Set{\txid}\right)}}, \vi, \fp', \txid](\key) 
            \end{multlined} \\
            & \stackrel{\cref{eq:updatekv.explicit.none.IHrd}}{=}
            \begin{multlined}[t]
		    \text{let} \ (\val', \txid', \txidset') = \mkvs(\key', \max_{<}(\vi(\key'))) \\
            \text{in} \ \mkvs\rmto{\key'}{\mkvs(\key')\rmto{\max_{<}(\vi(\key'))}{\left(\val', \txid', \txidset' \Set{\txid}\right)}}(\key) 
            \end{multlined} \\
            &\stackrel{\cref{eq:updatekv.explicit.none.keneqkepRD}}{=} 
		    \text{let} \ (\val', \txid', \txidset') = \mkvs(\key', \max_{<}(\vi(\key'))) \text{ in } \mkvs(\key) \big) \\
            & = \mkvs(\key)
		\end{align*}

		\item Suppose that $\fp = \fp' \uplus \Set{(\otW, \key', \val')}$ for some $\val' \in \Val$. Then it must be the 
		case that 
		\begin{equation}
		\label{eq:updatekv.explicit.none.keneqkepWR}
		\key \neq \key'
		\end{equation}
		Also, we have that $(\otR,\key, \val) \notin \fp'$ and $(\otW, \key, \val) \notin \fp$ for any $\val \in \Val$. 
		By inductive hypothesis we can assume 
		\begin{equation}
		\forall \mkvs'.\;\updateKV[\mkvs', \vi, \fp', \txid](\key) = \mkvs'(\key)
		\label{eq:updatekv.explicit.none.IHwr}
		\end{equation}
		Therefore we have 
        \begin{align*}
            \updateKV[\mkvs, \key, \fp, \txid](\key)
            & =
            \updateKV[\mkvs, \key, \fp \uplus \{(\otW, \key', \val')\}, \txid](\key) \\
            & \stackrel{\cref{eq:updatekv}}{=} 
            \updateKV[\mkvs\rmto{\key'}{\mkvs(\key')\lcat (\val', \txid, \emptyset)}, \vi, \fp, \txid ](\key)  \\
            &\stackrel{\cref{eq:updatekv.explicit.none.IHwr}}{=}
            \mkvs\rmto{\key'}{\mkvs(\key') \lcat (\val', \txid, \emptyset)}(\key) \\
            & \stackrel{\cref{eq:updatekv.explicit.none.keneqkepWR}}{=} \mkvs(\key)
		\end{align*}
	\end{itemize}

	\item Suppose $(\otR, \key, \stub) \in \fp$, and $(\otW, \key, \val) \notin \fp$ for all $\val \in \Val$. 
        Let $(\val, \txid', \txidset) = \mkvs(\key, \max_{<}(\vi(\key)))$. We prove that 
    \[
        \updateKV[\mkvs, \vi, \fp, \txid](\key) = \mkvs(\key)\rmto{\vi(\key)}{(\val, \txid', \txidset \cup \{\txid\})}
    \]
		\begin{itemize}
        \item \caseB{$\fp = \emptyset$} this case is vacuous, as $(\otR, \key, \val) \notin \fp$ for all $\val \in \Val$, 
		against the assumption that $(\otR, \key, \stub) \in \fp$. 

		\item Suppose that $\fp = \fp' \cup \Set{(\otR, \key', \stub)}$ for some $\key'$. 
            We have two possible cases: 
			\begin{enumerate}
			\item $\key = \key'$, in which case we know that $(\otR, \key, \val') \notin \fp'$ for all $\val' \in \Val$ because of 
			the assumptions that we make on the structure of $\fp$. 
            By \cref{lem:updatekv.explicit}\cref{item:updatekv.explicit.none} we have that
			\begin{equation}
            \fora{ \mkvs' } \updateKV[\mkvs', \vi, \fp', \txid](\key) = \mkvs'(\key).
			\label{eq:updatekv.explicit.rd.applynone}
			\end{equation}
			In this case we have that 
            \begin{align*}
                \updateKV[\mkvs, \vi, \fp, \txid](\key) 
                & =
                \updateKV[\mkvs,\vi, \fp' \uplus \Set{(\otR, \key, \val')}, \txid](\key) \\
                & \stackrel{\cref{eq:updatekv}}{=} 
                \updateKV[\mkvs\rmto{\key}{\mkvs(\key)\rmto{\max_{<}(\vi(\key))}{(\val, \txid', \txidset \cup \Set{\txid})}}, \vi, \fp', \txid](\key) \\
                & \stackrel{\cref{eq:updatekv.explicit.rd.applynone}}{=}
                \mkvs\rmto{\key}{\mkvs(\key)\rmto{\max_{<}(\vi(\key))}{(\val, \txid', \txidset \cup \Set{\txid})}}(\key) \\
                & = \mkvs(\key)\rmto{\max(\vi(\key))}{(\val, \txid', \txidset \cup \Set{\txid})}
            \end{align*}
            \item \( \key \neq \key' \).
			In this case we know that because $(\otR, \key, \stub) \in \fp$, then 
			it must be $(\otR, \key, \stub) \in \fp'$. We also know that $\forall \val.(\otW, \key, \val) \notin \fp$. 
			By the inductive hypothesis, we have that 
			\begin{equation}
			\label{eq:updatekv.explicit.rd.IHrd}
            \begin{array}{l}
			\fora{ \mkvs' } \updateKV[\mkvs', \vi, \fp', \txid](\key) 
            = \mkvs'(\key)\rmto{\max_{<}(\vi(\key))}{(\val, \txid', \txidset \cup \Set{\txid})}
            \end{array}
			\end{equation}
			In this case we have 
			\begin{align*}
                \updateKV[\mkvs, \vi, \fp, \txid](\key) 
                & =
                \updateKV[\mkvs, \vi, \fp' \uplus \Set{(\otR, \key', \stub)}, \txid](\key) \\
                & \stackrel{\cref{eq:updatekv}}{=}
			    \updateKV[\mkvs\rmto{\key'}{\stub}, \vi, \fp, \txid](\key) \\
                & \stackrel{\cref{eq:updatekv.explicit.rd.IHrd}}{=} 
                \mkvs\rmto{\key'}{\stub}(\key)\rmto{\max_{<}(\vi(\key))}{(\val, \txid', \txidset' \cup \Set{\txid})} \\
                &\stackrel{\key \neq \key'}{=}
                \mkvs(\key)\rmto{\max_{<}(\vi(\key))}{(\val, \txid', \txidset' \cup \Set{\txid})}
			\end{align*}
		\end{enumerate}

		\item $\fp = \fp' \uplus \Set{(\otW, \key', \val')}$ for some $\val' \in \Val$. Because $(\otW, \key, \val) \notin \fp$ 
		for any $\val \in \Val$, it must be the case that 
		\begin{equation}
		\key \neq \key'
		\label{eq:updatekv.explicit.rd.keneqkepWR}
		\end{equation}
		Because $(\otR, \key, \stub) \in \fp$, it must also be the case that $(\otR, \key, \stub) \in \fp'$. By the inductive hypothesis, 
		we have that 
		\begin{equation}
		\label{eq:updatekv.explicit.rd.IHwr}
        \begin{array}{l}
        \fora{ \mkvs' }\updateKV[\mkvs', \vi, \fp', \txid](\key) 
        {} = \mkvs(\key)\rmto{\max_{<}(\vi(\key))}{(\val, \txid', \txidset \cup \{(\txid)\})}
        \end{array}
		\end{equation}
		It follows that 
        \begin{align*}
		    \updateKV[\mkvs, \vi, \fp, \txid](\key) 
            & =
            \updateKV[\mkvs, \vi, \fp' \uplus \Set{(\otW, \key', \val')}, \txid](\key) \\
            & \stackrel{\cref{eq:updatekv}}{=}
		    \updateKV[\mkvs\rmto{\key'}{\stub}, \vi, \fp', \txid](\key) \\
            & \stackrel{\cref{eq:updatekv.explicit.rd.IHwr}}{=} 
            \mkvs(\rmto{\key'}{\stub}(\key)\rmto{\max_{<}(\vi(\key))}{(\val, \txid', \txidset \cup \Set{\txid})} \\
            & \stackrel{\cref{eq:updatekv.explicit.rd.keneqkepWR}}{=} 
            \mkvs(\key)\rmto{\max_{<}(\vi(\key))}{(\val, \txid', \txidset \cup \{\txid\})}
        \end{align*}
	\end{itemize}
	
	\item Suppose that $(\otW, \key, \val) \in \fp$ for some $\val \in \Val$, and 
	$(\otR, \key, \val') \notin \fp$ for any $\val' \in \Val$. We prove that 
	$\updateKV[\mkvs, \vi, \fp, \txid](\key) = \mkvs(\key) \lcat (\val, \txid, \emptyset)$. 
		\begin{itemize}
        \item \caseB{$\fp = \emptyset$} This case is vacuous, as $(\otW, \key, \val) \in \fp$.
		\item Suppose that $\fp = \fp' \uplus \{(\otR, \key', \stub)\}$ for some 
		$\key'$. Note that, because we are assuming that $\{(\otR, \key, \val')\} \notin \fp$ 
		for all $\val' \in \Val$, then it must be the case that 
		\begin{equation}
		\key \neq \key'
		\label{eq:updatekv.explicit.wr.kenqkepRD}
		\end{equation}	
		We also have that $\{(\otR, \key, \val')\} \notin \fp'$ for all $\val' \in \Val$, and 
		$(\otW, \key, \val) \in \fp'$. By the inductive hypothesis we have that 
		\begin{equation}
        \fora{\mkvs'} \updateKV[\mkvs', \vi, \fp', \txid](\key) = \mkvs'(\key) \lcat (\val, \txid, \emptyset)
		\label{eq:updatekv.explicit.wr.IHrd}
		\end{equation}
		Therefore, we have that 
        \begin{align*}
		    \updateKV[\mkvs, \vi, \fp, \txid]]\key) 
            & = 
            \updateKV[\mkvs, \vi, \fp' \uplus \Set{(\otR, \key', \stub)}, \txid](\key) \\
            & \stackrel{\cref{eq:updatekv}}{=}
		    \updateKV[\mkvs\rmto{\key'}{\stub}, \vi, \fp',\txid ](\key) \\
            & \stackrel{\cref{eq:updatekv.explicit.wr.IHrd}}{=} 
            \mkvs\rmto{\key'}{\stub}(\key) \lcat (\val, \txid, \emptyset) \\
            & \stackrel{\cref{eq:updatekv.explicit.wr.kenqkepRD}}{=} 
		    \mkvs(\key) \lcat (\val, \txid, \emptyset)
		\end{align*}
		
		\item Suppose that $\fp = \fp' \uplus \{(\otW, \key', \val')\}$ 
		for some $\key'$. We distinguish two possible cases:
			\begin{enumerate}
			\item $\key = \key'$. In this case the structure of $\fp$ also imposes that $\val = \val'$, 
			and $(\otW, \key, \val'') \notin \fp'$ for any $\val'' \in \Val$. Furthermore, we have 
			that $(\otR, \key, \val'') \notin \fp'$ for any $\val'' \in \Val$. 
			By \cref{lem:updatekv.explicit}\cref{item:updatekv.explicit.none}, we have that 
			\begin{equation}
            \fora{\mkvs'} \updateKV[\mkvs', \vi, \fp', \txid](\key) = \mkvs(\key)
			\label{eq:updatekv.explicit.wr.applynone}
			\end{equation}
			from which it follows 
            \begin{align*}
			    \updateKV[\mkvs, \vi, \fp, \txid](\key) 
                & =
			    \updateKV[\mkvs, \vi, \fp' \uplus \Set{(\otW, \key', \val')}, \txid](\key) \\
                & = 
                \updateKV[\mkvs, \vi, \fp' \uplus \Set{(\otW, \key, \val)}, \txid](\key) \\
                & \stackrel{\cref{eq:updatekv}}{=} 
                \updateKV[\mkvs\rmto{\key}{\mkvs(\key) \lcat (\val, \txid, \emptyset)}, \vi, \fp', \txid](\key) \\
                & \stackrel{\cref{eq:updatekv.explicit.wr.applynone}}{=} 
                \mkvs\rmto{\key}{\mkvs(\key) \lcat (\val, \txid, \emptyset)}(\key) \\
                & = \mkvs(\key) \lcat (\val, \txid, \emptyset)
			\end{align*}
			
            \item \( \key \neq \key'\).
			In this case we have that, because $(\otW, \key, \val) \in \fp$, then it must 
			be $(\otW, \key, \val) \in \fp'$. Furthermore, we also have that $(\otR, \key, \val'') \notin \fp'$ 
			for any $\val'' \in \Val$. By the inductive hypothesis, we have that 
			\begin{equation}
            \fora{\mkvs'}\updateKV[\mkvs', \vi, \fp', \txid](\key) = \mkvs(\key) \lcat (\val, \txid, \emptyset)
			\label{eq:updatekv.explicit.wr.IHwr}
			\end{equation}
			from which it follows 
            \begin{align*}
			    \updateKV[\mkvs, \vi, \fp, \txid](\key) 
                & =
                \updateKV[\mkvs, \vi, \fp' \uplus \Set{(\otW,\key', \val')}, \txid](\key) \\
                & \stackrel{\cref{eq:updatekv}}{=}
			    \updateKV[\mkvs\rmto{\key'}{\stub}, \vi, \fp, \txid](\key) \\
                & \stackrel{\cref{eq:updatekv.explicit.wr.IHwr}}{=} 
                \mkvs\rmto{\key'}{\stub}(\key) \lcat (\val, \txid, \emptyset) \\
                & \stackrel{\key \neq \key'}{=} 
                \mkvs(\key) \lcat (\val, \txid, \emptyset)
			\end{align*}
			\end{enumerate}
		\end{itemize}
		
		\item Suppose that $(\otW, \key, \val) \in \fp$ for some $\val \in \Val$, and $(\otR, \key, \stub) \in \fp$. 
		Let $\mkvs(\key, \vi) = (\val', \txid', \txidset')$. We prove that 
        \[ 
            \updateKV[\mkvs, \vi, \fp, \txid](\key) = 
            \mkvs(\key)\rmto{\vi(\key)}{(\val', \txid', \txidset' \cup \{\txid\})} \lcat (\val, \txid, \emptyset)
        \]
		by induction on $\fp$:
			\begin{itemize}
			\item $\fp = \emptyset$; this case is vacuous.
			\item $\fp = \fp' \uplus \{(\otR, \key', \stub)\}$. We distinguish two cases, according to 
			whether $\key = \key'$ or $\key \neq \key'$. If $\key = \key'$, then we know that 
			$(\otW, \key, \val) \in \fp'$ and $(\otR, \key, \val'') \notin \fp$ for any $\val'' \in \Val$. 
			By Lemma \cref{lem:updatekv.explicit}\cref{item:updatekv.explicit.wr} we have that 
			\begin{equation}
            \fora{\mkvs'}\updateKV[\mkvs,\vi,\fp',\txid](\key) = \mkvs(\key) \lcat (\val, \txid, \emptyset)
			\label{eq:updateKV.explicit.rdwr.applyWR}
			\end{equation}
			from which it follows that 
			\begin{align*}
			    \updateKV[\mkvs, \vi, \fp, \txid](\key)
                & =
                \updateKV[\mkvs, \vi, \fp' \uplus \Set{(\otR, \key', \stub)}, \txid](\key) \\
                & = 
			    \updateKV[\mkvs, \vi, \fp' \uplus \Set{(\otR, \key, \stub)}, \txid](\key) \\
                & \stackrel{\cref{eq:updatekv}}{=}
                \updateKV[\mkvs\rmto{\key}{\mkvs(\key)\rmto{\max_{<}(\vi(\key))}{(\val', \txid', \txidset' \cup \Set{\txid})}}, \vi, \fp', \txid](\key) \\
                & \stackrel{\cref{eq:updateKV.explicit.rdwr.applyWR}}{=} 
                \mkvs\rmto{\key}{\mkvs(\key)\rmto{\max_{<}(\vi(\key))}{(\val', \txid', \txidset' \cup \{\txid\})}}(\key) \lcat (\val, \txid, \emptyset) \\
                & = 
			    \mkvs(\key)\rmto{\max_{<}(\vi(\key))}{(\val' \txid', \txidset' \cup \{\txid\}} \lcat (\val, \txid, \emptyset)
            \end{align*}
			If $\key \neq \key'$, then we have that both $(\otR, \key, \stub) \in \fp'$ and 
			$(\otW, \key, \val) \in \fp'$. In this case, by the inductive hypothesis we have that 
			\begin{equation}
			\label{eq:updatekv.explicit.rdwr.IHrd}
            \begin{array}{l}
            \fora{\mkvs'}\updateKV[\mkvs,\vi,\fp',\txid](\key) = 
            \mkvs'(\key)\rmto{\max_{<}(\vi(\key))}{(\val', \txid', \txidset' \cup \Set{\txid})} \lcat (\val, \txid, \emptyset)
            \end{array}
			\end{equation}
			from which it follows that 
            \begin{align*}
			    \updateKV[\mkvs, \vi, \fp,\txid](\key)
                & = 
                \updateKV[\mkvs, \vi, \fp' \uplus \Set{(\otR, \key', \stub)}, \txid](\key) \\
                & \stackrel{\cref{eq:updatekv}}{=}
			    \updateKV[\mkvs\rmto{\key'}{\stub}, \vi, \fp', \txid](\key) \\
                & \stackrel{\cref{eq:updatekv.explicit.rdwr.IHrd}}{=} 
                \mkvs\rmto{\key'}{\stub}(\key)\rmto{\max_{<}(\vi(\key))}{(\val', \txid', \txidset' \cup \Set{\txid})} \lcat (\val, \txid, \emptyset) \\
                & = 
                \mkvs(\key)\rmto{\max_{<}(\vi(\key))}{(\val', \txid', \txidset' \cup \Set{\txid})} \lcat (\val, \txid, \emptyset)
            \end{align*}
			
			\item $\fp = \fp' \uplus \Set{(\otW, \key'', \val'')}$ for some $\key'', \val''$. Again, 
			there are two possible cases to consider. If $\key = \key''$, then $\val = \val''$ because of the structure imposed on $\fp$.
			Furthermore, we have that 
			$(\otR, \key, \stub) \in \fp'$ and $(\otW, \key, \val''') \notin \fp$ for all $\val''' \in \Val$.
			By \cref{lem:updatekv.explicit}\cref{item:updatekv.explicit.rd} we have that 
			\begin{equation}
			\label{eq:updatekv.explicit.rdwr.applyRD}
            \begin{array}{l}
            \fora{\mkvs'}\updateKV[\mkvs', \vi, \fp', \txid](\key) =
            \mkvs'(\key)\rmto{\max_{<}(\vi(\key))}{(\val', \txid', \txidset' \cup \Set{\txid})} 
            \end{array}
			\end{equation}
			We have that 
            \begin{align*}
			    \updateKV[\mkvs,\vi,\txid, \fp](\key)
                & =
                \updateKV[\mkvs, \vi, \fp' \cup \Set{(\otW, \key'', \val'')}, \txid](\key) \\
                & =
			    \updateKV[\mkvs,\vi, \fp' \cup \Set{(\otW, \key, \val)}, \txid](\key) \\
                & \stackrel{\cref{eq:updatekv}}{=}
			    \updateKV[\mkvs\rmto{\key}{\mkvs(\key) \lcat (\val, \txid, \emptyset)}, \vi, \fp', \txid](\key) \\
                & \stackrel{\cref{eq:updatekv.explicit.rdwr.applyRD}}{=}
			    \mkvs\rmto{\key}{\mkvs(\key) \lcat (\val, \txid, \emptyset)}(\key)\rmto{\max_{<}(\vi(\key))}{(\val', \txid', \txidset' \cup \Set{\txid})} \\
                & =
			    \left(\mkvs(\key) \lcat (\val, \txid, \emptyset)\right)\rmto{\max_{<}(\vi(\key))}{(\val', \txid', \txidset' \cup \Set{\txid})} \\
                & = 
			    \mkvs(\key)\rmto{\max_{<}(\vi(\key))}{(\val',\txid', \txidset' \cup \Set{\txid})} \lcat (\val, \txid, \emptyset)
            \end{align*}
			Finally, if $\key \neq \key'$, then we have that $(\otR, \key, \stub) \in \fp'$ and $(\otW, \key, \val) \in \fp'$. 
			By the inductive hypothesis, we obtain 
			\begin{equation}
			\label{eq:updatekv.explicit.rdwr.IHwr}
            \begin{array}{l}
            \fora{\mkvs'}\updateKV[\mkvs', \vi, \fp', \txid](\key) = 
            \mkvs'(\key)\rmto{\max_{<}(\vi(\key))}{(\val', \txid', \txidset' \cup \Set{\txid})} \lcat (\val, \txid, \emptyset)
            \end{array}
			\end{equation}
			It follows that 
            \begin{align*}
			    \updateKV[\mkvs, \vi, \fp, \txid](\key)
                & =
                \updateKV[\mkvs, \vi, \fp' \uplus \Set{(\otW, \key', \stub)}, \txid](\key) \\
                & \stackrel{\cref{eq:updatekv}}{=} 
			    \updateKV[\mkvs\rmto{\key'}{\stub}, \vi, \txid, \fp'](\key) \\
                & \stackrel{\cref{eq:updatekv.explicit.rdwr.IHwr}}{=}
                \mkvs\rmto{\key'}{\stub}(\key)\rmto{\max_{<}(\vi(\key))}{(\val', \txid', \txidset' \cup \Set{\txid})} \lcat (\val, \txid, \emptyset) \\
                & =
                \mkvs\rmto{\max_{<}(\vi(\key))}{(\val', \txid', \txidset' \cup \Set{\txid})} \lcat (\val, \txid, \emptyset)
            \end{align*}
			\end{itemize}
\end{enumerate}
\end{proof}

In the following, given a version $\ver = (\val, \txid', \txidset)$ and a set of 
transaction identifiers $\txidset'$, we let $\ver \oplus \txidset' = (\val, \txid', \txidset \cup \txidset')$. 
Clearly the operator $\oplus$ is commutative over sets of transactions: 
$\forall \ver, \txidset, \txidset'.\; (\ver \oplus \txidset) \oplus \txidset' = (\ver \oplus \txidset') \oplus \txidset = 
\ver \oplus (\txidset \cup \txidset')$.

\begin{corollary}
\label{cor:updatekv.singlecell}
Let $\mkvs$ be a kv-store, $\vi \in \Views(\mkvs)$, $\txid \in \TxID$ and $\fp \in \pset{\Ops}$. 
Let also $\key \in \Keys$. Then 
\begin{enumerate}
\item\label{item:updatekv.singlecell.noview} 
    $ 
    \begin{array}[t]{l}
        \fora{ i } 0 \leq i < \abs{\mkvs(\key) } - 1 \land i \neq \max_{<}(\vi(\key)) 
        \implies \updateKV[\mkvs, \vi, \fp, \txid](\key, i) = \mkvs(\key, i)
    \end{array}
    $
\item\label{item:updatekv.singlecell.rd} $\forall \val. (\otR, \key, \stub) \in \fp \implies \updateKV[\mkvs,\vi, \fp,\txid](\key, \vi) = \mkvs(\key, \max_{<}(\vi(\key))) \oplus \Set{\txid}$
\item\label{item:updatekv.singlecell.nord} $\forall \val.(\otR,\key, \val) \notin \fp \implies \updateKV[\mkvs,\vi, \fp,\txid](\key,\vi) = \mkvs(\key, \max_{<}(\vi(\key)))$
\item\label{item:updatekv.singlecell.wr} 
    $
    \begin{array}[t]{l}
        \fora{\val} (\otW, \key, \val) \in \fp \implies
        \lvert \updateKV[\mkvs,\vi,\fp,\txid](\key) \rvert = 
        \lvert \mkvs(\key) \rvert + 1 \wedge
        \updateKV[\mkvs,\vi,\fp,\txid](\key, \lvert \mkvs(\key) \rvert) = (\val, \txid, \emptyset)
    \end{array}
    $
\item\label{item:updatekv.singlecell.nowr} $\forall \val.(\otW, \key, \val) \notin \fp \implies \lvert \updateKV[\mkvs,\vi,\fp,\txid](\key) \rvert = \lvert \mkvs(\key) \rvert$
\end{enumerate}
\end{corollary}

\begin{proof}
A simple consequence of \cref{lem:updatekv.explicit}.
\end{proof}

\begin{proposition}
\label{prop:updatekv.comm}
\label{prop:swap-update}
Let $\mkvs \in \MKVSs$, $\vi_1, \vi_2 \in \Views(\mkvs)$ and let $\cl_1, \cl_2 \in \Clients$ 
be such that $\cl_1 \neq \cl_2$. 
Let also $\fp_1, \fp_2 \in \pset{\Ops}$ be such that 
whenever $(\otW, \key, \stub) \in \fp_1$ for some key $\key$, then 
$(\otW, \key, \val) \notin \fp_2$ for all $\val \in \Val$. Then 
\[
\begin{array}{l}
\Set{ \updateKV[\mkvs_1, \vi_2, \fp_2, \cl_2]}[\mkvs_1 \in \updateKV[\mkvs, \vi_1, \fp_1, \cl_1]] = 
\Set{ \updateKV[\mkvs_2, \vi_1, \fp_1, \cl_1]}[\mkvs_2 \in \updateKV[\mkvs, \vi_2, \fp_2, \cl_2]]\\
\end{array}
\]
\end{proposition}

\begin{proof}
Assume $\mkvs_1 = \updateKV[\mkvs, \vi_1, \fp_1, \txid_1]$, $\mkvs_2 = \updateKV[\mkvs, \vi_2, \fp_2, \txid_2]$. 
It suffices to show that for any key $\key$:
\[\lvert \updateKV[\mkvs_1, \vi_2, \fp_2, \txid_2](\key) \rvert = \lvert 
\updateKV[\mkvs_2, \vi_1, \fp_1, \txid_1](\key) \rvert
\]
and for any index $i$ such that \( 0 \leq i < \lvert \updateKV[\mkvs_1, \vi_2, \fp_2, \txid_2](\key) \rvert \):
\[
\updateKV[\mkvs_1, \vi_2,\fp_2, \txid_2](\key, i) = \updateKV[\mkvs_2, \vi_1, \fp_1, \txid_1](\key_1)
\]

First, fix a key $\key \in \Keys$. Note that if $(\otW, \key, \stub) \in \fp_1$, then 
by Corollary \ref{cor:updatekv.singlecell} we have that $\lvert \updateKV[\mkvs, \vi_1, \fp_1, \txid_1](\key) \rvert = 
\lvert \mkvs(\key) \rvert$. Because $\fp_1$ is not conflicting with $\fp_2$, it must be the case 
that $\forall \val.(\otW,\key,\val) \notin \fp_2$, and therefore by \cref{cor:updatekv.singlecell} 
we have that 
\[
\lvert \updateKV[\mkvs_1, \vi_2, \fp_2, \txid_2](\key) \rvert = \lvert \mkvs_1(\key) \rvert = \lvert \mkvs(\key) \rvert + 1.
\] 
Similarly, because $\forall \val.(\otW,\key,\val)\notin \fp_2$ 
and $(\otW,\key,\stub) \in \fp_1$, then 
\[
\lvert \updateKV[\mkvs_2, \vi_1, \fp_1, \txid_1](\key) \rvert = \lvert \mkvs_2(\key) \rvert + 1 
= \lvert \updateKV[\mkvs, \vi_2, \fp_2, \txid_2](\key) \rvert = \lvert \mkvs(\key) \rvert + 1
\]
Therefore, if $(\otW, \key, \stub) \in \fp_1$, we have that 
\[ 
\lvert \updateKV[\mkvs_2, \vi_1, \fp_1, \txid_1](\key) \rvert = 
\lvert \updateKV[\mkvs_1(\key), \vi_2, \fp_2, \txid_2](\key) \rvert
\]

Analogously, we can prove that this claim holds also when $(\otW, \key, \stub) \in \fp_2$. 
Finally, if $(\forall \val.(\otW,\key,\stub) \notin \fp_1) \land (\forall \val.(\otW,\key,\val) \notin \fp_2)$, 
then by \cref{cor:updatekv.singlecell} we have that 
\[
\lvert \updateKV[\mkvs_1, \vi_2, \fp_2, \txid_2](\key) \rvert = 
\lvert \mkvs_1(\key) \rvert = \lvert \updateKV[\mkvs, \vi_1, \fp_1, \txid_1](\key) \rvert = \lvert \mkvs(\key) \rvert
\]
and
\[
\lvert \updateKV[\mkvs_2, \vi_1, \fp_1, \txid_1](\key) \rvert = 
\lvert \mkvs_2(\key) \rvert = \lvert \updateKV[\mkvs, \vi_2, \fp_2, \txid_2](\key) \rvert = \lvert \mkvs(\key) \rvert
\]
This concludes the proof that, for any key $\key \in \Keys$,
\[ \lvert \updateKV[\mkvs_1,\vi_2,\fp_2,\txid_2] \rvert = 
\lvert \updateKV[\mkvs_2,\vi_1,\fp_1,\txid_1] \rvert
\]

Next, fix a key $\key$ and a index $i$ such that $0 \leq i < \abs{ \mkvs(\key) } - 1$. 
We show that:
\[ 
    \updateKV[\mkvs_1,\vi_2,\fp_2,\txid_2](\key, i) = \updateKV[\mkvs_2, \vi_1, \fp_1, \txid_1](\key, i)
\]
by performing a case analysis on $\vi_1$: 
\begin{enumerate}
    \item $i \neq \max_{<}(\vi_1(\key))$. 
In this case, by \cref{cor:updatekv.singlecell}\cref{item:updatekv.singlecell.noview}, 
we have that 
\begin{equation}
\mkvs_1(\key, i) = \updateKV[\mkvs, \vi_1, \fp_1, \txid_1](\key, i) = \mkvs(\key, i)
\label{eq:v1.nord.hh1}
\end{equation}
and 
\begin{equation}
\updateKV[\mkvs_2, \vi_1, \fp_1, \txid_1](\key, i) = \mkvs_2(\key, i)
\label{eq:v1.nord.uhh2}
\end{equation}
Then, we have three possible sub-cases: 
\begin{enumerate}
    \item $i \neq \max_{<}(\vi_2(\key))$: in this case, by \cref{cor:updatekv.singlecell}\cref{item:updatekv.singlecell.noview} we have that 
\[
\updateKV[\mkvs_1, \vi_2, \fp_2, \txid_2](\key, i) = 
\mkvs_1(\key, i) \stackrel{\cref{eq:v1.nord.hh1}}{=} \mkvs(\key, i)
\]
and
\[
\updateKV[\mkvs_2, \vi_1, \fp_1, \txid_1] \stackrel{\cref{eq:v1.nord.uhh2}}{=} \mkvs_2(\key,i) = 
\updateKV[\mkvs, \vi_2, \fp_2, \txid_2](\key, i) = \mkvs(\key, i)
\]
\item $i = \max_{<}(\vi_2(\key))$, and $(\otR, \key, \stub) \notin \fp_2$. In this case the proof is analogous to the previous case, 
only \cref{cor:updatekv.singlecell}\cref{item:updatekv.singlecell.nord} needs to be applied in place 
of \cref{cor:updatekv.singlecell}\cref{item:updatekv.singlecell.noview}.
\item $i = \max_{<}(\vi_2(\key))$, and $(\otR, \key, \stub) \in \fp_2$. In this case we can apply \cref{cor:updatekv.singlecell}\cref{item:updatekv.singlecell.rd}, 
and deduce that 
\begin{equation}
\updateKV[\mkvs_1, \vi_2, \fp_2, \txid_2](\key, i) = \mkvs_1(\key, i) \oplus \Set{\txid_2}
\label{eq:v1.nord.v2.rd.uhh1}
\end{equation}
\begin{equation}
\mkvs_2(\key, i) = \updateKV[\mkvs, \vi_2, \fp_2, \txid_2](\key, i) = \mkvs(\key,i) \oplus \Set{\txid_2}
\label{eq:v1.nord.v2.rd.hh2}
\end{equation}
It follows that 
\[
\begin{array}{l}
\updateKV[\mkvs_1, \vi_2, \fp_2, \txid_2](\key, i) \stackrel{\cref{eq:v1.nord.v2.rd.uhh1}}{=} \mkvs_1(\key, i) \oplus \Set{\txid_2} \stackrel{\cref{eq:v1.nord.hh1}}{=} \mkvs(\key, i) \oplus \Set{\txid_2}\\
\updateKV[\mkvs_2,\vi_1,\fp_1, \txid_1](\key, i) \stackrel{\cref{eq:v1.nord.uhh2}}{=} \mkvs_2(\key, i) \stackrel{\cref{eq:v1.nord.v2.rd.hh2}}{=} \mkvs(\key, i) \oplus \Set{\txid_2}
\end{array}
\]
\end{enumerate}
\item $i = \max_{<}(\vi_1(\key))$, $(\otR, \key, \stub) \notin \fp_1$. This case is similar to the previous one: we can infer 
that Equations \cref{eq:v1.nord.hh1} and \cref{eq:v1.nord.uhh2} are valid in this case using \cref{cor:updatekv.singlecell}
\cref{item:updatekv.singlecell.nord}, then we can proceed by performing a case analysis on $\vi_2$ and $\fp_2$ as in the previous case.
\item $i = \max_{<}(\vi_1(\key))$, $\otR,\ ke, \stub) \in \fp_1$. We can apply \cref{cor:updatekv.singlecell}\cref{item:updatekv.singlecell.rd} 
to deduce the following: 
\begin{equation}
\mkvs_1(\key, i) = \updateKV[\mkvs, \vi_1, \fp_1, \txid_1](\key, i) = \mkvs(\key, i) \oplus \Set{\txid_1}
\label{eq:v1.rd.hh1}
\end{equation}
and
\begin{equation}
\updateKV[\mkvs_2, \vi_1, \fp_1, \txid_1](\key, i) = \mkvs_2(\key, i) \oplus \Set{\txid_1}
\label{eq:v1.rd.uhh2}
\end{equation}
We have two different sub-cases to consider: 
\begin{enumerate}
\item $i \neq \max_{<}(\vi_2(\key))$, or $i = \max_{<}(\vi_2(\key))$ with $(\otR,\key,\stub) \notin \fp_2$. In this case, we can apply either 
\cref{cor:updatekv.singlecell}\cref{item:updatekv.singlecell.noview} (if $i \neq \max_{<}(\vi_2(\key))$ ), or 
\cref{cor:updatekv.singlecell} \cref{item:updatekv.singlecell.nord} (if $i = \max_{<}(\vi_2(\key))$ and $(\otR, \key, \stub) \notin \fp_2$), 
to obtain 
\[
\updateKV[\mkvs_1, \vi_2, \fp_2, \txid_2](\key, i) = \mkvs_1(\key, i) \stackrel{\cref{eq:v1.rd.hh1}}{=} \mkvs(\key, i) \oplus \Set{\txid_1}
\]
and
\[
\updateKV[\mkvs_2, \vi_1, \fp_1, \txid_1](\key, i) \stackrel{\cref{eq:v1.rd.uhh2}}{=} \mkvs_2(\key, i) \oplus \Set{ \txid_1 } = 
\mkvs(\key, i) \oplus \Set{ \txid_1 }
\]
\item if $i = \max_{<}(\vi_2(\key))$ and $(\otR, \key, \stub) \in \fp_2$, then by \cref{cor:updatekv.singlecell}\cref{item:updatekv.singlecell.rd} 
we obtain that 
\begin{equation}
\mkvs_2(\key, i) = \updateKV[\mkvs, \vi_2, \fp_2, \txid_2](\key, i) = \mkvs(\key, i) \oplus \Set{\txid_2}
\label{eq:v1.rd.v2.rd.hh2}
\end{equation}
\begin{equation}
\updateKV[\mkvs_1, \vi_2, \fp_2, \txid_2](\key, i) = \mkvs_1(\key, i) \oplus \Set{ \txid_2}
\label{eq:v1.rd.v2.rd.uhh1}
\end{equation}
From these facts it follows that
\[
\begin{array}{l}
\updateKV[\mkvs_1, \vi_2, \fp_2, \txid_2](\key, i) \stackrel{\cref{eq:v1.rd.v2.rd.uhh1}}{=} 
\mkvs_1(\key, i) \oplus \Set{\txid_2} \stackrel{\cref{eq:v1.rd.hh1}}{=} 
(\mkvs(\key, i) \oplus \Set{\txid_1}) \oplus \Set{\txid_2 } = \mkvs(\key, i) \oplus \Set{\txid_1, \txid_2}\\
\updateKV[\mkvs_2, \vi_1, \fp_1, \txid_1](\key, i) \stackrel{\cref{eq:v1.rd.uhh2}}{=} 
\mkvs_2(\key, i) \oplus \Set{\txid_1} 
\stackrel{\cref{eq:v1.rd.v2.rd.hh2}}{=} (\mkvs(\key, i) \oplus \Set{\txid_2}) \oplus \Set{\txid_1} = \mkvs(\key, i) \oplus \Set{\txid_1, \txid_2}
\end{array}
\]
\end{enumerate}
\end{enumerate}

Next, note that if $\forall \val \in \Val.\;(\otW,\key,\val) \notin \fp_1 \land (\otW, \key, \val) \notin 
\fp_2$, then 
\[
\lvert \updateKV[\mkvs_1, \vi_2, \fp_2, \txid_2](\key) \rvert = \lvert \mkvs(\key) \rvert = 
\lvert \updateKV[\mkvs_2, \vi_1, \fp_1, \txid_1](\key) \rvert
\]
Because we have already proved that 
\[
    \fora{ i = 0,\cdots, \lvert \mkvs(\key) \rvert } \updateKV[\mkvs_1, \vi_2, \fp_2, \txid_2](\key, i) = \updateKV[\mkvs_2, \vi_1, \fp_1, \txid_1](\key, i)
\]
It follows that
\[ 
    \updateKV[\mkvs_1, \vi_2, \fp_2, \txid_2](\key) = \updateKV[\mkvs_2,\vi_1,\fp_1,\txid_1](\key)
\]
and there is nothing left to prove.

Suppose then that  either $(\otW, \key, \val) \in \fp_1$ or $(\otW,\key, \val) \in \fp_2$ 
for some $\val$. Without loss of generality, let $(\otW,\key,\val) \in \fp_1$ for some $\val \in \Val$; 
because we are assuming that $\fp_1$ does not conflict with $\fp_2$, then 
it must be the case that $\forall \val' \in \Val.\;(\otW,\key,\val') \notin \fp_2$. 
Using \cref{cor:updatekv.singlecell}\cref{item:updatekv.singlecell.nowr} and 
\cref{cor:updatekv.singlecell}\cref{item:updatekv.singlecell.wr}, 
\[
\begin{array}{l}
\updateKV[\mkvs_1, \vi_2, \fp_2, \txid_2](\key, \lvert \mkvs(\key) \rvert) = 
\mkvs_1(\key, \lvert \mkvs(\key) \rvert) = \updateKV[\mkvs, \vi_1, \fp_1, \txid_1](\lvert \mkvs(\key) \rvert) = (\val, \txid_1, \emptyset)\\
{} \land \updateKV[\mkvs_2, \vi_1,\fp_1, \txid_1](\key, \lvert, \mkvs(\key) \rvert) = (\val, \txid_1, \emptyset)
\end{array}
\]
We have now proved that if $(\otW,\key,\val) \in \fp_1$, then $\lvert \updateKV[\mkvs_1, \vi_2, \fp_2, \txid_2] \rvert = 
\lvert \updateKV[\mkvs_2, \vi_1, \fp_1, \txid_1] \rvert$, and for all 
$i=0,\cdots, \lvert \updateKV[\mkvs_1, \vi_2, \fp_2, \txid_2] \rvert - 1$, 
$\updateKV[\mkvs_1,\vi_2, \fp_2, \txid_2](\key, i) = \updateKV[\mkvs_2, \vi_1, \fp_1, \txid_1](\key, i)$. 
This concludes the proof that for any key \( \key \), $\updateKV[\mkvs_1,\vi_2,\fp_2,\txid_2](\key) = 
\updateKV[\mkvs_2,\vi_1,\fp_1,\txid_1](\key)$, and therefore 
$\updateKV[\mkvs_1, \vi_2, \fp_2, \txid_2] = \updateKV[\mkvs_2, \vi_1,\fp_1,\txid_1]$.
\end{proof}
