\subsection{Commutativity \( \updateKV \)}

A desirable property that one would request from execution test is compositionality:
the consistency model induced by a composite execution test can be recovered from the consistency 
models generated by each execution test: that is, 
\[ 
\forall \ET_1, \ET_2. \CMs(\ET_1 \cap \ET_2) = \CMs(\ET_1) \cap \CMs(\ET_2).
\]
However, execution tests do not always satisfy this property.
We find that if \( \ET_1 \) and \( \ET_2 \) satisfies certain constraints, 
the above holds (\cref{thm:et-comm}).
Before showing the \cref{thm:et-comm},
we first define \emph{conflict} (\cref{def:conflict-commit})
and composition of \( \updateKV \).

\begin{definition}
\label{def:conflict-commit}
Two triples $(\cl_1, \fp_1)$ and $(\cl_2, \fp_2)$ are 
conflicting if either $\cl_1 = \cl_2$, or there exists a key $\ke$ such that 
$(\otW, \ke, \stub) \in \fp_1, (\otW, \ke, \stub) \in \fp_2$. 

An execution test is $\ET$ is \emph{commutative} if, whenever $(\cl_1, \vi_1, \fp_1)$, 
$(\cl_2, \vi_2, \fp_2)$ are non-conflicting, and $\vi_1, \vi_2 \in \Views(\hh_0)$,  
then for any $\hh_0, \mkvs', \viewFun, \viewFun'$ we have that 
\[
\begin{array}{l}
(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_1, \fp_1)}_{\ET} 
\stub \xrightarrowtriangle{(\cl_2, \fp_2)}_{\ET} (\mkvs', \viewFun') \implies
(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_2, \fp_2)}_{\ET} 
\stub \xrightarrowtriangle{(\cl_1, \fp_1)}_{\ET} (\mkvs', \viewFun')
\end{array}
\]
\end{definition}

Given two non-conflict commits, it is possible to swap the commit order as shown in \cref{prop:updatekv.comm}.
The \cref{lem:updatekv.explicit} and then \cref{cor:updatekv.singlecell} shows that
swapping the operations of one key yields the same result.
Given \cref{cor:updatekv.singlecell}, then \cref{prop:updatekv.comm} holds.

\begin{lemma}[Swapping Operation]
\label{lem:updatekv.explicit}
Let $\mkvs$ be a kv-store, $\vi \in \Views(\mkvs)$, $\txid \in \TxID$ and $\fp \in \powerset{\Ops}$. 
Let also $\ke \in \Keys$. Then
\begin{enumerate}
    \item\label{item:updatekv.explicit.none} 
        $\fora{\val} (\otR, \ke, \val) \notin \fp \wedge (\otW, \ke, \val) \notin \fp \implies \updateKV(\mkvs, \vi, \fp, \txid)(\ke) = \mkvs(\ke)$
\item\label{item:updatekv.explicit.rd} 
    $\fora{\val} (\otR, \ke, \stub) \in \fp \wedge (\otW, \ke, \val) \notin \fp 
    \implies 
    \updateKV(\mkvs, \vi, \fp, \txid)(\ke) =
    \begin{array}[t]{@{}l@{}}
    \text{let} \ (\val', \txid', \T') = \mkvs(\ke, \max<(\vi(\ke))) \\
    \text{in} \ \mkvs(\ke)\rmto{\max<(\vi(\ke))}{(\val', \txid', \T' \cup \{\txid\})}
    \end{array}
    $
\item\label{item:updatekv.explicit.wr} 
    $
    \begin{array}[t]{@{}l@{}}
    \fora{ \val, \val'}(\otR, \ke, \val) \notin \fp \wedge (\otW, \ke, \val) \in \fp 
    \implies \updateKV(\mkvs, \vi, \fp, \txid)(\ke) = \mkvs(\ke) \lcat \List{(\val, \txid, \emptyset)}
    \end{array}
    $
\item\label{item:updatekv.explicit.rdwr}
    $
    \fora{\val} (\otR, \ke, \stub) \in \fp \wedge (\otW, \ke, \val) \in \fp 
    \implies 
    \updateKV(\mkvs,\vi,\fp,\txid)(\ke) = 
    \begin{array}[t]{@{}l@{}}
    \text{let} \ (\val', \txid', \T') = \mkvs(\ke, \max(\vi(\ke)))  \\
    \text{in} \ \mkvs(\ke)\rmto{\max(\vi(\ke))}{(\val', \txid', \T' \cup \{\txid\}) } \lcat \List{(\val, \txid, \emptyset)} 
    \end{array}
    $
\end{enumerate}
\end{lemma}

\begin{proof}
All the four statements are proved by induction on $\fp$, by keeping the variable $\mkvs$ universally quantified in the inductive hypothesis. 
Statement \cref{item:updatekv.explicit.rd} and \cref{item:updatekv.explicit.wr} requires 
proving \cref{item:updatekv.explicit.none} first, while Statement \cref{item:updatekv.explicit.rdwr} requires proving all the other statements. 
Fix then an arbitrary $\ke \in \Keys$.
\begin{enumerate}
	\item 
	Suppose that for any $\val$, $(\otR, \ke, \val) \notin \fp$ and $(\otW, \ke, \val)) \notin \fp$. We prove that $\updateKV(\mkvs, \vi, \fp, \txid)(\ke) = 
	\mkvs(\ke)$.
	\begin{itemize}
        \item \caseB{$\fp = \emptyset$} in this case we have that 
		\[
		\updateKV(\mkvs, \vi, \emptyset, \txid)(\ke) \stackrel{\cref{eq:updatekv}}{=} \mkvs(\ke).
		\]
    \item  
        Suppose that $\fp = \fp' \uplus \{(\otR, \ke', \val')\}$ for some $\ke', \val'$. Because we are assuming that 
		$(\otR, \ke, \val) \notin \fp$ for any $\val \in \Val$, then it must be the case that 
		\begin{equation}
		\label{eq:updatekv.explicit.none.keneqkepRD}
		\ke \neq \ke'.
		\end{equation}
		Also, we have that $(\otR,\ke, \val) \notin \fp'$ and $(\otW, \ke, \val) \notin \fp$ for any $\val \in \Val$. 
		By inductive hypothesis we can assume 
		\begin{equation}
		\forall \mkvs'.\;\updateKV(\mkvs', \vi, \fp', \txid)(\ke) = \mkvs'(\ke)
		\label{eq:updatekv.explicit.none.IHrd}
		\end{equation} 
		Therefore we have 
		\[  
        \begin{array}{@{}l@{}}
        \updateKV(\mkvs, \vi, \fp, \txid)(\ke) 
		\begin{rclarray}
            {}& = & 
            \updateKV(\mkvs, \vi, \fp' \uplus \Set{(\otR, \ke', \val')}, \txid)(\ke) \\
            & \stackrel{\cref{eq:updatekv}}{=} &
            \text{let} \ (\val', \txid', \T') = \mkvs(\ke', \max_{<}(\vi(\ke))) \\
            & & \text{in} \ \updateKV(\mkvs\rmto{\ke'}{\mkvs(\ke')\rmto{\max_{<}(\vi(\ke'))}{\left(\val', \txid', \T' \cup \Set{\txid}\right)}}, \vi, \fp', \txid)(\ke) \\
            & \stackrel{\cref{eq:updatekv.explicit.none.IHrd}}{=} &
		    \text{let} \ (\val', \txid', \T') = \mkvs(\ke', \max_{<}(\vi(\ke'))) \\
            & & \text{in} \ \mkvs\rmto{\ke'}{\mkvs(\ke')\rmto{\max_{<}(\vi(\ke'))}{\left(\val', \txid', \T' \Set{\txid}\right)}}(\ke) \\
            &\stackrel{\cref{eq:updatekv.explicit.none.keneqkepRD}}{=} & 
		    \text{let} \ (\val', \txid', \T') = \mkvs(\ke', \max_{<}(\vi(\ke'))) \text{ in } \mkvs(\ke) \big) \\
            & =  & \mkvs(\ke)
		\end{rclarray}
		\end{array}
		\]

		\item Suppose that $\fp = \fp' \uplus \Set{(\otW, \ke', \val')}$ for some $\val' \in \Val$. Then it must be the 
		case that 
		\begin{equation}
		\label{eq:updatekv.explicit.none.keneqkepWR}
		\ke \neq \ke'
		\end{equation}
		Also, we have that $(\otR,\ke, \val) \notin \fp'$ and $(\otW, \ke, \val) \notin \fp$ for any $\val \in \Val$. 
		By inductive hypothesis we can assume 
		\begin{equation}
		\forall \mkvs'.\;\updateKV(\mkvs', \vi, \fp', \txid)(\ke) = \mkvs'(\ke)
		\label{eq:updatekv.explicit.none.IHwr}
		\end{equation}
		Therefore we have 
		\[
        \begin{array}{@{}l@{}}
		\updateKV(\mkvs, \ke, \fp, \txid)(\ke)
        \begin{rclarray}
            {} & = & 
            \updateKV(\mkvs, \ke, \fp \uplus \{(\otW, \ke', \val')\}, \txid)(\ke) \\
            & \stackrel{\cref{eq:updatekv}}{=} & 
		\updateKV(\mkvs\rmto{\ke'}{\mkvs(\ke')\lcat \List{(\val', \txid, \emptyset)}}, \vi, \fp, \txid )(\ke)  \\
        &\stackrel{\cref{eq:updatekv.explicit.none.IHwr}}{=} &
		\mkvs\rmto{\ke'}{\mkvs(\ke') \lcat \List{(\val', \txid, \emptyset)}}, \vi, \txid, \fp)(\ke) \\
        & \stackrel{\cref{eq:updatekv.explicit.none.keneqkepWR}}{=} &
		\mkvs(\ke)
        \end{rclarray}
		\end{array}
		\]
	\end{itemize}

	\item Suppose $(\otR, \ke, \stub) \in \fp$, and $(\otW, \ke, \val) \notin \fp$ for all $\val \in \Val$. 
        Let $(\val, \txid', \T) = \mkvs(\ke, \max_{<}(\vi(\ke)))$. We prove that 
    \[
        \updateKV(\mkvs, \vi, \fp, \txid)(\ke) = \mkvs(\ke)\rmto{\vi(\ke)}{(\val, \txid', \T \cup \{\txid\})}
    \]
		\begin{itemize}
        \item \caseB{$\fp = \emptyset$} this case is vacuous, as $(\otR, \ke, \val) \notin \fp$ for all $\val \in \Val$, 
		against the assumption that $(\otR, \ke, \stub) \in \fp$. 

		\item Suppose that $\fp = \fp' \cup \Set{(\otR, \ke', \stub)}$ for some $\ke'$. 
            We have two possible cases: 
			\begin{enumerate}
			\item $\ke = \ke'$, in which case we know that $(\otR, \ke, \val') \notin \fp'$ for all $\val' \in \Val$ because of 
			the assumptions that we make on the structure of $\fp$. 
            By \cref{lem:updatekv.explicit}\cref{item:updatekv.explicit.none} we have that
			\begin{equation}
			\forall \mkvs'.\; \updateKV(\mkvs', \vi, \fp', \txid)(\ke) = \mkvs'(\ke).
			\label{eq:updatekv.explicit.rd.applynone}
			\end{equation}
			In this case we have that 
			\[
            \begin{array}{@{}l@{}} 
            \updateKV(\mkvs, \vi, \fp, \txid)(\ke) 
            \begin{rclarray}
                {} & = & 
                \updateKV(\mkvs,\vi, \fp' \uplus \Set{(\otR, \ke, \val')}, \txid)(\ke) \\
                & \stackrel{\cref{eq:updatekv}}{=} & 
                \updateKV(\mkvs\rmto{\ke}{\mkvs(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val, \txid', \T \cup \Set{\txid})}}, \vi, \fp', \txid)(\ke) \\
                & \stackrel{\cref{eq:updatekv.explicit.rd.applynone}}{=} &
                \mkvs\rmto{\ke}{\mkvs(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val, \txid', \T \cup \Set{\txid})}}(\ke) \\
                & = &
			    \mkvs(\ke)\rmto{\max(\vi(\ke))}{(\val, \txid', \T \cup \Set{\txid})}
            \end{rclarray}
			\end{array}
			\]
            \item \( \ke \neq \ke' \).
			In this case we know that because $(\otR, \ke, \stub) \in \fp$, then 
			it must be $(\otR, \ke, \stub) \in \fp'$. We also know that $\forall \val.(\otW, \ke, \val) \notin \fp$. 
			By the inductive hypothesis, we have that 
			\begin{equation}
			\label{eq:updatekv.explicit.rd.IHrd}
            \begin{array}{l}
			\forall \mkvs'.\; \updateKV(\mkvs', \vi, \fp', \txid)(\ke) 
            = \mkvs'(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val, \txid', \T \cup \Set{\txid})}
            \end{array}
			\end{equation}
			In this case we have 
			\[
			\begin{array}{l}
            \updateKV(\mkvs, \vi, \fp, \txid)(\ke) 
            \begin{rclarray}
                {} & = &
                \updateKV(\mkvs, \vi, \fp' \uplus \Set{(\otR, \ke', \stub)}, \txid)(\ke) \\
                & \stackrel{\cref{eq:updatekv}}{=} &
			    \updateKV(\mkvs\rmto{\ke'}{\stub}, \vi, \fp, \txid)(\ke) \\
                & \stackrel{\cref{eq:updatekv.explicit.rd.IHrd}}{=} &
                \big(\mkvs\rmto{\ke'}{\stub}(\ke)\big) \rmto{\max_{<}(\vi(\ke))}{(\val, \txid', \T' \cup \Set{\txid})} \\
                &\stackrel{\ke \neq \ke'}{=} &
                \mkvs(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val, \txid', \T' \cup \Set{\txid})}
            \end{rclarray}
			\end{array}
			\]
		\end{enumerate}

		\item $\fp = \fp' \uplus \Set{(\otW, \ke', \val')}$ for some $\val' \in \Val$. Because $(\otW, \ke, \val) \notin \fp$ 
		for any $\val \in \Val$, it must be the case that 
		\begin{equation}
		\ke \neq \ke'
		\label{eq:updatekv.explicit.rd.keneqkepWR}
		\end{equation}
		Because $(\otR, \ke, \stub) \in \fp$, it must also be the case that $(\otR, \ke, \stub) \in \fp'$. By the inductive hypothesis, 
		we have that 
		\begin{equation}
		\label{eq:updatekv.explicit.rd.IHwr}
        \begin{array}{l}
		\forall \mkvs'.\;\updateKV(\mkvs', \vi, \fp', \txid)(\ke) 
        {} = \mkvs(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val, \txid', \T \cup \{(\txid)\})}
        \end{array}
		\end{equation}
		It follows that 
		\[
		\begin{array}{l}
		\updateKV(\mkvs, \vi, \fp, \txid)(\ke) 
        \begin{rclarray}
            {} & = & 
            \updateKV(\mkvs, \vi, \fp' \uplus \Set{(\otW, \ke', \val')}, \txid)(\ke) \\
            & \stackrel{\cref{eq:updatekv}}{=} &
		    \updateKV(\mkvs\rmto{\ke'}{\stub}, \vi, \fp', \txid)(\ke) \\
            & \stackrel{\cref{eq:updatekv.explicit.rd.IHwr}}{=} &
            \mkvs(\rmto{\ke'}{\stub}(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val, \txid', \T \cup \Set{\txid})} \\
            & \stackrel{\cref{eq:updatekv.explicit.rd.keneqkepWR}}{=} & 
            \mkvs(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val, \txid', \T \cup \{\txid\})}
        \end{rclarray}
		\end{array}
		\]
	\end{itemize}
	
	\item Suppose that $(\otW, \ke, \val) \in \fp$ for some $\val \in \Val$, and 
	$(\otR, \ke, \val') \notin \fp$ for any $\val' \in \Val$. We prove that 
	$\updateKV(\mkvs, \vi, \fp, \txid)(\ke) = \mkvs(\ke) \lcat \List{(\val, \txid, \emptyset)}$. 
		\begin{itemize}
        \item \caseB{$\fp = \emptyset$} This case is vacuous, as $(\otW, \ke, \val) \in \fp$.
		\item Suppose that $\fp = \fp' \uplus \{(\otR, \ke', \stub)\}$ for some 
		$\ke'$. Note that, because we are assuming that $\{(\otR, \ke, \val')\} \notin \fp$ 
		for all $\val' \in \Val$, then it must be the case that 
		\begin{equation}
		\ke \neq \ke'
		\label{eq:updatekv.explicit.wr.kenqkepRD}
		\end{equation}	
		We also have that $\{(\otR, \ke, \val')\} \notin \fp'$ for all $\val' \in \Val$, and 
		$(\otW, \ke, \val) \in \fp'$. By the inductive hypothesis we have that 
		\begin{equation}
		\forall \mkvs'.\; \updateKV(\mkvs', \vi, \fp', \txid)(\ke) = \mkvs'(\ke) \lcat \List{(\val, \txid, \emptyset)}
		\label{eq:updatekv.explicit.wr.IHrd}
		\end{equation}
		Therefore, we have that 
		\[
		\begin{array}{lr}
		\updateKV(\mkvs, \vi, \fp, \txid)(\ke) 
        \begin{rclarray}
            {} & = & 
            \updateKV(\mkvs, \vi, \fp' \uplus \Set{(\otR, \ke', \stub)}, \txid)(\ke) \\
            & \stackrel{\cref{eq:updatekv}}{=} &
		    \updateKV(\mkvs\rmto{\ke'}{\stub}, \vi, \fp',\txid )(\ke) \\
            & \stackrel{\cref{eq:updatekv.explicit.wr.IHrd}}{=} &
            \mkvs\rmto{\ke'}{\stub}(\ke) \lcat \List{(\val, \txid, \emptyset)}  \\
            & \stackrel{\cref{eq:updatekv.explicit.wr.kenqkepRD}}{=} &
		    \mkvs(\ke) \lcat \List{(\val, \txid, \emptyset)}
            \end{rclarray}
		\end{array}
		\]
		
		\item Suppose that $\fp = \fp' \uplus \{(\otW, \ke', \val')\}$ 
		for some $\ke'$. We distinguish two possible cases:
			\begin{enumerate}
			\item $\ke = \ke'$. In this case the structure of $\fp$ also imposes that $\val = \val'$, 
			and $(\otW, \ke, \val'') \notin \fp'$ for any $\val'' \in \Val$. Furthermore, we have 
			that $(\otR, \ke, \val'') \notin \fp'$ for any $\val'' \in \Val$. 
			By \cref{lem:updatekv.explicit}\cref{item:updatekv.explicit.none}, we have that 
			\begin{equation}
			\forall \mkvs'.\updateKV(\mkvs', \vi, \fp', \txid)(\ke) = \mkvs(\ke)
			\label{eq:updatekv.explicit.wr.applynone}
			\end{equation}
			from which it follows 
			\[
			\begin{array}{l}
			\updateKV(\mkvs, \vi, \fp, \txid)(\ke) 
            \begin{rclarray}
                {} & = &
			    \updateKV(\mkvs, \vi, \fp' \uplus \Set{(\otW, \ke', \val')}, \txid)(\ke) \\
                & = & 
                \updateKV(\mkvs, \vi, \fp' \uplus \Set{(\otW, \ke, \val)}, \txid)(\ke) \\
                & \stackrel{\cref{eq:updatekv}}{=} &
                \updateKV(\mkvs\rmto{\ke}{\mkvs(\ke) \lcat \List{(\val, \txid, \emptyset)}}, \vi, \fp', \txid)(\ke) \\
                & \stackrel{\cref{eq:updatekv.explicit.wr.applynone}}{=} &
                \mkvs\rmto{\ke}{\mkvs(\ke) \lcat \List{(\val, \txid, \emptyset)}}(\ke) \\
                & = & 
                \mkvs(\ke) \lcat \List{(\val, \txid, \emptyset)}
            \end{rclarray}
			\end{array}
			\]
			
            \item \( \ke \neq \ke'\).
			In this case we have that, because $(\otW, \ke, \val) \in \fp$, then it must 
			be $(\otW, \ke, \val) \in \fp'$. Furthermore, we also have that $(\otR, \ke, \val'') \notin \fp'$ 
			for any $\val'' \in \Val$. By the inductive hypothesis, we have that 
			\begin{equation}
			\forall \mkvs'.\; \updateKV(\mkvs', \vi, \fp', \txid)(\ke) = \mkvs(\ke) \lcat \List{(\val, \txid, \emptyset)}
			\label{eq:updatekv.explicit.wr.IHwr}
			\end{equation}
			from which it follows 
			\[
			\begin{array}{l}
			\updateKV(\mkvs, \vi, \fp, \txid)(\ke) 
            \begin{rclarray}
                {} & = &
                \updateKV(\mkvs, \vi, \fp' \uplus \Set{(\otW,\ke', \val')}, \txid) \\
                & \stackrel{\cref{eq:updatekv}}{=} &
			    \updateKV(\mkvs\rmto{\ke'}{\stub}, \vi, \fp, \txid)(\ke) \\
                & \stackrel{\cref{eq:updatekv.explicit.wr.IHwr}}{=} &
                \mkvs\rmto{\ke'}{\stub}(\ke) \lcat \List{(\val, \txid, \emptyset)} \\
                & \stackrel{\ke \neq \ke'}{=} & 
                \mkvs(\ke) \lcat \List{(\val, \txid, \emptyset)}
            \end{rclarray}
			\end{array}
			\]
			\end{enumerate}
		\end{itemize}
		
		\item Suppose that $(\otW, \ke, \val) \in \fp$ for some $\val \in \Val$, and $(\otR, \ke, \stub) \in \fp$. 
		Let $\mkvs(\ke, \vi) = (\val', \txid', \T')$. We prove that 
        \[ 
            \updateKV(\mkvs, \vi, \fp, \txid)(\ke) = 
            \mkvs(\ke)\rmto{\vi(\ke)}{(\val', \txid', \T' \cup \{\txid\})} \lcat \List{(\val, \txid, \emptyset)}
        \]
		by induction on $\fp$:
			\begin{itemize}
			\item $\fp = \emptyset$; this case is vacuous.
			\item $\fp = \fp' \uplus \{(\otR, \ke', \stub)\}$. We distinguish two cases, according to 
			whether $\ke = \ke'$ or $\ke \neq \ke'$. If $\ke = \ke'$, then we know that 
			$(\otW, \ke, \val) \in \fp'$ and $(\otR, \ke, \val'') \notin \fp$ for any $\val'' \in \Val$. 
			By Lemma \cref{lem:updatekv.explicit}\cref{item:updatekv.explicit.wr} we have that 
			\begin{equation}
			\forall \mkvs'.\;\updateKV(\mkvs,\vi,\fp',\txid)(\ke) = \mkvs(\ke) \lcat \List{(\val, \txid, \emptyset)}
			\label{eq:updateKV.explicit.rdwr.applyWR}
			\end{equation}
			from which it follows that 
			\[
			\begin{array}{l}
			\updateKV(\mkvs, \vi, \fp, \txid)(\ke)
            \begin{rclarray}
                {} & = &
                \updateKV(\mkvs, \vi, \fp' \uplus \Set{(\otR, \ke', \stub)}, \txid)(\ke) \\
                & = & 
			    \updateKV(\mkvs, \vi, \fp' \uplus \Set{(\otR, \ke, \stub)}, \txid)(\ke) \\
                & \stackrel{\cref{eq:updatekv}}{=} &
                \updateKV(\mkvs\rmto{\ke}{\mkvs(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val', \txid', \T' \cup \Set{\txid})}}, \vi, \fp', \txid)(\ke) \\
                & \stackrel{\cref{eq:updateKV.explicit.rdwr.applyWR}}{=} &
                \mkvs\rmto{\ke}{\mkvs(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val', \txid', \T' \cup \{\txid\})}}(\ke) \lcat \List{(\val, \txid, \emptyset)} \\
                & = & 
			    \mkvs(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val' \txid', \T' \cup \{\txid\}} \lcat \List{(\val, \txid, \emptyset)}
            \end{rclarray}
			\end{array}
			\]
			If $\ke \neq \ke'$, then we have that both $(\otR, \ke, \stub) \in \fp'$ and 
			$(\otW, \ke, \val) \in \fp'$. In this case, by the inductive hypothesis we have that 
			\begin{equation}
			\label{eq:updatekv.explicit.rdwr.IHrd}
            \begin{array}{l}
			\forall \mkvs'.\;\updateKV(\mkvs,\vi,\fp',\txid)(\ke) = 
            \mkvs'(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val', \txid', \T' \cup \Set{\txid})} \lcat \List{(\val, \txid, \emptyset)}
            \end{array}
			\end{equation}
			from which it follows that 
			\[
			\begin{array}{l}
			\updateKV(\mkvs, \vi, \fp,\txid)(\ke)
            \begin{rclarray}
                {} & = & 
                \updateKV(\mkvs, \vi, \fp' \uplus \Set{(\otR, \ke', \stub)}, \txid)(\ke) \\
                & \stackrel{\cref{eq:updatekv}}{=} &
			    \updateKV(\mkvs\rmto{\ke'}{\stub}, \vi, \fp', \txid)(\ke) \\
                & \stackrel{\cref{eq:updatekv.explicit.rdwr.IHrd}}{=} & 
                \mkvs\rmto{\ke'}{\stub}(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val', \txid', \T' \cup \Set{\txid})} \lcat \List{(\val, \txid, \emptyset)} \\
                & = &
                \mkvs(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val', \txid', \T' \cup \Set{\txid})} \lcat \List{(\val, \txid, \emptyset)}
            \end{rclarray}
			\end{array}
			\]
			
			\item $\fp = \fp' \uplus \Set{(\otW, \ke'', \val'')}$ for some $\ke'', \val''$. Again, 
			there are two possible cases to consider. If $\ke = \ke''$, then $\val = \val''$ because of the structure imposed on $\fp$.
			Furthermore, we have that 
			$(\otR, \ke, \stub) \in \fp'$ and $(\otW, \ke, \val''') \notin \fp$ for all $\val''' \in \Val$.
			By \cref{lem:updatekv.explicit}\cref{item:updatekv.explicit.rd} we have that 
			\begin{equation}
			\label{eq:updatekv.explicit.rdwr.applyRD}
            \begin{array}{l}
			\forall \mkvs'.\;\updateKV(\mkvs', \vi, \fp', \txid)(\ke) =
            \mkvs'(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val', \txid', \T' \cup \Set{\txid})} 
            \end{array}
			\end{equation}
			We have that 
			\[
			\begin{array}{l}
			\updateKV(\mkvs,\vi,\txid, \fp)(\ke)
            \begin{rclarray}
                {} & = & 
                \updateKV(\mkvs, \vi, \fp' \cup \Set{(\otW, \ke'', \val'')}, \txid)(\ke) \\
                & = &
			    \updateKV(\mkvs,\vi, \fp' \cup \Set{(\otW, \ke, \val)}, \txid)(\ke) \\
                & \stackrel{\cref{eq:updatekv}}{=} &
			    \updateKV(\mkvs\rmto{\ke}{\mkvs(\ke) \lcat \List{(\val, \txid, \emptyset)}}, \vi, \fp', \txid)(\ke) \\
                & \stackrel{\cref{eq:updatekv.explicit.rdwr.applyRD}}{=} &
			    \mkvs\rmto{\ke}{\mkvs(\ke) \lcat \List{(\val, \txid, \emptyset)}}(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val', \txid', \T' \cup \Set{\txid})} \\
                & = &
			    (\mkvs(\ke) \lcat\List{(\val, \txid, \emptyset)})\rmto{\max_{<}(\vi(\ke))}{(\val', \txid', \T' \cup \Set{\txid})} \\
                & = &
			    \mkvs(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val',\txid', \T' \cup \Set{\txid})} \lcat \List{(\val, \txid, \emptyset)}
            \end{rclarray}
			\end{array}
			\]
			Finally, if $\ke \neq \ke'$, then we have that $(\otR, \ke, \stub) \in \fp'$ and $(\otW, \ke, \val) \in \fp'$. 
			By the inductive hypothesis, we obtain 
			\begin{equation}
			\label{eq:updatekv.explicit.rdwr.IHwr}
            \begin{array}{l}
			\forall \mkvs'.\;\updateKV(\mkvs', \vi, \fp', \txid)(\ke) = 
            \mkvs'(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val', \txid', \T' \cup \Set{\txid})} \lcat \List{(\val, \txid, \emptyset)}.
            \end{array}
			\end{equation}
			It follows that 
			\[
			\begin{array}{l}
			\updateKV(\mkvs, \vi, \fp, \txid)(\ke)
            \begin{rclarray}
                {} & = &
                \updateKV(\mkvs, \vi, \fp' \uplus \Set{(\otW, \ke', \stub)}, \txid) \\
                & \stackrel{\cref{eq:updatekv}}{=} & 
			    \updateKV(\mkvs\rmto{\ke'}{\stub}, \vi, \txid, \fp')(\ke) \\
                & \stackrel{\cref{eq:updatekv.explicit.rdwr.IHwr}}{=} &
                \mkvs\rmto{\ke'}{\stub}(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val', \txid', \T' \cup \Set{\txid})} \lcat \List{(\val, \txid, \emptyset)} \\
                & = &
                \mkvs\rmto{\max_{<}(\vi(\ke))}{(\val', \txid', \T' \cup \Set{\txid})} \lcat \List{(\val, \txid, \emptyset)}
            \end{rclarray}
			\end{array}
			\]
			\end{itemize}
\end{enumerate}
\end{proof}

In the following, given a version $\ver = (\val, \txid', \T)$ and a set of 
transaction identifiers $\T'$, we let $\ver \oplus \T' = (\val, \txid', \T \cup \T')$. 
Clearly the operator $\oplus$ is commutative over sets of transactions: 
$\forall \ver, \T, \T'.\; (\ver \oplus \T) \oplus \T' = (\ver \oplus \T') \oplus \T = 
\ver \oplus (\T \cup \T')$.

\begin{corollary}
\label{cor:updatekv.singlecell}
Let $\mkvs$ be a kv-store, $\vi \in \Views(\mkvs)$, $\txid \in \TxID$ and $\fp \in \powerset{\Ops}$. 
Let also $\ke \in \Keys$. Then 
\begin{enumerate}
\item\label{item:updatekv.singlecell.noview} 
    $ 
    \begin{array}[t]{l}
        \fora{ i } 0 \leq i < \abs{\mkvs(\ke) } - 1 \land i \neq \max_{<}(\vi(\ke)) 
        \implies \updateKV(\mkvs, \vi, \fp, \txid)(\ke, i) = \mkvs(\ke, i)
    \end{array}
    $
\item\label{item:updatekv.singlecell.rd} $\forall \val. (\otR, \ke, \stub) \in \fp \implies \updateKV(\mkvs,\vi, \fp,\txid)(\ke, \vi) = \mkvs(\ke, \max_{<}(\vi(\ke))) \oplus \Set{\txid}$
\item\label{item:updatekv.singlecell.nord} $\forall \val.(\otR,\ke, \val) \notin \fp \implies \updateKV(\mkvs,\vi, \fp,\txid)(\ke,\vi) = \mkvs(\ke, \max_{<}(\vi(\ke)))$
\item\label{item:updatekv.singlecell.wr} 
    $
    \begin{array}[t]{l}
        \fora{\val} (\otW, \ke, \val) \in \fp \implies
        \lvert \updateKV(\mkvs,\vi,\fp,\txid)(\ke) \rvert = 
        \lvert \mkvs(\ke) \rvert + 1 \wedge
        \updateKV(\mkvs,\vi,\fp,\txid)(\ke, \lvert \mkvs(\ke) \rvert) = (\val, \txid, \emptyset)
    \end{array}
    $
\item\label{item:updatekv.singlecell.nowr} $\forall \val.(\otW, \ke, \val) \notin \fp \implies \lvert \updateKV(\mkvs,\vi,\fp,\txid)(\ke) \rvert = \lvert \mkvs(\ke) \rvert$
\end{enumerate}
\end{corollary}

\begin{proof}
A simple consequence of \cref{lem:updatekv.explicit}.
\end{proof}

\begin{proposition}
\label{prop:updatekv.comm}
\label{prop:swap-update}
Let $\mkvs \in \HisHeaps$, $\vi_1, \vi_2 \in \Views(\mkvs)$ and let $\cl_1, \cl_2 \in \Clients$ 
be such that $\cl_1 \neq \cl_2$. 
Let also $\fp_1, \fp_2 \in \powerset{\Ops}$ be such that 
whenever $(\otW, \ke, \stub) \in \fp_1$ for some key $\ke$, then 
$(\otW, \ke, \val) \notin \fp_2$ for all $\val \in \Val$. Then 
\[
\begin{array}{l}
\{ \updateKV(\hh_1, \vi_2, \fp_2, \cl_2) \mid \hh_1 \in \updateKV(\mkvs, \vi_1, \fp_1, \cl_1)\} = 
\{ \updateKV(\hh_2, \vi_1, \fp_1, \cl_1) \mid \hh_2 \in \updateKV(\mkvs, \vi_2, \fp_2, \cl_2)\}\\
\end{array}
\]
\end{proposition}

\begin{proof}
Assume $\hh_1 = \updateKV(\mkvs, \vi_1, \fp_1, \txid_1)$, $\hh_2 = \updateKV(\mkvs, \vi_2, \fp_2, \txid_2)$. 
It suffices to show that for any key $\ke$:
\[\lvert \updateKV(\hh_1, \vi_2, \fp_2, \txid_2)(\ke) \rvert = \lvert 
\updateKV(\hh_2, \vi_1, \fp_1, \txid_1)(\ke) \rvert
\]
and for any index $i$ such that \( 0 \leq i < \lvert \updateKV(\hh_1, \vi_2, \fp_2, \txid_2)(\ke) \rvert \):
\[
\updateKV(\hh_1, \vi_2,\fp_2, \txid_2)(\ke, i) = \updateKV(\hh_2, \vi_1, \fp_1, \txid_1)(\ke_1)
\]

First, fix a key $\ke \in \Keys$. Note that if $(\otW, \ke, \stub) \in \fp_1$, then 
by Corollary \ref{cor:updatekv.singlecell} we have that $\lvert \updateKV(\mkvs, \vi_1, \fp_1, \txid_1)(\ke) \rvert = 
\lvert \mkvs(\ke) \rvert$. Because $\fp_1$ is not conflicting with $\fp_2$, it must be the case 
that $\forall \val.(\otW,\ke,\val) \notin \fp_2$, and therefore by \cref{cor:updatekv.singlecell} 
we have that 
\[
\lvert \updateKV(\hh_1, \vi_2, \fp_2, \txid_2)(\ke) \rvert = \lvert \hh_1(\ke) \rvert = \lvert \mkvs(\ke) \rvert + 1.
\] 
Similarly, because $\forall \val.(\otW,\ke,\val)\notin \fp_2$ 
and $(\otW,\ke,\stub) \in \fp_1$, then 
\[
\begin{array}{l}
\lvert \updateKV(\hh_2, \vi_1, \fp_1, \txid_1)(\ke) \rvert = \lvert \hh_2(\ke) \rvert + 1 
= \lvert \updateKV(\mkvs, \vi_2, \fp_2, \txid_2)(\ke) \rvert = \lvert \mkvs(\ke) \rvert + 1
\end{array}
\]
Therefore, if $(\otW, \ke, \stub) \in \fp_1$, we have that 
\[ \lvert \updateKV(\hh_2, \vi_1, \fp_1, \txid_1)(\ke) \rvert = 
\lvert \updateKV(\hh_1(\ke), \vi_2, \fp_2, \txid_2)(\ke) \rvert
\]

Analogously, we can prove that this claim holds also when $(\otW, \ke, \stub) \in \fp_2$. 
Finally, if $(\forall \val.(\otW,\ke,\stub) \notin \fp_1) \wedge (\forall \val.(\otW,\ke,\val) \notin \fp_2)$, 
then by \cref{cor:updatekv.singlecell} we have that 
\[
\lvert \updateKV(\hh_1, \vi_2, \fp_2, \txid_2)(\ke) \rvert = 
\lvert \hh_1(\ke) \rvert = \lvert \updateKV(\mkvs, \vi_1, \fp_1, \txid_1)(\ke) \rvert = \lvert \mkvs(\ke) \rvert
\]
and
\[
\lvert \updateKV(\hh_2, \vi_1, \fp_1, \txid_1)(\ke) \rvert = 
\lvert \hh_2(\ke) \rvert = \lvert \updateKV(\mkvs, \vi_2, \fp_2, \txid_2)(\ke) \rvert = \lvert \mkvs(\ke) \rvert
\]
This concludes the proof that, for any key $\ke \in \Keys$,
\[ \lvert \updateKV(\hh_1,\vi_2,\fp_2,\txid_2) \rvert = 
\lvert \updateKV(\hh_2,\vi_1,\fp_1,\txid_1) \rvert
\]

Next, fix a key $\ke$ and a index $i$ such that $0 \leq i < \abs{ \mkvs(\ke) } - 1$. 
We show that:
\[ 
    \updateKV(\hh_1,\vi_2,\fp_2,\txid_2)(\ke, i) = \updateKV(\hh_2, \vi_1, \fp_1, \txid_1)(\ke, i)
\]
by performing a case analysis on $\vi_1$: 
\begin{enumerate}
    \item $i \neq \max_{<}(\vi_1(\ke))$. 
In this case, by \cref{cor:updatekv.singlecell}\cref{item:updatekv.singlecell.noview}, 
we have that 
\begin{equation}
\hh_1(\ke, i) = \updateKV(\mkvs, \vi_1, \fp_1, \txid_1)(\ke, i) = \mkvs(\ke, i)
\label{eq:v1.nord.hh1}
\end{equation}
and 
\begin{equation}
\updateKV(\hh_2, \vi_1, \fp_1, \txid_1)(\ke, i) = \hh_2(\ke, i)
\label{eq:v1.nord.uhh2}
\end{equation}
Then, we have three possible sub-cases: 
\begin{enumerate}
    \item $i \neq \max_{<}(\vi_2(\ke))$: in this case, by \cref{cor:updatekv.singlecell}\cref{item:updatekv.singlecell.noview} we have that 
\[\updateKV(\hh_1, \vi_2, \fp_2, \txid_2)(\ke, i) = 
\hh_1(\ke, i) \stackrel{\cref{eq:v1.nord.hh1}}{=} \mkvs(\ke, i)
\]
and
\[
\begin{array}{l}
\updateKV(\hh_2, \vi_1, \fp_1, \txid_1) \stackrel{\cref{eq:v1.nord.uhh2}}{=} \hh_2(\ke,i) = 
\updateKV(\mkvs, \vi_2, \fp_2, \txid_2)(\ke, i) = \mkvs(\ke, i)
\end{array}
\]
\item $i = \max_{<}(\vi_2(\ke))$, and $(\otR, \ke, \stub) \notin \fp_2$. In this case the proof is analogous to the previous case, 
only \cref{cor:updatekv.singlecell}\cref{item:updatekv.singlecell.nord} needs to be applied in place 
of \cref{cor:updatekv.singlecell}\cref{item:updatekv.singlecell.noview}.
\item $i = \max_{<}(\vi_2(\ke))$, and $(\otR, \ke, \stub) \in \fp_2$. In this case we can apply \cref{cor:updatekv.singlecell}\cref{item:updatekv.singlecell.rd}, 
and deduce that 
\begin{equation}
\updateKV(\hh_1, \vi_2, \fp_2, \txid_2)(\ke, i) = \hh_1(\ke, i) \oplus \Set{\txid_2}
\label{eq:v1.nord.v2.rd.uhh1}
\end{equation}
\begin{equation}
\hh_2(\ke, i) = \updateKV(\mkvs, \vi_2, \fp_2, \txid_2)(\ke, i) = \mkvs(\ke,i) \oplus \Set{\txid_2}
\label{eq:v1.nord.v2.rd.hh2}
\end{equation}
It follows that 
\[
\begin{array}{l}
\updateKV(\hh_1, \vi_2, \fp_2, \txid_2)(\ke, i) \stackrel{\cref{eq:v1.nord.v2.rd.uhh1}}{=} \hh_1(\ke, i) \oplus \Set{\txid_2} \stackrel{\cref{eq:v1.nord.hh1}}{=} \mkvs(\ke, i) \oplus \Set{\txid_2}\\
\updateKV(\hh_2,\vi_1,\fp_1, \txid_1)(\ke, i) \stackrel{\cref{eq:v1.nord.uhh2}}{=} \hh_2(\ke, i) \stackrel{\cref{eq:v1.nord.v2.rd.hh2}}{=} \mkvs(\ke, i) \oplus \Set{\txid_2}
\end{array}
\]
\end{enumerate}
\item $i = \max_{<}(\vi_1(\ke))$, $(\otR, \ke, \stub) \notin \fp_1$. This case is similar to the previous one: we can infer 
that Equations \cref{eq:v1.nord.hh1} and \cref{eq:v1.nord.uhh2} are valid in this case using \cref{cor:updatekv.singlecell}
\cref{item:updatekv.singlecell.nord}, then we can proceed by performing a case analysis on $\vi_2$ and $\fp_2$ as in the previous case.
\item $i = \max_{<}(\vi_1(\ke))$, $\otR,\ ke, \stub) \in \fp_1$. We can apply \cref{cor:updatekv.singlecell}\cref{item:updatekv.singlecell.rd} 
to deduce the following: 
\begin{equation}
\hh_1(\ke, i) = \updateKV(\mkvs, \vi_1, \fp_1, \txid_1)(\ke, i) = \mkvs(\ke, i) \oplus \Set{\txid_1}
\label{eq:v1.rd.hh1}
\end{equation}
and
\begin{equation}
\updateKV(\hh_2, \vi_1, \fp_1, \txid_1)(\ke, i) = \hh_2(\ke, i) \oplus \Set{\txid_1}
\label{eq:v1.rd.uhh2}
\end{equation}
We have two different sub-cases to consider: 
\begin{enumerate}
\item $i \neq \max_{<}(\vi_2(\ke))$, or $i = \max_{<}(\vi_2(\ke))$ with $(\otR,\ke,\stub) \notin \fp_2$. In this case, we can apply either 
\cref{cor:updatekv.singlecell}\cref{item:updatekv.singlecell.noview} (if $i \neq \max_{<}(\vi_2(\ke))$ ), or 
\cref{cor:updatekv.singlecell} \cref{item:updatekv.singlecell.nord} (if $i = \max_{<}(\vi_2(\ke))$ and $(\otR, \ke, \stub) \notin \fp_2$), 
to obtain 
\[
\updateKV(\hh_1, \vi_2, \fp_2, \txid_2)(\ke, i) = \hh_1(\ke, i) \stackrel{\cref{eq:v1.rd.hh1}}{=} \mkvs(\ke, i) \oplus \Set{\txid_1}
\]
and
\[
\updateKV(\hh_2, \vi_1, \fp_1, \txid_1)(\ke, i) \stackrel{\cref{eq:v1.rd.uhh2}}{=} \hh_2(\ke, i) \oplus \Set{ \txid_1 } = 
\mkvs(\ke, i) \oplus \Set{ \txid_1 }
\]
\item if $i = \max_{<}(\vi_2(\ke))$ and $(\otR, \ke, \stub) \in \fp_2$, then by \cref{cor:updatekv.singlecell}\cref{item:updatekv.singlecell.rd} 
we obtain that 
\begin{equation}
\hh_2(\ke, i) = \updateKV(\mkvs, \vi_2, \fp_2, \txid_2)(\ke, i) = \mkvs(\ke, i) \oplus \Set{\txid_2}
\label{eq:v1.rd.v2.rd.hh2}
\end{equation}
\begin{equation}
\updateKV(\hh_1, \vi_2, \fp_2, \txid_2)(\ke, i) = \hh_1(\ke, i) \oplus \Set{ \txid_2}
\label{eq:v1.rd.v2.rd.uhh1}
\end{equation}
From these facts it follows that
\[
\begin{array}{l}
\updateKV(\hh_1, \vi_2, \fp_2, \txid_2)(\ke, i) \stackrel{\cref{eq:v1.rd.v2.rd.uhh1}}{=} 
\hh_1(\ke, i) \oplus \Set{\txid_2} \stackrel{\cref{eq:v1.rd.hh1}}{=} 
(\mkvs(\ke, i) \oplus \Set{\txid_1}) \oplus \Set{\txid_2 } = \mkvs(\ke, i) \oplus \Set{\txid_1, \txid_2}\\
\updateKV(\hh_2, \vi_1, \fp_1, \txid_1)(\ke, i) \stackrel{\cref{eq:v1.rd.uhh2}}{=} 
\hh_2(\ke, i) \oplus \Set{\txid_1} 
\stackrel{\cref{eq:v1.rd.v2.rd.hh2}}{=} (\mkvs(\ke, i) \oplus \Set{\txid_2}) \oplus \Set{\txid_1} = \mkvs(\ke, i) \oplus \Set{\txid_1, \txid_2}
\end{array}
\]
\end{enumerate}
\end{enumerate}

Next, note that if $\forall \val \in \Val.\;(\otW,\ke,\val) \notin \fp_1 \wedge (\otW, \ke, \val) \notin 
\fp_2$, then 
\[
\lvert \updateKV(\hh_1, \vi_2, \fp_2, \txid_2)(\ke) \rvert = \lvert \mkvs(\ke) \rvert = 
\lvert \updateKV(\hh_2, \vi_1, \fp_1, \txid_1)(\ke) \rvert
\]
Because we have already proved that 
\[
    \forall i = 0,\cdots, \lvert \mkvs(\ke) \rvert.\; \updateKV(\hh_1, \vi_2, \fp_2, \txid_2)(\ke, i) = \updateKV(\hh_2, \vi_1, \fp_1, \txid_1)(\ke, i)
\]
It follows that
\[ 
    \updateKV(\hh_1, \vi_2, \fp_2, \txid_2)(\ke) = \updateKV(\hh_2,\vi_1,\fp_1,\txid_1)(\ke)
\]
and there is nothing left to prove.

Suppose then that  either $(\otW, \ke, \val) \in \fp_1$ or $(\otW,\ke, \val) \in \fp_2$ 
for some $\val$. Without loss of generality, let $(\otW,\ke,\val) \in \fp_1$ for some $\val \in \Val$; 
because we are assuming that $\fp_1$ does not conflict with $\fp_2$, then 
it must be the case that $\forall \val' \in \Val.\;(\otW,\ke,\val') \notin \fp_2$. 
Using \cref{cor:updatekv.singlecell}\cref{item:updatekv.singlecell.nowr} and 
\cref{cor:updatekv.singlecell}\cref{item:updatekv.singlecell.wr}, 
\[
\begin{array}{l}
\updateKV(\hh_1, \vi_2, \fp_2, \txid_2)(\ke, \lvert \mkvs(\ke) \rvert) = 
\hh_1(\ke, \lvert \mkvs(\ke) \rvert) = \updateKV(\mkvs, \vi_1, \fp_1, \txid_1)(\lvert \mkvs(\ke) \rvert) = (\val, \txid_1, \emptyset)\\
{} \land \updateKV(\hh_2, \vi_1,\fp_1, \txid_1)(\ke, \lvert, \mkvs(\ke) \rvert) = (\val, \txid_1, \emptyset)
\end{array}
\]
We have now proved that if $(\otW,\ke,\val) \in \fp_1$, then $\lvert \updateKV(\hh_1, \vi_2, \fp_2, \txid_2) \rvert = 
\lvert \updateKV(\hh_2, \vi_1, \fp_1, \txid_1) \rvert$, and for all 
$i=0,\cdots, \lvert \updateKV(\hh_1, \vi_2, \fp_2, \txid_2) \rvert - 1$, 
$\updateKV(\hh_1,\vi_2, \fp_2, \txid_2)(\ke, i) = \updateKV(\hh_2, \vi_1, \fp_1, \txid_1)(\ke, i)$. 
This concludes the proof that for any key \( \ke \), $\updateKV(\hh_1,\vi_2,\fp_2,\txid_2)(\ke) = 
\updateKV(\hh_2,\vi_1,\fp_1,\txid_1)(\ke)$, and therefore 
$\updateKV(\hh_1, \vi_2, \fp_2, \txid_2) = \updateKV(\hh_2, \vi_1,\fp_1,\txid_1)$.
\end{proof}
