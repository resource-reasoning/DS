\subsection{Commutativity \( \updateKV \)}

A desirable property that one would request from execution test is compositionality:
the consistency model induced by a composite execution test can be recovered from the consistency 
models generated by each execution test: that is, 
\[ 
\forall \ET_1, \ET_2. \CMs(\ET_1 \cap \ET_2) = \CMs(\ET_1) \cap \CMs(\ET_2).
\]
However, execution tests do not always satisfy this property.
We find that if \( \ET_1 \) and \( \ET_2 \) satisfies certain constraints, 
the above holds (\cref{thm:et-comm}).
Before showing the \cref{thm:et-comm},
we first define \emph{conflict} (\cref{def:conflict-commit})
and composition of \( \updateKV \).

\begin{definition}
\label{def:conflict-commit}
Two triples $(\cl_1, \opset_1)$ and $(\cl_2, \opset_2)$ are 
conflicting if either $\cl_1 = \cl_2$, or there exists a key $\ke$ such that 
$(\otW, \ke, \stub) \in \opset_1, (\otW, \ke, \stub) \in \opset_2$. 

An execution test is $\ET$ is \emph{commutative} if, whenever $(\cl_1, \vi_1, \opset_1)$, 
$(\cl_2, \vi_2, \opset_2)$ are non-conflicting, and $\vi_1, \vi_2 \in \Views(\hh_0)$,  
then for any $\hh_0, \hh', \viewFun, \viewFun'$ we have that 
\[
\begin{array}{l}
(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} 
\stub \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} (\hh', \viewFun') \implies
(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} 
\stub \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} (\hh', \viewFun')
\end{array}
\]
\end{definition}

Given two non-conflict commits, it is possible to swap the commit order as shown in \cref{prop:updatekv.comm}.
The \cref{lem:updatekv.explicit} and then \cref{cor:updatekv.singlecell} shows that
swapping the operations of one key yields the same result.
Given \cref{cor:updatekv.singlecell}, then \cref{prop:updatekv.comm} holds.

\begin{lemma}[Swapping Operation]
\label{lem:updatekv.explicit}
Let $\hh$ be a kv-store, $\vi \in \Views(\hh)$, $\txid \in \TxID$ and $\opset \in \powerset{\Ops}$. 
Let also $\ke \in \Keys$. Then
\begin{enumerate}
    \item\label{item:updatekv.explicit.none} 
        $\fora{\val} (\otR, \ke, \val) \notin \opset \wedge (\otW, \ke, \val) \notin \opset \implies \updateKV(\hh, \vi, \opset, \txid)(\ke) = \hh(\ke)$
\item\label{item:updatekv.explicit.rd} 
    $\fora{\val} (\otR, \ke, \stub) \in \opset \wedge (\otW, \ke, \val) \notin \opset 
    \implies 
    \updateKV(\hh, \vi, \opset, \txid)(\ke) =
    \begin{array}[t]{@{}l@{}}
    \text{let} \ (\val', \txid', \T') = \hh(\ke, \max<(\vi(\ke))) \\
    \text{in} \ \hh(\ke)\rmto{\max<(\vi(\ke))}{(\val', \txid', \T' \cup \{\txid\})}
    \end{array}
    $
\item\label{item:updatekv.explicit.wr} 
    $
    \begin{array}[t]{@{}l@{}}
    \fora{ \val, \val'}(\otR, \ke, \val) \notin \opset \wedge (\otW, \ke, \val) \in \opset 
    \implies \updateKV(\hh, \vi, \opset, \txid)(\ke) = \hh(\ke) \lcat \List{(\val, \txid, \emptyset)}
    \end{array}
    $
\item\label{item:updatekv.explicit.rdwr}
    $
    \fora{\val} (\otR, \ke, \stub) \in \opset \wedge (\otW, \ke, \val) \in \opset 
    \implies 
    \updateKV(\hh,\vi,\opset,\txid)(\ke) = 
    \begin{array}[t]{@{}l@{}}
    \text{let} \ (\val', \txid', \T') = \hh(\ke, \max(\vi(\ke)))  \\
    \text{in} \ \hh(\ke)\rmto{\max(\vi(\ke))}{(\val', \txid', \T' \cup \{\txid\}) } \lcat \List{(\val, \txid, \emptyset)} 
    \end{array}
    $
\end{enumerate}
\end{lemma}

\begin{proof}
All the four statements are proved by induction on $\opset$, by keeping the variable $\hh$ universally quantified in the inductive hypothesis. 
Statement \cref{item:updatekv.explicit.rd} and \cref{item:updatekv.explicit.wr} requires 
proving \cref{item:updatekv.explicit.none} first, while Statement \cref{item:updatekv.explicit.rdwr} requires proving all the other statements. 
Fix then an arbitrary $\ke \in \Keys$.
\begin{enumerate}
	\item 
	Suppose that for any $\val$, $(\otR, \ke, \val) \notin \opset$ and $(\otW, \ke, \val)) \notin \opset$. We prove that $\updateKV(\hh, \vi, \opset, \txid)(\ke) = 
	\hh(\ke)$.
	\begin{itemize}
        \item \caseB{$\opset = \emptyset$} in this case we have that 
		\[
		\updateKV(\hh, \vi, \emptyset, \txid)(\ke) \stackrel{\cref{eq:updatekv}}{=} \hh(\ke).
		\]
    \item  
        Suppose that $\opset = \opset' \uplus \{(\otR, \ke', \val')\}$ for some $\ke', \val'$. Because we are assuming that 
		$(\otR, \ke, \val) \notin \opset$ for any $\val \in \Val$, then it must be the case that 
		\begin{equation}
		\label{eq:updatekv.explicit.none.keneqkepRD}
		\ke \neq \ke'.
		\end{equation}
		Also, we have that $(\otR,\ke, \val) \notin \opset'$ and $(\otW, \ke, \val) \notin \opset$ for any $\val \in \Val$. 
		By inductive hypothesis we can assume 
		\begin{equation}
		\forall \hh'.\;\updateKV(\hh', \vi, \opset', \txid)(\ke) = \hh'(\ke)
		\label{eq:updatekv.explicit.none.IHrd}
		\end{equation} 
		Therefore we have 
		\[  
        \begin{array}{@{}l@{}}
        \updateKV(\hh, \vi, \opset, \txid)(\ke) 
		\begin{rclarray}
            {}& = & 
            \updateKV(\hh, \vi, \opset' \uplus \Set{(\otR, \ke', \val')}, \txid)(\ke) \\
            & \stackrel{\cref{eq:updatekv}}{=} &
            \text{let} \ (\val', \txid', \T') = \hh(\ke', \max_{<}(\vi(\ke))) \\
            & & \text{in} \ \updateKV(\hh\rmto{\ke'}{\hh(\ke')\rmto{\max_{<}(\vi(\ke'))}{\left(\val', \txid', \T' \cup \Set{\txid}\right)}}, \vi, \opset', \txid)(\ke) \\
            & \stackrel{\cref{eq:updatekv.explicit.none.IHrd}}{=} &
		    \text{let} \ (\val', \txid', \T') = \hh(\ke', \max_{<}(\vi(\ke'))) \\
            & & \text{in} \ \hh\rmto{\ke'}{\hh(\ke')\rmto{\max_{<}(\vi(\ke'))}{\left(\val', \txid', \T' \Set{\txid}\right)}}(\ke) \\
            &\stackrel{\cref{eq:updatekv.explicit.none.keneqkepRD}}{=} & 
		    \text{let} \ (\val', \txid', \T') = \hh(\ke', \max_{<}(\vi(\ke'))) \text{ in } \hh(\ke) \big) \\
            & =  & \hh(\ke)
		\end{rclarray}
		\end{array}
		\]

		\item Suppose that $\opset = \opset' \uplus \Set{(\otW, \ke', \val')}$ for some $\val' \in \Val$. Then it must be the 
		case that 
		\begin{equation}
		\label{eq:updatekv.explicit.none.keneqkepWR}
		\ke \neq \ke'
		\end{equation}
		Also, we have that $(\otR,\ke, \val) \notin \opset'$ and $(\otW, \ke, \val) \notin \opset$ for any $\val \in \Val$. 
		By inductive hypothesis we can assume 
		\begin{equation}
		\forall \hh'.\;\updateKV(\hh', \vi, \opset', \txid)(\ke) = \hh'(\ke)
		\label{eq:updatekv.explicit.none.IHwr}
		\end{equation}
		Therefore we have 
		\[
        \begin{array}{@{}l@{}}
		\updateKV(\hh, \ke, \opset, \txid)(\ke)
        \begin{rclarray}
            {} & = & 
            \updateKV(\hh, \ke, \opset \uplus \{(\otW, \ke', \val')\}, \txid)(\ke) \\
            & \stackrel{\cref{eq:updatekv}}{=} & 
		\updateKV(\hh\rmto{\ke'}{\hh(\ke')\lcat \List{(\val', \txid, \emptyset)}}, \vi, \opset, \txid )(\ke)  \\
        &\stackrel{\cref{eq:updatekv.explicit.none.IHwr}}{=} &
		\hh\rmto{\ke'}{\hh(\ke') \lcat \List{(\val', \txid, \emptyset)}}, \vi, \txid, \opset)(\ke) \\
        & \stackrel{\cref{eq:updatekv.explicit.none.keneqkepWR}}{=} &
		\hh(\ke)
        \end{rclarray}
		\end{array}
		\]
	\end{itemize}

	\item Suppose $(\otR, \ke, \stub) \in \opset$, and $(\otW, \ke, \val) \notin \opset$ for all $\val \in \Val$. 
        Let $(\val, \txid', \T) = \hh(\ke, \max_{<}(\vi(\ke)))$. We prove that 
    \[
        \updateKV(\hh, \vi, \opset, \txid)(\ke) = \hh(\ke)\rmto{\vi(\ke)}{(\val, \txid', \T \cup \{\txid\})}
    \]
		\begin{itemize}
        \item \caseB{$\opset = \emptyset$} this case is vacuous, as $(\otR, \ke, \val) \notin \opset$ for all $\val \in \Val$, 
		against the assumption that $(\otR, \ke, \stub) \in \opset$. 

		\item Suppose that $\opset = \opset' \cup \Set{(\otR, \ke', \stub)}$ for some $\ke'$. 
            We have two possible cases: 
			\begin{enumerate}
			\item $\ke = \ke'$, in which case we know that $(\otR, \ke, \val') \notin \opset'$ for all $\val' \in \Val$ because of 
			the assumptions that we make on the structure of $\opset$. 
            By \cref{lem:updatekv.explicit}\cref{item:updatekv.explicit.none} we have that
			\begin{equation}
			\forall \hh'.\; \updateKV(\hh', \vi, \opset', \txid)(\ke) = \hh'(\ke).
			\label{eq:updatekv.explicit.rd.applynone}
			\end{equation}
			In this case we have that 
			\[
            \begin{array}{@{}l@{}} 
            \updateKV(\hh, \vi, \opset, \txid)(\ke) 
            \begin{rclarray}
                {} & = & 
                \updateKV(\hh,\vi, \opset' \uplus \Set{(\otR, \ke, \val')}, \txid)(\ke) \\
                & \stackrel{\cref{eq:updatekv}}{=} & 
                \updateKV(\hh\rmto{\ke}{\hh(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val, \txid', \T \cup \Set{\txid})}}, \vi, \opset', \txid)(\ke) \\
                & \stackrel{\cref{eq:updatekv.explicit.rd.applynone}}{=} &
                \hh\rmto{\ke}{\hh(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val, \txid', \T \cup \Set{\txid})}}(\ke) \\
                & = &
			    \hh(\ke)\rmto{\max(\vi(\ke))}{(\val, \txid', \T \cup \Set{\txid})}
            \end{rclarray}
			\end{array}
			\]
            \item \( \ke \neq \ke' \).
			In this case we know that because $(\otR, \ke, \stub) \in \opset$, then 
			it must be $(\otR, \ke, \stub) \in \opset'$. We also know that $\forall \val.(\otW, \ke, \val) \notin \opset$. 
			By the inductive hypothesis, we have that 
			\begin{equation}
			\label{eq:updatekv.explicit.rd.IHrd}
            \begin{array}{l}
			\forall \hh'.\; \updateKV(\hh', \vi, \opset', \txid)(\ke) 
            = \hh'(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val, \txid', \T \cup \Set{\txid})}
            \end{array}
			\end{equation}
			In this case we have 
			\[
			\begin{array}{l}
            \updateKV(\hh, \vi, \opset, \txid)(\ke) 
            \begin{rclarray}
                {} & = &
                \updateKV(\hh, \vi, \opset' \uplus \Set{(\otR, \ke', \stub)}, \txid)(\ke) \\
                & \stackrel{\cref{eq:updatekv}}{=} &
			    \updateKV(\hh\rmto{\ke'}{\stub}, \vi, \opset, \txid)(\ke) \\
                & \stackrel{\cref{eq:updatekv.explicit.rd.IHrd}}{=} &
                \big(\hh\rmto{\ke'}{\stub}(\ke)\big) \rmto{\max_{<}(\vi(\ke))}{(\val, \txid', \T' \cup \Set{\txid})} \\
                &\stackrel{\ke \neq \ke'}{=} &
                \hh(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val, \txid', \T' \cup \Set{\txid})}
            \end{rclarray}
			\end{array}
			\]
		\end{enumerate}

		\item $\opset = \opset' \uplus \Set{(\otW, \ke', \val')}$ for some $\val' \in \Val$. Because $(\otW, \ke, \val) \notin \opset$ 
		for any $\val \in \Val$, it must be the case that 
		\begin{equation}
		\ke \neq \ke'
		\label{eq:updatekv.explicit.rd.keneqkepWR}
		\end{equation}
		Because $(\otR, \ke, \stub) \in \opset$, it must also be the case that $(\otR, \ke, \stub) \in \opset'$. By the inductive hypothesis, 
		we have that 
		\begin{equation}
		\label{eq:updatekv.explicit.rd.IHwr}
        \begin{array}{l}
		\forall \hh'.\;\updateKV(\hh', \vi, \opset', \txid)(\ke) 
        {} = \hh(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val, \txid', \T \cup \{(\txid)\})}
        \end{array}
		\end{equation}
		It follows that 
		\[
		\begin{array}{l}
		\updateKV(\hh, \vi, \opset, \txid)(\ke) 
        \begin{rclarray}
            {} & = & 
            \updateKV(\hh, \vi, \opset' \uplus \Set{(\otW, \ke', \val')}, \txid)(\ke) \\
            & \stackrel{\cref{eq:updatekv}}{=} &
		    \updateKV(\hh\rmto{\ke'}{\stub}, \vi, \opset', \txid)(\ke) \\
            & \stackrel{\cref{eq:updatekv.explicit.rd.IHwr}}{=} &
            \hh(\rmto{\ke'}{\stub}(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val, \txid', \T \cup \Set{\txid})} \\
            & \stackrel{\cref{eq:updatekv.explicit.rd.keneqkepWR}}{=} & 
            \hh(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val, \txid', \T \cup \{\txid\})}
        \end{rclarray}
		\end{array}
		\]
	\end{itemize}
	
	\item Suppose that $(\otW, \ke, \val) \in \opset$ for some $\val \in \Val$, and 
	$(\otR, \ke, \val') \notin \opset$ for any $\val' \in \Val$. We prove that 
	$\updateKV(\hh, \vi, \opset, \txid)(\ke) = \hh(\ke) \lcat \List{(\val, \txid, \emptyset)}$. 
		\begin{itemize}
        \item \caseB{$\opset = \emptyset$} This case is vacuous, as $(\otW, \ke, \val) \in \opset$.
		\item Suppose that $\opset = \opset' \uplus \{(\otR, \ke', \stub)\}$ for some 
		$\ke'$. Note that, because we are assuming that $\{(\otR, \ke, \val')\} \notin \opset$ 
		for all $\val' \in \Val$, then it must be the case that 
		\begin{equation}
		\ke \neq \ke'
		\label{eq:updatekv.explicit.wr.kenqkepRD}
		\end{equation}	
		We also have that $\{(\otR, \ke, \val')\} \notin \opset'$ for all $\val' \in \Val$, and 
		$(\otW, \ke, \val) \in \opset'$. By the inductive hypothesis we have that 
		\begin{equation}
		\forall \hh'.\; \updateKV(\hh', \vi, \opset', \txid)(\ke) = \hh'(\ke) \lcat \List{(\val, \txid, \emptyset)}
		\label{eq:updatekv.explicit.wr.IHrd}
		\end{equation}
		Therefore, we have that 
		\[
		\begin{array}{lr}
		\updateKV(\hh, \vi, \opset, \txid)(\ke) 
        \begin{rclarray}
            {} & = & 
            \updateKV(\hh, \vi, \opset' \uplus \Set{(\otR, \ke', \stub)}, \txid)(\ke) \\
            & \stackrel{\cref{eq:updatekv}}{=} &
		    \updateKV(\hh\rmto{\ke'}{\stub}, \vi, \opset',\txid )(\ke) \\
            & \stackrel{\cref{eq:updatekv.explicit.wr.IHrd}}{=} &
            \hh\rmto{\ke'}{\stub}(\ke) \lcat \List{(\val, \txid, \emptyset)}  \\
            & \stackrel{\cref{eq:updatekv.explicit.wr.kenqkepRD}}{=} &
		    \hh(\ke) \lcat \List{(\val, \txid, \emptyset)}
            \end{rclarray}
		\end{array}
		\]
		
		\item Suppose that $\opset = \opset' \uplus \{(\otW, \ke', \val')\}$ 
		for some $\ke'$. We distinguish two possible cases:
			\begin{enumerate}
			\item $\ke = \ke'$. In this case the structure of $\opset$ also imposes that $\val = \val'$, 
			and $(\otW, \ke, \val'') \notin \opset'$ for any $\val'' \in \Val$. Furthermore, we have 
			that $(\otR, \ke, \val'') \notin \opset'$ for any $\val'' \in \Val$. 
			By \cref{lem:updatekv.explicit}\cref{item:updatekv.explicit.none}, we have that 
			\begin{equation}
			\forall \hh'.\updateKV(\hh', \vi, \opset', \txid)(\ke) = \hh(\ke)
			\label{eq:updatekv.explicit.wr.applynone}
			\end{equation}
			from which it follows 
			\[
			\begin{array}{l}
			\updateKV(\hh, \vi, \opset, \txid)(\ke) 
            \begin{rclarray}
                {} & = &
			    \updateKV(\hh, \vi, \opset' \uplus \Set{(\otW, \ke', \val')}, \txid)(\ke) \\
                & = & 
                \updateKV(\hh, \vi, \opset' \uplus \Set{(\otW, \ke, \val)}, \txid)(\ke) \\
                & \stackrel{\cref{eq:updatekv}}{=} &
                \updateKV(\hh\rmto{\ke}{\hh(\ke) \lcat \List{(\val, \txid, \emptyset)}}, \vi, \opset', \txid)(\ke) \\
                & \stackrel{\cref{eq:updatekv.explicit.wr.applynone}}{=} &
                \hh\rmto{\ke}{\hh(\ke) \lcat \List{(\val, \txid, \emptyset)}}(\ke) \\
                & = & 
                \hh(\ke) \lcat \List{(\val, \txid, \emptyset)}
            \end{rclarray}
			\end{array}
			\]
			
            \item \( \ke \neq \ke'\).
			In this case we have that, because $(\otW, \ke, \val) \in \opset$, then it must 
			be $(\otW, \ke, \val) \in \opset'$. Furthermore, we also have that $(\otR, \ke, \val'') \notin \opset'$ 
			for any $\val'' \in \Val$. By the inductive hypothesis, we have that 
			\begin{equation}
			\forall \hh'.\; \updateKV(\hh', \vi, \opset', \txid)(\ke) = \hh(\ke) \lcat \List{(\val, \txid, \emptyset)}
			\label{eq:updatekv.explicit.wr.IHwr}
			\end{equation}
			from which it follows 
			\[
			\begin{array}{l}
			\updateKV(\hh, \vi, \opset, \txid)(\ke) 
            \begin{rclarray}
                {} & = &
                \updateKV(\hh, \vi, \opset' \uplus \Set{(\otW,\ke', \val')}, \txid) \\
                & \stackrel{\cref{eq:updatekv}}{=} &
			    \updateKV(\hh\rmto{\ke'}{\stub}, \vi, \opset, \txid)(\ke) \\
                & \stackrel{\cref{eq:updatekv.explicit.wr.IHwr}}{=} &
                \hh\rmto{\ke'}{\stub}(\ke) \lcat \List{(\val, \txid, \emptyset)} \\
                & \stackrel{\ke \neq \ke'}{=} & 
                \hh(\ke) \lcat \List{(\val, \txid, \emptyset)}
            \end{rclarray}
			\end{array}
			\]
			\end{enumerate}
		\end{itemize}
		
		\item Suppose that $(\otW, \ke, \val) \in \opset$ for some $\val \in \Val$, and $(\otR, \ke, \stub) \in \opset$. 
		Let $\hh(\ke, \vi) = (\val', \txid', \T')$. We prove that 
        \[ 
            \updateKV(\hh, \vi, \opset, \txid)(\ke) = 
            \hh(\ke)\rmto{\vi(\ke)}{(\val', \txid', \T' \cup \{\txid\})} \lcat \List{(\val, \txid, \emptyset)}
        \]
		by induction on $\opset$:
			\begin{itemize}
			\item $\opset = \emptyset$; this case is vacuous.
			\item $\opset = \opset' \uplus \{(\otR, \ke', \stub)\}$. We distinguish two cases, according to 
			whether $\ke = \ke'$ or $\ke \neq \ke'$. If $\ke = \ke'$, then we know that 
			$(\otW, \ke, \val) \in \opset'$ and $(\otR, \ke, \val'') \notin \opset$ for any $\val'' \in \Val$. 
			By Lemma \cref{lem:updatekv.explicit}\cref{item:updatekv.explicit.wr} we have that 
			\begin{equation}
			\forall \hh'.\;\updateKV(\hh,\vi,\opset',\txid)(\ke) = \hh(\ke) \lcat \List{(\val, \txid, \emptyset)}
			\label{eq:updateKV.explicit.rdwr.applyWR}
			\end{equation}
			from which it follows that 
			\[
			\begin{array}{l}
			\updateKV(\hh, \vi, \opset, \txid)(\ke)
            \begin{rclarray}
                {} & = &
                \updateKV(\hh, \vi, \opset' \uplus \Set{(\otR, \ke', \stub)}, \txid)(\ke) \\
                & = & 
			    \updateKV(\hh, \vi, \opset' \uplus \Set{(\otR, \ke, \stub)}, \txid)(\ke) \\
                & \stackrel{\cref{eq:updatekv}}{=} &
                \updateKV(\hh\rmto{\ke}{\hh(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val', \txid', \T' \cup \Set{\txid})}}, \vi, \opset', \txid)(\ke) \\
                & \stackrel{\cref{eq:updateKV.explicit.rdwr.applyWR}}{=} &
                \hh\rmto{\ke}{\hh(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val', \txid', \T' \cup \{\txid\})}}(\ke) \lcat \List{(\val, \txid, \emptyset)} \\
                & = & 
			    \hh(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val' \txid', \T' \cup \{\txid\}} \lcat \List{(\val, \txid, \emptyset)}
            \end{rclarray}
			\end{array}
			\]
			If $\ke \neq \ke'$, then we have that both $(\otR, \ke, \stub) \in \opset'$ and 
			$(\otW, \ke, \val) \in \opset'$. In this case, by the inductive hypothesis we have that 
			\begin{equation}
			\label{eq:updatekv.explicit.rdwr.IHrd}
            \begin{array}{l}
			\forall \hh'.\;\updateKV(\hh,\vi,\opset',\txid)(\ke) = 
            \hh'(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val', \txid', \T' \cup \Set{\txid})} \lcat \List{(\val, \txid, \emptyset)}
            \end{array}
			\end{equation}
			from which it follows that 
			\[
			\begin{array}{l}
			\updateKV(\hh, \vi, \opset,\txid)(\ke)
            \begin{rclarray}
                {} & = & 
                \updateKV(\hh, \vi, \opset' \uplus \Set{(\otR, \ke', \stub)}, \txid)(\ke) \\
                & \stackrel{\cref{eq:updatekv}}{=} &
			    \updateKV(\hh\rmto{\ke'}{\stub}, \vi, \opset', \txid)(\ke) \\
                & \stackrel{\cref{eq:updatekv.explicit.rdwr.IHrd}}{=} & 
                \hh\rmto{\ke'}{\stub}(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val', \txid', \T' \cup \Set{\txid})} \lcat \List{(\val, \txid, \emptyset)} \\
                & = &
                \hh(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val', \txid', \T' \cup \Set{\txid})} \lcat \List{(\val, \txid, \emptyset)}
            \end{rclarray}
			\end{array}
			\]
			
			\item $\opset = \opset' \uplus \Set{(\otW, \ke'', \val'')}$ for some $\ke'', \val''$. Again, 
			there are two possible cases to consider. If $\ke = \ke''$, then $\val = \val''$ because of the structure imposed on $\opset$.
			Furthermore, we have that 
			$(\otR, \ke, \stub) \in \opset'$ and $(\otW, \ke, \val''') \notin \opset$ for all $\val''' \in \Val$.
			By \cref{lem:updatekv.explicit}\cref{item:updatekv.explicit.rd} we have that 
			\begin{equation}
			\label{eq:updatekv.explicit.rdwr.applyRD}
            \begin{array}{l}
			\forall \hh'.\;\updateKV(\hh', \vi, \opset', \txid)(\ke) =
            \hh'(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val', \txid', \T' \cup \Set{\txid})} 
            \end{array}
			\end{equation}
			We have that 
			\[
			\begin{array}{l}
			\updateKV(\hh,\vi,\txid, \opset)(\ke)
            \begin{rclarray}
                {} & = & 
                \updateKV(\hh, \vi, \opset' \cup \Set{(\otW, \ke'', \val'')}, \txid)(\ke) \\
                & = &
			    \updateKV(\hh,\vi, \opset' \cup \Set{(\otW, \ke, \val)}, \txid)(\ke) \\
                & \stackrel{\cref{eq:updatekv}}{=} &
			    \updateKV(\hh\rmto{\ke}{\hh(\ke) \lcat \List{(\val, \txid, \emptyset)}}, \vi, \opset', \txid)(\ke) \\
                & \stackrel{\cref{eq:updatekv.explicit.rdwr.applyRD}}{=} &
			    \hh\rmto{\ke}{\hh(\ke) \lcat \List{(\val, \txid, \emptyset)}}(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val', \txid', \T' \cup \Set{\txid})} \\
                & = &
			    (\hh(\ke) \lcat\List{(\val, \txid, \emptyset)})\rmto{\max_{<}(\vi(\ke))}{(\val', \txid', \T' \cup \Set{\txid})} \\
                & = &
			    \hh(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val',\txid', \T' \cup \Set{\txid})} \lcat \List{(\val, \txid, \emptyset)}
            \end{rclarray}
			\end{array}
			\]
			Finally, if $\ke \neq \ke'$, then we have that $(\otR, \ke, \stub) \in \opset'$ and $(\otW, \ke, \val) \in \opset'$. 
			By the inductive hypothesis, we obtain 
			\begin{equation}
			\label{eq:updatekv.explicit.rdwr.IHwr}
            \begin{array}{l}
			\forall \hh'.\;\updateKV(\hh', \vi, \opset', \txid)(\ke) = 
            \hh'(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val', \txid', \T' \cup \Set{\txid})} \lcat \List{(\val, \txid, \emptyset)}.
            \end{array}
			\end{equation}
			It follows that 
			\[
			\begin{array}{l}
			\updateKV(\hh, \vi, \opset, \txid)(\ke)
            \begin{rclarray}
                {} & = &
                \updateKV(\hh, \vi, \opset' \uplus \Set{(\otW, \ke', \stub)}, \txid) \\
                & \stackrel{\cref{eq:updatekv}}{=} & 
			    \updateKV(\hh\rmto{\ke'}{\stub}, \vi, \txid, \opset')(\ke) \\
                & \stackrel{\cref{eq:updatekv.explicit.rdwr.IHwr}}{=} &
                \hh\rmto{\ke'}{\stub}(\ke)\rmto{\max_{<}(\vi(\ke))}{(\val', \txid', \T' \cup \Set{\txid})} \lcat \List{(\val, \txid, \emptyset)} \\
                & = &
                \hh\rmto{\max_{<}(\vi(\ke))}{(\val', \txid', \T' \cup \Set{\txid})} \lcat \List{(\val, \txid, \emptyset)}
            \end{rclarray}
			\end{array}
			\]
			\end{itemize}
\end{enumerate}
\end{proof}

In the following, given a version $\ver = (\val, \txid', \T)$ and a set of 
transaction identifiers $\T'$, we let $\ver \oplus \T' = (\val, \txid', \T \cup \T')$. 
Clearly the operator $\oplus$ is commutative over sets of transactions: 
$\forall \ver, \T, \T'.\; (\ver \oplus \T) \oplus \T' = (\ver \oplus \T') \oplus \T = 
\ver \oplus (\T \cup \T')$.

\begin{corollary}
\label{cor:updatekv.singlecell}
Let $\hh$ be a kv-store, $\vi \in \Views(\hh)$, $\txid \in \TxID$ and $\opset \in \powerset{\Ops}$. 
Let also $\ke \in \Keys$. Then 
\begin{enumerate}
\item\label{item:updatekv.singlecell.noview} 
    $ 
    \begin{array}[t]{l}
        \fora{ i } 0 \leq i < \abs{\hh(\ke) } - 1 \land i \neq \max_{<}(\vi(\ke)) 
        \implies \updateKV(\hh, \vi, \opset, \txid)(\ke, i) = \hh(\ke, i)
    \end{array}
    $
\item\label{item:updatekv.singlecell.rd} $\forall \val. (\otR, \ke, \stub) \in \opset \implies \updateKV(\hh,\vi, \opset,\txid)(\ke, \vi) = \hh(\ke, \max_{<}(\vi(\ke))) \oplus \Set{\txid}$
\item\label{item:updatekv.singlecell.nord} $\forall \val.(\otR,\ke, \val) \notin \opset \implies \updateKV(\hh,\vi, \opset,\txid)(\ke,\vi) = \hh(\ke, \max_{<}(\vi(\ke)))$
\item\label{item:updatekv.singlecell.wr} 
    $
    \begin{array}[t]{l}
        \fora{\val} (\otW, \ke, \val) \in \opset \implies
        \lvert \updateKV(\hh,\vi,\opset,\txid)(\ke) \rvert = 
        \lvert \hh(\ke) \rvert + 1 \wedge
        \updateKV(\hh,\vi,\opset,\txid)(\ke, \lvert \hh(\ke) \rvert) = (\val, \txid, \emptyset)
    \end{array}
    $
\item\label{item:updatekv.singlecell.nowr} $\forall \val.(\otW, \ke, \val) \notin \opset \implies \lvert \updateKV(\hh,\vi,\opset,\txid)(\ke) \rvert = \lvert \hh(\ke) \rvert$
\end{enumerate}
\end{corollary}

\begin{proof}
A simple consequence of \cref{lem:updatekv.explicit}.
\end{proof}

\begin{proposition}
\label{prop:updatekv.comm}
\label{prop:swap-update}
Let $\hh \in \HisHeaps$, $\vi_1, \vi_2 \in \Views(\hh)$ and let $\cl_1, \cl_2 \in \Clients$ 
be such that $\cl_1 \neq \cl_2$. 
Let also $\opset_1, \opset_2 \in \powerset{\Ops}$ be such that 
whenever $(\otW, \ke, \stub) \in \opset_1$ for some key $\ke$, then 
$(\otW, \ke, \val) \notin \opset_2$ for all $\val \in \Val$. Then 
\[
\begin{array}{l}
\{ \updateKV(\hh_1, \vi_2, \opset_2, \cl_2) \mid \hh_1 \in \updateKV(\hh, \vi_1, \opset_1, \cl_1)\} = 
\{ \updateKV(\hh_2, \vi_1, \opset_1, \cl_1) \mid \hh_2 \in \updateKV(\hh, \vi_2, \opset_2, \cl_2)\}\\
\end{array}
\]
\end{proposition}

\begin{proof}
Assume $\hh_1 = \updateKV(\hh, \vi_1, \opset_1, \txid_1)$, $\hh_2 = \updateKV(\hh, \vi_2, \opset_2, \txid_2)$. 
It suffices to show that for any key $\ke$:
\[\lvert \updateKV(\hh_1, \vi_2, \opset_2, \txid_2)(\ke) \rvert = \lvert 
\updateKV(\hh_2, \vi_1, \opset_1, \txid_1)(\ke) \rvert
\]
and for any index $i$ such that \( 0 \leq i < \lvert \updateKV(\hh_1, \vi_2, \opset_2, \txid_2)(\ke) \rvert \):
\[
\updateKV(\hh_1, \vi_2,\opset_2, \txid_2)(\ke, i) = \updateKV(\hh_2, \vi_1, \opset_1, \txid_1)(\ke_1)
\]

First, fix a key $\ke \in \Keys$. Note that if $(\otW, \ke, \stub) \in \opset_1$, then 
by Corollary \ref{cor:updatekv.singlecell} we have that $\lvert \updateKV(\hh, \vi_1, \opset_1, \txid_1)(\ke) \rvert = 
\lvert \hh(\ke) \rvert$. Because $\opset_1$ is not conflicting with $\opset_2$, it must be the case 
that $\forall \val.(\otW,\ke,\val) \notin \opset_2$, and therefore by \cref{cor:updatekv.singlecell} 
we have that 
\[
\lvert \updateKV(\hh_1, \vi_2, \opset_2, \txid_2)(\ke) \rvert = \lvert \hh_1(\ke) \rvert = \lvert \hh(\ke) \rvert + 1.
\] 
Similarly, because $\forall \val.(\otW,\ke,\val)\notin \opset_2$ 
and $(\otW,\ke,\stub) \in \opset_1$, then 
\[
\begin{array}{l}
\lvert \updateKV(\hh_2, \vi_1, \opset_1, \txid_1)(\ke) \rvert = \lvert \hh_2(\ke) \rvert + 1 
= \lvert \updateKV(\hh, \vi_2, \opset_2, \txid_2)(\ke) \rvert = \lvert \hh(\ke) \rvert + 1
\end{array}
\]
Therefore, if $(\otW, \ke, \stub) \in \opset_1$, we have that 
\[ \lvert \updateKV(\hh_2, \vi_1, \opset_1, \txid_1)(\ke) \rvert = 
\lvert \updateKV(\hh_1(\ke), \vi_2, \opset_2, \txid_2)(\ke) \rvert
\]

Analogously, we can prove that this claim holds also when $(\otW, \ke, \stub) \in \opset_2$. 
Finally, if $(\forall \val.(\otW,\ke,\stub) \notin \opset_1) \wedge (\forall \val.(\otW,\ke,\val) \notin \opset_2)$, 
then by \cref{cor:updatekv.singlecell} we have that 
\[
\lvert \updateKV(\hh_1, \vi_2, \opset_2, \txid_2)(\ke) \rvert = 
\lvert \hh_1(\ke) \rvert = \lvert \updateKV(\hh, \vi_1, \opset_1, \txid_1)(\ke) \rvert = \lvert \hh(\ke) \rvert
\]
and
\[
\lvert \updateKV(\hh_2, \vi_1, \opset_1, \txid_1)(\ke) \rvert = 
\lvert \hh_2(\ke) \rvert = \lvert \updateKV(\hh, \vi_2, \opset_2, \txid_2)(\ke) \rvert = \lvert \hh(\ke) \rvert
\]
This concludes the proof that, for any key $\ke \in \Keys$,
\[ \lvert \updateKV(\hh_1,\vi_2,\opset_2,\txid_2) \rvert = 
\lvert \updateKV(\hh_2,\vi_1,\opset_1,\txid_1) \rvert
\]

Next, fix a key $\ke$ and a index $i$ such that $0 \leq i < \abs{ \hh(\ke) } - 1$. 
We show that:
\[ 
    \updateKV(\hh_1,\vi_2,\opset_2,\txid_2)(\ke, i) = \updateKV(\hh_2, \vi_1, \opset_1, \txid_1)(\ke, i)
\]
by performing a case analysis on $\vi_1$: 
\begin{enumerate}
    \item $i \neq \max_{<}(\vi_1(\ke))$. 
In this case, by \cref{cor:updatekv.singlecell}\cref{item:updatekv.singlecell.noview}, 
we have that 
\begin{equation}
\hh_1(\ke, i) = \updateKV(\hh, \vi_1, \opset_1, \txid_1)(\ke, i) = \hh(\ke, i)
\label{eq:v1.nord.hh1}
\end{equation}
and 
\begin{equation}
\updateKV(\hh_2, \vi_1, \opset_1, \txid_1)(\ke, i) = \hh_2(\ke, i)
\label{eq:v1.nord.uhh2}
\end{equation}
Then, we have three possible sub-cases: 
\begin{enumerate}
    \item $i \neq \max_{<}(\vi_2(\ke))$: in this case, by \cref{cor:updatekv.singlecell}\cref{item:updatekv.singlecell.noview} we have that 
\[\updateKV(\hh_1, \vi_2, \opset_2, \txid_2)(\ke, i) = 
\hh_1(\ke, i) \stackrel{\cref{eq:v1.nord.hh1}}{=} \hh(\ke, i)
\]
and
\[
\begin{array}{l}
\updateKV(\hh_2, \vi_1, \opset_1, \txid_1) \stackrel{\cref{eq:v1.nord.uhh2}}{=} \hh_2(\ke,i) = 
\updateKV(\hh, \vi_2, \opset_2, \txid_2)(\ke, i) = \hh(\ke, i)
\end{array}
\]
\item $i = \max_{<}(\vi_2(\ke))$, and $(\otR, \ke, \stub) \notin \opset_2$. In this case the proof is analogous to the previous case, 
only \cref{cor:updatekv.singlecell}\cref{item:updatekv.singlecell.nord} needs to be applied in place 
of \cref{cor:updatekv.singlecell}\cref{item:updatekv.singlecell.noview}.
\item $i = \max_{<}(\vi_2(\ke))$, and $(\otR, \ke, \stub) \in \opset_2$. In this case we can apply \cref{cor:updatekv.singlecell}\cref{item:updatekv.singlecell.rd}, 
and deduce that 
\begin{equation}
\updateKV(\hh_1, \vi_2, \opset_2, \txid_2)(\ke, i) = \hh_1(\ke, i) \oplus \Set{\txid_2}
\label{eq:v1.nord.v2.rd.uhh1}
\end{equation}
\begin{equation}
\hh_2(\ke, i) = \updateKV(\hh, \vi_2, \opset_2, \txid_2)(\ke, i) = \hh(\ke,i) \oplus \Set{\txid_2}
\label{eq:v1.nord.v2.rd.hh2}
\end{equation}
It follows that 
\[
\begin{array}{l}
\updateKV(\hh_1, \vi_2, \opset_2, \txid_2)(\ke, i) \stackrel{\cref{eq:v1.nord.v2.rd.uhh1}}{=} \hh_1(\ke, i) \oplus \Set{\txid_2} \stackrel{\cref{eq:v1.nord.hh1}}{=} \hh(\ke, i) \oplus \Set{\txid_2}\\
\updateKV(\hh_2,\vi_1,\opset_1, \txid_1)(\ke, i) \stackrel{\cref{eq:v1.nord.uhh2}}{=} \hh_2(\ke, i) \stackrel{\cref{eq:v1.nord.v2.rd.hh2}}{=} \hh(\ke, i) \oplus \Set{\txid_2}
\end{array}
\]
\end{enumerate}
\item $i = \max_{<}(\vi_1(\ke))$, $(\otR, \ke, \stub) \notin \opset_1$. This case is similar to the previous one: we can infer 
that Equations \cref{eq:v1.nord.hh1} and \cref{eq:v1.nord.uhh2} are valid in this case using \cref{cor:updatekv.singlecell}
\cref{item:updatekv.singlecell.nord}, then we can proceed by performing a case analysis on $\vi_2$ and $\opset_2$ as in the previous case.
\item $i = \max_{<}(\vi_1(\ke))$, $\otR,\ ke, \stub) \in \opset_1$. We can apply \cref{cor:updatekv.singlecell}\cref{item:updatekv.singlecell.rd} 
to deduce the following: 
\begin{equation}
\hh_1(\ke, i) = \updateKV(\hh, \vi_1, \opset_1, \txid_1)(\ke, i) = \hh(\ke, i) \oplus \Set{\txid_1}
\label{eq:v1.rd.hh1}
\end{equation}
and
\begin{equation}
\updateKV(\hh_2, \vi_1, \opset_1, \txid_1)(\ke, i) = \hh_2(\ke, i) \oplus \Set{\txid_1}
\label{eq:v1.rd.uhh2}
\end{equation}
We have two different sub-cases to consider: 
\begin{enumerate}
\item $i \neq \max_{<}(\vi_2(\ke))$, or $i = \max_{<}(\vi_2(\ke))$ with $(\otR,\ke,\stub) \notin \opset_2$. In this case, we can apply either 
\cref{cor:updatekv.singlecell}\cref{item:updatekv.singlecell.noview} (if $i \neq \max_{<}(\vi_2(\ke))$ ), or 
\cref{cor:updatekv.singlecell} \cref{item:updatekv.singlecell.nord} (if $i = \max_{<}(\vi_2(\ke))$ and $(\otR, \ke, \stub) \notin \opset_2$), 
to obtain 
\[
\updateKV(\hh_1, \vi_2, \opset_2, \txid_2)(\ke, i) = \hh_1(\ke, i) \stackrel{\cref{eq:v1.rd.hh1}}{=} \hh(\ke, i) \oplus \Set{\txid_1}
\]
and
\[
\updateKV(\hh_2, \vi_1, \opset_1, \txid_1)(\ke, i) \stackrel{\cref{eq:v1.rd.uhh2}}{=} \hh_2(\ke, i) \oplus \Set{ \txid_1 } = 
\hh(\ke, i) \oplus \Set{ \txid_1 }
\]
\item if $i = \max_{<}(\vi_2(\ke))$ and $(\otR, \ke, \stub) \in \opset_2$, then by \cref{cor:updatekv.singlecell}\cref{item:updatekv.singlecell.rd} 
we obtain that 
\begin{equation}
\hh_2(\ke, i) = \updateKV(\hh, \vi_2, \opset_2, \txid_2)(\ke, i) = \hh(\ke, \i) \oplus \Set{\txid_2}
\label{eq:v1.rd.v2.rd.hh2}
\end{equation}
\begin{equation}
\updateKV(\hh_1, \vi_2, \opset_2, \txid_2)(\ke, i) = \hh_1(\ke, i) \oplus \Set{ \txid_2}
\label{eq:v1.rd.v2.rd.uhh1}
\end{equation}
From these facts it follows that
\[
\begin{array}{l}
\updateKV(\hh_1, \vi_2, \opset_2, \txid_2)(\ke, i) \stackrel{\cref{eq:v1.rd.v2.rd.uhh1}}{=} 
\hh_1(\ke, i) \oplus \Set{\txid_2} \stackrel{\cref{eq:v1.rd.hh1}}{=} 
(\hh(\ke, i) \oplus \Set{\txid_1}) \oplus \Set{\txid_2 } = \hh(\ke, i) \oplus \Set{\txid_1, \txid_2}\\
\updateKV(\hh_2, \vi_1, \opset_1, \txid_1)(\ke, i) \stackrel{\cref{eq:v1.rd.uhh2}}{=} 
\hh_2(\ke, i) \oplus \Set{\txid_1} 
\stackrel{\cref{eq:v1.rd.v2.rd.hh2}}{=} (\hh(\ke, i) \oplus \Set{\txid_2}) \oplus \Set{\txid_1} = \hh(\ke, i) \oplus \Set{\txid_1, \txid_2}
\end{array}
\]
\end{enumerate}
\end{enumerate}

Next, note that if $\forall \val \in \Val.\;(\otW,\ke,\val) \notin \opset_1 \wedge (\otW, \ke, \val) \notin 
\opset_2$, then 
\[
\lvert \updateKV(\hh_1, \vi_2, \opset_2, \txid_2)(\ke) \rvert = \lvert \hh(\ke) \rvert = 
\lvert \updateKV(\hh_2, \vi_1, \opset_1, \txid_1)(\ke) \rvert
\]
Because we have already proved that 
\[
    \forall i = 0,\cdots, \lvert \hh(\ke) \rvert.\; \updateKV(\hh_1, \vi_2, \opset_2, \txid_2)(\ke, i) = \updateKV(\hh_2, \vi_1, \opset_1, \txid_1)(\ke, i)
\]
It follows that
\[ 
    \updateKV(\hh_1, \vi_2, \opset_2, \txid_2)(\ke) = \updateKV(\hh_2,\vi_1,\opset_1,\txid_1)(\ke)
\]
and there is nothing left to prove.

Suppose then that  either $(\otW, \ke, \val) \in \opset_1$ or $(\otW,\ke, \val) \in \opset_2$ 
for some $\val$. Without loss of generality, let $(\otW,\ke,\val) \in \opset_1$ for some $\val \in \Val$; 
because we are assuming that $\opset_1$ does not conflict with $\opset_2$, then 
it must be the case that $\forall \val' \in \Val.\;(\otW,\ke,\val') \notin \opset_2$. 
Using \cref{cor:updatekv.singlecell}\cref{item:updatekv.singlecell.nowr} and 
\cref{cor:updatekv.singlecell}\cref{item:updatekv.singlecell.wr}, 
\[
\begin{array}{l}
\updateKV(\hh_1, \vi_2, \opset_2, \txid_2)(\ke, \lvert \hh(\ke) \rvert) = 
\hh_1(\ke, \lvert \hh(\ke) \rvert) = \updateKV(\hh, \vi_1, \opset_1, \txid_1)(\lvert \hh(\ke) \rvert) = (\val, \txid_1, \emptyset)\\
{} \land \updateKV(\hh_2, \vi_1,\opset_1, \txid_1)(\ke, \lvert, \hh(\ke) \rvert) = (\val, \txid_1, \emptyset)
\end{array}
\]
We have now proved that if $(\otW,\ke,\val) \in \opset_1$, then $\lvert \updateKV(\hh_1, \vi_2, \opset_2, \txid_2) \rvert = 
\lvert \updateKV(\hh_2, \vi_1, \opset_1, \txid_1) \rvert$, and for all 
$i=0,\cdots, \lvert \updateKV(\hh_1, \vi_2, \opset_2, \txid_2) \rvert - 1$, 
$\updateKV(\hh_1,\vi_2, \opset_2, \txid_2)(\ke, i) = \updateKV(\hh_2, \vi_1, \opset_1, \txid_1)(\ke, i)$. 
This concludes the proof that for any key \( \ke \), $\updateKV(\hh_1,\vi_2,\opset_2,\txid_2)(\ke) = 
\updateKV(\hh_2,\vi_1,\opset_1,\txid_1)(\ke)$, and therefore 
$\updateKV(\hh_1, \vi_2, \opset_2, \txid_2) = \updateKV(\hh_2, \vi_1,\opset_1,\txid_1)$.
\end{proof}
