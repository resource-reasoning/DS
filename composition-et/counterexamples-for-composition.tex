\subsection{Counter examples for compositionality}
\label{sec:counter-examples-composition}

A desirable property that one would request from execution test is compositionality:
the consistency model induced by a composite execution test can be recovered from the consistency 
models generated by each execution test: that is, 
\[ 
\fora{ \ET_1, \ET_2 } \CMs(\ET_1 \cap \ET_2) = \CMs(\ET_1) \cap \CMs(\ET_2).
\]
However, execution tests do not always satisfy this property.

\subsubsection{Commutativity}
Consider the following:
%
\[
\begin{array}{@{}l | l@{}}
    \hline
    \ET_1 & \ET_2 \\
%    
    \hline
    (\mkvs_{0}, \vi_{0}) \csat \Set{(\otW, \key, 1)} : ( \mkvs_{\key}, \vi_{0})
    &
    (\mkvs_{0}, \vi_{0}) \csat \Set{(\otW, \key', 1)} : ( \mkvs_{\key'}, \vi_{0}) 
    \vspace*{-7pt}\\\\
% %   
    (\mkvs_{\key}, \vi_{0}) \csat  \Set{(\otW, \key', 1)} : (\mkvs',\vi_{0}) 
    &
    (\mkvs_{\key'}, \vi_{0}) \csat \Set{(\otW, \key, 1)} : (\mkvs',\vi_{1}) 
    \\
\hline
\end{array}
\]%
 
\begin{align*}
    \mkvs_{\key} & = \mkvs_{0}[\key \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \stub, \emptyset)] \\
    \mkvs_{\key'} & = \mkvs_{0}[\key' \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \stub, \emptyset)] \\
    \mkvs' & = \mkvs[\key \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \stub, \emptyset) 
                ,\key' \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \stub, \emptyset)] \\
\end{align*}
%

As both $\ET_1$ and $\ET_2$ allow a version with value $1$ to be written for 
$\key, \key'$,  we have $\mkvs' \in \CMs(\ET_1) \cap \CMs(\ET_2)$. 
However, $\ET_1$ and $\ET_2$ enforce a different order in which the writes on $\key, \key'$ must happen; 
thus $\mkvs' \notin \CMs(\ET_1 \cap \ET_2)$. 

In this example, compositionality fails because execution tests 
enforced a particular order in which the updates must be committed, even though such updates 
are non-conflicting: the kv-store obtained after committing such updates is independent of the commit order. This observation is captures in the following definition: 
\begin{definition}
\label{def:conflict-commit}
Two triples $(\cl_1, \fp_1)$ and $(\cl_2, \fp_2)$ are 
conflicting if either $\cl_1 = \cl_2$, or there exists a key $\key$ such that 
$(\otW, \key, \stub) \in \fp_1, (\otW, \key, \stub) \in \fp_2$. 
\end{definition}

\begin{definition}
\label{def:app-et-comm}
An execution test is $\ET$ is \emph{commutative} if, whenever $(\cl_1, \vi_1, \fp_1)$, 
$(\cl_2, \vi_2, \fp_2)$ are non-conflicting, and $\vi_1, \vi_2 \in \Views(\mkvs_0)$,  
then for any $\mkvs_0, \mkvs', \vienv, \vienv'$ we have that 
\begin{centermultline}
(\mkvs_0, \vienv) \toET{(\cl_1, \fp_1)}
\stub \toET{(\cl_2, \fp_2)} (\mkvs', \vienv') \implies
(\mkvs_0, \vienv) \toET{(\cl_2, \fp_2)} 
\stub \toET{(\cl_1, \fp_1)} (\mkvs', \vienv'') 
\land \vienv''(\cl_2) \viewleq \vienv'(\cl_2)
\end{centermultline}
\end{definition}

\begin{proposition}
\label{prop:et-comm-matching-vi-env}
\label{lem:et-comm-matching-vi-env}
Assume an execution test is $\ET$ is \emph{commutative}.
Assume $(\cl_1, \vi_1, \fp_1)$, 
$(\cl_2, \vi_2, \fp_2)$ are non-conflicting, and $\vi_1, \vi_2 \in \Views(\mkvs_0)$,  
then for any $\mkvs_0, \mkvs', \vienv, \vienv'$ we have that:
\begin{centermultline}
(\mkvs_0, \vienv) \toET{(\cl_1, \fp_1)}
\stub \toET{(\cl_2, \fp_2)} (\mkvs', \vienv') \implies
(\mkvs_0, \vienv) \toET{(\cl_2, \fp_2)} 
\stub \toET{(\cl_1, \fp_1)} \stub \toET{(\cl_2, \epsilon)} (\mkvs', \vienv')
\end{centermultline}
\end{proposition}

\begin{proposition}
\label{thm:appendix-et-composition-2}
\label{prop:appendix-et-composition-2}
if $\ET_1, \ET_2$ are commutative, then $\ET_1 \cap \ET_2$ is commutative.
\end{proposition}
\begin{proof}
Let \( \ET_{12} = \ET_1 \cap \ET_2 \).
Assume \(\conf_1, \conf_2, \conf_3, \cl, \cl', \vi, \vi', \fp, \fp' \) such that:
\[
    \conf_1 \toET{\cl, \fp}[\ET_{12}] \conf_2 \toET{\cl', \fp'}[\ET_{12}] \conf_3
\]
Therefore, we have:
\[
    \conf_1 \toET{\cl, \fp}[\ET_{1}] \conf_2 \toET{\cl', \fp'}[\ET_{1}] \conf_3 \land 
    \conf_1 \toET{\cl, \fp}[\ET_{2}] \conf_2 \toET{\cl', \fp'}[\ET_{2}] \conf_3
\]
Because \( \ET_1 \)  and \( \ET_2 \) are commutative, there exists a configuration \( \conf'_2 \) such that:
\[
    \conf_1 \toET{\cl', \fp'}[\ET_{1}] \conf'_2 \toET{\cl, \fp}[\ET_{1}] \conf_3 \land 
    \conf_1 \toET{\cl', \fp'}[\ET_{2}] \conf'_2 \toET{\cl, \fp}[\ET_{2}] \conf_3
\]
so we have the proof that: 
\[
    \conf_1 \toET{\cl', \fp'}[\ET_{12}] \conf'_2 \toET{\cl, \fp}[\ET_{12}] \conf_3
\]
\end{proof}

\subsubsection{Matching views}
\label{ex:noblindwrites}
\label{sec:no-blind-writes-counter}
\label{sec:matching-pre-views}
\label{sec:matching-views}
For compositionality of two execution tests, 
it is not enough that one execution test is commutative, since the views used to update kv-stores from two execution tests might not match but still yield the same final kv-store.
The following two counter examples lead us to further restrict the execution tests.

Let consider a kv-store \( \mkvs = \Set{\key \mapsto (0,\txid_0,\emptyset) \lcat (1,\txid,\emptyset) }\):
\begin{centertikz}
%Location x
\node(locx) {$\key \mapsto$};

\draw pic at ([xshift=\tikzkvspace]locx.east) {vlist={versionx}{%
    /$0$/$\txid_0$/$\emptyset$
    , /$1$/$\txid$/$\emptyset$
}};
\end{centertikz}
and the following two execution test:
\[
    \ET_1 \vdash (\mkvs, \vi_1) \csat \fp, (\mkvs',\vi') 
    \qquad 
    \ET_2 \vdash (\mkvs, \vi_2) \csat \fp, (\mkvs',\vi') 
\]
where \( \vi_1 = \Set{\key \mapsto \Set{0} }\), \( \vi' = \vi_2 = \Set{\key \mapsto \Set{0,1}} \) and \( \fp = \Set{(\otW, \key, 2)}\).
This leads to the final kv-store \( \mkvs' = \mkvs\rmto{\key}{\mkvs(\key) \lcat (2,\txid',\emptyset)} \) for some \( \txid' \):
\begin{centertikz}
%Location x
\node(locx) {$\key \mapsto$};

\draw pic at ([xshift=\tikzkvspace]locx.east) {vlist={versionx}{%
    /$0$/$\txid_0$/$\emptyset$
    , /$1$/$\txid$/$\emptyset$
    , /$2$/$\txid'$/$\emptyset$
}};
\end{centertikz}

It is easy to see \( \ET_1 \cap \ET_2  = \emptyset \) therefore \( \CMs(\ET_1 \cap \ET_2) = \emptyset \), yet \( \CMs(\ET_1) \cap \CMs(\ET_2) = \Set{\mkvs'}\).
If execution tests enforce \emph{no blind write}, \( \ET_1\) and \( \ET_2 \) cannot produce the same kv-store, thus \( \CMs(\ET_1) \cap \CMs(\ET_2) = \CMs(\ET_1 \cap \ET_2) = \emptyset\), because the initial views are different.

%\begin{definition}[No blind writes]
%\label{def:noblidwrites}
%An execution test $\ET$ has \emph{no blind writes} if, whenever $\ET \vdash (\mkvs, \vi) \csat \fp \cup \Set{(\otW, \key, \stub)} : (\mkvs',\vi')$, 
%then $(\otR, \key, \stub) \in \fp$.
%\end{definition}

Let consider a kv-store \( \mkvs = \Set{\key_1 \mapsto (0,\txid_0,\emptyset) \lcat (1,\txid_1,\emptyset), \key_2 \mapsto (2,\txid_0,\emptyset) \lcat (3,\txid_2,\emptyset)}\):
\begin{centertikz}
%Location x
\node(locx) {$\key_1 \mapsto$};
\draw pic at ([xshift=\tikzkvspace]locx.east) {vlist={versionx}{%
    /$0$/$\txid_0$/$\emptyset$
    , /$1$/$\txid_1$/$\emptyset$
}};

%Location y
\path (versionx.east) + (1,0) node (locy) {$\key_2 \mapsto$};
\draw pic at ([xshift=\tikzkvspace]locy.east) {vlist={versiony}{%
    /$2$/$\txid_0$/$\emptyset$
    , /$3$/$\txid_2$/$\emptyset$
}};
\end{centertikz}
and the following two execution test:
\[
    \ET_1 \vdash (\mkvs, \vi_1) \csat \fp, (\mkvs',\vi') 
    \qquad 
    \ET_2 \vdash (\mkvs, \vi_2) \csat \fp, (\mkvs',\vi') 
\]
where \( \vi_1 = \Set{\key_1 \mapsto \Set{0}, \key_2 \mapsto \Set{0} }\), \( \vi_2 = \Set{\key_1 \mapsto \Set{0}, \key_2 \mapsto \Set{0,1} }\) and \( \fp = \Set{(\otR, \key_1, 0)}\).
This leads to the final kv-store \( \mkvs' = \mkvs\rmto{\key}{(0,\txid_0,\Set{\txid'}) \lcat (1,\txid_1,\emptyset)} \) for some \( \txid' \):
\begin{centertikz}
%Location x
\node(locx) {$\key_1 \mapsto$};
\draw pic at ([xshift=\tikzkvspace]locx.east) {vlist={versionx}{%
        /$0$/$\txid_0$/$\Set{\txid'}$
    , /$1$/$\txid_1$/$\emptyset$
}};

%Location y
\path (versionx.east) + (1,0) node (locy) {$\key_2 \mapsto$};
\draw pic at ([xshift=\tikzkvspace]locy.east) {vlist={versiony}{%
    /$2$/$\txid_0$/$\emptyset$
    , /$3$/$\txid_2$/$\emptyset$
}};
\end{centertikz}
It is easy to see \( \ET_1 \cap \ET_2  = \emptyset \) therefore \( \CMs(\ET_1 \cap \ET_2) = \emptyset \), yet \( \CMs(\ET_1) \cap \CMs(\ET_2) = \Set{\mkvs'}\).

%\begin{definition}[Minimum footprints]
%\label{def:et-minimum-footprint}
%An execution test $\ET$ has \emph{minimum footprints} if for any key-value store \( \mkvs \)
%views \( \vi, \vi',\vi''\) and fingerprint \( \fp \),
%\[
%\begin{array}{@{}l@{}}
    %\ET \vdash (\mkvs, \vi) \csat \fp : (\mkvs',\vi'')
%\land \fora{ \key} \left( (\stub, \key, \stub) \in \fp \implies \vi(\key) = \vi'(\key) \right) 
%\implies \ET \vdash (\mkvs, \vi') \csat \fp : (\mkvs',\vi'')
%\end{array}
%\]
%\end{definition}

%If execution tests enforce \emph{minimum footprint}, 
%given that \( \key_2 \) does not appear in the fingerprint \( \fp \),
%then we have 
%\(
%\ET_2 \vdash (\mkvs, \vi_2) \csat \fp, (\mkvs',\vi') 
%\implies 
%\ET_2 \vdash (\mkvs, \vi_1) \csat \fp, (\mkvs',\vi') 
%\).
%This means \( \CMs(\ET_1) \cap \CMs(\ET_2) = \CMs(\ET_1 \cap \ET_2) = \Set{\mkvs'}\).

To rule out those situations, we further constraints execution tests \( \ET_1 \) and \( \ET_2 \):
\begin{definition}[matching views]
\label{def:match-pre-view}
\label{def:match-view}
Two execution tests $\ET_1$ and $\ET_2$ have matching views if for any \(\mkvs, \mkvs',\fp,\vi_1,\vi_2,\vi_1',\vi_2'\):
\begin{multline*}
    \ET_1 \vdash (\mkvs,\vi_1) \csat \fp : (\mkvs', \vi_1' ) \land
    \ET_2 \vdash (\mkvs,\vi_2) \csat \fp : (\mkvs', \vi_2' )  \\
    {} \land \begin{bracketarray}\fora{l, \key, \val} (l, \key, \val) \in \fp \implies \max(\vi_1(\key)) = \max(\vi_2(\key))\end{bracketarray} \\
    {} \implies
    \exsts{\vi, \vi'}
    \ET_1 \vdash (\mkvs,\vi) \csat \fp : (\mkvs', \vi' ) \land
    \ET_2 \vdash (\mkvs,\vi) \csat \fp : (\mkvs', \vi' )  \\
    {} \land \vi_1 \viewleq \vi \land \vi_2 \viewleq \vi
    \land \begin{bracketarray}\fora{\key} \max(\vi_1(\key),\vi_2(\key)) \subseteq \max(\vi(\key)) \land \vi'(\key) = \max(\vi'_1(\key), \vi'_2(\key)) \end{bracketarray} 
\end{multline*}
\end{definition}

%\subsubsection{monotonic post-views}
%Last, the post-views are not necessary match.
%Let consider a kv-store \( \mkvs = \Set{\key \mapsto (0,\txid_0,\emptyset) \lcat (1,\txid,\emptyset) }\):
%\begin{centertikz}
%%Location x
%\node(locx) {$\key_1 \mapsto$};
%\draw pic at ([xshift=\tikzkvspace]locx.east) {vlist={versionx}{%
        %/$0$/$\txid_0$/$\emptyset$
    %, /$1$/$\txid$/$\emptyset$
%}};
%\end{centertikz}
%and the following two execution test:
%\[
    %\ET_1 \vdash (\mkvs, \vi) \csat \fp, (\mkvs',\vi_1) 
    %\qquad 
    %\ET_2 \vdash (\mkvs, \vi) \csat \fp, (\mkvs',\vi_2) 
%\]
%where \( \vi = \vi_1 = \Set{\key \mapsto \Set{0} }\), \(\vi_2 = \Set{\key \mapsto \Set{0,1}} \) and \( \fp = \Set{(\otR, \key, 0)}\).
%This leads to the final kv-store \( \mkvs' = \Set{\key \mapsto (0,\txid_0,\Set{\txid'}) \lcat (1,\txid,\emptyset) } \) for some \( \txid' \):
%\begin{centertikz}
%%Location x
%\node(locx) {$\key_1 \mapsto$};
%\draw pic at ([xshift=\tikzkvspace]locx.east) {vlist={versionx}{%
        %/$0$/$\txid_0$/$\Set{\txid'}$
    %, /$1$/$\txid$/$\emptyset$
%}};

%\end{centertikz}
%It is easy to see \( \ET_1 \cap \ET_2  = \emptyset \) therefore \( \CMs(\ET_1 \cap \ET_2) = \emptyset \), yet \( \CMs(\ET_1) \cap \CMs(\ET_2) = \Set{\mkvs'}\).
%\begin{definition}
%\label{def:et-continuous-postview}
%\label{def:et-monotonic-postview}
%An execution test $\ET$ has \emph{monotonic post-views} if for any key-value store \( \mkvs \)
%views \( \vi, \vi',\vi''\) and fingerprint \( \fp \), 
%\[
%\begin{array}{@{}l@{}}
    %\ET \vdash (\mkvs, \vi) \csat \fp : (\mkvs',\vi') \land \vi' \sqsubseteq \vi'' \implies \ET \vdash (\mkvs, \vi) \csat \fp : (\mkvs',\vi'')
%\end{array}
%\]
%\end{definition}
%%If execution tests enforce \emph{monotonic post-views}, 
%%we have 
%%\( 
    %%\ET_1 \vdash (\mkvs, \vi) \csat \fp, (\mkvs',\vi_1) \implies 
    %%\ET_1 \vdash (\mkvs, \vi) \csat \fp, (\mkvs',\vi_2) 
%%\)
%%thus \( \CMs(\ET_1) \cap \CMs(\ET_2) = \CMs(\ET_1 \cap \ET_2) = \Set{\mkvs'}\).


