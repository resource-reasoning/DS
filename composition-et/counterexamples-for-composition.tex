\subsection{Counter examples for compositionality}
\label{sec:counter-examples-composition}

A desirable property that one would request from execution test is compositionality:
the consistency model induced by a composite execution test can be recovered from the consistency 
models generated by each execution test: that is, 
\[ 
\fora{ \ET_1, \ET_2 } \CMs(\ET_1 \cap \ET_2) = \CMs(\ET_1) \cap \CMs(\ET_2).
\]
However, execution tests do not always satisfy this property.

\subsubsection{Commutativity}
Consider the following:
%
\[
\begin{array}{@{}l | l@{}}
    \hline
    \ET_1 & \ET_2 \\
%    
    \hline
    (\mkvs_{0}, \vi_{0}) \csat \Set{(\otW, \key, 1)} : ( \mkvs_{\key}, \vi_{0})
    &
    (\mkvs_{0}, \vi_{0}) \csat \Set{(\otW, \key', 1)} : ( \mkvs_{\key'}, \vi_{0}) 
    \vspace*{-7pt}\\\\
% %   
    (\mkvs_{\key}, \vi_{0}) \csat  \Set{(\otW, \key', 1)} : (\mkvs',\vi_{0}) 
    &
    (\mkvs_{\key'}, \vi_{0}) \csat \Set{(\otW, \key, 1)} : (\mkvs',\vi_{1}) 
    \\
\hline
\end{array}
\]%
 
\begin{align*}
    \mkvs_{\key} & = \mkvs_{0}[\key \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \stub, \emptyset)] \\
    \mkvs_{\key'} & = \mkvs_{0}[\key' \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \stub, \emptyset)] \\
    \mkvs' & = \mkvs[\key \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \stub, \emptyset) 
                ,\key' \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \stub, \emptyset)] \\
\end{align*}
%

As both $\ET_1$ and $\ET_2$ allow a version with value $1$ to be written for 
$\key, \key'$,  we have $\mkvs' \in \CMs(\ET_1) \cap \CMs(\ET_2)$. 
However, $\ET_1$ and $\ET_2$ enforce a different order in which the writes on $\key, \key'$ must happen; 
thus $\mkvs' \notin \CMs(\ET_1 \cap \ET_2)$. 

In this example, compositionality fails because execution tests 
enforced a particular order in which the updates must be committed, even though such updates 
are non-conflicting: the kv-store obtained after committing such updates is independent of the commit order. This observation is captures in the following definition: 
\begin{definition}
\label{def:conflict-commit}
Two triples $(\cl_1, \fp_1)$ and $(\cl_2, \fp_2)$ are 
conflicting if either $\cl_1 = \cl_2$, or there exists a key $\key$ such that 
$(\otW, \key, \stub) \in \fp_1, (\otW, \key, \stub) \in \fp_2$. 
\end{definition}

\begin{definition}
\label{def:app-et-comm}
An execution test is $\ET$ is \emph{commutative} if, whenever $(\cl_1, \vi_1, \fp_1)$, 
$(\cl_2, \vi_2, \fp_2)$ are non-conflicting, and $\vi_1, \vi_2 \in \Views(\mkvs_0)$,  
then for any $\mkvs_0, \mkvs', \vienv, \vienv'$ we have that 
\begin{centermultline}
(\mkvs_0, \vienv) \toET{(\cl_1, \fp_1)}
\stub \toET{(\cl_2, \fp_2)} (\mkvs', \vienv') \implies
(\mkvs_0, \vienv) \toET{(\cl_2, \fp_2)} 
\stub \toET{(\cl_1, \fp_1)} (\mkvs', \vienv'') 
\land \vienv''(\cl_2) \viewleq \vienv'(\cl_2)
\end{centermultline}
\end{definition}

\begin{proposition}
\label{prop:et-comm-matching-vi-env}
\label{lem:et-comm-matching-vi-env}
Assume an execution test is $\ET$ is \emph{commutative}.
Assume $(\cl_1, \vi_1, \fp_1)$, 
$(\cl_2, \vi_2, \fp_2)$ are non-conflicting, and $\vi_1, \vi_2 \in \Views(\mkvs_0)$,  
then for any $\mkvs_0, \mkvs', \vienv, \vienv'$ we have that:
\begin{centermultline}
(\mkvs_0, \vienv) \toET{(\cl_1, \fp_1)}
\stub \toET{(\cl_2, \fp_2)} (\mkvs', \vienv') \\
{} \implies
(\mkvs_0, \vienv) \toET{(\cl_2, \fp_2)} 
\stub \toET{(\cl_1, \fp_1)} \stub \toET{(\cl_2, \epsilon)} (\mkvs', \vienv')
\end{centermultline}
\end{proposition}

\begin{proposition}
\label{thm:appendix-et-composition-2}
\label{prop:appendix-et-composition-2}
if $\ET_1, \ET_2$ are commutative, then $\ET_1 \cap \ET_2$ is commutative.
\end{proposition}
\begin{proof}
Let \( \ET_{12} = \ET_1 \cap \ET_2 \).
Assume \(\conf_1, \conf_2, \conf_3, \cl, \cl', \vi, \vi', \fp, \fp' \) such that:
\[
    \conf_1 \toET{\cl, \fp}[\ET_{12}] \conf_2 \toET{\cl', \fp'}[\ET_{12}] \conf_3
\]
Therefore, we have:
\[
    \conf_1 \toET{\cl, \fp}[\ET_{1}] \conf_2 \toET{\cl', \fp'}[\ET_{1}] \conf_3 \land 
    \conf_1 \toET{\cl, \fp}[\ET_{2}] \conf_2 \toET{\cl', \fp'}[\ET_{2}] \conf_3
\]
Because \( \ET_1 \)  and \( \ET_2 \) are commutative, there exists a configuration \( \conf'_2 \) such that:
\[
    \conf_1 \toET{\cl', \fp'}[\ET_{1}] \conf'_2 \toET{\cl, \fp}[\ET_{1}] \conf_3 \land 
    \conf_1 \toET{\cl', \fp'}[\ET_{2}] \conf'_2 \toET{\cl, \fp}[\ET_{2}] \conf_3
\]
so we have the proof that: 
\[
    \conf_1 \toET{\cl', \fp'}[\ET_{12}] \conf'_2 \toET{\cl, \fp}[\ET_{12}] \conf_3
\]
\end{proof}

\subsubsection{Matching views}
\label{ex:noblindwrites}
\label{sec:no-blind-writes-counter}
\label{sec:matching-pre-views}
\label{sec:matching-views}
For compositionality of two execution tests, 
it is not enough that one execution test is commutative, since the views used to update kv-stores from two execution tests might not match but still yield the same final kv-store.
The following two counter examples lead us to further restrict the execution tests.

Let consider a kv-store \( \mkvs = \Set{\key \mapsto (0,\txid_0,\emptyset) \lcat (1,\txid,\emptyset) }\):
\begin{centertikz}
%Location x
\node(locx) {$\key \mapsto$};

\draw pic at ([xshift=\tikzkvspace]locx.east) {vlist={versionx}{%
    /$0$/$\txid_0$/$\emptyset$
    , /$1$/$\txid$/$\emptyset$
}};
\end{centertikz}
and the following two execution test:
\[
    \ET_1 \vdash (\mkvs, \vi_1) \csat \fp, (\mkvs',\vi') 
    \qquad 
    \ET_2 \vdash (\mkvs, \vi_2) \csat \fp, (\mkvs',\vi') 
\]
where \( \vi_1 = \Set{\key \mapsto \Set{0} }\), \( \vi' = \vi_2 = \Set{\key \mapsto \Set{0,1}} \) and \( \fp = \Set{(\otW, \key, 2)}\).
This leads to the final kv-store \( \mkvs' = \mkvs\rmto{\key}{\mkvs(\key) \lcat (2,\txid',\emptyset)} \) for some \( \txid' \):
\begin{centertikz}
%Location x
\node(locx) {$\key \mapsto$};

\draw pic at ([xshift=\tikzkvspace]locx.east) {vlist={versionx}{%
    /$0$/$\txid_0$/$\emptyset$
    , /$1$/$\txid$/$\emptyset$
    , /$2$/$\txid'$/$\emptyset$
}};
\end{centertikz}

It is easy to see \( \ET_1 \cap \ET_2  = \emptyset \) therefore \( \CMs(\ET_1 \cap \ET_2) = \emptyset \), yet \( \CMs(\ET_1) \cap \CMs(\ET_2) = \Set{\mkvs'}\).
If execution tests enforce \emph{no blind write}, \( \ET_1\) and \( \ET_2 \) cannot produce the same kv-store, thus \( \CMs(\ET_1) \cap \CMs(\ET_2) = \CMs(\ET_1 \cap \ET_2) = \emptyset\), because the initial views are different.


Let consider a kv-store \( \mkvs = \Set{\key \mapsto (0,\txid_0,\emptyset) \lcat (1,\txid,\emptyset) }\):
\begin{centertikz}
%Location x
\node(locx) {$\key_1 \mapsto$};
\draw pic at ([xshift=\tikzkvspace]locx.east) {vlist={versionx}{%
        /$0$/$\txid_0$/$\emptyset$
    , /$1$/$\txid$/$\emptyset$
}};
\end{centertikz}
and the following two execution test:
\[
    \ET_1 \vdash (\mkvs, \vi) \csat \fp, (\mkvs',\vi_1) 
    \qquad 
    \ET_2 \vdash (\mkvs, \vi) \csat \fp, (\mkvs',\vi_2) 
\]
where \( \vi = \vi_1 = \Set{\key \mapsto \Set{0} }\), \(\vi_2 = \Set{\key \mapsto \Set{0,1}} \) and \( \fp = \Set{(\otR, \key, 0)}\).
This leads to the final kv-store \( \mkvs' = \Set{\key \mapsto (0,\txid_0,\Set{\txid'}) \lcat (1,\txid,\emptyset) } \) for some \( \txid' \):
\begin{centertikz}
%Location x
\node(locx) {$\key_1 \mapsto$};
\draw pic at ([xshift=\tikzkvspace]locx.east) {vlist={versionx}{%
        /$0$/$\txid_0$/$\Set{\txid'}$
    , /$1$/$\txid$/$\emptyset$
}};

\end{centertikz}
It is easy to see \( \ET_1 \cap \ET_2  = \emptyset \) therefore \( \CMs(\ET_1 \cap \ET_2) = \emptyset \), yet \( \CMs(\ET_1) \cap \CMs(\ET_2) = \Set{\mkvs'}\).

To rule out those situations, we further constraint execution tests \( \ET_1 \) and \( \ET_2 \).
Given an execution tests, we the \(\min(\ET, \mkvs, \cl)\)  returns the minimum view for client \( \cl \) under the \( \mkvs \).

\begin{definition}[matching views]
\label{def:match-pre-view}
\label{def:match-view}
Two execution tests $\ET_1$ and $\ET_2$ have matching views if there exists a minimum client view function \( \func{minClientViews}[\ET,\mkvs,\cl] \) for \( \ET_1 \), \( \ET_2 \) and \( \ET_1 \cap \ET_2 \) such that:
\begin{itemize}
    \item for any \( \mkvs, \cl\):
    \begin{centermultline}
        \func{minClientViews}[\ET_1, \mkvs, \cl] \viewcup \func{minClientViews}[\ET_2, \mkvs, \cl] \viewleq \func{minClientViews}[\ET_1 \cap \ET_2, \mkvs, \cl]
    \end{centermultline}
    \item for any \(\mkvs, \mkvs',\fp,\vi_1,\vi_2,\vi_1',\vi_2',\cl\):
\begin{centermultline}
    (\vi_1,\vi'_1) =  \func{minFpViews}[\ET_1,\mkvs,\fp,\mkvs',\cl]
    \land (\vi_2,\vi'_2) =  \func{minFpViews}[\ET_2,\mkvs,\fp,\mkvs',\cl] \\
    \implies 
    \vi'_1 = \func{minClientView}[\ET_1, \mkvs',\cl]
    \land \vi'_2 = \func{minClientView}[\ET_2, \mkvs',\cl]  \\
    \exsts{\vi,\vi'} 
    (\vi,\vi') =  \func{minFpViews}[\ET_1 \cap \ET_2,\mkvs,\fp,\mkvs',\cl]
    \land \vi_1 \sqcup \vi_2 \viewleq \vi
    \land \vi'_1 \sqcup \vi'_2 \viewleq \vi' \\
    {} \land \vi' =  \func{minClientViews}[\ET_1 \cap \ET_2, \mkvs', \cl]
\end{centermultline}
where,
\begin{align*}
    (\vi,\vi') = \func{minFpViews}[\ET, \mkvs,\fp,\mkvs',\cl] & \defiff 
    \begin{multlined}[t]
        \func{minClientViews}[\ET, \mkvs, \cl] \viewleq \vi  \\
        {} \land \func{minClientViews}[\ET, \mkvs', \cl] \viewleq \vi' \\
        {} \land \ET \vdash (\mkvs,\vi) \csat \fp : (\mkvs',\vi') \\
        {} \land \fora{\vi'',\vi'''} \ET \vdash (\mkvs,\vi'') \csat \fp : (\mkvs',\vi''') \\
        {} \implies \vi \viewleq \vi'' \land \vi' \viewleq \vi'''
    \end{multlined} \\
    \vi \sqcup \vi' & \defeq \lambda \key \ldotp \vi(\key) \cup \vi'(\key)
\end{align*}
    \item for \( \ET_1 \) (\(\ET_2\) and \( \ET_1 \cap \ET_2\) respectively),
    if any kv-store \( \mkvs \) contains less information than \( \mkvs' \) then
    \begin{centermultline}
        \func{minClientView}[\ET_1,\mkvs,\cl] \viewleq \func{minClientView}[\ET_1, \mkvs',\cl]
    \end{centermultline}
\end{itemize}
\end{definition}

%\subsubsection{Minimum footprint}
%\sx{This condition might be useless because of the minimum in matching views condition}
 
%Let consider a kv-store \( \mkvs = \Set{\key_1 \mapsto (0,\txid_0,\emptyset) \lcat (1,\txid_1,\emptyset), \key_2 \mapsto (2,\txid_0,\emptyset) \lcat (3,\txid_2,\emptyset)}\):
%\begin{centertikz}
%%Location x
%\node(locx) {$\key_1 \mapsto$};
%\draw pic at ([xshift=\tikzkvspace]locx.east) {vlist={versionx}{%
    %/$0$/$\txid_0$/$\emptyset$
    %, /$1$/$\txid_1$/$\emptyset$
%}};

%%Location y
%\path (versionx.east) + (1,0) node (locy) {$\key_2 \mapsto$};
%\draw pic at ([xshift=\tikzkvspace]locy.east) {vlist={versiony}{%
    %/$2$/$\txid_0$/$\emptyset$
    %, /$3$/$\txid_2$/$\emptyset$
%}};
%\end{centertikz}
%and the following two execution test:
%\[
    %\ET_1 \vdash (\mkvs, \vi_1) \csat \fp, (\mkvs',\vi') 
    %\qquad 
    %\ET_2 \vdash (\mkvs, \vi_2) \csat \fp, (\mkvs',\vi') 
%\]
%where \( \vi_1 = \Set{\key_1 \mapsto \Set{0}, \key_2 \mapsto \Set{0} }\), \( \vi_2 = \Set{\key_1 \mapsto \Set{0}, \key_2 \mapsto \Set{0,1} }\) and \( \fp = \Set{(\otR, \key_1, 0)}\).
%This leads to the final kv-store \( \mkvs' = \mkvs\rmto{\key}{(0,\txid_0,\Set{\txid'}) \lcat (1,\txid_1,\emptyset)} \) for some \( \txid' \):
%\begin{centertikz}
%%Location x
%\node(locx) {$\key_1 \mapsto$};
%\draw pic at ([xshift=\tikzkvspace]locx.east) {vlist={versionx}{%
        %/$0$/$\txid_0$/$\Set{\txid'}$
    %, /$1$/$\txid_1$/$\emptyset$
%}};

%%Location y
%\path (versionx.east) + (1,0) node (locy) {$\key_2 \mapsto$};
%\draw pic at ([xshift=\tikzkvspace]locy.east) {vlist={versiony}{%
    %/$2$/$\txid_0$/$\emptyset$
    %, /$3$/$\txid_2$/$\emptyset$
%}};
%\end{centertikz}
%It is easy to see \( \ET_1 \cap \ET_2  = \emptyset \) therefore \( \CMs(\ET_1 \cap \ET_2) = \emptyset \), yet \( \CMs(\ET_1) \cap \CMs(\ET_2) = \Set{\mkvs'}\).

%\begin{definition}[Minimum footprints]
%\label{def:et-minimum-footprint}
%An execution test $\ET$ has \emph{minimum footprints} if for any key-value store \( \mkvs \)
%views \( \vi, \vi',\vi''\) and fingerprint \( \fp \),
%\[
%\begin{array}{@{}l@{}}
%\ET \vdash (\mkvs, \vi) \csat \fp : (\mkvs',\vi'')
%\land \fora{l,\key,\val} \left( (l, \key, \val) \in \fp \implies \vi(\key) = \vi'(\key) \right) 
%\implies \ET \vdash (\mkvs, \vi') \csat \fp : (\mkvs',\vi'')
%\end{array}
%\]
%\end{definition}

%\subsubsection{monotonic post-views}
%Last, the post-views are not necessary match.
%%If execution tests enforce \emph{monotonic post-views}, 
%%we have 
%%\( 
    %%\ET_1 \vdash (\mkvs, \vi) \csat \fp, (\mkvs',\vi_1) \implies 
    %%\ET_1 \vdash (\mkvs, \vi) \csat \fp, (\mkvs',\vi_2) 
%%\)
%%thus \( \CMs(\ET_1) \cap \CMs(\ET_2) = \CMs(\ET_1 \cap \ET_2) = \Set{\mkvs'}\).

%\begin{definition}
%\label{def:et-continuous-postview}
%\label{def:et-monotonic-postview}
%An execution test $\ET$ has \emph{monotonic post-views} if for any key-value store \( \mkvs \)
%views \( \vi, \vi',\vi''\) and fingerprint \( \fp \), 
%\[
%\begin{array}{@{}l@{}}
    %\ET \vdash (\mkvs, \vi) \csat \fp : (\mkvs',\vi') \land \vi' \sqsubseteq \vi'' \implies \ET \vdash (\mkvs, \vi) \csat \fp : (\mkvs',\vi'')
%\end{array}
%\]
%\end{definition}

