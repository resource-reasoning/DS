\subsection{Counter example for composition}
\begin{example}
\label{ex:noncompositional.et}
Define the following terms: 
\[
\begin{array}{lcl}
\hh_0 &=& [\ke_1 \mapsto (\val_0, \txid_0, \emptyset) , \ke_2 \mapsto (\val_0, \txid_0, \emptyset)]\\
\hh_1 &=& \big[\ke_1 \mapsto \big( (\val_0, \txid_0, \emptyset) \lcat (\val_2, \txid_{\cl_1}^{1}, \emptyset)\big) , \ke_2 \mapsto (\val_0, \txid_0, \emptyset) \big]\\
\hh_2 &=& \big[\ke_1, \mapsto (\val_0, \txid_0, \emptyset), \ke_2 \mapsto \big( (\val_0, \txid_0, \emptyset) \lcat (\val_2, \txid_{\cl_2}^{1}, \emptyset) \big) \big]\\
\hh_3 &=& \big[\ke_1 \mapsto \big( (\val_0, \txid_0, \emptyset) \lcat (\val_2, \txid_{\cl_1}^{1}, \emptyset)\big), 
                         \ke_2 \mapsto \big( (\val_0, \txid_0, \emptyset) \lcat (\val_2, \txid_{\cl_2}^{1}, \emptyset) \big) \big]\\
&&\\
\vi_0 &=& [\ke_1 \mapsto \{0\}, \ke_2 \mapsto \{0\}]\\
\viewFun_0 &=& [\cl_1 \mapsto \vi_0, \cl_2 \mapsto \vi_0]\\
&&\\
\ET_1 &\vdash& (\hh_0, \vi_0) \triangleright \{(\otW, \ke_1, \val_1)\} : \vi_0\\
\ET_1 &\vdash& (\hh_1, \vi_0) \triangleright \{(\otW, \ke_2, \val_2)\} : \vi_0\\
&&\\
\ET_2 &\vdash& (\hh_0, \vi_0) \triangleright \{(\otW, \ke_2, \val_2)\} : \vi_0\\
\ET_2 &\vdash& (\hh_2, \vi_0) \triangleright \{(\otW, \ke_1, \val_1)\} : \vi_0.
\end{array}
\]
There are no further constraints on $\ET_1, \ET_2$.
For $\ET_1$ and $\ET_2$, we have that 
\[
\begin{array}{l}
(\hh_0, \viewFun_0) \xrightarrowtriangle{(\cl_1, \{(\otW, \ke_1, \val_1)\})}_{\ET_1} 
(\hh_1, \viewFun_0) \xrightarrowtriangle{(\cl_2, \{(\otW, \ke_2, \val_2)\})}_{\ET_1} (\hh_3, \viewFun_0), \\
(\hh_0, \viewFun_0) \xrightarrowtriangle{(\cl_2, \{(\otW, \ke_2, \val_2)\})}_{\ET_2} 
(\hh_2, \viewFun_0) \xrightarrowtriangle{(\cl_1, \{(\otW, \ke_1, \val_1)\})}_{\ET_2} (\hh_3, \viewFun_0).\\
\end{array}
\] 
Therefore, we have that $\hh_3 \in \CMs(\ET_1) \cap \CMs(\ET_2)$. On the other hand, it is immediate 
to observe that $\ET_1 \cap \ET_2 = \emptyset$, and therefore $\hh_3 \notin \CMs(\ET_1 \cap \ET_2)$.
\end{example}
The reason why compositionality fails, for the execution tests of \cref{ex:noncompositional.et}, 
is that both the execution tests $\ET_1, \ET_2$ require that the fingerprints 
$\{(\otW, \ke_1, \_)\}, \{(\otW, \ke_2, \_)\}$ commit in different order: in $\ET_1$, the write to $\ke_1$ must commit 
before the write to $\ke_2$, and vice versa for $\ET_2$. On the other hand, 
because the two fingerprints above do not write to the same key, 
the order in which they are committed should not be relevant: by changing the order 
in which different clients commit such fingerprints to a kv-store, the result stays the same. 

Requiring execution tests to be commutative is a necessary step for ensuring 
that the specification of consistency models are compositional. However, it 
is not sufficient. The next example shows how compositionality fails 
for commutative execution tests. 

\begin{example}
\label{ex:noblindwrites}
For any $n \in \Nat$, let $[n] = \{0,\cdots, n\}$.
Consider the execution tests $\ET_1, \ET_2$ defined below: 
\[
\begin{array}{lcl}
\ET_1 \vdash (\hh, \vi) \triangleright \opset : \vi' &\iff& 
\forall \ke.\;(\otW, \ke, \_) \in \opset \implies \vi(\ke) = \vi'(\ke) = [0]\\
\ET_2 \vdash (\hh, \vi) \triangleright \opset : \vi'(\ke) &\iff& 
\forall \ke. \;(\otW, \ke, \_ ) \in \opset \implies \vi(\ke) = [ \lvert \hh(\ke) \rvert - 1] \wedge \vi'(\ke) = [\lvert \hh(\ke) \rvert ] \\
\end{array}
\]
It is immediate to observe that both $\ET_1$ and $\ET_2$ are commutative. However, 
consider the kv-store $\hh_2 = [\ke \mapsto (\val_0, \txid_0, \emptyset) \lcat (\val_1, \txid_{\cl}^1, \emptyset) \lcat (\val_2, \txid_{\cl}^2, \emptyset)]$. 
We have that $\hh \in \CMs(\ET_1)$ and $\hh \in \CMs(\ET_2)$.
Let in fact $\hh_1 = [\ke \mapsto (\val_0, \txid_0, \emptyset) \lcat (\val_1, \txid_{\cl}^1, \emptyset)]$, $\vi_{i} = [\ke \mapsto [i] ]$.
%\ac{Seriously, square brackets are being used everywhere (though all of this is standard notation. Maybe $\langle n \rangle$ for $\{0,\cdots, n\}$ is 
%a better notation?
%\sx{  \( \ke \mapsto \langle n \rangle \) is cool. }
%}
We have the following sequences of reductions: 
\[
\begin{array}{l}
(\hh_0, \vi_0) \xrightarrowtriangle{(\cl, \{(\otW, \ke, \val_1)\})}_{\ET_1} 
(\hh_1, \vi_0) \xrightarrowtriangle{(\cl,\{(\otW, \ke, \val_2)\})}_{\ET_1} (\hh_2, \vi_0)\\
(\hh_0, \vi_0) \xrightarrow{(\cl, \{(\otW, \ke, \val_1)\})}_{\ET_2} (\hh_1, \vi_1) \xrightarrow{(\cl, \{(\otW, \ke, \val_2)\})}_{\ET_2} 
(\hh_2, \vi_2)
\end{array}
\]
On the other hand, we can observe that $\hh_2 \notin \CMs(\ET_1 \cap \ET_2)$. $\ET_1$ allows a client to 
commit a transaction if its view only includes the initial version of each key it writes. $\ET_2$ allows a client 
to commit a transaction when its view include all the versions for each key it writes. In $\ET_1 \cap \ET_2$ 
a client can commit a transaction only if the initial version of each key it writes is also the only version in the kv-store: 
as a result, $\CMs(\ET_1 \cap \ET_2)$ never contains a  kv-stores $\hh$ such that $\hh(\ke) > 1$ for some key $\ke$; 
in particular, $\hh_2 \notin \CMs(\ET_1 \cap \ET_2)$.
\end{example}
\ac{Two possible reasons why compositionality fails: because of blind writes, or because the test $\ET_1$ hinders progress, 
i.e. it is not possible to replace a view with a more up-to-date one to enable progress. We must choose which assumption 
we make on the consistency model.}

One reason why compositionality fails in \cref{ex:noblindwrites} is that the execution tests $\ET_1$ and $\ET_2$ do not contain 
any information about the views that client $\cl$ used to commit the transactions $\txid_{\cl}^1, \txid_{\cl}^2$. 
To solve this problem we adopt the \emph{no blind writes} assumption, that requires that a client never commits 
a transaction that writes a key, without reading such a key beforehand. Many implementations of consistency models 
in distributed key-value stores respect the no blind writes assumption. 
