\section{Formal Model}
\label{sec:model}
\label{sec:semantics}
\ac{I am going to split this section into two, for the sake of clarity. 
As of now, the structure that I have in mind for the paper is as follows: 
Section 2 (i.e. this section) contains the notion of key-value store, view, snapshot, 
execution tests, and consistency model  -i.e. sets of key-value stores- 
induced by an execution test). Then Section 3 discusses 
the semantics of programs, and possibly we state the result 
of adequateness. In Section 4 we discuss the equivalence of consistency 
models specifications with respect to axiomatic ones. In Section 5 
we present the logic and litmus tests examples.}

\begin{wrapfigure}[7]{r}{0.33\textwidth}
\vspace{-10pt}
\begin{verbatim}
interface Transaction {
    Start(); 
    Read(Key k);
    Write(Key k, Value v); 
    Commit();    }
\end{verbatim}
\vspace{-10pt}
\caption{Example of Transaction API.}
\label{fig:api}
\end{wrapfigure}
We focus on an abstract computational model where multiple client programs can access and update keys in a key-value store using atomic transactions. 
In general, clients are provided with a simple \textit{API} such as the one depicted in \cref{fig:api} \cite{gdur,physicsnmsi,clockSI}\footnote{It is 
often the case that key-value stores provide a mechanism to wrap more transactions inside a session, and give 
provide appropriate APIs to handle sessions. For the sake of simplicity, in this paper we assume that each client executes transactions 
within a single session.}
\textbf{AC: (not using boxes because they clash with wrapfig. Technically, clockSI also has a delete operation, this should be either pointed out 
or the citation be substituted with something else.)}, while both the implementation details and the system architecture are hidden from clients. 
Because (distributed) key-value stores only give weak consistency guarantees of the data to their clients, the latter are 
not ensured to read the most up-to-date version of a key.
%In an ideal world, when executing a transaction clients would read the most up-to-date version of a key. In a distributed setting 
%this approach, known as (strict) serialisability, would require a continuous synchronisation between the different components of 
%the system, which impacts performance and limits scalability. To this end, the database only provides weak consistency model
%\ac{This sentence should probably be in the introduction.}

Following these intuitions, we model a key-value stores, or \emph{kv-store}, as a centralised unit where multiple versions 
are stored for each key (\cref{sec:mkvs-view}). Versions consist of a value and the meta-data of the transactions that wrote and 
read such a version. In practical systems, the meta-data is usually encoded using either timestamps 
\cite{physicsnmsi,clockSI} or vector clocks \cite{gdur}. We focus on key-value stores whose transactions 
enjoy \emph{atomic visibility}, meaning that \textbf{(i)} transactions read their data from an atomic 
snapshot of the key-value store, and \textbf{(ii)} a transaction can observe either none or all 
of the updates performed by another transaction. In other words, a transaction only reads (writes) at most 
one version for each key.
Because clients may observe potentially out-of-date versions of the system, we introduce the notion of \emph{views}. 
Intuitively, a view records the version of each key that a client observes at a given time. We use views 
to determine the snapshot taken by transactions executed by clients.

A consistency model is a contract between the key-value store and its clients. We distinguish 
between \emph{data-centric} consistency models \cite{framework-concur}, which impose constraints 
on the structure of the key value store, and \emph{client-centric} consistency models, 
which impose constraints on the observations and updates made by a single client 
\cite{terry1994session}. 
To specify weak consistency models, 
we introduce the notion of \emph{execution tests} (sec:execution.tests). An execution test is a predicate 
that specifies when a client is allowed to execute a transaction carrying a given 
set of read and write operations, or \emph{fingerprint}. Therefore, an execution 
test constrains how the state of the key-value store may evolve;
by considering at all the possible evolutions of the key-value store under said execution test, 
we determine a consistency model. For example, an execution test for (strict) serialisability 
requires that a transaction can be executed by a client, only if it observes the most up-to-date 
version for each key. 
We give several examples of execution tests that capture both data-centric and 
client-centric consistency models. 

The idea of specifying consistency models using execution tests has been 
already proposed in \cite{seebelieve}; however, their notion of execution 
test is intrinsecally more complex than ours: to determine 
whether a transaction can commit, the total order in which all past transactions 
have committed must be known. This knowledge is not needed in our setting.
%the author require 
%the knowledge of the total order in which all past transactions have been 
%executed, to determine whether a new transaction can commit.

%%\ac{Can't cite documentations of real databases, as they usually have a much more complicated API.}
%
%%Transactions in our model execute atomically, though they have different effects on the key-value stores depending on their associated \emph{consistency model}.
%%A consistency model controls how the key-value store evolves.
%%A common model is \emph{serialisability}, where transactions appear to execute one after another in a sequential order.
%%This notion of sequential execution is however not necessary for many weaker models. As such, upon commencing execution, a transaction may not observe the most up-to-date values for keys. 
%
%To address this, we 
%first model 
%the state of the system using \emph{multi-version key-value stores (MKVSs)} (\cref{sec:mkvs-view}). 
%An MKVS keeps track of all versions (values) written for keys, as well as the information about the transactions that read and wrote such versions. 
%To model the potential out-of-date observation, we introduce \emph{views}.
%A view decides the observable versions of keys for a client.
%Therefore, in order to execute a transaction, the client first takes \emph{a snapshot} of the system with the view, executes the transaction locally with respect to its snapshot (\cref{sec:trans-semantics}), and afterwards commits the effect of the transaction if the change is allowed by the underlying consistency model (\cref{sec:prog-semantics}).


%We first introduce MKVSs and views (\secref{sec:mkvs-view}) and.
%We starts with the syntax of programs followed by the semantics of transaction.
%Finally, we will give the semantics for the entire programs.


\input{\RootPath/semantics/database-view.tex}
\input{\RootPath/semantics/execution-tests.tex}
\input{\RootPath/semantics/trans.tex}
%\input{\RootPath/semantics/prog.tex}
%\input{\RootPath/semantics/example.tex}
