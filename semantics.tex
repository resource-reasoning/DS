\section{Semantics}
\label{sec:semantics}

\sx{program vs. transaction}
We focus on an abstract computational model where multiple client programs can access and update keys in a key-value store using atomic transactions. 
Transactions in our model execute atomically, though they have different effects on the key-value stores depending on their associated \emph{consistency model}.
A consistency model controls how the key-value store evolves.
A common model is \emph{serialisability}, where transactions appear to execute one after another in a sequential order.
This notion of sequential execution is however not necessary for many weaker models. As such, upon commencing execution, a transaction may not observe the most up-to-date values for keys. 

To address this, we first model the state of the system using \emph{multi-version key-value stores (MKVSs)} (\cref{sec:mkvs-view}). 
An MKVS keeps track of all versions (values) written for keys, as well as the information about the transactions that read and wrote such versions. 
To model the potential out-of-date observation, we introduce \emph{views}.
A view decides the observable versions of keys for a client.
Therefore, in order to execute a transaction, the client first takes \emph{a snapshot} of the system with the view, executes the transaction locally with respect to its snapshot (\cref{sec:trans-semantics}), and afterwards commits the effect of the transaction if the change is allowed by the underlying consistency model (\cref{sec:prog-semantics}).


%We first introduce MKVSs and views (\secref{sec:mkvs-view}) and.
%We starts with the syntax of programs followed by the semantics of transaction.
%Finally, we will give the semantics for the entire programs.


\input{\RootPath/semantics/database-view.tex}
\input{\RootPath/semantics/trans.tex}
\input{\RootPath/semantics/prog.tex}
\input{\RootPath/semantics/example.tex}
