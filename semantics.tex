\section{Semantics}
\label{sec:semantics}

\sx{program vs transaction}
We focus on an abstract computational model where multiple client programs can access and update keys in a key-value store using atomic transactions. 
Transactions in our model execute atomically, though they have different effect on the key-value stores depending on the \emph{consistency model}.
A consistency model controls how the key-value store evolves.
A common model is  \emph{serialisability}, where transactions appear one after another, yet it is not necessary for many weaker model, which means that, at the moment of executing, a transaction may not observe the most up-to-date values of keys. 

To overcome this issue, we first model the state of the system using \emph{multi-version key-value stores (MKVSs)} (\secref{sec:mkvs-view}). 
It keeps track of all the versions written for any key, as well as the information about the transactions that read and wrote such versions. 
To model the potential out-of-date observation, we intrude \emph{views}.
A view decides the observable versions of keys for a client.
Therefore, when a client want to commit a transaction, it first takes \emph{a snapshot} of the system with the view, executes internally with respect to the snapshot (\secref{sec:trans-semantics})  and afterwards commits the effect of the transaction if the change is allowed by the consistency model (\secref{sec:prog-semantics}).


%We first introduce MKVSs and views (\secref{sec:mkvs-view}) and.
%We starts with the syntax of programs followed by the semantics of transaction.
%Finally, we will give the semantics for the entire programs.


\input{\RootPath/semantics/database-view.tex}
\input{\RootPath/semantics/trans.tex}
\input{\RootPath/semantics/prog.tex}
\input{\RootPath/semantics/example.tex}
