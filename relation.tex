\section{Consistency Models: Dependency Graphs and Abstract Executions}
\label{sec:other_formalisms}


We demonstrate that our consistency models for kv-stores
are equivalent to the declarative consistency models for 
dependency graphs \cite{adya} 
and abstract executions \cite{ev_transactions,framework-concur}. 
We outline our results here, and refer the reader
to \cref{sec:app-abstract-semantics-sound-complete,sec:et-sound-complete-constructor,app:et_sound_complete} for the full details.


\subsection{Relating KV-Stores and Dependency Graphs}
\label{sec:dep_graphs}
Dependency graphs \cite{adya-icde,adya} provide  perhaps the most
well-known 
formalism used for specifying transactional consistency models. 
A dependency graph $\Gr$ is a directed, labelled graph whose 
nodes denote transactions, and whose edges denote \emph{dependencies} between transactions.  
More specifically, nodes are labelled with a transaction identifier
and the fingerprint associated with the  transaction. 
Edges are labelled with a dependency relation $\SO, \WR, \WW, \RW$, in the 
same spirit of dependencies of transactions in kv-stores in \cref{sec:cm}.
An example of dependency graph is given in \cref{fig:dependency-graph}.
%
%\begin{enumerate*}
%    \item a \emph{session order} edge, $\txid_1 \toEDGE{\SO} \txid_2$, 
%	\item a \emph{read dependency} edge, $\txid_1 \toEDGE{\WR} \txid_2$, denotes
%that transaction $\txid_2$ reads a version written by $\txid_1$;
%	\item a \emph{write dependency} edge, $\txid_1 \toEDGE{\WW} \txid_2$, denotes that $\txid_2$ overwrites a version written by $\txid_1$; and 
%	\item an \emph{anti-dependency} edge, $\txid_1 \toEDGE{\RW} \txid_2$, denotes that $\txid_2$ overwrites a version read by $\txid_2$. 
%\end{enumerate*}
We give the formal definition of dependency graphs in \cref{app:depgraphs}.

We can always {extract} a dependency graph  from a kv-store, and vice-versa. 
%we choose the transaction identifiers appearing in $\mkvs$ as the nodes of $\Gr$, 
%and let $\SO$ as defined in \cref{subsec:kvstores}, and $ \WR, \WW, \RW$  
%be as defined in \cref{sec:c}.
For example, \cref{fig:dependency-graph} corresponds to the dependency graph extracted from the kv-store in \cref{fig:ser-disallowed}. 
%In fact, this construction can be reversed; see \cref{app:depgraphs}.
%we show that this construction can be reversed, thus giving 
%rise to the following result: 
\begin{theorem}
\label{thm:kv_graph_isomorph}
Dependency graphs are isomorphic to kv-stores.
\end{theorem}

\input{dep-graph-and-aexec-graph.tex}

Consistency models using dependency graphs can be specified by
constraining the shape of the graphs, typically by requiring the absence of certain cycles.  For example, strict serialisability is defined as
the set of dependency graphs with no cycles. %where $(\SO \cup \WW \cup \WR \cup \RW)^+$ is acyclic.
We can immediately use such constraints to define execution tests on
kv-stores, and hence consistency models for kv-stores. However, to show 
that our consistency models over kv-stores given in~\cref{fig:execution-tests} are equivalent
to existing consistency model definitions using dependency graphs,
we first prove that our models are equivalent
to existing definitions using abstract executions, and then appeal 
to the results of \citet{laws} showing the equivalence between definitions using dependency graphs and those using abstract executions.  


%Note that we use dependency relations in a fundamentally 
%different way from dependency graph specifications \cite{adya}.
%In particular, dependency graph specifications are of a declarative nature: they are specified by placing constraints on the structure of graphs admitted by a consistency model.
%By contrast, our execution tests use dependency relations to define consistency models in a constructive way: they are used to restrict the views of clients before or 
%after committing a transaction. 


%\sx{quoting from Azalea, the following text may put here:\\
%As we will see shortly, we use dependencies in a way fundamentally 
%different from Adya's dependency graphs \cite{adya}, 
%a well-known mathematical structure used for specifying consistency models that is introduced 
%formally in \cref{sec:dep_graphs}.
%Adya's specifications are of a declarative nature: dependency models are specified by 
%placing constraints on the structure of dependency graphs admitted by a consistency model, using the dependency graph counterpart 
%of the relations introduced above. 
%In contrast, execution tests define consistency models in a constructive way. Dependencies 
%over kv-stores are used by execution tests to restrict the views of clients (i.e the sets of versions that clients must see) before or 
%after committing a transaction. The consistency model induced $\ET$ corresponds 
%to the set of kv-stores that can be constructed by allowing clients to commit transactions only 
%when the conditions on such views are respected. This approach is agnostic of the structure 
%of kv-stores contained in $\CMs(\ET)$.}

%Dependency graph-based specifications can be converted into
%execution-test-based ones: such execution tests prevent committing
%transactions that result in kv-stores whose associated dependency
%graph violates the constraints imposed by the consistency model.
% the effects of committing a transaction to kv-store $\mkvs$ leads to $\mkvs'$, 
%then check that dependency graph extracted from $\mkvs'$ contains no cycles prohibited by the dependency graph-based specification. 
%
%\mypar{Relating KV-Stores and Abstract Executions}
%\emph{Abstract executions} \cite{ev_transactions,framework-concur} are an alternative formalism for defining consistency models. 
%As with dependency graphs, an abstract execution graph $\aexec$
%is a directed graph with its nodes representing transactions (with each node labelled with a transaction identifier and a set of (read/write) operations), 
%and its edges representing certain relations between transactions. 
%An example abstract execution graph is depicted in \cref{fig:abstract_execution}. 
%Each edge is labelled by either the \emph{visibility} ($\VIS$) or \emph{arbitration} ($\AR$) relation. 
%The $\VIS$ is an irreflexive order on transactions such that $\txid_1 \toEDGE{\VIS} \txid_2$ denotes that the effects (updates) of $\txid_1$ are visible to $\txid_2$. 
%The $\AR$ is a strict total order on transactions such that $\txid_1 \toEDGE{\AR} \txid_2$ denotes that the updates performed by $\txid_2$ are newer than those of $\txid_1$. 
%Moreover, $\AR$ contains $\VIS$ ($\VIS \subseteq \AR$) and agrees with the session order ($\SO \subseteq \AR$).
%Lastly, abstract executions observe the \emph{last-write-wins} policy: 
%a transaction reading $\key$ always fetches the latest visible write ($\VIS$ predecessor) on $\key$.
%We refer the reader to \cref{sec:abstract-execution} for full details.
%
%Following \cite{laws}, we can always \emph{extract} a dependency graph $\Gr_{\aexec}$ from an abstract execution $\aexec$, and thus a kv-store $\mkvs_{\aexec}$ via \cref{thm:kv_graph_isomorph}---see \cref{app:aexec2kv} for the formal details.
%We write  $\mkvs_\aexec$ for the kv-store extracted from $\aexec$ using this construction.  
%Moreover, we show that there is a \emph{Galois connection}
%between $\ET_{\top}$ traces, the weakest possible execution test and abstract executions (\cref{sec:galois-kv-aexec}).
%
%As with dependency graphs, consistency models using abstract executions are defined by constraining the shape of abstract execution graphs via a set of \emph{axioms} $\Ax$, \eg imposing certain conditions on $\VIS$. %the absence of certain cycles.
%All consistency models presented in this paper have an equivalent axiomatic definition based on abstract executions~\cite{framework-concur,laws}. 
%Proving the equivalence of execution test-based and abstract execution-based definitions is non-trivial; 
%however, we have observed that all proofs follow the same \emph{structure}, so long as certain conditions hold. 
%We develop the meta-theory to capture this proof structure.
%Our meta-theory is non-trivial; we refer the reader to \cref{sec:kv2aexec-sound-complete} for the full details. 
%We give an intuitive account of the two conditions required by our meta-theory, and then state our equivalence theorem. 
%
%Given a set of axioms $\Ax$, we define $\CMa(\Ax) \defeq \Set{ \aexec }[ \aexec \text{ sats.} \ \Ax ]$.
%Our first condition is the \emph{soundness} of an execution test against an axiomatic definition.
%An execution test $\ET$ is sound against an axiomatic definition $\Ax$ if:
%for all $n$ and for all \( \ET \)-traces \( \tau \) with \( n \) steps, 
%we can construct $\aexec_0, \cdots, \aexec_n$ and \( \mkvs_i = \mkvs_{\aexec_i} \) such that 
%for each step \( (\mkvs_i, \vi_i) \csat \fp_i : (\mkvs_{i+1}, \vi_{i+1}) \) in \( \tau \),
%the new $\VIS$ edges in \( \aexec_{i+1} \) (those not in $\aexec_i$)
%%, which links transactions included in the view \( \vi_i \) to the new transaction \( \txid_i \),
%satisfy \( \Ax \).
%The formal definition of execution test soundness is given in \cref{sec:kv2aexec-sound-complete}.
%
%Our second condition is the \emph{completeness} of an execution test against an axiomatic definition.
%Let $\txid_i$ denote the $i$\textsuperscript{th} transaction of $\aexec$ in its $\AR$ order, and $\aexec^{i}$ denote the restriction of $\aexec$ to $\txid_1 \cdots \txid_i$. 
%An execution test $\ET$ is complete against an axiomatic definition $\Ax$ if:
%for all abstract executions \( \aexec \) that satisfy \( \Ax \) containing $n$ transactions, 
%all $i \in \Set{1 \cdots n}$, views $\vi_i, \vi'_i$, transactions $\txid'$, and fingerprints $\fp_i$,
%whenever
%\begin{enumerate*}
%	\item $\txid'$ is the immediate $\SO$-successor of $\txid_i$;
%	\item \( \vi_i \) includes all visible transactions of \( \txid_i \); 
%    \item $\vi'_i$ includes all visible transactions, equal or committed before \( \txid_i \), of $\txid'$; and
%	\item $\fp_i$ is the fingerprint of $\txid_i$, 
%\end{enumerate*} 
%then $\ET \vdash (\mkvs_i, \vi_i) \csat \fp_i : (\mkvs_{i+1}, \vi_{i+1})$.
%The formal definition of execution test completeness is given in \cref{sec:kv2aexec-sound-complete}.
%
%Finally, we state our equivalence theorem below (\cref{thm:main-body-et_soundness_completeness}), with its full proof in \cref{sec:kv2aexec-sound-complete}. 
%This theorem ensures that if an execution test is sound and complete against a set of axioms $\Ax$, 
%then the consistency model induced by $\ET$ corresponds to the kv-stores extracted from abstract executions satisfying $\Ax$.
%
%\begin{theorem}
%\label{thm:main-body-et_soundness_completeness}
%For all $\ET, \Ax$, if $\ET$ is sound against $\Ax$, then:
%\(
%\CMs(\ET) \subseteq \Set{ \mkvs_\aexec }[ \aexec \in \CMs(\Ax)]
%\).
%For all $\ET, \Ax$, if $\ET$ is complete against $\Ax$, then:
%\(
%\Set{ \mkvs_\aexec }[ \aexec \in \CMs(\Ax)]  \subseteq \CMs(\ET)
%\).
%\end{theorem} 
%
%In \cref{sec:spec-proof} we apply \cref{thm:main-body-et_soundness_completeness} and show all our definitions in \cref{fig:execution_tests} 
%are sound and complete against (equivalent to) existing axiomatic definitions on abstract executions.
%
%
%\subsection{Andrea's Version}
\subsection{Relating KV-Stores and Abstract Executions}
We compare our consistency model specifications using execution tests over kv-stores 
with an alternative, axiomatic specification style based on abstract 
executions \cite{framework-concur}, defined shortly. 
Our main contribution here is the development of a general proof technique for proving the equivalence of our execution-test-based specifications and abstract-execution-based specifications.
Our proof technique keeps the proof obligations (conditions that must be satisfied by its user) to a minimum. 
In particular, the user only needs to show that the constraints on client views in execution tests relate to analogous constraints on visibility edges in abstract executions.
We then provide a mapping between the $\ET$-traces to 
$\mkvs$, to a set of abstract executions that satisfy the axiomatic specification corresponding to $\ET$.
Here we use our proof technique to prove that the execution 
tests for serialisability ($\SER$) are equivalent to their 
axiomatic specifications. In \cref{sec:spec-proof} we apply our proof technique 
to show that all the execution tests from \cref{fig:execution.tests} are equivalent 
to their respective axiomatic specifications. 

%\textbf{Main points: need to make sure that these are clear throughout the text.}
%\begin{itemize}
%\item Proof technique for proving the equivalence of specifications using kv-store 
%with those using abstract executions, which is based into mapping $\ET$-traces 
%for a given execution test $\ET$ into sets of abstract executions satisfying the set of axioms $\Ax$.
%\item The core of the proof technique is rooted in the equivalence between the most permissive 
%execution test $\ET$ with Eventual Consistency/Read Atomic (no axioms), which we prove first.
%We show that any $\ET_{\top}$-trace terminating into a kv-store $\mkvs$ can be mapped into a 
%\textbf{maximal} set of abstract executions whose underlying kv-store is $\mkvs$, and that 
%any abstract execution $\aexec$ with underlying kv-store $\mkvs$ can be mapped into a \textbf{maximal} set of 
%$\ET_{\top}$-traces. Both definitions are by induction. 
%I think the maximal part was not stressed before, and it is kind of important. 
%
%\item Our proof technique reduces the proof obligations for proving the equivalence of 
%an execution test $\ET$ with an axiomatic specification $\Ax$ to the commit of a single 
%transaction. Soundness amounts to prove that each kv-store $\mkvs$ generated by $\ET$ 
%can be obtained as the underlying kv-store of some abstract execution that satisfies $\Ax$. 
%To do this, we reuse the construction adopted for the most permissive execution test. 
%
%\end{itemize}

%Abstract executions provide another formalism for specifying
%transactional consistency models. 
\subsubsection{Abstract Executions}
Abstract executions are labelled graphs 
whose nodes comprise transaction identifiers and their fingerprints. 
These nodes may be connected either by a \emph{visibility edge}, $\txid \xrightarrow{\VIS} 
\txid'$, when $\txid'$ sees the updates of $\txid$;  or an \emph{arbitration edge}, $\txid \xrightarrow{\AR} 
\txid'$, when $\txid'$ updates overwrite $\txid$ updates.
\Cref{fig:abstract_execution} depicts an example abstract execution.
%An abstract execution is a directed,
%labelled graph whose nodes consist of transaction identifiers and  their 
%associated fingerprints, 
%and  %are labelled with a transaction identifier and the associated fingerprint. 
% edges labelled  $\VIS$
%or $\AR$ describe  information  which is locally available to  transactions: 
%\begin{itemize}
%\item edge $\txid \xrightarrow{\VIS} \txid'$ denotes that  when transaction 
%$\txid'$ is executed  it sees the updates of $\txid$; and 
%\item edge $\txid \xrightarrow{\AR} \txid'$ denotes  that updates 
%performed by $\txid'$ are newer than those of $\txid$. 
%\end{itemize}
% \emph{Abstract executions} \cite{ev_transactions} 
%are directed graph with its nodes representing transactions (with each node labelled with a transaction identifier and a set of (read/write) operations), 
%and its edges representing certain relations between transactions. 
%An example abstract execution graph is depicted in \cref{fig:abstract_execution}. 
%Each node is . 
%Each edge is labelled by either the \emph{visibility} ($\VIS$) or \emph{arbitration} ($\AR$) relation. 
%The $\VIS$ is an irreflexive order on transactions such that $\txid_1 \xrightarrow{\VIS} \txid_2$ denotes that the effects (updates) of $\txid_1$ are visible to $\txid_2$. 
%The $\AR$ is a strict total order on transactions describing the commit order:  $\txid_1 \xrightarrow{\AR} \txid_2$ denotes that $\txid_1$ commits before $\txid_2$. 
%Moreover, $\AR$ contains $\VIS$ ($\VIS \subseteq \AR$) and agrees with the session order: 
%if $\txid_{\cl}^{n} \xrightarrow{\AR}  \txid_{\cl}^{m}$, then $n < m$.
\begin{definition}[Abstract executions]
\label{def:main-body-absexec}
\label{def:main-body-aexec}
An {\em abstract execution} is a triple $\aexec = (\TtoOp{T}, \VIS, \AR)$, where 
 $\TtoOp{T}: \TxID \parfun \pset{\Ops}$ is a partial  
 %$\TtoOp{T}: \TxID_{0} \parfinfun \pset{\Ops}$ is a partial, finite 
function mapping transaction identifiers to 
fingerprints, with $\TtoOp{T}(\txid_{0}) = \Set{ (\otW, \key, \val_{0}) }[ \key \in \Keys]$, 
$\VIS \subseteq \dom(\TtoOp{T}) \times \dom(\TtoOp{T})$ is an irreflexive relation 
such that, for any $\txid \in \dom(\TtoOp{T})$, $\txid_{0}
\xrightarrow{\VIS} \txid$ for the initial transaction $\txid_0$, and 
%called \emph{visibility}, 
$\AR \subseteq \dom(\TtoOp{T}) \times \dom(\TtoOp{T})$ is a strict, total order 
such that $\VIS \subseteq \AR$, $\min_{\AR}(\dom(\TtoOp{T})) = \txid_{0}$
and $\txid_{\cl}^{n} \xrightarrow{\AR} \txid_{\cl}^{m}$ only if $n < m$. 
%Furthermore, for any transaction $\txid \in \dom(\TtoOp{T})$, and $\key \in \Keys$, let 
%$\visibleWrites_{\aexec}(\key, \txid) = \VIS^{-1}(\txid) \cap \{\txid' \mid (\otW,\key, \stub) \in \TtoOp{T}(\txid')\}$; 
%we require that whenever  $(\otR, \key, \val) \in \TtoOp(\txid)$ for some $\key, \val$ 
%and $\txid \in \dom(\TtoOp{T})$, then either $\visibleWrites_{\aexec}(\key, \txid) = \emptyset$ and 
%$\val$ is the default value $\val_{0}$, or the transaction $\txid' = \max_{\AR}(\visibleWrites_{\aexec}(\key, \txid))$ 
%is defined and $(\otR, \key, \val) \in \TtoOp{T}(\txid')$.
\end{definition}
Given an abstract execution $\aexec = (\TtoOp{T}, \VIS, \AR)$,  we let $\TtoOp{T}_{\aexec} = \TtoOp{T}$, 
$\VIS_{\aexec} = \VIS$ and $\AR_{\aexec} = \AR$. 
We write $(l, \key, \val) \in_{\aexec} \txid$ as a shorthand for $(l, \key, \val) \in \TtoOp{T}_{\aexec}(\txid)$.
%The set of abstract executions is denoted by $\aeset$.
%Intuitively, $\txid \xrightarrow{\VIS_{\aexec}} \txid'$ means that, at the moment of executing, 
%transaction $\txid'$ sees the updates performed by $\txid$; $\txid \xrightarrow{\AR_{\aexec}} \txid'$ 
%means that the updates performed by $\txid'$ are newer than those performed by $\txid$. 
For $\txid \in \T_{\aexec}$, 
%$\txid: (\otR, \key, \val) \in_{\aexec} \txid$, \azalea{I don't know what this notation is saying}
we define its \emph{visible writes} in $\aexec$ as 
$\visibleWrites_{\aexec}(\key, \txid) \defeq \VIS^{-1}_{\aexec}(\txid) \cap 
\{\txid' \mid (\otW, \key, \stub) \in_{\aexec} \txid'\}$. 
An abstract execution $\aexec$ satisfies the \emph{last-writer-wins} policy: if
a transaction \( \txid \) reads key \( \key \), 
it must read from the latest transaction in the arbitration order that is visible to $\txid$ and wrote to key $\key$,
\ie $\forall \txid \in \T_{\aexec}.\; (\otR,\key,\val) \in_{\aexec} \txid 
\implies (\otW, \key, \val) \in \max_{\AR_{\aexec}}(\visibleWrites_{\aexec}(\key, \txid))$.
%We focus on  abstract executions that satisfy the
%\emph{last-writer-wins} resolution policy, which  states that, if transaction $\txid$ reads value $\key$ in $\aexec$, then it reads the most up-to-date version among 
%the ones written by the transactions it sees: formally,  if $\visibleWrites_{\aexec}(\key, \txid) = \VIS^{-1}_{\aexec}(\txid) \cap 
%\{ \txid' \mid (\otW, \key, \stub) \in_{\aexec} \txid'\}$ then $\forall \key, \val.\; (\otR,\key,\val) \in_{\aexec} \txid
%\implies (\otW, \key, \val) \in \max_{\AR_{\aexec}}(\visibleWrites_{\aexec}(\key, \txid))$.
Henceforth we assume that abstract executions satisfy the last-writer-wins policy, 
and we let $\Aexecs$ be the set of all such abstract executions.

%
%The constraint in \cref{def:main-body-aexec} amounts to require that a transaction reading 
%key $\key$ always fetches the newest write over $\key$ performed in its set of visible transactions, 
%thus modelling the last write wins policy. An example of abstract execution is given in \cref{fig:abstract_execution}.
%Consistency models for  abstract executions are specified by
%providing axioms which 

Abstract-execution-based specifications of consistency models constrain the overall structure of abstract executions. 
For most consistency models \cite{laws,framework-concur,sureshConcur}, 
such constraints are over the set of transactions that  \textbf{must} be seen  by 
other transactions. For example, monotonic reads is specified by requiring 
that if a transaction $\txid$ follows another transaction $\txid'$ in the session order, 
then $\txid$ must see all transactions that are seen by $\txid'$.
Serialisability can be specified by requiring that 
%in an abstract execution $\aexec$, 
a transaction $\txid$ see all transactions preceding $\txid$ in the arbitration order.
%form $\mathcal{R}_{\aexec} \subseteq \VIS_{\aexec}$.

Formally, an axiomatic specification $\Ax$ is a set of {\em axioms} $\A : \Aexecs \to \pset{\TxID \times \TxID}$,
where  $\forall \aexec.\;\A(\aexec) \subseteq \AR_{\aexec}$. 
We write $\aexec \models \A$ when $\A(\aexec) \subseteq \VIS_{\aexec}$.
We refer the reader to \cref{sec:abstract-execution} for details about abstract executions.

Returning to the monotonic reads (\MR) example, 
we define $\Ax_{\MRd} \defeq \{\A_{\MRd}\}$, where $\A_{\MRd}(\aexec) \defeq \VIS_{\aexec} ; \SO_{\VIS}$. 
By definition, for a given $\aexec$, $\aexec \models \A_{\MRd}$ if and only 
if $\VIS_{\aexec} ; \SO_{\aexec} \subseteq \VIS_{\aexec}$. 
That is, whenever $\txid'' \xrightarrow{\VIS_{\aexec}} \txid' \xrightarrow{\PO_{\aexec}} \txid $, 
then $\txid'' \xrightarrow{\VIS_{\aexec}} \txid$.
Similarly, for serialisability (\SER) we define $\Ax_{\SER} \defeq \{ \A_{\SER} \}$, where $\A_{\SER}(\aexec) \defeq \AR_{\aexec}$, 
captures the constraint that a transaction $\txid$ must see all transactions
preceding it in the arbitration order.
%The  { consistency
%  model} generated by $\Ax$ is defined by
%$\CMs(\Ax) = \{\aexec \mid \aexec \text{ satisfies } \Ax\}$. 
%Examples of such consistency models include {strict
%  serialisability}  given by  the set of abstract executions $\aexec$ such that
%$\AR_{\aexec} \subseteq \VIS_{\aexec}$ and  $\PO_{\aexec} \subseteq \VIS_{\aexec}$, 
%and {read atomic} ~\cite{ramp} given by  the set of abstract
%executions without constraints. 

Any abstract executions $\aexec$ can be mapped 
into an equivalent dependency graph $\Gr_{\aexec}$ (\citet{laws}), and hence into a kv-store 
$\hh_{\aexec}$ (\cref{thm:kv_graph_isomorph}). 
\sx{straightforward? Maybe better words like: 
we refer the readers to \cite{laws} for mapping an abstract execution $\aexec$ into an
equivalent dependency graph $\Gr_{\aexec}$. } 
We can then use this construction to define the consistency model induced by an abstract-execution-based specification 
$\CMs(\Ax)$ by projecting abstract executions that satisfy the axioms in $\Ax$ to kv-stores: 
$\CMs(\Ax) \defeq \{ \hh_{\aexec} \mid \forall \A \in \Ax. \aexec \models \A \}$. 

In the remainder of this section we develop a proof techniques for showing  
that an execution test $\ET$ and an axiomatic specification $\Ax$ induce the same 
consistency model, \ie$\CMs(\ET) {=} \CMs(\Ax)$. 
Due to space constraints, we focus only on \emph{soundness}, \ie on proving the left-to-right inclusion: $\CMs(\ET) \subseteq \CMs(\Ax)$; 
we describe the other direction in full in \cref{sec:et-sound-complete-constructor}. 
The core of our proof technique lies in the soundness of the most permissive execution 
test, $\CMs(\ET_{\top})$, with respect to the weakest axiomatic specification, given by 
the empty set of axioms, which we prove next.
%lifting this mapping, we can convert a consistency model for abstract
%executions to a consistency model for kv-stores.  
%In~\cref{app:et_sound_complete}, 
%we prove that all the consistency models
%for kv-stores given in~\cref{fig:execution-tests} are equivalent to
% consistency models for abstract
%executions, as  defined
%in the literatures~\cite{principle-eventual-consistency,surech-session-guarantee,framework-concur,laws}.
%This result is based on a 
%generic technique for proving that axiomatic specification $\Ax$ is
%equivalent to an execution test $\ET$, that is,
%$\aexec \in \CMs(\Ax) \Leftrightarrow \mkvs_{\aexec} \in \CMs(\ET)$.
%We describe this generic technique here. We first prove the equivalence of the empty set of axioms, which
%gives rise to the read atomic consistency model for abstract
%executions, and the most permissive execution test $\ET_{\top}$, which
%gives rise to read atomic for kv-stores. Using this result, we 
%demonstrate how to prove the equivalence of axiomatic
%specifications and execution tests in general. 
%
%In \cref{app:et_sound_complete} we prove that these are equivalent to the consistency models 
%defined by the corresponding execution tests. In the following, we focus on proving the 
%equivalence between the axiomatic specification of \emph{Read Atomic}
%%We defer the details of this mapping to \cref{app:depgraphs}.

%
%We defer the formal details of such a construction to \cref{app:depgraphs}, 
%but we mention here that in such a construction, we draw an edge of the form $\txid \xrightarrow{\RF} \txid'$ 
%if $\txid = \max_{\AR_{\aexec}}(\visibleWrites_{\aexec}(\key, \txid'))$ and $(\otR, \key, \stub) \in \TtoOp{T}(\txid')$ for some $\key \in \Keys$, 
%while $\txid \rightarrow{\VO} \txid'$ if $(\otW, \key, \stub) \in \TtoOp{T}(\txid), (\otW, \key, \stub) \in \TtoOp{T}(\txid')$ and 
%$\txid \xrightarrow{\AR_{\aexec}} \txid'$; edges labelled as $\AD$ can be uniquely determined from edges labelled as 
%$\RF$ and $\VO$.
%\sx{If we dont have space. we can cut the technical details here}

%a variant of \emph{Eventual Consistency} 
%\cite{ev_transactions} that assumes the last-write-win resolution policy.

\subsubsection{Equivalence of Read Atomic and $\CMs(\ET_{\top})$} 
\sx{high level comments: read atomic -> snapshot property? }
%We develop the methodology  to show that 
%axiomatic specifications for abstract executions are equivalent to
%execution tests  for kv-stores. 
The weakest axiomatic specification, given by the empty set of 
axioms, corresponds to the \emph{Read Atomic} consistency model \cite{ramp}. 
To prove that the most permissive execution test $\ET_{\top}$ is sound with 
respect to the weakest axiomatic specification, we map $\ET_{\top}$-traces 
terminating in a configuration of the form $(\hh, \stub)$, into the set of 
abstract executions whose underlying kv-store is $\hh$. 
%We show that the  axiomatic specification $\emptyset$ for abstract
%execution $\aexec$  is equivalent to the
%execution test $\ET_{\top}$ for kv-store $\hh_{\aexec}$. The full details are given
%in~\ref{sec:app-abstract-semantics-sound-complete}. 


%$\ET_{\top} \vdash (\hh, \vi) \csat \opset, (\mkvs',  \vi')$ for any $\hh, \hh', \vi, \vi', \opset$. 
%We show that there is a close connection between the set $\ET_{\top}$-traces and 
%$\aeset$. 
\begin{theorem}
\label{thm:kvtrace2aexec}
%Given an $\ET_{\top}$-trace $\tau = (\mkvs_{0}, \vienv_{0}) \toET{(\cl_{1}, \alpha_{1})} \cdots \toET{(\cl_{n}, \vienv_{n})} (\mkvs_{n}, \vienv_{n})$, 
%there exists a non-empty set of abstract executions $\execs(\tau) = \{\aexec_i\}_{i = 0}^{n}$ such that, for any $i = 0,\cdots,n$, 
%$\hh_{\aexec_{i}} = \hh_{i}$, and the order in which transactions are executed in $\tau$ is consistent with $\AR_{\aexec_{n}}$. 
Given an $\ET_{\top}$-trace $\tau$ terminating in $(\hh, \_)$, 
there exists a non-empty set of abstract executions $\execs(\tau)$
such that: $\forall \aexec \in \execs(\tau).\ \hh_{\aexec} = \hh$, 
and the order in which transactions are executed in $\tau$ is consistent with $\AR_{\aexec}$. 
\end{theorem}
\noindent 
The proof of \cref{thm:kvtrace2aexec} is highly
non-trivial, and relies on the following intuition that drives the construction of the set $\execs(\tau)$: 
whenever a client $\cl$ in $\tau$  with view $\vi$ commits a transaction $\txid$, then in all 
abstract executions included in $\execs(\tau)$, transaction $\txid$ must see the writers  
of the versions included in $\vi$, and it never sees the writers of versions not included in $\vi$ (\cref{fig:et-sound-to-aexec}). 
These are defined by the set $\Tx[\hh, \vi]$ (defined in \cref{subsec:cm_examples}). Furthermore, 
abstract executions in $\execs(\tau)$ differ only in the set of read-only transactions (\ie those with no write operations) 
that transactions see. While mapping an $\ET_{\top}$-trace into multiple abstract executions is 
not strictly necessary for proving the soundness of $\ET_{\top}$ with respect 
to the weakest axiomatic specification, it plays a significant role when proving the soundness 
of an arbitrary execution test $\ET$ with respect to its counterpart in axiomatic specifications. 
%The full details of the proof of \cref{thm:kvtrace2aexec} can be found in
%\cref{sec:kvtrace2aexec}.  Here, we  focus on the construction of the set $\execs(\tau)$. 

The definition of $\execs(\tau)$ is by induction on the length of the $\ET_{\top}$-trace
$\tau$. For the base case with $\tau_{0}$ consisting of a single configuration 
$(\hh_{0}, \stub)$, we define $\execs(\tau_{0})$ to contain a single abstract execution with 
a single transaction $\txid_{0}$ that initialises all the keys to the initial value $\val_{0}$:
$\execs(\tau_{0}) \defeq \{ ([\txid_{0} \mapsto \{ (\otW, \key, \val_{0} \mid \key \in \Keys)\}], \emptyset, \emptyset \}$. 
For the inductive case with $\tau {=} \tau' \toET{(\cl, \alpha)} (\hh', \vienv')$, let $(\hh, \vienv)$ be the last 
configuration appearing in $\tau'$. 
%Suppose also that $\aexec(\tau')$ has been already defined. 
If $\alpha {=} \varepsilon$, then $\execs(\tau) \defeq \execs(\tau')$. 
If $\alpha {=} \fp$ for some $\fp$, we first determine the transaction identifier $\txid'$ that was used to commit $\fp$ in $\hh'$, 
the view $\vi' = \vienv'(\cl)$ of the client $\cl$ when committing $\txid'$, the 
set of transactions that $\cl$ must see when committing $\txid'$, given by 
$\Tx[\hh', \vi']$, and the set of read-only transactions $\txidset_{\rd}$ in $\hh'$: 
the latter are those transactions that never appear as writers. 
Then, for all abstract execution $\aexec' \in \execs(\tau')$, we define $\extend[\aexec', \txid', \Tx[\mkvs',\vi'], \fp]$ as the largest set 
such that, whenever $\aexec \in \extend[\aexec', \txid', \Tx[\mkvs',\vi'], \fp]$, then 
\begin{enumerate*}
\item $\TtoOp{T}_{\aexec} = \TtoOp{T}_{\aexec'}\rmto{\txid'}{\fp}$;
\item  for all $\txid' \in \T_{\aexec}$, 
$\txid' \xrightarrow{\AR_{\aexec'}} \txid$; and 
\item if $\txid' \xrightarrow{\VIS_{\aexec}} \txid$, 
then either $\txid \in \Tx[\hh', \vi']$, or $\txid \in \txidset_{\rd}$.  
\end{enumerate*}
Finally, we define $\execs(\tau) \defeq \bigcup_{\aexec \in \execs(\tau')} \extend[\aexec, \txid, \Tx[\mkvs',\vi'], \txidset_{\rd}, \fp]$. 
In \cref{sec:kvtrace2aexec,sec:aexectrace2kv} we give the full details. 
To understand the construction outlined above, we 
illustrate one use of the function $\extend$. The abstract 
execution $\aexec$ to the left of \cref{fig:et-sound-aexec-update} has underlying kv-store $\hh$, 
depicted to the left of \cref{fig:et-sound-kv-store-update}. If a client commits a transaction 
$\txid_{3}$ that reads the last version of $\key_1$, then the resulting kv-store $\hh'$ would be the one 
to the right of \cref{fig:et-sound-kv-store-update}. This commit is simulated by the function 
$\extend[\aexec', \txid_{3}, \Tx[\hh, \vi], \fp]$, where $\vi, \fp$ are the view and fingerprint used to 
update $\hh$ to $\hh'$: the result of this function consists of two abstract executions $\aexec_1, \aexec_2$, 
that only differ in read-only transactions (the right of \cref{fig:et-sound-kv-store-update}).
The visibility edges of $\aexec_1$ are exactly the concrete edges in \cref{fig:et-sound-aexec-update}; however, 
$\aexec_2$ has the extra dashed visibility edge $\txid_{2} \xrightarrow{\VIS} \txid_{3}$. 
Note that $\hh_{\aexec_2} = \hh_{\aexec_3} = \hh'$.

\input{et-sound-diagram.tex}

%first, for any 
%%For any $\aexec \in \execs(\tau)$, we define a set of abstract execution $\extend[\aexec, 
%%\txid, \Tx[\mkvs',\vi'], \txidset_{\rd}, \fp]$ as follows: 
%%$\aexec''$ as follows: 
%We define $\execs(\tau)$ using the following process: 
%\textbf{Leaving this here: It would be really nice if we could have a picture outlining the construction!}
%\textbf{(i)} we append the transaction $\txid$ at the end of $\AR_{\aexec}$, and by associating the transaction 
%$\txid$ with the fingerprint $\txid$; \textbf{(ii)} for each $\txid' \in \Tx[\hh,\vi]$, we add a visibility edge, 
%\item  we determine the set of read-only transactions in $\hh$: for each of its subsets 
%$\txidset_{\rd}$, we extend $\aexec'$ by adding a visibility edge from each transaction in 
%$\txidset_{\rd}$ to $\txid$; the result is a set of abstract executions, which we denote as 
%$\extend[\aexec,\txid, \fp]$.
%\item The set $\aexec_{\tau}$ is defined by  lifting the 
%construction above from $\ET_{\top}$-traces to the 
%set of $\ET_{\top}$-traces in $\exec(\tau')$: $\exec(\tau) = \bigcup_{\aexec \in \exec(\tau')} 
%\extend[\aexec, \txid, \fp]$.
% \extend[\aexec,\txid,\Tx[\mkvs,\vi] \cup \txidset_\rd, \fp]$

%The proof of \cref{thm:kvtrace2aexec} is highly
%non-trivial. The full details can be found in
%\cref{sec:kvtrace2aexec}.   Here, we  focus on  the construction of the set
%$\execs(\tau)$. 
%Let $\tau$ be an $\ET_{\top}$-trace. The construction of the set $\execs(\tau)$ is incremental. 
%We start with the singleton set $\execs_{0}(\tau)$ containing an abstract execution where the initial transactions $\txid_{0}$ writes 
%the initial value $\val_{0}$ for each $\key$ in the kv-store: 
%$\execs_{0}(\tau) = \{(\emptyset, \emptyset, \emptyset)\}$. 
%$\execs_{0}(\tau) = \{([\txid_{0} \mapsto \{ (\otW, \key, \val_{0} \mid \key \in \Keys)\}], \emptyset, \emptyset)\}$. 
%Then for $i=0,\cdots, n-1$, we define $\execs_{i+1}(\tau)$ from $\execs_{i}(\tau)$ and the $\ET_{\top}$-reduction 
%$(\mkvs_{i}, \vienv_{i} \toET{(\cl_{i}, \alpha_{i})} \mkvs_{i+1}, \vienv_{i+1})$. Finally, we define $\execs(\tau) \defeq \execs_{n}(\tau)$.
%\ac{Here there is an inconsistency: if we want $\txid_{0}$ to be included in abstract executions, then initially we 
%must set $\execs(\tau) = ([\txid_{0} \mapsto \{ (\otW, \key, \val_{0} \mid \key \in \Keys)\}], \emptyset, \emptyset$.} 

%Let us show how $\execs_{i+1}(\tau)$ is defined, for $i=0,\cdots,n-1$: 
%%inductively from $\execs_{i-1}(\tau)$. 
%If the $i$-th action of $\tau$ is a view-shift, i.e. $\alpha_{i} = \varepsilon$, then 
%we let $\execs_{i+1}(\tau) = \execs_{i}(\tau)$. Otherwise, the $i$-th action of $\tau$ consists of client $\cl_{i}$
%committing a transaction $\txid_{i}$ with fingerprint $\fp_{i}$, and we follow a two step process for constructing $\execs_{i+1}(\tau)$: first, we extend each of the 
%executions in $\execs_{i}(\tau)$ by inserting the mapping $(\txid_{i} \mapsto \fp_{i})$ as the last element of its arbitration order; this operation 
%results in an intermediate set of abstract executions, $\execs_{i}^{\mathsf{partial}}(\tau)$. Second, for each 
%abstract execution $\aexec^{\mathsf{partial}} \in \execs_{i}^{\mathsf{partial}}(\tau)$ we determine a set of sets of visible transactions for $\txid_{i}$:  
%each of these sets is used to extend the visibility relation of $\aexec_{\mathsf{partial}}$, and the resulting abstract execution  is included in  the final 
%set $\aexec_{i+1}(\tau)$. Each visibility set for $\txid_{i}$ must contain at least the writers of the versions contained in $\vienv_{i-1}(\cl_{i})$, 
%$\Tx[\hh_{i}, \vienv_{i}]$, because we know that read operations in $\fp_{i}$ fetch their value of a key $\key$ from the 
%last version of $\mkvs_{i}$ included in $\vi_{i}$; but it may also contain any other read-only transaction 
%(excluded $\txid_{i}$) that is already present in the abstract execution $\aexec_{\mathsf{partial}}$.

%\sx{
%I had a go, can someone check:
%If the $i$-th action of $\tau$ is a view-shift, that is $\alpha_{i} = \varepsilon$, then $\execs_{i+1}(\tau) = \execs_{i}(\tau)$.
%Otherwise, the $i$-th action of $\tau$ consists of client $\cl_{i}$ with view \( \vi_i = \vienv_i(\cl_i) \)
%committing a transaction $\txid_{i}$ with fingerprint $\fp_{i}$.
%We construct the next step $\execs_{i+1}(\tau)$ by adding the new transaction with appropriate edges to any abstract execution \( \aexec_i \in \execs_{i}(\tau) \): 
%first, we add the new transaction \( (\txid_{i} \mapsto \fp_{i}) \) to \( \TtoOp{T}_{\aexec_i} \) and
%second, $\txid_{i}$ is appended to the end of \( \AR_{\aexec_i} \) since it is the newest so far;
%these operations result in an intermediate abstract execution, written $\aexec_{i+1}^{\mathsf{partial}}$.
%Last, we construct a set of visible transactions \( \txidset_i \) for $\txid_{i}$
%which is used to extend the visibility relation of $\aexec_{i+1}^{\mathsf{partial}}$.
%This means in the new abstract execution \( \aexec_{i+1} \in \execs_{i+1}(\tau) \), \( \fora{\txid \in \txidset} (\txid,\txid_i) \in \VIS_{\aexec_{i+1}} \).
%Note that \( \txidset_i \) is not unique and
%all of them must contain at least the writers of the versions contained in $\vi_i$, 
%that is, $\Tx[\mkvs_{i}, \vi_{i}]$, but may contain different read-only transactions.
%}

%%Formally, consider the $i$-th $\ET_{\top}$-reduction of $\tau$, $(\hh_{i-1}, \vienv_{i-1}) \xrightarrow{(\cl_{i}, \alpha_{i})}_{\ET_{\top}} (\hh_i, \vienv_{i})$, 
%%and assume that $\alpha_{i} = \opset$ for some $\opset$. Let 
%%If $\alpha_{i} = \varepsilon$, then we let $\execs_{i}(\tau) = \execs_{i-1}(\tau)$. Otherwise, 
%%if $\alpha_{i} = \opset$, let 
%$\{\txid_{i}\} := \hh_{i} \setminus \hh_{i-1}$; 
%%we first identify the transaction identifier that is associated to $\opset$ in $\tau$: this 
%%is the only transaction identifier $\txid_{i}$ that appears in $\hh_{i}$ and not in $\hh_{i-1}$; 
%we extend the arbitration order of each abstract execution $\aexec \in \execs_{i}(\tau)$ by appending the transaction identifier 
%$\txid_{i}$ as its last  transaction, and we let $\execs_{i}^{\mathsf{partial}}(\tau)$ be the resulting set of 
%abstract executions. Then, for each abstract execution in this set, we determine a set of suitable 
%local visibility relations for the transaction $\txid_{i}$, i.e. the possible sets of transactions that 
%$\txid_{i}$ sees.  Each of these sets must contain at least the writers of the versions contained $\vienv_{i-1}(\cl_{i})$ in the 
%view of client $\cl_{i}$ in $\vienv_{i-1}$, defined by $\Tx[\hh_{i-1}, \vienv{i-1}]$; but it may also contain any other read-only transaction 
%that is already present in the abstract execution. 
%%Formally, given a kv-store $\hh$ and a view $\vi$, we let 
%%$\Tx[\hh, \vi] \defeq \Setcon{ \WTx(\hh(\key, i)) }{ \key \in \Keys \wedge i \in \vi(\key) }$. 
%That is, for each 
%abstract execution $\aexec \in \execs_{i}^{\mathsf{partial}}$ and each subset $\T_{\mathsf{rd}}$ of 
%read-only transactions in $\aexec$, we extend the visibility relation $\VIS_{\aexec}$ 
%with the pairs $\Set{(\txid, \txid_{i}) }[  \txid \in \Tx[\hh_{i-1}, \vienv{i-1}(\cl_{i})] \cup \txidset_\rd]$, 
%and we include the resulting abstract execution in $\aexec \in \execs_{i}(\tau)$. Finally, we 
%let $\execs(\tau) = \execs_{n}(\tau)$.

%We let $\execs_{i}^{\mathsf{partial}(\tau)} = \{(\TtoOp{T}_{\aexec}[\txid_{i} \mapsto \opset], \VIS_{\aexec}, 
%\AR_{\aexec} \cup \{(\txid, \txid_{i} \mid \txid \in \dom\TtoOp{T}(\aexec)\} \mid \aexec \in \execs_{i}(\tau)\}$. 
%Then, for each $\aexec \in \execs_{i}^{\mathsf{partial}(\tau)}$, we determine the set of transactions that  

\begin{theorem}
\label{thm:aexec2kvtrace}
Given an abstract execution $\aexec$, there exists a non-empty 
set of $\ET_{\top}$-traces $\{\tau_{i}\}_{i \in I}$ such that, for each $i \in I$, the last configuration of $\tau_{i}$ is 
$(\hh_{\aexec}, \_)$, and $\tau_{i}$ executes transactions in the order established by $\AR_{\aexec}$. 
\end{theorem}
\noindent The proof of \cref{thm:aexec2kvtrace} is given 
in \cref{sec:kvtrace2aexec,sec:aexectrace2kv}. 
\Cref{thm:kvtrace2aexec,thm:aexec2kvtrace} together establish the
equivalence  of $\ET_{\top}$ with the weakest axiomatic specification. 
%$\CMs(\ET_{\top}) = \CMs(\emptyset)$ is sound and complete with respect to the set of abstract executions
%allowed by the read atomic consistency model. 

\subsubsection{Equivalence of axiomatic specifications and execution tests}
We are now ready to present our proof technique for proving the soundness 
of an execution test $\ET$ with respect to an axiomatic specification $\Ax$.
It can be summarised as follows: 
the user considers an arbitrary 
$\aexec: \aexec \models \Ax$ , and a tuple of the form 
$\ET \vdash (\hh_{\aexec}, \vi) \csat \opset: (\hh', \vi')$. 
Then, it constructs a non-empty subset of $\extend[\aexec, \txid, \Tx[\hh, \vi], \fp]$ 
whose elements satisfy the axioms $\Ax$. Note that, because abstract executions in
$\extend[\aexec, \txid, \Tx[\hh, \vi], \fp]$ differ only in visibility edges of the form $\txid_{\mathsf{rd}}
\xrightarrow{\VIS} \txid$, where $\txid_{\mathsf{rd}}$ is a read-only transaction, 
then constructing the set above amounts to identifying a suitable set of 
read-only transactions in $\aexec$.

To see why our proof technique guarantees the soundness of $\ET$ with respect 
to $\Ax$ (\cref{thm:main-body-et_soundness}), we apply an inductive argument over the number of $\ET$-reductions $n$ in a $\ET$-trace $\tau$: 
first, if $n = 0$ then $\tau = (\mkvs_{0}, \vienv_{0})$, and $\aexec_{0} \in \execs(\tau)$ trivially satisfies the axioms
$\Ax$: $\forall \A \in \Ax. \A(\aexec_{0}) \subseteq \AR_{\aexec_{0}} = \emptyset \subseteq \VIS_{\aexec_{0}}$. 
Otherwise, if $\tau = \tau' \xrightarrow{(\cl, \fp)} (\mkvs, \vi)$, 
suppose that there exists an abstract execution $\aexec' \in \execs(\tau')$ that satisfies 
the axioms $\Ax$. If the proof obligations of our proof technique are satisfied, we can construct an abstract execution 
$\aexec \in \extend[\aexec, \txid, \Tx[\hh, \vi], \fp] \subseteq \aexec(\tau)$ that satisfies $\Ax$; furthermore $\hh_{\aexec} = \mkvs$. 

In practice, our proof techniques allows defining a per-client invariant 
on the visibility relation of abstract executions, which must be proved to be preserved by $\ET$-reductions (\cref{def:main-body-et_sound}).
This invariant carries client-specific information that links to \( \vshiftname \) (defined in \cref{sec:cm}) in execution tests.
Defining the right invariant is crucial for proving the soundness of several execution-test-based specifications (see \cref{app:et_sound_complete}).

\begin{definition}
\label{def:main-body-et_sound}
An execution test $\ET$ is sound with respect to an axiomatic 
specification $\Ax$ if and only if
there exists an invariant condition $I$ such that, 
for any $\cl, \txid, \vi, \vi', \mkvs, \vi', \fp, \aexec$, if:
\begin{itemize}
    \item $\ET \vdash (\mkvs, \vi) \csat \fp: (\mkvs',\vi')$, where \( \mkvs' = \updateKV[\mkvs, \vi ,\fp, \txid]\)
    \item  $\mkvs_{\aexec} = \mkvs$ and $I(\aexec, \cl) \subseteq \Tx[\mkvs, \vi]$,
\end{itemize}
then there exists a non-empty subset of $\mathscr{X} \subseteq \extend[\aexec, \txid, \Tx[\hh, \vi], \fp]$ 
such that, for any $\aexec' in \mathscr{X}$, $\aexec \models \Ax$ and $I(\aexec', \cl) \subseteq \Tx[\mkvs', \vi']$.
\end{definition}

\begin{theorem}
\label{thm:main-body-et_soundness}
If $\ET$ is sound with respect to $(\Ax)$, then $\CMs(\ET) \subseteq \CMs(\Ax)$.
\end{theorem}

We conclude this section by outlining how our proof technique can be applied to show that the 
execution test $\ET_{\SER}$ defined for serialisability is sound with respect to the axiomatic 
specification $\Ax_{\SER}$. Let $\aexec$ be an abstract execution such that $\aexec \models \Ax_{\SER}$, 
and suppose that the underlying 
kv-store $\hh_{\aexec}$ is in $\CMs(\ET_{\SER})$. An example is the abstract execution $\aexec$ 
and kv-store $\hh$ to the left of \cref{fig:et-sound-to-aexec}. 
We pick an invariant \( I_{\SER} \) that is always empty since \( \vshiftname_\SER \) is always true.
When a client \(\cl\) commits a transaction $\txid$ 
with fingerprint $\fp$ in $\hh_{\aexec}$ under $\ET_{\SER}$, then its view $\vi$ must contain all the versions stored in $\hh_{\aexec}$ (\( \cancommit[\SER]{\mkvs_\aexec}{\vi}{\fp} \)). 
This means that all the abstract executions \( \aexec'' \) in $\extend[\aexec, \txid, \Tx[\hh_\aexec, \vi], \fp]$ are such that there is a visibility 
edge $\txid' \xrightarrow{\VIS_{\aexec''}} \txid$ where $\txid'$ is a writer transaction in $\hh_{\aexec}$. 
It is easy to see there exists an singleton set \( \Set{\aexec'} \) 
that is a subset of $\extend[\aexec, \txid, \Tx[\hh, \vi], \fp]$ and \( \aexec' \models \Ax_\SER \);
in particular, 
there is an edge $\txid' \xrightarrow{\VIS_{\aexec'}} \txid$ for any transaction $\txid' \in \T_{\aexec'}$.
For example, in \cref{fig:et-sound-to-aexec}, the possible abstract executions are $\aexec_1, \aexec_2$.
We pick $\Set{\aexec_2}$, because the new transaction \( \txid_3 \) in \( \aexec_2 \) sees all previous transactions including  
the visibility edge $\txid_{2} \xrightarrow{\VIS} \txid_{3}$. 
Last, the invariant \( I_\SER(\aexec',\cl) \subseteq \Tx[\hh', \vi] \) given \( I_\SER(\aexec',\cl) = \emptyset \).
%Because $\aexec \models \Ax_{\SER}$ and  
%$\aexec'$ is obtained by extending $\aexec$ with a new transaction $\txid$ that sees all the transactions 
%in $\aexec$, it follows that $\aexec' \models \Ax_{\SER}$.

%Similarly, in \cref{sec:aexectrace2kv} we show that it is possible to 
%construct a set of $\ET$-traces $\{\tau_{i}\}_{i \in I}$ from an abstract execution $\aexec$, such that 
%for any $i \in I$, the last configuration of $\tau_{i}$ has the form $(\hh_{\aexec}, \stub)$, and 
%the order in which transactions are executed in $\tau_{i}$ is consistent with $\AR_{\aexec}$. 
%This gives rise to a proof technique aimed at showing that execution-test based specifications 
%of consistency models are sound and complete with respect with their axiomatic counterparts on abstract executions. 
%More details are outlined in \cref{sec:kv2aexec-sound-complete}. 
%In \cref{app:et_sound_complete} we employ our proof techniques to prove that our specifications (\cref{fig:execution.tests})
%of consistency models using execution tests are sound and complete with respect to previously 
%existing axiomatic specifications based on dependency graphs.
%
%\sx{
%    The sketch prove of this theorem might be too much details.
%}
%
%\begin{definition}
%\label{def:main-body-et_complete}
%An execution test $\ET$ is \emph{complete} with respect 
%to an axiomatic definition $(\RP_{\LWW}, \Ax)$ if, for any abstract execution $\aexec \in \CMa(\RP_{\LWW}, \Ax)$ 
%and index \( i : 1 \leq i < \abs{\txidset_{\aexec}}\) such that \( \txid_{i} \toEDGE{\AR_{\aexec}} \txid_{i+1} \), there exist an initial view $\vi_{i}$ and a final view $\vi_{i}'$ where 
%\begin{itemize}
%\item $\vi_{i} = \getView[\aexec, \VIS_{\aexec}^{-1}(\txid_{i})]$, 
%\item let $\txid_{i} = \txid_{\cl}^{n}$ for some $\cl, n$; 
%    \begin{itemize}
%        \item if the transaction $\txid_{i}' = \min_{\SO_{\aexec}}\Set{\txid' }[ \txid_i \toEDGE{\SO_{\aexec}} \txid']$ is defined, then $\vi' = \getView[\aexec, \txidset_{i}]$ where $\txidset_{i} \subseteq (\AR_{\aexec}^{-1})\rflx(\txid_{i}) \cap \VIS_{\aexec}^{-1}(\txid_{i}'))$; 
%        \item otherwise $\vi' = \getView[\aexec, \txidset_{i}]$ where $\txidset_{i} \subseteq (\AR_{\aexec}^{-1})\rflx(\txid_{i})$, 
%    \end{itemize}
%\item $\ET \vdash (\mkvs_{\cut[\aexec, i-1]}, \vi_{i}) \csat \TtoOp{T}_{\aexec}(\txid_{i}) : (\mkvs_{\cut[\aexec, i]},\vi_{i}')$.
%\end{itemize}
%\end{definition}
%
%\begin{theorem}
%\label{thm:main-body-et_complete}
%Let $\ET$ be an execution test that is complete with respect to 
%an axiomatic specification $(\RP_{\LWW}, \Ax)$. Then 
%$\CMa(\RP_{\LWW}, \Ax) \subseteq \CMs(\ET)$.
%\end{theorem}
%
%\sx{
%    The sketch prove of this theorem might be too much details.
%}
%
%
%\sx{Here we could discuss of applying \cref{def:main-body-et_sound,def:main-body-et_complete} on \( \ET_\PSI \) ( or \( \SI \)) and \( \Ax_\PSI \)  }
%
%





%\sx{
%    START
%}
%
%To specify consistency models, abstract executions constraint resolution policy \( \RP \) and the sharp of abstract execution \( \Ax \) (I believe we could even say more precise --- the minimum visibility relation, and cite andrea's concur paper).
%Resolution policy determines a set of snapshot given a set of observable transactions.
%Most time it is last-write-win which gives a unique single snapshot.
%This corresponds to the \( \snapshot{} \) function in the semantics kv-store.
%The resolution policy part we could (question?) choose to not mentioned, since it is minor and many people always assume last-write-win.
%
%The \( \Ax = \Set{ \A : \aeset \to \pset{\TxID} \times \pset{\TxID}} \) is a set of constraints on visibility relations, \eg \( \Ax = \Set{\lambda \aexec \ldotp \SO_\aexec,  \lambda \aexec \ldotp \VIS_\aexec;\VIS_\aexec} \) means all the abstract executions must satisfy \( \SO \subseteq \VIS , \VIS ; \VIS \subseteq \VIS \).
%
%\begin{definition}
%\label{def:aexec2graph}
%Given an abstract execution $\aexec$ that satisfies the last write wins policy,
%the dependency graph $\graphof(\aexec) \defeq (\TtoOp{T}_{\aexec}, \RF_{\aexec}, 
%\VO_{\aexec}, \AD_{\aexec})$ is defined by letting
%\begin{itemize}
%\item $\txid \xrightarrow{\RF_{\aexec}(\key)} \txid'$ if and only if 
%$\txid = \max_{\AR_{\aexec}}(\visibleWrites_{\aexec}(\key, \txid'))$, 
%\item $\txid \xrightarrow{\VO_{\aexec}(\key)} \txid'$ if and only 
%$\txid, \txid' \in_{\aexec} (\otW, \;\ke: \stub)$ 
%and $\txid \xrightarrow{\AR_{\aexec}} \txid'$,
%\item $\txid \xrightarrow{\AD_{\aexec}(\key)} \txid'$ if and only if either 
%$(\otR, \key, \stub) \in_{\aexec} \txid, (\otW, \key, \stub) \in_{\aexec} \txid'$ and 
%whenever $\txid'' \xrightarrow{\RF_{\aexec}(\key)} \txid$, 
%then $\txid'' \xrightarrow{\VO_{\aexec}(\key)} \txid'$.
%\end{itemize}
%\end{definition}
%Note that each abstract execution $\aexec$ determines a key-value store $\hh_{\aexec}$,
%as a result of \cref{def:aexec2graph} and \cref{thm:kv2graph}. 
%Let $\hh$ be the unique kv-store such that $\Gr_{\hh} = \graphof(\aexec)$, then $\hh_{\aexec} = \hh$. 
%
%A kv-store \( \mkvs \) is compatible with an abstract execution \( \aexec \)
%There is a mapping from 
%\begin{definition}
%\label{def:compatible-main-body}
%Given a key-value store $\hh$,
%an abstract execution $\aexec$ is compatible with $\hh$, written 
%$\aexec \compatible \hh$, if and only if there exists a  mapping 
%$f: \pset{\T_{\aexec}} \rightarrow \Views(\hh)$
%such that  
%\begin{itemize}
%\item for any subset $\T \subseteq \T_{\aexec}$, then $\RP_{\LWW}(\aexec, \T) = \{\snapshot(\hh, f(\T))\}$; 
%\item for any view $\vi \in \Views(\hh)$, there exists a subset $\T \subseteq \T_{\aexec}$ 
%such that $f(\T) = \vi$, and $\RP_{\LWW}(\aexec, \T) = \{\snapshot(\hh_{\aexec}, \vi)\}$.
%\end{itemize}
%\end{definition}
%The function $\getView(\aexec, \T)$ defines the view on \( \mkvs_\aexec \) that corresponds to \( \T \) as the following:
%\[
%\getView(\aexec, \T) \defeq \lambda \key. \{0\} \cup \Setcon{ i }{\WTx(\hh_{\aexec}(\key, i)) \in \T}
%\]
%Inversely, the function \( \Tx(\hh, \vi) \) converts a view to a set of observable transactions:
%\[
%\Tx(\hh, \vi) \defeq \Setcon{ \WTx(\hh(\key, i)) }{ \key \in \Keys \wedge i \in \vi(\key) }
%\]
%Given \( \getView \), \( \Tx \), \cref{def:compatible}, 
%it follows \( \aexec \compatible \hh_{\aexec} \) shown in \cref{thm:aexec2kv.compatible}.
%
%Given a trace with the final kv-store \( \mkvs \), there an abstract execution \( \aexec \) that is compatible with \( \mkvs \).
%First, all transactions in an abstract execution are totally ordered by \( \AR \),
%therefore an abstract execution by itself is a trace.
%The reduction order of a trace of kv-store maps to the \( \AR \) in the abstract execution and vice versa.
%The challenge is to show that
%for each transaction \( \txid \) in the trace and the initial view \( \vi \) of the transaction, the visible transitions \( \Tx(\hh, \vi) \) contains at least those transactions by the constraints \( \Ax \), \ie
%Note that \( \Tx(\hh, \vi) \) do not contain any read-only transactions, 
%thus to be more precise, we mean \( \Tx(\hh, \vi) \) plus some potentially read-only transactions contains those by the constraints \( \Ax \), \ie
%\( \fora{\A\in \Ax, \txid'} (\txid', \txid) \in \A(\aexec) \implies \txid' \in \Tx(\hh, \vi) \lor \txid' \text{is read only} \).
%
%Given an abstract execution \( \aexec \) there is a trace of kv-store with the final kv-store \( \mkvs \) that is compatible.
%Similarly, the \( \AR \) decides the reduction order in the trace.
%The challenge here is that
%for each transaction \( \txid \) with fingerprint \( \f \) in the abstract execution,
%(We should mentioned a node in the graph is the fingerprint)
%We find two views, the initial \( \vi \) and the final \( \vi' \), so \( \ET \vdash (\mkvs, \vi) \csat \f : \vi' \) where the \( \mkvs \) is the kv-store when \( \txid \) commits.
%The initial view \( \vi \) includes all versions written by visible transactions of \( \txid \) from the abstract execution, \ie \( \vi = \getView(\aexec, \VIS_\aexec^{-1}(\txid)) \).
%Since \( \vi' \) gives the minimum views for the next transactions from the same clients,
%it can be computed by including all versions, if exists in \( \mkvs \), written by visible transactions of \( \txid' \) where \( \txid' \toEdge{\SO} \txid \).
%
%\sx{
%    END
%}
%
