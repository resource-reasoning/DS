\newcommand{\execs}{\ensuremath{\mathsf{Execs}}}

\section{KV-Stores and Other Formalisms}
\label{sec:other_formalisms}

We demonstrate that our definition of consistency models via 
execution tests have several desirable properties. 
First we investigate the compositionality of consistency models 
induced by execution tests. Then we discuss how kv-stores and execution 
tests relate to existing declarative formalisms for specifying  
consistency models, based on dependency graphs \cite{adya} 
and abstract executions \cite{framework-concur}. 
We give a main overview of our results here, and refer the reader to the 
appendix for more details.

\mypar{Compositionality}
We examine the \emph{compositionality} of the  consistency models induced by execution tests:  
\ie given two execution tests $\ET_1, \ET_2$, does 
$\CMs(\ET_1 \cap \ET_2) = \CMs(\ET_1) \cap \CMs(\ET_2)$ hold? 
It is straightforward to show that the left-to-right direction holds: for all $\ET_1, \ET_2$, \( \CMs(\ET_1 \cap \ET_2) \subseteq \CMs(\ET_1) \cap \CMs(\ET_2) \) 
However, the other direction \( \CMs(\ET_1) \cap \CMs(\ET_2) \subseteq \CMs(\ET_1 \cap \ET_2) \) does not hold for arbitrary consistency models.
Consider the following:
\[
\small
\begin{array}{@{}l @{\hspace{2pt}} | @{\hspace{2pt}} l@{}}
    \hline
    \ET_1 & \ET_2 \\
%    
    \hline
    (\hh_{0}, \vi_{0}) \csat\! \{(\otW, \ke, 1)\} {:} ( \hh_{\ke}, \vi_{0})
    &
    (\hh_{0}, \vi_{0}) \csat\! \{(\otW, \ke', 1)\} {:} ( \hh_{\ke'}, \vi_{0}) 
    \vspace{-5pt}\\\\
% %   
    (\hh_{\ke}, \vi_{0}) \csat  \!\{(\otW, \ke', 1)\} {:} (\hh',\vi_{0}) 
    &
    (\hh_{\ke'}, \vi_{0}) \csat \!\{(\otW, \ke, 1)\} {:} (\hh',\vi_{1}) 
    \\
\hline
\end{array}
\]
with 
\begin{align*}
    \hh_{\ke} & = \hh_{0}[\ke \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \_, \emptyset)] \\
    \hh_{\ke'} & = \hh_{0}[\ke' \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \_, \emptyset)] \\
    \hh' & = \hh[\ke \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \_, \emptyset) 
                ,\ke' \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \_, \emptyset)] \\
\end{align*}
As both $\ET_1$ and $\ET_2$ allow a version with value $1$ to be written for 
$\ke, \ke'$,  we have $\hh' \in \CMs(\ET_1) \cap \CMs(\ET_2)$. 
However, $\ET_1$ and $\ET_2$ enforce a different order in which the updates on $\ke, \ke'$ must happen; 
thus $\hh' \notin \CMs(\ET_1 \cap \ET_2)$. 

In this example, compositionality fails because execution tests 
enforced a particular order in which the updates must be committed, even though such updates 
are non-conflicting: \ie the kv-store obtained after committing such updates is independent of the commit order. This observation is captures in the following definition: 
\begin{definition}
Two fingerprints $\opset_1$ and $\opset_2$ are \emph{conflicting} 
iff there exists $\ke$ such that 
$(\otW, \ke, -) \in \opset_1 \land (\otW, \ke, -) \in \opset_2$. 

An execution test $\ET$ is \emph{commutative}, written $\com{\ET}$, if 
for all views $\vi_1, \vi_2 \in \Views(\hh_0)$, 
clients $\cl_1, \cl_2$,
fingerprints $\opset_1, \opset_2$, 
kv-stores $\hh'$,
and view functions $\viewFun, \viewFun'$:
\[
\begin{array}{@{}r @{\hspace{10pt}} l @{}}
	\text{if} &  
	(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} 
	\_ \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} (\hh', \viewFun') \\
	& \land\ \cl_1 \ne \cl_2 \land \opset_1, \opset_2  \text{ are non-conflicting}\\
%
%	
	\text{then} & (\hh_0, \viewFun) \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} 
\_ \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} (\hh', \viewFun')
\end{array}
\]
\end{definition}

Commutativity is necessary so to swap steps in a trace to match steps in another,
but not sufficient condition for recovering the desired compositionality result. 
We further restrict that an execution test has \emph{no blind writes}, \emph{minimum footprint} and \emph{monotonic post-view} (\cref{def:et_properties}).
We refer the reader to \cref{sec:counter-examples-composition} for the counter examples.
%=======
%Commutativity is a necessary, but not sufficient condition for recovering
%the desired compositionality result. 


\sx{
    I suggestion this part cut out:

In \cref{app:compositionality} we prove that commutativity ensures that, 
if $\hh \in \CMs(\ET_1) \cap \CMs(\ET_2)$, then for each 
$\ET_1$-trace of the form $(\hh_{0}, \viewFun_{0}) \xrightarrow{(\alpha_{1})}_{\ET_1} \cdots 
\xrightarrow{(\alpha_{n})}_{\ET_1} (\hh_{n}, \viewFun_{n})$ it is possible to reorder the actions of 
an $\ET_2$-trace terminating in a configuration $(\hh_{n}, \_)$, so that the resulting trace matches 
closely the $\ET_1$-trace that we are considering, exception made for the views of the clients: 
$\ET-2$-trace of the form$(\hh_{0}, \viewFun'_{0}) \xrightarrow{(\alpha_{1})}_{\ET_1} \cdots 
\xrightarrow{(\alpha_{n})}_{\ET_2} (\hh_{n}, \viewFun'_{n})$. To ensure that we can further modify 
such an $\ET_2$-trace so that its structure matches exactly the considered $\ET_1$-trace, we 
impose further constraints on pre and post views  in execution tests.
}
>>>>>>> 8a0c68b0ec68b042f098a3b86e33e5a8ab39eb36

\begin{definition}[$\ET$ properties]
\label{def:et_properties}
An execution test $\ET$ has \emph{no blind writes} if
for all $\hh, \hh', \vi, \vi', \opset, \ke$:
\[
\begin{array}{@{} r @{\hspace{10pt}} l @{}}
\text{if} & \ET \vdash (\hh, \vi) \triangleright \opset: (\hh',\vi' ) 
\text{and} (\otW, \ke, \_) \in \opset \\
\text{then} & (\otR, \ke, \_) \in \opset
\end{array} 
\]
An execution test $\ET$ has a \emph{minimum footprint} if for all kv-stores $\hh, \hh'$,
views $\vi, \vi',\vi''$, and fingerprints $\f$: 
%
\[
\begin{array}{@{} r @{\hspace{10pt}} l @{}}
    \text{if} & \ET \vdash (\hh, \vi) \triangleright \opset : (\hh', \vi'')  \\
    \text{and} & \fora{(\stub, \ke, \stub) \in \f} \vi(\ke) {=} \vi'(\ke) \\
    \text{then} & \ET \vdash (\hh, \vi') \triangleright \opset : (\hh', \vi'')
\end{array} 
\]
%
An execution test $\ET$ has \emph{monotonic post-views} if 
for all kv-stores $\hh,\hh'$, 
views $\vi, \vi',\vi''$ and fingerprints $\f$:
\[
\begin{array}{@{} r @{\hspace{10pt}} l @{}}
    \text{if} & \ET \vdash (\hh, \vi) \triangleright \opset : (\hh',\vi' )
    \text{ and } \vi' \sqsubseteq \vi''  \\
    \text{then} & \ET \vdash (\hh, \vi) \triangleright \opset : (\hh',\vi'')
\end{array} 
\]
\end{definition}
<<<<<<< HEAD
The no blind writes ensure that, for keys in the fingerprint, the views used to commit a transaction can be determined by $\hh$. 
By minimum footprint, the views for for untouched keys can be ignored.
If $\ET_1, \ET_2$ have monotonic post-views, then there exists at least one common post-view 
that can be obtained after a client commits $\f$ to $(\hh, \vi)$ using $\ET_1$ and $\ET_2$. 

\begin{theorem}[Compositionality]     
For all $\ET_1, \ET_2$ with no blind writes, minimum footprints and monotonic post-views: 
if $\com{\ET_1}$, 
then $\CMs(\ET_1 \cap \ET_2) {=} \CMs(\ET_1) \cap \CMs(\ET_2)$;
if $\com{\ET_1} \land \com{\ET_2}$, then $\com{\ET_1 \cap \ET_2}$.
=======
%\sx{I will produce 3 counter examples in the appendix so we can refer to the counter example}
The first two requirements ensure that, in an $\ET$-trace 
terminates in a configuration $(\hh, \stub)$, 
the set of client views used to commit a transaction is uniquely determined by $\hh$. 
If $\ET_1, \ET_2$ have monotonic post-views, then there exists at least one common post-view 
that can be obtained after a client commits $\f$ to $(\hh, \vi)$ using $\ET_1$ and $\ET_2$. 
we refer the reader to \cref{sec:counter-examples-composition} for counter examples.
\azalea{counter examples of what?}

\begin{theorem}[Compositionality]     
For all $\ET_1, \ET_2$ with no blind writes, minimum footprints and monotonic post-views: 
\begin{align*}
    \com {\ET_1}
    & \implies \CMs(\ET_1 \cap \ET_2) {=} \CMs(\ET_1) \cap \CMs(\ET_2)\\
    \bigwedge_{i \in \{1, 2\}} \!\!\!\!\com{\ET_i}
    & \implies  \com{\ET_1 \cap \ET_2}
\end{align*}
%If $\com{\ET_1}$, 
%then $\CMs(\ET_1 \cap \ET_2) {=} \CMs(\ET_1) \cap \CMs(\ET_2)$. 
%If $\com{\ET_1} \land \com{\ET_2}$, then $\com{\ET_1 \cap \ET_2}$.
>>>>>>> 8a0c68b0ec68b042f098a3b86e33e5a8ab39eb36
\end{theorem}

Most of the execution tests in \cref{fig:execution_tests} can be minimally adapted to satisfy these 
properties, without excluding any anomalous (weak) behaviour. However, the definitions 
of $\ET_{\SI}$ and $\ET_{\CP}$ are inherently non-commutative (counter example in \cref{sec:comm-counter-cp-si}), which also motivates 
why $\ET_{\UA} \cap \ET_{\CP}$ is not an appropriate execution test for Snapshot Isolation.

\mypar{Relating KV-Stores and Dependency Graphs}
Dependency graphs \cite{adya-icde,adya} are perhaps the most popular 
formalism used for specifying transactional consistency models. 
A dependency graph $\Gr$ is a directed, labelled graph where its
nodes denote transactions and its denote certain \emph{dependencies} between transactions.  
An example dependency graph is given in \cref{fig:dependency-graph}.
Each node is labelled with a transaction identifier and a fingerprint.
Each edges is labelled with metadata describing the information flow in a run of the database%
\footnote{Dependency graphs additionally record a session order between transactions, corresponding to our session order $\SO$ in \cref{subsec:kvstores}.}:
\begin{enumerate*}
	\item a \emph{read dependency} edge, $\txid_1 \xrightarrow{\WR} \txid_2$, denotes
that transaction $\txid_2$ reads a version written by $\txid_1$;
	\item a \emph{write dependency} edge, $\txid_1 \xrightarrow{\WW} \txid_2$, denotes that $\txid_2$ overwrites a version written by $\txid_1$; and 
	\item an \emph{anti-dependency} edge, $\txid_1 \xrightarrow{\RW} \txid_2$, denotes that $\txid_2$ overwrites a version read by $\txid_2$. 
\end{enumerate*}
We give the formal definition of dependency graphs in \cref{app:depgraphs}.
Observe that we can always \emph{extract} a dependency graph  $\Gr$ from a kv-store $\hh$:
we choose the set of transaction identifiers appearing in $\hh$ as the nodes of $\Gr$, 
and let $\RF, \VO, \AD$ be $\RF_{\hh}, \VO_{\hh}, \AD_{\hh}$ as defined in \cref{fig:execution_tests}.
For example, \cref{fig:counter_kv_final} corresponds to the dependency graph extracted from the kv-store in \cref{fig:counter_kv_final}.
In \cref{app:depgraphs} we show that this construction can be reversed, thus giving 
rise to the following result: 
\begin{theorem}
\label{thm:kv_graph_isomorph}
Dependency graphs are isomorphic to kv-stores.
\end{theorem}

Using dependency graphs, consistency models are specified by constraining the shape of the graph; typically, such constraints mandate the absence of cycles of a particular. For example, strict serialisability is defined as those dependency graphs where $(\SO \cup \WW \cup \WR \cup \RW)^+$ is acyclic. 
We can always convert a dependency graph-based specification into an execution test-based one by simply checking that, when committing a transaction to kv-store $\hh$ and obtaining $\hh'$, 
the dependency graph extracted from $\hh'$ contains no cycles prohibited by the dependency graph-based specification. 

\begin{figure*}[t]
\begin{center}
\begin{halfsubfig} 
\begin{center}
\begin{tikzpicture}[scale=0.85, every node/.style={transform shape}]

\node(t0wx) at (-1,2) {$(\otW, \ke_1, \val_0)$}; 
\path (t0wx.east) + (1,0) node (t0wy) {$(\otW, \ke_2, \val'_0)$};
\path (t0wx.north east) + (2.5,0.5) node[anchor = west] (t1ry) {$(\otR, \ke_2, \val'_0)$}; 
\path (t1ry.east) + (0.2,0) node[anchor = west] (t1wx) {$(\otW, \ke_1, \val_1)$};
\path (t0wx.south east) + (2.5,-0.5) node[anchor = west] (t2rx) {$(\otR, \ke_1, \val_0)$};
\path (t2rx.east) + (0.2,0) node[anchor = west] (t2wy) {$(\otW, \ke_2, \val'_1$)};

\begin{pgfonlayer}{background}
\node[background, fit=(t0wx) (t0wy),inner ysep=3pt, inner xsep=6pt] (t0) {};
\node[background, fit= (t1ry) (t1wx),inner ysep=3pt, inner xsep=6pt] (t1) {};
\node[background, fit= (t2rx) (t2wy),inner ysep=3pt, inner xsep=6pt] (t2) {};

\path(t0.west) node[anchor=east] (t0lbl) {$\txid_0$};
\path(t1.north) node[anchor=south] (t1lbl) {$\txid_1$};
\path(t2.south) node[anchor=north] (t2lbl) {$\txid_2$};

\path[->]
(t0.north) edge[bend left=30] node[above, yshift=3pt, xshift=-20pt, pos=0.3] {$\RF, \VO$} (t1.west)
(t0.south) edge[bend right=30] node[below, yshift=-3pt, xshift=-20pt, pos=0.3] {$\RF, \VO$} (t2.west)
([xshift=-8pt]t2.north) edge[bend left=20] node[left] {$\AD$} ([xshift=-8pt]t1.south) 
([xshift=8pt]t1.south) edge[bend left=20] node[right] {$\AD$} ([xshift=8pt]t2.north);
\end{pgfonlayer}

\end{tikzpicture}
\end{center}
\vspace*{-10pt}
\caption{Dependency graph}
\label{fig:dependency-graph}
\end{halfsubfig} 
%
\begin{halfsubfig} 
\begin{center}
\begin{tikzpicture}[scale=0.85, every node/.style={transform shape}]

\node(t0wx) at (-1,2) {$(\otW, \ke_1, \val_0)$}; 
\path (t0wx.east) + (1,0) node (t0wy) {$(\otW, \ke_2, \val'_0)$};
\path (t0wx.north east) + (2.5,0.5) node[anchor = west] (t1ry) {$(\otR, \ke_2, \val'_0)$}; 
\path (t1ry.east) + (0.2,0) node[anchor = west] (t1wx) {$(\otW, \ke_1, \val_1)$};
\path (t0wx.south east) + (2.5,-0.5) node[anchor = west] (t2rx) {$(\otR, \ke_1, \val_0)$};
\path (t2rx.east) + (0.2,0) node[anchor = west] (t2wy) {$(\otW, \ke_2, \val'_1$)};

\begin{pgfonlayer}{background}
\node[background, fit=(t0wx) (t0wy),inner ysep=3pt, inner xsep=6pt] (t0) {};
\node[background, fit= (t1ry) (t1wx),inner ysep=3pt, inner xsep=6pt] (t1) {};
\node[background, fit= (t2rx) (t2wy),inner ysep=3pt, inner xsep=6pt] (t2) {};

\path(t0.west) node[anchor=east] (t0lbl) {$\txid_0$};
\path(t1.north) node[anchor=south] (t1lbl) {$\txid_1$};
\path(t2.south) node[anchor=north] (t2lbl) {$\txid_2$};

\path[->]
(t0.north) edge[bend left=30] node[above, yshift=3pt, xshift=-20pt, pos=0.3] {$\VIS, \AR$} (t1.west)
(t0.south) edge[bend right=30] node[below, yshift=-3pt, xshift=-20pt, pos=0.3] {$\VIS, \AR$} (t2.west)
([xshift=8pt]t1.south) edge[bend left=20] node[right] {$\AR$} ([xshift=8pt]t2.north);
\end{pgfonlayer}

\end{tikzpicture}
\end{center}
\vspace*{-10pt}
\caption{Abstract execution graph}
\label{fig:abstract_execution}
\end{halfsubfig} 
\end{center}
\hrulefill
\captionsetup{width=\linewidth}
\caption{The dependency graph (\subref{fig:dependency-graph}) and abstract execution graph (\subref{fig:abstract_execution}) associated with the kv-store in \cref{fig:ser-disallowed}
}
\end{figure*}

%\subsection{Azalea's Version}
\mypar{Relating KV-Stores and Abstract Executions}
\emph{Abstract executions} \cite{ev_transactions,framework-concur} are an alternative formalism for specifying consistency models. 
As with dependency graphs, an abstract execution graph $\aexec$
is a directed graph with its nodes representing transactions (with each node labelled with a transaction identifier and a set of (read/write) operations), 
and its edges representing certain relations between transactions. 
An example abstract execution graph is depicted in \cref{fig:abstract_execution}. 
Each edge is labelled by either the \emph{visibility} ($\VIS$) or \emph{arbitration} ($\AR$) relation. 
The $\VIS$ is an irreflexive order on transactions such that $\txid_1 \xrightarrow{\VIS} \txid_2$ denotes that the effects (updates) of $\txid_1$ are visible to $\txid_2$. 
The $\AR$ is a strict total order on transactions such that $\txid_1 \xrightarrow{\AR} \txid_2$ denotes that the updates performed by $\txid_2$ are newer than those of $\txid_1$. 
Moreover, $\AR$ contains $\VIS$ ($\VIS \subseteq \AR$) and agrees with the session order.
Lastly, abstract executions observe the \emph{last-write-wins} policy: 
a transaction reading $\ke$ always fetches the latest visible write ($\VIS$ predecessor) on $\ke$.

Following \cite{laws}, we can always \emph{extract} a dependency graph $\Gr_{\aexec}$ from an abstract execution $\aexec$, and thus a kv-store $\hh_{\aexec}$ via \cref{thm:kv_graph_isomorph}---see \cref{app:aexec2kv} for the formal details.
We write  $\hh_\aexec$ for the kv-store extracted from $\aexec$ using this construction.  
Moreover, we show that there is a \emph{Galois connection}
between $\ET_{\top}$ traces, the weakest possible execution test and abstract executions (\cref{sec:galois-kv-aexec}).

As with dependency graphs, consistency models using abstract executions are specified by constraining the shape of abstract execution graphs via a set of \emph{axioms} $\Ax$, \eg mandating certain properties of visibility relation. %the absence of certain cycles.
All consistency models presented in this paper have an equivalent axiomatic specification based on abstract executions~\cite{framework-concur,laws}. 
Proving the equivalence of execution test-based and abstract execution-based specifications is non-trivial; 
however, we have observed that all proofs follow the same \emph{structure}, so long as certain conditions hold. 
We develop the meta-theory to capture this proof structure.
Our meta-theory is non-trivial; we refer the reader to \cref{sec:kv2aexec-sound-complete} for the full details. 
We give an intuitive account of the two conditions required by our meta-theory, and then state our equivalence theorem. 

Given a set of axioms $\Ax$, we define $\CMs(\Ax) \eqdef \{\hh_\aexec \mid \aexec \text{ sats.\ } \Ax \}$.
Our first required condition is the \emph{soundness} of an execution test against an axiomatic specification.
An execution test $\ET$ is sound against an axiomatic specification $\Ax$ if:
for all \( \ET \)-traces \( \tau \) with \( n \) steps, 
we can construct \( \aexec_0, \cdots, \aexec_n \) such that \( \mkvs_i = \mkvs_{\aexec_i} \); and
for each step \( \ET \vdash (\mkvs_i, \vi_i) \csat \f_i : (\mkvs_{i+1}, \vi_{i+1}) \) in \( \tau \),
the new visibility edges in \( \aexec_{i+1} \), which are associated with transactions included in the view \( \vi_i \),
 satisfy \( \Ax \).
The formal definition of execution test soundness is given in \cref{sec:kv2aexec-sound-complete}.

\azalea{I don't think the intuitive description of soundness above is very clear...}

Let \( \cut(\aexec,n) \) be the projection for the first n\(^{th}\) (with respect to arbitrary relation).
Our second required condition is the \emph{completeness} of an execution test against an axiomatic specification.
An execution test $\ET$ is complete against an axiomatic specification $\Ax$ if:
for all abstract executions \( \aexec \) that satisfy \( \Ax \), 
we can construct a \( \ET \)-traces such that \( \mkvs_i = \cut(\aexec,i) \); and
for the new transaction \( \txid_i \) with operation \( \f_i \) in \( \cut(\aexec,i+1) \),
the pre-view \( \vi_i \), including all visible transactions of \( \txid_i \),
and the post-view \( \vi'_i \), including all visible transactions of the immediately next transaction \( \txid' \) from the same client, \( \txid' \toEdge{\SO} \txid \),
satisfy
\( \ET \vdash (\mkvs_i, \vi_i) \csat \f_i : (\mkvs_{i+1}, \vi_{i+1}) \).
The formal definition of execution test completeness is given in \cref{sec:kv2aexec-sound-complete}.
%
\azalea{I don't think the intuitive description of completeness above is very clear...}

Finally, we state our equivalence theorem below (\cref{thm:main-body-et_soundness_completeness}), with its full proof in \cref{sec:kv2aexec-sound-complete}. 
This theorem ensures that if an execution test is sound and complete against a set of axioms $\Ax$, 
then the consistency model induced by $\ET$ corresponds to the kv-stores extracted from abstract executions satisfying $\Ax$.

\begin{theorem}
\label{thm:main-body-et_soundness_completeness}
For all $\ET, \Ax$, if $\ET$ is sound against $\Ax$, then:
\[
    \CMs(\ET) \subseteq \{ \hh_\aexec \mid \aexec \in \CMs(\Ax)\}
\]
For all $\ET, \Ax$, if $\ET$ is complete against $\Ax$, then:
\[
    \{ \hh_\aexec \mid \aexec \in \CMs(\Ax)\}  \subseteq \CMs(\ET)
\]
\end{theorem} 

In \cref{sec:spec-proof}, we show all our specifications in \cref{fig:execution_tests} 
are sound and complete with existing axiomatic specifications on abstract executions.
Together with \cref{thm:main-body-et_soundness_completeness}, 
our specifications do capture all possible behaviours of consistency models.


%\subsection{Andrea's Version}
%\mypar{Relating KV-Stores and Abstract Executions}
%Abstract executions \cite{ev_transactions,framework-concur} are an alternative formalism for specifying consistency models. 
%Similarly to $\ET$-traces, abstract executions represent computations on kv-stores.
 

%%similarly to dependency graphs, they are also labelled 
%%graph, where nodes are labelled with a transaction identifier and the associated fingerprint. 
%%However, in contrast with dependency graphs, edges in abstract executions are used to 
%%capture the information that is locally available to one transaction. Each 
%%edge in abstract executions is labelled either as $\VIS$ or $\AR$: 
%%\begin{itemize}
%%\item an edge of the form $\txid \xrightarrow{\VIS} \txid'$ means that, when transaction 
%%$\txid'$ is executed, it sees the updates performed by $\txid$,
%%\item an edge of the form $\txid \xrightarrow{\AR} \txid'$ means that any update 
%%performed by $\txid'$ is considered to be newer than the updates performed by $\txid$. 
%%\end{itemize}
%%
%%As with dependency graphs, an \emph{abstract execution} graph $\aexec$~\cite{??} 
%%is a directed graph with its nodes representing transactions (with each node labelled with a transaction identifier and a set of (read/write) operations), 
%%and its edges representing certain relations between transactions. 
%%An example abstract execution graph is depicted in \cref{fig:abstract_execution}. 
%%Each node is . 
%%Each edge is labelled by either the \emph{visibility} ($\VIS$) or \emph{arbitration} ($\AR$) relation. 
%%The $\VIS$ is an irreflexive order on transactions such that $\txid_1 \xrightarrow{\VIS} \txid_2$ denotes that the effects (updates) of $\txid_1$ are visible to $\txid_2$. 
%%The $\AR$ is a strict total order on transactions describing the commit order:  $\txid_1 \xrightarrow{\AR} \txid_2$ denotes that $\txid_1$ commits before $\txid_2$. 
%%Moreover, $\AR$ contains $\VIS$ ($\VIS \subseteq \AR$) and agrees with the session order: 
%%if $\txid_{\cl}^{n} \xrightarrow{\AR}  \txid_{\cl}^{m}$, then $n < m$.

%\begin{definition}
%\label{def:main-body-absexec}
%\label{def:main-body-aexec}
%An abstract execution is a triple $\aexec = (\TtoOp{T}, \VIS, \AR)$, where 
 %$\TtoOp{T}: \TxID_{0} \parfinfun \powerset{\Ops}$ is a partial, 
%finite function mapping transaction identifiers to the set of operations that they perform,
%$\VIS \subseteq \dom(\TtoOp{T}) \times \dom(\TtoOp{T})$ is an irreflexive relation, 
%called \emph{visibility}, $\AR \subseteq \dom(\TtoOp{T}) \times \dom(\TtoOp{T})$ is a strict, total order 
%such that $\VIS \subseteq \AR$, and whenever $\txid_{\cl}^{n} \xrightarrow{\AR} 
%\txid_{\cl}^{m}$, then $n < m$. 
%Furthermore, for any transaction $\txid \in \dom(\TtoOp{T})$, and $\ke \in \Keys$, let 
%$\visibleWrites_{\aexec}(\ke, \txid) = \VIS^{-1}(\txid) \cap \{\txid' \mid (\otW,\ke, \stub) \in \TtoOp{T}(\txid')\}$; 
%we require that whenever  $(\otR, \ke, \val) \in \TtoOp(\txid)$ for some $\ke, \val$ 
%and $\txid \in \dom(\TtoOp{T})$, then either $\visibleWrites_{\aexec}(\ke, \txid) = \emptyset$ and 
%$\val$ is the default value $\val_{0}$, or the transaction $\txid' = \max_{\AR}(\visibleWrites_{\aexec}(\ke, \txid))$ 
%is defined and $(\otR, \ke, \val) \in \TtoOp{T}(\txid')$.

%Given an abstract execution $\aexec = (\TtoOp{T}, \VIS, \AR)$ we let $\TtoOp{T}_{\aexec} = \TtoOp{T}$, 
%$\VIS_{\aexec} = \VIS$ and $\AR_{\aexec} = \AR$.
%The set of abstract executions is denoted by $\aeset$.
%\end{definition}
%Intuitively, $\txid \xrightarrow{\VIS_{\aexec}} \txid'$ means that, at the moment of executing, 
%transaction $\txid'$ sees the updates performed by $\txid$; $\txid \xrightarrow{\AR_{\aexec}} \txid'$ 
%means that the updates performed by $\txid'$ are newer than those performed by $\txid$. 
%The constraint in \cref{def:main-body-aexec} amounts to require that a transaction reading 
%key $\ke$ always fetches the newest write over $\ke$ performed in its set of visible transactions, 
%thus modelling the last write wins policy. An example of abstract execution is given in \cref{fig:abstract_execution}.

%Following \cite{laws}, it is always possible to extract a dependency graph $\Gr_{\aexec}$ from an abstract 
%execution $\aexec$, and therefore a kv-store $\hh_{\aexec}$ (cf. \cref{thm:kv_graph_isomorph}). We defer the formal details of such a construction 
%to \ref{app:?}, but we mention here that in such a construction, we draw an edge of the form $\txid \xrightarrow{\RF} \txid'$ 
%if $\txid = \max_{\AR_{\aexec}}(\visibleWrites(\ke, \txid'))$ and $(\otR, \ke, \_) \in \TtoOp{T}(\txid')$ for some $\ke \in \Keys$, 
%while $\txid \rightarrow{\VO} \txid'$ if $(\otW, \ke, \_) \in \TtoOp{T}(\txid), (\otW, \ke, \_) \in \TtoOp{T}(\txid')$ and 
%$\txid \xrightarrow{\AR_{\aexec}} \txid'$; edges labelled as $\AD$ can be uniquely determined from edges labelled as 
%$\RF$ and $\VO$.
%\sx{If we dont have space. we can cut the technical details here}

%Consistency models specifications based on abstract executions are given by imposing 
%constraints on the structure of abstract executions, and then by extracting the 
%set of kv-stores from those abstract executions that satisfy said requirements. 
%For example, strict serialisability can be formalised by only considering 
%those kv-stores $\hh_{\aexec}$ obtained from an abstract execution 
%$\aexec$ where $\AR_{\aexec} \subseteq \VIS_{\aexec}$. Formally, 
%we consider declarative specifications of consistency models where 
%we require an abstract execution $\aexec$ to satisfy axioms of the 
%form $\mathcal{R}_{\aexec} \subseteq \VIS_{\aexec}$, where 
%$\mathcal{R}_{\aexec} \subseteq \AR_{\aexec}$. Given such a set of 
%axioms $\Ax$, we let $\CMs(\Ax) = \{\hh_{\aexec} \mid \aexec \text{ satisfies } \Ax\}$. 
%Formally, an axiom is a function $\A : \aeset \to \powerset{\TxID} \times \powerset{\TxID}$, 
%and we say that $\aexec$ satisfies $\A$, if $\A(\aexec) \subseteq \VIS_{\aexec}$.
%All the consistency models presented in this paper have an axiomatic 
%specification based on abstract executions \cite{framework-concur,laws}. 
%In the rest of this section, we develop the methodologies to show that 
%such specifications are indeed equivalent to those based on execution tests.

%Consider the weakest possible execution test $\ET_{\top}$, i.e. such that 
%$\ET_{\top} \vdash (\hh, \vi) \triangleright \opset, (\mkvs',  \vi')$ for any $\hh, \hh', \vi, \vi', \opset$. 
%We show that there is a close connection between the set $\ET_{\top}$-traces and 
%$\aeset$. 

%\begin{theorem}
%\label{thm:kvtrace2aexec}
%Given an $\ET_{\top}$-trace 
%\[
    %\tau = (\hh_{0}, \viewFun_{0}) \xrightarrow{(\cl_{1}, \lambda_1)}_{\ET_{\top}} \cdots \xrightarrow{(\cl_{n}, \lambda_n)} (\hh_{n}, \viewFun_{n})
%\]
%there exists a non-empty set of abstract executions $\execs(\tau) = \{\aexec_i\}_{i \in I}$ such that, for any $i \in I$, 
%$\hh_{\aexec_{i}} = \hh_{n}$, and the order in which transactions are executed in $\tau$ matches $\AR_{\aexec_{i}}$. 
%\end{theorem}
%The construction of the set $\execs(\tau)$, where $\tau$ is as defined in \cref{thm:kvtrace2aexec}, is incremental: 
%initially we let $\execs_{0}(\tau) = \{(\emptyset, \emptyset, \emptyset)\}$. \ac{Here there is an inconsistency: if we want $\txid_{0}$ to be included in abstract executions, then initially we 
%must set $\execs(\tau) = ([\txid_{0} \mapsto \{ (\otW, \ke, \val_{0} \mid \ke \in \Keys)\}], \emptyset, \emptyset$.} 
%Then for any $i=1,\cdots, n$ we define $\execs_{i}(\tau)$ 
%inductively from $\execs_{i-1}(\tau)$ as follows: 
%consider the $i$-th $\ET_{\top}$-reduction of $\tau$, $(\hh_{i-1}, \viewFun_{i-1}) \xrightarrow{(\cl_{i}, \lambda_{i})}_{\ET_{\top}} (\hh_i, \viewFun_{i})$. 
%If $\lambda_{i} = \varepsilon$, then we let $\execs_{i}(\tau) = \execs_{i-1}(\tau)$. Otherwise, 
%if $\lambda_{i} = \opset$, we first identify the transaction identifier that is associated to $\opset$ in $\tau$: this 
%is the only transaction identifier $\txid_{i}$ that appears in $\hh_{i}$ and not in $\hh_{i-1}$; we extend the arbitration order 
%of each abstract execution $\aexec \in \execs_{i}(\tau)$ by appending the transaction identifier 
%$\txid_{i}$ as its last  transaction; we let $\execs_{i}^{\mathsf{partial}}(\tau)$ be the resulting set of 
%abstract executions. Then, for each abstract execution in this set, we determine a set of suitable 
%local visibility relations for the transaction $\txid_{i}$, i.e. the possible sets of transactions that 
%$\txid_{i}$ sees. Each of this sets must contain at least the writers of the versions contained in the 
%view of client $\cl_{i}$ in $\viewFun_{i-1}$, but it may also contain any other read-only transaction 
%that is already present in the abstract execution. Formally, given a kv-store $\hh$ and a view $\vi$, we let 
%$\Tx(\hh, \vi) \defeq \Setcon{ \WTx(\hh(\ke, i)) }{ \ke \in \Keys \wedge i \in \vi(\ke) }$. Then, for each 
%abstract execution $\aexec \in \execs_{i}^{\mathsf{partial}}$ and each subset $\T_{\mathsf{rd}}$ of 
%read-only transactions in $\aexec$, we extend the visibility relation $\VIS_{\aexec}$ 
%with the pairs $\{(\txid, \txid_{i}) \mid  \txid \in \Tx(\hh_{i-1}, \viewFun_{i-1}(\cl_{i})) \cup \T_{\mathsf{rd}}\}$, 
%and we include the resulting abstract execution in $\aexec \in \execs_{i}(\tau)$. Finally, we 
%let $\execs(\tau) = \execs_{n}(\tau)$.
%\sx{We should mentioned incremental, but could leave the details out.}
%%formally, we let $\execs_{i}^{\mathsf{partial}(\tau)} = \{(\TtoOp{T}_{\aexec}[\txid_{i} \mapsto \opset], \VIS_{\aexec}, 
%%\AR_{\aexec} \cup \{(\txid, \txid_{i} \mid \txid \in \dom\TtoOp{T}(\aexec)\} \mid \aexec \in \execs_{i}(\tau)\}$. 
%%Then, for each $\aexec \in \execs_{i}^{\mathsf{partial}(\tau)}$, we determine the set of transactions that  
%%
%%Similarly, given an abstract execution $\aexec$, there exists a non-empty 
%%set of $\ET_{\top}$-traces $\{\tau_{i}\}$ such that, for each $i \in I$, the last configuration of $\tau_{i}$ is 
%%$\hh_{\aexec}$, and $\tau_{i}$ executes transactions in the order established by $\AR_{\aexec}$. 

%The construction outlined above is crucial to the development of a proof technique aimed 
%at proving the soundness of an execution test-based specification of a consistency 
%model, with respect to an axiomatic one based on abstract executions. 
%Suppose that we want to prove that an execution test $\ET$ is sound with respect 
%to an axiomatic specification $\Ax$. A kv-store $\hh$ is included in $\CMs(\ET)$ only 
%if we can find an $\ET$-trace $\tau$ that terminates in a configuration $(\hh, \_)$. Because 
%any $\ET$-trace is also a $\ET_{\top}$-trace, then by \cref{thm:kvtrace2aexec} 
%for any $\aexec \in \execs(\tau)$, $\hh_{\aexec} = \hh$. Therefore, it suffices to prove 
%$\execs(\tau)$ contains at least one abstract execution that satisfies $\Ax$, to conclude 
%that $\hh \in \CMs(\Ax)$. 
%Our proof technique amounts to proving that, whenever $\aexec$ satisfies the axioms in
%$\Ax$ and $\ET \vdash (\hh_{\aexec}, \vi) \triangleright 
%\opset: (\mkvs', \vi')$, then we can always find a set of read-only transactions $\T_{\mathsf{rd}}$ such that 
%by extending $\aexec$ with some transaction $\txid$, appearing last in the arbitration order 
%and whose set of visible transactions is $\Tx(\hh_{\aexec}, \vi) \cup \T_{\mathsf{rd}}$, then 
%the resulting execution also satisfies the axioms in $\Ax$. Assume that we have successfully employed the 
%proof technique for $\ET$, and consider the $\ET$-trace $\tau$ above, which we assume it has 
%$n$ $\ET$-reductions. It is immediate to note that the abstract execution $(\emptyset, \emptyset, \emptyset)$ 
%included in $\execs_{0}(\tau)$ satisfies $\Ax$; furthermore, because we have successfully applied our proof technique to $\ET$, 
%we are ensured that if $\execs_{i}(\tau)$ contains at least one abstract execution $\aexec_{i}$ that satisfies the axioms in $\Ax$, where $i=0,\cdots n-1$. 
%By induction, we conclude that $\execs(\tau)$ contains at least one abstract execution satisfying $\Ax$, and 
%therefore $\hh_{\aexec} \in \CMs(\aexec)$. 
%\sx{Not sure how to deal with above}

%In practice, our proof techniques also takes into account the possibility of defining an invariant over the set $\Tx(\_, \_)$, which 
%must be proved to be preserved by $\ET$-reductions. As we explain in \cref{app:?}, defining the right invariant 
%is crucial to prove the soundness of some execution test-based specifications.


%\begin{definition}
%\label{def:main-body-et_sound}
%An execution test $\ET$ is sound with respect to an axiomatic 
%specification $\Ax$ if and only if there exists an 
%invariant condition $I$ such that whenever $\ET \vdash (\hh, \vi) 
%\triangleright \opset: (\hh',\vi')$ where \( \mkvs' = \updKV{\mkvs, \vi ,\f, \txid}\), 
%for any $\aexec$ such that 
%$\hh_{\aexec} = \hh$, any client $\cl$ and any 
%transaction identifier $\txid \in \nextTxId(\hh, \cl)$, 
%such that $I(\aexec, \cl) \subseteq \Tx(\hh, \vi)$, then  
%there exists a other sets of transactions $\T_{\rd}$, 
%such that 
%\begin{itemize}
%\item $\forall \A \in \Ax. \Setcon{\txid' }{ (\txid', \txid) \in \A(\aexec')} \subseteq \Tx(\hh, \vi) \cup \T_{\rd}$, 
%\item the invariant is preserved, \ie $I(\aexec', \cl) \subseteq \Tx(\mkvs', \vi')$ for some \( \aexec' \) that \( \hh' = \hh_{\aexec'}\)
%\end{itemize}
%\end{definition}

%\sx{
    %Abuse of notation: 
    %\( \CMa(\RP_{\LWW}, \Ax) \), all possible abstract executions produced by the specification \( (\RP_{\LWW}, \Ax) \).
%}
%\begin{theorem}
%\label{thm:main-body-et_soundness}
%If $\ET$ is sound with respect to $(\RP_{\LWW}, \Ax)$, then 
%\[
    %\CMs(\ET) \subseteq \{ \hh \mid \exists \aexec \in \CMa(\RP_{\LWW}, \Ax)).\;\hh_{\aexec} = \hh\}
%\]
%\end{theorem}

%Similarly, in \cref{sec:aexectrace2kv} we show that it is possible to 
%construct a set of $\ET$-traces $\{\tau_{i}\}_{i \in I}$ from an abstract execution $\aexec$, such that 
%for any $i \in I$, the last configuration of $\tau_{i}$ has the form $(\hh_{\aexec}, \stub)$, and 
%the order in which transactions are executed in $\tau_{i}$ is consistent with $\AR_{\aexec}$. 
%This gives rise to a proof technique aimed at showing that execution-test based specifications 
%of consistency models are sound and complete with respect with their axiomatic counterparts on abstract executions. 
%More details are outlined in \cref{sec:kv2aexec-sound-complete}. 
%In \cref{app:et_sound_complete} we employ our proof techniques to prove that our specifications (\cref{fig:execution.tests})
%of consistency models using execution tests are sound and complete with respect to previously 
%existing axiomatic specifications based on dependency graphs.
