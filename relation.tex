\section{Correctness of Definitions of Consistency Models}
\label{sec:other_formalisms}

We demonstrate how our kv-stores and execution 
tests relate to existing declarative semantics for specifying  
consistency models, based on abstract executions \cite{framework-concur}. 
We prove our definitions of consistency models using execution tests
are equivalent to the definitions on abstract executions.
We give an overview of our results here, and refer the reader to \cref{app:depgraphs,sec:abstract-execution}
for more details.

%\mypar{Dependency Graphs and KV-Stores}
%Dependency graphs \cite{adya-icde,adya} are perhaps the most popular 
%formalism used for specifying transactional consistency models. 
%A dependency graph $\Gr$ is a directed, labelled graph where its
%nodes denote transactions and its edges denote certain \emph{dependencies} between transactions.  
%Each node is labelled with a transaction identifier and a fingerprint.
%Each edges is labelled with metadata describing the information flow in a run of the database: 
%\begin{enumerate*}
    %\item a \emph{session order} edge, $\txid_1 \xrightarrow{\SO} \txid_2$, 
	%\item a \emph{read dependency} edge, $\txid_1 \xrightarrow{\WR} \txid_2$, denotes
%that transaction $\txid_2$ reads a version written by $\txid_1$;
	%\item a \emph{write dependency} edge, $\txid_1 \xrightarrow{\WW} \txid_2$, denotes that $\txid_2$ overwrites a version written by $\txid_1$; and 
	%\item an \emph{anti-dependency} edge, $\txid_1 \xrightarrow{\RW} \txid_2$, denotes that $\txid_2$ overwrites a version read by $\txid_2$. 
%\end{enumerate*}
%Using dependency graphs, consistency models are specified by constraining the shape of the graph, typically by requiring the absence of certain cycles.  
%Observe that we can always \emph{extract} a dependency graph  $\Gr$ from a kv-store $\kvs$:
%we choose the transaction identifiers appearing in $\kvs$ as the nodes of $\Gr$, 
%and define $\SO$ as in \cref{subsec:kvstores}, and $ \RF, \VO, \AD$ as in \cref{fig:execution_tests}.
%In the technical appendix we show that we can reverse this process to construct dependency graphs from our kv-stores, thus giving 
%rise to the following result.

%\spaceshrink{-4pt}
%\begin{theorem}
%\label{thm:kv_graph_isomorph}
%Dependency graphs are bijective to kv-stores.
%\end{theorem}
%\spaceshrink{-6pt}

%\mypar{Abstract Executions and KV-Stores}

\emph{Abstract executions} \cite{ev_transactions,framework-concur} are a declarative formalism for defining consistency models. 
An abstract execution graph $\aexec$ is a directed graph with its nodes representing transactions 
(with each node labelled with a transaction identifier and a set of read/write operations), 
and its edges representing certain relations between transactions. 
Each edge is labelled by either the \emph{visibility} ($\VIS$) or \emph{arbitration} ($\AR$) relation. 
Visibility is an irreflexive order on transactions such that $(\txid_1,\txid_2) {\in} \VIS$ denotes that the effects (updates) of $\txid_1$ are visible to $\txid_2$. 
Arbitration is a strict total order on transactions such that $(\txid_1,\txid_2) {\in} \AR$ denotes that the updates performed by $\txid_2$ are newer than those of $\txid_1$. 
Moreover, $\AR$ contains $\VIS$ ($\VIS {\subseteq} \AR$) and agrees with the session order.
Lastly, abstract executions observe the \emph{last-write-wins} policy: 
a transaction reading $\key$ always fetches the latest visible write on $\key$.
Consistency models are defined by visibility axiom \( \visaxioms\) 
that imposes certain conditions on $\VIS$ and hence the shape of the graphs.

There is a correspondence between individual kv-stores and abstract executions.
We first show that there is a bijective between individual kv-stores and dependency graphs (\cref{app:depgraphs}),
another well-known graph-based declare rive semantics.
Then following \cite{laws}, we can always \emph{extract} a dependency graph from an abstract execution.
However, the correspondence to abstract executions is not one-to-one 
because multiple arbitration orders may produce equivalent kv-stores.
This correspondence is not enough for proving that 
the definitions using execution tests are correct to those on abtract executions, 
because of the operational flavour of the execution tests.
We propose an alternative operational semantics on abstract executions,
where, for each transition, 
a new node representing a transaction, together with the visibility edges for this new node,
is added to the graph, if the new graph satisfies the visibility axiom \( \visaxioms \).

The defintion of a consistency model using the execution test \( \et \) is \emph{correct}, 
\ie \emph{sound} and \emph{complete},
with repsect to the definition using visibility axiom \( \visaxioms \),
if, for every program, there is a correspondence
between traces of kv-stores under \( \et \) and 
traces of abstract executions under \( \visaxioms \).
Instead of directly working on traces,
we introduce soundness contractor and completeness constructor
that lift the corresponce between \( \et \) and \( \visaxioms \) to the trace level. 
In the technical appendix we show that 
all our definitions of consistency models in \cref{fig:execution_tests} 
are \emph{equivalent} to existing axiomatic definitions using abstract executions.
