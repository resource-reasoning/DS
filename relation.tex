\section{Correct Definitions of Consistency Models}
\label{sec:other_formalisms}

We demonstrate how our kv-stores and execution 
tests relate to existing declarative semantics for specifying  
consistency models, based on abstract executions \cite{framework-concur}. 
We prove our definitions of consistency models using execution tests
are \emph{equivalent} to the definitions on abstract executions.
We give an overview of our results here, and refer the reader to \cref{app:depgraphs,sec:abstract-execution}
for more details.

%\mypar{Dependency Graphs and KV-Stores}
%Dependency graphs \cite{adya-icde,adya} are perhaps the most popular 
%formalism used for specifying transactional consistency models. 
%A dependency graph $\Gr$ is a directed, labelled graph where its
%nodes denote transactions and its edges denote certain \emph{dependencies} between transactions.  
%Each node is labelled with a transaction identifier and a fingerprint.
%Each edges is labelled with metadata describing the information flow in a run of the database: 
%\begin{enumerate*}
    %\item a \emph{session order} edge, $\txid_1 \xrightarrow{\SO} \txid_2$, 
	%\item a \emph{read dependency} edge, $\txid_1 \xrightarrow{\WR} \txid_2$, denotes
%that transaction $\txid_2$ reads a version written by $\txid_1$;
	%\item a \emph{write dependency} edge, $\txid_1 \xrightarrow{\WW} \txid_2$, denotes that $\txid_2$ overwrites a version written by $\txid_1$; and 
	%\item an \emph{anti-dependency} edge, $\txid_1 \xrightarrow{\RW} \txid_2$, denotes that $\txid_2$ overwrites a version read by $\txid_2$. 
%\end{enumerate*}
%Using dependency graphs, consistency models are specified by constraining the shape of the graph, typically by requiring the absence of certain cycles.  
%Observe that we can always \emph{extract} a dependency graph  $\Gr$ from a kv-store $\kvs$:
%we choose the transaction identifiers appearing in $\kvs$ as the nodes of $\Gr$, 
%and define $\SO$ as in \cref{subsec:kvstores}, and $ \RF, \VO, \AD$ as in \cref{fig:execution_tests}.
%In the technical appendix we show that we can reverse this process to construct dependency graphs from our kv-stores, thus giving 
%rise to the following result.

%\spaceshrink{-4pt}
%\begin{theorem}
%\label{thm:kv_graph_isomorph}
%Dependency graphs are bijective to kv-stores.
%\end{theorem}
%\spaceshrink{-6pt}

%\mypar{Abstract Executions and KV-Stores}

\emph{Abstract executions} \cite{ev_transactions,framework-concur} are a declarative formalism for defining consistency models. 
An abstract execution graph is a directed graph with its nodes representing transactions 
(with each node labelled with a transaction identifier and a set of read/write operations), 
and its edges representing certain relations between transactions. 
Each edge is labelled by either the \emph{visibility} ($\VIS$) or \emph{arbitration} ($\AR$) relation. 
Visibility is an irreflexive order on transactions such that $(\txid_1,\txid_2) {\in} \VIS$ denotes that the effects (updates) of $\txid_1$ are visible to $\txid_2$. 
Arbitration is a strict total order on transactions such that $(\txid_1,\txid_2) {\in} \AR$ denotes that the updates performed by $\txid_2$ are newer than those of $\txid_1$. 
Moreover, $\AR$ contains $\VIS$ ($\VIS {\subseteq} \AR$) and agrees with the session order.
Lastly, abstract executions observe the \emph{last-write-wins} policy: 
a transaction reading $\key$ always fetches the latest visible write on $\key$.
Consistency models are defined by visibility axioms \( \visaxioms\) 
that impose certain conditions on $\VIS$ and hence the shape of the graphs.

%<<<<<<< HEAD
%There is a correspondence between individual kv-stores and abstract executions.
%We first show that there is a bijection between individual kv-stores and dependency graphs (\cref{app:depgraphs}),
%another well-known graph-based declarative semantics.
%Then following \cite{laws}, we can always \emph{extract} an abstract execution
%from a dependency graph and therefore from a kv-store.
%However, the correspondence between kv-stores and abstract executions is not one-to-one 
%because multiple arbitration orders may produce equivalent kv-stores.
%This correspondence is \emph{not enough} for proving that 
%our definitions using \( \ET \) are correct to those using \( \visaxioms \), 
%because the \( \ET \) restricts the steps in traces but \( \visaxioms\) is on the final states.
%We propose an alternative operational semantics on abstract executions:
%for each transition, 
%a new transaction node, with the visibility edges for the node,
%is extended to the graph (with respect to \(\AR\)), if the new graph satisfies the visibility axiom \( \visaxioms \).

%The definition of a consistency model using the execution test \( \et \) is \emph{equivalent}, 
%\ie \emph{sound} and \emph{complete},
%with respect to the definition using visibility axiom \( \visaxioms \),
%=======
We show that there is a correspondence between kv-stores and abstract executions.
To do this, we 
\begin{enumerate*}
	\item establish a bijection between kv-stores and dependency graphs (\cref{app:depgraphs}),
	\label{item:kv-dependency}
another well-known graph-based declarative formalism; and then
	\item following \cite{laws}, we show that we can always \emph{extract} an abstract execution from a dependency graph and therefore from a kv-store by \ref{item:kv-dependency}. 
\end{enumerate*}
However, this correspondence is not one-to-one 
as multiple $\AR$ relations may produce equivalent kv-stores.
As such, our correspondence result is not enough to prove that 
our definitions using \( \ET \) are equivalent to those using \( \visaxioms \).
This is because \( \ET \) constrains each transition step while \( \visaxioms\) constrains the final graph shape.
We thus propose an alternative operational semantics on abstract executions,
where each transition extends the graph with a 
new transaction node and its visibility edges, 
provided that the new graph satisfies \( \visaxioms \).

We thus show that a consistency model defined using an execution test \( \et \) is \emph{equivalent}
(\ie \emph{sound} and \emph{complete})
to the definition using visibility axiom \( \visaxioms \),
%>>>>>>> d707795db22c75a103fe00ea1c486952e2f45afe
if for every program there is a correspondence
between traces of kv-stores under \( \et \) and 
traces of abstract executions under \( \visaxioms \).
Instead of directly working on traces,
we introduce soundness and completeness constructors (\cref{sec:et-sound-complete-constructor})
that lift certain conditions between \( \et \) and \( \visaxioms \) to the level of traces. 
In \cref{app:et_sound_complete}, we show that 
all our definitions of consistency models in \cref{fig:execution_tests} 
are \emph{equivalent} to existing axiomatic definitions using abstract executions.
