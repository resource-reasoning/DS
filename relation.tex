\section{Our Framework and Other Formalisms}
\label{sec:other_formalisms}
We demonstrate that our definition of consistency models via execution tests have several desirable properties. 
First, we demonstrate that our consistency models are \emph{compositional} in that they can be composed to build stronger models.
%Next, we demonstrate that the commutativity of our execution tests are preserved under 
Next, we demonstrate that our representation of consistency models \emph{generalises} the existing formalisms in the literature, namely \emph{dependency graphs}~\cite{adya-icde} and abstract executions~\cite{}. 
That is, \emph{any} consistency model specified using these formalisms can be encoded as is a consistency model in our framework. 
For abstract executions, we further demonstrate that the other direction holds too. 
That is, \emph{any} consistency model formulated in our framework can be specified using abstract executions. 
\azalea{Can someone double check to make sure these claims are accurate? \sx{the another way is abstract execution, I already change}}



\sx{
    Most execution tests we proposed can be adapted to 
    satisfy the first three constraints.
    The last one is the main constraints, and \( \CP \) and \( \SI \) do not satisfy it.
    Is this also true of commutativity? Are they all commutative?
}

\mypar{Compositionality}
We demonstrate that our consistency models are \emph{compositional}.
That is, given two execution tests $\ET_1$ and $\ET_2$, the consistency model induced by their composition 
(\ie $\CMs(\ET_1 \cap \ET_2)$) is equivalent to the composition of their two consistency models (\ie $\CMs(\ET_1) \cap \CMs(\ET_2)$), 
provided that $\ET_1, \ET_2$ meet \emph{certain conditions}.
These conditions are formalised in \cref{def:et_properties} below. 
Given an execution test $\ET$, 
the \emph{no blind writes} property ensures that $\ET$ allows a transaction to write to a key $\ke$ only if the transaction also reads from $\ke$. 
The \emph{minimum footprint} property ensures that $\ET$ is only concerned with those keys accessed (read or written) by a transaction (\ie those keys in its fingerprint) and is thus agnostic to the keys not accessed by the transaction. 
The \emph{monotonic post-views} ensures that $\ET$ allows client views to grow after committing a transaction. 
The \emph{commutativity} ensures that $\ET$ allows the execution of two \emph{non-conflicting} transactions of distinct clients to be reordered. 
Two transactions are non-conflicting if they write to disjoint set of keys; \ie their fingerprints do not contain a write operation to the same key. 

Note that these properties are not too restrictive in that the execution tests of most common consistency model satisfy them. 
In particular, with the exception of $\CP$ and $\SI$, all execution tests defined \cref{fig:execution_tests} satisfy the four conditions in \cref{def:et_properties}. 
Moreover, $\CP$ and $\SI$ execution tests satisfy all conditions but that of monotonic post-vies. 
This is because \todo.
\azalea{Shale, Andrea, can you give an intuitive explanation why $\CP, \SI$ don't satisfy monotonic post-views?
    \sx{They satisfies monotonic post-view, but \( \CP, \SI, \UA \) do not satisfy commutative.
        Many literatures claim \( \SI = \CP + \UA \) \ie, \( \CMs(\CP \cap \UA ) = \CMs(\CP) \cap \CMs(\UA) \), 
        but in our framework, if none of \( \CP \) and \( \UA \) is commutative, it does not hold.
        (side note, \( \PSI = \CC + \UA \), because \( \CC \) is commutative).
    }

}


\begin{definition}[$\ET$ properties]
\label{def:noblidwrites}
\label{def:et-minimum-footprint}
\label{def:et-continuous-postview}
\label{def:et_properties}
An execution test $\ET$ has \emph{no blind writes} if
%it allows a key to be written only when it is also read;
%that is, 
for all $\hh, \vi, \vi', \opset, \ke$:\\
\indent
$
\ET \vdash (\hh, \vi) \triangleright \opset: \vi' 
\land (\otW, \ke, \_) \in \opset
\implies (\otR, \ke, \_) \in \opset
$
\azalea{This definition of minimum footprint below doesn't make sense; it is too strong! 
Since $\vi, \vi'$ is universally quantified, we are essentially saying for any key in the footprint, two arbitrary views must have the same versions!
I think you mean for all $\hh$, $\vi, \vi', \vi'', \opset$:
\[
\begin{array}{@{} r l @{}}
\text{if} & \ET \vdash (\hh, \vi) \triangleright \opset : \vi'' \\
\text{and} & \fora{ \ke} (\stub, \ke, \stub) \in \f \implies \vi(\ke) = \vi'(\ke) \\
\text{then} & \ET \vdash (\hh, \vi') \triangleright \opset : \vi''
\end{array} 
\]
\sx{Yes you are right. I already change}
}
An execution test $\ET$ has \emph{minimum footprints} if for all kv-stores $\hh$,
views $\vi, \vi',\vi''$ and fingerprints $\f$: 
%
\[
\begin{array}{@{}l@{}}
\ET \vdash (\hh, \vi) \triangleright \opset : \vi''     
\land \fora{ \ke} \left( (\stub, \ke, \stub) \in \f \implies \vi(\ke) = \vi'(\ke) \right) 
\implies \ET \vdash (\hh, \vi') \triangleright \opset : \vi''
\end{array}
\]
%

An execution test $\ET$ has \emph{monotonic post-views} if 
%it allows views to grow after committing; 
%that is, 
for all kv-stores $\hh$, 
views $\vi, \vi',\vi''$ and fingerprints $\f$:
\[
    \ET \vdash (\hh, \vi) \triangleright \opset : \vi' 
    \land \vi' \sqsubseteq \vi'' 
    \implies 
    \ET \vdash (\hh, \vi) \triangleright \opset : \vi''
\]

Two fingerprints $\opset_1$ and $\opset_2$ are \emph{conflicting} 
iff there exists $\ke$ such that 
$(\otW, \ke, -) \in \opset_1 \land (\otW, \ke, -) \in \opset_2$. 

An execution test $\ET$ is \emph{commutative}, written $\com \ET$, if 
for all views $\vi_1, \vi_2 \in \Views(\hh_0)$, 
clients $\cl_1, \cl_2$,
fingerprints $\opset_1, \opset_2$, 
kv-stores $\hh'$,
and view functions $\viewFun, \viewFun'$:
\[
\begin{array}{@{}r @{\hspace{10pt}} l @{}}
	\text{if} &  
	(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} 
	\_ \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} (\hh', \viewFun') \\
	& \land\ \cl_1 \ne \cl_2 \land \opset_1, \opset_2  \text{ are non-conflicting}\\
%
%	
	\text{then} & (\hh_0, \viewFun) \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} 
\_ \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} (\hh', \viewFun')
\end{array}
\]

%if $\cl_1 \ne \cl_2$, and $\opset_1, \opset_2$ are non-conflicting,
%then for all $\hh', \viewFun, \viewFun'$:
%\[
%\begin{array}{lr}
%(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} 
%\_ \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} (\hh', \viewFun') &\implies \\
%(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} 
%\_ \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} (\hh', \viewFun')
%\end{array}
%\]
\end{definition}



%\begin{definition}
%Two fingerprints $\opset_1$ and $\opset_2$ are \emph{conflicting} 
%iff there exists $\ke$ such that 
%$(\otW, \ke, -) \in \opset_1 \land (\otW, \ke, -) \in \opset_2$. 
%
%Execution test is $\ET$ is \emph{commutative}, written $\com \ET$, if 
%for all views $\vi_1, \vi_2 \in \Views(\hh_0)$, 
%clients $\cl_1, \cl_2$,
%fingerprints $\opset_1, \opset_2$, 
%kv-stores $\hh'$,
%and view functions $\viewFun, \viewFun'$:
%\[
%\begin{array}{@{}r @{\hspace{10pt}} l @{}}
%	\text{if} &  
%	(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} 
%	\_ \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} (\hh', \viewFun') \\
%	& \land\ \cl_1 \ne \cl_2 \land \opset_1, \opset_2  \text{ are non-conflicting}\\
%%
%%	
%	\text{then} & (\hh_0, \viewFun) \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} 
%\_ \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} (\hh', \viewFun')
%\end{array}
%\]
%
%%if $\cl_1 \ne \cl_2$, and $\opset_1, \opset_2$ are non-conflicting,
%%then for all $\hh', \viewFun, \viewFun'$:
%%\[
%%\begin{array}{lr}
%%(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} 
%%\_ \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} (\hh', \viewFun') &\implies \\
%%(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} 
%%\_ \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} (\hh', \viewFun')
%%\end{array}
%%\]
%\end{definition}

We can now formalise our compositionality theorem below. 
The first part states that the consistency model induced by the composition of two execution tests, is equivalent to the composition of their two consistency models.
The second part states that composition preserves commutativity:
if two execution tests are commutative, then their composition is also commutative. 
The full proof of this theorem is given in the appendix (see \cref{thm:et-comm}). 
%
\begin{theorem}[Compositionality]     
For all $\ET_1, \ET_2$ with no blind writes, minimum footprints and monotonic post-views: 
\begin{align*}
	\com {\ET_1}
	& \implies \CMs(\ET_1 \cap \ET_2) {=} \CMs(\ET_1) \cap \CMs(\ET_2)\\
	\bigwedge_{i \in \{1, 2\}} \!\!\!\!\com{\ET_i}
	& \implies  \com{\ET_1 \cap \ET_2}
\end{align*}
%If $\com{\ET_1}$, 
%then $\CMs(\ET_1 \cap \ET_2) {=} \CMs(\ET_1) \cap \CMs(\ET_2)$. 
%If $\com{\ET_1} \land \com{\ET_2}$, then $\com{\ET_1 \cap \ET_2}$.
\end{theorem}

\subsection{Dependency Graphs}

\sx{I try to remember the discussion among me, Andrea and P:
the relation to dependency can simplify to one paragraph since it is easy to see.}
\emph{Dependency graphs} are introduced by Adya to specify consistency models of transactional databases \cite{adya}. 
They are directed graphs consisting of transactions as nodes, 
each of which is labelled with transaction identifier and a set of read and write operations,
and labelled edges between transactions for specifying how information flows between nodes. 
Specifically, a transaction $\txid$ reads a version for a key $\ke$ that has been written by another transaction $\txid'$ 
(\emph{write-read dependency} \( \WR\)), overwrites a version of $\ke$ written by $\txid'$ (\emph{write-write dependency} \( \WW \)),
or reads a version of $\ke$ that is later overwritten by $\txid'$ (\emph{read-write anti-dependency} \( \RW \)).
Note that here we purposely use the same names \( \WR, \WW, \RW \) as those used in key-value store,
since there is one-to-one map between key-value stores and dependency graphs.

\input{\RootPath/dgraph/depend-aexec-fig.tex}

\begin{definition}
A \emph{dependency graph} is a quadruple $\Gr = (\TtoOp{T}, \RF, \VO, \AD)$, where
\begin{itemize}
\item 
    $\TtoOp{T}_0: \TxID_0 \parfinfun \powerset{\Ops}$ is a partial finite mapping from transaction identifiers 
    to the set of operations, where there are at most one read operation and one write operation per key;
\item 
    $\RF : \Keys \to \pset{\dom(\TtoOp{T}) \times \dom(\TtoOp{T})}$ is a function that 
maps each key $\ke$ into a relation between transactions, such that for any $\txid, \txid_1, \txid_2, 
\ke, \cl, m, n$: 
\begin{itemize}
\item if $(\otR, \ke, \val) \in \TtoOp{T}(\txid)$, either $\val = \val_0$ 
and there exists no $\txid'$ such that $\txid' \xrightarrow{\RF(\ke)} \txid$,  
or there exists $\txid'$ such that $(\otW, \ke, \val) \in \TtoOp{T}(\txid')$, and $\txid' \xrightarrow{\RF(\ke)} \txid$, 
\item if $\txid_1 \xrightarrow{\RF(\ke)} \txid$ and $\txid_2 \xrightarrow{\RF(\ke)} \txid$, then 
$\txid_2 = \txid_1$.
\item if $\txid_{\cl}^{m} \xrightarrow{\RF(\ke)} \txid_{\cl}^{n}$, then $m < n$.
\end{itemize}
\item $\VO: \Keys \to \pset{\dom(\TtoOp{T}) \times \dom(\TtoOp{T})}$ is a function 
that maps each key into an irreflexive relation between transactions, such that for any $\txid, \txid', \ke, \cl, m, n$, 
\begin{itemize}
\item if $\txid \xrightarrow{\VO(\ke)} \txid'$, then $(\otW, \ke, \_) \in \TtoOp{T}(\txid), (\otW, \ke, \_) \in \TtoOp{T}(\txid')$, 
\item if $(\otW, \ke, \_) \in \TtoOp{T}(\txid), (\otW, \ke, \_) \in \TtoOp{T}(\txid')$, then either $\txid = \txid'$, 
$\txid \xrightarrow{\VO(\ke)} \txid'$, or $\txid' \xrightarrow{\VO(\ke)} \txid$.
\item if $\txid_{\cl}^{m} \xrightarrow{\WW(\ke)} \txid_{\cl}^{n}$, then $m < n$.
\end{itemize}
\item $\AD: \Keys \to \pset{\dom(\TtoOp{T}) \times \dom(\TtoOp{T})}$ is defined 
by letting $\txid \xrightarrow{\AD(\ke)} \txid'$ if and only if $(\otR, \ke, \_) \in \TtoOp{T}(\txid)$, 
$(\otW, \ke, \_) \in \TtoOp{T}(\txid')$ and 
either there exists no $\txid''$ such that $\txid'' \xrightarrow{\RF(\ke)} \txid$, or 
$\txid'' \xrightarrow{\RF(\ke)} \txid$, $\txid'' \xrightarrow{\VO(\ke)} \txid'$ for 
some $\txid''$.
\end{itemize}
\end{definition}
Given a dependency graph $\Gr = (\TtoOp{T}, \RF, \VO, \AD)$, we often 
commit an abuse of notation and use $\RF$ to denote the relation 
$\bigcup\limits_{\ke \in \Keys} \RF(\ke)$; a similar notation is adopted for $\VO, \AD$. 
It will always be clear from the context whether the symbol $\RF$ refers to a function 
from keys to relations, or to a relation between transactions. 

We let $\Dgraphs$ be the set of all dependency graphs.
It is always possible to convert a kv-store $\hh$ into a well-formed dependency 
graph. For example, \cref{fig:dependency-graph} is the dependency graph 
that illustrates scenario similar with the key-value store in \cref{fig:hheap-a}.

\begin{definition}
\label{def:main-body-kv2graph}
Given a kv-store $\hh$, the \emph{dependency graph} $\Gr_{\hh} = (\TtoOp{T}_{\hh}, \RF_{\hh}, 
\VO_{\hh}, \AD_{\hh})$ is defined as follows: 
\begin{itemize}
\item for any $\txid \neq \txid_0$, $\TtoOp{T}_{\hh}(\txid)$ is defined if and only if there exists an index $i$ and a key 
$\ke$ such that either $\txid = \WTx(\hh(\ke, i))$, or $\txid \in \RTx(\hh(\ke,i))$; furthermore, 
$(\otW, \ke, \val) \in \TtoOp{T}(\txid)$ if and only 
if $\txid = \WTx(\hh(\ke, i))$ for some $i$, and 
$(\otR, \ke, \val) \in \TtoOp{T}(\txid)$ if and only if $\txid \in \RTx(\hh(\ke, i))$ for some $i$, 
\item $\txid \xrightarrow{\RF(\ke)} \txid'$ if and only if there exists an index $i: 0 < i < \lvert \hh(\ke) \rvert$ 
such that $\txid = \WTx(\hh(\ke, i))$, and $\txid' \in \RTx(\hh(\ke, i))$, 
\item $\txid \xrightarrow{\VO(\ke)} \txid'$ if and only if there exist two indexes $i,j$: $0 < i < j < \lvert \hh(\ke) \rvert$ 
such that $\txid = \WTx(\ke, i)$, $\txid' = \WTx(\ke, j)$, 
\item $\txid \xrightarrow{\AD(\ke)} \txid'$ if and only if there exist two indexes $i,j$: $0 < i < j < \lvert \hh(\ke) \rvert$ 
such that $\txid \in \RTx(\ke, i)$ and $\txid' = \WTx(\ke, j)$.
\end{itemize}
\end{definition}

\begin{theorem}
\label{thm:main-body-kv2graph}
There is a one-to-one map between key-value stores and dependency graphs.
\end{theorem}
\begin{proof}
    See \cref{thm:kv2graph} in \cref{sec:dependent-graph}.
\end{proof}



\subsection{Abstract Executions}
\sx{
The following is the relation between key-values and abstract executions}
\begin{definition}
\label{def:main-body-absexec}
\label{def:main-body-aexec}
An abstract execution is a triple $\aexec = (\TtoOp{T}, \VIS, \AR)$, where 
\begin{itemize}
    \item $\TtoOp{T}: \TxID_{0} \parfinfun \powerset{\Ops}$ is a partial, 
finite function mapping transaction identifiers to the set of operations that they perform,
\item $\VIS \subseteq \dom(\TtoOp{T}) \times \dom(\TtoOp{T})$ is an irreflexive relation, 
called \emph{visibility}, 
\item $\AR \subseteq \dom(\TtoOp{T}) \times \dom(\TtoOp{T})$ is a strict, total order 
such that $\VIS \subseteq \AR$, and whenever $\txid_{\cl}^{n} \xrightarrow{\AR} 
\txid_{\cl}^{m}$, then $n < m$.
\end{itemize} 
The set of abstract executions is denoted by $\aeset$.
\end{definition}

A semantics under \( \aexec \), where transaction satisfies the specification in the form of \( (\RP,\Ax) \).
\( \RP \) is a function takes a set of transactions \( \T \) from abstract execution \( \aexec \), 
and returns  a set of possible snapshots.
A common one is last-write-win.

\begin{definition}
\label{def:lww}
The Last Write Wins resolution policy $\RP_{\LWW}$ is defined as 
$\RP_{\LWW}(\aexec, \T) \defeq \{\h\}$ where
\begin{align*}
    \h & \defeq \lambda \ke. \text{let} \ \T_{\ke} = ( \T \cap \{\txid \mid (\otW,\ke, \_) \in_{\aexec} \txid\}) \\
       & \quad \text{in} \
\begin{cases}
\val_{0} &\impliedby \T_{\ke} =  \emptyset\\
\val &\impliedby (\otW, \ke, \val) \in_{\aexec} \max_{\AR_{\aexec}}(\T_{\ke})
\end{cases}
\end{align*}
\end{definition}

\( \Ax \) is a set of constraints on the shape of the abstract execution,
which defines the minimum visibility relation.
For example, the minimum visibility for serialisability is a singleton set
\( \Ax_\SER = \Set{\lambda \aexec \ldotp \AR_\aexec } \),
which means the minimum visibility should contain the arbitration \( \AR_\aexec \subseteq \VIS_\aexec \).
In general, if an abstract execution \( \aexec \) satisfies a set of constraints  \( \Ax \),
if \( \fora{\A \in \Ax} \A(\aexec) \subseteq \VIS_\aexec \).

Through the dependency graph, we can relate key-value stores and abstract executions (\cref{def:main-body-aexec2graph}).
Note that each abstract execution $\aexec$ determines a key-value store 
$\hh_{\aexec}$, as per \cref{def:main-body-aexec2graph} and \cref{thm:main-body-kv2graph}. 

\begin{definition}
\label{def:main-body-aexec2graph}
Given an abstract execution $\aexec$ that satisfies the last write wins policy,
the dependency graph $\graphof(\aexec) \defeq (\TtoOp{T}_{\aexec}, \RF_{\aexec}, 
\VO_{\aexec}, \AD_{\aexec})$ is defined by letting
\begin{itemize}
\item $\txid \xrightarrow{\RF_{\aexec}(\ke)} \txid'$ if and only if 
    $\txid = \max_{\AR_{\aexec}}\left( \Setcon{\txid}{(\otW,\ke,\stub) \in \txid' \land \txid' \toEdge{\VIS_\aexec} \txid } \right)$, 
\item $\txid \xrightarrow{\VO_{\aexec}(\ke)} \txid'$ if and only 
$\txid, \txid' \in_{\aexec} (\otW, \;\ke: \_)$ 
and $\txid \xrightarrow{\AR_{\aexec}} \txid'$,
\item $\txid \xrightarrow{\AD_{\aexec}(\ke)} \txid'$ if and only if either 
$(\otR, \ke, \_) \in_{\aexec} \txid, (\otW, \ke, \_) \in_{\aexec} \txid'$ and 
whenever $\txid'' \xrightarrow{\RF_{\aexec}(\ke)} \txid$, 
then $\txid'' \xrightarrow{\VO_{\aexec}(\ke)} \txid'$.
\end{itemize}
\end{definition}

Let $\hh$ be the unique kv-store such that $\Gr_{\hh} = \graphof(\aexec)$: then 
$\hh_{\aexec} = \hh$. 
Yet this mapping $\hh_{(\stub)}$ is not a bijection, 
in that several abstract executions may be encoded in the same key-value store. 
This is because key-value stores abstract away the total arbitration order of transactions.

\sx{
    explain \( \Tx(\mkvs,\vi) \) and intuition of invariant \( I \):
    \( \Tx(\mkvs,\vi) \) includes all the writers of the versions \( \mkvs(\ke, i)\), 
    where these versions are included in the view \( i \in \vi(\ke)\).
    In abstract executions, there is  no explicit \( \SO \) relation 
    but \( \VIS \) and \( \AR \) relations.
    The invariant \( I(\aexec, \cl) \) is for carrying information 
    for transactions from the client \( \cl \).
}

\begin{definition}
\label{def:main-body-et_sound}
An execution test $\ET$ is sound with respect to an axiomatic 
specification $(\RP_{\LWW}, \Ax)$ if and only if there exists an 
invariant condition $I$ such that whenever $\ET \vdash (\hh, \vi) 
\triangleright \opset: \vi'$, for any $\aexec$ such that 
$\hh_{\aexec} = \hh$, for any client $\cl$, for any 
transaction identifier $\txid \in \nextTxId(\hh, \cl)$, 
such that  $I(\aexec, \cl) \subseteq \Tx(\hh, \vi)$, then  
there exist two other sets of transactions $\T_{\rd}$, 
such that 
\begin{itemize}
\item $\forall \A \in \Ax. \Setcon{\txid' }{ (\txid', \txid) \in \A(\aexec')} \subseteq \Tx(\hh, \vi) \cup \T_{\rd}$, 
\item $I(\aexec', \cl) \subseteq \Tx(\mkvs_{\aexec'}, \vi')$
\end{itemize}
\end{definition}

\sx{
    Abuse of notation: 
    \( \CMa(\RP_{\LWW}, \Ax) \), all possible abstract executions produced by the specification \( (\RP_{\LWW}, \Ax) \).
}
\begin{theorem}
\label{thm:main-body-et_soundness}
If $\ET$ is sound with respect to $(\RP_{\LWW}, \Ax)$, then 
\[
    \CMs(\ET) \subseteq \{ \hh \mid \exists \aexec \in \CMa(\RP_{\LWW}, \Ax)).\;\hh_{\aexec} = \hh\}
\].
\end{theorem}
\begin{proof}
    See \cref{thm:et_soundness} in \cref{sec:kv2aexec-sound-complete}.
\end{proof}

\sx{explain \( \getView\):
    It can be seen as the inverse of \( \Tx \).
    Assume the key-value store \( \mkvs \) and  abstract execution \( \aexec \)  are compatible,
    ie\( \mkvs = \mkvs_\aexec \).
    For any version \( \mkvs(\ke,i)\) and its writer \( \txid = \WTx(\mkvs(\ke,i)) \),
    if \( \txid \) is visible by \( \txid' \) in the \( \aexec \),
    then the view of \( \txid' \) before commit contains the version \( \mkvs(\ke,i) \),
    that is \( i \in \getView(\aexec, \VIS^{-1}(\txid'))(\ke) \).
}

\begin{definition}
\label{def:main-body-et_complete}
An execution test $\ET$ is \emph{complete} with respect 
to an axiomatic specification $(\RP_{\LWW}, \Ax)$ if, for any 
abstract execution $\aexec \in \CMa(\RP_{\LWW}, \Ax)$ 
such that $\AR_{\aexec} = \{(\txid_{i}, \txid_{i+1})\}_{i=1}^{\lvert \T_{\aexec} \rvert - 1}$, 
and for any $i=1,\cdots, n$, there exist two views $\vi_{i}, \vi_{i}'$ such that 
\begin{itemize}
\item $\vi_{i} = \getView(\aexec, \VIS_{\aexec}^{-1}(\txid_{i}))$, 
\item let $\txid_{i} = \txid_{\cl}^{n}$ for some $\cl, n$; if the
transaction $\txid_{i}' = \min_{\PO_{\aexec}}\{\txid' \mid \txid_i \xrightarrow{\PO_{\aexec}} \txid'\}$  
is defined, then $\vi' = \getView(\aexec, \T_{i})$, where $\T_{i} \subseteq (\AR_{\aexec}^{-1})?(\txid_{i}) \cap \VIS_{\aexec}^{-1}(\txid_{i}'))$; 
otherwise $\vi' = \getView(\aexec, \T_{i})$, where $\T_{i} \subseteq (\AR_{\aexec}^{-1})?(\txid_{i})$, 
\item $\ET \vdash (\hh_{\cut(\aexec, i-1)}, \vi_{i}) \triangleright \TtoOp{T}_{\aexec}(\txid_{i}) : \vi_{i}'$.
\end{itemize}
\end{definition}

\begin{theorem}
\label{thm:main-body-et_complete}
Let $\ET$ be an execution test that is complete with respect to 
an axiomatic specification $(\RP_{\LWW}, \Ax)$. Then 
$\CMa(\RP_{\LWW}, \Ax) \subseteq \CMs(\ET)$.
\end{theorem}
\begin{proof}
    See \cref{thm:et_complete} in \cref{sec:kv2aexec-sound-complete}.
\end{proof}

Given above, we have proven the specification in \cref{sec:spec-proof}.

