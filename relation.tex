\section{KV-Stores and Other Formalisms}
\label{sec:other_formalisms}

%We demonstrate that our definition of consistency models via execution tests have several desirable properties. 
%First, we demonstrate that our consistency models are \emph{compositional} in that they can be composed to build stronger models.
%%Next, we demonstrate that the commutativity of our execution tests are preserved under 
%Next, we demonstrate that our representation of consistency models \emph{generalises} the existing formalisms in the literature, namely \emph{dependency graphs}~\cite{adya-icde} and abstract executions~\cite{??}. 
%That is, \emph{any} consistency model specified using these formalisms can be encoded as is a consistency model in our framework. 
%For abstract executions, we further demonstrate that the other direction holds too. 
%That is, \emph{any} consistency model formulated in our framework can be specified using abstract executions. 
%\ac{
%\azalea{Can someone double check to make sure these claims are accurate? }
%I don't think so. These claims are too strong that the actual results we have.}
We give a formal account of the properties enjoyed by our operational 
semantics. We first investigate the compositionality of consistency models 
induced by execution tests. Then we discuss how kv-stores and execution 
tests relate to previously known declarative formalisms for specifying weak 
consistency models, based on dependency graphs \cite{adya} 
and abstract executions \cite{framework-concur}. Due to space 
constraints, we give a main overview of the results and refer the reader to the 
appendix for technical details.

%\sx{
%    Most execution tests we proposed can be adapted to 
%    satisfy the first three constraints.
%    The last one is the main constraints, and \( \CP \) and \( \SI \) do not satisfy it.
%    \azalea{Is this also true of commutativity? Are they all commutative?}
%}

\mypar{Compositionality}
We address the issue of whether specifications of consistency models 
induced by execution tests are compositional:  i.e. given 
two execution tests $\ET_1, \ET_2$, does it hold that 
$\CMs(\ET_1 \cap \ET_2) = \CMs(\ET_1) \cap \CMs(\ET_2)$? 
It is not difficult to show that, for any arbitrary $\ET_1$ and $\ET_2$, 
then the consistency model induced by the composite execution test 
$\ET_1 \cap \ET_2$ is at least as strong as the intersection of the 
consistency models defined by each individual execution test. 
\begin{proposition}
\label{prop:composite_stronger}
$\forall \ET_1, \ET_2.\CMs(\ET_1 \cap \ET_2) \subseteq \CMs(\ET_1) \cap \CMs(\ET_2)$.
\end{proposition}

Unfortunately, the other inclusion of \cref{prop:composite_stronger} is not satisfied 
by arbitrary consistency models.
To see why this is true, consider two simple execution tests: 
$\ET_1 \vdash (\hh_{0}, \vi_{0}) \triangleright \{(\otW, \ke, 1)\}, \vi_{0}$, 
$\ET_1 \vdash (\hh_{\ke}, \vi_{0}) \triangleright \{(\otW, \ke', 1)\}, \vi_{0}$, 
and $\ET_2 \vdash (\hh_{0}, \vi_{0}) \triangleright \{(\otW, \ke', 1)\}, \vi_{0}$, 
$\ET_2 \vdash (\hh_{\ke'}, \vi_{0}) \triangleright \{(\otW, \ke, 1)\} \vi_{1}$, 
where $\hh_{\ke} = \hh_{0}[\ke \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \_, \emptyset)]$
and $\hh_{\ke'} = \hh_{0}[\ke' \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \_, \emptyset)]$. 
Both $\ET_1$ and $\ET_2$ allow a version with value $1$ to be written for the two keys 
$\ke, \ke'$, which means that for $\hh' = \hh[\ke \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \_, \emptyset), 
\ke' = \ke \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \_, \emptyset)]$ we have that $\hh' \in \CMs(\ET_1) \cap \CMs(\ET_2)$. 
However, $\ET_1$ and $\ET_2$ enforce a different order in which the updates to the keys $\ke, \ke'$ must happen, 
and therefore we have that $\hh' \in \CMs(\ET_1 \cap \ET_2)$. 

In the example above, the main problem that led to the failure of compositionality is that the execution tests 
enforced a particular order on the updates that can be committed into the kv-store, even though such updates 
are non-conflicting: i.e. the kv-store obtained after applying such updates is independent of the order in which the 
updates are actually performed. This observation justifies the following definition: 
\begin{definition}
Two fingerprints $\opset_1$ and $\opset_2$ are \emph{conflicting} 
iff there exists $\ke$ such that 
$(\otW, \ke, -) \in \opset_1 \land (\otW, \ke, -) \in \opset_2$. 

An execution test $\ET$ is \emph{commutative}, written $\com \ET$, if 
for all views $\vi_1, \vi_2 \in \Views(\hh_0)$, 
clients $\cl_1, \cl_2$,
fingerprints $\opset_1, \opset_2$, 
kv-stores $\hh'$,
and view functions $\viewFun, \viewFun'$:
\[
\begin{array}{@{}r @{\hspace{10pt}} l @{}}
	\text{if} &  
	(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} 
	\_ \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} (\hh', \viewFun') \\
	& \land\ \cl_1 \ne \cl_2 \land \opset_1, \opset_2  \text{ are non-conflicting}\\
%
%	
	\text{then} & (\hh_0, \viewFun) \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} 
\_ \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} (\hh', \viewFun')
\end{array}
\]
\end{definition}

Requiring execution tests to be commutative is a necessary condition to recover 
the compositionality result that we desire. However, it is not sufficient. 
In \cref{app:compositionality} we prove that commutativity ensures that, 
if $\hh \in \CMs(\ET_1) \cap \CMs(\ET_2)$, then for each 
$\ET_1$-trace of the form $(\hh_{0}, \viewFun_{0}) \xrightarrow{(\alpha_{1})}_{\ET_1} \cdots 
\xrightarrow{(\alpha_{n})}_{\ET_1} (\hh_{n}, \viewFun_{n})$ it is possible to reorder the actions of 
an $\ET_2$-trace terminating in a configuration $(\hh_{n}, \_)$, so that the resulting trace matches 
closely the $\ET_1$-trace that we are considering, exception made for the views of the clients: 
$\ET-2$-trace of the form$(\hh_{0}, \viewFun'_{0}) \xrightarrow{(\alpha_{1})}_{\ET_1} \cdots 
\xrightarrow{(\alpha_{n})}_{\ET_2} (\hh_{n}, \viewFun'_{n})$. To ensure that we can further modify 
such an $\ET_2$-trace so that its structure matches exactly the considered $\ET_1$-trace, we 
impose further constraints on pre and post views  in execution tests.
\begin{definition}[$\ET$ properties]
%\label{def:noblidwrites}
%\label{def:et-minimum-footprint}
%\label{def:et-continuous-postview}
\label{def:et_properties}
An execution test $\ET$ has \emph{no blind writes} if
%it allows a key to be written only when it is also read;
%that is, 
for all $\hh, \vi, \vi', \opset, \ke$:\\
\indent
$
\ET \vdash (\hh, \vi) \triangleright \opset: \vi' 
\land (\otW, \ke, \_) \in \opset
\implies (\otR, \ke, \_) \in \opset
$
%\azalea{This definition of minimum footprint below doesn't make sense; it is too strong! 
%Since $\vi, \vi'$ is universally quantified, we are essentially saying for any key in the footprint, two arbitrary views must have the same versions!
%I think you mean for all $\hh$, $\vi, \vi', \vi'', \opset$:
%\[
%\begin{array}{@{} r l @{}}
%\text{if} & \ET \vdash (\hh, \vi) \triangleright \opset : \vi'' \\
%\text{and} & \fora{ \ke} (\stub, \ke, \stub) \in \f \implies \vi(\ke) = \vi'(\ke) \\
%\text{then} & \ET \vdash (\hh, \vi') \triangleright \opset : \vi''
%\end{array} 
%\]
%\sx{Yes you are right. I already change}
%}
An execution test $\ET$ has a \emph{minimum footprint} if for all kv-stores $\hh$,
views $\vi, \vi',\vi''$, and fingerprints $\f$: 
%
\[
\begin{array}{@{} r @{\hspace{3pt}} l @{}}
\text{if} & \ET \vdash (\hh, \vi) \triangleright \opset : \vi'' 
\text{ and } \fora{(\stub, \ke, \stub) \in \f}\!\! \vi(\ke) {=} \vi'(\ke) \\
%\text{and} & \fora{ \ke} (\stub, \ke, \stub) \in \f \implies \vi(\ke) = \vi'(\ke) \\
\text{then} & \ET \vdash (\hh, \vi') \triangleright \opset : \vi''
\end{array} 
\]
%

An execution test $\ET$ has \emph{monotonic post-views} if 
%it allows views to grow after committing; 
%that is, 
for all kv-stores $\hh$, 
views $\vi, \vi',\vi''$ and fingerprints $\f$:
\[
    \ET \vdash (\hh, \vi) \triangleright \opset : \vi' 
    \land \vi' \sqsubseteq \vi'' 
    \implies 
    \ET \vdash (\hh, \vi) \triangleright \opset : \vi''
\]
%if $\cl_1 \ne \cl_2$, and $\opset_1, \opset_2$ are non-conflicting,
%then for all $\hh', \viewFun, \viewFun'$:
%\[
%\begin{array}{lr}
%(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} 
%\_ \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} (\hh', \viewFun') &\implies \\
%(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} 
%\_ \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} (\hh', \viewFun')
%\end{array}
%\]
\end{definition}
The no-blind writes and minimum-footprint requirements ensure that, in any $\ET$-trace 
terminating in a configuration $(\hh, \stub)$, 
the set of views used by a client to commit a transaction is uniquely determined by $\hh$. 
If $\ET_1$ and $\ET_2$ satisfy the monotonic post-view requirement, then there exists at least one  same post-view 
that can be obtained after a client commits a fingerprint from a configuration $\Gamma$, 
using two different execution tests $\ET_1$ and $\ET_2$, respectively. 

\begin{theorem}[Compositionality]     
For all $\ET_1, \ET_2$ with no blind writes, minimum footprints and monotonic post-views, 
if $\ET_1$ is commutative then
%\begin{align*}
%	\com {\ET_1}
%	& \implies \CMs(\ET_1 \cap \ET_2) {=} \CMs(\ET_1) \cap \CMs(\ET_2)\\
%	\bigwedge_{i \in \{1, 2\}} \!\!\!\!\com{\ET_i}
%	& \implies  \com{\ET_1 \cap \ET_2}
%\end{align*}
\begin{align*}
 \CMs(\ET_1 \cap \ET_2) {=} \CMs(\ET_1) \cap \CMs(\ET_2)
\end{align*}
%If $\com{\ET_1}$, 
%then $\CMs(\ET_1 \cap \ET_2) {=} \CMs(\ET_1) \cap \CMs(\ET_2)$. 
%If $\com{\ET_1} \land \com{\ET_2}$, then $\com{\ET_1 \cap \ET_2}$.
\end{theorem}
Most of the execution tests from \cref{fig:execution_tests} can be tweaked to satisfy these 
properties, without preventing any anomalous behaviour. However, the definitions 
of $\ET_{\SI}$ and $\ET_{\CP}$ are inherently non-commutative, which also motivates 
why $\ET_{\UA} \cap \ET_{\CP}$ is not an appropriate execution test for Snapshot Isolation.
\ac{This is going to backfire. The reviewer may want to 
see an example of kv-store that is included in $\ET_{\UA} \cap \ET_{\CP}$, but not in 
$\ET_{\SI}$: I can write this at the blackboard, but somebody will need to put it in the Appendix.}

%By defintion, given a kv-store $\hh$ and an execution test $\ET$, 
%$\hh \in \CMs(\ET)$ implies that there 
%exists an $\ET-trace$ $(\hh_0, \viewFun_{0}) \xrightarrow{(\cl_1, \opset_1)}_{\ET} \cdots \xrightarrow{(\cl_n, \opset_n)}_{\ET} (\hh_n, \viewFun_{n})$ 
%with $\hh_n = \hh$. In \cref{app:compositionality} we prove that the (not ordered) multiset of actions $\{(\cl_{i}, \opset_i)\}_{i=1}^{n}$ 
%is uniquely determined by $\hh_{n}$. As a consequence, if $\hh \in \CMs(\ET_1) \cap \CMs(\ET_2)$, 
%then there exist an $\ET_1$-trace and $\ET_2$-trace whose last configuration is $\hh_{n}$, and the multi-set of 
%actions performed in the former is a permutation of the multiset of actions performed by the latter. However, 
%to ensure that $\hh_{n} \in \CMs(\ET_1) \cap \CMs(\ET_2)$ we need to ensure that each of the $\ET$-reductions

%We demonstrate that our consistency models are \emph{compositional}.
%That is, given two execution tests $\ET_1$ and $\ET_2$, the consistency model induced by their composition 
%(\ie $\CMs(\ET_1 \cap \ET_2)$) is equivalent to the composition of their two consistency models (\ie $\CMs(\ET_1) \cap \CMs(\ET_2)$), 
%provided that $\ET_1, \ET_2$ meet \emph{certain conditions}.
%These conditions are formalised in \cref{def:et_properties} below. 
%Given an execution test $\ET$, 
%the \emph{no blind writes} property ensures that $\ET$ allows a transaction to write to a key $\ke$ only if the transaction also reads from $\ke$. 
%The \emph{minimum footprint} property ensures that $\ET$ is only concerned with those keys accessed (read or written) by a transaction (\ie those keys in its fingerprint) and is thus agnostic to the keys not accessed by the transaction. 
%The \emph{monotonic post-views} ensures that $\ET$ allows client views to grow after committing a transaction. 
%The \emph{commutativity} ensures that $\ET$ allows the execution of two \emph{non-conflicting} transactions of distinct clients to be reordered. 
%Two transactions are non-conflicting if they write to disjoint set of keys; \ie their fingerprints do not contain a write operation to the same key. 
%
%Note that these properties are not too restrictive in that the execution tests of most common consistency model satisfy them. 
%In particular, with the exception of $\CP$ and $\SI$, all execution tests defined in \cref{fig:execution_tests} satisfy the four conditions in \cref{def:et_properties}. 
%Moreover, $\UA$, $\CP$ and $\SI$ execution tests satisfy all conditions but that of commutativity.
%This is because \todo.
%\sx{All execution tests in \cref{fig:execution_tests} satisfy monotonic post-view and {\color{red}can be adapted} without losing any behaviours so to satisfy no blind writes and minimum footprint.
%Yet the important property for compositionality is if it is commutative.}
%\azalea{Shale, Andrea, can you give an intuitive explanation why $\UA$, $\CP, \SI$ don't satisfy commutativity?
%    \sx{
%        Sorry, \( \UA \) is fine, but \( \CP \) and \( \SI \) are not, 
%        because \( \dagger \) and \( \ddagger \) use \( \RW_\mkvs \) in the specifications,
%        which means a read from a transaction might also affect future transactions from different clients.
%
%        Assume that two fingerprints \( \f_1 \) and \( \f_2 \) are non-conflict and views \( \vi_1 \) and \( \vi_2 \) respectively.
%        Assume that they both want to read a key \( \ke \) and the views \( i \in \vi_2(\ke) \) and \( j \in \vi_1(\ke) \) where \( i < j \).
%        If \( \f_1\) commits first, it will not affect \( \f_2 \) but if \( \f_2 \) commits first, it will introduce a new \( \RW \) for \( \vi_1 \).
%    }
%
%}
%
%
%\begin{definition}[$\ET$ properties]
%%\label{def:noblidwrites}
%%\label{def:et-minimum-footprint}
%%\label{def:et-continuous-postview}
%\label{def:et_properties}
%An execution test $\ET$ has \emph{no blind writes} if
%%it allows a key to be written only when it is also read;
%%that is, 
%for all $\hh, \vi, \vi', \opset, \ke$:\\
%\indent
%$
%\ET \vdash (\hh, \vi) \triangleright \opset: \vi' 
%\land (\otW, \ke, \_) \in \opset
%\implies (\otR, \ke, \_) \in \opset
%$
%%\azalea{This definition of minimum footprint below doesn't make sense; it is too strong! 
%%Since $\vi, \vi'$ is universally quantified, we are essentially saying for any key in the footprint, two arbitrary views must have the same versions!
%%I think you mean for all $\hh$, $\vi, \vi', \vi'', \opset$:
%%\[
%%\begin{array}{@{} r l @{}}
%%\text{if} & \ET \vdash (\hh, \vi) \triangleright \opset : \vi'' \\
%%\text{and} & \fora{ \ke} (\stub, \ke, \stub) \in \f \implies \vi(\ke) = \vi'(\ke) \\
%%\text{then} & \ET \vdash (\hh, \vi') \triangleright \opset : \vi''
%%\end{array} 
%%\]
%%\sx{Yes you are right. I already change}
%%}
%An execution test $\ET$ has a \emph{minimum footprint} if for all kv-stores $\hh$,
%views $\vi, \vi',\vi''$, and fingerprints $\f$: 
%%
%\[
%\begin{array}{@{} r @{\hspace{3pt}} l @{}}
%\text{if} & \ET \vdash (\hh, \vi) \triangleright \opset : \vi'' 
%\text{ and } \fora{(\stub, \ke, \stub) \in \f}\!\! \vi(\ke) {=} \vi'(\ke) \\
%%\text{and} & \fora{ \ke} (\stub, \ke, \stub) \in \f \implies \vi(\ke) = \vi'(\ke) \\
%\text{then} & \ET \vdash (\hh, \vi') \triangleright \opset : \vi''
%\end{array} 
%\]
%%
%
%An execution test $\ET$ has \emph{monotonic post-views} if 
%%it allows views to grow after committing; 
%%that is, 
%for all kv-stores $\hh$, 
%views $\vi, \vi',\vi''$ and fingerprints $\f$:
%\[
%    \ET \vdash (\hh, \vi) \triangleright \opset : \vi' 
%    \land \vi' \sqsubseteq \vi'' 
%    \implies 
%    \ET \vdash (\hh, \vi) \triangleright \opset : \vi''
%\]
%
%Two fingerprints $\opset_1$ and $\opset_2$ are \emph{conflicting} 
%iff there exists $\ke$ such that 
%$(\otW, \ke, -) \in \opset_1 \land (\otW, \ke, -) \in \opset_2$. 
%
%An execution test $\ET$ is \emph{commutative}, written $\com \ET$, if 
%for all views $\vi_1, \vi_2 \in \Views(\hh_0)$, 
%clients $\cl_1, \cl_2$,
%fingerprints $\opset_1, \opset_2$, 
%kv-stores $\hh'$,
%and view functions $\viewFun, \viewFun'$:
%\[
%\begin{array}{@{}r @{\hspace{10pt}} l @{}}
%	\text{if} &  
%	(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} 
%	\_ \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} (\hh', \viewFun') \\
%	& \land\ \cl_1 \ne \cl_2 \land \opset_1, \opset_2  \text{ are non-conflicting}\\
%%
%%	
%	\text{then} & (\hh_0, \viewFun) \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} 
%\_ \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} (\hh', \viewFun')
%\end{array}
%\]
%
%%if $\cl_1 \ne \cl_2$, and $\opset_1, \opset_2$ are non-conflicting,
%%then for all $\hh', \viewFun, \viewFun'$:
%%\[
%%\begin{array}{lr}
%%(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} 
%%\_ \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} (\hh', \viewFun') &\implies \\
%%(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} 
%%\_ \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} (\hh', \viewFun')
%%\end{array}
%%\]
%\end{definition}
%
%
%
%%\begin{definition}
%%Two fingerprints $\opset_1$ and $\opset_2$ are \emph{conflicting} 
%%iff there exists $\ke$ such that 
%%$(\otW, \ke, -) \in \opset_1 \land (\otW, \ke, -) \in \opset_2$. 
%%
%%Execution test is $\ET$ is \emph{commutative}, written $\com \ET$, if 
%%for all views $\vi_1, \vi_2 \in \Views(\hh_0)$, 
%%clients $\cl_1, \cl_2$,
%%fingerprints $\opset_1, \opset_2$, 
%%kv-stores $\hh'$,
%%and view functions $\viewFun, \viewFun'$:
%%\[
%%\begin{array}{@{}r @{\hspace{10pt}} l @{}}
%%	\text{if} &  
%%	(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} 
%%	\_ \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} (\hh', \viewFun') \\
%%	& \land\ \cl_1 \ne \cl_2 \land \opset_1, \opset_2  \text{ are non-conflicting}\\
%%%
%%%	
%%	\text{then} & (\hh_0, \viewFun) \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} 
%%\_ \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} (\hh', \viewFun')
%%\end{array}
%%\]
%%
%%%if $\cl_1 \ne \cl_2$, and $\opset_1, \opset_2$ are non-conflicting,
%%%then for all $\hh', \viewFun, \viewFun'$:
%%%\[
%%%\begin{array}{lr}
%%%(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} 
%%%\_ \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} (\hh', \viewFun') &\implies \\
%%%(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} 
%%%\_ \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} (\hh', \viewFun')
%%%\end{array}
%%%\]
%%\end{definition}
%
%We can now formalise our compositionality theorem below. 
%The first part states that the consistency model induced by the composition of two execution tests, is equivalent to the composition of their two consistency models.
%The second part states that composition preserves commutativity:
%if two execution tests are commutative, then their composition is also commutative. 
%The full proof of this theorem is given in the appendix (see \cref{thm:et-comm}). 
%%
%\begin{theorem}[Compositionality]     
%For all $\ET_1, \ET_2$ with no blind writes, minimum footprints and monotonic post-views: 
%\begin{align*}
%	\com {\ET_1}
%	& \implies \CMs(\ET_1 \cap \ET_2) {=} \CMs(\ET_1) \cap \CMs(\ET_2)\\
%	\bigwedge_{i \in \{1, 2\}} \!\!\!\!\com{\ET_i}
%	& \implies  \com{\ET_1 \cap \ET_2}
%\end{align*}
%%If $\com{\ET_1}$, 
%%then $\CMs(\ET_1 \cap \ET_2) {=} \CMs(\ET_1) \cap \CMs(\ET_2)$. 
%%If $\com{\ET_1} \land \com{\ET_2}$, then $\com{\ET_1 \cap \ET_2}$.
%\end{theorem}

\mypar{Relating KV-Stores and Dependency Graphs}
Dependency graphs \cite{adya-icde,adya} are perhaps the most popular 
mathematical structure serving as a basis for specifying transactional consistency models. 
%Adya \etal proposed \emph{dependency graphs} for specification of transactional consistency models~\cite{adya-icde,adya}. 
A dependency graph $\Gr$ is a directed, labelled graph where
nodes are
%with its 
%nodes representing transactions, 
%and its edges representing certain \emph{dependencies} (relations) between transactions. 
%An example dependency graph is depicted in \cref{fig:dependency-graph}. 
%each node is 
labelled with a transaction identifier and a fingerprint, and edges are labelled with a 
key-indexed label that describes the information flow of versions in a run of the database\footnote{Dependency graphs 
come equipped with a session order between transactions. In our case, the session order is embedded into the structure 
of the set of transaction identifiers.}. 
\begin{enumerate*}
	\item a \emph{read dependency} edge, $\txid_1 \xrightarrow{\WR} \txid_2$, denotes
that transaction $\txid_2$ reads a version written by $\txid_1$;
	\item a \emph{write dependency} edge, $\txid_1 \xrightarrow{\WW} \txid_2$, denotes that $\txid_2$ overwrites a version written by $\txid_1$; and 
	\item an \emph{anti-dependency} edge, $\txid_1 \xrightarrow{\RW} \txid_2$, denotes that $\txid_2$ overwrites a version read by $\txid_2$. 
\end{enumerate*}
We give the formal definition of dependency graphs in \cref{app:depgraphs}.
An example dependency graph is given in \cref{fig:dependency-graph}. 
\ac{There was a reason why I removed the initial transaction identifier $\txid_{0}$ 
from dependency graphs (and from abstract executions, for what it matters). It was 
a technical glitch. But I can't remember exactly what was it.}
Observe that we can always extract a dependency graph  $\Gr$ from a kv-store $\hh$, by choosing 
the set of transaction identifiers appearing in $\hh$ as the set of nodes of $\Gr$, and by letting the relation $\RF, \VO, \AD$ to be defined by $\RF_{\hh}, \VO_{\hh}, \AD_{\hh}$ from \cref{fig:execution_tests}, 
respectively. For example, if we apply the construction outlined above to the kv-store 
from \cref{fig:counter_kv_final}, we obtain the dependency graph from \cref{fig:dependency-graph}. 
\ac{Some glitch with values, transaction identifiers. To be corrected} 
In \cref{app:depgraphs} we show that this construction can be reversed, thus giving 
rise to the following result: 
\begin{theorem}
Dependency graphs are isomorphic to kv-stores.
\end{theorem}

Consistency models can be specified by placing some constraints on the structure of a dependency 
graphs; typically, such constraints involve checking the absence of cycles of a particular form 
in a dependency graph. We can always convert a dependency-graph based specification of 
a consistency model into an execution-test based one by simply checking that, when committing  
a transaction into a kv-store $\hh'$, no cycle disallowed by the (dependency-graph based) consistency model specification 
is introduced in the resulting kv-store\footnote{More precisely, in the dependency graph isomorphic to the resulting kv-store.}.

%\emph{Dependency graphs} are introduced by Adya to specify consistency models of transactional databases \cite{adya}. 
%They are directed graphs consisting of transactions as nodes, 
%each of which is labelled with transaction identifier and a set of read and write operations,
%and labelled edges between transactions for specifying how information flows between nodes. 
%Specifically, a transaction $\txid$ reads a version for a key $\ke$ that has been written by another transaction $\txid'$ 
%(\emph{write-read dependency} \( \WR\)), overwrites a version of $\ke$ written by $\txid'$ (\emph{write-write dependency} \( \WW \)),
%or reads a version of $\ke$ that is later overwritten by $\txid'$ (\emph{read-write anti-dependency} \( \RW \)).
%Note that here we purposely use the same names \( \WR, \WW, \RW \) as those used in key-value store,
%since there is one-to-one map between key-value stores and dependency graphs.


%Note that in \cref{sec:cm} we intentionally used relations with the same names ($\WR, \WW, \RW$) on kv-stores in \cref{fig:execution_tests} as there is a one-to-one correspondence between these relations and their corresponding dependency edges of dependency graphs. 
%In particular, there is a one-to-one correspondence between kv-stores and dependency graphs. 
%For instance, the dependency graph in \cref{fig:dependency-graph} corresponds to the kv-store in \cref{fig:execution_tests} and vice versa. 
%This is captured in \cref{thm:dependency-graph-kv-store} below, with its full proof given in the  appendix (see \cref{thm:kv2graph}). 
%%In the proof of \cref{thm:dependency-graph-kv-store}, we provide two \emph{construction functions}; one constructs a dependency graph given a kv-store; the other constructs a kv-store given a dependency graph. 
%
%Consistency models specified using dependency graphs are typically expressed by imposing constraints on the graph shape, \eg stipulating the absence of dependency cycles of certain shapes. 
%As such, given our correspondence theorem below, \emph{any} consistency model specified using dependency graphs can be lifted to an execution test on kv-stores, by lifting the constraints on dependency edges, to constraints on the corresponding relations on kv-stores. 
%In particular, the $\CP$ and $\SI$ consistency models in the literature have been specified using dependency graphs~\cite{??}. 
%In the appendix (\cref{???}) we demonstrate that the consistency models induced by the $\CP$ and $\SI$ execution tests in \cref{fig:execution_tests} are \emph{equivalent} to their dependency graph counterparts. 
%\azalea{Shale please add the appendix references and make sure I haven't left out anything.
%    \sx{will add ref.
%        To be more precise if necessary: The lift of \( \SI \) is andrea's paper, and the lift of \( \CP \) is in the appendix with the same method.
%    }
%}

%\sx{I try to remember the discussion among me, Andrea and P:
%the relation to dependency can simplify to one paragraph since it is easy to see.}



\input{\RootPath/dgraph/depend-aexec-fig.tex}

%\begin{definition}
%A \emph{dependency graph} is a quadruple $\Gr = (\TtoOp{T}, \RF, \VO, \AD)$, where
%\begin{itemize}
%\item 
%    $\TtoOp{T}_0: \TxID_0 \parfinfun \powerset{\Ops}$ is a partial finite mapping from transaction identifiers 
%    to the set of operations, where there are at most one read operation and one write operation per key;
%\item 
%    $\RF : \Keys \to \pset{\dom(\TtoOp{T}) \times \dom(\TtoOp{T})}$ is a function that 
%maps each key $\ke$ into a relation between transactions, such that for any $\txid, \txid_1, \txid_2, 
%\ke, \cl, m, n$: 
%\begin{itemize}
%\item if $(\otR, \ke, \val) \in \TtoOp{T}(\txid)$, either $\val = \val_0$ 
%and there exists no $\txid'$ such that $\txid' \xrightarrow{\RF(\ke)} \txid$,  
%or there exists $\txid'$ such that $(\otW, \ke, \val) \in \TtoOp{T}(\txid')$, and $\txid' \xrightarrow{\RF(\ke)} \txid$, 
%\item if $\txid_1 \xrightarrow{\RF(\ke)} \txid$ and $\txid_2 \xrightarrow{\RF(\ke)} \txid$, then 
%$\txid_2 = \txid_1$.
%\item if $\txid_{\cl}^{m} \xrightarrow{\RF(\ke)} \txid_{\cl}^{n}$, then $m < n$.
%\end{itemize}
%\item $\VO: \Keys \to \pset{\dom(\TtoOp{T}) \times \dom(\TtoOp{T})}$ is a function 
%that maps each key into an irreflexive relation between transactions, such that for any $\txid, \txid', \ke, \cl, m, n$, 
%\begin{itemize}
%\item if $\txid \xrightarrow{\VO(\ke)} \txid'$, then $(\otW, \ke, \_) \in \TtoOp{T}(\txid), (\otW, \ke, \_) \in \TtoOp{T}(\txid')$, 
%\item if $(\otW, \ke, \_) \in \TtoOp{T}(\txid), (\otW, \ke, \_) \in \TtoOp{T}(\txid')$, then either $\txid = \txid'$, 
%$\txid \xrightarrow{\VO(\ke)} \txid'$, or $\txid' \xrightarrow{\VO(\ke)} \txid$.
%\item if $\txid_{\cl}^{m} \xrightarrow{\WW(\ke)} \txid_{\cl}^{n}$, then $m < n$.
%\end{itemize}
%\item $\AD: \Keys \to \pset{\dom(\TtoOp{T}) \times \dom(\TtoOp{T})}$ is defined 
%by letting $\txid \xrightarrow{\AD(\ke)} \txid'$ if and only if $(\otR, \ke, \_) \in \TtoOp{T}(\txid)$, 
%$(\otW, \ke, \_) \in \TtoOp{T}(\txid')$ and 
%either there exists no $\txid''$ such that $\txid'' \xrightarrow{\RF(\ke)} \txid$, or 
%$\txid'' \xrightarrow{\RF(\ke)} \txid$, $\txid'' \xrightarrow{\VO(\ke)} \txid'$ for 
%some $\txid''$.
%\end{itemize}
%\end{definition}
%Given a dependency graph $\Gr = (\TtoOp{T}, \RF, \VO, \AD)$, we often 
%commit an abuse of notation and use $\RF$ to denote the relation 
%$\bigcup\limits_{\ke \in \Keys} \RF(\ke)$; a similar notation is adopted for $\VO, \AD$. 
%It will always be clear from the context whether the symbol $\RF$ refers to a function 
%from keys to relations, or to a relation between transactions. 
%
%We let $\Dgraphs$ be the set of all dependency graphs.
%It is always possible to convert a kv-store $\hh$ into a well-formed dependency 
%graph. For example, \cref{fig:dependency-graph} is the dependency graph 
%that illustrates scenario similar with the key-value store in \cref{fig:hheap-a}.
%
%\begin{definition}
%\label{def:main-body-kv2graph}
%Given a kv-store $\hh$, the \emph{dependency graph} $\Gr_{\hh} = (\TtoOp{T}_{\hh}, \RF_{\hh}, 
%\VO_{\hh}, \AD_{\hh})$ is defined as follows: 
%\begin{itemize}
%\item for any $\txid \neq \txid_0$, $\TtoOp{T}_{\hh}(\txid)$ is defined if and only if there exists an index $i$ and a key 
%$\ke$ such that either $\txid = \WTx(\hh(\ke, i))$, or $\txid \in \RTx(\hh(\ke,i))$; furthermore, 
%$(\otW, \ke, \val) \in \TtoOp{T}(\txid)$ if and only 
%if $\txid = \WTx(\hh(\ke, i))$ for some $i$, and 
%$(\otR, \ke, \val) \in \TtoOp{T}(\txid)$ if and only if $\txid \in \RTx(\hh(\ke, i))$ for some $i$, 
%\item $\txid \xrightarrow{\RF(\ke)} \txid'$ if and only if there exists an index $i: 0 < i < \lvert \hh(\ke) \rvert$ 
%such that $\txid = \WTx(\hh(\ke, i))$, and $\txid' \in \RTx(\hh(\ke, i))$, 
%\item $\txid \xrightarrow{\VO(\ke)} \txid'$ if and only if there exist two indexes $i,j$: $0 < i < j < \lvert \hh(\ke) \rvert$ 
%such that $\txid = \WTx(\ke, i)$, $\txid' = \WTx(\ke, j)$, 
%\item $\txid \xrightarrow{\AD(\ke)} \txid'$ if and only if there exist two indexes $i,j$: $0 < i < j < \lvert \hh(\ke) \rvert$ 
%such that $\txid \in \RTx(\ke, i)$ and $\txid' = \WTx(\ke, j)$.
%\end{itemize}
%\end{definition}

%\begin{theorem}
%\label{thm:main-body-kv2graph}
%\label{thm:dependency-graph-kv-store}
%There is a one-to-one correspondence between key-value stores and dependency graphs.
%\end{theorem}
%%\begin{proof}
%%    See \cref{thm:kv2graph} in \cref{sec:dependent-graph}.
%%\end{proof}



\mypar{Relating KV-Stores and Abstract Executions}
%\sx{
%The following is the relation between key-values and abstract executions}
As with dependency graphs, an \emph{abstract execution} graph $\aexec$~\cite{??} 
is a directed graph with its nodes representing transactions (with each node labelled with a transaction identifier and a set of (read/write) operations), 
and its edges representing certain relations between transactions. 
An example abstract execution graph is depicted in \cref{fig:abstract_execution}. 
Each node is . 
Each edge is labelled by either the \emph{visibility} ($\VIS$) or \emph{arbitration} ($\AR$) relation. 
The $\VIS$ is an irreflexive order on transactions such that $\txid_1 \xrightarrow{\VIS} \txid_2$ denotes that the effects (updates) of $\txid_1$ are visible to $\txid_2$. 
The $\AR$ is a strict total order on transactions describing the commit order:  $\txid_1 \xrightarrow{\AR} \txid_2$ denotes that $\txid_1$ commits before $\txid_2$. 
Moreover, $\AR$ contains $\VIS$ ($\VIS \subseteq \AR$) and agrees with the session order: 
if $\txid_{\cl}^{n} \xrightarrow{\AR}  \txid_{\cl}^{m}$, then $n < m$.

%\begin{definition}
%\label{def:main-body-absexec}
%\label{def:main-body-aexec}
%An abstract execution is a triple $\aexec = (\TtoOp{T}, \VIS, \AR)$, where 
%\begin{itemize}
%    \item $\TtoOp{T}: \TxID_{0} \parfinfun \powerset{\Ops}$ is a partial, 
%finite function mapping transaction identifiers to the set of operations that they perform,
%\item $\VIS \subseteq \dom(\TtoOp{T}) \times \dom(\TtoOp{T})$ is an irreflexive relation, 
%called \emph{visibility}, 
%\item $\AR \subseteq \dom(\TtoOp{T}) \times \dom(\TtoOp{T})$ is a strict, total order 
%such that $\VIS \subseteq \AR$, and whenever $\txid_{\cl}^{n} \xrightarrow{\AR} 
%\txid_{\cl}^{m}$, then $n < m$.
%\end{itemize} 
%The set of abstract executions is denoted by $\aeset$.
%\end{definition}

\azalea{OK, from here on things get a bit hairy and I don't have a clear understanding of what is going on.
Ideally, we should be able to state the two theorems (\cref{thm:main-body-et_soundness} and \cref{thm:main-body-et_complete}) intuitively, without giving the scary technical definitions. 
In my opinion, what matters here is that we have established a link between kv-stores and abstract executions. The details of how this link is constructed can be pushed to the appendix.  

I have not touched the remainder of this section.  
}
\sx{
    START
}

To specify consistency models, abstract executions constraint resolution policy \( \RP \) and the sharp of abstract execution \( \Ax \) (I believe we could even say more precise --- the minimum visibility relation, and cite andrea's concur paper).
Resolution policy determines a set of snapshot given a set of observable transactions.
Most time it is last-write-win which gives a unique single snapshot.
This corresponds to the \( \snapshot{} \) function in the semantics kv-store.
The resolution policy part we could (question?) choose to not mentioned, since it is minor and many people always assume last-write-win.

The \( \Ax = \Set{ A : \aeset \to \powerset{\TxID} \times \powerset{\TxID}} \) is a set of constraints on visibility relations, \eg \( \Ax = \Set{\lambda \aexec \ldotp \SO_\aexec,  \lambda \aexec \ldotp \VIS_\aexec;\VIS_\aexec} \) means all the abstract executions must satisfy \( \SO \subseteq \VIS , \VIS ; \VIS \subseteq \VIS \).

\begin{definition}
\label{def:aexec2graph}
Given an abstract execution $\aexec$ that satisfies the last write wins policy,
the dependency graph $\graphof(\aexec) \defeq (\TtoOp{T}_{\aexec}, \RF_{\aexec}, 
\VO_{\aexec}, \AD_{\aexec})$ is defined by letting
\begin{itemize}
\item $\txid \xrightarrow{\RF_{\aexec}(\ke)} \txid'$ if and only if 
$\txid = \max_{\AR_{\aexec}}(\visibleWrites_{\aexec}(\ke, \txid'))$, 
\item $\txid \xrightarrow{\VO_{\aexec}(\ke)} \txid'$ if and only 
$\txid, \txid' \in_{\aexec} (\otW, \;\ke: \_)$ 
and $\txid \xrightarrow{\AR_{\aexec}} \txid'$,
\item $\txid \xrightarrow{\AD_{\aexec}(\ke)} \txid'$ if and only if either 
$(\otR, \ke, \_) \in_{\aexec} \txid, (\otW, \ke, \_) \in_{\aexec} \txid'$ and 
whenever $\txid'' \xrightarrow{\RF_{\aexec}(\ke)} \txid$, 
then $\txid'' \xrightarrow{\VO_{\aexec}(\ke)} \txid'$.
\end{itemize}
\end{definition}
Note that each abstract execution $\aexec$ determines a key-value store $\hh_{\aexec}$,
as a result of \cref{def:aexec2graph} and \cref{thm:kv2graph}. 
Let $\hh$ be the unique kv-store such that $\Gr_{\hh} = \graphof(\aexec)$, then $\hh_{\aexec} = \hh$. 

A kv-store \( \mkvs \) is compatible with an abstract execution \( \aexec \)
There is a mapping from 
\begin{definition}
\label{def:compatible-main-body}
Given a key-value store $\hh$,
an abstract execution $\aexec$ is compatible with $\hh$, written 
$\aexec \compatible \hh$, if and only if there exists a  mapping 
$f: \powerset{\T_{\aexec}} \rightarrow \Views(\hh)$
such that  
\begin{itemize}
\item for any subset $\T \subseteq \T_{\aexec}$, then $\RP_{\LWW}(\aexec, \T) = \{\snapshot(\hh, f(\T))\}$; 
\item for any view $\vi \in \Views(\hh)$, there exists a subset $\T \subseteq \T_{\aexec}$ 
such that $f(\T) = \vi$, and $\RP_{\LWW}(\aexec, \T) = \{\snapshot(\hh_{\aexec}, \vi)\}$.
\end{itemize}
\end{definition}
The function $\getView(\aexec, \T)$ defines the view on \( \mkvs_\aexec \) that corresponds to \( \T \) as the following:
\[
\getView(\aexec, \T) \defeq \lambda \ke. \{0\} \cup \Setcon{ i }{\WTx(\hh_{\aexec}(\ke, i)) \in \T}
\]
Inversely, the function \( \Tx(\hh, \vi) \) converts a view to a set of observable transactions:
\[
\Tx(\hh, \vi) \defeq \Setcon{ \WTx(\hh(\ke, i)) }{ \ke \in \Keys \wedge i \in \vi(\ke) }
\]
Given \( \getView \), \( \Tx \), \cref{def:compatible}, 
it follows \( \aexec \compatible \hh_{\aexec} \) shown in \cref{thm:aexec2kv.compatible}.

Given a trace with the final kv-store \( \mkvs \), there an abstract execution \( \aexec \) that is compatible with \( \mkvs \).
First, all transactions in an abstract execution are totally ordered by \( \AR \),
therefore an abstract execution by itself is a trace.
The reduction order of a trace of kv-store maps to the \( \AR \) in the abstract execution and vice versa.
The challenge is to show that
for each transaction \( \txid \) in the trace and the initial view \( \vi \) of the transaction, the visible transitions \( \Tx(\hh, \vi) \) contains at least those transactions by the constraints \( \Ax \), \ie
Note that \( \Tx(\hh, \vi) \) do not contain any read-only transactions, 
thus to be more precise, we mean \( \Tx(\hh, \vi) \) plus some potentially read-only transactions contains those by the constraints \( \Ax \), \ie
\( \fora{\A\in \Ax, \txid'} (\txid', \txid) \in \A(\aexec) \implies \txid' \in \Tx(\hh, \vi) \lor \txid' \text{is read only} \).

Given an abstract execution \( \aexec \) there is a trace of kv-store with the final kv-store \( \mkvs \) that is compatible.
Similarly, the \( \AR \) decides the reduction order in the trace.
The challenge here is that
for each transaction \( \txid \) with fingerprint \( \f \) in the abstract execution,
(We should mentioned a node in the graph is the fingerprint)
We find two views, the initial \( \vi \) and the final \( \vi' \), so \( \ET \vdash (\mkvs, \vi) \csat \f : \vi' \) where the \( \mkvs \) is the kv-store when \( \txid \) commits.
The initial view \( \vi \) includes all versions written by visible transactions of \( \txid \) from the abstract execution, \ie \( \vi = \getView(\aexec, \VIS_\aexec^{-1}(\txid)) \).
Since \( \vi' \) gives the minimum views for the next transactions from the same clients,
it can be computed by including all versions, if exists in \( \mkvs \), written by visible transactions of \( \txid' \) where \( \txid' \toEdge{\SO} \txid \).

\sx{
    END
}

A semantics under \( \aexec \), where transaction satisfies the specification in the form of \( (\RP,\Ax) \).
\( \RP \) is a function takes a set of transactions \( \T \) from abstract execution \( \aexec \), 
and returns  a set of possible snapshots.
A common one is last-write-win.

\begin{definition}
\label{def:lww}
The Last Write Wins resolution policy $\RP_{\LWW}$ is defined as 
$\RP_{\LWW}(\aexec, \T) \defeq \{\h\}$ where
\begin{align*}
    \h & \defeq \lambda \ke. \text{let} \ \T_{\ke} = ( \T \cap \{\txid \mid (\otW,\ke, \_) \in_{\aexec} \txid\}) \\
       & \quad \text{in} \
\begin{cases}
\val_{0} &\impliedby \T_{\ke} =  \emptyset\\
\val &\impliedby (\otW, \ke, \val) \in_{\aexec} \max_{\AR_{\aexec}}(\T_{\ke})
\end{cases}
\end{align*}
\end{definition}

\( \Ax \) is a set of constraints on the shape of the abstract execution,
which defines the minimum visibility relation.
For example, the minimum visibility for serialisability is a singleton set
\( \Ax_\SER = \Set{\lambda \aexec \ldotp \AR_\aexec } \),
which means the minimum visibility should contain the arbitration \( \AR_\aexec \subseteq \VIS_\aexec \).
In general, if an abstract execution \( \aexec \) satisfies a set of constraints  \( \Ax \),
if \( \fora{\A \in \Ax} \A(\aexec) \subseteq \VIS_\aexec \).

Through the dependency graph, we can relate key-value stores and abstract executions (\cref{def:main-body-aexec2graph}).
Note that each abstract execution $\aexec$ determines a key-value store 
$\hh_{\aexec}$, as per \cref{def:main-body-aexec2graph} and \cref{thm:main-body-kv2graph}. 

\begin{definition}
\label{def:main-body-aexec2graph}
Given an abstract execution $\aexec$ that satisfies the last write wins policy,
the dependency graph $\graphof(\aexec) \defeq (\TtoOp{T}_{\aexec}, \RF_{\aexec}, 
\VO_{\aexec}, \AD_{\aexec})$ is defined by letting
\begin{itemize}
\item $\txid \xrightarrow{\RF_{\aexec}(\ke)} \txid'$ if and only if 
    $\txid = \max_{\AR_{\aexec}}\left( \Setcon{\txid}{(\otW,\ke,\stub) \in \txid' \land \txid' \toEdge{\VIS_\aexec} \txid } \right)$, 
\item $\txid \xrightarrow{\VO_{\aexec}(\ke)} \txid'$ if and only 
$\txid, \txid' \in_{\aexec} (\otW, \;\ke: \_)$ 
and $\txid \xrightarrow{\AR_{\aexec}} \txid'$,
\item $\txid \xrightarrow{\AD_{\aexec}(\ke)} \txid'$ if and only if either 
$(\otR, \ke, \_) \in_{\aexec} \txid, (\otW, \ke, \_) \in_{\aexec} \txid'$ and 
whenever $\txid'' \xrightarrow{\RF_{\aexec}(\ke)} \txid$, 
then $\txid'' \xrightarrow{\VO_{\aexec}(\ke)} \txid'$.
\end{itemize}
\end{definition}

Let $\hh$ be the unique kv-store such that $\Gr_{\hh} = \graphof(\aexec)$: then 
$\hh_{\aexec} = \hh$. 
Yet this mapping $\hh_{(\stub)}$ is not a bijection, 
in that several abstract executions may be encoded in the same key-value store. 
This is because key-value stores abstract away the total arbitration order of transactions.

\sx{
    explain \( \Tx(\mkvs,\vi) \) and intuition of invariant \( I \):
    \( \Tx(\mkvs,\vi) \) includes all the writers of the versions \( \mkvs(\ke, i)\), 
    where these versions are included in the view \( i \in \vi(\ke)\).
    In abstract executions, there is  no explicit \( \SO \) relation 
    but \( \VIS \) and \( \AR \) relations.
    The invariant \( I(\aexec, \cl) \) is for carrying information 
    for transactions from the client \( \cl \).
}

\begin{definition}
\label{def:main-body-et_sound}
An execution test $\ET$ is sound with respect to an axiomatic 
specification $(\RP_{\LWW}, \Ax)$ if and only if there exists an 
invariant condition $I$ such that whenever $\ET \vdash (\hh, \vi) 
\triangleright \opset: \vi'$, for any $\aexec$ such that 
$\hh_{\aexec} = \hh$, for any client $\cl$, for any 
transaction identifier $\txid \in \nextTxId(\hh, \cl)$, 
such that  $I(\aexec, \cl) \subseteq \Tx(\hh, \vi)$, then  
there exist two other sets of transactions $\T_{\rd}$, 
such that 
\begin{itemize}
\item $\forall \A \in \Ax. \Setcon{\txid' }{ (\txid', \txid) \in \A(\aexec')} \subseteq \Tx(\hh, \vi) \cup \T_{\rd}$, 
\item $I(\aexec', \cl) \subseteq \Tx(\mkvs_{\aexec'}, \vi')$
\end{itemize}
\end{definition}

\sx{
    Abuse of notation: 
    \( \CMa(\RP_{\LWW}, \Ax) \), all possible abstract executions produced by the specification \( (\RP_{\LWW}, \Ax) \).
}
\begin{theorem}
\label{thm:main-body-et_soundness}
If $\ET$ is sound with respect to $(\RP_{\LWW}, \Ax)$, then 
\[
    \CMs(\ET) \subseteq \{ \hh \mid \exists \aexec \in \CMa(\RP_{\LWW}, \Ax)).\;\hh_{\aexec} = \hh\}
\].
\end{theorem}
\begin{proof}
    See \cref{thm:et_soundness} in \cref{sec:kv2aexec-sound-complete}.
\end{proof}

\sx{explain \( \getView\):
    It can be seen as the inverse of \( \Tx \).
    Assume the key-value store \( \mkvs \) and  abstract execution \( \aexec \)  are compatible,
    ie\( \mkvs = \mkvs_\aexec \).
    For any version \( \mkvs(\ke,i)\) and its writer \( \txid = \WTx(\mkvs(\ke,i)) \),
    if \( \txid \) is visible by \( \txid' \) in the \( \aexec \),
    then the view of \( \txid' \) before commit contains the version \( \mkvs(\ke,i) \),
    that is \( i \in \getView(\aexec, \VIS^{-1}(\txid'))(\ke) \).
}

\begin{definition}
\label{def:main-body-et_complete}
An execution test $\ET$ is \emph{complete} with respect 
to an axiomatic specification $(\RP_{\LWW}, \Ax)$ if, for any 
abstract execution $\aexec \in \CMa(\RP_{\LWW}, \Ax)$ 
such that $\AR_{\aexec} = \{(\txid_{i}, \txid_{i+1})\}_{i=1}^{\lvert \T_{\aexec} \rvert - 1}$, 
and for any $i=1,\cdots, n$, there exist two views $\vi_{i}, \vi_{i}'$ such that 
\begin{itemize}
\item $\vi_{i} = \getView(\aexec, \VIS_{\aexec}^{-1}(\txid_{i}))$, 
\item let $\txid_{i} = \txid_{\cl}^{n}$ for some $\cl, n$; if the
transaction $\txid_{i}' = \min_{\PO_{\aexec}}\{\txid' \mid \txid_i \xrightarrow{\PO_{\aexec}} \txid'\}$  
is defined, then $\vi' = \getView(\aexec, \T_{i})$, where $\T_{i} \subseteq (\AR_{\aexec}^{-1})?(\txid_{i}) \cap \VIS_{\aexec}^{-1}(\txid_{i}'))$; 
otherwise $\vi' = \getView(\aexec, \T_{i})$, where $\T_{i} \subseteq (\AR_{\aexec}^{-1})?(\txid_{i})$, 
\item $\ET \vdash (\hh_{\cut(\aexec, i-1)}, \vi_{i}) \triangleright \TtoOp{T}_{\aexec}(\txid_{i}) : \vi_{i}'$.
\end{itemize}
\end{definition}

\begin{theorem}
\label{thm:main-body-et_complete}
Let $\ET$ be an execution test that is complete with respect to 
an axiomatic specification $(\RP_{\LWW}, \Ax)$. Then 
$\CMa(\RP_{\LWW}, \Ax) \subseteq \CMs(\ET)$.
\end{theorem}
\begin{proof}
    See \cref{thm:et_complete} in \cref{sec:kv2aexec-sound-complete}.
\end{proof}

Given above, we have proven the specification in \cref{sec:spec-proof}.

