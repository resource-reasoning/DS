\newcommand{\execs}{\ensuremath{\mathsf{Execs}}}

\section{KV-Stores and Other Formalisms}
\label{sec:other_formalisms}

We give a formal account of the properties enjoyed by our operational 
semantics. 
First we investigate the compositionality of consistency models 
induced by execution tests. Then we discuss how kv-stores and execution 
tests relate to existing declarative formalisms for specifying  
consistency models, based on dependency graphs \cite{adya} 
and abstract executions \cite{framework-concur}. 
We give a main overview of our results here, and refer the reader to the 
appendix for more details.

\mypar{Compositionality}
We examine the \emph{compositionality} of the  consistency models induced by execution tests:  
\ie given two execution tests $\ET_1, \ET_2$, does 
$\CMs(\ET_1 \cap \ET_2) = \CMs(\ET_1) \cap \CMs(\ET_2)$ hold? 
It is straightforward to show that the left-to-right direction holds: for all $\ET_1, \ET_2$, \( \CMs(\ET_1 \cap \ET_2) \subseteq \CMs(\ET_1) \cap \CMs(\ET_2) \) 
However, the other direction \( \CMs(\ET_1) \cap \CMs(\ET_2) \subseteq \CMs(\ET_1 \cap \ET_2) \) does not hold for arbitrary consistency models.
Consider the following:
\[
\small
\begin{array}{@{}l @{\hspace{2pt}} | @{\hspace{2pt}} l@{}}
    \hline
    \ET_1 & \ET_2 \\
%    
    \hline
    (\hh_{0}, \vi_{0}) \csat\! \{(\otW, \ke, 1)\} {:} ( \hh_{\ke}, \vi_{0})
    &
    (\hh_{0}, \vi_{0}) \csat\! \{(\otW, \ke', 1)\} {:} ( \hh_{\ke'}, \vi_{0}) 
    \vspace{-5pt}\\\\
% %   
    (\hh_{\ke}, \vi_{0}) \csat  \!\{(\otW, \ke', 1)\} {:} (\hh',\vi_{0}) 
    &
    (\hh_{\ke'}, \vi_{0}) \csat \!\{(\otW, \ke, 1)\} {:} (\hh',\vi_{1}) 
    \\
\hline
\end{array}
\]
with 
\begin{align*}
    \hh_{\ke} & = \hh_{0}[\ke \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \_, \emptyset)] \\
    \hh_{\ke'} & = \hh_{0}[\ke' \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \_, \emptyset)] \\
    \hh' & = \hh[\ke \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \_, \emptyset) 
                ,\ke' \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \_, \emptyset)] \\
\end{align*}
As both $\ET_1$ and $\ET_2$ allow a version with value $1$ to be written for 
$\ke, \ke'$,  we have $\hh' \in \CMs(\ET_1) \cap \CMs(\ET_2)$. 
However, $\ET_1$ and $\ET_2$ enforce a different order in which the updates on $\ke, \ke'$ must happen; 
thus $\hh' \notin \CMs(\ET_1 \cap \ET_2)$. 

In this example, compositionality fails because execution tests 
enforced a particular order in which the updates must be committed, even though such updates 
are non-conflicting: \ie the kv-store obtained after committing such updates is independent of the commit order. This observation is captures in the following definition: 
\begin{definition}
Two fingerprints $\opset_1$ and $\opset_2$ are \emph{conflicting} 
iff there exists $\ke$ such that 
$(\otW, \ke, -) \in \opset_1 \land (\otW, \ke, -) \in \opset_2$. 

An execution test $\ET$ is \emph{commutative}, written $\com{\ET}$, if 
for all views $\vi_1, \vi_2 \in \Views(\hh_0)$, 
clients $\cl_1, \cl_2$,
fingerprints $\opset_1, \opset_2$, 
kv-stores $\hh'$,
and view functions $\viewFun, \viewFun'$:
\[
\begin{array}{@{}r @{\hspace{10pt}} l @{}}
	\text{if} &  
	(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} 
	\_ \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} (\hh', \viewFun') \\
	& \land\ \cl_1 \ne \cl_2 \land \opset_1, \opset_2  \text{ are non-conflicting}\\
%
%	
	\text{then} & (\hh_0, \viewFun) \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} 
\_ \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} (\hh', \viewFun')
\end{array}
\]
\end{definition}

Commutativity is a necessary, but not sufficient condition for recovering
the desired compositionality result.
To recover compositionality, we further require that an execution test have \emph{no blind writes}, 
\emph{minimal footprint} and \emph{monotonic post-view} (\cref{def:et_properties}).
We refer the reader to \cref{sec:counter-examples-composition} for counter examples demonstrating why these conditions are necessary.


\begin{definition}[$\ET$ properties]
\label{def:et_properties}
An execution test $\ET$ has \emph{no blind writes} if
for all $\hh, \hh', \vi, \vi', \opset, \ke$:
\[
\begin{array}{@{} r @{\hspace{10pt}} l @{}}
\text{if} & \ET \vdash (\hh, \vi) \triangleright \opset: (\hh',\vi' ) 
\text{and} (\otW, \ke, \_) \in \opset \\
\text{then} & (\otR, \ke, \_) \in \opset
\end{array} 
\]
An execution test $\ET$ has a \emph{minimum footprint} if for all kv-stores $\hh, \hh'$,
views $\vi, \vi',\vi''$, and fingerprints $\f$: 
%
\[
\begin{array}{@{} r @{\hspace{10pt}} l @{}}
    \text{if} & \ET \vdash (\hh, \vi) \triangleright \opset : (\hh', \vi'')  \\
    \text{and} & \fora{(\stub, \ke, \stub) \in \f} \vi(\ke) {=} \vi'(\ke) \\
    \text{then} & \ET \vdash (\hh, \vi') \triangleright \opset : (\hh', \vi'')
\end{array} 
\]
%
An execution test $\ET$ has \emph{monotonic post-views} if 
for all kv-stores $\hh,\hh'$, 
views $\vi, \vi',\vi''$ and fingerprints $\f$:
\[
\begin{array}{@{} r @{\hspace{10pt}} l @{}}
    \text{if} & \ET \vdash (\hh, \vi) \triangleright \opset : (\hh',\vi' )
    \text{ and } \vi' \sqsubseteq \vi''  \\
    \text{then} & \ET \vdash (\hh, \vi) \triangleright \opset : (\hh',\vi'')
\end{array} 
\]
\end{definition}
The first two requirements ensure that, in an $\ET$-trace 
terminates in a configuration $(\hh, \stub)$, 
the set of client views used to commit a transaction can uniquely determined by $\hh$. 
If $\ET_1, \ET_2$ have monotonic post-views, then there exists at least one common post-view 
that can be obtained after a client commits $\f$ to $(\hh, \vi)$ using $\ET_1$ and $\ET_2$. 

\begin{theorem}[Compositionality]     
For all $\ET_1, \ET_2$ with no blind writes, minimum footprints and monotonic post-views: 
if $\com{\ET_1}$, 
then $\CMs(\ET_1 \cap \ET_2) {=} \CMs(\ET_1) \cap \CMs(\ET_2)$;
if $\com{\ET_1} \land \com{\ET_2}$, then $\com{\ET_1 \cap \ET_2}$.
\end{theorem}

Most of the execution tests in \cref{fig:execution_tests} can be minimally adapted to satisfy these 
properties, without excluding any anomalous (weak) behaviour. However, the definitions 
of $\ET_{\SI}$ and $\ET_{\CP}$ are inherently non-commutative (counter example in \cref{sec:comm-counter-cp-si}), which also motivates 
why $\ET_{\UA} \cap \ET_{\CP}$ is not an appropriate execution test for Snapshot Isolation.

\mypar{Relating KV-Stores and Dependency Graphs}
Dependency graphs \cite{adya-icde,adya} are perhaps the most popular 
formalism used for specifying transactional consistency models. 
A dependency graph $\Gr$ is a directed, labelled graph where its
nodes denote transactions and its edges denote certain \emph{dependencies} between transactions.  
An example dependency graph is given in \cref{fig:dependency-graph}.
Each node is labelled with a transaction identifier and a fingerprint.
Each edges is labelled with metadata describing the information flow in a run of the database%
\footnote{Dependency graphs additionally record a session order between transactions, corresponding to our session order $\SO$ in \cref{subsec:kvstores}.}:
\begin{enumerate*}
	\item a \emph{read dependency} edge, $\txid_1 \xrightarrow{\WR} \txid_2$, denotes
that transaction $\txid_2$ reads a version written by $\txid_1$;
	\item a \emph{write dependency} edge, $\txid_1 \xrightarrow{\WW} \txid_2$, denotes that $\txid_2$ overwrites a version written by $\txid_1$; and 
	\item an \emph{anti-dependency} edge, $\txid_1 \xrightarrow{\RW} \txid_2$, denotes that $\txid_2$ overwrites a version read by $\txid_2$. 
\end{enumerate*}
We give the formal definition of dependency graphs in \cref{app:depgraphs}.
Observe that we can always \emph{extract} a dependency graph  $\Gr$ from a kv-store $\hh$:
we choose the transaction identifiers appearing in $\hh$ as the nodes of $\Gr$, 
and let $\RF, \VO, \AD$  $\RF_{\hh}, \VO_{\hh}, \AD_{\hh}$ be as defined in \cref{fig:execution_tests}.
For example, \cref{fig:counter_kv_final} corresponds to the dependency graph extracted from the kv-store in \cref{fig:counter_kv_final}.
In \cref{app:depgraphs} we show that this construction can be reversed, thus giving 
rise to the following result: 
\begin{theorem}
\label{thm:kv_graph_isomorph}
Dependency graphs are isomorphic to kv-stores.
\end{theorem}

Using dependency graphs, consistency models are specified by constraining the shape of the graph; typically, such constraints mandate the absence of certain cycles. For example, strict serialisability is defined as those dependency graphs where $(\SO \cup \WW \cup \WR \cup \RW)^+$ is acyclic. 
We can always convert a dependency graph-based specification into an execution test-based one by simply checking that, when committing a transaction to kv-store $\hh$ and obtaining $\hh'$, 
the dependency graph extracted from $\hh'$ contains no cycles prohibited by the dependency graph-based specification. 

\begin{figure*}[t]
\begin{center}
\begin{halfsubfig} 
\begin{center}
\begin{tikzpicture}[scale=0.85, every node/.style={transform shape}]

\node(t0wx) at (-1,2) {$(\otW, \ke_1, \val_0)$}; 
\path (t0wx.east) + (1,0) node (t0wy) {$(\otW, \ke_2, \val'_0)$};
\path (t0wx.north east) + (2.5,0.5) node[anchor = west] (t1ry) {$(\otR, \ke_2, \val'_0)$}; 
\path (t1ry.east) + (0.2,0) node[anchor = west] (t1wx) {$(\otW, \ke_1, \val_1)$};
\path (t0wx.south east) + (2.5,-0.5) node[anchor = west] (t2rx) {$(\otR, \ke_1, \val_0)$};
\path (t2rx.east) + (0.2,0) node[anchor = west] (t2wy) {$(\otW, \ke_2, \val'_1$)};

\begin{pgfonlayer}{background}
\node[background, fit=(t0wx) (t0wy),inner ysep=3pt, inner xsep=6pt] (t0) {};
\node[background, fit= (t1ry) (t1wx),inner ysep=3pt, inner xsep=6pt] (t1) {};
\node[background, fit= (t2rx) (t2wy),inner ysep=3pt, inner xsep=6pt] (t2) {};

\path(t0.west) node[anchor=east] (t0lbl) {$\txid_0$};
\path(t1.north) node[anchor=south] (t1lbl) {$\txid_1$};
\path(t2.south) node[anchor=north] (t2lbl) {$\txid_2$};

\path[->]
(t0.north) edge[bend left=30] node[above, yshift=3pt, xshift=-20pt, pos=0.3] {$\RF, \VO$} (t1.west)
(t0.south) edge[bend right=30] node[below, yshift=-3pt, xshift=-20pt, pos=0.3] {$\RF, \VO$} (t2.west)
([xshift=-8pt]t2.north) edge[bend left=20] node[left] {$\AD$} ([xshift=-8pt]t1.south) 
([xshift=8pt]t1.south) edge[bend left=20] node[right] {$\AD$} ([xshift=8pt]t2.north);
\end{pgfonlayer}

\end{tikzpicture}
\end{center}
\vspace*{-10pt}
\caption{Dependency graph}
\label{fig:dependency-graph}
\end{halfsubfig} 
%
\begin{halfsubfig} 
\begin{center}
\begin{tikzpicture}[scale=0.85, every node/.style={transform shape}]

\node(t0wx) at (-1,2) {$(\otW, \ke_1, \val_0)$}; 
\path (t0wx.east) + (1,0) node (t0wy) {$(\otW, \ke_2, \val'_0)$};
\path (t0wx.north east) + (2.5,0.5) node[anchor = west] (t1ry) {$(\otR, \ke_2, \val'_0)$}; 
\path (t1ry.east) + (0.2,0) node[anchor = west] (t1wx) {$(\otW, \ke_1, \val_1)$};
\path (t0wx.south east) + (2.5,-0.5) node[anchor = west] (t2rx) {$(\otR, \ke_1, \val_0)$};
\path (t2rx.east) + (0.2,0) node[anchor = west] (t2wy) {$(\otW, \ke_2, \val'_1$)};

\begin{pgfonlayer}{background}
\node[background, fit=(t0wx) (t0wy),inner ysep=3pt, inner xsep=6pt] (t0) {};
\node[background, fit= (t1ry) (t1wx),inner ysep=3pt, inner xsep=6pt] (t1) {};
\node[background, fit= (t2rx) (t2wy),inner ysep=3pt, inner xsep=6pt] (t2) {};

\path(t0.west) node[anchor=east] (t0lbl) {$\txid_0$};
\path(t1.north) node[anchor=south] (t1lbl) {$\txid_1$};
\path(t2.south) node[anchor=north] (t2lbl) {$\txid_2$};

\path[->]
(t0.north) edge[bend left=30] node[above, yshift=3pt, xshift=-20pt, pos=0.3] {$\VIS, \AR$} (t1.west)
(t0.south) edge[bend right=30] node[below, yshift=-3pt, xshift=-20pt, pos=0.3] {$\VIS, \AR$} (t2.west)
([xshift=8pt]t1.south) edge[bend left=20] node[right] {$\AR$} ([xshift=8pt]t2.north);
\end{pgfonlayer}

\end{tikzpicture}
\end{center}
\vspace*{-10pt}
\caption{Abstract execution graph}
\label{fig:abstract_execution}
\end{halfsubfig} 
\end{center}
\hrulefill
\captionsetup{width=\linewidth}
\caption{The dependency graph (\subref{fig:dependency-graph}) and abstract execution graph (\subref{fig:abstract_execution}) associated with the kv-store in \cref{fig:ser-disallowed}
}
\end{figure*}

%\begin{definition}
%A \emph{dependency graph} is a quadruple $\Gr = (\TtoOp{T}, \RF, \VO, \AD)$, where
%\begin{itemize}
%\item 
%    $\TtoOp{T}_0: \TxID_0 \parfinfun \powerset{\Ops}$ is a partial finite mapping from transaction identifiers 
%    to the set of operations, where there are at most one read operation and one write operation per key;
%\item 
%    $\RF : \Keys \to \pset{\dom(\TtoOp{T}) \times \dom(\TtoOp{T})}$ is a function that 
%maps each key $\ke$ into a relation between transactions, such that for any $\txid, \txid_1, \txid_2, 
%\ke, \cl, m, n$: 
%\begin{itemize}
%\item if $(\otR, \ke, \val) \in \TtoOp{T}(\txid)$, either $\val = \val_0$ 
%and there exists no $\txid'$ such that $\txid' \xrightarrow{\RF(\ke)} \txid$,  
%or there exists $\txid'$ such that $(\otW, \ke, \val) \in \TtoOp{T}(\txid')$, and $\txid' \xrightarrow{\RF(\ke)} \txid$, 
%\item if $\txid_1 \xrightarrow{\RF(\ke)} \txid$ and $\txid_2 \xrightarrow{\RF(\ke)} \txid$, then 
%$\txid_2 = \txid_1$.
%\item if $\txid_{\cl}^{m} \xrightarrow{\RF(\ke)} \txid_{\cl}^{n}$, then $m < n$.
%\end{itemize}
%\item $\VO: \Keys \to \pset{\dom(\TtoOp{T}) \times \dom(\TtoOp{T})}$ is a function 
%that maps each key into an irreflexive relation between transactions, such that for any $\txid, \txid', \ke, \cl, m, n$, 
%\begin{itemize}
%\item if $\txid \xrightarrow{\VO(\ke)} \txid'$, then $(\otW, \ke, \_) \in \TtoOp{T}(\txid), (\otW, \ke, \_) \in \TtoOp{T}(\txid')$, 
%\item if $(\otW, \ke, \_) \in \TtoOp{T}(\txid), (\otW, \ke, \_) \in \TtoOp{T}(\txid')$, then either $\txid = \txid'$, 
%$\txid \xrightarrow{\VO(\ke)} \txid'$, or $\txid' \xrightarrow{\VO(\ke)} \txid$.
%\item if $\txid_{\cl}^{m} \xrightarrow{\WW(\ke)} \txid_{\cl}^{n}$, then $m < n$.
%\end{itemize}
%\item $\AD: \Keys \to \pset{\dom(\TtoOp{T}) \times \dom(\TtoOp{T})}$ is defined 
%by letting $\txid \xrightarrow{\AD(\ke)} \txid'$ if and only if $(\otR, \ke, \_) \in \TtoOp{T}(\txid)$, 
%$(\otW, \ke, \_) \in \TtoOp{T}(\txid')$ and 
%either there exists no $\txid''$ such that $\txid'' \xrightarrow{\RF(\ke)} \txid$, or 
%$\txid'' \xrightarrow{\RF(\ke)} \txid$, $\txid'' \xrightarrow{\VO(\ke)} \txid'$ for 
%some $\txid''$.
%\end{itemize}
%\end{definition}
%Given a dependency graph $\Gr = (\TtoOp{T}, \RF, \VO, \AD)$, we often 
%commit an abuse of notation and use $\RF$ to denote the relation 
%$\bigcup\limits_{\ke \in \Keys} \RF(\ke)$; a similar notation is adopted for $\VO, \AD$. 
%It will always be clear from the context whether the symbol $\RF$ refers to a function 
%from keys to relations, or to a relation between transactions. 
%
%We let $\Dgraphs$ be the set of all dependency graphs.
%It is always possible to convert a kv-store $\hh$ into a well-formed dependency 
%graph. For example, \cref{fig:dependency-graph} is the dependency graph 
%that illustrates scenario similar with the key-value store in \cref{fig:hheap-a}.
%
%\begin{definition}
%\label{def:main-body-kv2graph}
%Given a kv-store $\hh$, the \emph{dependency graph} $\Gr_{\hh} = (\TtoOp{T}_{\hh}, \RF_{\hh}, 
%\VO_{\hh}, \AD_{\hh})$ is defined as follows: 
%\begin{itemize}
%\item for any $\txid \neq \txid_0$, $\TtoOp{T}_{\hh}(\txid)$ is defined if and only if there exists an index $i$ and a key 
%$\ke$ such that either $\txid = \WTx(\hh(\ke, i))$, or $\txid \in \RTx(\hh(\ke,i))$; furthermore, 
%$(\otW, \ke, \val) \in \TtoOp{T}(\txid)$ if and only 
%if $\txid = \WTx(\hh(\ke, i))$ for some $i$, and 
%$(\otR, \ke, \val) \in \TtoOp{T}(\txid)$ if and only if $\txid \in \RTx(\hh(\ke, i))$ for some $i$, 
%\item $\txid \xrightarrow{\RF(\ke)} \txid'$ if and only if there exists an index $i: 0 < i < \lvert \hh(\ke) \rvert$ 
%such that $\txid = \WTx(\hh(\ke, i))$, and $\txid' \in \RTx(\hh(\ke, i))$, 
%\item $\txid \xrightarrow{\VO(\ke)} \txid'$ if and only if there exist two indexes $i,j$: $0 < i < j < \lvert \hh(\ke) \rvert$ 
%such that $\txid = \WTx(\ke, i)$, $\txid' = \WTx(\ke, j)$, 
%\item $\txid \xrightarrow{\AD(\ke)} \txid'$ if and only if there exist two indexes $i,j$: $0 < i < j < \lvert \hh(\ke) \rvert$ 
%such that $\txid \in \RTx(\ke, i)$ and $\txid' = \WTx(\ke, j)$.
%\end{itemize}
%\end{definition}

%\begin{theorem}
%\label{thm:main-body-kv2graph}
%\label{thm:dependency-graph-kv-store}
%There is a one-to-one correspondence between key-value stores and dependency graphs.
%\end{theorem}
%%\begin{proof}
%%    See \cref{thm:kv2graph} in \cref{sec:dependent-graph}.
%%\end{proof}
%\subsection{Azalea's Version}
\mypar{Relating KV-Stores and Abstract Executions}
\emph{Abstract executions} \cite{ev_transactions,framework-concur} are an alternative formalism for specifying consistency models. 
As with dependency graphs, an abstract execution graph $\aexec$
is a directed graph with its nodes representing transactions (with each node labelled with a transaction identifier and a set of (read/write) operations), 
and its edges representing certain relations between transactions. 
An example abstract execution graph is depicted in \cref{fig:abstract_execution}. 
Each edge is labelled by either the \emph{visibility} ($\VIS$) or \emph{arbitration} ($\AR$) relation. 
The $\VIS$ is an irreflexive order on transactions such that $\txid_1 \xrightarrow{\VIS} \txid_2$ denotes that the effects (updates) of $\txid_1$ are visible to $\txid_2$. 
The $\AR$ is a strict total order on transactions such that $\txid_1 \xrightarrow{\AR} \txid_2$ denotes that the updates performed by $\txid_2$ are newer than those of $\txid_1$. 
Moreover, $\AR$ contains $\VIS$ ($\VIS \subseteq \AR$) and agrees with the session order.
Lastly, abstract executions observe the \emph{last-write-wins} policy: 
a transaction reading $\ke$ always fetches the latest visible write ($\VIS$ predecessor) on $\ke$.

Following \cite{laws}, we can always \emph{extract} a dependency graph $\Gr_{\aexec}$ from an abstract execution $\aexec$, and thus a kv-store $\hh_{\aexec}$ via \cref{thm:kv_graph_isomorph}---see \cref{app:aexec2kv} for the formal details.
We write  $\hh_\aexec$ for the kv-store extracted from $\aexec$ using this construction.  
Moreover, we show that there is a \emph{Galois connection}
between $\ET_{\top}$ traces, the weakest possible execution test and abstract executions (\cref{sec:galois-kv-aexec}).

As with dependency graphs, consistency models using abstract executions are specified by constraining the shape of abstract execution graphs via a set of \emph{axioms} $\Ax$, \eg imposing certain conditions on $\VIS$. %the absence of certain cycles.
All consistency models presented in this paper have an equivalent axiomatic specification based on abstract executions~\cite{framework-concur,laws}. 
Proving the equivalence of execution test-based and abstract execution-based specifications is non-trivial; 
however, we have observed that all proofs follow the same \emph{structure}, so long as certain conditions hold. 
We develop the meta-theory to capture this proof structure.
Our meta-theory is non-trivial; we refer the reader to \cref{sec:kv2aexec-sound-complete} for the full details. 
We give an intuitive account of the two conditions required by our meta-theory, and then state our equivalence theorem. 

Given a set of axioms $\Ax$, we define $\CMs(\Ax) \eqdef \{\hh_\aexec \mid \aexec \text{ sats.\ } \Ax \}$.
Our first required condition is the \emph{soundness} of an execution test against an axiomatic specification.
An execution test $\ET$ is sound against an axiomatic specification $\Ax$ if:
for all $n$ and for all \( \ET \)-traces \( \tau \) with \( n \) steps, 
we can construct $\aexec_0, \cdots, \aexec_n$ and \( \mkvs_i = \mkvs_{\aexec_i} \) such that 
for each step \( (\mkvs_i, \vi_i) \csat \f_i : (\mkvs_{i+1}, \vi_{i+1}) \) in \( \tau \),
the new $\VIS$ edges in \( \aexec_{i+1} \) (those not in $\aexec_i$)
%, which links transactions included in the view \( \vi_i \) to the new transaction \( \txid_i \),
satisfy \( \Ax \).
The formal definition of execution test soundness is given in \cref{sec:kv2aexec-sound-complete}.
%
%\azalea{I don't think the intuitive description of soundness above is very clear...}

Our second required condition is the \emph{completeness} of an execution test against an axiomatic specification.
Let us write $\txid_i$ to denote the $i$\textsuperscript{th} transaction of $\aexec$ in the $\AR$ order, and write $\aexec^{n}$ to denote the restriction of $\aexec$ to $\txid_1 \cdots \txid_n$. 
An execution test $\ET$ is complete against an axiomatic specification $\Ax$ if:
for all abstract executions \( \aexec \) that satisfy \( \Ax \), 
we can construct an \( \ET \)-trace such that \( \mkvs_i = \mkvs_{\aexec^i} \); and
for the new transaction \( \txid_i \) (one not in \(\aexec^{i-1}\)) with operation \( \f_i \) in \( \aexec^i \),
the pre-view \( \vi_i \), including all visible transactions of \( \txid_i \),
and the post-view \( \vi'_i \), including all visible transactions of the immediately next transaction \( \txid' \) from the same client, \( \txid_i \toEdge{\SO} \txid' \),
satisfy
\( \ET \vdash (\mkvs_i, \vi_i) \csat \f_i : (\mkvs_{i+1}, \vi_{i+1}) \).
The formal definition of execution test completeness is given in \cref{sec:kv2aexec-sound-complete}.
%
%\azalea{I don't think the intuitive description of completeness above is very clear...}

Finally, we state our equivalence theorem below (\cref{thm:main-body-et_soundness_completeness}), with its full proof in \cref{sec:kv2aexec-sound-complete}. 
This theorem ensures that if an execution test is sound and complete against a set of axioms $\Ax$, 
then the consistency model induced by $\ET$ corresponds to the kv-stores extracted from abstract executions satisfying $\Ax$.

\begin{theorem}
\label{thm:main-body-et_soundness_completeness}
For all $\ET, \Ax$, if $\ET$ is sound against $\Ax$, then:
\[
    \CMs(\ET) \subseteq \{ \hh_\aexec \mid \aexec \in \CMs(\Ax)\}
\]
For all $\ET, \Ax$, if $\ET$ is complete against $\Ax$, then:
\[
    \{ \hh_\aexec \mid \aexec \in \CMs(\Ax)\}  \subseteq \CMs(\ET)
\]
\end{theorem} 

In \cref{sec:spec-proof}, we show all our specifications in \cref{fig:execution_tests} 
are sound and complete with existing axiomatic specifications on abstract executions.
Together with \cref{thm:main-body-et_soundness_completeness}, 
our specifications do capture all possible behaviours of consistency models.


%\subsection{Andrea's Version}
%\mypar{Relating KV-Stores and Abstract Executions}
%Abstract executions \cite{ev_transactions,framework-concur} are an alternative formalism for specifying consistency models. 
%Similarly to $\ET$-traces, abstract executions represent computations on kv-stores.
 

%\subsection{Andrea's Version}
%\mypar{Relating KV-Stores and Abstract Executions}
%%\sx{
%%The following is the relation between key-values and abstract executions}
%Abstract executions \cite{ev_transactions,framework-concur} are an alternative formalism for specifying consistency models. 
%Similarly to $\ET$-traces, abstract executions represent computations on kv-stores.
% 
%
%%similarly to dependency graphs, they are also labelled 
%%graph, where nodes are labelled with a transaction identifier and the associated fingerprint. 
%%However, in contrast with dependency graphs, edges in abstract executions are used to 
%%capture the information that is locally available to one transaction. Each 
%%edge in abstract executions is labelled either as $\VIS$ or $\AR$: 
%%\begin{itemize}
%%\item an edge of the form $\txid \xrightarrow{\VIS} \txid'$ means that, when transaction 
%%$\txid'$ is executed, it sees the updates performed by $\txid$,
%%\item an edge of the form $\txid \xrightarrow{\AR} \txid'$ means that any update 
%%performed by $\txid'$ is considered to be newer than the updates performed by $\txid$. 
%%\end{itemize}
%%
%%As with dependency graphs, an \emph{abstract execution} graph $\aexec$~\cite{??} 
%%is a directed graph with its nodes representing transactions (with each node labelled with a transaction identifier and a set of (read/write) operations), 
%%and its edges representing certain relations between transactions. 
%%An example abstract execution graph is depicted in \cref{fig:abstract_execution}. 
%%Each node is . 
%%Each edge is labelled by either the \emph{visibility} ($\VIS$) or \emph{arbitration} ($\AR$) relation. 
%%The $\VIS$ is an irreflexive order on transactions such that $\txid_1 \xrightarrow{\VIS} \txid_2$ denotes that the effects (updates) of $\txid_1$ are visible to $\txid_2$. 
%%The $\AR$ is a strict total order on transactions describing the commit order:  $\txid_1 \xrightarrow{\AR} \txid_2$ denotes that $\txid_1$ commits before $\txid_2$. 
%%Moreover, $\AR$ contains $\VIS$ ($\VIS \subseteq \AR$) and agrees with the session order: 
%%if $\txid_{\cl}^{n} \xrightarrow{\AR}  \txid_{\cl}^{m}$, then $n < m$.
%\begin{definition}
%\label{def:main-body-absexec}
%\label{def:main-body-aexec}
%An abstract execution is a triple $\aexec = (\TtoOp{T}, \VIS, \AR)$, where 
 %$\TtoOp{T}: \TxID_{0} \parfinfun \powerset{\Ops}$ is a partial, 
% $\TtoOp{T}: \TxID_{0} \parfinfun \powerset{\Ops}$ is a partial, 
%finite function mapping transaction identifiers to the set of operations that they perform,
%$\VIS \subseteq \dom(\TtoOp{T}) \times \dom(\TtoOp{T})$ is an irreflexive relation, 
%called \emph{visibility}, $\AR \subseteq \dom(\TtoOp{T}) \times \dom(\TtoOp{T})$ is a strict, total order 
%such that $\VIS \subseteq \AR$, and whenever $\txid_{\cl}^{n} \xrightarrow{\AR} 
%\txid_{\cl}^{m}$, then $n < m$. 
%Furthermore, for any transaction $\txid \in \dom(\TtoOp{T})$, and $\ke \in \Keys$, let 
%$\visibleWrites_{\aexec}(\ke, \txid) = \VIS^{-1}(\txid) \cap \{\txid' \mid (\otW,\ke, \stub) \in \TtoOp{T}(\txid')\}$; 
%we require that whenever  $(\otR, \ke, \val) \in \TtoOp(\txid)$ for some $\ke, \val$ 
%and $\txid \in \dom(\TtoOp{T})$, then either $\visibleWrites_{\aexec}(\ke, \txid) = \emptyset$ and 
%$\val$ is the default value $\val_{0}$, or the transaction $\txid' = \max_{\AR}(\visibleWrites_{\aexec}(\ke, \txid))$ 
%is defined and $(\otR, \ke, \val) \in \TtoOp{T}(\txid')$.
%Given an abstract execution $\aexec = (\TtoOp{T}, \VIS, \AR)$ we let $\TtoOp{T}_{\aexec} = \TtoOp{T}$, 
%$\VIS_{\aexec} = \VIS$ and $\AR_{\aexec} = \AR$.
%The set of abstract executions is denoted by $\aeset$.
%\end{definition}
%%Henceforth, given $\aexec$, we use the more suggestive notation 
%%$\txid \xrightarrow{\VIS_{\aexec}} \txid'$ in lieu of $(\txid, \txid') \in \VIS_{\aexec}$, and similarly for $\AR_{\aexec}$. 
%%\sx{We have introduced the notation before.}
%Intuitively, $\txid \xrightarrow{\VIS_{\aexec}} \txid'$ means that, at the moment of executing, 
%transaction $\txid'$ sees the updates performed by $\txid$; $\txid \xrightarrow{\AR_{\aexec}} \txid'$ 
%means that the updates performed by $\txid'$ are newer than those performed by $\txid$. 
%The constraint in \cref{def:main-body-aexec} amounts to require that a transaction reading 
%key $\ke$ always fetches the newest write over $\ke$ performed in its set of visible transactions, 
%thus modelling the last write wins policy. An example of abstract execution is given in \cref{fig:abstract_execution}.
%Following \cite{laws}, it is always possible to extract a dependency graph $\Gr_{\aexec}$ from an abstract 
%execution $\aexec$, and therefore a kv-store $\hh_{\aexec}$ (cf. \cref{thm:kv_graph_isomorph}). We defer the formal details of such a construction 
%to \ref{app:?}, but we mention here that in such a construction, we draw an edge of the form $\txid \xrightarrow{\RF} \txid'$ 
%if $\txid = \max_{\AR_{\aexec}}(\visibleWrites(\ke, \txid'))$ and $(\otR, \ke, \_) \in \TtoOp{T}(\txid')$ for some $\ke \in \Keys$, 
%while $\txid \rightarrow{\VO} \txid'$ if $(\otW, \ke, \_) \in \TtoOp{T}(\txid), (\otW, \ke, \_) \in \TtoOp{T}(\txid')$ and 
%$\txid \xrightarrow{\AR_{\aexec}} \txid'$; edges labelled as $\AD$ can be uniquely determined from edges labelled as 
%$\RF$ and $\VO$.
%\sx{If we dont have space. we can cut the technical details here}
%Consistency models specifications based on abstract executions are given by imposing 
%constraints on the structure of abstract executions, and then by extracting the 
%set of kv-stores from those abstract executions that satisfy said requirements. 
%For example, strict serialisability can be formalised by only considering 
%those kv-stores $\hh_{\aexec}$ obtained from an abstract execution 
%$\aexec$ where $\AR_{\aexec} \subseteq \VIS_{\aexec}$. Formally, 
%we consider declarative specifications of consistency models where 
%we require an abstract execution $\aexec$ to satisfy axioms of the 
%form $\mathcal{R}_{\aexec} \subseteq \VIS_{\aexec}$, where 
%$\mathcal{R}_{\aexec} \subseteq \AR_{\aexec}$. Given such a set of 
%axioms $\Ax$, we let $\CMs(\Ax) = \{\hh_{\aexec} \mid \aexec \text{ satisfies } \Ax\}$. 
%Formally, an axiom is a function $\A : \aeset \to \powerset{\TxID} \times \powerset{\TxID}$, 
%and we say that $\aexec$ satisfies $\A$, if $\A(\aexec) \subseteq \VIS_{\aexec}$.
%All the consistency models presented in this paper have an axiomatic 
%specification based on abstract executions \cite{framework-concur,laws}. 
%In the rest of this section, we develop the methodologies to show that 
%such specifications are indeed equivalent to those based on execution tests.
%Consider the weakest possible execution test $\ET_{\top}$, i.e. such that 
%$\ET_{\top} \vdash (\hh, \vi) \triangleright \opset, (\mkvs',  \vi')$ for any $\hh, \hh', \vi, \vi', \opset$. 
%We show that there is a close connection between the set $\ET_{\top}$-traces and 
%$\aeset$. 
%\begin{theorem}
%\label{thm:kvtrace2aexec}
%Given an $\ET_{\top}$-trace 
%\[
%\]
%there exists a non-empty set of abstract executions $\execs(\tau) = \{\aexec_i\}_{i \in I}$ such that, for any $i \in I$, 
%$\hh_{\aexec_{i}} = \hh_{n}$, and the order in which transactions are executed in $\tau$ matches $\AR_{\aexec_{i}}$. 
%\end{theorem}
%The construction of the set $\execs(\tau)$, where $\tau$ is as defined in \cref{thm:kvtrace2aexec}, is incremental: 
%initially we let $\execs_{0}(\tau) = \{(\emptyset, \emptyset, \emptyset)\}$. \ac{Here there is an inconsistency: if we want $\txid_{0}$ to be included in abstract executions, then initially we 
%must set $\execs(\tau) = ([\txid_{0} \mapsto \{ (\otW, \ke, \val_{0} \mid \ke \in \Keys)\}], \emptyset, \emptyset$.} 
%Then for any $i=1,\cdots, n$ we define $\execs_{i}(\tau)$ 
%inductively from $\execs_{i-1}(\tau)$ as follows: 
%consider the $i$-th $\ET_{\top}$-reduction of $\tau$, $(\hh_{i-1}, \viewFun_{i-1}) \xrightarrow{(\cl_{i}, \lambda_{i})}_{\ET_{\top}} (\hh_i, \viewFun_{i})$. 
%If $\lambda_{i} = \varepsilon$, then we let $\execs_{i}(\tau) = \execs_{i-1}(\tau)$. Otherwise, 
%if $\lambda_{i} = \opset$, we first identify the transaction identifier that is associated to $\opset$ in $\tau$: this 
%is the only transaction identifier $\txid_{i}$ that appears in $\hh_{i}$ and not in $\hh_{i-1}$; we extend the arbitration order 
%of each abstract execution $\aexec \in \execs_{i}(\tau)$ by appending the transaction identifier 
%$\txid_{i}$ as its last  transaction; we let $\execs_{i}^{\mathsf{partial}}(\tau)$ be the resulting set of 
%abstract executions. Then, for each abstract execution in this set, we determine a set of suitable 
%local visibility relations for the transaction $\txid_{i}$, i.e. the possible sets of transactions that 
%$\txid_{i}$ sees. Each of this sets must contain at least the writers of the versions contained in the 
%view of client $\cl_{i}$ in $\viewFun_{i-1}$, but it may also contain any other read-only transaction 
%that is already present in the abstract execution. Formally, given a kv-store $\hh$ and a view $\vi$, we let 
%$\Tx(\hh, \vi) \defeq \Setcon{ \WTx(\hh(\ke, i)) }{ \ke \in \Keys \wedge i \in \vi(\ke) }$. Then, for each 
%abstract execution $\aexec \in \execs_{i}^{\mathsf{partial}}$ and each subset $\T_{\mathsf{rd}}$ of 
%read-only transactions in $\aexec$, we extend the visibility relation $\VIS_{\aexec}$ 
%with the pairs $\{(\txid, \txid_{i}) \mid  \txid \in \Tx(\hh_{i-1}, \viewFun_{i-1}(\cl_{i})) \cup \T_{\mathsf{rd}}\}$, 
%and we include the resulting abstract execution in $\aexec \in \execs_{i}(\tau)$. Finally, we 
%let $\execs(\tau) = \execs_{n}(\tau)$.
%\sx{We should mentioned incremental, but could leave the details out.}
%%formally, we let $\execs_{i}^{\mathsf{partial}(\tau)} = \{(\TtoOp{T}_{\aexec}[\txid_{i} \mapsto \opset], \VIS_{\aexec}, 
%%\AR_{\aexec} \cup \{(\txid, \txid_{i} \mid \txid \in \dom\TtoOp{T}(\aexec)\} \mid \aexec \in \execs_{i}(\tau)\}$. 
%%Then, for each $\aexec \in \execs_{i}^{\mathsf{partial}(\tau)}$, we determine the set of transactions that  
%%
%%Similarly, given an abstract execution $\aexec$, there exists a non-empty 
%%set of $\ET_{\top}$-traces $\{\tau_{i}\}$ such that, for each $i \in I$, the last configuration of $\tau_{i}$ is 
%%$\hh_{\aexec}$, and $\tau_{i}$ executes transactions in the order established by $\AR_{\aexec}$. 
%model, with respect to an axiomatic one based on abstract executions. 
%Suppose that we want to prove that an execution test $\ET$ is sound with respect 
%to an axiomatic specification $\Ax$. A kv-store $\hh$ is included in $\CMs(\ET)$ only 
%if we can find an $\ET$-trace $\tau$ that terminates in a configuration $(\hh, \_)$. Because 
%any $\ET$-trace is also a $\ET_{\top}$-trace, then by \cref{thm:kvtrace2aexec} 
%for any $\aexec \in \execs(\tau)$, $\hh_{\aexec} = \hh$. Therefore, it suffices to prove 
%$\execs(\tau)$ contains at least one abstract execution that satisfies $\Ax$, to conclude 
%that $\hh \in \CMs(\Ax)$. 
%Our proof technique amounts to proving that, whenever $\aexec$ satisfies the axioms in
%$\Ax$ and $\ET \vdash (\hh_{\aexec}, \vi) \triangleright 
%\opset: (\mkvs', \vi')$, then we can always find a set of read-only transactions $\T_{\mathsf{rd}}$ such that 
%by extending $\aexec$ with some transaction $\txid$, appearing last in the arbitration order 
%and whose set of visible transactions is $\Tx(\hh_{\aexec}, \vi) \cup \T_{\mathsf{rd}}$, then 
%the resulting execution also satisfies the axioms in $\Ax$. Assume that we have successfully employed the 
%proof technique for $\ET$, and consider the $\ET$-trace $\tau$ above, which we assume it has 
%$n$ $\ET$-reductions. It is immediate to note that the abstract execution $(\emptyset, \emptyset, \emptyset)$ 
%included in $\execs_{0}(\tau)$ satisfies $\Ax$; furthermore, because we have successfully applied our proof technique to $\ET$, 
%we are ensured that if $\execs_{i}(\tau)$ contains at least one abstract execution $\aexec_{i}$ that satisfies the axioms in $\Ax$, where $i=0,\cdots n-1$. 
%By induction, we conclude that $\execs(\tau)$ contains at least one abstract execution satisfying $\Ax$, and 
%therefore $\hh_{\aexec} \in \CMs(\aexec)$. 
%\sx{Not sure how to deal with above}
%In practice, our proof techniques also takes into account the possibility of defining an invariant over the set $\Tx(\_, \_)$, which 
%must be proved to be preserved by $\ET$-reductions. As we explain in \cref{app:?}, defining the right invariant 
%is crucial to prove the soundness of some execution test-based specifications.


%
%In practice, our proof techniques also takes into account the possibility of defining an invariant over the set $\Tx(\_, \_)$, which 
%must be proved to be preserved by $\ET$-reductions. As we explain in \cref{app:?}, defining the right invariant 
%is crucial to prove the soundness of some execution-test based specifications.
%
%
%%for any $i=0,\cdots,n-1$, if $\execs_{i}(\tau)$ contains 
%%an execution $\aexec_{i}$ that satisfies $\Ax$, then $\execs_{i+1}(\tau)$. Assuming that 
%%$\execs_{i+1}(\tau)$ has been obtained by extending executions in $\aexec_{i}$ with some 
%%transaction $\txid_{i}$, then this amounts to find a suitable set of read-only transactions in $\aeset_{i}$ 
%%such that the relation $\{(\txid', \txid_{i}) \mid \txid' \in \Tx(\hh_{i}, \viewFun_{i-1}(\cl_{i})) \cup \T_{\rd}$ 
%%satisfies the axioms in $\Ax$. In practice, our proof techniques also allows to prove invariants 
%%over the view funcitons in configurations of $\tau$, which then can be used 
%
%%\azalea{OK, from here on things get a bit hairy and I don't have a clear understanding of what is going on.
%%Ideally, we should be able to state the two theorems (\cref{thm:main-body-et_soundness} and \cref{thm:main-body-et_complete}) intuitively, without giving the scary technical definitions. 
%%In my opinion, what matters here is that we have established a link between kv-stores and abstract executions. The details of how this link is constructed can be pushed to the appendix.  
%%
%%I have not touched the remainder of this section.  
%%}
%%\sx{
%%    START
%%}
%%
%%To specify consistency models, abstract executions constraint resolution policy \( \RP \) and the sharp of abstract execution \( \Ax \) (I believe we could even say more precise --- the minimum visibility relation, and cite andrea's concur paper).
%%Resolution policy determines a set of snapshot given a set of observable transactions.
%%Most time it is last-write-win which gives a unique single snapshot.
%%This corresponds to the \( \snapshot{} \) function in the semantics kv-store.
%%The resolution policy part we could (question?) choose to not mentioned, since it is minor and many people always assume last-write-win.
%%
%%The \( \Ax = \Set{ \A : \aeset \to \powerset{\TxID} \times \powerset{\TxID}} \) is a set of constraints on visibility relations, \eg \( \Ax = \Set{\lambda \aexec \ldotp \SO_\aexec,  \lambda \aexec \ldotp \VIS_\aexec;\VIS_\aexec} \) means all the abstract executions must satisfy \( \SO \subseteq \VIS , \VIS ; \VIS \subseteq \VIS \).
%%
%%\begin{definition}
%%\label{def:aexec2graph}
%%Given an abstract execution $\aexec$ that satisfies the last write wins policy,
%%the dependency graph $\graphof(\aexec) \defeq (\TtoOp{T}_{\aexec}, \RF_{\aexec}, 
%%\VO_{\aexec}, \AD_{\aexec})$ is defined by letting
%%\begin{itemize}
%%\item $\txid \xrightarrow{\RF_{\aexec}(\ke)} \txid'$ if and only if 
%%$\txid = \max_{\AR_{\aexec}}(\visibleWrites_{\aexec}(\ke, \txid'))$, 
%%\item $\txid \xrightarrow{\VO_{\aexec}(\ke)} \txid'$ if and only 
%%$\txid, \txid' \in_{\aexec} (\otW, \;\ke: \_)$ 
%%and $\txid \xrightarrow{\AR_{\aexec}} \txid'$,
%%\item $\txid \xrightarrow{\AD_{\aexec}(\ke)} \txid'$ if and only if either 
%%$(\otR, \ke, \_) \in_{\aexec} \txid, (\otW, \ke, \_) \in_{\aexec} \txid'$ and 
%%whenever $\txid'' \xrightarrow{\RF_{\aexec}(\ke)} \txid$, 
%%then $\txid'' \xrightarrow{\VO_{\aexec}(\ke)} \txid'$.
%%\end{itemize}
%%\end{definition}
%%Note that each abstract execution $\aexec$ determines a key-value store $\hh_{\aexec}$,
%%as a result of \cref{def:aexec2graph} and \cref{thm:kv2graph}. 
%%Let $\hh$ be the unique kv-store such that $\Gr_{\hh} = \graphof(\aexec)$, then $\hh_{\aexec} = \hh$. 
%%
%%A kv-store \( \mkvs \) is compatible with an abstract execution \( \aexec \)
%%There is a mapping from 
%%\begin{definition}
%%\label{def:compatible-main-body}
%%Given a key-value store $\hh$,
%%an abstract execution $\aexec$ is compatible with $\hh$, written 
%%$\aexec \compatible \hh$, if and only if there exists a  mapping 
%%$f: \powerset{\T_{\aexec}} \rightarrow \Views(\hh)$
%%such that  
%%\begin{itemize}
%%\item for any subset $\T \subseteq \T_{\aexec}$, then $\RP_{\LWW}(\aexec, \T) = \{\snapshot(\hh, f(\T))\}$; 
%%\item for any view $\vi \in \Views(\hh)$, there exists a subset $\T \subseteq \T_{\aexec}$ 
%%such that $f(\T) = \vi$, and $\RP_{\LWW}(\aexec, \T) = \{\snapshot(\hh_{\aexec}, \vi)\}$.
%%\end{itemize}
%%\end{definition}
%%The function $\getView(\aexec, \T)$ defines the view on \( \mkvs_\aexec \) that corresponds to \( \T \) as the following:
%%\[
%%\getView(\aexec, \T) \defeq \lambda \ke. \{0\} \cup \Setcon{ i }{\WTx(\hh_{\aexec}(\ke, i)) \in \T}
%%\]
%%Inversely, the function \( \Tx(\hh, \vi) \) converts a view to a set of observable transactions:
%%\[
%%\Tx(\hh, \vi) \defeq \Setcon{ \WTx(\hh(\ke, i)) }{ \ke \in \Keys \wedge i \in \vi(\ke) }
%%\]
%%Given \( \getView \), \( \Tx \), \cref{def:compatible}, 
%%it follows \( \aexec \compatible \hh_{\aexec} \) shown in \cref{thm:aexec2kv.compatible}.
%%
%%Given a trace with the final kv-store \( \mkvs \), there an abstract execution \( \aexec \) that is compatible with \( \mkvs \).
%%First, all transactions in an abstract execution are totally ordered by \( \AR \),
%%therefore an abstract execution by itself is a trace.
%%The reduction order of a trace of kv-store maps to the \( \AR \) in the abstract execution and vice versa.
%%The challenge is to show that
%%for each transaction \( \txid \) in the trace and the initial view \( \vi \) of the transaction, the visible transitions \( \Tx(\hh, \vi) \) contains at least those transactions by the constraints \( \Ax \), \ie
%%Note that \( \Tx(\hh, \vi) \) do not contain any read-only transactions, 
%%thus to be more precise, we mean \( \Tx(\hh, \vi) \) plus some potentially read-only transactions contains those by the constraints \( \Ax \), \ie
%%\( \fora{\A\in \Ax, \txid'} (\txid', \txid) \in \A(\aexec) \implies \txid' \in \Tx(\hh, \vi) \lor \txid' \text{is read only} \).
%%
%%Given an abstract execution \( \aexec \) there is a trace of kv-store with the final kv-store \( \mkvs \) that is compatible.
%%Similarly, the \( \AR \) decides the reduction order in the trace.
%%The challenge here is that
%%for each transaction \( \txid \) with fingerprint \( \f \) in the abstract execution,
%%(We should mentioned a node in the graph is the fingerprint)
%%We find two views, the initial \( \vi \) and the final \( \vi' \), so \( \ET \vdash (\mkvs, \vi) \csat \f : \vi' \) where the \( \mkvs \) is the kv-store when \( \txid \) commits.
%%The initial view \( \vi \) includes all versions written by visible transactions of \( \txid \) from the abstract execution, \ie \( \vi = \getView(\aexec, \VIS_\aexec^{-1}(\txid)) \).
%%Since \( \vi' \) gives the minimum views for the next transactions from the same clients,
%%it can be computed by including all versions, if exists in \( \mkvs \), written by visible transactions of \( \txid' \) where \( \txid' \toEdge{\SO} \txid \).
%%
%%\sx{
%%    END
%%}
%%
%%A semantics under \( \aexec \), where transaction satisfies the specification in the form of \( (\RP,\Ax) \).
%%\( \RP \) is a function takes a set of transactions \( \T \) from abstract execution \( \aexec \), 
%%and returns  a set of possible snapshots.
%%A common one is last-write-win.
%%
%%\begin{definition}
%%\label{def:lww}
%%The Last Write Wins resolution policy $\RP_{\LWW}$ is defined as 
%%$\RP_{\LWW}(\aexec, \T) \defeq \{\h\}$ where
%%\begin{align*}
%%    \h & \defeq \lambda \ke. \text{let} \ \T_{\ke} = ( \T \cap \{\txid \mid (\otW,\ke, \_) \in_{\aexec} \txid\}) \\
%%       & \quad \text{in} \
%%\begin{cases}
%%\val_{0} &\impliedby \T_{\ke} =  \emptyset\\
%%\val &\impliedby (\otW, \ke, \val) \in_{\aexec} \max_{\AR_{\aexec}}(\T_{\ke})
%%\end{cases}
%%\end{align*}
%%\end{definition}
%%
%%\( \Ax \) is a set of constraints on the shape of the abstract execution,
%%which defines the minimum visibility relation.
%%For example, the minimum visibility for serialisability is a singleton set
%%\( \Ax_\SER = \Set{\lambda \aexec \ldotp \AR_\aexec } \),
%%which means the minimum visibility should contain the arbitration \( \AR_\aexec \subseteq \VIS_\aexec \).
%%In general, if an abstract execution \( \aexec \) satisfies a set of constraints  \( \Ax \),
%%if \( \fora{\A \in \Ax} \A(\aexec) \subseteq \VIS_\aexec \).
%%
%%Through the dependency graph, we can relate key-value stores and abstract executions (\cref{def:main-body-aexec2graph}).
%%Note that each abstract execution $\aexec$ determines a key-value store 
%%$\hh_{\aexec}$, as per \cref{def:main-body-aexec2graph} and \cref{thm:main-body-kv2graph}. 
%%
%%\begin{definition}
%%\label{def:main-body-aexec2graph}
%%Given an abstract execution $\aexec$ that satisfies the last write wins policy,
%%the dependency graph $\graphof(\aexec) \defeq (\TtoOp{T}_{\aexec}, \RF_{\aexec}, 
%%\VO_{\aexec}, \AD_{\aexec})$ is defined by letting
%%\begin{itemize}
%%\item $\txid \xrightarrow{\RF_{\aexec}(\ke)} \txid'$ if and only if 
%%    $\txid = \max_{\AR_{\aexec}}\left( \Setcon{\txid}{(\otW,\ke,\stub) \in \txid' \land \txid' \toEdge{\VIS_\aexec} \txid } \right)$, 
%%\item $\txid \xrightarrow{\VO_{\aexec}(\ke)} \txid'$ if and only 
%%$\txid, \txid' \in_{\aexec} (\otW, \;\ke: \_)$ 
%%and $\txid \xrightarrow{\AR_{\aexec}} \txid'$,
%%\item $\txid \xrightarrow{\AD_{\aexec}(\ke)} \txid'$ if and only if either 
%%$(\otR, \ke, \_) \in_{\aexec} \txid, (\otW, \ke, \_) \in_{\aexec} \txid'$ and 
%%whenever $\txid'' \xrightarrow{\RF_{\aexec}(\ke)} \txid$, 
%%then $\txid'' \xrightarrow{\VO_{\aexec}(\ke)} \txid'$.
%%\end{itemize}
%%\end{definition}
%%
%%Let $\hh$ be the unique kv-store such that $\Gr_{\hh} = \graphof(\aexec)$: then 
%%$\hh_{\aexec} = \hh$. 
%%Yet this mapping $\hh_{(\stub)}$ is not a bijection, 
%%in that several abstract executions may be encoded in the same key-value store. 
%%This is because key-value stores abstract away the total arbitration order of transactions.
%%
%%\sx{
%%    explain \( \Tx(\mkvs,\vi) \) and intuition of invariant \( I \):
%%    \( \Tx(\mkvs,\vi) \) includes all the writers of the versions \( \mkvs(\ke, i)\), 
%%    where these versions are included in the view \( i \in \vi(\ke)\).
%%    In abstract executions, there is  no explicit \( \SO \) relation 
%%    but \( \VIS \) and \( \AR \) relations.
%%    The invariant \( I(\aexec, \cl) \) is for carrying information 
%%    for transactions from the client \( \cl \).
%%}
%
%\begin{definition}
%\label{def:main-body-et_sound}
%An execution test $\ET$ is sound with respect to an axiomatic 
%specification $\Ax$ if and only if there exists an 
%invariant condition $I$ such that whenever $\ET \vdash (\hh, \vi) 
%\triangleright \opset: (\hh',\vi')$ where \( \mkvs' = \updKV{\mkvs, \vi ,\f, \txid}\), 
%for any $\aexec$ such that 
%$\hh_{\aexec} = \hh$, any client $\cl$ and any 
%transaction identifier $\txid \in \nextTxId(\hh, \cl)$, 
%such that $I(\aexec, \cl) \subseteq \Tx(\hh, \vi)$, then  
%there exists a other sets of transactions $\T_{\rd}$, 
%such that 
%\begin{itemize}
%\item $\forall \A \in \Ax. \Setcon{\txid' }{ (\txid', \txid) \in \A(\aexec')} \subseteq \Tx(\hh, \vi) \cup \T_{\rd}$, 
%\item the invariant is preserved, \ie $I(\aexec', \cl) \subseteq \Tx(\mkvs', \vi')$ for some \( \aexec' \) that \( \hh' = \hh_{\aexec'}\)
%\end{itemize}
%\end{definition}
%\sx{
    %Abuse of notation: 
    %\( \CMa(\RP_{\LWW}, \Ax) \), all possible abstract executions produced by the specification \( (\RP_{\LWW}, \Ax) \).
%
%\sx{
%    Abuse of notation: 
%    \( \CMa(\RP_{\LWW}, \Ax) \), all possible abstract executions produced by the specification \( (\RP_{\LWW}, \Ax) \).
%}
%\begin{theorem}
%\label{thm:main-body-et_soundness}
%If $\ET$ is sound with respect to $(\RP_{\LWW}, \Ax)$, then 
%\[
    %\CMs(\ET) \subseteq \{ \hh \mid \exists \aexec \in \CMa(\RP_{\LWW}, \Ax)).\;\hh_{\aexec} = \hh\}
%\]
%\end{theorem}

%    \CMs(\ET) \subseteq \{ \hh \mid \exists \aexec \in \CMa(\RP_{\LWW}, \Ax)).\;\hh_{\aexec} = \hh\}
%\]
%\end{theorem}
%
%Similarly, in \cref{sec:aexectrace2kv} we show that it is possible to 
%construct a set of $\ET$-traces $\{\tau_{i}\}_{i \in I}$ from an abstract execution $\aexec$, such that 
%for any $i \in I$, the last configuration of $\tau_{i}$ has the form $(\hh_{\aexec}, \stub)$, and 
%the order in which transactions are executed in $\tau_{i}$ is consistent with $\AR_{\aexec}$. 
%This gives rise to a proof technique aimed at showing that execution-test based specifications 
%of consistency models are sound and complete with respect with their axiomatic counterparts on abstract executions. 
%More details are outlined in \cref{sec:kv2aexec-sound-complete}. 
%In \cref{app:et_sound_complete} we employ our proof techniques to prove that our specifications (\cref{fig:execution.tests})
%of consistency models using execution tests are sound and complete with respect to previously 
%existing axiomatic specifications based on dependency graphs.
%%\begin{proof}
%%    See \cref{thm:et_soundness} in \cref{sec:kv2aexec-sound-complete}.
%%\end{proof}
%%
%%\sx{explain \( \getView\):
%%    It can be seen as the inverse of \( \Tx \).
%%    Assume the key-value store \( \mkvs \) and  abstract execution \( \aexec \)  are compatible,
%%    ie\( \mkvs = \mkvs_\aexec \).
%%    For any version \( \mkvs(\ke,i)\) and its writer \( \txid = \WTx(\mkvs(\ke,i)) \),
%%    if \( \txid \) is visible by \( \txid' \) in the \( \aexec \),
%%    then the view of \( \txid' \) before commit contains the version \( \mkvs(\ke,i) \),
%%    that is \( i \in \getView(\aexec, \VIS^{-1}(\txid'))(\ke) \).
%%}
%%
%%\begin{definition}
%%\label{def:main-body-et_complete}
%%An execution test $\ET$ is \emph{complete} with respect 
%%to an axiomatic specification $(\RP_{\LWW}, \Ax)$ if, for any 
%%abstract execution $\aexec \in \CMa(\RP_{\LWW}, \Ax)$ 
%%such that $\AR_{\aexec} = \{(\txid_{i}, \txid_{i+1})\}_{i=1}^{\lvert \T_{\aexec} \rvert - 1}$, 
%%and for any $i=1,\cdots, n$, there exist two views $\vi_{i}, \vi_{i}'$ such that 
%%\begin{itemize}
%%\item $\vi_{i} = \getView(\aexec, \VIS_{\aexec}^{-1}(\txid_{i}))$, 
%%\item let $\txid_{i} = \txid_{\cl}^{n}$ for some $\cl, n$; if the
%%transaction $\txid_{i}' = \min_{\PO_{\aexec}}\{\txid' \mid \txid_i \xrightarrow{\PO_{\aexec}} \txid'\}$  
%%is defined, then $\vi' = \getView(\aexec, \T_{i})$, where $\T_{i} \subseteq (\AR_{\aexec}^{-1})?(\txid_{i}) \cap \VIS_{\aexec}^{-1}(\txid_{i}'))$; 
%%otherwise $\vi' = \getView(\aexec, \T_{i})$, where $\T_{i} \subseteq (\AR_{\aexec}^{-1})?(\txid_{i})$, 
%%\item $\ET \vdash (\hh_{\cut(\aexec, i-1)}, \vi_{i}) \triangleright \TtoOp{T}_{\aexec}(\txid_{i}) : \vi_{i}'$.
%%\end{itemize}
%%\end{definition}
%%
%%\begin{theorem}
%%\label{thm:main-body-et_complete}
%%Let $\ET$ be an execution test that is complete with respect to 
%%an axiomatic specification $(\RP_{\LWW}, \Ax)$. Then 
%%$\CMa(\RP_{\LWW}, \Ax) \subseteq \CMs(\ET)$.
%%\end{theorem}
%%\begin{proof}
%%    See \cref{thm:et_complete} in \cref{sec:kv2aexec-sound-complete}.
%%\end{proof}
%%
%%Given above, we have proven the specification in \cref{sec:spec-proof}.
%
