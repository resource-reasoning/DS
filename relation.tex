\section{KV-Stores and Other Formalisms}
\label{sec:other_formalisms}

In this Section, we discuss how kv-stores and execution 
tests relate to existing declarative formalisms for specifying  
consistency models, based on dependency graphs \cite{adya} 
and abstract executions \cite{framework-concur}. 
We give an overview of our results here, and refer the reader to the 
appendix for more details.


\mypar{Relating KV-Stores and Dependency Graphs}
Dependency graphs \cite{adya-icde,adya} are perhaps the most popular 
formalism used for specifying transactional consistency models. 
A dependency graph $\Gr$ is a directed, labelled graph where its
nodes denote transactions and its edges denote certain \emph{dependencies} between transactions.  
An example dependency graph is given in \cref{fig:dependency-graph}.
Each node is labelled with a transaction identifier and a fingerprint.
Each edges is labelled with metadata describing the information flow in a run of the database: 
%\footnote{Dependency graphs additionally record a session order between transactions, corresponding to our session order $\SO$ in \cref{subsec:kvstores}.}:
\begin{enumerate*}
    \item a \emph{session order} edge, $\txid_1 \xrightarrow{\SO} \txid_2$, 
	\item a \emph{read dependency} edge, $\txid_1 \xrightarrow{\WR} \txid_2$, denotes
that transaction $\txid_2$ reads a version written by $\txid_1$;
	\item a \emph{write dependency} edge, $\txid_1 \xrightarrow{\WW} \txid_2$, denotes that $\txid_2$ overwrites a version written by $\txid_1$; and 
	\item an \emph{anti-dependency} edge, $\txid_1 \xrightarrow{\RW} \txid_2$, denotes that $\txid_2$ overwrites a version read by $\txid_2$. 
\end{enumerate*}
We give the formal definition of dependency graphs in \cref{app:depgraphs}.
Observe that we can always \emph{extract} a dependency graph  $\Gr$ from a kv-store $\hh$:
we choose the transaction identifiers appearing in $\hh$ as the nodes of $\Gr$, 
and let $\SO$ as defined in \cref{subsec:kvstores}, and $ \RF, \VO, \AD$  
be as defined in \cref{fig:execution_tests}.
For example, \cref{fig:counter_kv_final} corresponds to the dependency graph extracted from the kv-store in \cref{fig:counter_kv_final}.
In \cref{app:depgraphs} we show that this construction can be reversed, thus giving 
rise to the following result: 
\begin{theorem}
\label{thm:kv_graph_isomorph}
Dependency graphs are isomorphic to kv-stores.
\end{theorem}

Using dependency graphs, consistency models are specified by constraining the shape of the graph; typically, such constraints mandate the absence of certain cycles. For example, strict serialisability is defined as those dependency graphs where $(\SO \cup \WW \cup \WR \cup \RW)^+$ is acyclic. 
We can always convert a dependency graph-based specification into an execution test-based one by simply checking that, when committing a transaction to kv-store $\hh$ and obtaining $\hh'$, 
the dependency graph extracted from $\hh'$ contains no cycles prohibited by the dependency graph-based specification. 

\begin{figure*}[t]
\begin{center}
\begin{halfsubfig} 
\begin{centertikz}

\node(t0wx) at (-1,2) {$(\otW, \ke_1, \val_0)$}; 
\path (t0wx.east) + (1,0) node (t0wy) {$(\otW, \ke_2, \val'_0)$};
\path (t0wx.north east) + (2.5,0.5) node[anchor = west] (t1ry) {$(\otR, \ke_2, \val'_0)$}; 
\path (t1ry.east) + (0.2,0) node[anchor = west] (t1wx) {$(\otW, \ke_1, \val_1)$};
\path (t0wx.south east) + (2.5,-0.5) node[anchor = west] (t2rx) {$(\otR, \ke_1, \val_0)$};
\path (t2rx.east) + (0.2,0) node[anchor = west] (t2wy) {$(\otW, \ke_2, \val'_1$)};

\begin{pgfonlayer}{background}
\node[background, fit=(t0wx) (t0wy),inner ysep=3pt, inner xsep=6pt] (t0) {};
\node[background, fit= (t1ry) (t1wx),inner ysep=3pt, inner xsep=6pt] (t1) {};
\node[background, fit= (t2rx) (t2wy),inner ysep=3pt, inner xsep=6pt] (t2) {};

\path(t0.west) node[anchor=east] (t0lbl) {$\txid_0$};
\path(t1.north) node[anchor=south] (t1lbl) {$\txid_1$};
\path(t2.south) node[anchor=north] (t2lbl) {$\txid_2$};

\path[->]
(t0.north) edge[bend left=30] node[above, yshift=3pt, xshift=-20pt, pos=0.3] {$\RF, \VO$} (t1.west)
(t0.south) edge[bend right=30] node[below, yshift=-3pt, xshift=-20pt, pos=0.3] {$\RF, \VO$} (t2.west)
([xshift=-8pt]t2.north) edge[bend left=20] node[left] {$\AD$} ([xshift=-8pt]t1.south) 
([xshift=8pt]t1.south) edge[bend left=20] node[right] {$\AD$} ([xshift=8pt]t2.north);
\end{pgfonlayer}

\end{centertikz}
\vspace*{-5pt}
\caption{Dependency graph}
\label{fig:dependency-graph}
\end{halfsubfig} 
%
\begin{halfsubfig} 
\begin{centertikz}

\node(t0wx) at (-1,2) {$(\otW, \ke_1, \val_0)$}; 
\path (t0wx.east) + (1,0) node (t0wy) {$(\otW, \ke_2, \val'_0)$};
\path (t0wx.north east) + (2.5,0.5) node[anchor = west] (t1ry) {$(\otR, \ke_2, \val'_0)$}; 
\path (t1ry.east) + (0.2,0) node[anchor = west] (t1wx) {$(\otW, \ke_1, \val_1)$};
\path (t0wx.south east) + (2.5,-0.5) node[anchor = west] (t2rx) {$(\otR, \ke_1, \val_0)$};
\path (t2rx.east) + (0.2,0) node[anchor = west] (t2wy) {$(\otW, \ke_2, \val'_1$)};

\begin{pgfonlayer}{background}
\node[background, fit=(t0wx) (t0wy),inner ysep=3pt, inner xsep=6pt] (t0) {};
\node[background, fit= (t1ry) (t1wx),inner ysep=3pt, inner xsep=6pt] (t1) {};
\node[background, fit= (t2rx) (t2wy),inner ysep=3pt, inner xsep=6pt] (t2) {};

\path(t0.west) node[anchor=east] (t0lbl) {$\txid_0$};
\path(t1.north) node[anchor=south] (t1lbl) {$\txid_1$};
\path(t2.south) node[anchor=north] (t2lbl) {$\txid_2$};

\path[->]
(t0.north) edge[bend left=30] node[above, yshift=3pt, xshift=-20pt, pos=0.3] {$\VIS, \AR$} (t1.west)
(t0.south) edge[bend right=30] node[below, yshift=-3pt, xshift=-20pt, pos=0.3] {$\VIS, \AR$} (t2.west)
([xshift=8pt]t1.south) edge[bend left=20] node[right] {$\AR$} ([xshift=8pt]t2.north);
\end{pgfonlayer}

\end{centertikz}
\vspace*{-5pt}
\caption{Abstract execution graph}
\label{fig:abstract_execution}
\end{halfsubfig} 
\vspace*{7pt}
\end{center}
\hrulefill

\caption{The dependency graph (\subref{fig:dependency-graph}) and abstract execution graph (\subref{fig:abstract_execution}) associated with the kv-store in \cref{fig:ser-disallowed}
}
\end{figure*}

\mypar{Relating KV-Stores and Abstract Executions}
\emph{Abstract executions} \cite{ev_transactions,framework-concur} are an alternative formalism for defining consistency models. 
As with dependency graphs, an abstract execution graph $\aexec$
is a directed graph with its nodes representing transactions (with each node labelled with a transaction identifier and a set of (read/write) operations), 
and its edges representing certain relations between transactions. 
An example abstract execution graph is depicted in \cref{fig:abstract_execution}. 
Each edge is labelled by either the \emph{visibility} ($\VIS$) or \emph{arbitration} ($\AR$) relation. 
The $\VIS$ is an irreflexive order on transactions such that $\txid_1 \xrightarrow{\VIS} \txid_2$ denotes that the effects (updates) of $\txid_1$ are visible to $\txid_2$. 
The $\AR$ is a strict total order on transactions such that $\txid_1 \xrightarrow{\AR} \txid_2$ denotes that the updates performed by $\txid_2$ are newer than those of $\txid_1$. 
Moreover, $\AR$ contains $\VIS$ ($\VIS \subseteq \AR$) and agrees with the session order.
Lastly, abstract executions observe the \emph{last-write-wins} policy: 
a transaction reading $\ke$ always fetches the latest visible write ($\VIS$ predecessor) on $\ke$.
We refer the reader to \cref{sec:abstract-execution} for full details.

Following \cite{laws}, we can always \emph{extract} a dependency graph $\Gr_{\aexec}$ from an abstract execution $\aexec$, and thus a kv-store $\hh_{\aexec}$ via \cref{thm:kv_graph_isomorph}---see \cref{app:aexec2kv} for the formal details.
We write  $\hh_\aexec$ for the kv-store extracted from $\aexec$ using this construction.  
Moreover, we show that there is a \emph{Galois connection}
between $\ET_{\top}$ traces, the weakest possible execution test and abstract executions (\cref{sec:galois-kv-aexec}).

As with dependency graphs, consistency models using abstract executions are defined by constraining the shape of abstract execution graphs via a set of \emph{axioms} $\Ax$, \eg imposing certain conditions on $\VIS$. %the absence of certain cycles.
All consistency models presented in this paper have an equivalent axiomatic definition based on abstract executions~\cite{framework-concur,laws}. 
Proving the equivalence of execution test-based and abstract execution-based definitions is non-trivial; 
however, we have observed that all proofs follow the same \emph{structure}, so long as certain conditions hold. 
We develop the meta-theory to capture this proof structure.
Our meta-theory is non-trivial; we refer the reader to \cref{sec:kv2aexec-sound-complete} for the full details. 
We give an intuitive account of the two conditions required by our meta-theory, and then state our equivalence theorem. 

Given a set of axioms $\Ax$, we define $\CMs(\Ax) \eqdef \{\hh_\aexec \mid \aexec \text{ sats.\ } \Ax \}$.
Our first condition is the \emph{soundness} of an execution test against an axiomatic definition.
An execution test $\ET$ is sound against an axiomatic definition $\Ax$ if:
for all $n$ and for all \( \ET \)-traces \( \tau \) with \( n \) steps, 
we can construct $\aexec_0, \cdots, \aexec_n$ and \( \mkvs_i = \mkvs_{\aexec_i} \) such that 
for each step \( (\mkvs_i, \vi_i) \csat \f_i : (\mkvs_{i+1}, \vi_{i+1}) \) in \( \tau \),
the new $\VIS$ edges in \( \aexec_{i+1} \) (those not in $\aexec_i$)
%, which links transactions included in the view \( \vi_i \) to the new transaction \( \txid_i \),
satisfy \( \Ax \).
The formal definition of execution test soundness is given in \cref{sec:kv2aexec-sound-complete}.
%
%\azalea{I don't think the intuitive description of soundness above is very clear...}

Our second condition is the \emph{completeness} of an execution test against an axiomatic definition.
Let $\txid_i$ denote the $i$\textsuperscript{th} transaction of $\aexec$ in its $\AR$ order, and $\aexec^{i}$ denote the restriction of $\aexec$ to $\txid_1 \cdots \txid_i$. 
An execution test $\ET$ is complete against an axiomatic definition $\Ax$ if:
for all abstract executions \( \aexec \) that satisfy \( \Ax \) containing $n$ transactions, 
all $i \in \{1 \cdots n\}$, views $\vi_i, \vi'_i$, transactions $\txid'$, and fingerprints $\opset_i$,
whenever
\begin{enumerate*}
	\item $\txid'$ is the immediate $\SO$-successor of $\txid_i$;
	\item \( \vi_i \) includes all visible transactions of \( \txid_i \); 
	\item $\vi'_i$ includes all visible transactions of $\txid'$; and
	\item $\opset_i$ is the fingerprint of $\txid_i$, 
\end{enumerate*} 
then $\ET \vdash (\mkvs_i, \vi_i) \csat \f_i : (\mkvs_{i+1}, \vi_{i+1})$.
The formal definition of execution test completeness is given in \cref{sec:kv2aexec-sound-complete}.
%
%\azalea{I don't think the intuitive description of completeness above is very clear...}

Finally, we state our equivalence theorem below (\cref{thm:main-body-et_soundness_completeness}), with its full proof in \cref{sec:kv2aexec-sound-complete}. 
This theorem ensures that if an execution test is sound and complete against a set of axioms $\Ax$, 
then the consistency model induced by $\ET$ corresponds to the kv-stores extracted from abstract executions satisfying $\Ax$.

\begin{theorem}
\label{thm:main-body-et_soundness_completeness}
For all $\ET, \Ax$, if $\ET$ is sound against $\Ax$, then:
\(
    \CMs(\ET) \subseteq \{ \hh_\aexec \mid \aexec \in \CMs(\Ax)\}
\).
For all $\ET, \Ax$, if $\ET$ is complete against $\Ax$, then:
\(
    \{ \hh_\aexec \mid \aexec \in \CMs(\Ax)\}  \subseteq \CMs(\ET)
\).
\end{theorem} 

In \cref{sec:spec-proof} we apply \cref{thm:main-body-et_soundness_completeness} and show all our definitions in \cref{fig:execution_tests} 
are sound and complete against (equivalent to) existing axiomatic definitions on abstract executions.
