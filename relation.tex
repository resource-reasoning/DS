\newcommand{\execs}{\ensuremath{\mathsf{Execs}}}

\section{KV-Stores and Other Formalisms}
\label{sec:other_formalisms}
%
%We give a formal account of the properties enjoyed by our operational 
%semantics. 
%First we investigate the compositionality of consistency models 
%induced by execution tests. Then 
In this Section, we discuss how kv-stores and execution 
tests relate to existing declarative formalisms for specifying  
consistency models, based on dependency graphs \cite{adya} 
and abstract executions \cite{framework-concur}. 
We give an overview of our results here, and refer the reader to the 
appendix for more details.

%\mypar{Compositionality}
%We examine the \emph{compositionality} of the  consistency models induced by execution tests:  
%\ie given two execution tests $\ET_1, \ET_2$, does 
%$\CMs(\ET_1 \cap \ET_2) = \CMs(\ET_1) \cap \CMs(\ET_2)$ hold? 
%It is straightforward to show that the left-to-right direction holds: for all $\ET_1, \ET_2$, \( \CMs(\ET_1 \cap \ET_2) \subseteq \CMs(\ET_1) \cap \CMs(\ET_2) \) 
%However, the other direction \( \CMs(\ET_1) \cap \CMs(\ET_2) \subseteq \CMs(\ET_1 \cap \ET_2) \) does not hold for arbitrary consistency models.
%Consider the following:
%\[
%\small
%\begin{array}{@{}l @{\hspace{2pt}} | @{\hspace{2pt}} l@{}}
%    \hline
%    \ET_1 & \ET_2 \\
%%    
%    \hline
%    (\hh_{0}, \vi_{0}) \csat\! \{(\otW, \ke, 1)\} {:} ( \hh_{\ke}, \vi_{0})
%    &
%    (\hh_{0}, \vi_{0}) \csat\! \{(\otW, \ke', 1)\} {:} ( \hh_{\ke'}, \vi_{0}) 
%    \vspace{-5pt}\\\\
%% %   
%    (\hh_{\ke}, \vi_{0}) \csat  \!\{(\otW, \ke', 1)\} {:} (\hh',\vi_{0}) 
%    &
%    (\hh_{\ke'}, \vi_{0}) \csat \!\{(\otW, \ke, 1)\} {:} (\hh',\vi_{1}) 
%    \\
%\hline
%\end{array}
%\]
%with 
%\begin{align*}
%    \hh_{\ke} & = \hh_{0}[\ke \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \_, \emptyset)] \\
%    \hh_{\ke'} & = \hh_{0}[\ke' \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \_, \emptyset)] \\
%    \hh' & = \hh[\ke \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \_, \emptyset) 
%                ,\ke' \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \_, \emptyset)] \\
%\end{align*}
%As both $\ET_1$ and $\ET_2$ allow a version with value $1$ to be written for 
%$\ke, \ke'$,  we have $\hh' \in \CMs(\ET_1) \cap \CMs(\ET_2)$. 
%However, $\ET_1$ and $\ET_2$ enforce a different order in which the updates on $\ke, \ke'$ must happen; 
%thus $\hh' \notin \CMs(\ET_1 \cap \ET_2)$. 
%
%In this example, compositionality fails because execution tests 
%enforced a particular order in which the updates must be committed, even though such updates 
%are non-conflicting: \ie the kv-store obtained after committing such updates is independent of the commit order. This observation is captures in the following definition: 
%\begin{definition}
%Two fingerprints $\opset_1$ and $\opset_2$ are \emph{conflicting} 
%iff there exists $\ke$ such that 
%$(\otW, \ke, -) \in \opset_1 \land (\otW, \ke, -) \in \opset_2$. 
%
%An execution test $\ET$ is \emph{commutative}, written $\com{\ET}$, if 
%for all views $\vi_1, \vi_2 \in \Views(\hh_0)$, 
%clients $\cl_1, \cl_2$,
%fingerprints $\opset_1, \opset_2$, 
%kv-stores $\hh'$,
%and view functions $\viewFun, \viewFun'$:
%\[
%\begin{array}{@{}r @{\hspace{10pt}} l @{}}
%	\text{if} &  
%	(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} 
%	\_ \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} (\hh', \viewFun') \\
%	& \land\ \cl_1 \ne \cl_2 \land \opset_1, \opset_2  \text{ are non-conflicting}\\
%%
%%	
%	\text{then} & (\hh_0, \viewFun) \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} 
%\_ \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} (\hh', \viewFun')
%\end{array}
%\]
%\end{definition}
%
%Commutativity is a necessary, but not sufficient condition for recovering
%the desired compositionality result.
%To recover compositionality, we further require that an execution test have \emph{no blind writes}, 
%\emph{minimal footprint} and \emph{monotonic post-view} (\cref{def:et_properties}).
%We refer the reader to \cref{sec:counter-examples-composition} for counter examples demonstrating why these conditions are necessary.
%
%
%\begin{definition}[$\ET$ properties]
%\label{def:et_properties}
%An execution test $\ET$ has \emph{no blind writes} if
%for all $\hh, \hh', \vi, \vi', \opset, \ke$:
%\[
%\begin{array}{@{} r @{\hspace{10pt}} l @{}}
%\text{if} & \ET \vdash (\hh, \vi) \triangleright \opset: (\hh',\vi' ) 
%\text{and} (\otW, \ke, \_) \in \opset \\
%\text{then} & (\otR, \ke, \_) \in \opset
%\end{array} 
%\]
%An execution test $\ET$ has a \emph{minimum footprint} if for all kv-stores $\hh, \hh'$,
%views $\vi, \vi',\vi''$, and fingerprints $\f$: 
%%
%\[
%\begin{array}{@{} r @{\hspace{10pt}} l @{}}
%    \text{if} & \ET \vdash (\hh, \vi) \triangleright \opset : (\hh', \vi'')  \\
%    \text{and} & \fora{(\stub, \ke, \stub) \in \f} \vi(\ke) {=} \vi'(\ke) \\
%    \text{then} & \ET \vdash (\hh, \vi') \triangleright \opset : (\hh', \vi'')
%\end{array} 
%\]
%%
%An execution test $\ET$ has \emph{monotonic post-views} if 
%for all kv-stores $\hh,\hh'$, 
%views $\vi, \vi',\vi''$ and fingerprints $\f$:
%\[
%\begin{array}{@{} r @{\hspace{10pt}} l @{}}
%    \text{if} & \ET \vdash (\hh, \vi) \triangleright \opset : (\hh',\vi' )
%    \text{ and } \vi' \sqsubseteq \vi''  \\
%    \text{then} & \ET \vdash (\hh, \vi) \triangleright \opset : (\hh',\vi'')
%\end{array} 
%\]
%\end{definition}
%The first two requirements ensure that, in an $\ET$-trace 
%terminates in a configuration $(\hh, \stub)$, 
%the set of client views used to commit a transaction can uniquely determined by $\hh$. 
%If $\ET_1, \ET_2$ have monotonic post-views, then there exists at least one common post-view 
%that can be obtained after a client commits $\f$ to $(\hh, \vi)$ using $\ET_1$ and $\ET_2$. 
%
%\begin{theorem}[Compositionality]     
%For all $\ET_1, \ET_2$ with no blind writes, minimum footprints and monotonic post-views: 
%if $\com{\ET_1}$, 
%then $\CMs(\ET_1 \cap \ET_2) {=} \CMs(\ET_1) \cap \CMs(\ET_2)$;
%if $\com{\ET_1} \land \com{\ET_2}$, then $\com{\ET_1 \cap \ET_2}$.
%\end{theorem}
%
%Most of the execution tests in \cref{fig:execution_tests} can be minimally adapted to satisfy these 
%properties, without excluding any anomalous (weak) behaviour. However, the definitions 
%of $\ET_{\SI}$ and $\ET_{\CP}$ are inherently non-commutative (counter example in \cref{sec:comm-counter-cp-si}), which also motivates 
%why $\ET_{\UA} \cap \ET_{\CP}$ is not an appropriate execution test for Snapshot Isolation.

\mypar{Relating KV-Stores and Dependency Graphs}
Dependency graphs \cite{adya-icde,adya} are perhaps the most popular 
formalism used for specifying transactional consistency models. 
A dependency graph $\Gr$ is a directed, labelled graph where its
nodes denote transactions and its edges denote certain \emph{dependencies} between transactions.  
An example dependency graph is given in \cref{fig:dependency-graph}.
Each node is labelled with a transaction identifier and a fingerprint.
Each edges is labelled with metadata describing the information flow in a run of the database: 
%\footnote{Dependency graphs additionally record a session order between transactions, corresponding to our session order $\SO$ in \cref{subsec:kvstores}.}:
\begin{enumerate*}
    \item a \emph{session order} edge, $\txid_1 \xrightarrow{\SO} \txid_2$, 
	\item a \emph{read dependency} edge, $\txid_1 \xrightarrow{\WR} \txid_2$, denotes
that transaction $\txid_2$ reads a version written by $\txid_1$;
	\item a \emph{write dependency} edge, $\txid_1 \xrightarrow{\WW} \txid_2$, denotes that $\txid_2$ overwrites a version written by $\txid_1$; and 
	\item an \emph{anti-dependency} edge, $\txid_1 \xrightarrow{\RW} \txid_2$, denotes that $\txid_2$ overwrites a version read by $\txid_2$. 
\end{enumerate*}
We give the formal definition of dependency graphs in \cref{app:depgraphs}.
Observe that we can always \emph{extract} a dependency graph  $\Gr$ from a kv-store $\hh$:
we choose the transaction identifiers appearing in $\hh$ as the nodes of $\Gr$, 
and let $\SO$ as defined in \cref{subsec:kvstores}, and $ \RF, \VO, \AD$  
%$\RF_{\hh}, \VO_{\hh}, \AD_{\hh}$ 
be as defined in \cref{fig:execution_tests}.
For example, \cref{fig:counter_kv_final} corresponds to the dependency graph extracted from the kv-store in \cref{fig:counter_kv_final}.
In \cref{app:depgraphs} we show that this construction can be reversed, thus giving 
rise to the following result: 
\begin{theorem}
\label{thm:kv_graph_isomorph}
Dependency graphs are isomorphic to kv-stores.
\end{theorem}

Using dependency graphs, consistency models are specified by constraining the shape of the graph; typically, such constraints mandate the absence of certain cycles. For example, strict serialisability is defined as those dependency graphs where $(\SO \cup \WW \cup \WR \cup \RW)^+$ is acyclic. 
We can always convert a dependency graph-based specification into an execution test-based one by simply checking that, when committing a transaction to kv-store $\hh$ and obtaining $\hh'$, 
the dependency graph extracted from $\hh'$ contains no cycles prohibited by the dependency graph-based specification. 

\begin{figure*}[t]
\begin{center}
\begin{halfsubfig} 
\begin{center}
\begin{tikzpicture}[scale=0.85, every node/.style={transform shape}]

\node(t0wx) at (-1,2) {$(\otW, \ke_1, \val_0)$}; 
\path (t0wx.east) + (1,0) node (t0wy) {$(\otW, \ke_2, \val'_0)$};
\path (t0wx.north east) + (2.5,0.5) node[anchor = west] (t1ry) {$(\otR, \ke_2, \val'_0)$}; 
\path (t1ry.east) + (0.2,0) node[anchor = west] (t1wx) {$(\otW, \ke_1, \val_1)$};
\path (t0wx.south east) + (2.5,-0.5) node[anchor = west] (t2rx) {$(\otR, \ke_1, \val_0)$};
\path (t2rx.east) + (0.2,0) node[anchor = west] (t2wy) {$(\otW, \ke_2, \val'_1$)};

\begin{pgfonlayer}{background}
\node[background, fit=(t0wx) (t0wy),inner ysep=3pt, inner xsep=6pt] (t0) {};
\node[background, fit= (t1ry) (t1wx),inner ysep=3pt, inner xsep=6pt] (t1) {};
\node[background, fit= (t2rx) (t2wy),inner ysep=3pt, inner xsep=6pt] (t2) {};

\path(t0.west) node[anchor=east] (t0lbl) {$\txid_0$};
\path(t1.north) node[anchor=south] (t1lbl) {$\txid_1$};
\path(t2.south) node[anchor=north] (t2lbl) {$\txid_2$};

\path[->]
(t0.north) edge[bend left=30] node[above, yshift=3pt, xshift=-20pt, pos=0.3] {$\RF, \VO$} (t1.west)
(t0.south) edge[bend right=30] node[below, yshift=-3pt, xshift=-20pt, pos=0.3] {$\RF, \VO$} (t2.west)
([xshift=-8pt]t2.north) edge[bend left=20] node[left] {$\AD$} ([xshift=-8pt]t1.south) 
([xshift=8pt]t1.south) edge[bend left=20] node[right] {$\AD$} ([xshift=8pt]t2.north);
\end{pgfonlayer}

\end{tikzpicture}
\end{center}
\vspace*{-10pt}
\caption{Dependency graph}
\label{fig:dependency-graph}
\end{halfsubfig} 
%
\begin{halfsubfig} 
\begin{center}
\begin{tikzpicture}[scale=0.85, every node/.style={transform shape}]

\node(t0wx) at (-1,2) {$(\otW, \ke_1, \val_0)$}; 
\path (t0wx.east) + (1,0) node (t0wy) {$(\otW, \ke_2, \val'_0)$};
\path (t0wx.north east) + (2.5,0.5) node[anchor = west] (t1ry) {$(\otR, \ke_2, \val'_0)$}; 
\path (t1ry.east) + (0.2,0) node[anchor = west] (t1wx) {$(\otW, \ke_1, \val_1)$};
\path (t0wx.south east) + (2.5,-0.5) node[anchor = west] (t2rx) {$(\otR, \ke_1, \val_0)$};
\path (t2rx.east) + (0.2,0) node[anchor = west] (t2wy) {$(\otW, \ke_2, \val'_1$)};

\begin{pgfonlayer}{background}
\node[background, fit=(t0wx) (t0wy),inner ysep=3pt, inner xsep=6pt] (t0) {};
\node[background, fit= (t1ry) (t1wx),inner ysep=3pt, inner xsep=6pt] (t1) {};
\node[background, fit= (t2rx) (t2wy),inner ysep=3pt, inner xsep=6pt] (t2) {};

\path(t0.west) node[anchor=east] (t0lbl) {$\txid_0$};
\path(t1.north) node[anchor=south] (t1lbl) {$\txid_1$};
\path(t2.south) node[anchor=north] (t2lbl) {$\txid_2$};

\path[->]
(t0.north) edge[bend left=30] node[above, yshift=3pt, xshift=-20pt, pos=0.3] {$\VIS, \AR$} (t1.west)
(t0.south) edge[bend right=30] node[below, yshift=-3pt, xshift=-20pt, pos=0.3] {$\VIS, \AR$} (t2.west)
([xshift=8pt]t1.south) edge[bend left=20] node[right] {$\AR$} ([xshift=8pt]t2.north);
\end{pgfonlayer}

\end{tikzpicture}
\end{center}
\vspace*{-10pt}
\caption{Abstract execution graph}
\label{fig:abstract_execution}
\end{halfsubfig} 
\end{center}
\hrulefill
\captionsetup{width=\linewidth}
\caption{The dependency graph (\subref{fig:dependency-graph}) and abstract execution graph (\subref{fig:abstract_execution}) associated with the kv-store in \cref{fig:ser-disallowed}
}
\vspace*{-10pt}
\end{figure*}

%\begin{definition}
%A \emph{dependency graph} is a quadruple $\Gr = (\TtoOp{T}, \RF, \VO, \AD)$, where
%\begin{itemize}
%\item 
%    $\TtoOp{T}_0: \TxID_0 \parfinfun \powerset{\Ops}$ is a partial finite mapping from transaction identifiers 
%    to the set of operations, where there are at most one read operation and one write operation per key;
%\item 
%    $\RF : \Keys \to \pset{\dom(\TtoOp{T}) \times \dom(\TtoOp{T})}$ is a function that 
%maps each key $\ke$ into a relation between transactions, such that for any $\txid, \txid_1, \txid_2, 
%\ke, \cl, m, n$: 
%\begin{itemize}
%\item if $(\otR, \ke, \val) \in \TtoOp{T}(\txid)$, either $\val = \val_0$ 
%and there exists no $\txid'$ such that $\txid' \xrightarrow{\RF(\ke)} \txid$,  
%or there exists $\txid'$ such that $(\otW, \ke, \val) \in \TtoOp{T}(\txid')$, and $\txid' \xrightarrow{\RF(\ke)} \txid$, 
%\item if $\txid_1 \xrightarrow{\RF(\ke)} \txid$ and $\txid_2 \xrightarrow{\RF(\ke)} \txid$, then 
%$\txid_2 = \txid_1$.
%\item if $\txid_{\cl}^{m} \xrightarrow{\RF(\ke)} \txid_{\cl}^{n}$, then $m < n$.
%\end{itemize}
%\item $\VO: \Keys \to \pset{\dom(\TtoOp{T}) \times \dom(\TtoOp{T})}$ is a function 
%that maps each key into an irreflexive relation between transactions, such that for any $\txid, \txid', \ke, \cl, m, n$, 
%\begin{itemize}
%\item if $\txid \xrightarrow{\VO(\ke)} \txid'$, then $(\otW, \ke, \_) \in \TtoOp{T}(\txid), (\otW, \ke, \_) \in \TtoOp{T}(\txid')$, 
%\item if $(\otW, \ke, \_) \in \TtoOp{T}(\txid), (\otW, \ke, \_) \in \TtoOp{T}(\txid')$, then either $\txid = \txid'$, 
%$\txid \xrightarrow{\VO(\ke)} \txid'$, or $\txid' \xrightarrow{\VO(\ke)} \txid$.
%\item if $\txid_{\cl}^{m} \xrightarrow{\WW(\ke)} \txid_{\cl}^{n}$, then $m < n$.
%\end{itemize}
%\item $\AD: \Keys \to \pset{\dom(\TtoOp{T}) \times \dom(\TtoOp{T})}$ is defined 
%by letting $\txid \xrightarrow{\AD(\ke)} \txid'$ if and only if $(\otR, \ke, \_) \in \TtoOp{T}(\txid)$, 
%$(\otW, \ke, \_) \in \TtoOp{T}(\txid')$ and 
%either there exists no $\txid''$ such that $\txid'' \xrightarrow{\RF(\ke)} \txid$, or 
%$\txid'' \xrightarrow{\RF(\ke)} \txid$, $\txid'' \xrightarrow{\VO(\ke)} \txid'$ for 
%some $\txid''$.
%\end{itemize}
%\end{definition}
%Given a dependency graph $\Gr = (\TtoOp{T}, \RF, \VO, \AD)$, we often 
%commit an abuse of notation and use $\RF$ to denote the relation 
%$\bigcup\limits_{\ke \in \Keys} \RF(\ke)$; a similar notation is adopted for $\VO, \AD$. 
%It will always be clear from the context whether the symbol $\RF$ refers to a function 
%from keys to relations, or to a relation between transactions. 
%
%We let $\Dgraphs$ be the set of all dependency graphs.
%It is always possible to convert a kv-store $\hh$ into a well-formed dependency 
%graph. For example, \cref{fig:dependency-graph} is the dependency graph 
%that illustrates scenario similar with the key-value store in \cref{fig:hheap-a}.
%
%\begin{definition}
%\label{def:main-body-kv2graph}
%Given a kv-store $\hh$, the \emph{dependency graph} $\Gr_{\hh} = (\TtoOp{T}_{\hh}, \RF_{\hh}, 
%\VO_{\hh}, \AD_{\hh})$ is defined as follows: 
%\begin{itemize}
%\item for any $\txid \neq \txid_0$, $\TtoOp{T}_{\hh}(\txid)$ is defined if and only if there exists an index $i$ and a key 
%$\ke$ such that either $\txid = \WTx(\hh(\ke, i))$, or $\txid \in \RTx(\hh(\ke,i))$; furthermore, 
%$(\otW, \ke, \val) \in \TtoOp{T}(\txid)$ if and only 
%if $\txid = \WTx(\hh(\ke, i))$ for some $i$, and 
%$(\otR, \ke, \val) \in \TtoOp{T}(\txid)$ if and only if $\txid \in \RTx(\hh(\ke, i))$ for some $i$, 
%\item $\txid \xrightarrow{\RF(\ke)} \txid'$ if and only if there exists an index $i: 0 < i < \lvert \hh(\ke) \rvert$ 
%such that $\txid = \WTx(\hh(\ke, i))$, and $\txid' \in \RTx(\hh(\ke, i))$, 
%\item $\txid \xrightarrow{\VO(\ke)} \txid'$ if and only if there exist two indexes $i,j$: $0 < i < j < \lvert \hh(\ke) \rvert$ 
%such that $\txid = \WTx(\ke, i)$, $\txid' = \WTx(\ke, j)$, 
%\item $\txid \xrightarrow{\AD(\ke)} \txid'$ if and only if there exist two indexes $i,j$: $0 < i < j < \lvert \hh(\ke) \rvert$ 
%such that $\txid \in \RTx(\ke, i)$ and $\txid' = \WTx(\ke, j)$.
%\end{itemize}
%\end{definition}

%\begin{theorem}
%\label{thm:main-body-kv2graph}
%\label{thm:dependency-graph-kv-store}
%There is a one-to-one correspondence between key-value stores and dependency graphs.
%\end{theorem}
%%\begin{proof}
%%    See \cref{thm:kv2graph} in \cref{sec:dependent-graph}.
%%\end{proof}
%\subsection{Azalea's Version}
\mypar{Relating KV-Stores and Abstract Executions}
\emph{Abstract executions} \cite{ev_transactions,framework-concur} are an alternative formalism for defining consistency models. 
As with dependency graphs, an abstract execution graph $\aexec$
is a directed graph with its nodes representing transactions (with each node labelled with a transaction identifier and a set of (read/write) operations), 
and its edges representing certain relations between transactions. 
An example abstract execution graph is depicted in \cref{fig:abstract_execution}. 
Each edge is labelled by either the \emph{visibility} ($\VIS$) or \emph{arbitration} ($\AR$) relation. 
The $\VIS$ is an irreflexive order on transactions such that $\txid_1 \xrightarrow{\VIS} \txid_2$ denotes that the effects (updates) of $\txid_1$ are visible to $\txid_2$. 
The $\AR$ is a strict total order on transactions such that $\txid_1 \xrightarrow{\AR} \txid_2$ denotes that the updates performed by $\txid_2$ are newer than those of $\txid_1$. 
Moreover, $\AR$ contains $\VIS$ ($\VIS \subseteq \AR$) and agrees with the session order.
Lastly, abstract executions observe the \emph{last-write-wins} policy: 
a transaction reading $\ke$ always fetches the latest visible write ($\VIS$ predecessor) on $\ke$.
We refer the reader to \cref{sec:abstract-execution} for full details.

Following \cite{laws}, we can always \emph{extract} a dependency graph $\Gr_{\aexec}$ from an abstract execution $\aexec$, and thus a kv-store $\hh_{\aexec}$ via \cref{thm:kv_graph_isomorph}---see \cref{app:aexec2kv} for the formal details.
We write  $\hh_\aexec$ for the kv-store extracted from $\aexec$ using this construction.  
Moreover, we show that there is a \emph{Galois connection}
between $\ET_{\top}$ traces, the weakest possible execution test and abstract executions (\cref{sec:galois-kv-aexec}).

As with dependency graphs, consistency models using abstract executions are defined by constraining the shape of abstract execution graphs via a set of \emph{axioms} $\Ax$, \eg imposing certain conditions on $\VIS$. %the absence of certain cycles.
All consistency models presented in this paper have an equivalent axiomatic definition based on abstract executions~\cite{framework-concur,laws}. 
Proving the equivalence of execution test-based and abstract execution-based definitions is non-trivial; 
however, we have observed that all proofs follow the same \emph{structure}, so long as certain conditions hold. 
We develop the meta-theory to capture this proof structure.
Our meta-theory is non-trivial; we refer the reader to \cref{sec:kv2aexec-sound-complete} for the full details. 
We give an intuitive account of the two conditions required by our meta-theory, and then state our equivalence theorem. 

Given a set of axioms $\Ax$, we define $\CMs(\Ax) \eqdef \{\hh_\aexec \mid \aexec \text{ sats.\ } \Ax \}$.
Our first condition is the \emph{soundness} of an execution test against an axiomatic definition.
An execution test $\ET$ is sound against an axiomatic definition $\Ax$ if:
for all $n$ and for all \( \ET \)-traces \( \tau \) with \( n \) steps, 
we can construct $\aexec_0, \cdots, \aexec_n$ and \( \mkvs_i = \mkvs_{\aexec_i} \) such that 
for each step \( (\mkvs_i, \vi_i) \csat \f_i : (\mkvs_{i+1}, \vi_{i+1}) \) in \( \tau \),
the new $\VIS$ edges in \( \aexec_{i+1} \) (those not in $\aexec_i$)
%, which links transactions included in the view \( \vi_i \) to the new transaction \( \txid_i \),
satisfy \( \Ax \).
The formal definition of execution test soundness is given in \cref{sec:kv2aexec-sound-complete}.
%
%\azalea{I don't think the intuitive description of soundness above is very clear...}

Our second condition is the \emph{completeness} of an execution test against an axiomatic definition.
Let $\txid_i$ denote the $i$\textsuperscript{th} transaction of $\aexec$ in its $\AR$ order, and $\aexec^{i}$ denote the restriction of $\aexec$ to $\txid_1 \cdots \txid_i$. 
An execution test $\ET$ is complete against an axiomatic definition $\Ax$ if:
for all abstract executions \( \aexec \) that satisfy \( \Ax \) containing $n$ transactions, 
all $i \in \{1 \cdots n\}$, views $\vi_i, \vi'_i$, transactions $\txid'$, and fingerprints $\opset_i$,
whenever
\begin{enumerate*}
	\item $\txid'$ is the immediate $\SO$-successor of $\txid_i$;
	\item \( \vi_i \) includes all visible transactions of \( \txid_i \); 
	\item $\vi'_i$ includes all visible transactions of $\txid'$; and
	\item $\opset_i$ is the fingerprint of $\txid_i$, 
\end{enumerate*} 
then $\ET \vdash (\mkvs_i, \vi_i) \csat \f_i : (\mkvs_{i+1}, \vi_{i+1})$.
The formal definition of execution test completeness is given in \cref{sec:kv2aexec-sound-complete}.
%
%\azalea{I don't think the intuitive description of completeness above is very clear...}

Finally, we state our equivalence theorem below (\cref{thm:main-body-et_soundness_completeness}), with its full proof in \cref{sec:kv2aexec-sound-complete}. 
This theorem ensures that if an execution test is sound and complete against a set of axioms $\Ax$, 
then the consistency model induced by $\ET$ corresponds to the kv-stores extracted from abstract executions satisfying $\Ax$.

\begin{theorem}
\label{thm:main-body-et_soundness_completeness}
For all $\ET, \Ax$, if $\ET$ is sound against $\Ax$, then:
\(
    \CMs(\ET) \subseteq \{ \hh_\aexec \mid \aexec \in \CMs(\Ax)\}
\).
For all $\ET, \Ax$, if $\ET$ is complete against $\Ax$, then:
\(
    \{ \hh_\aexec \mid \aexec \in \CMs(\Ax)\}  \subseteq \CMs(\ET)
\).
\end{theorem} 

In \cref{sec:spec-proof} we apply \cref{thm:main-body-et_soundness_completeness} and show all our definitions in \cref{fig:execution_tests} 
are sound and complete against (equivalent to) existing axiomatic definitions on abstract executions.
