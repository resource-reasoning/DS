\subsubsection{Verification}

\paragraph{\bf Structure}
We model the database use key-value store from \cref{def:mkvs},
yet here it is necessary to satisfy the well-formed conditions.
Transaction identifier \( \txid_\cl^n \) are labelled with the committing time \( n \).
Sometime we also write \( \txid_\cl^\ct \) or omit the client label, \ie \( \txid^n\) and \( \txid^\ct \).

Database is partitioned into several \emph{shards}.
A shard \(\sd \in \Shards \)  contains some keys which are disjointed from keys in other shards.
The \( \func{shardOf}{\key} \) denotes the shard where the key \( \key \) locates.

Shards and clients are associated with clock times, \(  \ct \in \ClockTimes \defeq \Nat \), which represent the current times of shards and clients.
We use notation \( \cts \in (\Shards \cup \Clients ) \parfinfun \ClockTimes\).

We will use notation \( \ptrans{\trans} \) to denote the static code of a transaction,
and \( \runtrans{\trans}{\ct}{\fp} \) for the runtime of a transaction,
where \( \ct \)  is the snapshot time and \( \fp \) is the read-write set.
Note that in the model, we only distinguishes \verb|active| and \verb|committed| state,
since the \verb|prepared| and \verb|committing| are only for better performance.

\paragraph{\bf Start Transaction}
To start a transaction, it picks a random shard \( \sd \) as the coordinator,
reads the local time \( \cts(\sd) \) as the snapshot,
and sets the initial read-write set to be an empty set.
Also the client time is updated to the snapshot time.
For technical reason,
we also update the shard time to avoid time collision to other transaction about to commit.
Note that in real life, all the operations running in a shard take many time cycles,
so it is impossible to have time collision.
\[
    \inferrule[StartTrans]{ 
        \ct < \cts(\sd) \and 
        \cts' = \cts\rmto{\sd}{\cts(\sd) + 1} \quad \texttt{--->  simulate time elapses}
        }{%
            \cl \vdash \mkvs, \ct, \cts, \stk, \ptrans{\trans} \toT{\cts(\sd), \ct, \emptyset, \perp}
            \mkvs, \cts(\sd), \cts', \stk, \runtrans{\trans}{\cts(\sd)}{\emptyset}
        }
\]

\paragraph{\bf Read}
The clock-SI protocol includes some codes related to performance which does not affect the correctness.
Clock-SI distinguishes a local read/commit and a remote read/commit,
yet it is sufficient to assume all the read and commit are ``remote'',
while the local read and commit can be treated as self communication.
Similarly we assume a transaction always commits to several shards.
\begin{lstlisting}[caption={simplified read},label={lst:simplified-read}]
On receive ``read(t,k)'' {
    if ( k in t.ws ) return ws(k); (*\label{line:read-from-local}*)

    asssert( t.snapshotTime < getClockTime() ) (*\label{line:snapshot-time-grt-than-shard}*)
    for t' that writes to k:
        if(t.snapshotTime > t'.preparedTime 
                    || t.snapshotTime > t'.committingTime) 
            asssert( t.state == committed )

    return K(k,i), where i is the latest version before t.snapshotTime; (*\label{line:read-i-from-shard}*)
}
\end{lstlisting}

If the key exists in the write set \( \fp \),
the transaction read from the write set immediately.
\[
    \inferrule[ReadTrans]{ 
            \key = \evalE{\expr} \\
            (\otW, \key, \val ) \in \fp \quad \texttt{---> \cref{lst:simplified-read}, \cref{line:read-from-local}}\\
        }{%
        \cl \vdash \mkvs, \ct, \cts, \stk, \runtrans{\pderef{\vx}{\expr}}{\ct}{\fp} \toT{\cl,\ct,\fp \addO (\otR, \key, \val),\perp}
            \mkvs, \ct, \cts, \stk\rmto{\vx}{\val}, \runtrans{\pskip}{\ct}{\fp \addO (\otR, \key, \val)}
        }
\]

Otherwise, the transaction needs to fetch the value from the shard.
The first premiss says the transaction must wait until the shard local time \( \cts(\func{shardOf}{\key}) \) is greater than the snapshot time \( \ct \).
If so, by the second line, the transaction fetches the latest version for key \( \key \) before the snapshot time \( \ct \).
\[
    \inferrule[ReadRemote]{ 
            \key = \evalE{\expr} \\
            (\otW, \key, \stub ) \notin \fp \\
            \ct < \cts(\func{shardOf}{\key}) \quad \texttt{---> \cref{lst:simplified-read}, \cref{line:snapshot-time-grt-than-shard}} \\\\
            n = \max\Setcon{n'}{ \exsts{j} \txid^{n'} = \WTx(\mkvs(\key, j)) \land n' < \ct } \quad \texttt{---> \cref{lst:simplified-read}, \cref{line:read-i-from-shard}} \\\\ 
            \mkvs(\key, i) = (\val, \txid^n, \stub) 
        }{%
        \cl \vdash \mkvs, \ct, \cts, \stk, \runtrans{\pderef{\vx}{\expr}}{\ct}{\fp} \toT{\cl,\ct,\fp \addO (\otR, \key, \val), \perp}
            \mkvs, \ct, \cts', \stk\rmto{\vx}{\val}, \runtrans{\pskip}{\ct}{\fp \addO (\otR, \key, \val)}
        }
\]

\paragraph{\bf Write}
Write will not go to the shard until committing time.
Before it only log it in the write set.
\[
    \inferrule[Write]{ 
            \key = \evalE{\expr_1} \\
            \val = \evalE{\expr_2} \\
        }{%
            \cl \vdash \mkvs, \ct, \cts, \stk, \runtrans{\pmutate{\expr_1}{\expr_2}}{\ct}{\fp} \toT{\cl,\ct,\fp \addO (\otW, \key, \val), \perp}
            \mkvs, \ct, \cts, \stk, \runtrans{\pskip}{\ct}{\fp \addO (\otW, \key, \val)}
        }
\]

\paragraph{\bf Commit}
We also assume transaction always commit to several shards and the local commit is treated as self-communication.

\begin{lstlisting}[caption={simplified commit},label={lst:simplified-commit}]
commit( Trans t )
    for p in t.updatedPartitions
        send ``prepare t'' to p;
    wait receiving ``t prepared'' from all participants, store into prep; (*\label{line:pick-time-1}*)
    t.state = committing; (*\label{line:pick-time-2}*)
    t.commitTime = max(prep); (*\label{line:pick-time-3}*)
    log t.commitTime;
    t.state = committed;
    for p in t.updatedPartitions
        send ``commit t'' to p;

On receiving ``prepare t''
    if noConcurrentWrite(t) (*\label{line:check-concur-write}*)
        log t.ws to t.coordinator ID
        t.state = prepared;
        t.prepareTime = getClockTime();
        send ``t prepared'' to t.coordinator

On receiving ``commit t''
    log t.commitTime (*\label{line:clock-si-commit-1}*)
    t.state = committed  (*\label{line:clock-si-commit-2}*)
\end{lstlisting}

Note that Clock-SI uses two phase commit:
the coordinator (the shard that the client directly connects to) distinguishes ``committing'' state  and ``committed'' state, where in between the coordinator pick the committing time and log the write set,
and the participants distinguishes ``prepared'' state and ``committed'' state.
Such operations are for possible network partition or single shard errors, and allowed a more fine-grain implementations which do not affect the correctness,
therefore it suffices to assume they are one atomic step.

\[
    \inferrule[Commit]{ 
        \fora{\key,i} (\otW, \key, \stub) \in \fp \land \WTx(\mkvs(\key,i)) < \ct \quad \texttt{---> \cref{lst:simplified-commit}, \cref{line:check-concur-write}} \\\\  
        n = \max\left( \Setcon{\ct'}{\exsts{\key} (\stub, \key, \stub) \in \fp \land \ct' = \cts(\func{shardOf}{\key})} \cup \Set{\ct} \right) \quad \texttt{---> \cref{lst:simplified-commit}, \cref{line:pick-time-1,line:pick-time-2,line:pick-time-3}} \\\\
        \mkvs' =  \func{commitKV}{\mkvs,\ct,\txid_\cl^n,\fp} \quad \texttt{---> \cref{lst:simplified-commit}, \cref{line:clock-si-commit-1,line:clock-si-commit-2}} \\\\
        \fora{\sd}
        {\left( \begin{array}{@{}l@{}}
            \sd \in \Setcon{\func{shardOf}{\key}}{(\stub, \key, \stub) \in \fp} \\
            \quad \implies \cts'(\sd) = \cts(\sd) + 1 
        \end{array} \right)} \lor (\cts'(\sd) = \cts(\sd)) \quad \texttt{--->  simulate time elapses}
        }{%
            \sd, \cl \vdash \mkvs, \ct, \cts, \stk, \runtrans{\pskip}{\ct}{\fp} \toT{\cl,\ct,\fp,n}
            \mkvs', n+1, \cts', \stk, \pskip
        }
\]

To commit the new transaction, it needs to check, by the first premiss,
there is no other transactions writing to the same keys after the snapshot time.
If it passes, by the second line it picks the maximum time \( n \) among all participants
as the commit time.
The new key-value store \( \mkvs' =  \func{commitKV}{\mkvs,\ct,\txid_\cl^n,\fp} \),
where 
\[
\begin{rclarray}
    \func{commitKV}{\mkvs,\ct,\txid,\fp \uplus \Set{(\otR,\key,\val)}} & \defeq & 
    \begin{array}[t]{@{}l@{}}
    \texttt{let} \ n = \max\Setcon{n'}{ \exsts{j} \txid^{n'} = \WTx(\mkvs(\key, j)) \land n' < \ct } \\
    \texttt{and} \ \mkvs(\key,i) = (\val, \txid^n, \T) \\
    \texttt{and} \ \mkvs' = \func{commitKV}{\mkvs,\ct,\txid,\fp} \\
    \texttt{in} \ \mkvs'\rmto{\key}{\mkvs'(\key)\rmto{i}{(\val, \txid^n, \T \cup \Set{\txid})}}
    \end{array} \\
    \func{commitKV}{\mkvs,\ct,\txid,\fp \uplus \Set{(\otW,\key,\val)}} & \defeq & 
    \begin{array}[t]{@{}l@{}}
    \texttt{let} \ \mkvs' = \func{commitKV}{\mkvs,\ct,\txid,\fp} \\
    \texttt{in} \ \mkvs'\rmto{\key}{\mkvs'(\key) \lcat \List{(\val, \txid, \emptyset)}}
    \end{array} \\
\end{rclarray}
\]
Note that \( \func{commitKV} \) is similar to \( \updateKV \) by appending the new version to the end of a list.
The \( \func{commitKV} \) also updates versions read by the new transaction 
using the snapshot time of the transaction.
Last, like \rl{StartTrans} 
we update the client time after the commit time, \ie \( n + 1 \) 
and simulate time elapses for all shards updated.

\paragraph{\bf Time Tick}
For technical reasoning, we have non-deterministic time elapses.
\[
    \inferrule[TimeTick]{ }{%
        \mkvs, \cts, \cts', \thdenv, \prog \toG{\sd,\cts(\sd) + 1}
        \mkvs, \cts, \cts'\rmto{\sd}{\cts(\sd) + 1}, \thdenv, \prog
    }
\]

\[
    \inferrule[ClientStep]{ 
            \cl \vdash 
            \mkvs, \cts(\cl), \cts', \thdenv(\cl), \prog(\cl) \toT{\cl,\ct',\fp,\ct''}
            \mkvs', \ct, \cts'', \stk, \cmd
        }{%
            \mkvs, \cts, \cts', \thdenv, \prog \toG{\cl,\ct',\fp,\ct''}
            \mkvs, \cts\rmto{\cl}{\ct}, \cts'', \thdenv\rmto{\cl}{\stk}, \prog\rmto{\cl}{\cmd}
        }
\]

\paragraph{\bf Verification}
Clock-SI allows interleaving, 
yet for any clock-si trace \( \tr \) there exists a equivalent trace \( \tr' \)
where transactions do not interleave with others (\cref{thm:clock-si-normal-trace}).
Furthermore, in such trace \( \tr' \), transactions are reduced in their commit order.
\begin{theorem}[Normal clock-SI trace]
\label{thm:clock-si-normal-trace}
A clock-SI trace \( \tr \) is a clock-SI normal trace if it satisfies the following:
there is no interleaving of a transaction,
\begin{equation}
    \label{equ:clock-si-no-interleaving}
    \begin{array}{@{}l@{}}
        \fora{\cl,\ct, \mkvs_i, \cts_i, \cts'_i, \thdenv_i, \prog_i} 
        \tr = \cdots \toG{\cl,\ct,\stub, \perp} \mkvs_i, \cts_i, \cts'_i, \thdenv_i, \prog_i \toG{\stub} \cdots \\
        \quad {} \implies \exsts{\ct', \mkvs_j, \cts_j, \cts'_j, \thdenv_j, \prog_j} 
        \tr = \cdots \toG{\cl,\ct,\stub, \perp} \mkvs_i, \cts_i, \cts'_i, \thdenv_i, \prog_i \toG{\cl,\ct,\stub, \perp} \stub \toG{\cl,\ct,\stub, \perp} 
        \cdots \toG{\cl,\ct,\stub,\ct'} \mkvs_j, \cts_j, \cts'_j, \thdenv_j, \prog_j
    \end{array}
\end{equation}
and transactions in the trace appear in the committing order, 
\begin{equation}
    \label{equ:clock-si-commit-order}
    \begin{array}{@{}l@{}}
        \fora{\cl_i,\cl_j,\ct_i, \ct_j, \ct'_i, \cl'_j, \fp_i, \fp_j \mkvs_i, \mkvs_j, \cts_i, \cts_j, \cts'_i, \cts'_j, \thdenv_i, \thdenv_j,  \prog_i, \prog_j} \\
        \tr = \cdots \toG{\cl_i,\ct_i,\fp_i,\ct'_i} \mkvs_i, \cts_i, \cts'_i, \thdenv_i, \prog_i \toG{\stub} 
        \cdots \toG{\cl_j,\ct_j,\fp_j,\ct'_j} \mkvs_j, \cts_j, \cts'_j, \thdenv_j, \prog_j 
        \implies \ct'_i < \ct'_j
    \end{array}
\end{equation}
For any clock-SI trace \( \tr \), there exists an equivalent normal trace \( \tr' \) which has the same final configuration as \( \tr \).
\end{theorem}
\begin{proof}
    Given a trace \( \tr \), we first construct a trace \( \tr' \)  that satisfies \cref{equ:clock-si-commit-order}, by swapping steps.
    Let take the first two transactions \( \txid_{\cl_i}^n \) and \( \txid_{\cl_j}^m \) that are out of order, \ie \( n > m \) and 
    \[
    \begin{array}{@{}l@{}}
        \tr = \cdots \toG{\cl_i,\ct_i,\fp_i,n} \mkvs_i, \cts_i, \cts'_i, \thdenv_i, \prog_i \toG{\stub}  \cdots \toG{\cl_j,\ct_j,\fp_j,m} \mkvs_j, \cts_j, \cts'_j, \thdenv_j, \prog_j \\
    \end{array}
    \]
    By \cref{lem:mono-client-clock-time}, the two clients are different \( \cl_i \neq \cl_j \) and thus two steps are unique in the trace.
    We will construct a trace that \( \txid_{\cl_i}^n \) commits after \( \txid_{\cl_j}^m  \).
    \begin{itemize}
    \item First, it is important to prove that \( \txid_{\cl_j}^m \) does not read any version written by \( \txid_{\cl_i}^n\).
    By \cref{lem:commit-after-snapshot-time}, the snapshot time \( \ct_j \) of \( \txid_{\cl_j}^m \) is less than the commit time, 
    \ie \( \ct_j < m \), therefore \( \ct_j < n \).                                                                                  
    By the \rl{read} rule, \( \ct_j < n \) implies the transaction \( \txid_{\cl_j}^m \) never read any version written by \( \txid_{\cl_i}^n \).

    \item Let consider any possible time tick for those shard \( \sd \) that has been updated by \( \txid_{\cl_j}^m \),
    that is, \( \sd = \func{shardOf}{\key}\) for some key \( \key \)  that \( (\otW, \key, \stub) \in \fp_i \) and
    \begin{equation}
    \label{equ:time-tick-move-afterwards}
    \begin{array}{@{}l@{}}
        \tr = \cdots \toG{\cl_i,\ct_i,\fp_i,n} \mkvs_i, \cts_i, \cts'_i, \thdenv_i, \prog_i \toG{\stub} 
        \cdots \toG{\sd,\ct} \stub \toG{\stub} \cdots \toG{\cl_j,\ct_j,\fp_j,m} \mkvs_j, \cts_j, \cts'_j, \thdenv_j, \prog_j \\
    \end{array}
    \end{equation}
    Since \( \ct_j < m < n < \ct \), therefore such time tick will not affect the transaction \( \txid_{\cl_j}^m \),
    which means it is safe to move the time tick step after the \( \txid_{\cl_j}^m \).
    \end{itemize}
    Now we can move the commit of \( \txid_{\cl_i}^n \) and time tick steps similar to \cref{equ:time-tick-move-afterwards} after the commit of \( \txid_{\cl_j}^m \),
    \[
    \begin{array}{@{}l@{}}
        \tr' = \cdots \toG{\cl_j,\ct_j,\fp_j,m} \mkvs_j, \cts_j, \cts'_j, \thdenv_j, \prog_j \toG{\cl_i,\ct_i,\fp_i,n} \mkvs_i, \cts_i, \cts'_i, \thdenv_i, \prog_i \toG{\sd,\ct} \cdots \\
    \end{array}
    \]
    We continually swap the out of order transaction until the newly constructed trace \( \tr' \)  satisfying \cref{equ:clock-si-commit-order}.

    Now let consider \cref{equ:clock-si-no-interleaving}.
    Let take the first transaction \( \txid \) whose read has been interleaved by other transaction or a time tick.
    \begin{itemize}
        \item If it is a step that the transaction \( \txid \) read from local state,
        \[
        \begin{array}{@{}l@{}}
            \tr = \cdots \toG{\cl,\ct,\fp \addO (\otR, \key, \val ),\perp} \stub  \toG{\alpha} \cdots  \toG{\cl,\ct,\fp'',n} \cdots \\
        \end{array}
        \]
        then by \rl{ReadTrans} we know \( \fp \addO (\otR, \key, \val ) = \fp\), and it is safe to swap the two steps as the following
        \[
        \begin{array}{@{}l@{}}
            \tr' = \cdots \toG{\alpha} \stub \toG{\cl,\ct,\fp \addO (\otR, \key, \val ),\perp} \cdots \toG{\cl,\ct,\fp'',n} \cdots \\
        \end{array}
        \]
        \item If it is a step that the transaction \( \txid \) read from remote, 
            the step might be interleaved by a step from other transaction or time tick step.
        \begin{itemize}                                                                       
            \item if it is interleaved by the commit of other transaction \( \txid' = \txid_{\cl'}^m \), that is
        \[
        \begin{array}{@{}l@{}}
            \tr = \cdots \toG{\cl,\ct,\fp,\perp} \mkvs, \cts, \cts', \thdenv, \prog  \toG{\cl',\ct',\fp',m} \cdots \toG{\cl,\ct,\fp'',n} \cdots \\
        \end{array}
        \]
        where \( \cl' \neq \cl \).
        \begin{itemize}
            \item if the transaction \( \txid' \) does not write to any key \( \key \) that is read by \( \txid \),
                \[
                    \fora{\key} (\otR, \key, \stub) \in \fp \implies (\otW, \key, \stub) \notin \fp'
                \]
            In this case, it is safe to swap the two steps
            \[
            \begin{array}{@{}l@{}}
                \tr' = \cdots \toG{\cl',\ct',\fp',m} \stub \toG{\cl,\ct,\fp,\perp} \cdots \toG{\cl,\ct,\fp'',n} \cdots \\
            \end{array}
            \]
            \item if the transaction \( \txid' \) write to a key \( \key \) that is read by \( \txid \),
                \[
                    (\otR, \key, \stub) \in \fp \land (\otW, \key, \stub) \in \fp'
                \]
                Let \( \sd = \func{shardOf}{\key} \).
                By the \rl{ReadRemote}, we know the current clock time for the shard \( \sd \) is greater than \( \ct \) which is the snapshot time of \( \txid \), 
                that is, \( \cts'(\sd) > \ct \).
                Then by \rl{commit}, the commit time of \( \txid' \) is picked as the maximum of the shards it touched, 
                \ie \( m \geq \cts'(\sd) \).
                Now by the \rl{ReadRemote} and \( m \geq \ct \), it is safe to swap the two steps since the new version of \( \key \) does not affect the \( \txid \).
        \end{itemize}
        \item if it is interleaved by the read of other transaction \( \txid' \), that is
        \[
        \begin{array}{@{}l@{}}
            \tr = \cdots \toG{\cl,\ct,\fp,\perp} \mkvs, \cts, \cts', \thdenv, \prog  \toG{\cl',\ct',\fp',\perp} \cdots \toG{\cl,\ct,\fp'',n} \cdots \\
        \end{array}
        \]
        Because reads have no side effect to any shard by \rl{readRemote},
        it is safe to swap the two steps
        \[
        \begin{array}{@{}l@{}}
            \tr' = \cdots \toG{\cl',\ct',\fp', \perp} \stub \toG{\cl,\ct,\fp,\perp} \cdots \toG{\cl,\ct,\fp'',n} \cdots \\
        \end{array}
        \]
        \item if it is interleaved by a time tick step,
        \[
        \begin{array}{@{}l@{}}
            \tr = \cdots \toG{\cl,\ct,\fp \addO (\otR, \key, \val),\perp} \mkvs, \cts, \cts', \thdenv, \prog  \toG{\sd, \ct'} \cdots \toG{\cl,\ct,\fp'',n} \cdots \\
        \end{array}
        \]
        \begin{itemize}
            \item if the transaction \( \txid \) does not read from the shard \( \sd \), it means for any key \( \key \),
                \[
                    \func{shardOf}{\key} \neq \sd
                \]
            In this case, it is safe to swap the two steps
            \[
            \begin{array}{@{}l@{}}
            \tr' = \cdots \toG{\sd, \ct'} \stub \toG{\cl,\ct,\fp \addO (\otR, \key, \val),\perp} \cdots \toG{\cl,\ct,\fp'',n} \cdots \\
            \end{array}
            \]
            \item if the transaction \( \txid \) read from the shard \( \sd \), it means that there exists a key \( \key \)
            \[
                \func{shardOf}{\key} = \sd
            \]
            By the \rl{ReadRemote}, we know the current clock time for the shard \( \sd \) is greater than the snapshot time of \( \txid \), 
            that is, \( \cts'(\sd) > \ct \).
            Then by \rl{TimeTick},  we have \( \ct' > \cts'(\sd) \).
            Now by the \rl{ReadRemote} and \( \ct' > \ct \), it is safe to swap the two steps.
        \end{itemize}
    \end{itemize}
    \end{itemize}
\end{proof}

\begin{lemma}[Monotonic client clock time]
    \label{lem:mono-client-clock-time}
    The clock time associated with a client monotonically increases,
    That is, given a step
    \[
        \mkvs, \cts, \cts', \thdenv, \prog \toG{\stub} \mkvs', \cts'', \cts''', \thdenv', \prog'
    \]
    then for any clients \( \cl \),
    \[
        \cts(\cl) \leq \cts(\cl')
    \]
\end{lemma}
\begin{proof}
    It suffices to only check the \rl{ClientStep} rule which is the only rule updates the client clock time,
    especially, it is enough to check the client \( \cl \) that who starts or commits a new transaction.
    \begin{itemize}
        \item \rl{Commit}.
            Let \( \ct \) be the clock time before committing, \( \ct = \cts(\cl)\).
            By the premiss of the rule, the new client time \( n + 1 \) satisfies that, 
            \[
                n = \max\left( \Setcon{\ct'}{\exsts{\key} (\stub, \key, \stub) \in \fp \land \ct' = \cts(\func{shardOf}{\key})} \cup \Set{\ct} \right)
            \]
            It means \( \ct < (n + 1)\).
        \item \rl{StartTrans}.
            Let \( \ct \) be the clock time before taking snapshot, \( \ct = \cts(\cl)\).
            By the premiss of the rule the new  client time \( \cts'(\sd) \) for a shard \( \sd \), 
            such that \( \ct < \cts'(\sd)  \).
    \end{itemize}
\end{proof}

\begin{lemma}[No side effect local operation]
    \label{lem:commit-after-snapshot-time}
    Any transactional operation has no side effect to the shard and key-value store,
    \[
        \mkvs, \cts, \cts', \thdenv, \prog \toG{\cl, \ct, \fp, \perp} \mkvs', \cts'', \cts''', \thdenv', \prog' \implies \mkvs = \mkvs'
    \]
\end{lemma}
\begin{proof}
    It is easy to see that 
    \rl{StartTrans}, \rl{ReadTrans}, \rl{ReadRemote} and \rl{Write} do not change the state of key-value store.
\end{proof}

Clock-SI also has a notion view which corresponds the snapshot time.
The following definition \( \func{viewOf}{\mkvs,\ct} \) extracts the view from snapshot time.
\begin{definition}
    \label{clock-si-view}
    \label{def:clock-si-view}
    Given a normal clock-SI trace \( \tr \) and a transaction \( \txid_\cl \), such that
    \[
        \tr = \cdots \toG{\cl, \ct, \emptyset, \perp} \cdots \toG{\cl, \ct, \fp, \perp} \mkvs, \cts, \cts', \thdenv, \prog  \toG{\cl, \ct, \fp, \ct'} \cdots
    \] 
    the initial view of the transaction is defined as the following:
    \[
        \begin{rclarray}
            \func{viewOf}{\mkvs,\ct} & \defeq & \lambda \key \ldotp \Setcon{i}{\exsts{\txid^{n} } \WTx(\mkvs(\key,i)) = \txid^{n} \land n < \ct}
        \end{rclarray}
    \]
\end{definition}

Given the view \( \func{viewOf}{\mkvs,\ct} \) for each transaction, 
we first prove that clock-si produces a well-formed key-value store (\cref{def:mkvs}).
\begin{lemma}
    \label{lem:well-formed-clock-si-view}
    Given any key-value store \( \mkvs \) and snapshot time \( \ct \) from a clock-SI trace \( \tr \),
    \[
        \tr = \cdots \toG{\stub} \mkvs, \cts, \cts', \thdenv, \prog \to{\cl, \ct, \fp, \ct'} \cdots
    \]
    \func{viewOf}{\mkvs, \ct} and \func{viewOf}{\mkvs, \ct'} (\cref{clock-si-view}) produce well-formed views.
\end{lemma}
\begin{proof}                     
    It suffices to prove that \cref{eq:view.atomic} in \cref{def:view}.
    Assume a key-value store \( \mkvs \) and a snapshot time \( \ct \).
    Suppose a version \( i \) in the view \( i \in \func{viewOf}{\mkvs,\ct}(\key)\) for some key \( \key \).
    By \cref{def:clock-si-view}, the version is committed before the snapshot time,
    \ie \( \txid^n = \WTx(\mkvs(\key, i)) \land n < \ct\).
    Assume another version \( \txid^n = \WTx(\mkvs(\key', j)) \) for some key \( \key' \) and index \( j \).
    By \cref{def:clock-si-view} we have \( j \in \func{viewOf}{\mkvs,\ct}(\key') \).
    Similarly \( \func{viewOf}{\mkvs, \ct'} \) is a well-formed view.
\end{proof}

Second, given the view \( \func{viewOf}{\mkvs,\ct} \) for each transaction, 
both \( \func{commitKV} \) and \( \updateKV \) produce the same result.
\begin{lemma}
    Given a normal clock-SI trace \( \tr \) and a transaction \( \txid_\cl \), such that
    \[
        \tr = \cdots \toG{\cl, \ct, \emptyset, \perp} \cdots \toG{\cl, \ct, \fp, \perp} \mkvs, \cts, \cts', \thdenv, \prog  \toG{\cl, \ct, \fp, \ct'} \cdots
    \] 
    the following holds:
    \[
        \func{commitKV}{\mkvs,\ct,\txid_\cl^{\ct'},\fp} = \updKV{\mkvs, \func{viewOf}{\mkvs, \ct},\fp, \txid_\cl^{\ct'}} 
    \]
\end{lemma}
\begin{proof}
    We prove by induction on \( \fp \).
    \begin{itemize}
        \item \caseB{\( \fp = \emptyset \)}
            It is easy to see that \( \func{commitKV}{\mkvs,\ct,\txid_\cl^{\ct'},\emptyset} = \mkvs =  \updKV{\mkvs, \func{viewOf}{\mkvs, \ct},\fp, \txid_\cl^{\ct'}} \).
        \item \caseI{\( \fp \uplus (\otW, \key, \val) \)}
            Because in both functions, the new version is installed at the tail of the list associated with \( \key \),
            \[
                \begin{array}{@{}l@{}}
                \func{commitKV}{\mkvs,\ct,\txid_\cl^{\ct'},\fp \uplus (\otW, \key, \val)}  \\
                \quad \begin{array}[t]{@{}c l@{}}
                = &
                \func{commitKV}{\mkvs,\ct,\txid_\cl^{\ct'},\fp}\rmto{\key}{\mkvs(\key) \lcat \List{(\val, \txid, \emptyset)}} \\
                = & 
                \updKV{\mkvs,\func{viewOf}{\mkvs,\ct},\fp,\txid_\cl^{\ct'}}\rmto{\key}{\mkvs(\key) \lcat \List{(\val, \txid, \emptyset)}} \\
                = & 
                \updKV{\mkvs,\func{viewOf}{\mkvs,\ct},\fp \uplus (\otW, \key, \val),\txid_\cl^{\ct'}}
                \end{array}
                \end{array}
            \]
        \item \caseI{\( \fp \uplus (\otR, \key, \val) \)}
            Let \( \mkvs(\key,i) \) be the version being read.
            That is, the writer \( \txid^n = \WTx(\mkvs(\key,i)) \)
            is the latest transaction written to the key \( \key \) before the snapshot time \( \ct \),
            \[
                n = \max\Setcon{n'}{%
                    \exsts{j} 
                    \txid^{n'} = \WTx(\mkvs(\key, j)) 
                    \land n' < \ct%
                } 
            \]
            Let the new version \( \ver = \left( \valueOf(\mkvs(\key,i)), \WTx(\mkvs(\key,i)), \RTx(\mkvs(\key,i)) \uplus \Set{\txid_\cl^{\ct'}} \right) \).
            By \cref{lem:well-formed-clock-si-view}, it follows \( i \in \func{viewOf}{\mkvs,\ct}(\key) \), then by \cref{lem:clock-si-mono-writer}, the version is the latest one \( i = \max(\func{viewOf}{\mkvs,\ct}(\key)) \).
            Therefore we have,
            \[
                \begin{array}{@{}l@{}}
                \func{commitKV}{\mkvs,\ct,\txid_\cl^{\ct'},\fp \uplus (\otR, \key, \val)}  \\
                \quad \begin{array}[t]{@{}c l@{}}
                = &
                \func{commitKV}{\mkvs,\ct,\txid_\cl^{\ct'},\fp}\rmto{\key}{\mkvs(\key)\rmto{i}{\ver}} \\
                = & 
                \updKV{\mkvs,\func{viewOf}{\mkvs,\ct},\fp,\txid_\cl^{\ct'}}\rmto{\key}{\mkvs(\key)\rmto{i}{\ver}} \\
                = & 
                \updKV{\mkvs,\func{viewOf}{\mkvs,\ct},\fp \uplus (\otR, \key, \val),\txid_\cl^{\ct'}}
                \end{array}
                \end{array}
            \]
    \end{itemize}
\end{proof}

\begin{lemma}[Strictly monotonic writers]
    \label{lem:clock-si-mono-writer}
    Each version for a key has a writer with strictly greater clock time than any versions before:
    \[
        \begin{array}{@{}l@{}}
            \fora{\mkvs,\key,i,j,\txid^n,\txid^m} 
            \WTx(\mkvs(\key,i)) = \txid^n 
            \land \WTx(\mkvs(\key,j)) = \txid^m 
            \land i < j
            \implies 
            n < m
        \end{array}
    \]
\end{lemma}

By \cref{thm:clock-si-normal-trace}, it is sufficient to only consider normal clock-SI trace.
Since transactions do not interleave in a normal clock-SI trace,
all transactional execution can be replaced by \cref{fig:semantics-trans}.
\begin{theorem}[Simulation]
    \label{thm:clock-si-transaction-to-atomic}
    Given a clock-SI normal trace \( \tr \), a transaction \( \txid_\cl^n \) from the trace,
    and the following transactional internal steps
    \[
        \mkvs_0, \ct_0, \cts_0, \stk_0, \ptrans{\trans} \toT{\cl,\ct,\emptyset,\perp} \cdots  \toG{\cl,\ct,\fp,n} \mkvs_i, \ct_i, \cts_i, \stk_i, \ptrans{\pskip}
    \]
    for some \( i \), there exists a trace
    \[
        (\stk_0, \snapshot(\mkvs_0,\func{viewOf}{\mkvs_0,\ct}), \emptyset), \trans \toL^*
        (\stk_i, \sn_i, \fp_i), \pskip
    \]
    that produces the same final fingerprint in the end.
\end{theorem}
\begin{proof}
    Given the internal steps of a transaction
    \[
        \mkvs_0, \ct_0, \cts_0, \stk_0, \ptrans{\trans_0}_\ct^{\fp_0} \toT{\stub} 
        \cdots  \toG{\stub} \mkvs_i, \ct_i, \cts_i, \stk_i, \ptrans{\trans_i}_\ct^{\fp_i}
    \]
    We construct the following trace,
    \[
        (\stk_0, \snapshot(\mkvs_0,\func{viewOf}{\mkvs_0,\ct}), \fp_0), \trans_0 \toL^*
        (\stk_i, \sn_i, \fp_i), \trans_i
    \]
    Let consider how many transactional internal steps.
    \begin{itemize}
        \item \caseB{i = 0}
        In this case, 
        \[
            \mkvs_0, \ct_0, \cts_0, \stk_0, \ptrans{\trans}_\ct^{\fp_0}
        \]
        It is easy to construct the following
        \[
            (\stk_0, \snapshot(\mkvs,\func{viewOf}{\mkvs,\ct}), \fp_0), \trans_0 
        \]
        \item \caseI{i + 1}
        Suppose  a trace with \(i\) steps,
        \[
            \mkvs_0, \ct_0, \cts_0, \stk_0, \ptrans{\trans_0}_\ct^{\fp_0} \toT{\stub} 
            \cdots  \toG{\stub} \mkvs_i, \ct_i, \cts_i, \stk_i, \ptrans{\trans_i}_\ct^{\fp_i}
        \]
        and a trace
        \[
            (\stk_0, \snapshot(\mkvs_0,\func{viewOf}{\mkvs_0,\ct}), \fp_0), \trans_0 \toL^*
            (\stk_i, \sn_i, \fp_i), \trans_i
        \]
        Now let consider the next step.
        \begin{itemize}
            \item \rl{ReadTrans}.
                In this case
                \[
                    \mkvs_i, \ct_i, \cts_i, \stk_i, \ptrans{\trans_i}_\ct^{\fp_i}
                    \toG{\stub}
                    \mkvs_{i+1}, \ct_{i+1}, \cts_{i+1}, \stk_{i+1}, \ptrans{\trans_{i+1}}_\ct^{\fp_{i+1}}
                \]
                such that
                \[
                    \fp_{i+1} = \fp_i \addO (\otR, \key, \val)  = \fp_i
                    \land (\otW,\key, \val) \in \fp_i
                \]
                for some key \( \key \) and value \( \val \), and
                \[
                    \trans_{i} \equiv \plookup{\vx}{\expr} ; \trans 
                    \land \evalE[\stk_i]{\expr} = \key 
                    \land \stk_{i+1} = \stk_i\rmto{\pv}{\val}
                    \land  \trans_{i+1} \equiv \pskip ; \trans
                \]
                for some variable \( \vx \), expression \( \expr \) and continuation \( \trans \).
                Since \( ( \otW, \key ,\val ) \in \fp_i  \), it means \( \ss_i(\key) = \val \) for the local snapshot.
                By the \rl{TPrimitive}, we have 
                \[
                    (\stk_i, \sn_i, \fp_i), \trans_i \toL \plookup{\vx}{\expr} ; \trans 
                    \toL (\stk_{i+1}, \sn_i, \fp_{i+1} ), \trans_{i+1}
                \]
            \item \rl{ReadRemote}.
                In this case
                \[
                    \mkvs_i, \ct_i, \cts_i, \stk_i, \ptrans{\trans_i}_\ct^{\fp_i}
                    \toG{\stub}
                    \mkvs_{i+1}, \ct_{i+1}, \cts_{i+1}, \stk_{i+1}, \ptrans{\trans_{i+1}}_\ct^{\fp_{i+1}}
                \]
                such that
                \[
                    \fp_{i+1} = \fp_i \addO (\otR, \key, \val) = \fp_i \uplus \Set{(\otR, \key, \val)}
                    \land \fora{\val} (\otW,\key, \val') \notin \fp_i
                \]
                for some key \( \key \) and value \( \val \), and
                \[
                    \trans_{i} \equiv \plookup{\vx}{\expr} ; \trans 
                    \land \evalE[\stk_i]{\expr} = \key 
                    \land \stk_{i+1} = \stk_i\rmto{\pv}{\val}
                    \land  \trans_{i+1} \equiv \pskip ; \trans
                \]
                for some variable \( \vx \), expression \( \expr \) and continuation \( \trans \).
                By the premiss of the \rl{ReadRemote}, the value read is from the last version before the snapshot time:
                \[
                    n = \max\Setcon{n'}{%
                        \exsts{j} \txid^{n'} = \WTx(\mkvs(\key, j)) \land n' < \ct%
                    } 
                    \land \valueOf(\mkvs_i(\key,n) ) = \val
                \]                 
                By the definition of \( \vi_0 = \func{viewOf}{\mkvs_0,\ct} \) and \( \snapshot[\mkvs_0,\vi_0] \) and the fact that there is no write to the key \( \key \),
                it follows \( \sn_i(\key) = \val \).
                Thus, by the \rl{TPrimitive}, we have 
                \[
                    (\stk_i, \sn_i, \fp_i), \trans_i \toL \plookup{\vx}{\expr} ; \trans 
                    \toL (\stk_{i+1}, \sn_i, \fp_{i+1} ), \trans_{i+1}
                \]
            \item \rl{Write}.
                In this case
                \[
                    \mkvs_i, \ct_i, \cts_i, \stk_i, \ptrans{\trans_i}_\ct^{\fp_i}
                    \toG{\stub}
                    \mkvs_{i+1}, \ct_{i+1}, \cts_{i+1}, \stk_{i+1}, \ptrans{\trans_{i+1}}_\ct^{\fp_{i+1}}
                \]
                such that
                \[
                    \fp_{i+1} = \fp_i \addO (\otW, \key, \val) = \fp_i \setminus \Setcon{(\otW, \key, \val')}{\val' \in \Val} \uplus \Set{(\otR, \key, \val)}
                \]
                for some key \( \key \) and value \( \val \), and
                \[
                    \trans_{i} \equiv \pmutate{\expr_1}{\expr_2} ; \trans 
                    \land \evalE[\stk_i]{\expr_1} = \key 
                    \land \evalE[\stk_i]{\expr_2} = \val 
                    \land  \trans_{i+1} \equiv \pskip ; \trans
                \]
                for some expressions \( \expr_1 \) and \( \expr_2 \), and continuation \( \trans \).
                By the \rl{TPrimitive}, it is easy to see: 
                \[
                    (\stk_i, \sn_i, \fp_i), \trans_i \toL \pmutate{\expr_1}{\expr_2} ; \trans 
                    \toL (\stk_{i+1}, \sn_i, \fp_{i+1} ), \trans_{i+1}
                \]
        \end{itemize}
    \end{itemize}
\end{proof}

By \cref{def:clock-si-view,lem:well-formed-clock-si-view,thm:clock-si-transaction-to-atomic},
we know for each clock-SI trace, there exists a trace that satisfies \( \ET_\perp \).
Last, we prove such trace also satisfies \( \ET_\SI \).
\begin{theorem}[Clock-SI satisfying SI]
    For any normal trace clock-SI trace \( \tr \), and transaction \( \txid_\cl^{n} \) such that
    \[
        \tr = \cdots \toG{\cl, \ct, \fp, \perp} \mkvs, \cts, \cts', \thdenv, \prog  \toG{\cl, \ct, \fp, n} \mkvs', \cts'', \cts''', \thdenv', \prog' \toG{\stub} \cdots
    \]
    the transaction satisfies \( \ET_\SI \), \ie \( \ET_\SI \vdash (\mkvs, \func{viewOf}{\mkvs,\ct}) \csat \fp : \func{viewOf}{\mkvs,\cts''(\cl)} \)
\end{theorem}
\begin{proof}
    Recall \( \ET_\SI  = \Setcon{(\mkvs, \vi, \fp, \vi')}{\dagger} \cap \ET_\MRd \cap \ET_\RYW  \cap \ET_\UA \)
    %where
    %\[
    %\begin{rclarray}
        %\RF_{\mkvs} &\defeq& \{ (\txid, \txid') \mid \exists \key, i.\; \txid = \WTx(\mkvs(\key, i)) \wedge \txid' \in \RTx(\mkvs(\key, i))\}\\
        %\VO_{\mkvs} &\defeq& \{ (\txid, \txid') \mid \exists \key, i, j.\; \txid = \WTx(\mkvs(\key, i)) \wedge \txid' = \WTx(\mkvs(\key, j)) \wedge i < j\}\\
        %\AD_{\mkvs} &\defeq& \{ (\txid, \txid') \mid \exists \key, i, j.\; \txid \in \RTx(\mkvs(\key, i)) \wedge \txid' = \WTx(\mkvs(\key, j)) \wedge i < j\}\\
        %\PO &\defeq& \{ (\txid, \txid') \mid \exists \cl, m, n.\; \txid = \txid_{\cl}^{m} \wedge \txid' = \txid_{\cl}^{n} \wedge m < n \}\\
        %\dagger & \equiv &
        %\begin{array}[t]{@{}l@{}}
               %\fora{\key, \key', i, j} 
            %\begin{array}{@{}l@{}}
            %i \in \vi(\key)  \wedge \WTx(\mkvs(\key', j)) \toEdge{((\PO \cup \RF_{\mkvs} \cup \VO_{\mkvs}) ; \AD_{\mkvs}?)^+} \WTx(\mkvs(\key, i))
            %\implies j \in \vi(\key') 
            %\end{array}
        %\end{array} \\
    %\end{rclarray}
    %\]
    Note that final view of the client, \( \cts''(\cl) = n + 1 \).
    We prove the four parts separately.
    \begin{itemize}
        \item \( \Setcon{(\mkvs, \func{viewOf}{\mkvs,\ct}, \fp, \func{viewOf}{\mkvs,\cts''(\cl)})}{\dagger} \).
            Assume a version \( i \in \func{viewOf}{\mkvs,\ct}(\key) \) for some key \( \key \).
            Suppose a version \( \mkvs(\key',j)\) such that 
            \[ 
                \WTx(\mkvs(\key',j)) \toEdge{((\PO \cup \RF_{\mkvs} \cup \VO_{\mkvs}) ; \AD_{\mkvs}?)^+} \WTx(\mkvs(\key,i))
            \]
            Let \( \txid^n = \WTx(\mkvs(\key',j)) \) and \( \txid^m = \WTx(\mkvs(\key,i)) \).
            By \cref{lem:clock-si-rw,lem:clock-si-wr-ww-so}, we know \( n < m \) then \( j  \in \func{viewOf}{\mkvs,\ct}(\key')\).
        \item \( \ET_\MRd \).
            By \rl{Commit}, we know \( \ct \leq n < \cts''(\cl) \) then \( \func{viewOf}{\mkvs,\ct} \viewleq \func{viewOf}{\mkvs,\cts''(\cl)} \).
        \item \( \ET_\MW \).
            By \rl{Commit}, for any write \( (\otW, \key, \val) \in \fp \), there is a new version written by the client \( \cl \) in the \( \mkvs'  \),
            \[
                \WTx(\mkvs'(\key,\abs{\mkvs'(\key)} - 1)) = \txid_\cl^{n}
            \]
            Since \( n < \cts''(\cl)\), it follows \( \abs{\mkvs'(\key)} - 1 \in \func{viewOf}{\mkvs,\cts''(\cl)}(\key) \).
        \item \( \ET_\UA \).
            By the premiss of \rl{Commit}, for any write \( (\otW, \key, \val) \in \fp \), any existed versions of the key \( \key \)
            must be installed by some transactions before the snapshot time of \( \ct \),
            \[
                \fora{\key,i} (\otW, \key, \stub) \in \fp \land \WTx(\mkvs(\key,i)) < \ct 
            \]
            It implies that 
            \[ 
                \fora{i} i \in \dom(\mkvs(\key)) \implies i \in \func{viewOf}{\mkvs,\ct}(\key) 
            \]
    \end{itemize}
\end{proof}

\begin{lemma}[\( \RW_\mkvs \)]
    \label{lem:clock-si-rw}
    Given a normal clock-SI trace \( \tr \), and two transactions \( \txid_\cl^n \) and \( \txid_{\cl'}^m \) from the trace
    \[
        \begin{array}{@{}l@{}}
            \tr = \cdots \toG{\stub} \mkvs,\cts,\cts',\thdenv, \prog \toG{\cl,\ct,\fp,n} \cdots \land 
            \tr = \cdot \toG{\stub} \mkvs',\cts'',\cts''',\thdenv', \prog' \toG{\cl',\ct',\fp',m} \cdots
        \end{array}
    \]
    Suppose the final state of the trace \( \tr \) is \( \mkvs'' \).
    , if \( \txid_\cl^n \toEdge{\RW_{\mkvs''}?} \txid_{\cl'}^m \) then the snapshot time of \( \txid_{\cl}^n \) took snapshot before the commit time of \( \txid_{\cl'}^m \), \ie \( \ct \leq m \).
\end{lemma}
\begin{proof}
    By definition of \( \txid_\cl^n \toEdge{\RW_{\mkvs''}?} \txid_{\cl'}^m \),
    it follows that
    \[
        \txid_\cl^n \in \RTx(\mkvs''(\key,i)) 
        \land \txid_{\cl'}^m = \WTx(\mkvs''(\key,j)) 
        \land i < j
    \]                              
    for some key \( \key \) and indexes \( i,j \).
    There are two cases depending on the commit order.
    \begin{itemize}
        \item If \( \txid_\cl^n \) commits after \( \txid_{\cl'}^m  \),
            we have,
            \[
                \begin{array}{@{}l@{}}
                \tr = \cdot \toG{\stub} \mkvs',\cts'',\cts''',\thdenv', \prog' \toG{\cl',\ct',\fp',m} \cdots
                \toG{\stub} \mkvs,\cts,\cts',\thdenv, \prog \toG{\cl,\ct,\fp,n} \cdots \\
                \end{array}
            \]
            We prove by contradiction.
            Assume \( \ct > m \).
            Since it is a normal trace \( \tr \) (\cref{thm:clock-si-normal-trace}), 
            it follows \( n > m \).
            Note that both transactions access the key \( \key \), and then by \cref{lem:mono-shard-clock-time,lem:commit-after-snapshot-time}, we have \( n > \ct > m  \).
            Given \( \ct > m \), by \rl{ReadRemote} the transaction \( \txid_\cl^n \) should at least read the version written by \( \txid_{\cl'}^m \) for the key \( \key \).
            That is,
            \[
                \txid_\cl^n \in \RTx(\mkvs''(\key,i)) 
                \land \txid_{\cl'}^m = \WTx(\mkvs''(\key,j)) 
                \land i > j
            \]
            which contradict  \( \txid_\cl^n \toEdge{\RW_{\mkvs''}?} \txid_{\cl'}^m  \).
        \item If \( \txid_\cl^n \) commits before \( \txid_{\cl'}^m  \),
            \[
                \begin{array}{@{}l@{}}
                    \tr = \cdots \toG{\stub} \mkvs,\cts,\cts',\thdenv, \prog \toG{\cl,\ct,\fp,n} \cdots
                    \toG{\stub} \mkvs',\cts'',\cts''',\thdenv', \prog' \toG{\cl',\ct',\fp',m} \cdots
                \end{array}
            \]
            It is trivial that \( \ct \leq m \) by \cref{lem:mono-shard-clock-time,lem:commit-after-snapshot-time}.
    \end{itemize}
\end{proof}

\begin{lemma}[\( \WR_\mkvs \), \( \WW_\mkvs  \) and \( \SO_\mkvs \)]
    \label{lem:clock-si-wr-ww-so}
    Given a normal clock-SI trace \( \tr \), and two transactions \( \txid_\cl^n \) and \( \txid_{\cl'}^m \) from the trace
    \[
        \begin{array}{@{}l@{}}
            \tr = \cdots \toG{\stub} \mkvs,\cts,\cts',\thdenv, \prog \toG{\cl,\ct,\fp,n} \cdots \land 
            \tr = \cdots \toG{\stub} \mkvs',\cts'',\cts''',\thdenv', \prog' \toG{\cl',\ct',\fp',m} \cdots
        \end{array}
    \]
    Suppose the final state of the trace \( \tr \) is \( \mkvs'' \).
    , if \( \txid_\cl^n \toEdge{\WR_{\mkvs''}?} \txid_{\cl'}^m \) then the transaction \( \txid_{\cl}^n \) commit before the commit time of \( \txid_{\cl'}^m \), \ie \( n < m \).
    Similarly, \( n <  m \) for the relations \( \WW_\mkvs \) and \( \SO_\mkvs \).
\end{lemma}
\begin{proof}
    \begin{itemize}
        \item \( \WR_{\mkvs''} \).
            Since  \( \txid_\cl^n \toEdge{\WR_{\mkvs''}?} \txid_{\cl'}^m \),
            it is only possible that the later commits after the former,
            \[
                \begin{array}{@{}l@{}}
                    \tr = \cdots \toG{\stub} \mkvs,\cts,\cts',\thdenv, \prog \toG{\cl,\ct,\fp,n} \cdots \land
                    \toG{\stub} \mkvs',\cts'',\cts''',\thdenv', \prog' \toG{\cl',\ct',\fp',m} \cdots
                \end{array}
            \]
            By \cref{lem:clock-si-reader-greater-than-writer},we know \( n < m \).
        \item \( \WW_{\mkvs''} \).
            By the definition of  \( \WW_{\mkvs''} \) and \cref{lem:clock-si-mono-writer},we know \( n < m \).
        \item \( \SO_{\mkvs''} \).
            By the definition of  \( \SO_{\mkvs''} \) and \cref{lem:mono-client-clock-time},we know \( n < m \).
    \end{itemize}
\end{proof}

\begin{lemma}[Reader greater than writer]
    \label{lem:clock-si-reader-greater-than-writer}
    Assume a trace \( \tr \) and two transactions \( \txid_{\cl}^n\) and \( \txid_{\cl'}^m \),
        \[
            \begin{array}{@{}l@{}}
                \tr = \cdots \toG{\stub} \mkvs,\cts,\cts',\thdenv, \prog \toG{\cl,\ct,\fp,n} \cdots \land
                \toG{\stub} \mkvs',\cts'',\cts''',\thdenv', \prog' \toG{\cl',\ct',\fp',m} \cdots
            \end{array}
        \]
    Assume the final state of key-value store of the trace is \( \mkvs'' \).
    If  \( \txid_{\cl'}^m \) reads a version written \ by \( \txid_{\cl}^n\)
    \[
        \begin{array}{@{}l@{}}
            \WTx(\mkvs''(\key,i)) = \txid^n 
            \land \txid^m \in \RTx(\mkvs''(\key,j))
        \end{array}
    \]
    Then, the snapshot times of readers of a version is greater then the commit time of the writer \( n < \ct' \)
\end{lemma}
\begin{proof}
    Trivially, \( \WTx(\mkvs'(\key,i)) = \txid^n \).
    By the \rl{ReadRemote}, it follows \( n  = \max\Setcon{n'}{ \exsts{j} \txid^{n'} = \WTx(\mkvs(\key, j)) \land n' < \ct' } \) which implies \( n < \ct' \).
\end{proof}


\begin{lemma}[Commit time after snapshot time]
    \label{lem:commit-after-snapshot-time}
    The commit time of a transaction is after the snapshot time.
    Suppose the following step,
    \[
        \mkvs,\cts,\cts',\thdenv, \prog \toG{\cl,\ct,\fp,n} \mkvs',\cts'',\cts''',\thdenv', \prog'
    \]
    then \( \ct < n \).
\end{lemma}
\begin{proof}
    It is easy to see by \rl{ClientStep} and then \rl{Commit} that 
    \[
        n > n - 1 \max\left( \Setcon{\ct'}{\exsts{\key} (\stub, \key, \stub) \in \fp \land \ct' = \cts'(\func{shardOf}{\key})} \cup \Set{\ct} \right)
    \]
    so \( \ct < n \).
\end{proof}


\begin{lemma}[Monotonic shard clock time]
    \label{lem:mono-shard-clock-time}
    The clock time associated with a shard monotonically increases,
    Suppose the following step,
    \[
        \mkvs,\cts,\cts',\thdenv, \prog \toG{\cl,\ct,\fp,n} \mkvs',\cts'',\cts''',\thdenv', \prog'
    \]
    then 
    \[
        \fora{\sd \in \dom(\cts')} \cts'(\sd) \leq \cts'''(\sd)
    \]
\end{lemma}
\begin{proof}
    We perform case analysis on rules.
    \begin{itemize}
        \item \rl{TimeTick}
            By the rule there is one shard \( \sd' \) ticks time \( \cts'''(\sd') = \cts'(\sd) + 1 > \cts'(\sd) \).
        \item \rl{ClientStep}.
            There are further five cases, yet only \rl{StartTrans} and \rl{Commit} change the shard's clock times.
            \begin{itemize}
                \item \rl{StartTrans}
                    By the rule a new transaction starts in a shard \( \sd' \) and triggering the shard \( \sd' \) ticks time \( \cts'''(\sd') = \cts'(\sd) + 1 > \cts'(\sd) \).
                \item \rl{Commit}
                    By the rule the transaction commits their fingerprint \( \fp \) to those shards \( \sd' \) it read or write, and triggering the shard \( \sd' \) ticks time \( \cts'''(\sd') = \cts'(\sd) + 1 > \cts'(\sd) \).
            \end{itemize}
    \end{itemize}
\end{proof}
