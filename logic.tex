\section{Logic}


\sx{
    Parametrised by CM.

    Generalise CAP by generalise the meaning of box assertions, stable and atomic update rule.

    Two example write skew and long fork.

    Discussion: our first step. For each consistency models, we want to build specific pattern to use the capabilities
    so to provide a more syntactic rules.

    Cite: FCSL(for the idea that recording some history in the assertions), 
    CAP,
    Iris (they have powerful framework, whether it also fits in the weaker consistency world?)
    TaDA
    Relaxed SL (The first separation logic that deal with weaker behaviour)

    Alexey, Reaon about ..... in Dis. Sys. A proof system to verify if 
    a system (a set of operations that might be installed with tokens to specify synchronisation ) satisfies invariant.
}

We present a logic that is parametrised by consistency models.
The logic has syntax that similar to concurrent abstract predicate (CAP),
but we generalise \emph{atomic update rule} so it is parametrised by consistency models.




the meaning \emph{box assertions} so they describe the partial views of key-value stores.
The \emph{stabilisation} by consistency models.
The  now 


We motivate the logic by the \emph{write skew} example under snapshot isolation (\cref{fig:write-skew-si-proof}).
This example distinguishes snapshot isolation (SI) from serialisability.
For serialisability that transactions appear one after another, only one key, \( \vx \) or \( \vy \), will be 1 at the end.
While for SI, transactions take a snapshot when they start, and concurrent transactions can commit as long as they write to different keys.
In \cref{fig:write-skew-si-proof}, both transactions may take snapshots where \( \vx \) and \( \vy \) are 0, and can commit, 
which yields result that \( \vx \) and \( \vy \) are 1.

\begin{figure}[!t]
\hrule
\[
\intass :
\begin{array}[t]{@{} c @{\quad} c @{\quad}  @{} }
\begin{rclarray}[t]
    \CB{L} & : & \vx \fpW 1 \sep \vy \fpR 0 \sep \null \fpA \cass{\CB{L}}{\lrid} \\
\end{rclarray}
&
\begin{rclarray}[t]
    \CB{R} & : & \vx \fpR 0 \sep \vy \fpW 1 \sep \null \fpA \cass{\CB{R}}{\lrid} \\
\end{rclarray}
\\
\begin{rclarray}[t]
    \CB{U} & : & \exsts{\V n} \vx \fpR \V{n} \\
\end{rclarray} 
&
\begin{rclarray}[t]
    \CB{U} & : & \exsts{\V n} \vy \fpR \V{n} \\
\end{rclarray} \\
\end{array}
\]
\[
\CB{L} \composeK \CB{L} \ \text{is undefined} \quad  \CB{R} \composeK \CB{R} \ \text{is undefined} \quad \CB{U} \ \text{is the unit}
\]
\hrule\vspace{5pt}
\[
\begin{session}
{\color{blue}P : } \specline{ \cass{\CB{L}}{\lrid} \sep \cass{\CB{R}}{\lrid} \sep \boxass{\vx \pt 0 \sep \vy \pt 0 }{\lrid}{\intass}  } \\
\begin{parl}
\begin{session}
    {\color{blue}P1 : } \specline{\cass{\CB{L}}{\lrid} \sep 
            \boxass{\vx \pt 0 \sep \vy \pt 0 }{\lrid}{\intass} \\
            {} \lor \boxass{\vx \pt 0 \sep ( \vy \pt 0 \lor \vy \pt 1 ) \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass} 
    } \\
    \txid_1 : \begin{transaction}
        {\color{blue}p1 : } \specline{\vx \fpI 0 \sep ( \vy \fpI 0 \lor \vy \fpI 1 )} \\
        \pderef{\pvar{b}}{\vy} ; 
        \quad \pifs{\pvar{b} = 0} 
        \pmutate{\vx}{1} ;
        \pife \\
        {\color{blue}q1 : } \specline{\vx \fpW 1 \sep  \vy \fpR 0 \lor {}\\
        \quad \vx \fpI 0 \sep \vy \fpR 1 )} \\
    \end{transaction} \\
    {\color{blue}Q1 : } \specline{ 
            \boxass{ \vx \pt 1 \sep \vy \pt 0 \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass} \\
            {} \lor \boxass{\vx \pt 1 \sep ( \vy \pt 0 \lor \vy \pt 1 ) \sep {} \\
            \cass{\CB{R}}{\lrid} \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass}  \\
            {} \lor \cass{\CB{L}}{\lrid} \sep \boxass{\vx \pt 0 \sep \vy \pt 1 \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass}  \\
    } \\
\end{session}
&
\begin{session}
    {\color{blue}P2 : } \specline{\cass{\CB{R}}{\lrid} \sep 
            \boxass{ ( \vx \pt 0 \sep \vy \pt 0 }{\lrid}{\intass} \\
            {} \lor \boxass{ ( \vx \pt 0 \lor \vx \pt 1 ) \sep \vy \pt 0 \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass} 
    } \\
    \txid_2 : \begin{transaction}
        {\color{blue}p2 : } \specline{ ( \vx \fpI 0 \lor \vx \fpI 1 ) \sep \vy \fpI 0 )} \\
        \pderef{\pvar{a}}{\vx} ; 
        \quad \pifs{\pvar{a} = 0} 
        \pmutate{\vy}{1} ; 
        \pife \\
        {\color{blue}q2 : } \specline{ \vx \fpR 0 \sep \vy \fpW 1 \lor {} \\
        \quad \vx \fpR 1 \sep \vy \fpI 0 )} \\
    \end{transaction} \\
    {\color{blue}Q2 : } \specline{ 
            \boxass{ \vx \pt 0 \sep \vy \pt 1 \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass} \\
            {} \lor \boxass{ ( \vx \pt 0 \lor \vx \pt 1 ) \sep \vy \pt 1 \sep {} \\
            \cass{\CB{L}}{\lrid} \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass}  \\
            {} \lor \cass{\CB{R}}{\lrid} \sep \boxass{\vx \pt 1 \sep \vy \pt 0 \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass}  \\
    } \\
\end{session}
\end{parl} \\
{\color{blue}Q : } \specline{ 
        \cass{\CB{L}}{\lrid} \sep \boxass{ \vx \pt 0 \sep \vy \pt 1 \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass} 
        \lor \cass{\CB{R}}{\lrid} \sep \boxass{\vx \pt 1 \sep \vy \pt 0 \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass}
        \lor \boxass{ \vx \pt 1 \sep \vy \pt 1 \sep \cass{\CB{L}}{\lrid} \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass}  \\
} \\
\end{session}
\]
\hrule
\caption{Interference (the top) and the sketch proof (the bottom) for write skew under snapshot isolation}
\label{fig:write-skew-si-proof}
\end{figure}

We often use \( \lpre, \lpost \) to denote \emph{transactional assertions} and \( \gpre, \gpost \) for \emph{program assertions}.
The transactional assertions, such as \( p1 \) in \cref{fig:write-skew-si-proof}, 
describe the state of local snapshots for transactions and more importantly the fingerprints.
The fingerprint is the transaction's contribution to the key-value store, that is, \emph{the first read preceding any write} and \emph{last write} of each key.
The transactional assertions for individual keys have the following forms: \( \vx \fpI 0 \), \( \vx \fpR 0\), \( \vx \fpW 0\), and \( \vx \fpRW (0,1) \),
where \( \otR \) and \( \otW \) are read and write labels respectively.
The first three asserts the only key \( \vx \) in the local snapshot has value 0 and it has not been touched (no label), 
has been read (\(\otR\)) and has been written (\(\otW\)) respectively.
The last one asserts that the key \( \vx \) currently has value 1, 
\emph{the first read preceding any write} fetched 0 and the \emph{the last write} updated the key to \( 1 \).
We extend the standard sequential separation logic rules in a ways that the first read to a key adds a read label to the assertion; 
and a write to a key adds a write label to assertion and updates the value.
All the detail is in \cref{sec:reasoning-transaction}.

The program assertions, such as \( P1 \) in \cref{fig:write-skew-si-proof}, 
describe clients' views on key-value stores, together with some capabilities for the purpose of reasoning.
The assertion in the form of \( \boxass{\bar{\lpre}}{\lrid}{\intass}\),
for example \( \boxass{\vx \pt 1 \sep \vy \pt 1}{\lrid}{\intass} \) in \( \gpre_1 \),
is called the \emph{shared region assertions} also know as \emph{boxed assertions},
where \( \lrid \) is a unique \emph{region identifier},  \( \intass \) is \emph{interference},
and \( \lpre \) describes the views on key-value stores.
Region are shareable and indivisible, \ie 
\( \boxass{\bar{\lpre}}{\lrid}{\intass} \sep \boxass{\bar{\lpost}}{\lrid}{\intass} \iff \boxass{\bar{\lpre} \land \bar{\lpost}}{\lrid}{\intass}\).

Interference is a set of actions to specify what transactions are allowed by the region.
Each action has the form \( \kap : \fp \),
where \( \kap \) is the \emph{client-specified capability} and \( \fp \) is the \emph{fingerprint},
describes that if a client holds the capability \( \kap \), 
it is allowed to execute a transaction with the fingerprint \( \fp \).
For instance in \cref{fig:write-skew-si-proof}, 
the \( \CB{L}\) allows a client to read \( \vy \) when it is 0 (\(\vy \fpR 0\)) and write 1 to \( \vx \) (\(\vx \fpW 1\)),
and similarly \( \CB{R} \) allows a client to read \( \vx \) when it is 0 and write 1 to \( \vy \).
The fingerprint \( \fp \) in an action also specifies capabilities transformation.
For example, \( \null \fpA \cass{\CB{L}}{\lrid} \) means that \( \CB{L} \) needs to return to the shared region after the transaction is committed.
Last, the capabilities forms \emph{a partial commutative monoid (PCM)} where \( \composeK \) denotes the composition function.
In the write skew example (\cref{fig:write-skew-si-proof}), 
both \( \CB{L} \) and \( \CB{R} \) are unique as the compositions are undefined and \( \CB{U} \) is the unit.

Interference induces a label transitions system upon states \( (\mkvs, \vi, \ca) \)
where the labels are actions from the interference.
Then the \emph{invariant} of a region \( \func{inv}{\lrid} \) is the set of states reachable from 
the initial states of the regions provided by the function \( \func{init}{\lrid}\).

Given the invariant, a state \( (\mkvs, \vi, \ca) \) satisfies the assertion \( \boxass{\bar{\lpre}}{\lrid}{\intass} \),
if it is in the invariant of the region \( (\mkvs, \vi, \ca) \in \func{inv}{\lrid} \) and the snapshot induced by the view \( \snapshot(\mkvs, \vi) \) and 
the shared capabilities satisfy \( \bar{\lpre} \) (details in \cref{def:prog-assertion}).

Now let discuss the sketch proof in \cref{fig:write-skew-si-proof}, especially the rule for committing a transaction (other rules are standard and can be found in \cref{sec:reasoning-prog})
\[
    \inferrule[\rl{PRCommit}]{%
        \tripleL{\lpre}{\trans}{\lpost} 
        \\ \repartition{\gpre}{\gpost}{\lpre}{\lpost}
        \\\\ \stable{\gpre, \como} 
        \\ \stable{\gpost, \como} 
    }{%
        \tripleG{\gpre}{ \ptrans{\trans} }{\gpost}
    }
\]

An assertion \( \gpre \) is \emph{stable} under execution test \( \ET \), written \( \stable{\gpre, \como} \), if it holds against the interference.
Specifically, stabilisation has two meanings: \textbf{(i)} the environment might interfere and change the state of key-value stores, note that, but not the views of the current client since the views are local; 
\textbf{(ii)} consequentially, the client can advance the views.
For example, \( P1 \) is stable as it describes the states that either the environment does nothing \( \boxass{\vx \pt 0 \sep \vy \pt 0 }{\lrid}{\intass} \),
or the environment has performed the action associated with \( \cass{\CB{R}}{\lrid}\), 
after which the environment cannot do any further action since the capabilities \( \cass{\CB{R}}{\lrid}\) is in the shared region,
\ie \( \boxass{\vx \pt 0 \sep ( \vy \pt 0 \lor \vy \pt 1 ) \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass}  \).

Let discuss the assertions \( \vy \pt 0  \lor \vy \pt 1  \sep \cass{\CB{R}}{\lrid} \) from \( P1 \).
The environment returns the capability \( \cass{\CB{R}}{\lrid} \), it means the environment commits a transaction that writes 1 to \( vy \) and the capability \( \cass{\CB{R}}{\lrid} \), thus the value \( 0 \) is out-of-date.
Because of stabilisation, the view might be advanced so we get an up-to-date view \( \vy \pt 1 \).

\[
\begin{rclarray}
    \repartition{\gpre}{\gpost}{\lpre}{\lpost} & \defeq & 
    \begin{array}[t]{@{}l@{}}
        \fora{ \w, \mkvs, \vi, \lenv, \stk } 
        \w \in \evalW{\gpre} 
        \land (\mkvs, \vi) = \eraseW{\w}
        \implies  \\
        \quad \exsts{\h_\lpre, \h}
        \h_\lpre \composeH \h = \getSN{\mkvs, \vi}
        \land (\h, \unitO) \in \evalLS{\lpre}  \\
        \quad {} \land \fora{\w', \mkvs', \vi', \stk', \opset, \cl}  \\
        \qquad  (\stub, \opset) \in \evalLS[\lenv, \stk']{\lpost} 
        \land \mkvs' \in \updM{\mkvs, \vi, \cl, \opset} \\
        \qquad {} \land \et \vdash (\mkvs, \vi) \csat \opset : \vi' 
        \land (\mkvs', \vi') = \eraseW{\w'} 
        \land (\w, \w') \in \Guar \\
        \qqqquad \implies \w' \in \evalW[\lenv, \stk']{\gpost}
    \end{array} 
\end{rclarray}                          
\]




Because of atomicity, a transaction takes a snapshot and afterword executes locally on the snapshot and only commits the fingerprint by the end.
For example, \( P1 \) asserts views where \( \vx \) has value 0 and \( \vy \) has value either 0 or 1, the precondition \( p1 \) for transaction \( \txid_1 \) describes exactly the same states, and initial all keys have no fingerprint.
By the end of the transaction, the postcondition \( q1 \) describes that the transaction \( \txid_1 \) either read \( \vy \) with 0 and wrote 1 to \( \vx \),
or only read \( \vy \) with 0 and did nothing to \( \vx \).

To commit a fingerprint under SI, we first need to check the view before the transaction satisfies certain constraints with respect to the fingerprint.
SI requires that if a view observe some transactions, it should observe everything before.
Also if there is a write fingerprint for a key, the view for that key must be up-to-date, so to avoid write-write conflict.
Now given the view on the key-value store \( \gpre \), and we are about to commit the fingerprint given by the transaction \( \lpost \):
\textbf{(i)} for any key that has been over-written, we create a new version with the value;
\textbf{(ii)} for any key that has been read, the view before points to a version containing the same value;
\textbf{(iii)} the view after moves the up-to-date versions for all keys;
and last \textbf{(iv)} we need to check the update is allowed by the local capabilities and transfer the capabilities if necessary.
This will give us the following assertions \emph{before stabilisation}:
\[
\boxass{ \vx \pt 1 \sep \vy \pt 0 \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass} 
\lor \boxass{\vx \pt 1 \sep \vy \pt 1  \sep \cass{\CB{R}}{\lrid} \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass}
\lor \cass{\CB{L}}{\lrid} \sep \boxass{\vx \pt 0 \sep \vy \pt 1 \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass} 
\]
We need to stabilise the assertions.
The environment can commit a transaction that updates \( \vy \) to 1 under the state that satisfies the first disjunction, 
which yields \( \boxass{\vx \pt 1 \sep \vy \pt 0 \sep \cass{\CB{R}}{\lrid} \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass} \).
Now we have a stable assertions \( Q1 \) shown in \cref{fig:write-skew-si-proof}.

Following similar reasoning, we get \( Q2 \) for right-hand-side client.
The final \( Q \) is  \( Q = Q1 \sep Q2 \) provided that \( \boxass{\bar{\lpre}}{\lrid}{\intass} \sep \boxass{\bar{\lpost}}{\lrid}{\intass} \iff \boxass{\bar{\lpre} \land \bar{\lpost}}{\lrid}{\intass}\).
It means the final views and key-value stores are those come from both \( Q1 \) and \( Q2 \).






Note that unlike serialisability, the view might be out-of-date for SI.
For instance, the assertion \( \boxass{\vx \pt 0 \sep ( \vy \pt 0 \lor \vy \pt 1 ) \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass}\) from \( P1 \) asserts views where \( \vy \) might point to either 0 or 1.
Since the capability \( \cass{\CB{R}}{\lrid} \) has been returned to the region, the view where \( \vy \) point to 0 is out-of-date.




\begin{figure}[!t]
\hrule
\[
\intass :
\begin{array}[t]{@{} c @{\quad} c @{\quad} c @{\quad} c @{} }
\begin{rclarray}[t]
    \CB{L} & : & \exsts{\V{n}} \vx \fpR \V{n} \sep \vx \fpW \V{n} + 1 \sep \null \fpA \cass{\CB{L}}{\lrid} \\
\end{rclarray}
&
\begin{rclarray}[t]
    \CB{R} & : & \exsts{\V{n}} \vx \fpR \V{n} \sep \vx \fpW \V{n} + 1 \sep \null \fpA \cass{\CB{R}}{\lrid} \\
\end{rclarray} \\
\end{array}
\]
\[
\CB{L} \composeK \CB{L} \ \text{is undefined} \quad  \CB{R} \composeK \CB{R} \ \text{is undefined}
\]
\hrule\vspace{5pt}
\[
\begin{session}
 \specline{ \cass{\CB{L}}{\lrid} \sep \cass{\CB{R}}{\lrid} \sep \boxass{\vx \pt 0}{\lrid}{\intass}  } \\
\begin{parl}
\begin{session}
    \specline{\cass{\CB{L}}{\lrid} \sep 
            \boxass{\vx \pt 0}{\lrid}{\intass} 
            \lor \boxass{\vx \pt 0  \lor \vx \pt 1 \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass} 
    } \\
    \txid_1 : \begin{transaction}
        \specline{ \vx \fpI 0 \lor \vx \fpI 1 } \\
        \pderef{\pvar{a}}{\vy} ; 
        \pmutate{\vx}{\pv{a} + 1} ; \\
        \specline{ \vx \fpW 2 \lor \vx \fpW 1 } \\
    \end{transaction} \\
    \specline{ 
            \boxass{ \vx \pt 1 \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass} \lor {} \\
            \boxass{ \vx \pt 1 \lor \vx \pt 2 \sep \cass{\CB{R}}{\lrid} \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass} \\
    } \\
\end{session}
&
\begin{session}
    \specline{\cass{\CB{R}}{\lrid} \sep 
            \boxass{\vx \pt 0}{\lrid}{\intass} 
            \lor \boxass{\vx \pt 0  \lor \vx \pt 1 \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass} 
    } \\
    \txid_2 : \begin{transaction}
        \specline{ \vx \fpI 0 \lor \vx \fpI 1 } \\
        \pderef{\pvar{b}}{\vy} ; 
        \pmutate{\vx}{\pv{b} + 1} ; \\
        \specline{ \vx \fpW 2 \lor \vx \fpW 1 } \\
    \end{transaction} \\
    \specline{ 
            \boxass{ \vx \pt 1 \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass}  \lor {} \\
            \boxass{ \vx \pt 1 \lor \vx \pt 2 \sep \cass{\CB{L}}{\lrid} \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass} \\
    } \\
\end{session}
\end{parl} \\
    \specline{ 
            \boxass{ \vx \pt 1 \lor \vx \pt 2 \sep \cass{\CB{L}}{\lrid} \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass} \\
    } \\
\end{session}
\]
\hrule\vspace{5pt}
\[
\begin{session}
 \specline{ \cass{\CB{L}}{\lrid} \sep \cass{\CB{R}}{\lrid} \sep \boxass{\vx \pt 0}{\lrid}{\intass}  } \\
\begin{parl}
\begin{session}
    \specline{\cass{\CB{L}}{\lrid} \sep 
            \boxass{\vx \pt 0}{\lrid}{\intass} 
            \lor \boxass{ \vy \pt 1 \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass} 
    } \\
    \txid_1 : \begin{transaction}
        \specline{ \vx \fpI 0 \lor \vx \fpI 1 } \\
        \pderef{\pvar{a}}{\vy} ; 
        \pmutate{\vx}{\pv{a} + 1} ; \\
        \specline{ \vx \fpW 2 \lor \vx \fpW 1 } \\
    \end{transaction} \\
    \specline{ 
            \boxass{ \vx \pt 1 \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass}
            \lor \boxass{ \vx \pt 2 \sep \cass{\CB{R}}{\lrid} \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass} \\
    } \\
\end{session}
&
\begin{session}
    \specline{\cass{\CB{R}}{\lrid} \sep 
            \boxass{\vx \pt 0}{\lrid}{\intass} 
            \lor \boxass{\vy \pt 1 \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass} 
    } \\
    \txid_2 : \begin{transaction}
        \specline{ \vx \fpI 0 \lor \vx \fpI 1 } \\
        \pderef{\pvar{b}}{\vy} ; 
        \pmutate{\vx}{\pv{b} + 1} ; \\
        \specline{ \vx \fpW 2 \lor \vx \fpW 1 } \\
    \end{transaction} \\
    \specline{ 
            \boxass{ \vx \pt 1 \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass}
            \lor \boxass{\vx \pt 2 \sep \cass{\CB{L}}{\lrid} \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass} \\
    } \\
\end{session}
\end{parl} \\
    \specline{ 
            \boxass{ \vx \pt 2 \sep \cass{\CB{L}}{\lrid} \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass} \\
    } \\
\end{session}
\]
\hrule
\caption{Sketch proofs for concurrent increments under serialisability (the bottom) and casual consistency (the middle)}
\label{fig:increment-proof}
\end{figure}

The \cref{fig:increment-proof} shows sketch proofs for the same \emph{concurrent increments} under different consistency models, causal consistency (the middle) and serialisability (the bottom).
For causal consistency, a transaction can update keys even if started with an out-of-date view on those keys.
That means, the fingerprint \( \vx \fpW 1\) is allowed to commit when the view for \( \vx \) is out-of-date, \ie \( \vx \pt 0 \).
The same situation is disallowed under serialisability and snapshot isolation.


\begin{figure}[!t]
\hrule
\[
\intass :
\begin{array}[t]{@{} c @{\quad} c @{\quad}  c @{} }
\begin{rclarray}[t]
    \CB{L1} \composeK \CB{L2} & : & \vx \fpW 1 \sep \null \fpA \cass{\CB{L1}}{\lrid} \\
\end{rclarray}
&
\begin{rclarray}[t]
    \CB{R1} \composeK \CB{R2} & : & \vy \fpW 1 \sep \null \fpA \cass{\CB{R1}}{\lrid} \\
\end{rclarray}
&
\begin{rclarray}[t]
    \CB{U} & : & \exsts{\V{n}} \vy \fpR \V{n} \\
\end{rclarray}
\\
\begin{rclarray}[t]
    \CB{L2} & : & \vy \fpR 0 \sep \null \fpA \cass{\CB{L2}}{\lrid} \\
\end{rclarray}
&
\begin{rclarray}[t]
    \CB{R2} & : & \vx \fpR 0 \sep \null \fpA \cass{\CB{R2}}{\lrid} \\
\end{rclarray}
&
\begin{rclarray}[t]
    \CB{U} & : & \exsts{\V{n}} \vx \fpR \V{n} \\
\end{rclarray}
\end{array}
\]


\hrule\vspace{5pt}
\[
\begin{session}
\specline{ \cass{\CB{L1}}{\lrid} \sep \cass{\CB{L2}}{\lrid} \sep \cass{\CB{R1}}{\lrid} \sep \cass{\CB{R2}}{\lrid} \sep \boxass{\vx \pt 0 \sep \vy \pt 0}{\lrid}{\intass}  } \\
\begin{parl}
\begin{session}
    \specline{ 
        \cass{\CB{L1}}{\lrid} \sep \cass{\CB{L2}}{\lrid} \sep \boxass{\vx \pt 0 \sep \vy \pt 0}{\lrid}{\intass} \\
        {} \lor \boxass{\vx \pt 0 \sep ( \vy \pt 0 \lor \vy \pt 1 ) \\ {} \sep \cass{\CB{R1}}{\lrid} 
        \sep ( \cass{\CB{R2}}{\lrid} \lor \assemp ) }{\lrid}{\intass} 
    } \\
    \begin{transaction}
        \pmutate{\vx}{1} ; \\
    \end{transaction} \\
    \specline{ 
        \cass{\CB{L2}}{\lrid} \sep \boxass{\vx \pt 1 \sep \vy \pt 0 \sep \cass{\CB{L1}}{\lrid} }{\lrid}{\intass} \lor {} \\
        \boxass{\vx \pt 1 \sep ( \vy \pt 0 \lor \vy \pt 1 ) \sep \cass{\CB{R1}}{\lrid} 
        \sep \cass{\CB{L1}}{\lrid} }{\lrid}{\intass}  \\
        {} \lor \boxass{\vx \pt 1 \sep  \vy \pt 1 \sep \cass{\CB{R1}}{\lrid} 
        \sep \cass{\CB{R2}}{\lrid} \sep \cass{\CB{L1}}{\lrid} }{\lrid}{\intass} 
    } \\
    \begin{transaction}
        \pderef{\pv{a}}{\vy}; \\
        \pifs{ \pv{a} = 0 } 
        \passign{\pv{f1}}{1} ; 
        \pife
    \end{transaction} \\
    \specline{ 
        \boxass{\vx \pt 1 \sep \vy \pt 0 \sep \cass{\CB{L1}}{\lrid} \sep \cass{\CB{L2}}{\lrid} }{\lrid}{\intass} \\
        {} \lor \boxass{\vx \pt 1 \sep ( \vy \pt 0 \lor \vy \pt 1 ) \\ 
        {} \sep \cass{\CB{R1}}{\lrid} \sep \cass{\CB{L1}}{\lrid} \sep \cass{\CB{L2}}{\lrid} }{\lrid}{\intass}  \lor {} \\
        \cass{\CB{L2}}{\lrid} \sep  \boxass{\vx \pt 1 \sep \vy \pt 1  \sep \cass{\CB{R1}}{\lrid} \\ {}
        \sep ( \cass{\CB{R2}}{\lrid} \lor \assemp ) \sep \cass{\CB{L1}}{\lrid} }{\lrid}{\intass} \\
    } \\
\end{session}
&
\begin{session}
    \specline{ 
        \cass{\CB{R1}}{\lrid} \sep \cass{\CB{R2}}{\lrid} \sep \boxass{\vx \pt 0 \sep \vy \pt 0}{\lrid}{\intass} \\
        {} \lor \boxass{(\vx \pt 0 \lor \vx \pt 1) \sep \vy \pt 0  \\ {} \sep \cass{\CB{L1}}{\lrid} 
        \sep ( \cass{\CB{L2}}{\lrid} \lor \assemp ) }{\lrid}{\intass} 
    } \\
    \begin{transaction}
        \pmutate{\vy}{1} ; \\
    \end{transaction} \\
    \specline{ 
        \cass{\CB{R2}}{\lrid} \sep \boxass{\vx \pt 0 \sep \vy \pt 1 \sep \cass{\CB{R1}}{\lrid} }{\lrid}{\intass} \lor {} \\
        \boxass{(\vx \pt 0 \lor \vx \pt 1) \sep \vy \pt 1 \sep \cass{\CB{L1}}{\lrid} 
        \sep \cass{\CB{R1}}{\lrid} }{\lrid}{\intass} \\
        {} \lor \boxass{\vx \pt 1 \sep \vy \pt 1 \sep \cass{\CB{L1}}{\lrid} 
        \sep \cass{\CB{L2}}{\lrid} \sep \cass{\CB{R1}}{\lrid} }{\lrid}{\intass} \\
    } \\
    \begin{transaction}
        \pderef{\pv{b}}{\vy}; \\
        \pifs{ \pv{b} = 0 } 
        \passign{\pv{f2}}{1} ; 
        \pife
    \end{transaction} \\
    \specline{ 
        \boxass{\vx \pt 0 \sep \vy \pt 1 \sep \cass{\CB{R1}}{\lrid} \sep \cass{\CB{R2}}{\lrid} }{\lrid}{\intass} \\
        {} \lor \boxass{( \vx \pt 0 \lor \vx \pt 1 ) \sep \vy \pt 1 \sep \\ 
        {} \cass{\CB{L1}}{\lrid} \sep \cass{\CB{R1}}{\lrid} \sep \cass{\CB{R2}}{\lrid} }{\lrid}{\intass}  \lor {} \\
        \cass{\CB{R2}}{\lrid} \sep  \boxass{\vx \pt 1 \sep \vy \pt 1  \sep \cass{\CB{L1}}{\lrid} \\ {}
        \sep ( \cass{\CB{L2}}{\lrid} \lor \assemp ) \sep \cass{\CB{R1}}{\lrid} }{\lrid}{\intass} \\
    } \\
\end{session}
\end{parl} \\
\specline{ 
    \cass{\CB{L2}}{\lrid} \sep \boxass{\vx \pt 1 \sep \vy \pt 1 \sep 
    \cass{\CB{L1}}{\lrid} \sep \cass{\CB{R1}}{\lrid} \sep \cass{\CB{R2}}{\lrid} }{\lrid}{\intass} \lor 
    \cass{\CB{R2}}{\lrid} \sep \boxass{\vx \pt 1 \sep \vy \pt 1 \sep 
    \cass{\CB{L1}}{\lrid} \sep \cass{\CB{R1}}{\lrid} \sep \cass{\CB{L2}}{\lrid} }{\lrid}{\intass} \\
    {} \lor \cass{\CB{L2}}{\lrid} \sep \cass{\CB{R2}}{\lrid} \sep \boxass{\vx \pt 1 \sep \vy \pt 1  \sep \cass{\CB{L1}}{\lrid} \sep \cass{\CB{R1}}{\lrid} }{\lrid}{\intass} \\
} \\
\end{session}
\]
\hrule
\caption{Sketch proofs for long fork under snapshot isolation}
\label{fig:long-fork-proof}
\end{figure}

We can also prove the \emph{long fork} (\cref{fig:long-fork-proof}), which distinguish snapshot isolation (SI) from parallel snapshot isolation (PSI) (\cref{fig:long-fork-proof}).
We use the similar pattern by putting back the capabilities to the region once the capabilities has been used.
Note that we encode the program order in interference so that if there is a write, the write must happen before the read.
Let discuss that the postcondition after left client commits the first transaction, especially the case from the second line, \ie \( \boxass{\vx \pt 1 \sep \vy \pt 0  \sep \cass{\CB{R1}}{\lrid} \sep \cass{\CB{L1}}{\lrid} }{\lrid}{\intass} \).
It comes from stabilising \( \boxass{\vx \pt 1 \sep \vy \pt 0 \sep \cass{\CB{L1}}{\lrid} }{\lrid}{\intass} \) without updating  the view.
%Because both \( \cass{\CB{L1}}{\lrid} \) and \( \cass{\CB{L2}}{\lrid} \), it means the environment has updated \( \vy \) to 1 and then read \( \vx \) with value 0 in order before the current client.
%Because the left client updated the \( \vy \) to 1, while the environment successfully read \( \vx \) with a old value 0, the snapshot isolation requires the view must include all transaction before the read, therefore the view must include the write of \( \vy \).


\ifTechReport
\input{\RootPath/logic/transaction.tex}
\input{\RootPath/logic/program.tex}
\input{\RootPath/logic/soundness.tex}
\input{\RootPath/logic/trans_sound.tex}
\input{\RootPath/logic/prog_sound.tex}
\fi

%\input{./logic/assertion_graph.tex}
%\input{./logic/rule_graph.tex}
