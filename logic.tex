\section{Logic}

We present a logic that is parametrised by any consistency model \emph{at least satisfying atomic  read and monotonic read}.
We motivate it by the \emph{write skew} example under snapshot isolation (\cref{fig:write-skew-si-proof}).
This example distinguishes serialisibility from snapshot isolation (SI).
Under serialisibility that transactions appear one after another, only one key, \( \vx \) or \( \vy \), will be 1 at the end.
While under SI, both keys \( \vx \) and \( \vy \) might be 1.
Because both transactions may take snapshots where \( \vx \) and \( \vy \) are 0, and both can commit because the two transactions write different keys.

\begin{figure}[!t]
\hrule
\[
\intass :
\begin{array}[t]{@{} c @{\quad} c @{\quad} c @{\quad} c @{} }
\begin{rclarray}[t]
    \CB{L} & : & \vx \fpW 1 \sep \vy \fpR 0 \sep \null \fpA \cass{\CB{L}}{\lrid} \\
\end{rclarray}
&
\begin{rclarray}[t]
    \CB{R} & : & \vx \fpR 0 \sep \vy \fpW 1 \sep \null \fpA \cass{\CB{R}}{\lrid} \\
\end{rclarray}
&
\begin{rclarray}[t]
    \CB{0} & : & \exsts{\V n} \vx \fpR \V{n} \\
\end{rclarray} 
&
\begin{rclarray}[t]
    \CB{0} & : & \exsts{\V n} \vy \fpR \V{n} \\
\end{rclarray} \\
\end{array}
\]
\[
\CB{L} \composeK \CB{L} \ \text{is undefined} \quad  \CB{R} \composeK \CB{R} \ \text{is undefined} \quad \CB{U} \ \text{is the unit}
\]
\hrule\vspace{5pt}
\[
\begin{session}
{\color{blue}P : } \specline{ \cass{\CB{L}}{\lrid} \sep \cass{\CB{R}}{\lrid} \sep \boxass{\vx \pt 0 \sep \vy \pt 0 }{\lrid}{\intass}  } \\
\begin{parl}
\begin{session}
    {\color{blue}P1 : } \specline{\cass{\CB{L}}{\lrid} \sep 
            \boxass{\vx \pt 0 \sep \vy \pt 0 }{\lrid}{\intass} \\
            {} \lor \boxass{\vx \pt 0 \sep ( \vy \pt \underline{0}  \lor \vy \pt 1 ) \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass} 
    } \\
    \txid_1 : \begin{transaction}
        {\color{blue}p1 : } \specline{\vx \fpI 0 \sep ( \vy \fpI 0 \lor \vy \fpI 1 )} \\
        \pderef{\pvar{b}}{\vy} ; 
        \quad \pifs{\pvar{b} = 0} 
        \pmutate{\vx}{1} ;
        \pife \\
        {\color{blue}q1 : } \specline{\vx \fpW 1 \sep  \vy \fpR 0 \lor \vx \fpI 0 \sep \vy \fpR 1 )} \\
    \end{transaction} \\
    {\color{blue}Q1 : } \specline{ 
            \boxass{ \vx \pt 1 \sep \vy \pt 0 \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass} \\
            {} \lor \boxass{\vx \pt 1 \sep ( \vy \pt \underline{0}  \lor \vy \pt 1 ) \sep \cass{\CB{R}}{\lrid} \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass}  \\
            {} \lor \cass{\CB{L}}{\lrid} \sep \boxass{\vx \pt 0 \sep \vy \pt 1 \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass}  \\
    } \\
\end{session}
&
\begin{session}
    {\color{blue}P2 : } \specline{\cass{\CB{R}}{\lrid} \sep 
            \boxass{ ( \vx \pt 0 \sep \vy \pt 0 }{\lrid}{\intass} \\
            {} \lor \boxass{ ( \vx \pt \underline{0} \lor \vx \pt 1 ) \sep \vy \pt 0 \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass} 
    } \\
    \txid_2 : \begin{transaction}
        {\color{blue}p2 : } \specline{ ( \vx \fpI 0 \lor \vx \fpI 1 ) \sep \vy \fpI 0 )} \\
        \pderef{\pvar{a}}{\vx} ; 
        \quad \pifs{\pvar{a} = 0} 
        \pmutate{\vy}{1} ; 
        \pife \\
        {\color{blue}q2 : } \specline{ \vx \fpR 0 \sep \vy \fpW 1 \lor \vx \fpR 1 \sep \vy \fpI 0 )} \\
    \end{transaction} \\
    {\color{blue}Q2 : } \specline{ 
            \boxass{ \vx \pt 0 \sep \vy \pt 1 \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass} \\
            {} \lor \boxass{ ( \vx \pt \underline{0} \lor \vx \pt 1 ) \sep \vy \pt 1 \sep \cass{\CB{L}}{\lrid} \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass}  \\
            {} \lor \cass{\CB{R}}{\lrid} \sep \boxass{\vx \pt 1 \sep \vy \pt 0 \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass}  \\
    } \\
\end{session}
\end{parl} \\
{\color{blue}Q : } \specline{ 
        \cass{\CB{L}}{\lrid} \sep \boxass{ \vx \pt 0 \sep \vy \pt 1 \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass} 
        \lor \cass{\CB{R}}{\lrid} \sep \boxass{\vx \pt 1 \sep \vy \pt 0 \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass}   \\
        {} \lor \boxass{ ( \vx \pt \underline{0} \lor \vx \pt 1 ) \sep \vy \pt 1 \sep \cass{\CB{L}}{\lrid} \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass}  \\
} \\
\end{session}
\]
\hrule
\caption{Interference, capabilities (the top), and sketch proof (the bottom) for write skew under snapshot isolation}
\label{fig:write-skew-si-proof}
\end{figure}

In the sketch proof (\cref{fig:write-skew-si-proof}), \emph{A shared region assertion} also know as \emph{a boxed assertion} in the form of \( \boxass{\bar{\lpre}}{\lrid}{\intass}\) describes that there is a region with \emph{a unique region identifier} \( \lrid \) and \emph{interference  assertion} \( \intass \), and the assertions inside \( \bar{\lpre} \) describe views on key-value stores.
Note that unlike serialisibility, the view might be out-of-date for SI.
In the assertion, a value with a underline means \emph{a potentially out-of-date value}, otherwise it is the \emph{most recent value}.
For instance, \( \boxass{\vx \pt 0 \sep ( \vy \pt \underline{0} \lor \vy \pt \underline{1} ) }{\lrid}{\intass}\) from \( P1 \) asserts views where \( \vx \) points to the most recent value of 0, but \( \vy \) points to a potentially out-of-date value of either 0 or 1.
Each region are shareable and indivisible, \ie \( \boxass{\bar{\lpre}}{\lrid}{\intass} \sep \boxass{\bar{\lpost}}{\lrid}{\intass} \iff \boxass{\bar{\lpre} \land \bar{\lpost}}{\lrid}{\intass}\).

The \emph{interference assertion} \( \intass \) specifies how the regions can evolve.
It is a set of actions, each of which has the form \( \kap : \fp \) where \( \kap \) is the \emph{client-specified capability} and \( \fp \) is the \emph{fingerprint}.
A client is allowed to execute a transaction with the fingerprint \( \fp \), when the client holds the capability \( \kap \).
The \( \CB{L}\) allows a client to read \( \vy \) when it is 0 and write 1 to \( \vx \), and similarly \( \CB{R} \) allows a client to read \( \vx \) when it is 0 and write 1 to \( \vy \).
The \( \fp \) also specifies capabilities transformation, for example in the example, both \( \CB{L} \) and \( \CB{R} \) need to be move into the region once they have been used.
The \emph{client-specified capability} forms \emph{a partial commutative monoid (PCM)} where \( \composeK \) denotes the composition function.
In the write skew example, both \( \CB{L} \) and \( \CB{R} \) are unique because the compositions with themselves are undefined, and \( \CB{U} \) is the unit.
The unit \( \CB{U} \) allows clients to always read \( \vx \) or \( \vy \) no matter the values.

Given the interference, an assertion \( \gpre \) is \emph{stable}, iff it holds against the interference from the environment.
Since the assertions describe views on key-value stores.
Stabilisation has two meanings: the environment might change the key-value stores but not the views, since the views are local; consequentially, the views can be advanced.
For example, \( P1 \) describes either the environment does nothing or the environment has performed the action associated with \( \cass{\CB{R}}{\lrid}\), 
after which the environment cannot do any further actions since the capabilities \( \cass{\CB{R}}{\lrid}\) is in the shared region.
Let discuss the assertions \( \vy \pt \underline{0}  \lor \vy \pt 1 \) from \( P1 \).
The underline value \( \underline{0} \) means the environment changed the state of the key-value store which make the view out-of-date.
Because the view can be advanced by stabilisation and the capability \( \cass{\CB{R}}{\lrid} \) is in the region, we get a up-to-date \( \vy \pt 1 \).

Because of atomicity, A transaction works on it own snapshot and only commits the fingerprint by the end.
We use \emph{transactional assertions} to describe the state of local snapshots for transactions and also the fingerprints.
The transactional assertions for a single key have the following forms: \( \vx \fpI 0 \), \( \vx \fpR 0\), \( \vx \fpW 0\), and \( \vx \fpRW (0,1) \), where \( \otR \) and \( \otW \) are read and write labels.
The first three asserts the key \( \vx \) in the local snapshot has value 0 and it has not been touched (no label), has been read (\(\otR\)) and has been written (\(\otW\)) respectively.
The last one asserts that the key \( \vx \) currently has value 1, \emph{the first read preceding any write} fetches 0 and the \emph{the last write} updates the key to \( 1 \).
We extend the standard sequential separation logic rules in a ways that the first read before any write to a key adds a read label to the assertion; and a write to a key adds a write label to assertion and updates the value.
Note that when writing to an key that has been read, the assertion after will have two values where the first corresponds to old read value and the second corresponds the written value.

When a transaction starts, it takes a snapshot provided by the view.
For example,  because of \( P1 \) where the view for the \( \vx \) has value 0 and \( \vy \) has value either 0 or 1, the precondition \( p1 \) for transaction \( \txid_1 \) describe exactly the same states, and initial all keys have no fingerprint.
To verify the transaction, it means collecting the fingerprint.
By the end, the postcondition \( q1 \) says the transaction \( \txid_1 \) either reads \( \vy \) with 0 and writes 1 to \( \vx \), or only reads \( \vy \) with 1 and does nothing to \( \vx \).

To committing the fingerprint under SI, we first need to check the view from \( P1 \).
SI requires that if a view observe some transactions, it should observe everything before.
It holds for \( P1 \).
Now given the view on the key-value store \( \gpre \), and committing the fingerprint of the transaction \( \lpost \) under SI means: 
(i) for any key that has been over-written, the view before for the key should be up-to-date and the view after should points to the new version;
(ii) for any key that has been read, the view before points to a version containing the same value and the view after remains the same;
{iii) there are some local capabilities that allows the updates.
This will give us the following assertion before stabilisation:
\[
\boxass{ \vx \pt 1 \sep \vy \pt 0 \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass} 
\lor \boxass{\vx \pt 1 \sep \vy \pt \underline{0}  \sep \cass{\CB{R}}{\lrid} \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass}
\lor \cass{\CB{L}}{\lrid} \sep \boxass{\vx \pt 0 \sep \vy \pt 1 \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass} 
\]
We need to stylise the assertions.
The environment can still change the state that satisfies the first disjunction, because environment still has the ability  to change the value of \( \vy \), which yield the state satisfying the second disjunction.
The second conduction can be stabilised by advancing the view.
Now we have a stable assertions as \( Q1 \) in \cref{fig:write-skew-si-proof}.

Following similar reasoning for right-hand-side client, we get \( Q2 \).
The final \( Q \) is  \( Q = Q1 \sep Q2 \) provided that \( \boxass{\bar{\lpre}}{\lrid}{\intass} \sep \boxass{\bar{\lpost}}{\lrid}{\intass} \iff \boxass{\bar{\lpre} \land \bar{\lpost}}{\lrid}{\intass}\).
It means the final views and key-value stores are those come from both \( Q1 \) and \( Q2 \).



%For serialisibility, the stable PL and PR rules out those views that cannot progress via any possible transactions.
%This mean the view must at the end of the history heap.
%The post conditions QL and QR is stronger because the consistency model check in the repartition 

%\[
%\begin{session}
%\specline{\boxass{\vx \pt 0 \sep \vy \pt 0}{\lrid}{\intass} \sep \cass{\CB{L}}{\lrid} \sep \cass{\CB{R}}{\lrid} } \\
%\begin{parl}
%\begin{session}
    %stable-PL : \specline{\cass{\CB{L}}{\lrid} \sep 
            %\boxass{\vx \pt \Set{0} \sep  \begin{B} \vy \pt \Set{0} \lor \vy \pt \Set{1} \end{B} }{\lrid}{\intass} 
    %} \\
    %%PL2 : \specline{\cass{\CB{L}}{\lrid} \sep 
            %%\boxass{\vx \pt 0 \sep \vy \pt 0 }{\lrid}{\intass} \lor {} \\
            %%\boxass{\vx \pt 0 \sep ( \vy \pt 0 \lor \vy \pt 1 ) \sep \cass{\CB{R}}{\lrid}}{\lrid}{\intass} 
    %%} \\
    %\begin{transaction}
        %\specline{\vx \fpI 0 \sep ( \vy \fpI 0 \lor \vy \fpI 1 )} \\
        %\pderef{\pvar{b}}{\vy} ; \\
        %\pifs{\pvar{b} = 0} 
        %\pmutate{\vx}{1} ;
        %\pife \\
        %\specline{\vx \fpW 1 \sep  \vy \fpR 0 \lor \vx \fpI 0 \sep \vy \fpR 1 )} \\
    %\end{transaction} \\
    %QL : \specline{\cass{\CB{L}}{\lrid} \sep 
            %\boxass{\vx \pt \Set{1} \sep \vy \pt \Set{0} }{\lrid}{\intass} \\
            %{} \lor \boxass{\vx \pt \Set{0} \sep \vy \pt \Set{1} }{\lrid}{\intass} \\
    %} \\
%\end{session}
%&
%\begin{session}
    %PR : \specline{\cass{\CB{R}}{\lrid} \sep 
            %\boxass{ \begin{B} \vx \pt \Set{0} \lor \vx \pt \Set{1} \end{B} {} \sep \vy \pt \Set{0} }{\lrid}{\intass} 
    %} \\
    %\begin{transaction}
        %\pderef{\pvar{a}}{\vx} ; 
        %\quad \pifs{\pvar{a} = 0} 
        %\pmutate{\vy}{1} ; 
        %\pife 
    %\end{transaction} \\
    %QR : \specline{\cass{\CB{R}}{\lrid} \sep 
            %\boxass{\vx \pt \Set{0} \sep \vy \pt \Set{1} }{\lrid}{\intass} \\
            %{} \lor \boxass{\vx \pt \Set{1} \sep \vy \pt \Set{0} }{\lrid}{\intass} \\
    %} \\
%\end{session}
%\end{parl} \\
%QL \sep QR : \specline{\cass{\CB{L}}{\lrid} \sep \cass{\CB{R}}{\lrid} \sep 
            %\boxass{\vx \pt \Set{0} \sep \vy \pt \Set{1} }{\lrid}{\intass} 
            %\lor \boxass{\vx \pt \Set{1} \sep \vy \pt \Set{0} }{\lrid}{\intass} \\
%}
%\end{session}
%\]



\input{\RootPath/logic/transaction.tex}
\input{\RootPath/logic/program.tex}
\input{\RootPath/logic/soundness.tex}
%\input{\RootPath/logic/trans_sound.tex}
%\input{\RootPath/logic/prog_sound.tex}

%\input{./logic/assertion_graph.tex}
%\input{./logic/rule_graph.tex}
