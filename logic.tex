\section{Logic}

We present a logic that is parametrised by any consistency model \emph{at least satisfying atomic  read and monotonic read}.
We motivate it by the \emph{write skew} example under snapshot isolation (\cref{fig:write-skew-si-proof}).
This example distinguishes serialisibility from snapshot isolation (SI).
Under serialisibility that transactions appear one after another, only one key, \( \vx \) or \( \vy \), will be 1 at the end.
While under SI, both keys \( \vx \) and \( \vy \) might be 1.
Because both transactions may take snapshots where \( \vx \) and \( \vy \) are 0, and both can commit because the two transactions write different keys.

\begin{figure}[!t]
\hrule
\[
\intass :
\begin{array}[t]{@{} c @{\quad} c @{\quad} c @{\quad} c @{} }
\begin{rclarray}[t]
    \CB{L} & : & \vx \fpW 1 \sep \vy \fpR 0 \sep \null \fpA \cass{\CB{L}}{\lrid} \\
\end{rclarray}
&
\begin{rclarray}[t]
    \CB{R} & : & \vx \fpR 0 \sep \vy \fpW 1 \sep \null \fpA \cass{\CB{R}}{\lrid} \\
\end{rclarray}
&
\begin{rclarray}[t]
    \CB{0} & : & \exsts{\V n} \vx \fpR \V{n} \\
\end{rclarray} 
&
\begin{rclarray}[t]
    \CB{0} & : & \exsts{\V n} \vy \fpR \V{n} \\
\end{rclarray} \\
\end{array}
\]
\[
\CB{L} \composeK \CB{L} \ \text{is undefined} \quad  \CB{R} \composeK \CB{R} \ \text{is undefined} \quad \CB{U} \ \text{is the unit}
\]
\hrule\vspace{5pt}
\[
\begin{session}
{\color{blue}P : } \specline{ \cass{\CB{L}}{\lrid} \sep \cass{\CB{R}}{\lrid} \sep \boxass{\vx \pt 0 \sep \vy \pt 0 }{\lrid}{\intass}  } \\
\begin{parl}
\begin{session}
    {\color{blue}P1 : } \specline{\cass{\CB{L}}{\lrid} \sep 
            \boxass{\vx \pt 0 \sep \vy \pt 0 }{\lrid}{\intass} \\
            {} \lor \boxass{\vx \pt 0 \sep ( \vy \pt 0 \lor \vy \pt 1 ) \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass} 
    } \\
    \txid_1 : \begin{transaction}
        {\color{blue}p1 : } \specline{\vx \fpI 0 \sep ( \vy \fpI 0 \lor \vy \fpI 1 )} \\
        \pderef{\pvar{b}}{\vy} ; 
        \quad \pifs{\pvar{b} = 0} 
        \pmutate{\vx}{1} ;
        \pife \\
        {\color{blue}q1 : } \specline{\vx \fpW 1 \sep  \vy \fpR 0 \lor \vx \fpI 0 \sep \vy \fpR 1 )} \\
    \end{transaction} \\
    {\color{blue}Q1 : } \specline{ 
            \boxass{ \vx \pt 1 \sep \vy \pt 0 \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass} \\
            {} \lor \boxass{\vx \pt 1 \sep ( \vy \pt 0 \lor \vy \pt 1 ) \sep \cass{\CB{R}}{\lrid} \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass}  \\
            {} \lor \cass{\CB{L}}{\lrid} \sep \boxass{\vx \pt 0 \sep \vy \pt 1 \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass}  \\
    } \\
\end{session}
&
\begin{session}
    {\color{blue}P2 : } \specline{\cass{\CB{R}}{\lrid} \sep 
            \boxass{ ( \vx \pt 0 \sep \vy \pt 0 }{\lrid}{\intass} \\
            {} \lor \boxass{ ( \vx \pt 0 \lor \vx \pt 1 ) \sep \vy \pt 0 \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass} 
    } \\
    \txid_2 : \begin{transaction}
        {\color{blue}p2 : } \specline{ ( \vx \fpI 0 \lor \vx \fpI 1 ) \sep \vy \fpI 0 )} \\
        \pderef{\pvar{a}}{\vx} ; 
        \quad \pifs{\pvar{a} = 0} 
        \pmutate{\vy}{1} ; 
        \pife \\
        {\color{blue}q2 : } \specline{ \vx \fpR 0 \sep \vy \fpW 1 \lor \vx \fpR 1 \sep \vy \fpI 0 )} \\
    \end{transaction} \\
    {\color{blue}Q2 : } \specline{ 
            \boxass{ \vx \pt 0 \sep \vy \pt 1 \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass} \\
            {} \lor \boxass{ ( \vx \pt 0 \lor \vx \pt 1 ) \sep \vy \pt 1 \sep \cass{\CB{L}}{\lrid} \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass}  \\
            {} \lor \cass{\CB{R}}{\lrid} \sep \boxass{\vx \pt 1 \sep \vy \pt 0 \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass}  \\
    } \\
\end{session}
\end{parl} \\
{\color{blue}Q : } \specline{ 
        \cass{\CB{L}}{\lrid} \sep \boxass{ \vx \pt 0 \sep \vy \pt 1 \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass} 
        \lor \cass{\CB{R}}{\lrid} \sep \boxass{\vx \pt 1 \sep \vy \pt 0 \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass}   \\
        {} \lor \boxass{ ( \vx \pt 0 \lor \vx \pt 1 ) \sep \vy \pt 1 \sep \cass{\CB{L}}{\lrid} \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass}  \\
} \\
\end{session}
\]
\hrule
\caption{Interference, capabilities (the top), and sketch proof (the bottom) for write skew under snapshot isolation}
\label{fig:write-skew-si-proof}
\end{figure}

In the sketch proof (\cref{fig:write-skew-si-proof}), \emph{A shared region assertion} also know as \emph{a boxed assertion} in the form of \( \boxass{\bar{\lpre}}{\lrid}{\intass}\) describes that there is a region with \emph{a unique region identifier} \( \lrid \) and \emph{interference  assertion} \( \intass \), and the assertions inside \( \bar{\lpre} \) describe views on key-value stores.
Note that unlike serialisibility, the view might be out-of-date for SI.
For instance, \( \boxass{\vx \pt 0 \sep ( \vy \pt 0 \lor \vy \pt 1 ) \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass}\) from \( P1 \) asserts views where \( \vx \) points to the most recent value of 0, but \( \vy \) might point to a out-of-date value of 0.
Each region are shareable and indivisible, \ie \( \boxass{\bar{\lpre}}{\lrid}{\intass} \sep \boxass{\bar{\lpost}}{\lrid}{\intass} \iff \boxass{\bar{\lpre} \land \bar{\lpost}}{\lrid}{\intass}\).

The \emph{interference assertion} \( \intass \) specifies how the regions can evolve.
It is a set of actions, each of which has the form \( \kap : \fp \) where \( \kap \) is the \emph{client-specified capability} and \( \fp \) is the \emph{fingerprint}.
A client is allowed to execute a transaction with the fingerprint \( \fp \), when the client holds the capability \( \kap \).
The \( \CB{L}\) allows a client to read \( \vy \) when it is 0 and write 1 to \( \vx \), and similarly \( \CB{R} \) allows a client to read \( \vx \) when it is 0 and write 1 to \( \vy \).
The \( \fp \) also specifies capabilities transformation, for example in the example, both \( \CB{L} \) and \( \CB{R} \) need to be move into the region once they have been used.
The \emph{client-specified capability} forms \emph{a partial commutative monoid (PCM)} where \( \composeK \) denotes the composition function.
In the write skew example, both \( \CB{L} \) and \( \CB{R} \) are unique because the compositions with themselves are undefined, and \( \CB{U} \) is the unit.
The unit \( \CB{U} \) allows clients to always read \( \vx \) or \( \vy \) no matter the values.

Given the interference, an assertion \( \gpre \) is \emph{stable}, iff it holds against the interference from the environment.
Since the assertions describe views on key-value stores.
Stabilisation has two meanings: the environment might change the key-value stores but not the views, since the views are local; consequentially, the views can be advanced.
For example, \( P1 \) describes either the environment does nothing or the environment has performed the action associated with \( \cass{\CB{R}}{\lrid}\), 
after which the environment cannot do any further actions since the capabilities \( \cass{\CB{R}}{\lrid}\) is in the shared region.
Let discuss the assertions \( \vy \pt 0  \lor \vy \pt 1  \sep \cass{\CB{R}}{\lrid} \) from \( P1 \).
The environment returns the capability \( \cass{\CB{R}}{\lrid} \), it means the environment performs the action associated with the capability, thus  the value \( 0 \) is out-of-date .
Because the view can be advanced by stabilisation and the capability \( \cass{\CB{R}}{\lrid} \) is in the region, we get a up-to-date \( \vy \pt 1 \).

Because of atomicity, A transaction works on it own snapshot and only commits the fingerprint by the end.
We use \emph{transactional assertions} to describe the state of local snapshots for transactions and also the fingerprints.
The transactional assertions for a single key have the following forms: \( \vx \fpI 0 \), \( \vx \fpR 0\), \( \vx \fpW 0\), and \( \vx \fpRW (0,1) \), where \( \otR \) and \( \otW \) are read and write labels.
The first three asserts the key \( \vx \) in the local snapshot has value 0 and it has not been touched (no label), has been read (\(\otR\)) and has been written (\(\otW\)) respectively.
The last one asserts that the key \( \vx \) currently has value 1, \emph{the first read preceding any write} fetches 0 and the \emph{the last write} updates the key to \( 1 \).
We extend the standard sequential separation logic rules in a ways that the first read before any write to a key adds a read label to the assertion; and a write to a key adds a write label to assertion and updates the value.
Note that when writing to an key that has been read, the assertion after will have two values where the first corresponds to old read value and the second corresponds the written value.

When a transaction starts, it takes a snapshot provided by the view.
For example,  because of \( P1 \) where the view for the \( \vx \) has value 0 and \( \vy \) has value either 0 or 1, the precondition \( p1 \) for transaction \( \txid_1 \) describe exactly the same states, and initial all keys have no fingerprint.
To verify the transaction, it means collecting the fingerprint.
By the end, the postcondition \( q1 \) says the transaction \( \txid_1 \) either reads \( \vy \) with 0 and writes 1 to \( \vx \), or only reads \( \vy \) with 1 and does nothing to \( \vx \).

To committing the fingerprint under SI, we first need to check the view from \( P1 \).
SI requires that if a view observe some transactions, it should observe everything before.
It holds for \( P1 \).
Now given the view on the key-value store \( \gpre \), and committing the fingerprint of the transaction \( \lpost \) under SI means: 
(i) for any key that has been over-written, the view before for the key should be up-to-date and the view after should points to the new version;
(ii) for any key that has been read, the view before points to a version containing the same value and the view after remains the same;
{iii) there are some local capabilities that allows the updates.
This will give us the following assertion before stabilisation:
\[
\boxass{ \vx \pt 1 \sep \vy \pt 0 \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass} 
\lor \boxass{\vx \pt 1 \sep \vy \pt 0  \sep \cass{\CB{R}}{\lrid} \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass}
\lor \cass{\CB{L}}{\lrid} \sep \boxass{\vx \pt 0 \sep \vy \pt 1 \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass} 
\]
We need to stylise the assertions.
The environment can still change the state that satisfies the first disjunction, because environment still has the ability  to change the value of \( \vy \), which yield the state satisfying the second disjunction.
The second conduction can be stabilised by advancing the view.
Now we have a stable assertions as \( Q1 \) in \cref{fig:write-skew-si-proof}.

Following similar reasoning for right-hand-side client, we get \( Q2 \).
The final \( Q \) is  \( Q = Q1 \sep Q2 \) provided that \( \boxass{\bar{\lpre}}{\lrid}{\intass} \sep \boxass{\bar{\lpost}}{\lrid}{\intass} \iff \boxass{\bar{\lpre} \land \bar{\lpost}}{\lrid}{\intass}\).
It means the final views and key-value stores are those come from both \( Q1 \) and \( Q2 \).

\begin{figure}[!t]
\hrule
\[
\intass :
\begin{array}[t]{@{} c @{\quad} c @{\quad} c @{\quad} c @{} }
\begin{rclarray}[t]
    \CB{L} & : & \exsts{\V{n}} \vx \fpR \V{n} \sep \vx \fpW \V{n} + 1 \sep \null \fpA \cass{\CB{L}}{\lrid} \\
\end{rclarray}
&
\begin{rclarray}[t]
    \CB{R} & : & \exsts{\V{n}} \vx \fpR \V{n} \sep \vx \fpW \V{n} + 1 \sep \null \fpA \cass{\CB{R}}{\lrid} \\
\end{rclarray} \\
\end{array}
\]
\[
\CB{L} \composeK \CB{L} \ \text{is undefined} \quad  \CB{R} \composeK \CB{R} \ \text{is undefined}
\]
\hrule\vspace{5pt}
\[
\begin{session}
 \specline{ \cass{\CB{L}}{\lrid} \sep \cass{\CB{R}}{\lrid} \sep \boxass{\vx \pt 0}{\lrid}{\intass}  } \\
\begin{parl}
\begin{session}
    \specline{\cass{\CB{L}}{\lrid} \sep 
            \boxass{\vx \pt 0}{\lrid}{\intass} 
            \lor \boxass{\vx \pt 0  \lor \vx \pt 1 \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass} 
    } \\
    \txid_1 : \begin{transaction}
        \specline{ \vx \fpI 0 \lor \vx \fpI 1 } \\
        \pderef{\pvar{a}}{\vy} ; 
        \pmutate{\vx}{\pv{a} + 1} ; \\
        \specline{ \vx \fpW 2 \lor \vx \fpW 1 } \\
    \end{transaction} \\
    \specline{ 
            \boxass{ \vx \pt 1 \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass} \lor {} \\
            \boxass{ \vx \pt 1 \lor \vx \pt 1 \lor \vx \pt 2 \sep \cass{\CB{R}}{\lrid} \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass} \\
    } \\
\end{session}
&
\begin{session}
    \specline{\cass{\CB{R}}{\lrid} \sep 
            \boxass{\vx \pt 0}{\lrid}{\intass} 
            \lor \boxass{\vx \pt 0  \lor \vx \pt 1 \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass} 
    } \\
    \txid_2 : \begin{transaction}
        \specline{ \vx \fpI 0 \lor \vx \fpI 1 } \\
        \pderef{\pvar{b}}{\vy} ; 
        \pmutate{\vx}{\pv{b} + 1} ; \\
        \specline{ \vx \fpW 2 \lor \vx \fpW 1 } \\
    \end{transaction} \\
    \specline{ 
            \boxass{ \vx \pt 1 \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass}  \lor {} \\
            \boxass{ \vx \pt 1 \lor \vx \pt 1 \lor \vx \pt 2 \sep \cass{\CB{L}}{\lrid} \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass} \\
    } \\
\end{session}
\end{parl} \\
    \specline{ 
            \boxass{ \vx \pt 1 \lor \vx \pt 1 \lor \vx \pt 2 \sep \cass{\CB{L}}{\lrid} \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass} \\
    } \\
\end{session}
\]
\hrule\vspace{5pt}
\[
\begin{session}
 \specline{ \cass{\CB{L}}{\lrid} \sep \cass{\CB{R}}{\lrid} \sep \boxass{\vx \pt 0}{\lrid}{\intass}  } \\
\begin{parl}
\begin{session}
    \specline{\cass{\CB{L}}{\lrid} \sep 
            \boxass{\vx \pt 0}{\lrid}{\intass} 
            \lor \boxass{ \vy \pt 1 \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass} 
    } \\
    \txid_1 : \begin{transaction}
        \specline{ \vx \fpI 0 \lor \vx \fpI 1 } \\
        \pderef{\pvar{a}}{\vy} ; 
        \pmutate{\vx}{\pv{a} + 1} ; \\
        \specline{ \vx \fpW 2 \lor \vx \fpW 1 } \\
    \end{transaction} \\
    \specline{ 
            \boxass{ \vx \pt 1 \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass}
            \lor \boxass{ \vx \pt 2 \sep \cass{\CB{R}}{\lrid} \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass} \\
    } \\
\end{session}
&
\begin{session}
    \specline{\cass{\CB{R}}{\lrid} \sep 
            \boxass{\vx \pt 0}{\lrid}{\intass} 
            \lor \boxass{\vy \pt 1 \sep \cass{\CB{L}}{\lrid} }{\lrid}{\intass} 
    } \\
    \txid_2 : \begin{transaction}
        \specline{ \vx \fpI 0 \lor \vx \fpI 1 } \\
        \pderef{\pvar{b}}{\vy} ; 
        \pmutate{\vx}{\pv{b} + 1} ; \\
        \specline{ \vx \fpW 2 \lor \vx \fpW 1 } \\
    \end{transaction} \\
    \specline{ 
            \boxass{ \vx \pt 1 \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass}
            \lor \boxass{\vx \pt 2 \sep \cass{\CB{L}}{\lrid} \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass} \\
    } \\
\end{session}
\end{parl} \\
    \specline{ 
            \boxass{ \vx \pt 2 \sep \cass{\CB{L}}{\lrid} \sep \cass{\CB{R}}{\lrid} }{\lrid}{\intass} \\
    } \\
\end{session}
\]
\hrule
\caption{Sketch proofs for concurrent increments under serialisibility (the bottom) and casual consistency (the middle)}
\label{fig:increment-proof}
\end{figure}

The \cref{fig:increment-proof} shows proofs for the same concurrent increments under different consistency model. 
The one in the bottom is the sketch proof under serialisibility, and the one in the middle is under causal consistency.
Under causal consistency, a transaction can start with a view that is out-of-date and still able to write a new value for keys.
That means, the fingerprint \( \vx \fpW 1\) is allowed to commit when the shared state is \( \vx \pt 0 \).
The same situation will be disallowed under serialisibility.

Using the similar pattern by putting back the capabilities to the region once it has been used,
We can also prove the long fork, which distinguish snapshot isolation from parallel isolation.

\begin{figure}[!t]
\hrule
\[
\intass :
\begin{array}[t]{@{} c @{\quad} c @{\quad}  c @{} }
\begin{rclarray}[t]
    \CB{L1} \composeK \CB{L2} & : & \vx \fpW 1 \sep \null \fpA \cass{\CB{L1}}{\lrid} \\
\end{rclarray}
&
\begin{rclarray}[t]
    \CB{R1} \composeK \CB{R2} & : & \vy \fpW 1 \sep \null \fpA \cass{\CB{R1}}{\lrid} \\
\end{rclarray}
&
\begin{rclarray}[t]
    \CB{U} & : & \exsts{\V{n}} \vy \fpR \V{n} \\
\end{rclarray}
\\
\begin{rclarray}[t]
    \CB{L2} & : & \vy \fpR 0 \sep \null \fpA \cass{\CB{L2}}{\lrid} \\
\end{rclarray}
&
\begin{rclarray}[t]
    \CB{R2} & : & \vx \fpR 0 \sep \null \fpA \cass{\CB{R2}}{\lrid} \\
\end{rclarray}
&
\begin{rclarray}[t]
    \CB{U} & : & \exsts{\V{n}} \vx \fpR \V{n} \\
\end{rclarray}
\end{array}
\]

\( \CB{U} \) is the unit and other capabilities are unique.

\hrule\vspace{5pt}
\[
\begin{session}
\specline{ \cass{\CB{L1}}{\lrid} \sep \cass{\CB{L2}}{\lrid} \sep \cass{\CB{R1}}{\lrid} \sep \cass{\CB{R2}}{\lrid} \sep \boxass{\vx \pt 0 \sep \vy \pt 0}{\lrid}{\intass}  } \\
\begin{parl}
\begin{session}
    \specline{ 
        \cass{\CB{L1}}{\lrid} \sep \cass{\CB{L2}}{\lrid} \sep \boxass{\vx \pt 0 \sep \vy \pt 0}{\lrid}{\intass} \\
        {} \lor \boxass{\vx \pt 0 \sep ( \vy \pt 0 \lor \vy \pt 1 ) \\ {} \sep \cass{\CB{R1}}{\lrid} 
        \sep ( \cass{\CB{R2}}{\lrid} \lor \assemp ) }{\lrid}{\intass} 
    } \\
    \begin{transaction}
        \pmutate{\vx}{1} ; \\
    \end{transaction} \\
    \specline{ 
        \cass{\CB{L2}}{\lrid} \sep \boxass{\vx \pt 1 \sep \vy \pt 0 \sep \cass{\CB{L1}}{\lrid} }{\lrid}{\intass} \lor {} \\
        \boxass{\vx \pt 1 \sep ( \vy \pt 0 \lor \vy \pt 1 ) \sep \cass{\CB{R1}}{\lrid} 
        \sep \cass{\CB{L1}}{\lrid} }{\lrid}{\intass}  \\
        {} \lor \boxass{\vx \pt 1 \sep  \vy \pt 1 \sep \cass{\CB{R1}}{\lrid} 
        \sep \cass{\CB{R2}}{\lrid} \sep \cass{\CB{L1}}{\lrid} }{\lrid}{\intass} 
    } \\
    \begin{transaction}
        \pderef{\pv{a}}{\vy}; \\
        \pifs{ \pv{a} = 0 } 
        \passign{\pv{f1}}{1} ; 
        \pife
    \end{transaction} \\
    \specline{ 
        \boxass{\vx \pt 1 \sep \vy \pt 0 \sep \cass{\CB{L1}}{\lrid} \sep \cass{\CB{L2}}{\lrid} }{\lrid}{\intass} \\
        {} \lor \boxass{\vx \pt 1 \sep ( \vy \pt 0 \lor \vy \pt 1 ) \\ 
        {} \sep \cass{\CB{R1}}{\lrid} \sep \cass{\CB{L1}}{\lrid} \sep \cass{\CB{L2}}{\lrid} }{\lrid}{\intass}  \lor {} \\
        \cass{\CB{L2}}{\lrid} \sep  \boxass{\vx \pt 1 \sep \vy \pt 1  \sep \cass{\CB{R1}}{\lrid} \\ {}
        \sep ( \cass{\CB{R2}}{\lrid} \lor \assemp ) \sep \cass{\CB{L1}}{\lrid} }{\lrid}{\intass} \\
    } \\
\end{session}
&
\begin{session}
    \specline{ 
        \cass{\CB{R1}}{\lrid} \sep \cass{\CB{R2}}{\lrid} \sep \boxass{\vx \pt 0 \sep \vy \pt 0}{\lrid}{\intass} \\
        {} \lor \boxass{(\vx \pt 0 \lor \vx \pt 1) \sep \vy \pt 0  \\ {} \sep \cass{\CB{L1}}{\lrid} 
        \sep ( \cass{\CB{L2}}{\lrid} \lor \assemp ) }{\lrid}{\intass} 
    } \\
    \begin{transaction}
        \pmutate{\vy}{1} ; \\
    \end{transaction} \\
    \specline{ 
        \cass{\CB{R2}}{\lrid} \sep \boxass{\vx \pt 0 \sep \vy \pt 1 \sep \cass{\CB{R1}}{\lrid} }{\lrid}{\intass} \lor {} \\
        \boxass{(\vx \pt 0 \lor \vx \pt 1) \sep \vy \pt 1 \sep \cass{\CB{L1}}{\lrid} 
        \sep \cass{\CB{R1}}{\lrid} }{\lrid}{\intass} \\
        {} \lor \boxass{\vx \pt 1 \sep \vy \pt 1 \sep \cass{\CB{L1}}{\lrid} 
        \sep \cass{\CB{L2}}{\lrid} \sep \cass{\CB{R1}}{\lrid} }{\lrid}{\intass} \\
    } \\
    \begin{transaction}
        \pderef{\pv{b}}{\vy}; \\
        \pifs{ \pv{b} = 0 } 
        \passign{\pv{f2}}{1} ; 
        \pife
    \end{transaction} \\
    \specline{ 
        \boxass{\vx \pt 0 \sep \vy \pt 1 \sep \cass{\CB{R1}}{\lrid} \sep \cass{\CB{R2}}{\lrid} }{\lrid}{\intass} \\
        {} \lor \boxass{( \vx \pt 0 \lor \vx \pt 1 ) \sep \vy \pt 1 \sep \\ 
        {} \cass{\CB{L1}}{\lrid} \sep \cass{\CB{R1}}{\lrid} \sep \cass{\CB{R2}}{\lrid} }{\lrid}{\intass}  \lor {} \\
        \cass{\CB{R2}}{\lrid} \sep  \boxass{\vx \pt 1 \sep \vy \pt 1  \sep \cass{\CB{L1}}{\lrid} \\ {}
        \sep ( \cass{\CB{L2}}{\lrid} \lor \assemp ) \sep \cass{\CB{R1}}{\lrid} }{\lrid}{\intass} \\
    } \\
\end{session}
\end{parl} \\
\specline{ 
    \cass{\CB{L2}}{\lrid} \sep \boxass{\vx \pt 1 \sep \vy \pt 1 \sep 
    \cass{\CB{L1}}{\lrid} \sep \cass{\CB{R1}}{\lrid} \sep \cass{\CB{R2}}{\lrid} }{\lrid}{\intass} \lor 
    \cass{\CB{R2}}{\lrid} \sep \boxass{\vx \pt 1 \sep \vy \pt 1 \sep 
    \cass{\CB{L1}}{\lrid} \sep \cass{\CB{R1}}{\lrid} \sep \cass{\CB{L2}}{\lrid} }{\lrid}{\intass} \\
    {} \lor \cass{\CB{L2}}{\lrid} \sep \cass{\CB{R2}}{\lrid} \sep \boxass{\vx \pt 1 \sep \vy \pt 1  \sep \cass{\CB{L1}}{\lrid} \sep \cass{\CB{R1}}{\lrid} }{\lrid}{\intass} \\
} \\
\end{session}
\]
\hrule
\caption{Sketch proofs for long fork under snapshot isolation}
\label{fig:long-fork-proof}
\end{figure}

In \cref{fig:long-fork-proof}, when left client observe that the shared state has \( \cass{\CB{R1}}{\lrid} \sep \cass{\CB{R2}}{\lrid} \sep \cass{\CB{L1}}{\lrid} \), the view must be update to both one for two key.
Because both \( \cass{\CB{L1}}{\lrid} \) and \( \cass{\CB{L2}}{\lrid} \), it means the environment has updated \( \vy \) to 1 and then read \( \vx \) with value 0 in order.
Because the left client updated the \( \vy \) to 1, while the environment successfully read \( \vx \) with a old value 0, the snapshot isolation requires the view must include all transaction before the read, therefore the view must include the write of \( \vy \).


\input{\RootPath/logic/transaction.tex}
\input{\RootPath/logic/program.tex}
\input{\RootPath/logic/soundness.tex}
%\input{\RootPath/logic/trans_sound.tex}
%\input{\RootPath/logic/prog_sound.tex}

%\input{./logic/assertion_graph.tex}
%\input{./logic/rule_graph.tex}
