\section{Logic}

\sx{small intro for why a logic}

We present a logic that is parametrised by any consistency model \emph{at least satisfying atomic  read and monotonic read}.
We motivate it by the \emph{write skew} example under snapshot isolation (\cref{fig:write-skew-si-proof}).
This example distinguishes serialisibility from snapshot isolation (SI).
Under serialisibility that transactions appear one after another, only one key, \( \vx \) or \( \vy \), will be 1 at the end.
While under SI, both keys \( \vx \) and \( \vy \) might be 1.
Because both transactions may take snapshots where \( \vx \) and \( \vy \) are 0, and both can commit because the two transactions write different keys.

In the sketch proof (\cref{fig:write-skew-si-proof}), \emph{A shared region assertion} also know as \emph{a boxed assertion} in the form of \( \boxass{\gpre}{\lrid}{\intass}\) describes that there is a region with \emph{a unique region identifier} \( \lrid \) and \emph{interference} \( \intass \), and the assertions inside \( \gpre \) satisfies views on key-value stores.
Note that there might be many views on the same key-value store, some of which might be out-of-date.
In the assertion, a value with a underline means \emph{a potentially out-of-date value}, otherwise it is the \emph{most recent value}.
For instance, \( \boxass{\vx \pt 0 \sep ( \vy \pt \underline{0} \lor \vy \pt \underline{1} ) }{\lrid}{\intass}\) from \( P1 \) asserts views where \( \vx \) points to the most recent value of 0, but \( \vy \) points to a potentially out-of-date value of either 0 or 1.
Each region are shareable and indivisible, \ie \( \boxass{\gpre}{\lrid}{\intass} \sep \boxass{\gpost}{\lrid}{\intass} \iff \boxass{\gpre \land \gpost}{\lrid}{\intass}\).

Regions are associated with \emph{interference} to specify how the regions can evolve.
The \emph{interference} \( \intass \) is a set of actions, each of which has the form \( \kap : \fp \) where \( \kap \) is the \emph{client-specified capability} and \( \fp \) is the \emph{fingerprint}.
A client is allowed to execute a transaction with the fingerprint \( \fp \), when the client holds the capability \( \kap \).
The \emph{client-specified capability} forms \emph{a partial commutative monoid (PCM)} where \( \composeK \) denotes the composition function.
In the write skew example, both \( \CB{L} \) and \( \CB{R} \) are unique because the compositions with themselves are undefined, and \( \CB{0} \) is the unit.
The \( \CB{L}\) allows a client to read \( \vy \) when it is 0 and write 1 to \( \vx \), and similarly \( \CB{R} \) allows a client to read \( \vx \) when it is 0 and write 1 to \( \vy \).
The unit \( \CB{0} \) allows clients to always read \( \vx \) or \( \vy \) no matter the values.

When a transaction starts, it take a snapshot give provided by the views.
For example the \( \txid_1 \) in \cref{fig:write-skew-si-proof} has precondition \( p1 \).
The transactional assertions for a single key are combinations of the state of key and the fingerprint.
They are one of the forms: \( \vx \ptI 0 \), \( \vx \ptR 0\), \( \vx \ptW 0\), and \( \vx \ptRW (0,1) \), where \( \otR \) and \( \otW \) are read and write labels.
The first three asserts the key \( \vx \) in the local snapshot has value 0 and it has not been touched, has been read and has been written respectively.
The last one asserts that the key \( \vx \) has value 1, \emph{the first read preceding any write} fetches 0 and the \emph{the last write} updates the key to \( 1 \).

\begin{figure}[!t]
\hrule
\[
\intass :
\begin{array}[t]{@{} c @{\quad} c @{\quad} c @{\quad} c @{} }
\begin{rclarray}[t]
    \CB{L} & : & \vx \fpW 1 \sep \vy \fpR 0  \\
\end{rclarray}
&
\begin{rclarray}[t]
    \CB{R} & : & \vx \fpR 0 \sep \vy \fpW 1  \\
\end{rclarray}
&
\begin{rclarray}[t]
    \CB{0} & : & \exsts{\V n} \vx \fpR \V{n} \\
\end{rclarray} 
&
\begin{rclarray}[t]
    \CB{0} & : & \exsts{\V n} \vy \fpR \V{n} \\
\end{rclarray} \\
\end{array}
\]
\[
\CB{L} \composeK \CB{L} \ \text{is undefined} \quad  \CB{R} \composeK \CB{R} \ \text{is undefined} \quad \CB{0} \ \text{is the unit}
\]
\hrule\vspace{5pt}
\[
\begin{session}
{\color{blue}P : } \specline{ \cass{\CB{L}}{\lrid} \sep \cass{\CB{R}}{\lrid} \sep \boxass{\vx \pt 0 \sep \vy \pt 0 }{\lrid}{\intass}  } \\
\begin{parl}
\begin{session}
    {\color{blue}P1 : } \specline{\cass{\CB{L}}{\lrid} \sep 
            \boxass{\vx \pt 0 \sep ( \vy \pt \underline{0}  \lor \vy \pt \underline{1} ) }{\lrid}{\intass} 
    } \\
    \txid_1 : \begin{transaction}
        {\color{blue}p1 : } \specline{\vx \fpI 0 \sep ( \vy \fpI 0 \lor \vy \fpI 1 )} \\
        \pderef{\pvar{b}}{\vy} ; 
        \quad \pifs{\pvar{b} = 0} 
        \pmutate{\vx}{1} ;
        \pife \\
        {\color{blue}q1 : } \specline{\vx \fpW 1 \sep  \vy \fpR 0 \lor \vx \fpI 0 \sep \vy \fpR 1 )} \\
    \end{transaction} \\
    {\color{blue}Q1 : } \specline{\cass{\CB{L}}{\lrid} \sep 
            \boxass{ \vx \pt 1 \sep \vy \pt \underline{0} \lor {} \\ \vx \pt 1 \sep \vy \pt \underline{1} \lor \vx \pt 0 \sep \vy \pt \underline{1} }{\lrid}{\intass} \\
    } \\
\end{session}
&
\begin{session}
    {\color{blue}P2 : } \specline{\cass{\CB{R}}{\lrid} \sep 
            \boxass{ ( \vx \pt \underline{0} \lor \vx \pt \underline{1} ) \sep \vy \pt 0 }{\lrid}{\intass} 
    } \\
    \txid_2 : \begin{transaction}
        {\color{blue}p2 : } \specline{ ( \vx \fpI 0 \lor \vx \fpI 1 ) \sep \vy \fpI 0 )} \\
        \pderef{\pvar{a}}{\vx} ; 
        \quad \pifs{\pvar{a} = 0} 
        \pmutate{\vy}{1} ; 
        \pife \\
        {\color{blue}q2 : } \specline{ \vx \fpR 0 \sep \vy \fpW 1 \lor \vx \fpR 1 \sep \vy \fpI 0 )} \\
    \end{transaction} \\
    {\color{blue}Q2 : } \specline{\cass{\CB{R}}{\lrid} \sep 
            \boxass{\vx \pt \underline{0} \sep \vy \pt 1 \lor {} \\ \vx \pt \underline{1} \sep \vy \pt 1 \lor \vx \pt \underline{1} \sep \vy \pt 0 }{\lrid}{\intass} \\
    } \\
\end{session}
\end{parl} \\
{\color{blue}Q : } \specline{%
    \cass{\CB{L}}{\lrid} \sep \cass{\CB{R}}{\lrid} \sep 
    \boxass{\vx \pt 0 \sep \vy \pt 1 \lor \vx \pt 1 \sep \vy \pt 1 \lor \vx \pt 1 \sep \vy \pt 0 }{\lrid}{\intass} \\ } \\
\end{session}
\]
\hrule
\caption{Interference, capabilities (the top), and sketch proof (the bottom) for write skew under snapshot isolation}
\label{fig:write-skew-si-proof}
\end{figure}

%For serialisibility, the stable PL and PR rules out those views that cannot progress via any possible transactions.
%This mean the view must at the end of the history heap.
%The post conditions QL and QR is stronger because the consistency model check in the repartition 

%\[
%\begin{session}
%\specline{\boxass{\vx \pt 0 \sep \vy \pt 0}{\lrid}{\intass} \sep \cass{\CB{L}}{\lrid} \sep \cass{\CB{R}}{\lrid} } \\
%\begin{parl}
%\begin{session}
    %stable-PL : \specline{\cass{\CB{L}}{\lrid} \sep 
            %\boxass{\vx \pt \Set{0} \sep  \begin{B} \vy \pt \Set{0} \lor \vy \pt \Set{1} \end{B} }{\lrid}{\intass} 
    %} \\
    %%PL2 : \specline{\cass{\CB{L}}{\lrid} \sep 
            %%\boxass{\vx \pt 0 \sep \vy \pt 0 }{\lrid}{\intass} \lor {} \\
            %%\boxass{\vx \pt 0 \sep ( \vy \pt 0 \lor \vy \pt 1 ) \sep \cass{\CB{R}}{\lrid}}{\lrid}{\intass} 
    %%} \\
    %\begin{transaction}
        %\specline{\vx \fpI 0 \sep ( \vy \fpI 0 \lor \vy \fpI 1 )} \\
        %\pderef{\pvar{b}}{\vy} ; \\
        %\pifs{\pvar{b} = 0} 
        %\pmutate{\vx}{1} ;
        %\pife \\
        %\specline{\vx \fpW 1 \sep  \vy \fpR 0 \lor \vx \fpI 0 \sep \vy \fpR 1 )} \\
    %\end{transaction} \\
    %QL : \specline{\cass{\CB{L}}{\lrid} \sep 
            %\boxass{\vx \pt \Set{1} \sep \vy \pt \Set{0} }{\lrid}{\intass} \\
            %{} \lor \boxass{\vx \pt \Set{0} \sep \vy \pt \Set{1} }{\lrid}{\intass} \\
    %} \\
%\end{session}
%&
%\begin{session}
    %PR : \specline{\cass{\CB{R}}{\lrid} \sep 
            %\boxass{ \begin{B} \vx \pt \Set{0} \lor \vx \pt \Set{1} \end{B} {} \sep \vy \pt \Set{0} }{\lrid}{\intass} 
    %} \\
    %\begin{transaction}
        %\pderef{\pvar{a}}{\vx} ; 
        %\quad \pifs{\pvar{a} = 0} 
        %\pmutate{\vy}{1} ; 
        %\pife 
    %\end{transaction} \\
    %QR : \specline{\cass{\CB{R}}{\lrid} \sep 
            %\boxass{\vx \pt \Set{0} \sep \vy \pt \Set{1} }{\lrid}{\intass} \\
            %{} \lor \boxass{\vx \pt \Set{1} \sep \vy \pt \Set{0} }{\lrid}{\intass} \\
    %} \\
%\end{session}
%\end{parl} \\
%QL \sep QR : \specline{\cass{\CB{L}}{\lrid} \sep \cass{\CB{R}}{\lrid} \sep 
            %\boxass{\vx \pt \Set{0} \sep \vy \pt \Set{1} }{\lrid}{\intass} 
            %\lor \boxass{\vx \pt \Set{1} \sep \vy \pt \Set{0} }{\lrid}{\intass} \\
%}
%\end{session}
%\]



\input{\RootPath/logic/assertion.tex}
\input{\RootPath/logic/rule.tex}

\section{Soundness of Logic}

\input{\RootPath/logic/trans_sound.tex}
\input{\RootPath/logic/prog_sound.tex}

%\input{./logic/assertion_graph.tex}
%\input{./logic/rule_graph.tex}
