\ac{Shale's Proof of Compositionality starts here.}
%\section{Commutativity of execution test}
%\ac{This is a different topic than separation logic. These 
%proofs should be in their own individual appendix.}

\begin{theorem}
\label{thm:appendix-et-composition-1}
Let $\ET_1, \ET_2$ be two execution tests with no blinding writes. 
If $\ET_1$ is commutative, then $\CMs(\ET_1 \cap \ET_2) = \CMs(\ET_1) \cap \CMs(\ET_2)$. 
\end{theorem}
\begin{proof}
Given the definition of the \( \CMs(.) \) function (\cref{def:cm}), 
it suffices to prove that \( \CMs(\ET_{1} \cap \ET{2}) \subseteq \CMs(\ET_1) \cap \CMs(\ET_2) \)
and \( \CMs(\ET_1) \cap \CMs(\ET_2) \subseteq \CMs(\ET_{1} \cap \ET{2}) \).
The former is proven by the \cref{lem:et12-in-et1-et2} and the later is proven by \cref{lem:et1-et2-in-et12}.
\end{proof}

\begin{lemma}
\label{lem:et12-in-et1-et2}
\( \CMs(\ET_{1} \cap \ET_{2}) \subseteq \CMs(\ET_1) \cap \CMs(\ET_2) \).
\end{lemma}
\begin{proof}
It suffices to prove a stronger result that \( \Confs(\ET_{1} \cap \ET_{2}) \subseteq \Confs(\ET_1) \cap \Confs(\ET_2) \).
By the definition of \Confs (\cref{def:cm}), it suffices to prove the following:
\begin{equation}
    \label{equ:et12-in-et1-et2}
    \begin{array}{@{}l}
    \fora{n,\conf_0, \conf_1, \dots, \conf_n} \conf_0 \text{ is initial } 
    \land \conf_0 \xrightarrowtriangle{\stub}_{\ET_1 \cap \ET_2} \cdots \xrightarrowtriangle{\stub}_{\ET_1 \cap \ET_2} \conf_n \implies {} \\
    \quad \conf_0 \xrightarrowtriangle{\stub}_{\ET_{1}} \cdots \xrightarrowtriangle{\stub}_{\ET_{1}} \conf_n \land \conf_0 \xrightarrowtriangle{\stub}_{\ET_{2}} \cdots \xrightarrowtriangle{\stub}_{\ET_{2}} \conf_n 
    \end{array}
\end{equation}
We prove the \cref{equ:et12-in-et1-et2} by induction on the number \( n \).
\begin{itemize}
\item Base case: \(n = 0\). 
The \cref{equ:et12-in-et1-et2} holds when \( n = 0 \), because all initial configurations \( \conf_0 \) are included in the \( \Confs(\ET_1)\) and \( \Confs(\ET_2) \) by the definition of the \( \Confs \) function (\cref{def:cm}).

\item Inductive case: \(n = i+1\). Suppose the \cref{equ:et12-in-et1-et2} holds when \( n = i \) for some \( i \).
Let consider \( n = i + 1 \) and specifically the last step.
For any \( \conf_{i+1} = (\mkvs_{i+1}, \viewFun_{i+1}) \) induced by \( \ET_{1} \cap \ET_2 \), 
there exist some client \( \cl \), views \( \vi, \vi' \) and fingerprint \( \f \) such that:
\[
    (\mkvs_i, \viewFun_i) \xrightarrowtriangle{\cl, \opset}_{\ET_{1} \cap \ET_{2}} (\mkvs_{i+1}, \viewFun_{i+1}) \land \viewFun_{i+1} = \viewFun_{i}\rmto{\cl}{\vi'} \land (\mkvs_i, \vi, \f, \vi' ) \in \ET_{1} \cap \ET_{2}
\]
Thus, it is easy to see that \( \conf_i \xrightarrowtriangle{\cl, \opset}_{\ET_{1}} \conf_{i+1} \) and \( \conf_i \xrightarrowtriangle{\cl, \opset}_{\ET_{2}} \conf_{i+1} \) by the \cref{lem:mono-et}.
\end{itemize}
\end{proof}

\begin{lemma}
\label{lem:mono-et}
If $\conf \xrightarrowtriangle{\cl, \opset}_{\ET} \conf'$ and $\ET \subseteq \ET'$, 
then $\conf \xrightarrowtriangle{\cl, \opset}_{\ET'} \conf'$.
\end{lemma}
\begin{proof}
    Let \((\mkvs, \viewFun)  = \conf \), \( (\mkvs', \viewFun') = \conf' \) and \( \vi  =\viewFun(\cl) \)
    By the definition of  $\conf \xrightarrowtriangle{\cl, \opset}_{\ET} \conf'$ (\cref{def:cm}), we have \(\mkvs' \in \updKV{\mkvs, \vi, \cl, \f}\) and  \( \viewFun' = \viewFun\rmto{\cl}{\vi'} \) for some \( \vi' \) such that \( \ET \vdash (\mkvs, \vi) \csat \f : \vi' \).
    Given that \( \ET \subseteq \ET'\), we know \( \ET' \vdash (\mkvs, \vi) \csat \f : \vi' \) and so $\conf \xrightarrowtriangle{\cl, \opset}_{\ET'} \conf'$.
\end{proof}

\begin{lemma}
\label{lem:et1-et2-in-et12}
\( \CMs(\ET_1) \cap \CMs(\ET_2) \subseteq \CMs(\ET_{1} \cap \ET_{2}) \).
\end{lemma}
\begin{proof}
    By the definition of \( \CMs\) and \( \Confs\) (\cref{def:cm}), we prove a stronger result as the following:
\begin{equation}
    \label{equ:et1-et2-in-et12}
    \begin{array}{@{}l}
    \fora{n,m,\conf_0, \conf_1, \dots, \conf_n, \conf'_1, \dots, \conf'_m} \conf_0 \text{ is initial }  \\
    \quad \conf_0 \xrightarrowtriangle{\stub}_{\ET_{1}} \conf_1 \xrightarrowtriangle{\stub}_{\ET_{1}} \cdots \xrightarrowtriangle{\stub}_{\ET_{1}} \conf_n {} \\
    \quad \land \conf_0 \xrightarrowtriangle{\stub}_{\ET_{2}} \conf'_1 \xrightarrowtriangle{\stub}_{\ET_{2}}  \cdots \xrightarrowtriangle{\stub}_{\ET_{2}} \conf'_m {} 
    \land \conf_n\projection{1} = \conf'_m\projection{1} \\
    \qquad {} \implies \exsts{k, \conf''_1, \dots, \conf''_k} \\
    \qqquad \conf_0 \xrightarrowtriangle{\stub}_{\ET_1 \cap \ET_2} \conf''_1 \xrightarrowtriangle{\stub}_{\ET_1 \cap \ET_2} \cdots \xrightarrowtriangle{\stub}_{\ET_1 \cap \ET_2} \conf''_k 
    \land \conf_n\projection{1} = \conf'_m\projection{1} = \conf''_k\projection{1} \\
    \qqqquad {} \land \fora{\cl \in \dom(\conf''_k\projection{2}),\ke \in (\conf''_k\projection{1})} \conf''_k\projection{2}(\cl)(\ke) = \max\Set{\conf_n\projection{2}(\cl)(\ke), \conf'_m\projection{2}(\cl)(\ke)}
    \end{array}
\end{equation}
We prove \cref{equ:et1-et2-in-et12} by induction on the length \( m \) of the trace of \( \ET_2 \).
\begin{itemize}
    \item \caseB{\(m = 0\)}
We have the trace of \( \ET_1 \):
\begin{equation}
    \label{equ:trace-view-shift-et1}
    \conf_0 \text{ is initial } \land \conf_0 \toET{\stub}{\ET_1} \dots \toET{\stub}{\ET_1} \conf_n
\end{equation}
for some number \( n \) and configurations from \( \conf_0 \) to \( \conf_n \) and the trace of \( \ET_2 \) with only one configuration:
\begin{equation}
    \label{equ:trace-singleton-et2}
    \conf_0
\end{equation}
By the hypothesis we have \( \conf_0\projection{1} = \conf_n\projection{1} \), which means that all the steps from the trace of \( \ET_1 \) are view shift.
We can pick the trace of \( \ET_1 \) (\cref{equ:trace-view-shift-et1}) as the trace of \( \ET_1 \cap \ET_2 \):
\begin{equation}
    \label{equ:trace-view-shift-et12}
    \conf_0 \toET{\stub}{\ET_1 \cap \ET_2} \dots \toET{\stub}{\ET_1 \cap \ET_2} \conf''_k \land  k = n \land \bigwedge_{ 0 < i \leq k} \conf_i = \conf''_i
\end{equation}
It is easy to see:
\begin{equation}
    \label{equ:max-et1-et2}
    \fora{\cl \in \dom(\conf_k\projection{2}), \ke \in \dom(\conf_k\projection{1})} \conf_0\projection{2}(\cl)(\ke) = \max\Set{\conf_0\projection{2}(\cl)(\ke), \conf_n\projection{2}(\cl)(\ke)}
\end{equation}
Combine \cref{equ:trace-view-shift-et12} and \cref{equ:max-et1-et2}, we prove the \cref{equ:et1-et2-in-et12}.

\item \caseI{\(m = i + 1\)}
Suppose that \cref{equ:et1-et2-in-et12} holds when \( m = i \).
Let consider \( m = i + 1 \).
We have the trace for \( \ET_1 \):
\begin{equation}
    \conf_0 \xrightarrowtriangle{\stub}_{\ET_{1}} \conf_1 \xrightarrowtriangle{\stub}_{\ET_{1}} \cdots \xrightarrowtriangle{\stub}_{\ET_{1}} \conf'_{n} 
\end{equation}
for some number \( n \) and the configurations from \(\conf_0\) to \( \conf_n \), and the trace of \(\ET_2\):
\begin{equation}
    \conf_0 \xrightarrowtriangle{\stub}_{\ET_{2}} \conf'_1 \xrightarrowtriangle{\stub}_{\ET_{2}} \cdots \xrightarrowtriangle{\stub}_{\ET_{2}} \conf'_{i+1} 
\end{equation}
It is safe to assume these two traces are in normal form by \cref{prop:et.normalform}.
Assume a client \( \cl'_{i} \), views \( \vi'_{i}, \vi'_{i+1} \) and a fingerprint \( \opset'_{i} \) that commit to the second last configuration \( (\mkvs'_i, \viewFun'_i) = \conf'_i \) in the trace of \( \ET_2 \) which yields the final configuration \( (\mkvs'_{i+1}, \viewFun'_{i+1}) = \conf_{i+1} \):
\begin{equation}
    \label{equ:last-et-2}
    \begin{array}{@{}l @{}}
    (\mkvs'_i, \viewFun'_i) \toET{\cl'_{i}, \opset'_{i}}{\ET_2} (\mkvs'_{i+1}, \viewFun'_{i+1}) \land \ET_2 \vdash (\mkvs'_i, \vi'_i) \csat \f'_i  : \vi'_{i+1} \\
    \quad {} \land \vi' = \viewFun'_i(\cl'_i) \land \viewFun'_{i+1} = \viewFun'_i\rmto{\cl'_i}{\vi'_{i+1}}
    \end{array}
\end{equation}
There are three cases: \textbf{(i)} \( \f'_i = \unitO \), \textbf{(i)} \( \f'_i = \epsilon \) and \textbf{(ii)} \( \f'_i \neq \unitO \land \f'_i \neq \epsilon \).
\begin{itemize}
    \item if \( \f'_i = \unitO \),

    \item If \( \f'_i = \epsilon \), by the \cref{lem:no-effect-for-empty-fingerprint} we know \( \conf'_{i}\projection{1} = \conf'_{i+1}\projection{1}\) from the trace of \( \ET_2 \).
Since \( \conf'_{i+1}\projection{1} = \conf_n\projection{1}\) where \( \conf_n \) is the final configuration of the trace of \( \ET_1 \), we now have \( \conf'_{i}\projection{1} = \conf_n\projection{1}\).
Applying \ih that \cref{equ:et1-et2-in-et12} holds when \( m = i \) gives the following:
\begin{equation}
    \label{equ:ih-for-k-length}
    \begin{array}{@{}l@{}}
    \exsts{k, \conf''_1, \dots, \conf''_k} \\
    \quad \conf_0 \xrightarrowtriangle{\stub}_{\ET_1 \cap \ET_2} \conf''_1 \xrightarrowtriangle{\stub}_{\ET_1 \cap \ET_2} \cdots \xrightarrowtriangle{\stub}_{\ET_1 \cap \ET_2} \conf''_k  \\
    \qquad {} \land \conf_n\projection{1} = \conf'_i\projection{1} = \conf''_k\projection{1}
    \land \fora{\cl \in \dom(\conf''_k\projection{2}),\ke \in (\conf''_k\projection{1})} \\
    \qqquad \conf''_k\projection{2}(\cl)(\ke) = \max\Set{\conf_n\projection{2}(\cl)(\ke), \conf'_i\projection{2}(\cl)(\ke)}
\end{array}
\end{equation}
Given the definition of the reduction (\cref{def:reduction}), when \( \f = \unitO \) we know \( \conf'_i\projection{2}(\cl_{i+1}) \sqsubseteq  \conf'_{i+1}\projection{2}(\cl_{i+1})\) thus:
\begin{equation}
    \label{equ:preserve-max-view}
    \max\Set{\conf_n\projection{2}(\cl_{i+1}), \conf'_i\projection{2}(\cl_{i+1})} \sqsubseteq \max\Set{\conf_n\projection{2}(\cl_{i+1}), \conf'_{i+1}\projection{2}(\cl_{i+1})}
\end{equation}
Therefore \cref{equ:et1-et2-in-et12} holds when \( m = i + 1\) by appending a view shift to the end of the trace in \cref{equ:ih-for-k-length}:
\[
    \begin{array}{@{}l}
    \conf_0 \xrightarrowtriangle{\stub}_{\ET_1 \cap \ET_2} \conf''_1 \xrightarrowtriangle{\stub}_{\ET_1 \cap \ET_2} \cdots \\
    \quad \xrightarrowtriangle{\stub}_{\ET_1 \cap \ET_2} \conf''_k \toET{\cl_{j}, \epsilon }{\ET_1 \cap \ET_2} \\
    \qquad \conf''_k\rmto{2}{\conf''_k\projection{2}\rmto{\cl_{i}}{\max\Set{\conf_n\projection{2}(\cl_{i+1}), \conf'_{i+1}\projection{2}(\cl_{i+1})} }}
    \end{array}
\]

    \item If \( \f'_i \neq \unitO  \land \f' \neq \epsilon \), by \cref{lem:identical-step} there exists a step \( \cl_j, \f_j \) from the trace of \( \ET_1 \) such that:
\begin{equation}
    \label{equ:j-th-step}
    (\mkvs_{j}, \viewFun_{j}) \xrightarrowtriangle{\cl_{j}, \opset_{j}}_{\ET_1} (\mkvs_{j + 1}, \viewFun_{j + 1}) \land \ET \vdash (\mkvs_{j}, \vi_j) \csat \f_j : \viewFun_{j + 1}(\cl_{j}) \land \vi_j = \viewFun_{j}(\cl_j)
\end{equation}
for some \( j, \cl_j, \vi_j\) and \( \f_j \) such that \( 0 \leq  j < n \), \( \cl_j = \cl'_{i}\), \( \vi_j = \vi'_{i}\), and \( \f_j = \f'_{i}\).
We apply the commutativity of \( \ET_1 \) until the step shown in \cref{equ:j-th-step} is at the end of the trace of \( \ET_1 \).
Let consider the next two steps, (j+1)-\emph{th} and (j+2)-\emph{th} step.
Since the trace is in normal form, the (j+1)-\emph{th} step is a view shift and (j+2)-\emph{th} step is a concrete step issued by the same client as the view shift:
\begin{equation}
    \label{equ:j-plus-1-th-step}
    \begin{array}{@{}l}
        (\mkvs_j, \viewFun_j) \xrightarrowtriangle{\cl_{j+2}, \vi_{j+1}, \unitO}_{\ET_1} (\mkvs_{j}, \viewFun_{j}\rmto{\cl_{j+2}}{\vi_{j+2}}) \toET{\cl_{j+2}, \vi_{j+2}, \f_{j+2}}{\ET_1} (\mkvs_{j+2}, \viewFun_{j+2}) \\
    \quad \land \ET \vdash (\mkvs_j,\vi_{j+2}) \csat \f_{j+2} : \viewFun_{j+2}(\cl_{j+2}) 
    \end{array}
\end{equation}
%First, if the fingerprint \( \f_{j+1} \) is an empty fingerprint, the kv-store remains unchanged, \ie \( \mkvs_j = \mkvs_{j+1} \).
%In this case, we can eliminate the (j+1)-\emph{th} step and the new j-\emph{step} is:
%\sx{Maybe a lemma here}
%\[
    %(\mkvs_{j-1}, \viewFun_{j-1}) \xrightarrowtriangle{\cl_{j}, \vi_{j}, \opset_{j}}_{\ET_1} (\mkvs_{j+1}, \viewFun_{j+1}) \land \ET \vdash (\mkvs_{j-1}, \viewFun_{j-1}(\cl_j)) \csat \f_j, \viewFun_{j+1}(\cl_j)
%\]
It is known that the client  \( \cl_{j+2} \) is different from \( \cl_j \) (\cref{lem:different-cl}) and \( \f_{j+2} \) writes different keys from \( \f_j\) (\cref{lem:different-writes}). 
Let discuss the view \( \vi_{j+2} \).
Similarly by the \cref{lem:identical-step}, there is step \((\cl_p, \vi_p, \f_p)\) from the trace of \( \ET_2 \) such that \( \cl_p = \cl_{j+2}\), \( \vi_p = \vi_{j+2} \), \( \f_p = \f_{j+2}\) and \( p \leq i \).
This means the fingerprint \( \vi_p \) does not observe any change by (i+1)-\emph{th} step from the trace of \( \ET_2\).
Therefore \( \vi_{j+2} \) does not observe any change by j-\emph{th} step from the trance of \( \ET_1\), \ie \( \vi_{j+2} \in \Views(\mkvs_j) \).
By \cref{prop:swap-update}, there exist a new kv-stores \( \mkvs'''_{j+1}\) and a new view environment \( \viewFun'''_{j+1} \) such that:
\[
    \begin{array}{@{}l}
    (\mkvs_{j-1}, \viewFun_{j-1}) \xrightarrowtriangle{\cl_{j+2}, \vi_{j+1}, \unitO}_{\ET_1} (\mkvs_{j-1}, \viewFun_{j-1}\rmto{\cl_{j+2}}{\vi_{j+2}})) \\
    \quad {} \toET{\cl_{j+2}, \vi_{j+2}, \f_{j+2}}{\ET_1} (\mkvs'''_{j+1}, \viewFun'''_{j+1}) \xrightarrowtriangle{\cl_{j}, \vi_{j}, \opset_{j}}_{\ET_1} (\mkvs_{j+2}, \viewFun_{j+2}) 
    \end{array}
\]
where the j-\emph{th} step moves to the right of (j+2)-\emph{th} step.
We continuously move the j-\emph{th} step until it is at the end of trace of \( \ET_1 \):
\begin{equation}
    \label{equ:new-et-1}
    \begin{array}{@{}l}
        \quad \conf_0 \xrightarrowtriangle{\stub}_{\ET_{1}} \cdots \xrightarrowtriangle{\stub}_{\ET_{1}} \conf_{j-1} \toET{\stub}{\ET_{1}} \conf'''_{j} \toET{\stub}{\ET_{1}} \dots \toET{\stub}{\ET_{1}} \conf'''_{n-1} \toET{\cl_j, \vi_j, \f_j }{\ET_{1}} \conf_{n} 
    \end{array}
\end{equation}
for some new configurations from \( \conf'''_{j}\) to \( \conf'''_{n-1} \).
Given \cref{equ:last-et-2}, \cref{equ:new-et-1} and the hypothesis that \( \conf_{n}\projection{1} = \conf'_{i+1}\projection{1} \), the kv-stores of the second last configurations from trace of \( \ET_2 \) (\cref{equ:last-et-2}) and the new trace of \( \ET_1 \) (\cref{equ:new-et-1}) are the same \(  \conf'''_{n-1}\projection{1} = \conf'_{i}\projection{1} \).
By applying \ih that \cref{equ:et1-et2-in-et12} holds when \( m = i \), there exists  trace of \( \ET_1 \cap \ET_2 \):
\begin{equation}
    \cref{equ:ih-for-merge-two-trace}
    \begin{array}{@{}l}
    \conf_0 \toET{\stub}{\ET_1 \cap \ET_2} \dots \toET{\stub}{\ET_1 \cap \ET_2} \conf''_{k-1} \land  \conf'''_{n-1}\projection{1} = \conf'_{i}\projection{1} = \conf''_{k-1}\projection{1} \\
    \quad {} \land \fora{\cl \in \dom(\conf''_k\projection{2}),\ke \in (\conf''_k\projection{1})} \conf''_k\projection{2}(\cl)(\ke) = \max\Set{\conf_n\projection{2}(\cl)(\ke), \conf'_i\projection{2}(\cl)(\ke)}
\end{array}
\end{equation}
for some number \( k \) and configurations from \( \conf''_1 \) to \( \conf''_{k-1} \).

By \cref{equ:last-et-2} and \cref{equ:new-et-1}, we have:
\[
    \ET_1 \vdash ( \conf'_{i}\projection{1}, \conf'_{i}\projection{2}(\cl_{i+1}) )  \csat \f_{i+1}, \conf'_{i+1}\projection{2}(\cl_{i+1}) 
    \land \ET_2 \vdash ( \conf'''_{n-1}\projection{1}, \conf'''_{n-1}\projection{2}(\cl_{i+1}) )  \csat \f_{i+1}, \conf_{n}\projection{2}(\cl_{i+1})
\]
so that we have:
\[
    \ET_1 \cap \ET_2 \vdash ( \conf''_{k-1}\projection{1}, \conf''_{k-1}\projection{2}(\cl_{i+1}) )  \csat \f_{i+1}, \max\Set{\conf'_{i+1}\projection{2}(\cl_{i+1}), \conf_{n}\projection{2}(\cl_{i+1})}
\]
Therefore \cref{equ:et1-et2-in-et12} holds when \( m = i + 1\) by appending the step above to the end of the trace in \cref{equ:ih-for-merge-two-trace}:
\[
\begin{array}{@{}l}
    \conf_0 \toET{\stub}{\ET_1 \cap \ET_2} \dots \toET{\stub}{\ET_1 \cap \ET_2} \conf''_{k-1} \\\\
    \quad {} \toET{cl_{i+1}, \vi_{i+1}, \f_{i+1}}{\ET_1 \cap \ET_2} \left( \conf_n\projection{1},\conf''_{k-1}\projection{2}\rmto{\cl_{i+1}}{\max\Set{\conf'_{i+1}\projection{2}(\cl_{i+1}), \conf_{n}\projection{2}(\cl_{i+1})} } \right)
\end{array}
\]
\end{itemize}
\end{itemize}
\end{proof}

\begin{lemma}
    \label{lem:no-effect-for-empty-fingerprint}
    \[
    \fora{\conf, \conf', \cl,\vi} \conf \toET{\cl, \vi, \unitO}{\ET} \conf' \implies \conf\projection{1} = \conf'\projection{1}
    \]
\end{lemma}
\begin{proof}
    Let \((\mkvs, \viewFun)  = \conf \) and \( (\mkvs', \viewFun') = \conf' \).
    By the definition of  $\conf \xrightarrowtriangle{\cl, \vi, \unitO}_{\ET} \conf'$ (\cref{def:cm}), we have \(\mkvs' \in \updKV{\mkvs, \vi, \cl, \unitO}\), and therefore \( \mkvs' = \mkvs \).
\end{proof}


We define a \(  \mkvs(\txid) \) function that returns the fingerprint associate with the transaction identifier \( \txid \):
\[
    \begin{rclarray}
        \mkvs(\txid) & \defeq & \Setcon{(\otW, \ke, \val)}{\exsts{i} \mkvs(\ke)(i) = (\val, \txid, \stub)} \cup  \Setcon{(\otR, \ke, \val)}{\exsts{i,\txidset} \mkvs(\ke)(i) = (\val, \stub, \txidset) \land \txid \in \txidset}
    \end{rclarray}
\]

\begin{lemma}
    \label{lem:mono-fingerprint}
    \[
        \fora{\ET,\conf,\conf',\txid,\f} \conf\projection{1}(\txid) = \f \land \conf \toET{\stub}{\ET} \conf' \implies \conf'\projection{1}(\txid) = \f
    \]
\end{lemma}

\begin{lemma}
\label{lem:identical-step}
\[
\begin{array}{@{}l}
    \fora{n,\conf_0, \conf_1, \dots, \conf_n, \cl_1, \dots, \cl_n, \vi_1, \dots, \vi_n, \f_1, \dots, \f_n } \\
    \fora{m,\conf'_1, \dots, \conf'_m, \cl'_1, \dots, \cl'_m, \vi'_1, \dots, \vi'_m, \f'_1 \dots, \f'_m } \\
    \quad \conf_0 \xrightarrowtriangle{\cl_1, \vi_1, \f_1}_{\ET_{1}} \cdots \xrightarrowtriangle{\cl_n, \vi_n, \f_n}_{\ET_{1}} \conf_n \land \conf_0 \xrightarrowtriangle{\cl'_1, \vi'_1, \f'_1}_{\ET_{2}} \cdots \xrightarrowtriangle{\cl'_m, \vi'_m, \f'_m}_{\ET_{2}} \conf'_m \\
    \quad {} \land \conf_n\projection{1} = \conf'_m\projection{1} 
    \implies \fora{i: 0 < i \leq n} \f_i = \unitO \lor {} \\
    \qqquad \exsts{j: 0 < j \leq m} \cl_i = \cl'_j \land \f_i = \f'_j \land ( \fora{\ke} (\stub, \ke, \stub) \in \f_i \implies \vi_i(\ke) = \vi'_j(\ke) )
\end{array}
\]
\end{lemma} 
\begin{proof}
    Let \(\conf_n = \mkvs_n,\viewFun_n \) and \(\conf'_m = \mkvs'_m,\viewFun'_m \).
    Assume a step \( \conf_i \toET{\cl, \vi ,\f }{\ET_1} \conf_{i+1} \) where the transaction identifier is \( \txid_\cl^{n}\) and \( \f \neq \unitO \).
    We know \( \mkvs_n(\txid_\cl^{n}) = \f \) by \cref{lem:mono-fingerprint}.
    By \( \mkvs_n = \mkvs'_m \), we also know that:
    \begin{equation}
        \label{equ:same-kv-store}
        \fora{\txid, \f} \mkvs_n(\txid) = \f \iff \mkvs'_m(\txid) = \f
    \end{equation}
    so it must exist an identical step from the trace of \( \ET_2 \) such that \( \conf'_j \toET{\cl, \vi ,\f }{\ET_1} \conf'_{j+1} \), otherwise it contradicts \cref{equ:same-kv-store}.
\end{proof}

We define \( \max_\cl(\conf) \) function that returns the most recent transaction identifier for client \( \cl \) in the configuration \( \conf \) 
\[
\begin{rclarray}
    \max_\cl((\mkvs, \viewFun)) & \defeq & \max\Setcon{\txid^{n}_\cl}{\txid^{n}_\cl \text{ appear in } \mkvs} \\
\end{rclarray}
\]

\begin{lemma}
\label{lem:different-cl}
\[
\begin{array}{@{}l}
    \fora{n,\conf_0, \conf_1, \dots, \conf_n, \cl_1, \dots, \cl_n, \vi_1, \dots, \vi_n, \f_1, \dots, \f_n } \\
    \fora{m,\conf'_1, \dots, \conf'_m, \cl'_1, \dots, \cl'_m, \vi'_1, \dots, \vi'_m, \f'_1 \dots, \f'_m } \\
    \quad \conf_0 \xrightarrowtriangle{\cl_1, \vi_1, \f_1}_{\ET_{1}} \cdots \xrightarrowtriangle{\cl_n, \vi_n, \f_n}_{\ET_{1}} \conf_n \land \conf_0 \xrightarrowtriangle{\cl'_1, \vi'_1, \f'_1}_{\ET_{2}} \cdots \xrightarrowtriangle{\cl'_m, \vi'_m, \f'_m}_{\ET_{2}} \conf'_m \\
    \quad {} \land \conf_n\projection{1} = \conf'_m\projection{1} 
    \land \f'_m \neq \unitO
    \land \exsts{i} 
    \cl_i = \cl'_m
    \land \vi_i = \vi'_m
    \land \f_i = \f'_m
    \implies \fora{j > i} \f_j = \unitO \lor \cl_i \neq \cl_j
\end{array}
\]
\end{lemma}
\begin{proof}
    We prove by deriving contradiction.
    Assume the last step of the trace of \( \ET_2 \) is:
    \begin{equation}
        \label{equ:last-step-for-cl-et2}
        \conf'_{m-1} \xrightarrowtriangle{\cl'_m, \vi'_m, \f'_m}_{\ET_{2}} \conf'_m
    \end{equation}
    Assume there is a step of the trace of \( \ET_1 \):
    \begin{equation}
        \label{equ:identical-step-for-cl-et1}
        \conf_{i-1} \xrightarrowtriangle{\cl_i, \vi_i, \f_i}_{\ET_{1}} \conf_i
    \end{equation}
    where \( \cl_i = \cl'_m \land \vi_i = \vi'_m \land \f_i = \f'_m \).
    Given \cref{equ:last-step-for-cl-et2} and \cref{equ:identical-step-for-cl-et1}, because they are identical steps, we know \( \max{}_{\cl_m}(\conf'_m) = \max{}_{\cl_m}(\conf_i) \).
    Assume that there exists a step from the trace of \( \ET_1 \), says j-\emph{th} step, such that \( \f_j \neq \unitO \land \cl_i = \cl_j \):
    \[
        \conf_{j-1} \xrightarrowtriangle{\cl_j, \vi_h, \f_h}_{\ET_{1}} \conf_j \land j > i
    \]
    Therefore we have \( \max{}_{\cl_m}(\conf_j) > \max{}_{\cl_m}(\conf_i) \) by \cref{lem:kv-max-cl}.
That means \( \max{}_{\cl_m}(\conf_n) > \max{}_{\cl_m}(\conf_j) > \max{}_{\cl_m}(\conf_i) = \max{}_{\cl_m}(\conf'_m) \), which contradicts to \( \conf_n\projection{1} = \conf'_m\projection{1}\).
\end{proof}

\begin{lemma}
\label{lem:kv-max-cl}
\[
\begin{array}{@{}l}
    \fora{\conf, \conf' ,\cl, \vi, \f, \ET}
    \conf \xrightarrowtriangle{\cl, \vi, \f}_{\ET}  \conf' \\
    \quad {} \land ( \f \neq \unitO \implies \max{}_\cl(\conf) < \max{}_\cl(\conf') ) \lor ( \f = \unitO \implies \max{}_\cl(\conf) = \max{}_\cl(\conf') )
\end{array}
\]
\end{lemma}
\begin{proof}
    Assume  \( (\mkvs, \viewFun) \xrightarrowtriangle{\cl, \vi, \f}_{\ET} (\mkvs', \viewFun') \).
    By the definition of \( \toET{\stub}{\ET}\), we know \( \mkvs' \in \updKV{\mkvs, \vi, \cl, \f} \).
    The \( \updKV{\mkvs, \vi, \cl, \f} \) picks a fresh transaction identifier \( \txid_\cl^{m} \) that is greater than any transaction identifiers \( \txid_\cl^{n} \) in \( \mkvs \) via \( \nextTxId \) function, \ie \( m > n \).
    If the fingerprint \( \f \) is not empty, the new identifier appear in \( \mkvs' \), so \( \max{}_\cl(\conf) < \max{}_\cl(\conf') \).
    Otherwise  the fingerprint is empty, the new identifier will not appear anywhere in \( \mkvs' \), so \( \max{}_\cl(\conf) = \max{}_\cl(\conf') \). 
\end{proof}

\begin{lemma}
\label{lem:different-writes}
\[
\begin{array}{@{}l}
    \fora{n,\conf_0, \conf_1, \dots, \conf_n, \cl_1, \dots, \cl_n, \vi_1, \dots, \vi_n, \f_1, \dots, \f_n } \\
    \fora{m,\conf'_1, \dots, \conf'_m, \cl'_1, \dots, \cl'_m, \vi'_1, \dots, \vi'_m, \f'_1 \dots, \f'_m } \\
    \quad \conf_0 \xrightarrowtriangle{\cl_1, \vi_1, \f_1}_{\ET_{1}} \cdots \xrightarrowtriangle{\cl_n, \vi_n, \f_n}_{\ET_{1}} \conf_n \land \conf_0 \xrightarrowtriangle{\cl'_1, \vi'_1, \f'_1}_{\ET_{2}} \cdots \xrightarrowtriangle{\cl'_m, \vi'_m, \f'_m}_{\ET_{2}} \conf'_m \\
    \quad {} \land \conf_n\projection{1} = \conf'_m\projection{1} 
    \land \f'_m \neq \unitO
    \land \exsts{i} 
    \cl_i = \cl'_m
    \land \vi_i = \vi'_m
    \land \f_i = \f'_m
    \implies \fora{j > i} \nexists{\ke} \ldotp (\otW, \ke, \stub) \in \f_j \cap \f_i
\end{array}
\]
\end{lemma}
\begin{proof}
    We prove this by deriving contradiction.
    Assume the step from the trace of \( \ET_2 \):
    \begin{equation}
        \label{equ:last-step-for-write-et2}
        \conf'_{m-1} \xrightarrowtriangle{\cl'_m, \vi'_m, \f'_m}_{\ET_{2}} (\mkvs'_m, \viewFun'_m )
    \end{equation}
    Assuming the transaction identifier for the \cref{equ:last-step-for-write-et2} is \( \txid \), by the definition of \( \toET{}{\ET}\) (\cref{def:cm}), we know:
    \begin{equation}
        \label{equ:write-fingerprint}
        \fora{\ke} (\otW, \ke, \stub) \in \f'_m \implies \mkvs'_m(\ke)(\lvert\mkvs'_m(\ke)\rvert - 1) = (\stub, \txid, \stub)
    \end{equation}
    Assume there is a step of the trace of \( \ET_1 \):
    \begin{equation}
        \label{equ:identical-step-for-write-et1}
        \conf_{i-1} \xrightarrowtriangle{\cl_i, \vi_i, \f_i}_{\ET_{1}} (\mkvs_i, \viewFun_i)
    \end{equation}
    where \( \cl_i = \cl'_m \land \vi_i = \vi'_m \land \f_i = \f'_m \).
    Given \cref{equ:write-fingerprint} and \cref{equ:identical-step-for-write-et1}, because they are identical steps, we know:
    \[
        \fora{\ke} (\otW, \ke, \stub) \in \f_i \implies \mkvs_i(\ke)(\lvert\mkvs_i(\ke)\rvert - 1) = (\stub, \txid, \stub)
    \]
    Assume the first step says j-\emph{th}, after i-\emph{th} step that writes the same key:
    \[
        \conf_{j-1} \xrightarrowtriangle{\cl_j, \vi_j, \f_j}_{\ET_{1}} (\mkvs_j, \viewFun_j) 
        \land j > i
        \land \exsts{\ke} (\otW, \ke, \stub) \in \f_i \cap \f_j
    \]
    Therefore, by \cref{lem:unique-writer} we have:
    \[
        \exsts{\ke,i} (\otW, \ke, \stub) \in \f'_m \land \mkvs_j(\ke)(i) = \txid \land \mkvs_j(\ke)(\mkvs_j(\ke) - 1) \neq \txid
    \]
    Note that \( \f_i = \f'_m\).
    Since the writer of a version cannot be overwritten, for the final configuration of the trace of \( \ET_1 \) \((\mkvs_n, \viewFun_n)\), we know:
    \[
        \exsts{\ke,i} (\otW, \ke, \stub) \in \f'_m \land \mkvs_n(\ke)(i) = \txid \land \mkvs_n(\ke)(\mkvs_n(\ke) - 1) \neq \txid
    \]
    By \cref{equ:write-fingerprint}:
    \[
        \exsts{\ke} (\otW, \ke, \stub) \in \f'_m \land \mkvs_n(\ke)(\mkvs_n(\ke) - 1) \neq \txid \land \mkvs'_m(\ke)(\lvert\mkvs'_m(\ke)\rvert - 1)\projection{2} = \txid
    \]
    which contradicts with \( \mkvs'_m = \mkvs_n\).
\end{proof}

\begin{lemma}
    \label{lem:unique-writer}
    \[
    \begin{array}{@{}l}
        \fora{\mkvs, \mkvs',\viewFun,\viewFun', \cl, \vi, \f}
        (\mkvs, \viewFun) \toET{\cl, \vi, \f}{\ET} (\mkvs', \viewFun')
        \land (\otW, \ke, \stub) \in \f  \\
        \quad \implies
        \fora{i : 0 \leq i < \lvert \mkvs'(\ke) \rvert - 2} \mkvs'(\ke)(i)\projection{2} \neq \mkvs'(\ke)(\lvert \mkvs'(\ke) \rvert - 1)\projection{2}
    \end{array}
    \]
\end{lemma}
\begin{proof}
    By the definition of \( \toET{\stub}{\ET} \) (\cref{def:cm}), the \( \mkvs' \in \updKV{\mkvs, \vi, \cl, \f} \).
    Given the definition of \( \updKV{\mkvs, \vi, \cl, \f}\), it the picks a fresh transaction identifier \( \txid \) such that does not appear in \( \mkvs \).
    For any write fingerprint \( (\otW, \ke, \stub) \in \f \), a new version is appended to the end of the key \( \ke \) and the writer (the second projection) is assigned to be the fresh identifier \( \txid \).
    Thus we have the proof.
\end{proof}

\begin{proposition}
\label{thm:appendix-et-composition-2}
\label{prop:appendix-et-composition-2}
if $\ET_1, \ET_2$ are commutative, then $\ET_1 \cap \ET_2$ is commutative.
\end{proposition}
\begin{proof}
Let \( \ET_{12} = \ET_1 \cap \ET_2 \).
Assume \(\conf_1, \conf_2, \conf_3, \cl, \cl', \vi, \vi', \opset, \opset' \) such that:
\[
    \conf_1 \xrightarrowtriangle{\cl, \vi, \opset}_{\ET_{12}} \conf_2 \xrightarrowtriangle{\cl', \vi', \opset'}_{\ET_{12}} \conf_3
\]
Therefore, we have:
\[
    \conf_1 \xrightarrowtriangle{\cl, \vi, \opset}_{\ET_{1}} \conf_2 \xrightarrowtriangle{\cl', \vi', \opset'}_{\ET_{1}} \conf_3 \land 
    \conf_1 \xrightarrowtriangle{\cl, \vi, \opset}_{\ET_{2}} \conf_2 \xrightarrowtriangle{\cl', \vi', \opset'}_{\ET_{2}} \conf_3
\]
Because \( ET_1 \)  and \( \ET_2 \) are commutative, there exists a configuration \( \conf'_2 \) such that:
\[
    \conf_1 \xrightarrowtriangle{\cl', \vi', \opset'}_{\ET_{1}} \conf'_2 \xrightarrowtriangle{\cl, \vi, \opset}_{\ET_{1}} \conf_3 \land 
    \conf_1 \xrightarrowtriangle{\cl', \vi', \opset'}_{\ET_{2}} \conf'_2 \xrightarrowtriangle{\cl, \vi, \opset}_{\ET_{2}} \conf_3
\]
so we have the proof that: 
\[
    \conf_1 \xrightarrowtriangle{\cl', \vi', \opset'}_{\ET_{12}} \conf'_2 \xrightarrowtriangle{\cl, \vi, \opset}_{\ET_{12}} \conf_3
\]
\end{proof}

\begin{lemma}
    \label{lem:mr-comm}
    \(\MRd\) is commutative.
\end{lemma}
\begin{proof}
    Let assume:
    \[
        \mkvs_0, \viewFun_0 \toET{\cl, \vi, \opset}{\MRd} \mkvs_1, \viewFun_1 \toET{\cl', \vi', \opset'}{\MRd} \mkvs_2, \viewFun_2 
    \]
    where \( \cl \neq \cl' \), \( \fora{ \ke } (\otW, \ke, \stub) \notin \opset \cap \opset' \) and \( \vi, \vi' \in \Views(\mkvs_0)\).
    Given the specification of \(\MRd\) (\cref{fig:execution-tests}), we know \( \viewFun_1 = \viewFun_0\rmto{\cl}{\vi''}\) for some \( \vi'' \) such that \( \vi \sqsubseteq \vi'' \).
    Similarly \( \viewFun_2 = \viewFun_1\rmto{\cl'}{\vi'''} \) for some \( \vi''' \) such that \(  \vi' \sqsubseteq \vi''' \). 
    Given that \( \cl \neq \cl' \), we can pick \( \mkvs'_1 \) and \( \viewFun'_1 \) such that \( \mkvs'_1 \in \updKV{\mkvs_0,\vi',\cl',\f'} \) and \( \viewFun'_1 = \viewFun_0\rmto{\cl'}{\vi'''} \), so we have:
    \[
        \mkvs_0, \viewFun_0 \toET{\cl', \vi', \opset'}{\MRd} \mkvs'_1, \viewFun'_1 \toET{\cl, \vi, \opset}{\MRd} \mkvs_2, \viewFun_2 
    \]
\end{proof}                                                                                    

\begin{lemma}
    \label{lem:mw-comm}
    \(\MW\) is commutative.
\end{lemma}
\begin{proof}
    Let assume:
    \[
        \mkvs_0, \viewFun_0 \toET{\cl, \vi, \opset}{\MW} \mkvs_1, \viewFun_1 \toET{\cl', \vi', \opset'}{\MW} \mkvs_2, \viewFun_2 
    \]
    where \( \cl \neq \cl' \), \( \fora{ \ke } (\otW, \ke, \stub) \notin \opset \cap \opset' \) and \( \vi, \vi' \in \Views(\mkvs_0)\).
    Because the client \( \cl' \) can commit the fingerprint \( \f' \) under \( \vi' \) to the kv-store \( \mkvs_1 \), it can also commit to \( \mkvs_0 \):
    \[
        \begin{array}{@{}l}
            \vi' \in \Views(\mkvs_0) \land \MW \vdash (\mkvs_1, \vi') \csat \f', \viewFun_2(\cl') \implies  \MW \vdash (\mkvs_0, \vi') \csat \f', \viewFun_2(\cl')
        \end{array}
    \]
    Assuming \( \mkvs'_1 \) and \( \viewFun'_1 \) such that \( \mkvs'_1 \in \updKV{\mkvs_0,\vi',\cl',\f'} \) and \( \viewFun'_1 = \viewFun_0\rmto{\cl'}{\viewFun_2(\vi')} \), we need to prove the specification for \( \MW \) (\cref{fig:execution-tests}):
    \[
        \fora{j,i, \ke, \ke'} j \leq \vi(\ke) \wedge \WTx(\hh'_1(\ke', i)) \xrightarrow{\PO ?} \WTx(\hh'_1(\ke, j)) \implies i \leq \vi'(\ke')  \\
    \]
    For any key written by \( \cl' \), there is a new version of the key in \( \mkvs'_1 \).
    Given \( \vi \in \Views(\mkvs_0)\), those new versions installed by \( \cl' \) do not affect \( \vi \):
    \[
        \fora{j,i, \ke} j \leq \vi(\ke) \land \hh'_1(\ke, j)\isdef \implies \hh_0(\ke, j)\isdef
    \]
    so we have:
    \[
        \begin{array}{@{}l}
            \MW \vdash (\mkvs_0, \vi) \csat \f, \viewFun_2(\cl) \implies  \MW \vdash (\mkvs'_1, \vi) \csat \f, \viewFun_2(\cl)
        \end{array}
    \]
\end{proof}


\begin{lemma}
    \label{lem:ryw-comm}
    \(\RYW\) is commutative.
\end{lemma}
\begin{proof}
    Let assume:
    \[
        \mkvs_0, \viewFun_0 \toET{\cl, \vi, \opset}{\RYW} \mkvs_1, \viewFun_1 \toET{\cl', \vi', \opset'}{\RYW} \mkvs_2, \viewFun_2 
    \]
    where \( \cl \neq \cl' \), \( \fora{ \ke } (\otW, \ke, \stub) \notin \opset \cap \opset' \) and \( \vi, \vi' \in \Views(\mkvs_0)\).
    %Assume \( \mkvs'_1 \) and \( \viewFun'_1 \) such that \( \mkvs'_1 \in \updKV{\mkvs_0,\vi',\cl',\f'} \) and \( \viewFun'_1 = \viewFun_0\rmto{\cl'}{\viewFun_2(\vi')} \).
    Given \( \fora{ \ke } (\otW, \ke, \stub) \notin \opset \cap \opset' \) and the specification for \( \RYW \) (\cref{fig:execution-tests}), we have:
    \[
        \fora{\ke} (\otW, \ke, \stub) \in \f \implies \viewFun_1(\cl)(\ke) = \viewFun_2(\cl)(\ke) = \lvert \mkvs_1(\ke) \rvert - 1 = \lvert \mkvs_2(\ke) \rvert - 1
    \]
    We can pick \( \mkvs'_1 \) and \( \viewFun'_1 \) such that \( \mkvs'_1 \in \updKV{\mkvs_0,\vi',\cl',\f'} \) and \( \viewFun'_1 = \viewFun_0\rmto{\cl'}{\viewFun_2(\cl')} \), so we have:
    \[
        \mkvs_0, \viewFun_0 \toET{\cl', \vi', \opset'}{\RYW} \mkvs'_1, \viewFun'_1 \toET{\cl, \vi, \opset}{\RYW} \mkvs_2, \viewFun_2 
    \]
\end{proof}

\begin{lemma}
    \label{lem:wfr-comm}
    \(\WFR\) is commutative.
\end{lemma}
\begin{proof}
    Let assume:
    \[
        \mkvs_0, \viewFun_0 \toET{\cl, \vi, \opset}{\WFR} \mkvs_1, \viewFun_1 \toET{\cl', \vi', \opset'}{\WFR} \mkvs_2, \viewFun_2 
    \]
    where \( \cl \neq \cl' \), \( \fora{ \ke } (\otW, \ke, \stub) \notin \opset \cap \opset' \) and \( \vi, \vi' \in \Views(\mkvs_0)\).
    Because the client \( \cl' \) can commit the fingerprint \( \f' \) under \( \vi' \) to the kv-store \( \mkvs_1 \), it can also commit to \( \mkvs_0 \):
    \[
        \begin{array}{@{}l}
            \vi' \in \Views(\mkvs_0) \land \WFR \vdash (\mkvs_1, \vi') \csat \f', \viewFun_2(\cl') \implies  \WFR \vdash (\mkvs_0, \vi') \csat \f', \viewFun_2(\cl')
        \end{array}
    \]
    Assume \( \mkvs'_1 \) and \( \viewFun'_1 \) such that \( \mkvs'_1 \in \updKV{\mkvs_0,\vi',\cl',\f'} \) and \( \viewFun'_1 = \viewFun_0\rmto{\cl'}{\viewFun_2(\vi')} \).
    For any key written by \( \cl' \), there is a new version of the key in \( \mkvs'_1 \).
    Given \( \vi \in \Views(\mkvs_0)\), those new versions installed by \( \cl' \) do not affect \( \vi \):
    \[
        \fora{j,i, \ke} j \leq \vi(\ke) \land \hh'_1(\ke, j)\isdef \implies \hh_0(\ke, j)\isdef
    \]
    so we have:
    \[
        \begin{array}{@{}l}
            \WFR \vdash (\mkvs_0, \vi) \csat \f, \viewFun_2(\cl) \implies \WFR \vdash (\mkvs'_1, \vi) \csat \f, \viewFun_2(\cl)
        \end{array}
    \]
\end{proof}

\begin{lemma}
    \label{lem:ua-comm}
    \(\UA\) is commutative.
\end{lemma}
\begin{proof}
    Let assume:
    \[
        \mkvs_0, \viewFun_0 \toET{\cl, \vi, \opset}{\WFR} \mkvs_1, \viewFun_1 \toET{\cl', \vi', \opset'}{\WFR} \mkvs_2, \viewFun_2 
    \]
    where \( \cl \neq \cl' \), \( \fora{ \ke } (\otW, \ke, \stub) \notin \opset \cap \opset' \) and \( \vi, \vi' \in \Views(\mkvs_0)\).
    Given the specification for \( \UA \) (\cref{fig:execution-tests}) we have:
    \[
        \begin{array}{@{}l}
            \vi' \in \Views(\mkvs_0) \land \fora{ \ke } (\otW, \ke, \stub) \notin \opset \cap \opset' \land \\ 
            \quad \UA \vdash (\mkvs_1, \vi') \csat \f', \viewFun_2(\cl') \implies  \UA \vdash (\mkvs_0, \vi') \csat \f', \viewFun_2(\cl')
        \end{array}
    \]
    Assume \( \mkvs'_1 \) and \( \viewFun'_1 \) such that \( \mkvs'_1 \in \updKV{\mkvs_0,\vi',\cl',\f'} \) and \( \viewFun'_1 = \viewFun_0\rmto{\cl'}{\viewFun_2(\vi')} \).
    Because transactions write different keys, It is easy to see that \( \UA \vdash (\mkvs'_1, \vi) \csat \f, \viewFun_2(\cl) \).
\end{proof}

\begin{proposition}
    \( \CC \) and \( \PSI \) are commutative.
\end{proposition}
\begin{proof}
    Because \( \CC = \MR \cap \MW \cap \RYW \cap \WFR \) and all four are commutative (\cref{lem:mr-comm,lem:mw-comm,lem:ryw-comm,lem:wfr-comm}), so \( \CC \) is commutative by the \cref{prop:appendix-et-composition-2}.
    Similarly, since \( \PSI = \CC \cap \UA \) and \( \UA \) is commutative (\cref{lem:ua-comm}), so \( \PSI \) is commutative.
\end{proof}

\( \CP \) is not commutative because the view after update must be up-to-date.

\begin{lemma}
    \label{lem:ser-comm}
    \( \SER \) is commutative.
\end{lemma}
\begin{proof}
    Given the specification for \( \SER \) (\cref{fig:execution-tests}), the hypothesis that \( \vi, \vi' \in \Views(\mkvs_0) \) never holds.
\end{proof}

