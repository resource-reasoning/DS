\begin{theorem}
\label{thm:appendix-et-composition-1}
Let $\ET_1, \ET_2$ be two execution tests. If $\ET_1$ is commutative, 
then $\CMs(\ET_1 \cap \ET_2) = \CMs(\ET_1) \cap \CMs(\ET_2)$. 
\end{theorem}
\begin{proof}
Let \( \ET_{12} = \ET_1 \cap \ET_2 \).
Given the definition of the \( \CMs(.) \) function (\cref{def:cm}), we need to prove \( \Confs(\ET_{12}) \subseteq \Confs(\ET_1) \cap \Confs(\ET_2) \) and \( \CMs(\ET_1) \cap \CMs(\ET_2) \subseteq \CMs(\ET_{12}) \).
To prove the former, it suffices to prove the follows:
\[
\begin{array}{@{}l}
    \fora{n,\conf_0, \conf_1, \dots, \conf_n} \conf_0 \text{ is initial } 
    \land \conf_0 \xrightarrowtriangle{\stub}_{\ET_{12}} \cdots \xrightarrowtriangle{\stub}_{\ET_{12}} \conf_n \implies {} \\
    \quad \conf_0 \xrightarrowtriangle{\stub}_{\ET_{1}} \cdots \xrightarrowtriangle{\stub}_{\ET_{1}} \conf_n \land \conf_0 \xrightarrowtriangle{\stub}_{\ET_{2}} \cdots \xrightarrowtriangle{\stub}_{\ET_{2}} \conf_n 
\end{array}
\]
We prove it by induction on the number \( n \).
It holds when \( n = 0 \) because initial configurations are included in \( \Confs(\ET_1) \) and \( \Confs(\ET_2) \) by the definition (\cref{def:cm}).
Assume that it holds when \( n = i \), let consider \( n = i + 1 \).
For any \( \conf_{i+1} \) induced by \( \ET_{12} \), there exist some client, view and fingerprint such that \( \conf_i \xrightarrowtriangle{\cl, \vi, \opset}_{\ET_{12}} \conf_{i+1} \).
Since \( \ET_{12} = \ET_1 \cap \ET_2 \), it is easy to see that \( \conf_i \xrightarrowtriangle{\cl, \vi, \opset}_{\ET_{1}} \conf_{i+1} \) and \( \conf_i \xrightarrowtriangle{\cl, \vi, \opset}_{\ET_{2}} \conf_{i+1} \).

To prove the latter, assuming there is no transaction with empty fingerprint, we need to prove the follows:
\[
\begin{array}{@{}l}
    \fora{n,\conf_0, \conf_1,\conf_1',\dots,\conf_{n-1}, \conf_{n-1}', \conf_n} \conf_0 \text{ is initial } \\
    \quad {} \land \conf_0 \xrightarrowtriangle{\stub}_{\ET_{1}} \conf_1 \xrightarrowtriangle{\stub}_{\ET_{1}} \cdots \xrightarrowtriangle{\stub}_{\ET_{1}} \conf_n \land \conf_0 \xrightarrowtriangle{\stub}_{\ET_{2}} \conf_1' \xrightarrowtriangle{\stub}_{\ET_{2}} \cdots \xrightarrowtriangle{\stub}_{\ET_{2}} \conf_n \\
    \qquad {} \implies \conf_0, \conf'_1, \dots, \conf'_{n} \in \Confs(\ET_{1})
\end{array}
\]
It means that for two traces by \( \ET_1 \) and \( \ET_2 \) respectively, 
if the finial configurations \( \conf_n \) are the same, 
then all the configurations from trace of \( \ET_2 \) satisfy \( \ET_{1} \).
We prove it by induction on the number \( n \).
It holds when \( n = 0 \) because any initial configuration is included in \( \Confs(\ET_1) \) by the definition of the function (\cref{def:cm}).
Assume that it holds when \( n = i \), let consider \( n = i + 1 \).
Assume a client \( \cl'_{i+1} \), a view \( \vi'_{i+1} \) and a fingerprint \( \opset'_{i+1} \) that transfer the second last configuration \( \conf'_i \) in the trace of \( \ET_2 \) to the final configuration \( \conf_{i+1} \):
\[
    \conf'_i \xrightarrowtriangle{\cl'_{i+1}, \vi'_{i+1}, \opset'_{i+1}}_{\ET_2} \conf_{i+1}
\]
Because the final configuration is the same, both traces must contain exactly the same transactions where the client, the fingerprint, and the view for all keys appearing in the fingerprint are the same.
Given that, there exist a client \( \cl_j \), a view \( \vi_j \) and a fingerprint \( \opset_j \) from the trace of \( \ET_1 \) such that \( \cl'_{i+1} = \cl_{j} \), \( \vi'_{i+1} \approx \vi_j \) and \( \opset'_{i+1} = \opset_{j}\), where the \( \vi_{i+1} \approx \vi_j \) is defined as the follows:
\[
    \fora{\ke} (\stub, \ke, \stub) \in \opset_j \implies \vi_{i+1}(\ke) = \vi_j(\ke)
\]
For brevity we write \( (\cl, \vi, \opset) = (\cl', \vi', \opset') \) for \( \cl = \cl' \), \( \vi \approx \vi' \) and \( \opset = \opset'\).
Since a client always picks a greater transaction identifier, the session order from one trace is the same as the one of another trace.
Similarly, because a write fingerprint for a key installs a new version for that key, the order in which transactions write to keys are the same for both traces.
Thus, all transactions after the j-\emph{th} transaction from the trace of \( \ET_1 \) do not conflict with the j-\emph{th} transaction:
\[
    \fora{k, \cl_k, \vi_k, \opset_k} j < k \leq i + 1 \land \conf_{k-1} \xrightarrowtriangle{\cl_k, \vi_k, \opset_k}_{\ET_{1}} \conf_k \implies \cl_k \neq \cl_j \land \nexists{\ke} \ldotp (\otW, \ke, \stub) \in \opset_k \cap \opset_j
\]
By the commutative of \( \ET_1 \), we can move the j-\emph{th} transaction to the end of the trace without changing the final configuration:
\[
\begin{array}{@{}l}
    \exsts{\conf''_{j}, \dots \conf''_i}  \\
    \quad \conf_{j-1} \xrightarrowtriangle{\cl_{j+1}, \vi_{j+1}, \opset_{j+1}}_{\ET_{1}} \conf''_{j} \xrightarrowtriangle{\cl_{j+2}, \vi_{j+2}, \opset_{j+2}}_{\ET_{1}} \\
    \qqquad \cdots \xrightarrowtriangle{\cl_{i+1}, \vi_{i+1}, \opset_{i+1}}_{\ET_{1}} \conf''_i \xrightarrowtriangle{\cl_{j}, \vi_{j}, \opset_{j}}_{\ET_{1}} \conf_{i+1}
\end{array}
\]
Because \( (\cl_{j}, \vi_{j}, \opset_{j}) = (\cl'_{i+1}, \vi'_{i+1}, \opset'_{i+1}) \), 
we know that the second last (the i-\emph{th}) configuration from the new trace of \( \ET_1 \) equals to the second last from the trace of \( \ET_2 \), \ie \( \conf''_i = \conf'_i \).
By the \ih, we know \( \conf_0, \conf'_1, \dots, \conf'_i \in \Confs(\ET_{1}) \).
Last, we know \( \conf''_i \xrightarrowtriangle{\cl_{j}, \vi_{j}, \opset_{j}}_{\ET_1} \conf_{i+1} \), \( (\cl_{j}, \vi_{j}, \opset_{j}) = (\cl'_{i+1}, \vi'_{i+1}, \opset'_{i+1}) \) and \( \conf''_i = \conf'_i \), so we know \( \conf_{i+1} \in \Confs(\ET_1)\).
\end{proof}

We define function that returns the fingerprint associate with a transaction identifier:
\[
    \begin{rclarray}
        \mkvs(\txid) & \defeq & \Setcon{(\otW, \ke, \val)}{\exsts{i} \mkvs(\ke)(i) = (\val, \txid, \stub)} \cup  \Setcon{(\otR, \ke, \val)}{\exsts{i,\txidset} \mkvs(\ke)(i) = (\val, \stub, \txidset) \land \txid \in \txidset}
    \end{rclarray}
\]

\begin{lemma}
    \label{lem:mono-fingerprint}
    \[
        \fora{\ET,\conf,\conf',\txid,\f} \conf\projection{1}(\txid) = \f \land \conf \toET{\stub}{\ET} \conf' \implies \conf'\projection{1}(\txid) = \f
    \]
\end{lemma}

\begin{lemma}
\[
\begin{array}{@{}l}
    \fora{n,\conf_0, \conf_1, \dots, \conf_n, \cl_1, \dots, \cl_n, \vi_1, \dots, \vi_n, \f_1, \dots, \f_n } \\
    \fora{m,\conf'_1, \dots, \conf'_m, \cl'_1, \dots, \cl'_m, \vi'_1, \dots, \vi'_m, \f'_1 \dots, \f'_m } \\
    \quad \conf_0 \xrightarrowtriangle{\cl_1, \vi_1, \f_1}_{\ET_{1}} \cdots \xrightarrowtriangle{\cl_n, \vi_n, \f_n}_{\ET_{1}} \conf_n \land \conf_0 \xrightarrowtriangle{\cl'_1, \vi'_1, \f'_1}_{\ET_{2}} \cdots \xrightarrowtriangle{\cl'_m, \vi'_m, \f'_m}_{\ET_{2}} \conf'_m \\
    \quad \land \bigwedge\limits_{ 0 < k \leq n } \f_k \neq \unitO \land \bigwedge\limits_{ 0 < l \leq m } \f'_l \neq \unitO \land \conf_n = \conf'_m \implies \\
    \qquad \fora{i: 0 < i \leq n} \exsts{j: 0 < j \leq m} \cl_i = \cl'_j \land \f_i = \f'_j \land ( \fora{\ke} (\stub, \ke, \stub) \in \f_i \implies \vi_i(\ke) = \vi'_j(\ke) )
\end{array}
\]
\end{lemma} 
\begin{proof}
    Let \(\conf_n = \mkvs_n,\viewFun_n \) and \(\conf'_m = \mkvs'_m,\viewFun'_m \).
    Assume a step \( \conf_i \toET{\cl, \vi ,\f }{\ET_1} \conf_{i+1} \) where the transaction identifier is \( \txid_\cl^{n}\).
    It means \( \mkvs_n(\txid_\cl^{n}) = \f \) by \cref{lem:mono-fingerprint}.
    By \( \mkvs_n = \mkvs'_m \), we also know that:
    \[
        \fora{\txid, \f} \mkvs_n(\txid) = \f \iff \mkvs'_m(\txid) = \f
    \]
    so it must exists a step from the trace of \( \ET_2 \) such that \( \conf'_j \toET{\cl, \vi ,\f }{\ET_1} \conf'_{j+1} \).
\end{proof}

\begin{lemma}
    \label{lem:kv-same-number}
    \[
    \fora{\conf, \conf' ,\cl, \vi, \f, \ET}
    \conf \xrightarrowtriangle{\cl, \vi, \f}_{\ET}  \conf' \land \f \neq \unitO \implies \max{}_\cl(\conf) < \max{}_\cl(\conf')
    \]
    where
    \[
        \begin{rclarray}
            \max_\cl((\mkvs, \viewFun)) & \defeq & \max\Setcon{\txid^{n}_\cl}{\txid^{n}_\cl \text{ appear in } \mkvs} \\
        \end{rclarray}
    \]
\end{lemma}
\begin{proof}
    Assume  \( (\mkvs, \viewFun) \xrightarrowtriangle{\cl, \vi, \f}_{\ET} (\mkvs', \viewFun') \).
    By the definition of \( \toET{\stub}{\ET}\), we know \( \mkvs' \in \updKV{\mkvs, \vi, \cl, \f} \).
    The \( \updKV{\mkvs, \vi, \cl, \f} \) picks a fresh transaction identifier \( \txid_\cl^{m} \) that is greater than any transaction identifiers \( \txid_\cl^{n} \) in \( \mkvs \) via \( \nextTxId \) function, \ie \( m > n \).
    Since the fingerprint is not empty, the new identifier appear in \( \mkvs' \), therefore we have the proof.
\end{proof}

\begin{proposition}
\label{thm:appendix-et-composition-2}
\label{prop:appendix-et-composition-2}
if $\ET_1, \ET_2$ are commutative, then $\ET_1 \cap \ET_2$ is commutative.
\end{proposition}
\begin{proof}
Let \( \ET_{12} = \ET_1 \cap \ET_2 \).
Assume \(\conf_1, \conf_2, \conf_3, \cl, \cl', \vi, \vi', \opset, \opset' \) such that:
\[
    \conf_1 \xrightarrowtriangle{\cl, \vi, \opset}_{\ET_{12}} \conf_2 \xrightarrowtriangle{\cl', \vi', \opset'}_{\ET_{12}} \conf_3
\]
Therefore, we have:
\[
    \conf_1 \xrightarrowtriangle{\cl, \vi, \opset}_{\ET_{1}} \conf_2 \xrightarrowtriangle{\cl', \vi', \opset'}_{\ET_{1}} \conf_3 \land 
    \conf_1 \xrightarrowtriangle{\cl, \vi, \opset}_{\ET_{2}} \conf_2 \xrightarrowtriangle{\cl', \vi', \opset'}_{\ET_{2}} \conf_3
\]
Because \( ET_1 \)  and \( \ET_2 \) are commutative, there exists a configuration \( \conf'_2 \) such that:
\[
    \conf_1 \xrightarrowtriangle{\cl', \vi', \opset'}_{\ET_{1}} \conf'_2 \xrightarrowtriangle{\cl, \vi, \opset}_{\ET_{1}} \conf_3 \land 
    \conf_1 \xrightarrowtriangle{\cl', \vi', \opset'}_{\ET_{2}} \conf'_2 \xrightarrowtriangle{\cl, \vi, \opset}_{\ET_{2}} \conf_3
\]
so we have the proof that: 
\[
    \conf_1 \xrightarrowtriangle{\cl', \vi', \opset'}_{\ET_{12}} \conf'_2 \xrightarrowtriangle{\cl, \vi, \opset}_{\ET_{12}} \conf_3
\]
\end{proof}

\begin{lemma}
    \label{lem:mr-comm}
    \(\MRd\) is commutative.
\end{lemma}
\begin{proof}
    Let assume:
    \[
        \mkvs_0, \viewFun_0 \toET{\cl, \vi, \opset}{\MRd} \mkvs_1, \viewFun_1 \toET{\cl', \vi', \opset'}{\MRd} \mkvs_2, \viewFun_2 
    \]
    where \( \cl \neq \cl' \), \( \fora{ \ke } (\otW, \ke, \stub) \notin \opset \cap \opset' \) and \( \vi, \vi' \in \Views(\mkvs_0)\).
    Given the specification of \(\MRd\) (\cref{fig:execution-tests}), we know \( \viewFun_1 = \viewFun_0\rmto{\cl}{\vi''}\) for some \( \vi'' \) such that \( \vi \sqsubseteq \vi'' \).
    Similarly \( \viewFun_2 = \viewFun_1\rmto{\cl'}{\vi'''} \) for some \( \vi''' \) such that \(  \vi' \sqsubseteq \vi''' \). 
    Given that \( \cl \neq \cl' \), we can pick \( \mkvs'_1 \) and \( \viewFun'_1 \) such that \( \mkvs'_1 \in \updKV{\mkvs_0,\vi',\cl',\f'} \) and \( \viewFun'_1 = \viewFun_0\rmto{\cl'}{\vi'''} \), so we have:
    \[
        \mkvs_0, \viewFun_0 \toET{\cl', \vi', \opset'}{\MRd} \mkvs'_1, \viewFun'_1 \toET{\cl, \vi, \opset}{\MRd} \mkvs_2, \viewFun_2 
    \]
\end{proof}                                                                                    

\begin{lemma}
    \label{lem:mw-comm}
    \(\MW\) is commutative.
\end{lemma}
\begin{proof}
    Let assume:
    \[
        \mkvs_0, \viewFun_0 \toET{\cl, \vi, \opset}{\MW} \mkvs_1, \viewFun_1 \toET{\cl', \vi', \opset'}{\MW} \mkvs_2, \viewFun_2 
    \]
    where \( \cl \neq \cl' \), \( \fora{ \ke } (\otW, \ke, \stub) \notin \opset \cap \opset' \) and \( \vi, \vi' \in \Views(\mkvs_0)\).
    Because the client \( \cl' \) can commit the fingerprint \( \f' \) under \( \vi' \) to the kv-store \( \mkvs_1 \), it can also commit to \( \mkvs_0 \):
    \[
        \begin{array}{@{}l}
            \vi' \in \Views(\mkvs_0) \land \MW \vdash (\mkvs_1, \vi') \csat \f', \viewFun_2(\cl') \implies  \MW \vdash (\mkvs_0, \vi') \csat \f', \viewFun_2(\cl')
        \end{array}
    \]
    Assuming \( \mkvs'_1 \) and \( \viewFun'_1 \) such that \( \mkvs'_1 \in \updKV{\mkvs_0,\vi',\cl',\f'} \) and \( \viewFun'_1 = \viewFun_0\rmto{\cl'}{\viewFun_2(\vi')} \), we need to prove the specification for \( \MW \) (\cref{fig:execution-tests}):
    \[
        \fora{j,i, \ke, \ke'} j \leq \vi(\ke) \wedge \WTx(\hh'_1(\ke', i)) \xrightarrow{\PO ?} \WTx(\hh'_1(\ke, j)) \implies i \leq \vi'(\ke')  \\
    \]
    For any key written by \( \cl' \), there is a new version of the key in \( \mkvs'_1 \).
    Given \( \vi \in \Views(\mkvs_0)\), those new versions installed by \( \cl' \) do not affect \( \vi \):
    \[
        \fora{j,i, \ke} j \leq \vi(\ke) \land \hh'_1(\ke, j)\isdef \implies \hh_0(\ke, j)\isdef
    \]
    so we have:
    \[
        \begin{array}{@{}l}
            \MW \vdash (\mkvs_0, \vi) \csat \f, \viewFun_2(\cl) \implies  \MW \vdash (\mkvs'_1, \vi) \csat \f, \viewFun_2(\cl)
        \end{array}
    \]
\end{proof}


\begin{lemma}
    \label{lem:ryw-comm}
    \(\RYW\) is commutative.
\end{lemma}
\begin{proof}
    Let assume:
    \[
        \mkvs_0, \viewFun_0 \toET{\cl, \vi, \opset}{\RYW} \mkvs_1, \viewFun_1 \toET{\cl', \vi', \opset'}{\RYW} \mkvs_2, \viewFun_2 
    \]
    where \( \cl \neq \cl' \), \( \fora{ \ke } (\otW, \ke, \stub) \notin \opset \cap \opset' \) and \( \vi, \vi' \in \Views(\mkvs_0)\).
    %Assume \( \mkvs'_1 \) and \( \viewFun'_1 \) such that \( \mkvs'_1 \in \updKV{\mkvs_0,\vi',\cl',\f'} \) and \( \viewFun'_1 = \viewFun_0\rmto{\cl'}{\viewFun_2(\vi')} \).
    Given \( \fora{ \ke } (\otW, \ke, \stub) \notin \opset \cap \opset' \) and the specification for \( \RYW \) (\cref{fig:execution-tests}), we have:
    \[
        \fora{\ke} (\otW, \ke, \stub) \in \f \implies \viewFun_1(\cl)(\ke) = \viewFun_2(\cl)(\ke) = \lvert \mkvs_1(\ke) \rvert - 1 = \lvert \mkvs_2(\ke) \rvert - 1
    \]
    We can pick \( \mkvs'_1 \) and \( \viewFun'_1 \) such that \( \mkvs'_1 \in \updKV{\mkvs_0,\vi',\cl',\f'} \) and \( \viewFun'_1 = \viewFun_0\rmto{\cl'}{\viewFun_2(\cl')} \), so we have:
    \[
        \mkvs_0, \viewFun_0 \toET{\cl', \vi', \opset'}{\RYW} \mkvs'_1, \viewFun'_1 \toET{\cl, \vi, \opset}{\RYW} \mkvs_2, \viewFun_2 
    \]
\end{proof}

\begin{lemma}
    \label{lem:wfr-comm}
    \(\WFR\) is commutative.
\end{lemma}
\begin{proof}
    Let assume:
    \[
        \mkvs_0, \viewFun_0 \toET{\cl, \vi, \opset}{\WFR} \mkvs_1, \viewFun_1 \toET{\cl', \vi', \opset'}{\WFR} \mkvs_2, \viewFun_2 
    \]
    where \( \cl \neq \cl' \), \( \fora{ \ke } (\otW, \ke, \stub) \notin \opset \cap \opset' \) and \( \vi, \vi' \in \Views(\mkvs_0)\).
    Because the client \( \cl' \) can commit the fingerprint \( \f' \) under \( \vi' \) to the kv-store \( \mkvs_1 \), it can also commit to \( \mkvs_0 \):
    \[
        \begin{array}{@{}l}
            \vi' \in \Views(\mkvs_0) \land \WFR \vdash (\mkvs_1, \vi') \csat \f', \viewFun_2(\cl') \implies  \WFR \vdash (\mkvs_0, \vi') \csat \f', \viewFun_2(\cl')
        \end{array}
    \]
    Assume \( \mkvs'_1 \) and \( \viewFun'_1 \) such that \( \mkvs'_1 \in \updKV{\mkvs_0,\vi',\cl',\f'} \) and \( \viewFun'_1 = \viewFun_0\rmto{\cl'}{\viewFun_2(\vi')} \).
    For any key written by \( \cl' \), there is a new version of the key in \( \mkvs'_1 \).
    Given \( \vi \in \Views(\mkvs_0)\), those new versions installed by \( \cl' \) do not affect \( \vi \):
    \[
        \fora{j,i, \ke} j \leq \vi(\ke) \land \hh'_1(\ke, j)\isdef \implies \hh_0(\ke, j)\isdef
    \]
    so we have:
    \[
        \begin{array}{@{}l}
            \WFR \vdash (\mkvs_0, \vi) \csat \f, \viewFun_2(\cl) \implies \WFR \vdash (\mkvs'_1, \vi) \csat \f, \viewFun_2(\cl)
        \end{array}
    \]
\end{proof}

\begin{lemma}
    \label{lem:ua-comm}
    \(\UA\) is commutative.
\end{lemma}
\begin{proof}
    Let assume:
    \[
        \mkvs_0, \viewFun_0 \toET{\cl, \vi, \opset}{\WFR} \mkvs_1, \viewFun_1 \toET{\cl', \vi', \opset'}{\WFR} \mkvs_2, \viewFun_2 
    \]
    where \( \cl \neq \cl' \), \( \fora{ \ke } (\otW, \ke, \stub) \notin \opset \cap \opset' \) and \( \vi, \vi' \in \Views(\mkvs_0)\).
    Given the specification for \( \UA \) (\cref{fig:execution-tests}) we have:
    \[
        \begin{array}{@{}l}
            \vi' \in \Views(\mkvs_0) \land \fora{ \ke } (\otW, \ke, \stub) \notin \opset \cap \opset' \land \\ 
            \quad \UA \vdash (\mkvs_1, \vi') \csat \f', \viewFun_2(\cl') \implies  \UA \vdash (\mkvs_0, \vi') \csat \f', \viewFun_2(\cl')
        \end{array}
    \]
    Assume \( \mkvs'_1 \) and \( \viewFun'_1 \) such that \( \mkvs'_1 \in \updKV{\mkvs_0,\vi',\cl',\f'} \) and \( \viewFun'_1 = \viewFun_0\rmto{\cl'}{\viewFun_2(\vi')} \).
    Because transactions write different keys, It is easy to see that \( \UA \vdash (\mkvs'_1, \vi) \csat \f, \viewFun_2(\cl) \).
\end{proof}

\begin{proposition}
    \( \CC \) and \( \PSI \) are commutative.
\end{proposition}
\begin{proof}
    Because \( \CC = \MR \cap \MW \cap \RYW \cap \WFR \) and all four are commutative (\cref{lem:mr-comm,lem:mw-comm,lem:ryw-comm,lem:wfr-comm}), so \( \CC \) is commutative by the \cref{prop:appendix-et-composition-2}.
    Similarly, since \( \PSI = \CC \cap \UA \) and \( \UA \) is commutative (\cref{lem:ua-comm}), so \( \PSI \) is commutative.
\end{proof}

\( \CP \) is not commutative because the view after update must be up-to-date.

\begin{lemma}
    \label{lem:ser-comm}
    \( \SER \) is commutative.
\end{lemma}
\begin{proof}
    Given the specification for \( \SER \) (\cref{fig:execution-tests}), the hypothesis that \( \vi, \vi' \in \Views(\mkvs_0) \) never holds.
\end{proof}

