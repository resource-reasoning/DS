\begin{theorem}
\label{thm:appendix-et-composition-1}
Let $\ET_1, \ET_2$ be two execution tests. If $\ET_1$ is commutative, 
then $\CMs(\ET_1 \cap \ET_2) = \CMs(\ET_1) \cap \CMs(\ET_2)$. 
\end{theorem}
\begin{proof}
Let \( \ET_{12} = \ET_1 \cap \ET_2 \).
Given the definition of \( \CMs(.) \) function (\cref{def:cm}), we need to prove \( \Confs(\ET_{12}) \subseteq \Confs(\ET_1) \cap \Confs(\ET_2) \) and \( \CMs(\ET_1) \cap \CMs(\ET_2) \subseteq \CMs(\ET_{12}) \)
To prove the former, it suffices to prove the follows:
\[
\begin{array}{@{}l}
    \fora{n,\conf_0, \conf_1, \dots, \conf_n} \conf_0 \text{ is initial } 
    \land \conf_0 \xrightarrowtriangle{\stub}_{\ET_{12}} \cdots \xrightarrowtriangle{\stub}_{\ET_{12}} \conf_n \implies {} \\
    \quad \conf_0 \xrightarrowtriangle{\stub}_{\ET_{1}} \cdots \xrightarrowtriangle{\stub}_{\ET_{1}} \conf_n \land \conf_0 \xrightarrowtriangle{\stub}_{\ET_{2}} \cdots \xrightarrowtriangle{\stub}_{\ET_{2}} \conf_n 
\end{array}
\]
We prove it by induction on the number \( n \).
It holds when \( n = 0 \).
Assume that it holds when \( n = i \), let consider \( n = i + 1 \).
For any \( \conf_{i+1} \) induced by \( \ET_{12} \), there exist some client, view and fingerprint such that \( \conf_i \xrightarrowtriangle{\cl, \vi, \opset}_{\ET_{12}} \conf_{i+1} \).
Since \( \ET_{12} = \ET_1 \cap \ET_2 \), it is easy to see that \( \conf_i \xrightarrowtriangle{\cl, \vi, \opset}_{\ET_{1}} \conf_{i+1} \) and \( \conf_i \xrightarrowtriangle{\cl, \vi, \opset}_{\ET_{2}} \conf_{i+1} \) hold.

To prove the latter, we need to prove the follows:
\[
\begin{array}{@{}l}
    \fora{n,\conf_0, \conf_1,\conf_1',\dots,\conf_{n-1}, \conf_{n-1}', \conf_n} \conf_0 \text{ is initial } \\
    \quad {} \land \conf_0 \xrightarrowtriangle{\stub}_{\ET_{1}} \conf_1 \xrightarrowtriangle{\stub}_{\ET_{1}} \cdots \xrightarrowtriangle{\stub}_{\ET_{1}} \conf_n \land \conf_0 \xrightarrowtriangle{\stub}_{\ET_{2}} \conf_1' \xrightarrowtriangle{\stub}_{\ET_{2}} \cdots \xrightarrowtriangle{\stub}_{\ET_{2}} \conf_n \\
    \qquad {} \implies \conf_n \in \Confs(\ET_{12})
\end{array}
\]
It means that for two traces by \( \ET_1 \) and \( \ET_2 \) respectively, 
if the initial and the finial configurations are the same and satisfy \( \ET_{12} \), 
then all the intermediate configurations from both traces satisfy \( \ET_{12} \).
We prove it by induction on the number \( n \).
It holds when \( n = 0 \) and \( n = 1 \).
Assume that it holds when \( n = i \), let consider \( n = i + 1 \).
Assume a client \( \cl_{i+1} \), a view \( \vi_{i+1} \) and a fingerprint \( \opset_{i+1} \) that transfer the second last configuration \( \conf'_i \) for \( \ET_2 \) to the final configuration \( \conf_{i+1} \):
\[
    \conf'_i \xrightarrowtriangle{\cl'_{i+1}, \vi'_{i+1}, \opset'_{i+1}}_{\ET_2} \conf_{i+1}
\]
Because the final configuration is the same from both traces, both traces must contain exactly the same transactions each of which is issued by the same client, starts with the same view and commits the same fingerprint.
There exist a client \( \cl_j \), a view \( \vi_j \) and a fingerprint \( \opset_j \) from the trace of \( \ET_1 \) such that \( \cl'_{i+1} = \cl_{j} \), \( \vi'_{i+1} \approx \vi_j \) and \( \opset'_{i+1} = \opset_{j}\), where the \( \vi_{i+1} \approx \vi_j \) is defined as the follows:
\[
    \fora{\ke} (\stub, \ke, \stub) \in \opset_j \implies \vi_{i+1}(\ke) = \vi_j(\ke)
\]
For brevity we write \( (\cl, \vi, \opset) = (\cl', \vi', \opset') \) for \( \cl = \cl' \), \( \vi \approx \vi' \) and \( \opset = \opset'\).
Since that a client always picks a greeter transaction identifier, the session order from one trace is the same as the one of another trace.
Similarly, if a transaction write to a key it installs a new version for that key, so the order in which transactions write to keys are the same for both traces.
Thus, all transactions appear after the j-\emph{th} transaction from \( \ET_1 \) do not confect with the j-\emph{th}:
\[
    \fora{k, \cl_k, \vi_k, \opset_k} j < k \leq i \land \conf_{k-1} \xrightarrowtriangle{\cl_k, \vi_k, \opset_k}_{\ET_{1}} \conf_k \implies \cl_k \neq \cl_j \land \nexists{\ke} \ldotp (\otW, \ke, \stub) \in \opset_k \cap \opset_j
\]
By the commutative of \( \ET_1 \), we can move the j-\emph{th} transaction to the end of the trace without changing the final configuration:
\[
\begin{array}{@{}l}
    \exsts{\conf''_{j}, \dots \conf''_i}  \\
    \quad \conf_{j-1} \xrightarrowtriangle{\cl_{j+1}, \vi_{j+1}, \opset_{j+1}}_{\ET_{1}} \conf''_{j} \xrightarrowtriangle{\cl_{j+2}, \vi_{j+2}, \opset_{j+2}}_{\ET_{1}} \\
    \qqquad \cdots \xrightarrowtriangle{\cl_{i+1}, \vi_{i+1}, \opset_{i+1}}_{\ET_{1}} \conf''_i \xrightarrowtriangle{\cl_{j}, \vi_{j}, \opset_{j}}_{\ET_{1}} \conf_{i+1}
\end{array}
\]
Because \( (\cl_{j}, \vi_{j}, \opset_{j}) = (\cl'_{i+1}, \vi'_{i+1}, \opset'_{i+1}) \), 
we know that second last (the i-\emph{th}) configuration from the new trace of \( \ET_0 \) is equal to the one from the trace of \( \ET_2 \), \ie \( \conf''_i = \conf'_i \).
By the \ih, we know \( \conf''_i = \conf'_i \in \Confs(\ET_1 \cap \ET_2) \), then \( \conf_{i+1} \in \Confs(\ET_1 \cap \ET_2)\).
\end{proof}

\begin{proposition}
\label{thm:appendix-et-composition-2}
if $\ET_1, \ET_2$ are commutative, then $\ET_1 \cap \ET_2$ is commutative.
\end{proposition}
\begin{proof}
Let \( \ET_{12} = \ET_1 \cap \ET_2 \).
Assume \(\conf_1, \conf_2, \conf_3, \cl, \cl', \vi, \vi', \opset, \opset' \) such that:
\[
    \conf_1 \xrightarrowtriangle{\cl, \vi, \opset}_{\ET_{12}} \conf_2 \xrightarrowtriangle{\cl', \vi', \opset'}_{\ET_{12}} \conf_3
\]
Therefore, we have:
\[
    \conf_1 \xrightarrowtriangle{\cl, \vi, \opset}_{\ET_{1}} \conf_2 \xrightarrowtriangle{\cl', \vi', \opset'}_{\ET_{1}} \conf_3 \land 
    \conf_1 \xrightarrowtriangle{\cl, \vi, \opset}_{\ET_{2}} \conf_2 \xrightarrowtriangle{\cl', \vi', \opset'}_{\ET_{2}} \conf_3
\]
Because \( ET_1 \)  and \( \ET_2 \) are commutative, there exists a configuration \( \conf'_2 \) such that:
\[
    \conf_1 \xrightarrowtriangle{\cl', \vi', \opset'}_{\ET_{1}} \conf'_2 \xrightarrowtriangle{\cl, \vi, \opset}_{\ET_{1}} \conf_3 \land 
    \conf_1 \xrightarrowtriangle{\cl', \vi', \opset'}_{\ET_{2}} \conf'_2 \xrightarrowtriangle{\cl, \vi, \opset}_{\ET_{2}} \conf_3
\]
so we have the proof that: 
\[
    \conf_1 \xrightarrowtriangle{\cl', \vi', \opset'}_{\ET_{12}} \conf'_2 \xrightarrowtriangle{\cl, \vi, \opset}_{\ET_{12}} \conf_3
\]
\end{proof}

\begin{lemma}
    \(\MRd\) is commutative.
\end{lemma}
\begin{proof}
    Let assume:
    \[
        \mkvs_0, \viewFun_0 \toET{\cl, \vi, \opset}{\MRd} \mkvs_1, \viewFun_1 \toET{\cl', \vi', \opset'}{\MRd} \mkvs_2, \viewFun_2 
    \]
    where \( \cl \neq \cl' \), \( \fora{ \ke } (\otW, \ke, \stub) \notin \opset \cap \opset' \) and \( \vi, \vi' \in \Views(\mkvs_0)\).
    Given the specification of \(\MRd\) (\cref{fig:execution-tests}), we know \( \viewFun_1 = \viewFun_0\rmto{\cl}{\vi''}\) for some \( \vi'' \) such that \( \vi \sqsubseteq \vi'' \).
    Similarly \( \viewFun_2 = \viewFun_1\rmto{\cl'}{\vi'''} \) for some \( \vi''' \) such that \(  \vi' \sqsubseteq \vi''' \). 
    Given that \( \cl \neq \cl' \), we can pick \( \mkvs'_1 \) and \( \viewFun'_1 \) such that \( \mkvs'_1 \in \updKV{\mkvs_0,\vi',\cl',\f'} \) and \( \viewFun'_1 = \viewFun_0\rmto{\cl'}{\vi'''} \), so we have:
    \[
        \mkvs_0, \viewFun_0 \toET{\cl', \vi', \opset'}{\MRd} \mkvs'_1, \viewFun'_1 \toET{\cl, \vi, \opset}{\MRd} \mkvs_2, \viewFun_2 
    \]
\end{proof}                                                                                    

\begin{lemma}
    \(\MW\) is commutative.
\end{lemma}
\begin{proof}
    Let assume:
    \[
        \mkvs_0, \viewFun_0 \toET{\cl, \vi, \opset}{\MW} \mkvs_1, \viewFun_1 \toET{\cl', \vi', \opset'}{\MW} \mkvs_2, \viewFun_2 
    \]
    where \( \cl \neq \cl' \), \( \fora{ \ke } (\otW, \ke, \stub) \notin \opset \cap \opset' \) and \( \vi, \vi' \in \Views(\mkvs_0)\).
    Because the client \( \cl' \) can commit the fingerprint \( \f' \) under \( \vi' \) to the kv-store \( \mkvs_1 \), it can also commit to \( \mkvs_0 \):
    \[
        \begin{array}{@{}l}
            \vi' \in \Views(\mkvs_0) \land \MW \vdash (\mkvs_1, \vi') \csat \f', \viewFun_2(\cl') \implies  \MW \vdash (\mkvs_0, \vi') \csat \f', \viewFun_2(\cl')
        \end{array}
    \]
    Assuming \( \mkvs'_1 \) and \( \viewFun'_1 \) such that \( \mkvs'_1 \in \updKV{\mkvs_0,\vi',\cl',\f'} \) and \( \viewFun'_1 = \viewFun_0\rmto{\cl'}{\viewFun_2(\vi')} \), we need to prove the specification for \( \MW \) (\cref{fig:execution-tests}):
    \[
        \fora{j,i, \ke, \ke'} j \leq \vi(\ke) \wedge \WTx(\hh'_1(\ke', i)) \xrightarrow{\PO ?} \WTx(\hh'_1(\ke, j)) \implies i \leq \vi'(\ke')  \\
    \]
    For any key written by \( \cl' \), there is a new version of the key in \( \mkvs'_1 \).
    Given \( \vi \in \Views(\mkvs_0)\), those new versions installed by \( \cl' \) do not affect \( \vi \):
    \[
        \fora{j,i, \ke} j \leq \vi(\ke) \land \hh'_1(\ke, j)\isdef \implies \hh_0(\ke, j)\isdef
    \]
    so we have:
    \[
        \begin{array}{@{}l}
            \MW \vdash (\mkvs_0, \vi) \csat \f, \viewFun_2(\cl) \implies  \MW \vdash (\mkvs'_1, \vi) \csat \f, \viewFun_2(\cl)
        \end{array}
    \]
\end{proof}


\begin{lemma}
    \(\RYW\) is commutative.
\end{lemma}
\begin{proof}
    Let assume:
    \[
        \mkvs_0, \viewFun_0 \toET{\cl, \vi, \opset}{\RYW} \mkvs_1, \viewFun_1 \toET{\cl', \vi', \opset'}{\RYW} \mkvs_2, \viewFun_2 
    \]
    where \( \cl \neq \cl' \), \( \fora{ \ke } (\otW, \ke, \stub) \notin \opset \cap \opset' \) and \( \vi, \vi' \in \Views(\mkvs_0)\).
    %Assume \( \mkvs'_1 \) and \( \viewFun'_1 \) such that \( \mkvs'_1 \in \updKV{\mkvs_0,\vi',\cl',\f'} \) and \( \viewFun'_1 = \viewFun_0\rmto{\cl'}{\viewFun_2(\vi')} \).
    Given \( \fora{ \ke } (\otW, \ke, \stub) \notin \opset \cap \opset' \) and the specification for \( \RYW \) (\cref{fig:execution-tests}), we have:
    \[
        \fora{\ke} (\otW, \ke, \stub) \in \f \implies \viewFun_1(\cl)(\ke) = \viewFun_2(\cl)(\ke) = \lvert \mkvs_1(\ke) \rvert - 1 = \lvert \mkvs_2(\ke) \rvert - 1
    \]
    We can pick \( \mkvs'_1 \) and \( \viewFun'_1 \) such that \( \mkvs'_1 \in \updKV{\mkvs_0,\vi',\cl',\f'} \) and \( \viewFun'_1 = \viewFun_0\rmto{\cl'}{\viewFun_2(\cl')} \), so we have:
    \[
        \mkvs_0, \viewFun_0 \toET{\cl', \vi', \opset'}{\RYW} \mkvs'_1, \viewFun'_1 \toET{\cl, \vi, \opset}{\RYW} \mkvs_2, \viewFun_2 
    \]
\end{proof}

\begin{lemma}
    \(\WFR\) is commutative.
\end{lemma}
\begin{proof}
    Let assume:
    \[
        \mkvs_0, \viewFun_0 \toET{\cl, \vi, \opset}{\WFR} \mkvs_1, \viewFun_1 \toET{\cl', \vi', \opset'}{\WFR} \mkvs_2, \viewFun_2 
    \]
    where \( \cl \neq \cl' \), \( \fora{ \ke } (\otW, \ke, \stub) \notin \opset \cap \opset' \) and \( \vi, \vi' \in \Views(\mkvs_0)\).
    Because the client \( \cl' \) can commit the fingerprint \( \f' \) under \( \vi' \) to the kv-store \( \mkvs_1 \), it can also commit to \( \mkvs_0 \):
    \[
        \begin{array}{@{}l}
            \vi' \in \Views(\mkvs_0) \land \WFR \vdash (\mkvs_1, \vi') \csat \f', \viewFun_2(\cl') \implies  \WFR \vdash (\mkvs_0, \vi') \csat \f', \viewFun_2(\cl')
        \end{array}
    \]
    Assume \( \mkvs'_1 \) and \( \viewFun'_1 \) such that \( \mkvs'_1 \in \updKV{\mkvs_0,\vi',\cl',\f'} \) and \( \viewFun'_1 = \viewFun_0\rmto{\cl'}{\viewFun_2(\vi')} \).
    For any key written by \( \cl' \), there is a new version of the key in \( \mkvs'_1 \).
    Given \( \vi \in \Views(\mkvs_0)\), those new versions installed by \( \cl' \) do not affect \( \vi \):
    \[
        \fora{j,i, \ke} j \leq \vi(\ke) \land \hh'_1(\ke, j)\isdef \implies \hh_0(\ke, j)\isdef
    \]
    so we have:
    \[
        \begin{array}{@{}l}
            \WFR \vdash (\mkvs_0, \vi) \csat \f, \viewFun_2(\cl) \implies \WFR \vdash (\mkvs'_1, \vi) \csat \f, \viewFun_2(\cl)
        \end{array}
    \]
\end{proof}

\begin{lemma}
    \(\UA\) is commutative.
\end{lemma}
