\section{Proofs of Results on the Operational Semantics}

\mypar{Proof of Proposition \ref{prop:kv2aexec_transition}.}

Suppose that $(\hh, \viewFun, \thdenv), \prog \toT{(\cl, \vi, \opset)}_{\ET_{\top}} (\hh', \viewFun', \thdenv), \prog'$. 
This transition can only be inferred by applying Rule \rl{PSingleThread}, meaning that 
\begin{itemize}
\item $\prog(\cl) \mapsto \cmd$ for some command $\cmd$, 
\item $\cl \vdash (\hh, \viewFun(\cl), \thdenv(\cl)), \cmd \toT{(\cl, \vi, \opset)}_{\ET_{\top}} (\hh', \vi', \stk'), \cmd'$ 
for some $\vi', \stk'$, and 
\item $\viewFun' = \viewFun\rmto{\cl}{\vi'}$, $\thdenv' = \thdenv\rmto{\cl}{\stk'}$, $\prog' = \prog\rmto{\cl}{\cmd'}$. 
\end{itemize}
Let now $\aexec$ be such that $\hh_{\aexec} = \hh$, and let $\T \subseteq \T_{\aexec}$ be a set of read-only 
transactions in $\aexec$. It suffices to show that there exists an abstract execution $\aexec'$ such that 
$\hh_{\aexec'} = \hh'$, and 
\[
\cl \vdash (\aexec, \thdenv(\cl)), \cmd \toA{(\cl, \T \cup \Tx(\hh, \vi), \opset}_{(\RP_{\LWW}, \emptyset)} (\aexec', \stk'), \cmd'.
\]
Then, by applying Rule \rl{ASingleThread}, we obtain 
\[ 
(\aexec, \thdenv) \prog \toA{(\cl, \T \cup \Tx(\hh,\vi), \opset)}_{\RP_{\LWW}, \emptyset)} (\aexec' ,\thdenv'), \prog'.
\]

We perform a rule induction on the derivation of the transition $\cl \vdash (\hh, \viewFun(\cl), \thdenv(\cl)), \cmd \toT{(\cl, \vi, \opset)}_{\ET_{\top}} (\hh', \vi', \h'), \cmd'$. 
The base case corresponds to such a transition being inferred by applying Rule \rl{PCommit}. 
This implies that 
\begin{itemize}
\item $\cmd = \ptrans{\trans}$ for some $\trans$, and $\cmd' = \pskip$,
\item $\viewFun(\cl) \viewleq \vi$, 
\item let $\h = \snapshot(\hh, \vi)$; then $(\thdenv(\cl), \h, \emptyset) \toL^{\ast} (\stk', \_, \opset)$, 
\item $hh' = \updateKV(\hh, \vi, \txid, \opset)$ for some $\txid \in \nextTxId(\hh, \cl)$, 
\item $\ET_{\top} \vdash \hh, \vi \triangleright \opset: \vi'$.
\end{itemize}

Choose an arbitrary set of of read-only transactions $\T \subseteq \T_{\aexec}$: 
we observe that, since $\hh_{\aexec} = \hh$, then  by \cref{prop:getview.tx} $\getView(\aexec, \T \cup \Tx(\hh, \vi)) = \vi$. 
We can now apply \cref{prop:compatible.aexec2kv} and ensure that $\RP_{\LWW}(\aexec, \T \cup \Tx(\hh, \vi)) = \{\h\}$.
Let $\aexec' = \extend(\aexec, \txid, \T \cup \Tx(\hh, \vi)), \opset)$; because $\getView(\aexec, \T \cup \Tx(\hh, \vi)) = \vi$, 
$\hh_{\aexec} = \hh$,
then by \cref{prop:extend.update.sameop} we have that $\hh_{\aexec'} = \updateKV(\hh, \vi, \txid, \opset) = \hh'$. 
We  have that $\T \cup \Tx(\hh, \vi) \subseteq \T_{\aexec}$, $\h \in \RP_{\LWW}(\aexec, \T \cup \Tx(\hh, \vi))$,
$(\thdenv(\cl), \h, \emptyset) \toL^{\ast} (\stk', \_, \opset)$ and $\txid \in \nextTxId(\T_{\aexec}, \cl)$. 
Now we can apply Rule \rl{ACommit} and infer
\[
\cl \vdash (\aexec, \thdenv(\cl)), \ptrans{\trans} \toA{(\cl, \T \cup \Tx(\hh_{\aexec}, \vi))}_{(\RP_{\LWW}, \emptyset)} 
(\aexec', \stk'), \pskip,
\]
which is exactly what we wanted to prove. 

\ac{Other cases follow by induction easily, since every rule of the kv-store semantics is 
matched by a rule in the abstract semantics.}

\mypar{Proof of Proposition \ref{prop:aexec2kv_transition}.}
Suppose that $(\aexec, \thdenv), \prog \toA{(\cl, \T, \opset)}_{(\RP_{\LWW}, \emptyset)} (\aexec', \thdenv'), \prog'$. 
Fix a function $\viewFun$ from clients in $\dom(\prog)$ to views in $\Views(\hh)$, and a view $\vi \viewleq \getView(\aexec, \T)$.
We show that 
$(\hh_{\aexec}, \viewFun\rmto{\cl}{\vi}, \thdenv) \toT{(\cl, \getView(\aexec, \T), \opset)}_{\ET_{\top}} (\hh_{\aexec'}, 
\viewFun, \thdenv'), \prog'$. 

Note that the transition $(\aexec, \thdenv, \prog \toA{(\cl, \T, \opset)}_{\RP_{\LWW}, \emptyset)} (\aexec', \thdenv'), \prog'$ 
can only be inferred using Rule \rl{ASingleThread}, from which it follows that $\cl \vdash (\aexec, \thdenv(\cl)), \prog(\cl) 
\toA{(\cl, \T, \opset)}_{\RP_{\LWW}, \emptyset)}, (\aexec' ,\stk') \cmd'$ for some $\stk'$ such that $\thdenv' = 
\thdenv\rmto{\cl}{\stk'}$ and $\cmd'$ such that $\prog' = \prog\rmto{\cl}{\cmd'}$.
It suffices to show that $\cl \vdash (\hh_{\aexec}), \vi, \thdenv(\cl), \prog(\cl) \toT{(\cl, \getView(\hh_{\aexec}, \T), \opset)}_{\ET_{\top}} 
(\hh_{\aexec'}, \viewFun(\cl), \stk'), \cmd'$. Then by applying Rule \rl{PSingleThread} we obtain 
\[
(\hh_{\aexec}, \viewFun\rmto{\cl}{\vi}, \thdenv), \prog \toT{(\cl, \getView(\hh_{\aexec}, \T), \opset)}_{\ET_{\top}} 
(\hh_{\aexec'}, \viewFun, \thdenv'), \prog'.
\]

The rest of the proof is performed by a rule induction on the derivation used to infer 
the transition $\cl \vdash (\aexec, \thdenv(\cl)), \prog(\cl) \toA{(\cl, \T, \opset)}_{(\RP_{\LWW}, \emptyset)} (\aexec', \stk'), \cmd'$. 
We only consider the most important case, namely the one in which the derivation above 
has been inferred using Rule \rl{ACommit}. In this case we have that 
$\prog = \ptrans{\trans}$, $\prog' = \pskip$, there exists an index $\h \in \RP_{\LWW}(\aexec, \T)$ such that 
$(\thdenv(\cl), \h, \emptyset), \trans \toL^{\ast} (\stk', \_, \opset), \pskip$, and $\aexec' = 
\extend(\aexec, \txid, \T, \opset)$ for some $\txid \in \nextTxId(\aexec, \cl)$. 
Furthermore, it is possible to prove, by induction on the length of the derivation $(\thdenv(\cl), \h, \emptyset), \trans \toL^{\ast} (\stk', \_, \opset), \pskip$, 
that whenever $(\otR, \ke, \val) \in \opset$, then $\h(\ke) = \val$.
Note that by \cref{prop:compatible.aexec2kv} we have that $\snapshot(\hh_{\aexec}, \getView(\aexec, \T)) = 
\h$. Also, if $(\otR,\ke, \val) \in \opset$ then $\h(\ke) = \val$, which is possible only if  
$\hh_{\aexec}(\ke, \max_{<}(\getView(\aexec, \T)(\ke))) = (\val, \_, \_)$. This ensures 
that $\ET_{\top} \vdash (\hh_{\aexec}, \getView(\aexec, \T)) \triangleright \opset: \viewFun(\cl)$. 
\ac{There should be a condition here that $\viewFun(\cl)(\ke)$ is the same as $\getView(\aexec, \T)(\ke)$ 
for any $\ke$ that is neither read nor written by $\opset$.} 
We can now combine all the facts above to apply rule \rl{PCommit} and show that 
\[
\cl \vdash (\hh_{\aexec}, \vi, \thdenv(\cl)), \ptrans{\trans} \toT{(\cl, \getView(\hh_{\aexec}, \T), \opset}_{\ET_{\top}} 
(\hh', \viewFun(\cl), \stk', \pskip, 
\] 
where $\hh' = \updateKV(\hh_{\aexec}, \txid, \getView(\aexec, \T), \opset)$. 
Recall that $\aexec' = \extend(\aexec, \T, \txid, \opset)$. 
By \cref{prop:extend.update.sameop} we have that $\hh' = \hh_{\aexec'}$, 
which concludes the proof.

\subsection{Proof of \cref{cor:et-soundness}}

If $\ET$ is sound with respect to $(\RP_{\LWW}, \Ax)$, then 
for any program $\prog$, $\interpr{\prog}_{\ET} \subseteq \{ \hh_{\aexec} \mid \aexec \in \interpr{P}_{(\RP_{\LWW}, \Ax)}$.
By the definition of \( \interpr{\prog}_{\ET} \) and \( \interpr{P}_{(\RP_{\LWW}, \Ax)} \), it suffices to prove the following:
\[
\begin{array}{@{}l@{}}
    \fora{\prog,\prog',\mkvs,\mkvs',\viewFun,\viewFun',\aexec,\thdenv,\thdenv',\cl,\vi,\f} \\
    \quad (\mkvs, \viewFun, \thdenv), \prog \toT{(\cl, \vi, \f)}_{\ET} (\mkvs', \viewFun', \thdenv'), \prog'
    \land \mkvs = \mkvs_{\aexec}
    \implies {} \\
    \qquad \exsts{\aexec',\T}
    (\aexec, \thdenv), \prog \toA{(\cl, \T, \f)}_{(\RP_{\LWW}, \Ax)} (\aexec', \thdenv'), \prog' 
    \land \mkvs' = \mkvs_{\aexec'}  
\end{array}
\]
Note that \( \ET \) is sound with respect to \( (\RP_{\LWW}, \Ax) \), we can prove a stronger result, \ie \cref{lem:aux-et-soundness-single-step-sound}, without losing generality.

\begin{lemma}
    \label{lem:aux-et-soundness-single-step-sound}
    Suppose a step \( (\mkvs, \viewFun, \thdenv), \prog \toT{(\cl, \vi, \f)}_{\ET} (\mkvs', \viewFun', \thdenv'), \prog' \), where the execution test \( \ET \) is sound with respect to \( (\RP_{\LWW}, \Ax) \).
    For any abstract execution \( \aexec \) and some read-only transactions \( \T_{r} \) such that \( \mkvs = \mkvs_\aexec \) and \( I(\aexec, \cl) \subseteq \Tx(\mkvs, \viewFun(\cl)) \cup \T_{r}\),
    there exist a new abstract execution \( \aexec' \), some transactions \( \T \) and some read-only transactions \( \T'_{r} \) such that: 
    \[
        (\aexec, \thdenv), \prog \toA{(\cl, \T, \f)}_{(\RP_{\LWW}, \Ax)} (\aexec', \thdenv'), \prog' \land \mkvs' = \mkvs_{\aexec'} 
        \land I(\aexec', \cl) \subseteq \Tx(\mkvs', \viewFun'(\cl)) \cup \T'_{r}
    \]
\end{lemma}
\begin{proof}
Suppose that $(\hh, \viewFun, \thdenv), \prog \toT{(\cl, \vi, \opset)}_{\ET} (\hh', \viewFun', \thdenv), \prog'$. 
This transition can only be inferred by applying Rule \rl{PSingleThread}, meaning that 
\begin{itemize}
\item $\prog(\cl) = \cmd$ for some command $\cmd$, 
\item $\cl \vdash (\hh, \viewFun(\cl), \thdenv(\cl)), \cmd \toT{(\cl, \vi, \opset)}_{\ET} (\hh', \vi', \stk'), \cmd'$ 
for some $\vi', \stk'$, and 
\item $\viewFun' = \viewFun\rmto{\cl}{\vi'}$, $\thdenv' = \thdenv\rmto{\cl}{\stk'}$, $\prog' = \prog\rmto{\cl}{\cmd'}$. 
\end{itemize}
Let now $\aexec$ be such that $\hh_{\aexec} = \hh$, and let $\T \subseteq \T_{\aexec}$ be a set of 
transactions in $\aexec$. It suffices to show that there exists an abstract execution $\aexec'$ such that 
$\hh_{\aexec'} = \hh'$, and 
\[
\cl \vdash (\aexec, \thdenv(\cl)), \cmd \toA{(\cl, \T , \opset}_{(\RP_{\LWW}, \Ax)} (\aexec', \stk'), \cmd'.
\]
Then, by applying Rule \rl{ASingleThread}, we obtain 
\[ 
    (\aexec, \thdenv) \prog \toA{(\cl, \T, \opset)}_{(\RP_{\LWW}, \Ax)} (\aexec' ,\thdenv'), \prog' \land \mkvs' = \mkvs_{\aexec'}
\]

We perform a rule induction on the derivation of the transition $\cl \vdash (\hh, \viewFun(\cl), \thdenv(\cl)), \cmd \toT{(\cl, \vi, \opset)}_{\ET_{\top}} (\hh', \vi', \h'), \cmd'$. 

\caseB{\rl{PCommit}}
This implies that 
\begin{itemize}
\item $\cmd = \ptrans{\trans}$ for some $\trans$, and $\cmd' = \pskip$,
\item $\viewFun(\cl) \viewleq \vi$, 
\item $\h = \snapshot(\hh, \vi)$ for some \( \h \), and then $(\thdenv(\cl), \h, \emptyset) \toL^{\ast} (\stk', \_, \opset)$, 
\item $\hh' = \updateKV(\hh, \vi, \txid, \opset)$ for some $\txid \in \nextTxId(\hh, \cl)$, and
\item $\ET \vdash \hh, \vi \triangleright \opset: \vi'$.
\end{itemize}

Since \( \ET \) is sound with respect to \( (\RP_{\LWW}, \Ax) \),
choose an arbitrary set of of read-only transactions $\T_{rd} \subseteq \T_{\aexec}$ in \( \aexec \) such that \( I(\aexec, \cl) \subseteq \Tx(\mkvs, \viewFun(\cl)) \cup \T_{r}\).
Given the soundness of \( \ET \), it is also know that there exist sets of read-only transactions  \( \T'_{rd}, \T''_{rd} \) and a new abstract execution \( \aexec' \) such that 
\[
    \aexec' = \extend(\aexec, \txid, \Tx(\hh, \vi) \cup \T_{rd} \cup \T'_{rd} ), \opset)  \land I(\aexec', \cl)  \subseteq  \Tx(\mkvs', \vi') \cup \T''_{rd}
\]
Since $\hh_{\aexec} = \hh$, then by \cref{prop:getview.tx} $\getView(\aexec, \Tx(\hh, \vi) \cup \T_{rd} \cup \T'_{rd}) = \vi$. 
We can now apply \cref{prop:compatible.aexec2kv} and ensure that $\RP_{\LWW}(\aexec, \Tx(\hh, \vi) \cup \T_{rd} \cup \T'_{rd}) = \{\h\}$.
Because $\getView(\aexec, \Tx(\hh, \vi) \cup \T_{rd} \cup \T'_{rd}) = \vi$ and $\hh_{\aexec} = \hh$,
then by \cref{prop:extend.update.sameop} we have that $\hh_{\aexec'} = \updateKV(\hh, \vi, \txid, \opset) = \hh'$. 
We  have that $\T \cup \Tx(\hh, \vi) \subseteq \T_{\aexec}$, $\h \in \RP_{\LWW}(\aexec, \T \cup \Tx(\hh, \vi))$,
$(\thdenv(\cl), \h, \emptyset) \toL^{\ast} (\stk', \_, \opset)$ and $\txid \in \nextTxId(\T_{\aexec}, \cl)$. 
Now we can apply Rule \rl{ACommit} and infer
\[
\begin{array}{@{}l@{}}
    \cl \vdash (\aexec, \thdenv(\cl)), \ptrans{\trans} 
    \toA{(\cl, \Tx(\hh, \vi) \cup \T_{rd} \cup \T'_{rd}, \f))}_{(\RP_{\LWW}, \Ax)}  
    (\aexec', \stk'), \pskip \\
    {} \land \mkvs' = \mkvs_{\aexec'} 
    \land I(\aexec', \cl) \subseteq \Tx(\mkvs', \viewFun'(\cl)) \cup \T''_{rd} 
\end{array}
\]

\caseI{..............}
The rest cases can be proven by applying \ih

\end{proof}

\subsection{Proof of Theorem \ref{thm:prooftechnique_sound}}
Let $\ET$ be an execution test that is sound with respect to an 
axiomatic specification $(\RP_{\LWW}, \Ax)$. Let $I$ be 
the invariant that is used to prove that $\ET$ is sound with respect to 
$(\RP_{\LWW}, \Ax)$. Consider an $\ET$-trace $\tr$; 
without loss of generality, and because of \cref{prop:et.normalform}, 
we can assume that $\tr$ is in normal form.  For simplicity, we can also 
assume that the trace does not have transitions labelled as $(\_, \emptyset)$, 
as the proof overhead in the case such labelled transitions are allowed is negligible 
and only involves technical details. Thus we have that 
\[
\tr = (\hh_{0}, \viewFun_{0}) \xrightarrowtriangle{(\cl_{0}, \varepsilon)} (\hh_{0}, \viewFun_{0}') 
\xrightarrowtriangle{(\cl_{0}, \opset_{0})} (\hh_1, \viewFun_{1}) \xrightarrowtriangle{(\cl_1, \varepsilon)}  \cdots
\xrightarrowtriangle{(\cl_{n-1}, \opset_{n-1})} (\hh_{n}, \viewFun_{n}).
\]
For any $i =0, \cdots n$, let $\tr_{i}$ be the prefix of $\tr$ that 
contains only the first $2 \cdot i$ transitions. 
Clearly $\tr_{i}$ is a valid $\ET$-trace, and it is also a $\ET_{\top}$-trace. 
By \cref{prop:kvtrace2aexec}, any 
$\aexec_{i} \in \aeset(\tr_{i})$ satisfies the last write wins policy. 
%Furthermore, $\aeset(\tr_{0}) = \{ ([], \emptyset, \emptyset)\}$, 
%and for any $\aexec_{i+1} \in \aeset(\tr_{i+1})$, where $i < \frac{n}{2}$, 
%there exist $\aexec_{i} \in \aeset(\tr_{i})$ and $\txid^{i} \in \nextTxId(\T_{\aexec_{i}}, \cl)$ such that 
%$\aexec_{i+1} = \extend(\aexec_{i}, \txid^{i}, \opset_{i}, \T_{i}$, where $\T_{i} = \Tx(\hh_{i}, \viewFun_{i}'(\cl)) 
%\cup \T'_{i}$ for some $\T'_{i} \subseteq \T_{\aexec_{i}}$ that only contains read-only transactions. 
%This is because of the definition of $\aeset(\tr_{i})$, and the fact that we are assuming that 
%no transition in $\tr$ is labelled as $(\_, \emptyset)$.
We show by induction on $i=0,\cdots, n$ that we can always find an abstract 
execution $\aexec_{i} \in \aeset(\tr_{i})$ such that $\aexec \models \Ax$, 
and for any client $\cl$ and set of transactions 
$\T^{i}_{\cl} = \Tx(\aexec_{i}, \viewFun_{i}(\cl)) \cup \T^{i}_{(\cl, \mathsf{rd})}$, 
where $\T_{(\cl, \mathsf{rd})}^{i}$ contains only read-only transactions in $\aexec_{i}$, 
%$\cup \T_{\cl}'$, where $\T_{\cl}'$ only contains read-only transactions, 
then $I(\aexec_{i}, \cl) \subseteq \T^{i}_{\cl}$. Because $\aexec_{i}$ satisfies the last write 
wins policy, then it must be the case that $\aexec_{i} \models (\RP_{\LWW}, \Ax)$. By choosing 
$i = n$, we obtain that $\aexec_{n} \models (\RP_{\LWW}, \Ax)$. By \cref{prop:kv2aexec}, 
$\hh_{\aexec_{n}} = \hh_{n}$, and there is nothing left to prove.

If $i = 0$, Let $\aexec_{0}$ be the only abstract execution included in $\aeset(\tr_{0})$, 
that is $\aexec_{0} = ([], \emptyset, \emptyset)$. For any $\A \in \Ax$, it must be the case that 
$\A(\aexec_{0}) \subseteq \T_{\aexec_{0}} = \emptyset$, hence the inequation $\A(\aexec_{0}) \subseteq \VIS_{\aexec_{0}}$ 
is trivially satisfies. Furthermore, for the client invariant $I$ we also require that $I(\aexec_{0}, \_) \subseteq \T_{\aexec_{0}} = \emptyset$; 
for any client $\cl$ we can choose $\T_{\cl}^{0} = \Tx(\viewFun_{0}(\cl)) \cup \emptyset = \emptyset$. Therefore 
$I(\aexec_{0}, \cl) = \emptyset \subseteq \emptyset = \T_{\cl}^{0}$.

%Next, consider an abstract execution $\aexec_{i+1} \in \aeset(\tr_{i+1})$. 
%We have that $\tr_{i+1} = \tr_{i} \xrightarrowtriangle{(\cl_{i}, \varepsilon)} (\hh_{i}, \viewFun_{i}') 
%\xrightarrowtriangle{(\cl_{i}, \opset_{i})}$. Let $\aexec_{i+1} \in \aeset(\tr_{i+1})$. 
%By \cref{def:kvtrace2aexec}, 
%using the assumption that $\opset_{i} \neq \emptyset$, then it must be the case that 
%$\aexec_{i+1} = \extend(\aexec_{i}, \txid^{i}, \T'_{i}, \opset_{i})$, where 
% $\aexec_{i} \in \aeset(\tr_{i})$, $\txid^{i} \in \nextTxId(\T_{\aexec_{i}}, \cl)$, and
%$(\T^{\cl}_{i})' = \Tx(\hh_{i}, \viewFun_{i}'(\cl)) \cup \T_{(\mathsf{rd}, i)}^{\cl}$ for some   
%$(\T_{(\mathsf{rd}, \cl)}^{i})' \subseteq \T_{\aexec_{i}}$ that only contains read-only transactions. 
Let now $i' = i + 1$, where $i < n$.
By the inductive hypothesis, there exists an abstract execution $\aexec$ such that  
\begin{itemize}
\item for all $\A \in \Ax$, $\aexec_{i} \models \A$, and 
\item for any client $\cl$ and set of transactions $\T_{\cl}^{i} = \Tx(\hh_{i}, \viewFun_{i}(\cl)) \cup \T_{(\cl, \mathsf{rd})}^{i}$, 
where $\T_{(\cl, \mathsf{rd})}^{i}$ contains read-only transactions in $\aexec_{i}$,
then $I(\aexec, \cl) \subseteq \T_{\cl}^{i}$.
\end{itemize}
Consider the transition $(\hh_{i}, \viewFun_{i}) \xrightarrowtriangle{(\cl_{i}, \varepsilon)} (\hh_{i}, \viewFun_{i'})$. 
By definition, it must be the case that $\viewFun'_{i} = \viewFun_{i}\rmto{\cl}{\vi'_{i}}$ 
for some $\vi'_{i}$ such that $\viewFun_{i}(\cl) \viewleq \vi'_{i}$.
Let $(\T_{\cl}^{i})' = \Tx(\hh_{i}, \vi'_{i}) \cup \T_{(\cl, \mathsf{rd})}^{i}$; then we must have 
\[
\T_{\cl}^{i} = \Tx(\hh_{i}, \viewFun_{i}(\cl)) \cup  \T_{(\cl, \mathsf{rd})}^{i} \subseteq \Tx(\hh_{i}, \vi'_{i}) \cup \T_{(\cl, \mathsf{rd})}^{i}= (\T_{\cl}^{i})'. 
\]
As a consequence, $I(\aexec, \cl) \subseteq \T_{\cl}^{i} \subseteq (\T_{\cl}^{i})'$.

%$\cup \T_{(\mathsf{rd}, \cl)}^{i}$, where $\T_{(\mathsf{rd}, \cl)}^{i}$ contains read-only transactions, 
%such that $I(\aexec_{i}, \cl) \subseteq \T^{\cl}_{i}$. 
%Because $(\hh_{i}, \viewFun_{i}) \xrightarrowtriangle{(\cl_{i}, \varepsilon)} (\hh_{i}, \viewFun_{i'})$, 
%we have that $\viewFun_{i}' = \viewFun_{i}\rmto{\cl}{\vi'_{i}}$, for some $\vi'_{i}$ such that 
%$\viewFun_{i}(\cl) \viewleq \vi'_{i}$. This implies that $ \Tx(\aexec_{i},\viewFun_{i})(\cl) 
%\subseteq \Tx(\aexec_{i}, \vi'_{i})$; recall that  $(\T_{\cl}^{i})' = \Tx(\aexec_{i}, \vi'_{i}) \cup \T_{(\cl, \mathsf{rd})}^{i}$, 
%hence$\T_{\cl}^{i} \subseteq (\T_{\cl})^{i}'$. We have therefore that, for any client $\cl \neq \cl'$, 
%$I(\aexec_{i}, \cl) \subseteq \T_{\cl} = \Tx(\aexec_{i}, \viewFun'_{i}) \cup \T'_{\cl}$, 
%and $I(\aexec_{i}, \cl_{i}) \subseteq \T^{i}_{\cl} \subseteq (\T^{i}_{\cl})'$.

Next, consider the transition $(\hh_{i}, \viewFun_{i}') \xrightarrowtriangle{(\cl_{i}, \opset_{i})}_{\ET} 
(\hh_{i+1}, \viewFun_{i+1})$, which appears in the trace $\tr$. A necessary condition for this transition 
to appear in $\tr$ is that $\ET \vdash (\hh_{i}, \viewFun(\cl) \triangleright \opset_{i}: \viewFun_{i+1}(\cl)$. 
Because $I$ is the invariant condition used in the proof that $\ET$ is sound with respect to $\Ax$, 
%because $\getView(\aexec_{i}, (\T^{i}_{\cl})') = \vi'_{i}$ 
%(by the facts that $\hh_{\aexec_{i}} = \hh_{i}$, $(\T^{i}_{\cl})' = \Tx(\hh_{i}, \vi'_{i}) \cup \T_{(\cl, \mathsf{rd})}^{i}$, 
%transactions in $\T_{(\cl, \mathsf{rd})}^{i}$ are read-only in $\aexec_{i}$, 
%and by \cref{prop:getview.tx}), 
and because 
$I(\aexec_{i}, \cl_{i}) \subseteq (\T^{i}_{\cl})' \cup \T_{(\cl, \mathsf{rd})}^{i}$, 
by \cref{def:et_sound} we have the following facts: 
\begin{itemize}
\item there exists a set of read-only transactions $(\T_{\mathsf(\cl, \mathsf{rd})}^{i})'$ 
such that $\{\txid' \mid (\txid', \txid_{(\cl, i)}) \in \A(\aexec_{i+1})\} \subseteq 
(\T^{i}_{\cl})' \cup (\T_{(\cl, \mathsf{rd})})'$, for 
$\txid_{(\cl, i)} \in \nextTxId(\hh_{i}, \cl)$ and $\aexec_{i+1} = 
\extend(\aexec_{i}, \txid_{(\cl, i)}, (\T^{i}_{\cl})' \cup (\T_{(\cl, \mathsf{rd})}^{i})', \opset_{i})$, 
\item there exists a set of transactions $\T_{\mathsf(\cl, \mathsf{rd})}^{i+1}$ 
such that $I(\aexec_{i+1}, \cl) \subseteq \Tx(\hh_{i+1}, \viewFun_{i+1}(\cl)) \cup \T_{\mathsf(\cl, \mathsf{rd})}^{i+1} = \T_{\cl}^{i+1}$.
\end{itemize} 
Because $\aexec_{i} \in \aeset(\tr_{i})$, by definition of $\aeset(\_)$ we have that 
$\aexec_{i+1} \in \aeset(\tr)$ (under the assumption that $\opset_{i} \neq \emptyset$), 
and because $\lastConf(\tr_{i+1}) = (\hh_{i+1}, \_)$, then $\hh_{\aexec_{i+1}} = \hh_{i+1}$. 
We observe the following facts: 
\begin{itemize}
\item for any $\A \in \Ax$, $\A(\aexec_{i+1}) \subseteq \VIS_{\aexec}^{i+1}$. 
To this end, choose, $\A \in \Ax$, and let $(\txid', \txid) \in \A(\aexec_{i+1})$. 
Because $\aexec_{i+1} = \extend(\aexec_{i}, \txid_{(\cl, i)}, (\T_{\cl}^{i})' \cup (\T_{(\cl, \mathsf{rd})}^{i})', \opset_{i}$), 
we distinguish between two cases.

If $\txid = \txid_{(\cl, i)}$, then it must be the case that $\txid' \in (\T^{i}_{\cl})' \cup (\T_{(\cl, \mathsf{rd})}^{i})', \opset_{i})$, 
and by definition of $\extend(\_)$ we have that $(\txid' ,\txid_{(\cl, i)}) \in \VIS_{\aexec_{i+1}}$. 
If $\txid \neq \txid_{(\cl, i)}$, then we have that $\txid, \txid' \in \T_{\aexec_{i}}$. Because 
$\aexec_{i}$ and $\aexec_{i+1}$ agree on $\T_{\aexec_{i}}$, then $(\txid', \txid) \in \A(\aexec_{i})$, 
and because $\aexec_{i} \models \A$, then $(\txid', \txid) \in \VIS_{\aexec_{i}}$. By definition of 
$\extend$, it follows that $(\txid', \txid) \in \VIS_{\aexec_{i+1}}$.

\item Finally, choose a client $\cl' \in \Clients$. If $\cl' = \cl$, then we have already proved that 
$I(\aexec_{i+1}, \cl) \subseteq \T_{\cl}^{i+1}$. 
if $\cl' \neq \cl$, then note that $\viewFun_{i}(\cl') = \viewFun'_{i}(\cl') = \viewFun_{i+1}(\cl')$, 
and in particular $(\T{\cl'}_{i})' = \Tx(\aexec_{i}, \viewFun'_{i}(\cl')) = \Tx(\aexec_{i+1}, \viewFun_{i+1}(\cl')) =  \T_{\cl'}^{i+1}$.
By the inductive hypothesis we know that $I(\aexec_{i}, \cl) \subseteq \T_{\cl'}^{i}$, 
and by the definition of client-based invariant we have that $I(\aexec_{i+1}, \cl) \subseteq \T_{\cl'}^{i} = \T_{\cl'}^{i+1}$. 
\end{itemize}

\mypar{Proof of Theorem \ref{thm:et_complete}}
Fix an abstract execution $\aexec \in \CMa(\RP_{\LWW}, \Ax)$. 
Suppose that $\T_{\aexec} = \{\txid_{i}\}_{i=1}^{n}$ for some $n$, and 
$\forall i=1,\cdots,n-1.\;\txid_{i} \xrightarrow{\AR_{\aexec}} \txid_{i+1}$.
For any $i=1,\cdots,n-1$, let $\cl_{i}$ be such that $\txid_{i} = \txid_{\cl_{i}}^{\cdot}$.

Because $\ET$ is complete with respect to $(\RP_{\LWW}, \Ax)$, 
for any $i=1,\cdots,n$ we can find two views $\vi'_{i-1}, \vi_{i}$ such that 
\begin{itemize}
\item $\vi'_{i-1} = \getView(\aexec, \VIS^{-1}_{\aexec}(\txid_{i}))$, 
\item there exists a set of transactions $\T_{i}$ such that $\getView(\aexec, \T_{i}) = \vi_{i}$, and 
either $\min_{<}\{\txid' \mid \txid_{i} \xrightarrow{\PO_{\aexec}} \txid'\}$ is 
is defined and $\T_{i} \subseteq (\AR_{\aexec}^{-1})?(\txid_{i}) \cap \VIS^{-1}_{\aexec}(\txid')$, 
or $\T_{i} \subseteq (\AR_{\aexec}^{-1}?(\txid_{i})$, 
\item $\ET \vdash (\hh_{\cut(\aexec, i-1)}, \vi'_{i-1}) \triangleright \TtoOp{T}_{\aexec}(\txid_{i}): \vi_{i}$.
\end{itemize}

For $i=1,\cdots,n$ we let $\hh_{i} = \cut(\aexec, i)$, and $\opset_{i} = \TtoOp{T}_{\aexec}(\txid_{i})$. Define 
\[
\begin{array}{lcl}
\viewFun_{0} &=& \lambda \cl \in \{\cl' \mid \exists \txid \in \T_{\aexec}.\; \txid = \txid_{\cl}\}. \lambda \ke. \{0\}\\
\viewFun'_{i-1} &=& \viewFun_{i}\rmto{\cl_{i}}{ \vi'_{i-1}}\\
\viewFun_{i} &=& \viewFun'_{i-1}\rmto{\cl_{i} }{\vi_{i}}\\
&&\\
\hh_{0} = \lambda \ke.(\val_{0}, \txid_{0}, \emptyset)\\
\hh_{i} = \updateKV(\hh_{i-1}, \txid_{i}, \opset_{i}, 
\end{array}
\]

For $i=1,\cdots,n$, let also $\opset_{i} = \TtoOp{T}_{\aexec}(\txid_{i})$.
By Proposition \cref{prop:aexec2kvtrace} we have that the following sequence of $\ET_{\top}$-teductions 
\[
(\hh_{0}, \viewFun_{0}) \xrightarrowtriangle{(\cl_{1}, \varepsilon)}_{\ET_{\top}} (\hh_{0}, \viewFun'_{0}) 
\xrightarrowtriangle{(\cl_{1}, \opset_{1})}_{\ET_{\top}} (\hh_{1}, \viewFun_{1}) \xrightarrowtriangle{(\cl_{2}, \varepsilon)}_{\ET_{\top}} 
\cdots \xrightarrowtriangle{(\cl_{n}, \opset_{n})}_{\ET_{\top}} (\hh_{n}, \viewFun_{n}),
\]
and note that for $i=0,\cdots, n$, $\hh_{i} = \hh_{\cut(\aexec, i)}$. Because 
for $i=1,\cdots,n$ then $\ET \vdash \hh_{\cut(\aexec,i-1)}, \vi'_{i-1} \triangleright \opset_{i} : \vi_{i}$, 
or equivalently $\ET \vdash \hh_{\cut(\aexec, i-1)} \viewFun'_{i-1}(\cl_{i}) \triangleright \opset_{i} : \viewFun_{i}(\cl_{i})$, 
and therefore 
\[
(\hh_{0}, \viewFun_{0}) \xrightarrowtriangle{(\cl_{1}, \varepsilon)}_{\ET} (\hh_{0}, \viewFun'_{0}) 
\xrightarrowtriangle{(\cl_{1}, \opset_{1})}_{\ET} (\hh_{1}, \viewFun_{1}) \xrightarrowtriangle{(\cl_{2}, \varepsilon)}_{\ET} 
\cdots \xrightarrowtriangle{(\cl_{n}, \opset_{n})}_{\ET} (\hh_{n}, \viewFun_{n}).
\]
It follows that $\hh_{n} \in \CMs(\ET)$, and because $\hh_{n} = \hh_{\cut(\aexec, n)} = \hh_{\aexec}$, there 
is nothing left to prove.