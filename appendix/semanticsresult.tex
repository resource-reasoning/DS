\section{Proofs of Results on the Operational Semantics}

\mypar{Proof of Proposition \ref{prop:kv2aexec_transition}.}

Suppose that $(\hh, \viewFun, \thdenv), \prog \toT{(\cl, \vi, \opset)}_{\ET_{\top}} (\hh', \viewFun', \thdenv), \prog'$. 
This transition can only be inferred by applying Rule \rl{PSingleThread}, meaning that 
\begin{itemize}
\item $\prog(\cl) \mapsto \cmd$ for some command $\cmd$, 
\item $\cl \vdash (\hh, \viewFun(\cl), \thdenv(\cl)), \cmd \toT{(\cl, \vi, \opset)}_{\ET_{\top}} (\hh', \vi', \stk'), \cmd'$ 
for some $\vi', \stk'$, and 
\item $\viewFun' = \viewFun\rmto{\cl}{\vi'}$, $\thdenv' = \thdenv\rmto{\cl}{\stk'}$, $\prog' = \prog\rmto{\cl}{\cmd'}$. 
\end{itemize}
Let now $\aexec$ be such that $\hh_{\aexec} = \hh$, and let $\T \subseteq \T_{\aexec}$ be a set of read-only 
transactions in $\aexec$. It suffices to show that there exists an abstract execution $\aexec'$ such that 
$\hh_{\aexec'} = \hh'$, and 
\[
\cl \vdash (\aexec, \thdenv(\cl)), \cmd \toA{(\cl, \T \cup \Tx(\hh, \vi), \opset}_{(\RP_{\LWW}, \emptyset)} (\aexec', \stk'), \cmd'.
\]
Then, by applying Rule \rl{ASingleThread}, we obtain 
\[ 
(\aexec, \thdenv) \prog \toA{(\cl, \T \cup \Tx(\hh,\vi), \opset)}_{\RP_{\LWW}, \emptyset)} (\aexec' ,\thdenv'), \prog'.
\]

We perform a rule induction on the derivation of the transition $\cl \vdash (\hh, \viewFun(\cl), \thdenv(\cl)), \cmd \toT{(\cl, \vi, \opset)}_{\ET_{\top}} (\hh', \vi', \h'), \cmd'$. 
The base case corresponds to such a transition being inferred by applying Rule \rl{PCommit}. 
This implies that 
\begin{itemize}
\item $\cmd = \ptrans{\trans}$ for some $\trans$, and $\cmd' = \pskip$,
\item $\viewFun(\cl) \viewleq \vi$, 
\item let $\h = \snapshot(\hh, \vi)$; then $(\thdenv(\cl), \h, \emptyset) \toL^{\ast} (\stk', \_, \opset)$, 
\item $hh' = \updateKV(\hh, \vi, \txid, \opset)$ for some $\txid \in \nextTxId(\hh, \cl)$, 
\item $\ET_{\top} \vdash \hh, \vi \triangleright \opset: \vi'$.
\end{itemize}

Choose an arbitrary set of of read-only transactions $\T \subseteq \T_{\aexec}$: 
we observe that, since $\hh_{\aexec} = \hh$, then  by \cref{prop:getview.tx} $\getView(\aexec, \T \cup \Tx(\hh, \vi)) = \vi$. 
We can now apply \cref{prop:compatible.aexec2kv} and ensure that $\RP_{\LWW}(\aexec, \T \cup \Tx(\hh, \vi)) = \{\h\}$.
Let $\aexec' = \extend(\aexec, \txid, \T \cup \Tx(\hh, \vi)), \opset)$; because $\getView(\aexec, \T \cup \Tx(\hh, \vi)) = \vi$, 
$\hh_{\aexec} = \hh$,
then by \cref{prop:extend.update.sameop} we have that $\hh_{\aexec'} = \updateKV(\hh, \vi, \txid, \opset) = \hh'$. 
We  have that $\T \cup \Tx(\hh, \vi) \subseteq \T_{\aexec}$, $\h \in \RP_{\LWW}(\aexec, \T \cup \Tx(\hh, \vi))$,
$(\thdenv(\cl), \h, \emptyset) \toL^{\ast} (\stk', \_, \opset)$ and $\txid \in \nextTxId(\T_{\aexec}, \cl)$. 
Now we can apply Rule \rl{ACommit} and infer
\[
\cl \vdash (\aexec, \thdenv(\cl)), \ptrans{\trans} \toA{(\cl, \T \cup \Tx(\hh_{\aexec}, \vi))}_{(\RP_{\LWW}, \emptyset)} 
(\aexec', \stk'), \pskip,
\]
which is exactly what we wanted to prove. 

\ac{Other cases follow by induction easily, since every rule of the kv-store semantics is 
matched by a rule in the abstract semantics.}

\mypar{Proof of Proposition \ref{prop:aexec2kv_transition}.}
Suppose that $(\aexec, \thdenv), \prog \toA{(\cl, \T, \opset)}_{(\RP_{\LWW}, \emptyset)} (\aexec', \thdenv'), \prog'$. 
Fix a function $\viewFun$ from clients in $\dom(\prog)$ to views in $\Views(\hh)$, and a view $\vi \viewleq \getView(\aexec, \T)$.
We show that 
$(\hh_{\aexec}, \viewFun\rmto{\cl}{\vi}, \thdenv) \toT{(\cl, \getView(\aexec, \T), \opset)}_{\ET_{\top}} (\hh_{\aexec'}, 
\viewFun, \thdenv'), \prog'$. 

Note that the transition $(\aexec, \thdenv, \prog \toA{(\cl, \T, \opset)}_{\RP_{\LWW}, \emptyset)} (\aexec', \thdenv'), \prog'$ 
can only be inferred using Rule \rl{ASingleThread}, from which it follows that $\cl \vdash (\aexec, \thdenv(\cl)), \prog(\cl) 
\toA{(\cl, \T, \opset)}_{\RP_{\LWW}, \emptyset)}, (\aexec' ,\stk') \cmd'$ for some $\stk'$ such that $\thdenv' = 
\thdenv\rmto{\cl}{\stk'}$ and $\cmd'$ such that $\prog' = \prog\rmto{\cl}{\cmd'}$.
It suffices to show that $\cl \vdash (\hh_{\aexec}), \vi, \thdenv(\cl), \prog(\cl) \toT{(\cl, \getView(\hh_{\aexec}, \T), \opset)}_{\ET_{\top}} 
(\hh_{\aexec'}, \viewFun(\cl), \stk'), \cmd'$. Then by applying Rule \rl{PSingleThread} we obtain 
\[
(\hh_{\aexec}, \viewFun\rmto{\cl}{\vi}, \thdenv), \prog \toT{(\cl, \getView(\hh_{\aexec}, \T), \opset)}_{\ET_{\top}} 
(\hh_{\aexec'}, \viewFun, \thdenv'), \prog'.
\]

The rest of the proof is performed by a rule induction on the derivation used to infer 
the transition $\cl \vdash (\aexec, \thdenv(\cl)), \prog(\cl) \toA{(\cl, \T, \opset)}_{(\RP_{\LWW}, \emptyset)} (\aexec', \stk'), \cmd'$. 
We only consider the most important case, namely the one in which the derivation above 
has been inferred using Rule \rl{ACommit}. In this case we have that 
$\prog = \ptrans{\trans}$, $\prog' = \pskip$, there exists an index $\h \in \RP_{\LWW}(\aexec, \T)$ such that 
$(\thdenv(\cl), \h, \emptyset), \trans \toL^{\ast} (\stk', \_, \opset), \pskip$, and $\aexec' = 
\extend(\aexec, \txid, \T, \opset)$ for some $\txid \in \nextTxId(\aexec, \cl)$. 
Furthermore, it is possible to prove, by induction on the length of the derivation $(\thdenv(\cl), \h, \emptyset), \trans \toL^{\ast} (\stk', \_, \opset), \pskip$, 
that whenever $(\otR, \ke, \val) \in \opset$, then $\h(\ke) = \val$.
Note that by \cref{prop:compatible.aexec2kv} we have that $\snapshot(\hh_{\aexec}, \getView(\aexec, \T)) = 
\h$. Also, if $(\otR,\ke, \val) \in \opset$ then $\h(\ke) = \val$, which is possible only if  
$\hh_{\aexec}(\ke, \max_{<}(\getView(\aexec, \T)(\ke))) = (\val, \_, \_)$. This ensures 
that $\ET_{\top} \vdash (\hh_{\aexec}, \getView(\aexec, \T)) \triangleright \opset: \viewFun(\cl)$. 
\ac{There should be a condition here that $\viewFun(\cl)(\ke)$ is the same as $\getView(\aexec, \T)(\ke)$ 
for any $\ke$ that is neither read nor written by $\opset$.} 
We can now combine all the facts above to apply rule \rl{PCommit} and show that 
\[
\cl \vdash (\hh_{\aexec}, \vi, \thdenv(\cl)), \ptrans{\trans} \toT{(\cl, \getView(\hh_{\aexec}, \T), \opset}_{\ET_{\top}} 
(\hh', \viewFun(\cl), \stk', \pskip, 
\] 
where $\hh' = \updateKV(\hh_{\aexec}, \txid, \getView(\aexec, \T), \opset)$. 
Recall that $\aexec' = \extend(\aexec, \T, \txid, \opset)$. 
By \cref{prop:extend.update.sameop} we have that $\hh' = \hh_{\aexec'}$, 
which concludes the proof.

\subsection{Proof of Theorem \ref{thm:prooftechnique}}
