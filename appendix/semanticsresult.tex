\section{Proofs of Results on the Operational Semantics}

\mypar{Proof of Proposition \ref{prop:kv2aexec_transition}.}

Suppose that $(\hh, \viewFun, \thdenv), \prog \toT{(\cl, \vi, \opset)}_{\ET_{\top}} (\hh', \viewFun', \thdenv), \prog'$. 
This transition can only be inferred by applying Rule \rl{PSingleThread}, meaning that 
\begin{itemize}
\item $\prog(\cl) \mapsto \cmd$ for some command $\cmd$, 
\item $\cl \vdash (\hh, \viewFun(\cl), \thdenv(\cl)), \cmd \toT{(\cl, \vi, \opset)}_{\ET_{\top}} (\hh', \vi', \stk'), \cmd'$ 
for some $\vi', \stk'$, and 
\item $\viewFun' = \viewFun\rmto{\cl}{\vi'}$, $\thdenv' = \thdenv\rmto{\cl}{\stk'}$, $\prog' = \prog\rmto{\cl}{\cmd'}$. 
\end{itemize}
Let now $\aexec$ be such that $\hh_{\aexec} = \hh$, and let $\T \subseteq \T_{\aexec}$ be a set of read-only 
transactions in $\aexec$. It suffices to show that there exists an abstract execution $\aexec'$ such that 
$\hh_{\aexec'} = \hh'$, and 
\[
\cl \vdash (\aexec, \thdenv(\cl)), \cmd \toA{(\cl, \T \cup \Tx(\hh, \vi), \opset}_{(\RP_{\LWW}, \emptyset)} (\aexec', \stk'), \cmd'.
\]
Then, by applying Rule \rl{ASingleThread}, we obtain 
\[ 
(\aexec, \thdenv) \prog \toA{(\cl, \T \cup \Tx(\hh,\vi), \opset)}_{\RP_{\LWW}, \emptyset)} (\aexec' ,\thdenv'), \prog'.
\]

We perform a rule induction on the derivation of the transition $\cl \vdash (\hh, \viewFun(\cl), \thdenv(\cl)), \cmd \toT{(\cl, \vi, \opset)}_{\ET_{\top}} (\hh', \vi', \h'), \cmd'$. 
The base case corresponds to such a transition being inferred by applying Rule \rl{PCommit}. 
This implies that 
\begin{itemize}
\item $\cmd = \ptrans{\trans}$ for some $\trans$, and $\cmd' = \pskip$,
\item $\viewFun(\cl) \viewleq \vi$, 
\item let $\h = \snapshot(\hh, \vi)$; then $(\thdenv(\cl), \h, \emptyset) \toL^{\ast} (\stk', \_, \opset)$, 
\item $hh' = \updateKV(\hh, \vi, \txid, \opset)$ for some $\txid \in \nextTxId(\hh, \cl)$, 
\item $\ET_{\top} \vdash \hh, \vi \triangleright \opset: \vi'$.
\end{itemize}

Choose an arbitrary set of of read-only transactions $\T \subseteq \T_{\aexec}$: 
we observe that, since $\hh_{\aexec} = \hh$, then  by \cref{prop:getview.tx} $\getView(\aexec, \T \cup \Tx(\hh, \vi)) = \vi$. 
We can now apply \cref{prop:compatible.aexec2kv} and ensure that $\RP_{\LWW}(\aexec, \T \cup \Tx(\hh, \vi)) = \{\h\}$.
Let $\aexec' = \extend(\aexec, \txid, \T \cup \Tx(\hh, \vi)), \opset)$; because $\getView(\aexec, \T \cup \Tx(\hh, \vi)) = \vi$, 
$\hh_{\aexec} = \hh$,
then by \cref{prop:extend.update.sameop} we have that $\hh_{\aexec'} = \updateKV(\hh, \vi, \txid, \opset) = \hh'$. 
We  have that $\T \cup \Tx(\hh, \vi) \subseteq \T_{\aexec}$, $\h \in \RP_{\LWW}(\aexec, \T \cup \Tx(\hh, \vi))$,
$(\thdenv(\cl), \h, \emptyset) \toL^{\ast} (\stk', \_, \opset)$ and $\txid \in \nextTxId(\T_{\aexec}, \cl)$. 
Now we can apply Rule \rl{ACommit} and infer
\[
\cl \vdash (\aexec, \thdenv(\cl)), \ptrans{\trans} \toA{(\cl, \T \cup \Tx(\hh_{\aexec}, \vi))}_{(\RP_{\LWW}, \emptyset)} 
(\aexec', \stk'), \pskip,
\]
which is exactly what we wanted to prove. 

\ac{Other cases follow by induction easily, since every rule of the kv-store semantics is 
matched by a rule in the abstract semantics.}

\mypar{Proof of Proposition \ref{prop:}}