\begin{figure}[!t]
\sx{Arrows open for discussion}
\hrule%\vspace{5pt}
%\begin{flushleft}
%The state transformers on pairs of stacks and snapshots for the primitive commands \(\trans_{p}\) (left), and the \( \funcn{op} \) for extracting the operation from the primitive commands (right):
%\end{flushleft}
\[
\begin{array}{@{} c @{\qquad} c @{}}
\begin{rclarray}
(\Stacks \times \Heaps)\!\!\! & \toLTS{\trans_p} &   (\Stacks \times \Heaps)  \vspace{5pt}\\
(\stk, \h)  & \toLTS{\passign{\var}{\expr}}          & (\stk\rmto{\var}{\evalE{\expr}}, \h)                  \\
(\stk, \h)  & \toLTS{\pderef{\var}{\expr}}           & (\stk\rmto{\var}{\h(\evalE{\expr})}, \h)              \\
(\stk, \h)  & \toLTS{\pmutate{\expr_{1}}{\expr_{2}}} & (\stk, \h\rmto{\evalE{\expr_{1}}}{\evalE{\expr_{2}}}) \\
(\stk, \h)  & \toLTS{\passume{\expr}}                & (\stk, \h) \text{ where } \evalE{\expr} \neq 0          
%(\stk, \h) & \toLTS{\preturn{\expr}}                & (\stk\rmto{\ret}{\evalE{\expr}}, \h)                 
\end{rclarray}                                                                                               
&
\begin{array}{@{} l @{}}
\funcFont{fp}: \Stacks \times \Heaps \times \trans_p \rightarrow \Ops \cup \{\emptyop\} \vspace{5pt} \\
\begin{rclarray}
\func{fp}{\stk, \h, \passign{\var}{\expr}}          & \defeq & \emptyop                                     \\
\func{fp}{\stk, \h, \pderef{\var}{\expr}}           & \defeq & (\etR, \evalE{\expr}, \h(\evalE{\expr}))     \\
\func{fp}{\stk, \h, \pmutate{\expr_{1}}{\expr_{2}}} & \defeq & (\etW, \evalE{\expr_{1}}, \evalE{\expr_{2}}) \\
\func{fp}{\stk, \h, \passume{\expr}}                & \defeq & \emptyop                                     \\
\func{fp}{\stk, \h, \preturn{\expr}}                & \defeq & \emptyop                                     
\end{rclarray}
\end{array}
\end{array}
\]

%\hrule\vspace{5pt}
%\begin{flushleft}
%The binary operator \( \opset \addO \op \) that specifies the effects of adding a new operation \( \op \) to the set \( \opset \):
%\end{flushleft}
%\[
%\begin{array}{c @{\qquad} c}
%\begin{rclarray}
%    \opset \addO (\etR, \addr, \val) & \defeq & 
%    \begin{cases}
%        \opset \uplus \Set{(\etR, \addr, \val)} & (\stub, \addr, \stub) \notin \opset \\
%        \opset &  \text{otherwise} \\
%    \end{cases} \\
%\end{rclarray}
%&
%\begin{rclarray}
%    \opset \addO (\etW, \addr, \val) & \defeq & \left( \opset \setminus \Set{(\etW, \addr, \stub)} \right) \uplus \Set{(\etW, \addr, \val)} \\
%    \opset \addO \emptyop & \defeq & \opset \\
%\end{rclarray}
%\end{array}
%\]

\hrule%\vspace{5pt}
%\begin{flushleft}
%Given the set of stacks \( \Stacks \) (\cref{def:stacks}), heaps \( \Heaps \) (\cref{def:heaps}) and transactions \( \Transactions \) (\cref{def:language}) and the arithmetic expression evaluation \( \evalE{\expr} \) (\cref{def:language}), the \emph{operational semantics of transactions}:
%\end{flushleft}
\[
\begin{rclarray}
\toL & : & ((\Stacks \times \Heaps \times \Opsets) \times \Transactions) \times ((\Stacks \times \Heaps \times \Opsets) \times \Transactions)
\end{rclarray}
\]

\begin{mathpar}
    \inferrule[\rl{TPrimitive}]{%
        (\stk, \h) \toLTS{\transpri} (\stk', \h')
        \\ \op = \func{fp}{\stk, \h, \transpri}
    }{%
        (\stk, \h, \opset) , \transpri \ \toL \  (\stk', \h', \opset \addO \op) , \pskip 
    }
    \and
    \inferrule[\rl{TChoice}]{
        i \in \Set{1,2}
    }{%
        (\stk, \h, \opset) , \trans_{1} \pchoice \trans_{2} \ \toL \  (\stk, \h, \opset) , \trans_{i}
    }
    \and
    \inferrule[\rl{TIter}]{ }{%
        (\stk, \h, \opset),  \trans\prepeat \ \toL \  (\stk, \h, \opset), \pskip \pchoice (\trans \pseq \trans\prepeat)
    } 
    \and
    \inferrule[\rl{TSeqSkip}]{ }{%
        (\stk, \h, \opset), \pskip \pseq \trans \ \toL \  (\stk, \h, \opset), \trans
    }
    \and
    \inferrule[\rl{TSeq}]{%
        (\stk, \h, \opset), \trans_{1} \ \toL \  (\stk', \h', \opset'), \trans_{1}'
    }{%
        (\stk, \h, \opset), \trans_{1} \pseq \trans_{2} \ \toL \  (\stk', \h', \opset'), \trans_{1}' \pseq \trans_{2}
    }
\end{mathpar}
\hrule
\caption{Operational semantics of transactions}
\label{fig:transaction_semantics}
\end{figure}

\begin{figure}[!t]
%\sx{drop \( \func{updateView}{\hh', \vi'', \opset} \orderVI \vi'\) and use \( \vi'' \leq \vi' \) which corresponds to monotonic read. }
\hrule
%
\[
\begin{rclarray}
	\toT{}  & : &
    \ClientID \; \times \;
	\left( ( \HisHeaps \times \Views \times \Stacks ) \times \Commands \right) 
	\; \times\; \Como \;\times \;
	\left( ( \HisHeaps \times \Views \times \Stacks ) \times \Commands \right) 
	\vspace{5pt}
\end{rclarray}
\]
\begin{mathpar}
    \inferrule[\rl{PCommit}]{%
        \vi \orderVI  \vi''
        %\\ \pred{atomic}{\vi'', \hh}
        \\ \h = \clpsHH{\hh,\vi''}
        \\ (\stk, \h, \unitO), \trans \ \toL^{*} \  (\stk', \stub,  \opset) , \pskip
        \\ \txid \in \func{nextTxid}{\hh,\cl}  
        \\\\ \hh' = \func{updateMKVS}{\hh, \vi'', \txid, \opset}  
        \\ \vi'' \leq \vi'
        %\\ \pred{atomic}{\vi', \hh'}
        %\\ \func{updateView}{\hh, \vi'', \opset} \orderVI \vi'
        \\ (\hh, \vi'') \csat \opset : \vi'
    }{%
        \cl \vdash ( \hh, \vi, \stk ), \ptrans{\trans} \ \toT{\como} \ ( \hh', \vi', \stk' ) , \pskip
    }
    \and
    \inferrule[\rl{PAssign}]{
        \val = \evalE{\expr}
    }{%
        \cl \vdash ( \hh, \vi, \stk ) , \passign{\var}{\expr} \ \toT{\como} \  ( \hh, \vi, \stk\rmto{\var}{\val} ) , \pskip
    }
    \and
    \inferrule[\rl{PAssume}]{%
        \evalE[\thstk]{\expr} \neq 0
    }{%
        \cl \vdash ( \hh, \vi, \stk ) , \passume{\expr} \ \toT{\como} \  ( \hh, \vi, \stk ) , \pskip
    }
    \and
    \inferrule[\rl{PChoice}]{
        i \in \Set{1,2}
    }{%
        \cl \vdash ( \hh, \vi, \stk ) , \cmd_{1} \pchoice \cmd_{2} \ \toT{\como} \  ( \hh, \vi, \stk ) , \cmd_{i}
    }
    \and
    \inferrule[\rl{PIter}]{ }{%
        \cl \vdash ( \hh, \vi, \stk ) , \cmd\prepeat \ \toT{\como} \  ( \hh, \vi, \stk ) , \pskip \pchoice (\cmd \pseq \cmd\prepeat)
    }
    \and
    \inferrule[\rl{PSeqSkip}]{ }{%
        \cl \vdash ( \hh, \vi, \stk ) , \pskip \pseq \cmd \ \toT{\como} \  ( \hh, \vi, \stk ) , \cmd
    }
    \and
    \inferrule[\rl{PSeq}]{% 
        \cl \vdash ( \hh, \vi, \stk ) , \cmd_{1} \ \toT{\como} \  ( \hh, \vi', \stk' ) , {\cmd_{1}}' 
    }{%
        \cl \vdash ( \hh, \vi, \stk ) , \cmd_{1} \pseq \cmd_{2} \ \toT{\como} \ ( \hh, \vi', \stk' ) , {\cmd_{1}}' \pseq \cmd_{2}
    }\vspace{5pt}
\end{mathpar}
\begin{flushleft} 
with
\quad
$
\func{nextTxid}{\hh,\cl}  \eqdef
\Setcon{ \txid^{\cl} }{ 
	\txid^{\cl} \in \TxID \land \fora{\ke, i, {\txid^{\cl}}'} {\txid^{\cl}}' = \WTx(\hh(\addr,i))  \lor {\txid^{\cl}}' \in \RTx(\hh(\addr,i)) \implies {\txid^{\cl}}' <_{\cl} \txid^{\cl} 
} 
$, 
\ac{\func{nextTxid}{\hh,\cl} is badly defined, as it does not depend on $\cl$ (the variable $\txid^{\cl}$ in the formula above is not free)}
and
\vspace{5pt}
 \end{flushleft}
%
\[
\begin{rclarray}         
%	 \func{updateKV}{., ., ., .} & : & \MKVSs \times \Views \times  \\                        
    \func{updateKV}{\hh, \vi, \txid, \unitO} & \defeq & \hh \\
    \func{updateKV}{\hh, \vi, \txid, \opset \uplus \Set{(\otR, \ke, \stub)}} & \defeq &  
    \begin{array}[t]{@{}l}
        \texttt{let } (\val, \txid', \txidset) = \hh(\ke, \vi(\ke)) \\
        \texttt{and } \hh' = \hh\rmto{\ke}{%
            \hh(\ke)\rmto{\vi(\addr)}{%
                (\val, \txid', \txidset \uplus \Set{\txid}) } } \\
        \texttt{ in } \func{updateMKVS}{\hh', \vi, \txid, \opset}
    \end{array} \\
    \func{updateMKVS}{\hh, \vi, \txid, \opset \uplus \Set{(\otW, \ke, \val)}} & \defeq &  
    \begin{array}[t]{@{}l}
        \texttt{let } \hh' = \hh\rmto{\ke}{ ( \hh(\ke) \lcat \List{(\val, \txid, \emptyset)} ) } \\
        \texttt{ in } \func{updateMKVS}{\hh', \vi, \txid, \opset}
    \end{array} 
%
\end{rclarray}
\]
\vspace{5pt}
\hrule
\[
	\toG{} : 
    ( \Confs \times \ThdEnv \times \Programs) 
    \;\times\; \Como \;\times\;
    ( \Confs \times \ThdEnv \times \Programs) 
\]
\begin{mathpar}
    \inferrule[\rl{PSingleThread}]{%
        \cl \vdash ( \mkvs, \viewFun(\thid), \thdenv(\thid) ), \prog(\thid), \ \toT{\como} \  ( \mkvs', \vi', \stk' ) , \cmd'  
    }{%
        ( (\mkvs, \viewFun), \thdenv, \prog ) \ \toG{\como} \  ( \mkvs', \viewFun\rmto{\thid}{\vi'}), \thdenv\rmto{\thid}{\stk'} , \prog\rmto{\thid}{\cmd'} ) 
    }
\end{mathpar}
%
\hrule
\caption{Operational semantics of commands (above) and programs (below)}
\label{def:thread_semantics}
\label{fig:thread_semantics}
\label{def:thread_pool_semantics}
\label{fig:thread_pool_semantics}
\label{def:program_semantics}
\label{fig:program_semantics}
\end{figure}
