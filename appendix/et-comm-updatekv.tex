\subsection{Proof of Proposition \ref{prop:updatekv.comm}}

\begin{lemma}
\label{lem:updatekv.explicit}
Let $\hh$ be a kv-store, $\vi \in \Views(\hh)$, $\txid \in \TxID$ and $\opset \in \powerset{\Ops}$. 
Let also $\ke \in \Keys$
\begin{enumerate}
\item\label{item:updatekv.explicit.none} $(\forall \val.\;(\otR, \ke, \val) \notin \opset \wedge (\otW, \ke, \val)) \notin \opset \implies \updateKV(\hh, \vi, \txid, \opset)(\ke) = \hh(\ke)$, 
\item\label{item:updatekv.explicit.rd} $(\otR, \ke, \_) \in \opset \wedge \forall \val.\;( (\otW, \ke, \val) \notin \opset) \implies \updateKV(\hh, \vi, \txid, \opset)(\ke) = 
\text{ let } (\val', \txid', \T') = \hh(\ke, \vi) \text{ in } \hh(\ke)\rmto{\vi(\ke)}{(\val', \txid', \T' \cup \{\txid\})}$, 
\item\label{item:updatekv.explicit.wr} $\forall \val.\; (\forall \val'.\;(\otR, \ke, \val) \notin \opset) \wedge (\otW, \ke, \val) \in \opset \implies \updateKV(\hh, \vi, \txid, \opset)(\ke) = 
\hh(\ke) \lcat \List{(\val, \txid, \emptyset)}$, 
\item\label{item:updatekv.explicit.rdwr} $\forall \val.\;(\otR, \ke, \_) \in \opset \wedge (\otW, \ke, \val) \in \opset \implies \updateKV(\hh,\vi,\txid,\opset)(\ke) = 
\mathtt{ let } (\val', \txid', \T') = \hh(\ke, \vi) \in \hh(\ke)\rmto{\vi(\ke)}{(\val', \txid', \T' \cup \{\txid\})} \lcat \List{(\val, \txid, \emptyset)}.$
\end{enumerate}
\end{lemma}

\begin{proof}
All the four statements are proved by induction on $\opset$, by keeping the variable $\hh$ universally quantified in the inductive hypothesis. 
Statement \eqref{item:updatekv.explicit.rd} and \eqref{item:updatekv.explicit.wr} requires 
proving \eqref{item:updatekv.explicit.none} first, while Statement \eqref{item:updatekv.explicit.rdwr} requires proving all the other statements. 
Fix then an arbitrary $\ke \in \Keys$.
\begin{enumerate}
	\item 
	Suppose that for any $\val$, $(\otR, \ke, \val) \notin \opset$ and $(\otW, \ke, \val)) \notin \opset$. We prove that $\updateKV(\hh, \vi, \txid, \opset)(\ke) = 
	\hh(\ke)$.
	\begin{itemize}
		\item Base case: $\opset = \emptyset$; in this case we have that 
		\[
		\updateKV(\hh, \vi, \txid, \emptyset)(\ke) \stackrel{\eqref{eq:updatekv}}{=} \hh(\ke).
		\]
		
		\item Suppose that $\opset = \opset' \uplus \{(\otR, \ke', \val')\}$ for some $\ke', \val'$. Because we are assuming that 
		$(\otR, \ke, \val) \notin \opset$ for any $\val \in \Val$, then it must be the case that 
		\begin{equation}
		\label{eq:updatekv.explicit.none.keneqkepRD}
		\ke \neq \ke'.
		\end{equation}
		Also, we have that $(\otR,\ke, \val) \notin \opset'$ and $(\otW, \ke, \val) \notin \opset$ for any $\val \in \Val$. 
		By inductive hypothesis we can assume 
		\begin{equation}
		\forall \hh'.\;\updateKV(\hh', \vi, \txid, \opset')(\ke) = \hh'(\ke).
		\label{eq:updatekv.explicit.none.IHrd}
		\end{equation} 
		Therefore we have 
		\[
		\begin{array}{lr}
		\updateKV(\hh, \vi, \txid, \opset)(\ke) = \updateKV(\hh, \vi, \txid, \opset' \uplus \{(\otR, \ke', \val')\})(\ke) &\stackrel{\eqref{eq:updatekv}}{=}\\
		\text{let } (\val', \txid', \T') = \hh(\ke', \vi) \text{ in } \updateKV(\hh\rmto{\ke'}{\hh(\ke')\rmto{\vi(\ke')}{(\val', \txid', \T' \cup \{\txid\})}}, \vi, \txid, \opset')(\ke) &			\stackrel{\eqref{eq:updatekv.explicit.none.IHrd}}{=}\\
		\text{let } (\val', \txid', \T') = \hh(\ke', \vi) \text{ in } \hh\rmto{\ke'}{\hh(\ke')\rmto{\vi(\ke')}{(\val', \txid', \T' \{\txid\}}}(\ke) &\stackrel{\eqref{eq:updatekv.explicit.none.keneqkepRD}}{=}\\
		\big( \text{let } (\val', \txid', \T') = \hh(\ke', \vi) \text{ in } \hh(\ke) \big) = \hh(\ke)
		\end{array}
		\]
		
		\item Suppose that $\opset = \opset' \uplus \{(\otW, \ke', \val')\}$ for some $\val' \in \Val$. Then it must be the 
		case that 
		\begin{equation}
		\label{eq:updatekv.explicit.none.keneqkepWR}
		\ke \neq \ke'.
		\end{equation}
		Also, we have that $(\otR,\ke, \val) \notin \opset'$ and $(\otW, \ke, \val) \notin \opset$ for any $\val \in \Val$. 
		By inductive hypothesis we can assume 
		\begin{equation}
		\forall \hh'.\;\updateKV(\hh', \vi, \txid, \opset')(\ke) = \hh'(\ke).
		\label{eq:updatekv.explicit.none.IHwr}
		\end{equation}
		Therefore we have 
		\[
		\begin{array}{lr}
		\updateKV(\hh, \ke, \txid, \opset)(\ke) = \updateKV(\hh, \ke, \txid, \opset \uplus \{(\otW, \ke', \val')\})(\ke) &\stackrel{\eqref{eq:updatekv}}{=}\\
		\updateKV(\hh\rmto{\ke'}{\hh(\ke')\lcat \List{(\val', \txid, \emptyset)}}, vi, \txid,\opset)(\ke) &\stackrel{\eqref{eq:updatekv.explicit.none.IHwr}}{=}\\
		\hh\rmto{\ke'}{\hh(\ke') \lcat \List{(\val', \txid, \emptyset)}}, \vi, \txid, \opset)(\ke) & \stackrel{\eqref{eq:updatekv.explicit.none.keneqkepWR}}{=}\\
		\hh(\ke)
		\end{array}
		\]
	\end{itemize}

	\item Suppose now that, $(\otR, \ke, \_) \in \opset$, and $(\otW, \ke, \val) \notin \opset$ for all $\val \in \Val$. 
	Let $(\val, \txid', \T) = \hh(\ke, \vi)$. We prove that $\updateKV(\hh, \vi, \txid, \opset)(\ke) = 
	\hh(\ke)\rmto{\vi(\ke)}{(\val, \txid', \T \cup \{\txid\})}$.
		\begin{itemize}
		\item Base case: $\opset = \emptyset$; this case is vacuous, as $(\otR, \ke, \val) \notin \opset$ for all $\val \in \Val$, 
		against the assumption that $(\otR, \ke, \_)$. 

		\item Suppose that $\opset = \opset' \cup \{(\otR, \ke', \_)\}$ for some $\ke'$. We have two possible cases: 
			\begin{enumerate}
			\item $\ke = \ke'$, in which case we know that $(\otR, \ke, \val') \notin \opset'$ for all $\val' \in \Val$ because of 
			the assumptions that we make on the structure of $\opset$. Thus we have that 
			\begin{equation}
			\forall \hh'.\; \updateKV(\hh', \vi, \txid, \opset')(\ke) = \hh'(\ke).
			\label{eq:updatekv.explicit.rd.applynone}
			\end{equation}
			In this case we have that 
			\[
			\begin{array}{lr}
			\updateKV(\hh, \vi, \txid, \opset)(\ke) = \updateKV(\hh,\vi, \txid, \opset' \uplus \{(\otR, \ke, \val')\})(\ke) &\stackrel{\eqref{eq:updatekv}}{=}\\
			\updateKV(\hh\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{(\val, \txid', \T \cup \{\txid\})}}, \vi, \txid, \opset')(\ke) &\stackrel{\eqref{eq:updatekv.explicit.rd.applynone}}{=} \\
			\hh\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{(\val, \txid', \T \cup \{\txid\})}}(\ke) &=\\ 
			\hh(\ke)\rmto{\vi(\ke)}{(\val, \txid', \T \cup \{\txid\})}.
			\end{array}
			\]

			\item \begin{equation}
			\ke \neq \ke'.
			\label{eq:updatekv.explicit.rd.keneqkepRD}
			\end{equation} 
			In this case we know that because $(\otR, \ke, \_) \in \opset$, then 
			it must be $(\otR, \ke, \_) \in \opset'$. We also know that $\forall \val.(\otW, \ke, \val) \notin \opset$. 
			By the inductive hypothesis, we have that 
			\begin{equation}
			\label{eq:updatekv.explicit.rd.IHrd}
			\forall \hh'.\; \updateKV(\hh', \vi, \txid, \opset')(\ke) = \hh'(\ke)\rmto{\vi(\ke)}{(\val, \txid', \T \cup \{(\txid)\})}.
			\end{equation}
			In this case we have 
			\[
			\begin{array}{lr}
			\updateKV(\hh, \vi, \txid, \opset)(\ke) = \updateKV(\hh, \vi, \txid, \opset' \uplus \{(\otR, \ke', \_)\})(\ke) &\stackrel{\eqref{eq:updatekv}}{=}\\
			\text{let } (\val'', \txid'', \T'') = \hh(\ke', \vi) \text{ in } \updateKV(\hh\rmto{\ke'}{\hh(\ke')\rmto{\vi(\ke')}{(\val'', \txid'', \T'' \cup \{\txid\})}}, \vi, \txid, \opset)(\ke) 			&
			\stackrel{\eqref{eq:updatekv.explicit.rd.IHrd}}{=} \\
			\text{let } (\val'', \txid'', \T'') = \hh(\ke', \vi) \text{ in } &\\
			\big(\hh\rmto{\ke'}{(\hh(\ke')\rmto{\vi(\ke')}{(\val'', \txid'', \T'' \cup \{\txid\})}}(\ke)\big) 
			\rmto{\vi(\ke)}{(\val, \txid', \T' \cup \{(\txid)\})} &\stackrel{\eqref{eq:updatekv.explicit.rd.keneqkepRD}}{=}\\
			\hh(\ke)\rmto{\vi(\ke)}{(\val, \txid', \T' \cup \{(\txid)\}}
			\end{array}
			\]
		\end{enumerate}

		\item $\opset = \opset' \uplus \{(\otW, \ke', \val')\}$ for some $\val' \in \Val$. Because $(\otW, \ke, \val) \notin \opset$ 
		for any $\val \in \Val$, it must be the case that 
		\begin{equation}
		\ke \neq \ke'
		\label{eq:updatekv.explicit.rd.keneqkepWR}
		\end{equation}
		Because $(\otR, \ke, \_) \in \opset$, it must also be the case that $(\otR, \ke, \_) \in \opset'$. By the inductive hypothesis, 
		we have that 
		\begin{equation}
		\forall \hh'.\;\updateKV(\hh', \vi,\txid, \opset')(\ke) = \hh(\ke)\rmto{\vi(\ke)}{(\val, \txid', \T \cup \{(\txid)\})}
		\label{eq:updatekv.explicit.rd.IHwr}
		\end{equation}
		It follows that 
		\[
		\begin{array}{lr}
		\updateKV(\hh, \vi, \txid, \opset)(\ke) = \updateKV(\hh, \vi, \txid, \opset' \uplus \{(\otW, \ke', \val')\})(\ke) &\stackrel{\eqref{eq:updatekv}}{=}\\
		\updateKV(\hh\rmto{\ke'}{\hh(\ke') \lcat \List{(\val', \txid, \emptyset)}}, \vi, \txid, \opset')(\ke) &\stackrel{\eqref{eq:updatekv.explicit.rd.IHwr}}{=}\\
		\hh(\rmto{\ke'}{\hh(\ke') \lcat \List{(\val', \txid, \emptyset)}}(\ke)\rmto{\vi(\ke)}{(\val, \txid', \T \cup \{\txid\})} &
		\stackrel{\eqref{eq:updatekv.explicit.rd.keneqkepWR}}{=}\\
		\hh(\ke)\rmto{\vi(\ke)}{(\val, \txid', \T \cup \{\txid\})}
		\end{array}
		\]
	\end{itemize}
	
	\item Suppose that $(\otW, \ke, \val) \in \opset$ for some $\val \in \Val$, and 
	$(\otR, \ke, \val') \notin \opset$ for any $\val' \in \Val$. We prove that 
	$\updateKV(\hh, \vi, \txid, \opset)(\ke) = \hh(\ke) \lcat \List{(\val, \txid, \emptyset)}$. 
		\begin{itemize}
		\item Base case: $\opset = \emptyset$. This case is vacuous, as we are assuming 
		that $(\otW, \ke, \val) \in \opset$.
		\item Suppose that $\opset = \opset' \uplus \{(\otR, \ke', \_)\}$ for some 
		$\ke'$. Note that, because we are assuming that $\{(\otR, \ke, \val')\} \notin \opset$ 
		for all $\val' \in \Val$, then it must be the case that 
		\begin{equation}
		\ke \neq \ke'.
		\label{eq:updatekv.explicit.wr.kenqkepRD}
		\end{equation}	
		We also have that $\{(\otR, \ke, \val')\} \notin \opset'$ for all $\val' \in \Val$, and 
		$(\otW, \ke, \val) \in \opset'$. By the inductive hypothesis we have that 
		\begin{equation}
		\forall \hh'.\; \updateKV(\hh', \vi, \txid, \opset')(\ke) = \hh'(\ke) \lcat \List{(\val, \txid, \emptyset)}.
		\label{eq:updatekv.explicit.wr.IHrd}
		\end{equation}
		Therefore, we have that 
		\[
		\begin{array}{lr}
		\updateKV(\hh, \vi, \txid, \opset)(\ke) = \updateKV(\hh, \vi, \txid, \opset' \uplus \{(\otR, \ke', \_)\})(\ke) &\stackrel{\eqref{eq:updatekv}}{=}\\
		\updateKV(\hh\rmto{\ke'}{\_}, \vi ,\txid, \opset')(\ke) \stackrel{\eqref{eq:updatekv.explicit.wr.IHrd}}{=} \hh\rmto{\ke'}{\_}(\ke) \lcat \List{(\val, \txid, \emptyset)} 
		& \stackrel{\eqref{eq:updatekv.explicit.wr.kenqkepRD}}{=} \\
		\hh(\ke) \lcat \List{(\val, \txid, \emptyset)}
		\end{array}
		\]
		
		\item Suppose that $\opset = \opset' \uplus \{(\otW, \ke', \val')\}$ 
		for some $\ke'$. We distinguish two possible cases:
			\begin{enumerate}
			\item $\ke = \ke'$. In this case the structure of $\opset$ also imposes that $\val = \val'$, 
			and $(\otW, \ke, \val'') \notin \opset'$ for any $\val'' \in \Val$. Furthermore, we have 
			that $(\otR, \ke, \val'') \notin \opset'$ for any $\val'' \in \Val$. 
			By \cref{lem:updatekv.explicit}\eqref{item:updatekv.explicit.none}, we have that 
			\begin{equation}
			\forall \hh'.\updateKV(\hh', \vi, \txid, \opset')(\ke) = \hh(\ke)
			\label{eq:updatekv.explicit.wr.applynone}
			\end{equation}
			from which it follows 
			\[
			\begin{array}{lr}
			\updateKV(\hh, \vi, \txid, \opset)(\ke) = \updateKV(\hh, \vi, \txid, \opset' \uplus \{(\otW, \ke', \val')\})(\ke) &=\\ 
			\updateKV(\hh, \vi, \txid, \opset' \uplus \{(\otW, \ke, \val)\})(\ke) &\stackrel{\eqref{eq:updatekv}}{=}\\
			\updateKV(\hh\rmto{\ke \mapsto \hh(\ke) \lcat \List{(\val, \txid, \emptyset)}}, \vi, \txid, \opset')(\ke) &\stackrel{\eqref{eq:updatekv.explicit.wr.applynone}}{=}\\
			\hh\rmto{\ke}{\ke\mapsto \hh(\ke) \lcat \List{(\val, \txid, \emptyset)}}(\ke) = \hh(\ke) \lcat \List{(\val, \txid, \emptyset)}
			\end{array}
			\]
			
			\item 
			\begin{equation}
			\ke \neq \ke'
			\label{eq:updatekv.explicit.wr.keneqkepWR}
			\end{equation}
			In this case we have that, because $(\otW, \ke, \val) \in \opset$, then it must 
			be $(\otW, \ke, \val) \in \opset'$. Furthermore, we also have that $(\otR, \ke, \val'') \notin \opset'$ 
			for any $\val'' \in \Val$. By the inductive hypothesis, we have that 
			\begin{equation}
			\forall \hh'.\; \updateKV(\hh', \vi, \txid, \opset')(\ke) = \hh(\ke) \lcat \List{(\val, \txid, \emptyset)}
			\label{eq:updatekv.explicit.wr.IHwr}
			\end{equation}
			from which it follows 
			\[
			\begin{array}{lr}
			\updateKV(\hh, \vi, \txid, \opset)(\ke) = \updateKV(\hh, \vi, \txid, \opset' \uplus \{(\otW,\ke', \val')\}) &\stackrel{\eqref{eq:updatekv}}{=}\\
			\updateKV(\hh\rmto{\ke'}{\hh(\ke') \lcat \List{(\val', \txid, \emptyset)}}, \vi, \txid, \opset)(\ke) &\stackrel{\eqref{eq:updatekv.explicit.wr.IHwr}}{=}\\
			\hh\rmto{\ke'}{\_}(\ke) \lcat \List{(\val, \txid, \emptyset)} \stackrel{\eqref{eq:updatekv.explicit.wr.keneqkepWR}}{=} \hh(\ke) \lcat \List{(\val, \txid, \emptyset)}
			\end{array}
			\]
			\end{enumerate}
		\end{itemize}
		
		\item Suppose that $(\otW, \ke, \val) \in \opset$ for some $\val \in \Val$, and $(\otR, \ke, \_) \in \opset$. 
		Let $\hh(\ke, \vi) = (\val', \txid', \T')$. We prove that $\updateKV(\hh, \vi, \txid, \opset)(\ke) = 
		\hh(\ke)\rmto{\vi(\ke)}{(\val', \txid', \T' \cup \{\txid\}} \lcat \List{(\val, \txid, \emptyset)}$. 
			\begin{itemize}
			\item $\opset = \emptyset$; this case is vacuous.
			\item $\opset = \opset' \uplus \{(\otR, \ke', \_)\}$. We distinguish two cases, according to 
			whether $\ke = \ke'$ or $\ke \neq \ke'$. If $\ke = \ke'$, then we know that 
			$(\otW, \ke, \val) \in \opset'$ and $(\otR, \ke, \val'') \notin \opset$ for any $\val'' \in \Val$. 
			By Lemma \cref{lem:updatekv.explicit}\eqref{item:updatekv.explicit.wr} we have that 
			\begin{equation}
			\forall \hh'.\;\updateKV(\hh,\vi,\txid,\opset')(\ke) = \hh(\ke) \lcat \List{(\val, \txid, \emptyset)}
			\label{eq:updateKV.explicit.rdwr.applyWR}
			\end{equation}
			from which it follows that 
			\[
			\begin{array}{lr}
			\updateKV(\hh, \vi, \txid, \opset)(\ke) = \updateKV(\hh, \vi, \txid, \opset' \uplus \{(\otR, \ke', \_)\})(\ke) &=\\
			\updateKV(\hh, \vi, \txid, \opset' \uplus \{(\otR, \ke, \_)\})(\ke) &\stackrel{\eqref{eq:updateKV}}{=}\\
			\updateKV(\hh\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{(\val', \txid', \T' \cup \{\txid\}}}, \vi, \txid, \opset')(\ke) &\stackrel{\eqref{eq:updateKV.explicit.rdwr.applyWR}}{=}\\
			\hh\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{(\val', \txid', \T' \cup \{\txid\}}}(\ke) \lcat \List{(\val, \txid, \emptyset)}\\
			\hh(\ke)\rmto{\vi(\ke)}{(\val' \txid', \T' \cup \{\txid\}} \lcat \List{(\val, \txid, \emptyset)}
			\end{array}
			\]
			If $\ke \neq \ke'$, then we have that both $(\otR, \ke, \_) \in \opset'$ and 
			$(\otW, \ke, \val) \in \opset'$. In this case, by the inductive hypothesis we have that 
			\begin{equation}
			\forall \hh'.\;\updateKV(\hh,\vi,\txid,\opset')(\ke) = \hh'(\ke)\rmto{\vi(\ke)}{(\val', \txid', \T' \cup \{\txid\})} \lcat \List{(\val, \txid, \emptyset)}
			\label{eq:updatekv.explicit.rdwr.IHrd}
			\end{equation}
			from which it follows that 
			\[
			\begin{array}{lr}
			\updateKV(\hh, \vi, \txid, \opset)(\ke) = \updateKV(\hh, \vi, \txid, \opset' \uplus \{(\otR, \ke', \_)\})(\ke) &\stackrel{\eqref{eq:updatekv}}{=}\\
			\updateKV(\hh\rmto{\ke'}{\_}, \vi, \txid, \opset')(\ke) &\stackrel{\eqref{eq:updatekv.explicit.rdwr.IHrd}}{=}\\
			\hh\rmto{\ke'}{\_}(\ke)\rmto{\vi(\ke)}{(\val', \txid', \T' \cup \{\txid\})} \lcat \List{(\val, \txid, \emptyset)} &=\\
			\hh(\ke)\rmto{\vi(\ke)}{(\val', \txid', \T' \cup \{\txid\})} \lcat \List{(\val, \txid, \emptyset)}
			\end{array}
			\]
			
			\item $\opset = \opset' \uplus \{(\otW, \ke'', \val'')\}$ for some $\ke'', \val''$. Again, 
			there are two possible cases to consider. If $\ke = \ke''$, then $\val = \val''$ because of the structure imposet on $\opset$.
			Furthermore, we have that 
			$(\otR, \ke, \_) \in \opset'$ and $(\otW, \ke, \val''') \notin \opset$ for all $\val''' \in \Val$.
			By \cref{lem:updatekv.explicit}\eqref{item:updatekv.explicit.rd} we have that 
			\begin{equation}
			\forall \hh'.\;\updateKV(\hh', \vi, \txid, \opset')(\ke) = \hh'(\ke)\rmto{\vi(\ke)}{(\val', \txid', \T' \cup \{\txid\})}
			\label{eq:updatekv.explicit.rdwr.applyRD}
			\end{equation}
			We have that 
			\[
			\begin{array}{lr}
			\updateKV(\hh,\vi,\txid, \opset)(\ke) = \updateKV(\hh, \vi, \txid, \opset' \cup \{(\otW, \ke'', \val'')\})(\ke) &= \\
			\updateKV(\hh,\vi, \txid, \opset' \cup \{(\otW, \ke, \val)\})(\ke) &\stackrel{\eqref{eq:updatekv}}{=}\\
			\updateKV(\hh\rmto{\ke}{\hh(\ke) \lcat \List{(\val, \txid, \emptyset)}}, \vi, \txid, \opset')(\ke) &\stackrel{\eqref{eq:updatekv.explicit.rdwr.applyRD}}{=}\\
			\hh\rmto{\ke}{\hh(\ke) \lcat \List{(\val, \txid, \emptyset)}}(\ke)\rmto{\vi(\ke)}{(\val', \txid', \T' \cup \{\txid\})} &=\\
			(\hh(\ke) \lcat\List{(\val, \txid, \emptyset)})\rmto{\vi(\ke)}{(\val', \txid', \T' \cup \{(\txid\})} &=\\
			\hh(\ke)\rmto{\vi(\ke)}{(\val',\txid', \T' \cup \{(\txid)\})} \lcat \List{(\val, \txid, \emptyset)}
			\end{array}
			\]
			Finally, if $\ke \neq \ke'$, then we have that $(\otR, \ke, \_) \in \opset'$ and $(\otW, \ke, \val) \in \opset'$. 
			By the inductive hypothesis, we obtain 
			\begin{equation}
			\forall \hh'.\;\updateKV(\hh', \vi, \txid, \opset')(\ke) = \hh'(\ke)\rmto{\vi(\ke)}{(\val', \txid', \T' \cup \{\txid\})} \lcat \List{(\val, \txid, \emptyset)}.
			\label{eq:updatekv.explicit.rdwr.IHwr}
			\end{equation}
			It follows that 
			\[
			\begin{array}{lr}
			\updateKV(\hh, \vi, \txid, \opset)(\ke) = \updateKV(\hh, \vi, \txid, \opset' \uplus \{(\otW, \ke', \_)\}) &\stackrel{\eqref{eq:updatekv}}{=}\\
			\updateKV(\hh\rmto{\ke'}{\_}, \vi, \txid, \opset')(\ke) &\stackrel{\eqref{eq:updatekv.explicit.rdwr.IHwr}}{=}\\
			\hh\rmto{\ke'}{\_}(\ke)\rmto{\vi(\ke)}{(\val', \txid', \T' \cup \{\txid\})} \lcat \List{(\val, \txid, \emptyset)} &=\\
			\hh\rmto{\vi(\ke)}{(\val', \txid', \T' \cup \{\txid\})} \lcat \List{(\val, \txid, \emptyset)}
			\end{array}
			\]
			\end{itemize}
\end{enumerate}
\end{proof}
%\begin{lemma}
%\ac{This Lemma was wrong}
%Let $\hh \in \HisHeaps$, $\vi \in \Views(\hh)$, 
%$\txid \in \TxID$ and $\opset \in \powerset{\Ops}$. 
%Let also $\ke \in \Keys$ be such that 
%$\forall \val \in \Val.\;(\otR, \ke, \val) \notin \opset$. Then 
%for any versions $\ver$, 
%\[
%\updateKV(\hh, \vi, \txid, \opset)\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}} = 
%\updateKV(\hh\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}}, \vi, \txid, \opset)
%\] 
%\end{lemma}
%
%\begin{proof}
%By induction on $\opset$. 
%\begin{itemize}
%\item Base case: $\opset = \emptyset$. In this case we have that 
%\[
%\begin{array}{lr}
%\updateKV(\hh, \vi, \txid, \emptyset)\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}} &=\\
%\hh\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}} &\\
%&\\
%\updateKV(\hh\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}}, \vi ,\txid, \opset) &=\\
%\hh\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}}
%\end{array}
%\]
%and there is nothing left to prove.
%\item Suppose that 
%\begin{equation}
%\label{eq:opset.read.def}
%\opset = \opset' \uplus \{(\otR, \ke', \val')\}. 
%\end{equation} 
%By assumption we have that $\forall \val \in \Val.\;(\otR,\ke, \val) \notin \opset$, which implies that 
%\begin{equation}
%\label{eq:kep.neq.ke}
%\ke' \neq \ke, 
%\end{equation}
%and $\forall \val \in \Val.\; (\otR, \ke, \val) \notin \opset'$. 
%%Also, because we are assuming that $\opset$ contains at most a read operation for key $\ke'$, 
%%it must be the case that $\forall \val \in \Val.\;(\otR, \ke', \val) \notin \opset'$.
%By inductive hypothesis, we have that for any kv-store $\hh'$, then 
%\begin{equation}
%\label{eq:updatekv.rd.extract}
%\updateKV(\hh', \vi, \txid, \opset')\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}} = 
%\updateKV(\hh'\rmto{\ke}{\hh'(\ke)\rmto{\vi(\ke)}{\ver'}}, \vi, \txid, \opset').
%\end{equation}
%To prove the claim, we will need the following facts, which are trivial to prove: 
%\begin{equation}
%\label{eq:fsubst.same}
%\forall f: X \rightarrow Y.\; \forall x_1,x_2 \in X.\;\forall y \in Y. x_1 \neq x_2 \implies f\rmto{x_2}{y}(x_1) = f(x_1).
%\end{equation}
%\begin{equation}
%\label{eq:fsubst.swap}
%\forall f: X \rightarrow Y. \forall x_1, x_2 \in X.\; \forall y_1, y_2 \in Y. x_1 \neq x_2 \implies f\rmto{x_1}{y_1}\rmto{x_2}{y_2} = 
%f\rmto{x_2}{y_2}\rmto{x_1}{y_1}.
%\end{equation}
%%We then have that 
%%\[
%%\begin{array}{lr}
%%\updateKV(\hh, \vi, \txid, \opset) =
%%\mathtt{ let } (\val, \txid', \T) = \hh(\ke', \vi) \mathtt{ in } &\\  
%% \updateKV(\hh\rmto{\ke'}{\hh(\ke')\rmto{\vi(\ke')}{(\val, \txid', \T \cup \{ t \})}}, \vi, \txid, \opset') &=\\
%% & \\
%% \mathtt{ let } (\val, \txid', \T) = \hh(\ke, \vi) \mathtt{ in } &\\ 
%% \updateKV(\hh, \vi, \txid, \opset')\rmto{\ke'}{\hh(\ke')\rmto{\vi(\ke')}{(\val, \txid', \T \cup \{ t \})}}
%%\end{array}
%%\]
%%from which it follows that \
%We then have that 
%\[
%\begin{array}{lr}
%\updateKV(\hh, \vi, \txid, \opset)\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}} &\stackrel{\eqref{eq:opset.read.def}}{=}\\ 
%&\\
%\updateKV(\hh, \vi, \txid, \opset' \cup \{(\otR, \ke', \val')\})\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}} &\stackrel{\eqref{eq:updatekv}}{=}\\ 
%&\\
%\mathtt{ let } (\val, \txid', \T) = \hh(\ke', \vi) \mathtt{ in } & \\
% \updateKV(\hh\rmto{\ke'}{\hh(\ke')\rmto{\vi(\ke')}{(\val, \txid', \T \cup \{ t \})}}, \vi, \txid, \opset')\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}} &\stackrel{\eqref{eq:updatekv.rd.extract}}{=}\\
%% &\\
%% \mathtt{ let } (\val, \txid', \T) = \hh(\ke', \vi') \mathtt { in } &\\
%% \updateKV(\hh, \vi, \txid, \opset')\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}}\rmto{\ke'}{\hh(\ke')\rmto{\vi(\ke')}{(\val, \txid', \T \cup \{ t \})}} &=\\
%% &\\
%% \mathtt{ let } (\val, \txid', \T) = \hh(\ke, \vi') \mathtt{ in } &\\
%% \updateKV(\hh\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}}, \vi, \txid, \opset')\rmto{\ke'}{\hh(\ke')\rmto{\vi(\ke')}{(\val, \txid', \T \cup \{ t \})}} &=\\ 
%&\\
%\mathtt{ let } (\val, \txid', \T) = \hh(\ke', \vi) \mathtt{ in } &\\
% \updateKV(\hh\rmto{\ke'}{\hh(\ke')\rmto{\vi(\ke')}{(\val, \txid', \T \cup \{ t \})}}\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}}, \vi, \txid, \opset') &\stackrel{\eqref{eq:fsubst.swap}}{=}\\ 
%&\\
%\mathtt{ let } (\val, \txid', \T) = \hh(\ke', \vi) \mathtt{ in } &\\
% \updateKV(\hh\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}}\rmto{\ke'}{\hh(\ke')\rmto{\vi(\ke')}{(\val, \txid', \T \cup \{ t \})}}, \vi, \txid, \opset') &\stackrel{\eqref{eq:fsubst.same}}{=}\\ 
%&\\
%\mathtt{ let } (\val, \txid', \T) = \hh\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}}(\ke', \vi) \mathtt{ in } &\\
% \updateKV(\hh\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}}\rmto{\ke'}{\hh(\ke')\rmto{\vi(\ke')}{(\val, \txid', \T \cup \{ t \})}}, \vi, \txid, \opset') &\stackrel{\eqref{eq:updatekv}}{=}\\ 
%&\\ 
%\updateKV(\hh\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}}, \vi, \txid, \opset' \cup \{(\otR, \ke', \val')\} &\stackrel{\eqref{eq:opset.read.def}}{=}\\
%&\\
%\updateKV(\hh\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}}, \vi, \txid, \opset)
%\end{array}
%\]
%\item Suppose that 
%\begin{equation}
%\label{eq:opset.wr.def}
%\opset = \opset' \uplus \{(\otW, \ke', \val)\}
%\end{equation}
%Then we have that 
%\[
%\begin{array}{lr}
%\updateKV(\hh, \vi, \txid, \opset)\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}} = 
%\updateKV(\hh, \vi, \txid, \opset' \uplus \{(\otW, \ke', \val)\} &=\\
%&\\
%\updateKV(\hh\rmto{\ke}{\hh(\ke) \lcat \List{(\val, \txid, \emptyset)}}, \vi, \txid, \opset')\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}} &=\\
%&\\
%\updateKV(\hh\rmto{\ke}{\hh(\ke) \lcat \List{(\varl, \txid, \emptyset)}}\rmto{\ke}{\hh(\ke)\rmto{\vi(\ke)}{\ver}}
%\end{array}
%\]
%\end{itemize}
%\end{proof}

\begin{proposition}
Let $\hh \in \HisHeaps$, $\vi_1, \vi_2 \in \Views(\hh)$, 
$\txid_1, \txid_2 \in \TxID$. 
Let also $\opset_1, \opset_2$ be such that whenever 
$(\otW, \ke, \_) \in \opset_1$, then $(\otW, \ke, \val) \notin \opset_2$ 
for all $\val \in \Val$. Then we have that
\[
\begin{array}{l}
\mathtt{let } \hh_1 = \updateKV(\hh, \vi_1, \txid_1, \opset_1) \mathtt{ in } \updateKV(\hh_1, \vi_2, \txid_2, \opset_2) = \\
\mathtt{let } \hh_2 = \updateKV(\hh, \vi_2, \txid_2, \opset_2) \mathtt{ in } \updateKV(\hh_2, \vi_1, \txid_1, \opset_1).
\end{array}
\]
\end{proposition}

\begin{proof}
By induction on $\opset_1$. 
\begin{itemize}
\item Base case: $\opset_1 = \emptyset$. Then we have that 
\[
\begin{array}{lr}
\mathtt{let } \hh_1 = \updateKV(\hh, \vi_1, \txid_1, \emptyset) \mathtt{ in } \updateKV(\hh_1, \vi_2, \txid_2, \opset_2) &= \\
\mathtt{let } \hh_1 = \hh \mathtt{ in } \updateKV(\hh_1, \vi_2, \txid_2, \opset_2) &= \\
\updateKV(\hh, \vi_2, \txid_2, \opset_2)
\end{array}
\]
Similarly, we have that 
\[
\begin{array}{lr}
\mathtt{let } \hh_2 = \updateKV(\hh, \vi_2, \txid_2, \opset_2) \mathtt{ in } \updateKV(\hh_2, \vi_1, \txid_1, \opset_1) &=\\
\mathtt{let } \hh_2 = \updateKV(\hh, \vi_2, \txid_2, \opset_2) \mathtt{ in } \hh_2 &=\\
\updateKV(\hh, \vi_2, \txid_2, \opset_2)
\end{array}
\]
\item Let $\opset_1 = \opset_1' \uplus \{(\otR, \ke_1, \val_1)\}$, and assume that for all $\hh'$,
\begin{equation}
\label{eq:updatekv.comm.rd}
\begin{array}{l}
\mathtt{let } \hh_1' = \updateKV(\hh', \vi_1, \txid_1, \opset'_1) \mathtt{ in } \updateKV(\hh_1, \vi_2, \txid_2, \opset_2) = \\
\mathtt{let } \hh_2 = \updateKV(\hh', \vi_2, \txid_2, \opset_2) \mathtt{ in } \updateKV(\hh_2, \vi_1, \txid_1, \opset'_1).
\end{array}
\end{equation}
We perform an inner induction on the structure of $\opset_2$. 
\begin{itemize}
\item Base case: $\opset_2 = \emptyset$. 
In this case we have that 
\[
\begin{array}{l}
\mathtt{let } \hh_1 = \updateKV(\hh, \vi_1, \txid_1, \opset_1) \mathtt{ in } \updateKV(\hh_1, \vi_2, \txid_2, \emptyset) = \\
\mathtt{let } \hh_1 = \updateKV(\hh, \vi_1, \txid_1, \opset_1) \mathtt{ in } \hh_1 = \\
\updateKV(\hh, \vi_1, \txid_1, \opset_1)
\end{array}
\]
and 
\[
\begin{array}{l}
\mathtt{let } \hh_2 = \updateKV(\hh, \vi_2, \txid_2, \emptyset) \mathtt{ in } \updateKV(\hh_2, \vi_1, \txid_1, \opset_1) = \\
\mathtt{let } \hh_2 = \hh \mathtt{ in } \updateKV(\hh, \vi_1, \txid_1, \opset_1) = \\
\updateKV(\hh, \vi_1, \txid_1, \opset_1).
\end{array}
\]
There is nothing left to prove in this case.
\item Suppose that $\opset_2 = \opset_2' \uplus \{(\otR, \ke_2, \val_2)\}$.
\end{itemize}

Let $\hh_1 = \updateKV(\hh, \vi_1, \txid_1, \opset_1)$. Let also $(\val, \txid', \T) = \hh(\ke, \vi_1)$, 
and $V_{\ke} = \hh_1(\ke)$. By definition, we have that 
%\[
%\hh_1 = \updateKV(\hh\rmto{\ke}{\V_{ke}\rmto{\vi_1(\ke)}{(\val, \txid', \T \cup \{ \txid_1\}}}, \vi_1, \txid_1, \opset'_1).
%\]

\end{itemize}
\end{proof}
