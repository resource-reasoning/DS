\section{Consistency Guarantees}
\label{sec:cm}
Consistency guarantees of distributed databases describe
what it means for distributed data to be consistent. 
They have been formally described axiomatically via dependency graphs~\cite{adya-icde,adya}
and abstract execution graphs~\cite{ev_transactions,framework-concur}. 
We formalise the consistency guarantees of our centralised kv-stores by defining a 
\emph{consistency model}. 
A consistency model is a set of kv-stores capturing the possible outcomes 
obtained when multiple clients commit several transactions each, 
provided that the effects of such transactions comply with the consistency guarantees of the underlying consistency model. 
%That is, the set of such transactions are restricted to those whose effects comply with the consistency guarantees of the underlying consistency model. 
To this end, we define consistency models induced by an \emph{execution test}.
An execution test is a relation which determines whether a client may commit a transaction into a kv-store.  
We formulate several well-known consistency models over our centralised kv-stores 
by defining their corresponding execution tests. 
Later in \cref{sec:other_formalisms} we demonstrate that our definitions over centralised kv-stores are equivalent 
to their existing definitions over distributed databases.




An execution test is a set $\ET$ of tuples of the form $(\mkvs, \vi, \opset, \mkvs', \vi')$,
denoting that a client with view $\vi$ on kv-store $\hh$  may commit an atomic transaction 
with fingerprint $\opset$, and obtain an updated kv-store \( \mkvs' \) and an updated view $\vi'$. 
We often write
$\ET \vdash (\hh, \vi) \triangleright \opset: ( \mkvs', \vi')$ for
$(\mkvs, \vi, \opset, \mkvs', \vi') \in \ET$.


\begin{definition}
\label{def:execution.test}
An \emph{execution test} is a set of tuples $\ET \subseteq \HisHeaps \times \Views \times \powerset{\Ops} \times \HisHeaps \times \Views$ 
such that for all $(\hh, \vi, \opset, \mkvs', \vi') \in \ET$ and all $\ke, \val$:

\vspace*{-14pt}
{\small%
\begin{align}
    & 
	(\otR, \ke, \val) \in \opset \Rightarrow
	\hh(\ke, \max{}_{<}(\vi(\ke))) = \val  
	\tag{Ext} \label{eq:read-external} \\
    & 
    \vi(\ke) \neq \vi'(\ke) 
    \Rightarrow
    \exsts{l} (l, \ke, -) \in \opset
    \tag{ValidViewUpd} \label{eq:valid-view-update}
\end{align}%
}%
\end{definition}
\vspace*{-8pt}

%
\noindent 
The first condition enforces the last-write-wins policy~\cite{vogels:2009:ec:1435417.1435432}: 
a transaction always reads the most recent writes from the initial view.  
The second condition states that a transaction is only allowed to update the view for those keys 
that have been recorded in the fingerprint.  

Note that at this initial stage \eqref{eq:read-external} and \eqref{eq:valid-view-update} are the only required conditions and execution tests are otherwise unrestricted. 
Further restrictions on execution tests are determined by the underlying consistency model, thus prescribing the consistency guarantees of the model.

Given an execution test  $\ET$, we define the $\ET$-trace as a sequence of $\ET$-reductions on configurations that either 
\begin{enumerate*}
	\item advances the client view to a more up-to-date view; or 
	\item commits a fingerprint of a transaction. 
\end{enumerate*}

\begin{definition}[$\ET$-trace]
\label{def:reduction}
An \emph{action} $\alpha \in \Act$ is either of the form $(\cl, \varepsilon)$ or $(\cl, \opset)$, 
where $\cl$ is a client and $\opset$ is a fingerprint. 
Given an execution test $\ET$, the $\ET$-\emph{reduction relation},
$\xrightarrowtriangle{}_{\ET} \subseteq \Confs \times \Act \times \Confs$, 
is the smallest relation such that for all $\cl, \hh, \hh', \viewFun, \opset, \vi'$ and $\vi = \viewFun(\cl)$:
{\small
\begin{enumerate}
	\item
    $\vi \sqsubseteq \vi'
    \Rightarrow
    (\hh, \viewFun) \xrightarrowtriangle{\hspace{-5pt}(\cl, \varepsilon)\hspace{-5pt}}_{\ET} 
    (\hh, \viewFun\rmto{\cl}{\vi'})$; 
	\item 
    $\hh' \in \updateKV(\hh, \vi , \opset, \cl)
     \wedge (\mkvs, \vi, \opset, \mkvs', \vi') \in \ET
	$  \\
	\phantom{a} \hfill $\implies (\hh, \viewFun) \xrightarrowtriangle{\hspace{-5pt}(\cl, \opset)\hspace{-5pt}}_{\ET} (\hh', \viewFun\rmto{\cl}{\vi'})$
\end{enumerate}
}
Given an execution test $\ET$, an \emph{$\ET$-trace} is a sequence of $\ET$-reductions of the form $\conf_{0} \xrightarrowtriangle{\alpha_{0}}_{\ET} \cdots 
\xrightarrowtriangle{\alpha_{n-1}} \conf_{n}$. $\ET$-traces are ranged over by $\tau, \tau', \cdots$; 
given a $\ET$-trace $\tau$, $\lvert \tau \rvert$ denotes the number of $\ET$-reductions in $\tau$, and 
for $i=1,\cdots,n$, $\tau(i)$ denotes the $i$-th reduction of $\tau$.
\end{definition}

A \emph{consistency model} induced by $\ET$ is a set of kv-stores
resulting from $\ET$-traces starting in an 
initial configuration. 

\begin{definition}[Consistency Model]
\label{def:cm}
Given an execution test $\ET$,  
the set of \emph{configurations induced by $\ET$},  $\Confs(\ET)$, is   given by: 
\(
\Confs(\ET)\defeq 
\Setcon{ \conf}{ 
	\exsts{\conf_0 \in \Confs_0}
	\conf_0 \xrightarrowtriangle{}_{\ET}^{*} \conf
}
\).
The \emph{consistency model} induced by $\ET$ is defined as:
\( 
\CMs(\ET) \defeq \Setcon{ \hh }{ (\hh, \stub) \in \Confs(\ET) }
\)
\end{definition}


\noindent In~\cref{sec:mono-et}, we prove that consistency models are 
\emph{monotonic}: 
if  $\ET_1 \subseteq \ET_2$ then $\CMs(\ET_1) \subseteq \CMs(\ET_2)$.

\mypar{Compositionality}
We examine the \emph{compositionality} of the consistency models induced by execution tests:  
\ie given two execution tests $\ET_1, \ET_2$, does 
$\CMs(\ET_1 \cap \ET_2) = \CMs(\ET_1) \cap \CMs(\ET_2)$ hold? 
The monotonicity of execution tests guarantees that 
%It is straightforward to show that the left-to-right direction holds:
 for all $\ET_1, \ET_2$, \( \CMs(\ET_1 \cap \ET_2) \subseteq \CMs(\ET_1) \cap \CMs(\ET_2) \). 
However, the other direction \( \CMs(\ET_1) \cap \CMs(\ET_2) \subseteq \CMs(\ET_1 \cap \ET_2) \) does not hold for arbitrary consistency models.
Consider the following:
\[
\small
\begin{array}{@{}l @{\hspace{2pt}} | @{\hspace{2pt}} l@{}}
    \hline
    \ET_1 & \ET_2 \\
%    
    \hline
    (\hh_{0}, \vi_{0}) \csat\! \{(\otW, \ke, 1)\} {:} ( \hh_{\ke}, \vi_{0})
    &
    (\hh_{0}, \vi_{0}) \csat\! \{(\otW, \ke', 1)\} {:} ( \hh_{\ke'}, \vi_{0}) 
    \vspace*{-7pt}\\\\
% %   
    (\hh_{\ke}, \vi_{0}) \csat  \!\{(\otW, \ke', 1)\} {:} (\hh',\vi_{0}) 
    &
    (\hh_{\ke'}, \vi_{0}) \csat \!\{(\otW, \ke, 1)\} {:} (\hh',\vi_{1}) 
    \\
\hline
\end{array}
\]%
with%
{\small
\(
\begin{array}[t]{l@{} l}
    \hh_{\ke} & = \hh_{0}[\ke \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \_, \emptyset)] \\
    \hh_{\ke'} & = \hh_{0}[\ke' \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \_, \emptyset)] \\
    \hh' & = \hh[\ke \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \_, \emptyset) 
                ,\ke' \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \_, \emptyset)] \\
\end{array}
\)%
}%

\vspace*{3pt}
\noindent As both $\ET_1$ and $\ET_2$ allow a version with value $1$ to be written for 
$\ke, \ke'$,  we have $\hh' \in \CMs(\ET_1) \cap \CMs(\ET_2)$. 
However, $\ET_1$ and $\ET_2$ enforce a different order in which the writes on $\ke, \ke'$ must happen; 
thus $\hh' \notin \CMs(\ET_1 \cap \ET_2)$. 

In this example, compositionality fails because execution tests 
enforced a particular order in which the updates must be committed, even though such updates 
are non-conflicting: the kv-store obtained after committing such updates is independent of the commit order. This observation is captures in the following definition: 

\begin{figure*}[!t]
    \small
\begin{center}
    \begin{tabular}{ @{} l  r ||  l  r @{} }
\hline
Model & Execution Test: \((\hh, \vi) \csat \opset : (\mkvs',\vi')\) &
Model & Execution Test: \((\hh, \vi) \csat \opset : (\mkvs',\vi')\)
\\
\hline
\MRd & $\vi \viewleq \vi'$ &
\UA & $(\otW, \ke,  \stub) \in \opset \land 0 \leq i < \lvert \hh(\ke)
      \rvert \implies i \in \vi(\ke) $
\\
\MW & 
$j \in \vi(\ke) \wedge \WTx(\hh(\ke', i)) \xrightarrow{\PO^?} \WTx(\hh(\ke, j)) 
\implies i \in \vi(\ke')$ &
\PSI & $\ET_{\PSI} = \ET_{\CC} \cap \ET_{\UA}$
\\
\RYW & $ \txid \in \mkvs' \wedge \txid \notin \mkvs \land \WTx(
\mkvs'(\ke, i) ) \xrightarrow{\PO^?} \txid \implies i \in \vi'(\ke) $ &
\CP & \( \Setcon{(\mkvs, \vi, \f, \mkvs', \vi')}{\dagger} \cap \ET_\MRd \cap \ET_\RYW \) 
\\
\WFR & $j \in \vi(\ke) \wedge \txid \in \RTx(\hh(\ke', i)) \wedge \txid {\xrightarrow{\PO^?}}
\WTx(\mkvs(\ke, j))  \implies i \in \vi(\ke')$ &
$\SI$ & $\Setcon{(\mkvs, \vi, \f, \mkvs', \vi')}{\ddagger} \cap \ET_\MRd \cap \ET_\RYW  \cap \ET_\UA $
\\
\CC & $\ET_{\CC} = \ET_{\MRd} \cap \ET_{\MW} \cap \ET_{\RYW} \cap \ET_{\WFR}$ &
\SER & $ 0 \leq i < \lvert \hh(\ke) \rvert \implies i \in \vi(\ke) $\\
\hline
\end{tabular}%
\end{center}
%
%with
\vspace*{-3pt}
\[  
    \begin{rclarray}
        \dagger 
        & \eqdef &  
        \fora{\ke, \ke', i, j}
         i \in \vi(\ke)  \wedge 
         \WTx(\hh(\ke', j)) \toEdge{((\SO ; \RW_{\hh}^{?}) \cup (\WR_{\hh} ; \RW_{\hh}^{?}) \cup \WW_\hh )^{+}} \WTx(\hh(\ke, i))
        \implies j \in \vi(\ke')  \\
        \ddagger 
        & \eqdef &
        \fora{\ke, \ke', i, j}
        i \in \vi(\ke)
        \wedge \WTx(\hh(\ke', j)) \toEdge{((\SO ; \RW_{\hh}^{?}) \cup (\WR_{\hh} ; \RW_{\hh}^{?}) \cup (\WW_\hh; \RW_\hh^{?}) )^{+}} \WTx(\hh(\ke, i))
        \implies j \in \vi(\ke')    
    \end{rclarray}
\]
\vspace*{-5pt}
\[
    \begin{rclarray}
       \RF_{\hh} &\defeq& \{ (\txid, \txid') \mid \exists \ke, i.\; \txid = \WTx(\hh(\ke, i)) \wedge \txid' \in \RTx(\hh(\ke, i))\}\\
     \VO_{\hh} &\defeq& \{ (\txid, \txid') \mid \exists \ke, i, j.\; \txid = \WTx(\hh(\ke, i)) \wedge \txid' = \WTx(\hh(\ke, j)) \wedge i < j\}\\
        \AD_{\hh}&\defeq& \{ (\txid, \txid') \mid \exists \ke, i,
        j.\; \txid \in \RTx(\hh(\ke, i)) \wedge \txid' = \WTx(\hh(\ke,
        j)) \wedge i < j \land \txid \neq \txid'\}
\end{rclarray}
\]
\vspace{-2pt}
\hrule\vspace{2pt}
\captionsetup{width=\linewidth}
\caption{Execution tests of client-centric (left) and data-centric (right) consistency models, 
with $\PO$ as defined in \cref{subsec:kvstores}. 
All free variables are universally quantified.
}
\label{fig:execution.tests}
\label{fig:execution_tests}
\vspace*{-15pt}
\end{figure*}


\begin{definition}
Two fingerprints $\opset_1$ and $\opset_2$ are \emph{conflicting} 
iff there exists $\ke$ such that 
$(\otW, \ke, -) \in \opset_1 \land (\otW, \ke, -) \in \opset_2$. 
An execution test $\ET$ is \emph{commutative}, written $\com{\ET}$, if 
for all \( \mkvs, \mkvs', \viewFun, \viewFun'\), distinct clients \( \cl_1, \cl_2 \), non-conflicting fingerprints \( \opset_1, \opset_2  \) and \( \vi_1, \vi_2 \in \Views(\hh) \):%

\vspace*{-11pt}
{\small%
\[
\begin{array}{@{}r @{\hspace{10pt}} l @{}}
	\text{if} &  
	(\hh, \viewFun) \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} 
	\_ \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} (\hh', \viewFun') \\
	%& \land\ \cl_1 \ne \cl_2 \land \opset_1, \opset_2  \text{ are non-conflicting}\\
%
%	
	\text{then} & (\hh, \viewFun) \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} 
\_ \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} (\hh', \viewFun')
\end{array}
\]%
}%
\end{definition}

To guarantee the compositionality of two execution tests $\ET_1, \ET_2$, we 
require at least one of those to be commutative, say $\ET_1$. The main idea 
is the following: fix a $\ET_1$-trace $\tau_1$ and a $\ET_2$-trace $\tau_2$, both terminating in a configuration 
of the form $(\hh, \stub)$; then we construct a $(\ET_1 \cap \ET_2)$-trace terminating 
in a configuration of the same form by re-ordering he sequence of 
reductions of $\tau_1$ as to match exactly the sequence of 
reductions of $\tau_2$. 
In \cref{sec:et-comp}, we show that if $\ET_1$ is commutative, 
we can indeed re-order the sequence of reductions in the 
$\ET_1$-trace leading to a trace $\tau_1'$ such that $(\lvert \tau'_1 \rvert = \lvert \tau_2 \rvert)$\footnote{In fact, 
to ensure that $\lvert \tau_1' \rvert = \lvert \tau_2 \rvert$ we require to further manipulate 
$\tau_1$ prior to re-ordering its sequence of $\ET_1$-reductions.}, 
and for any 
$i=1,\cdots, \lvert \tau_1'\rvert$, the pre and post kv-store of $\tau_1'(i)$,
 coincide with the action, pre and post kv-store 
of $\tau_2(i)$.


Commutativity alone does not ensure that, for $i=1,\cdots,\lvert \tau_2 \rvert$ the 
pre-views and post-views of $\tau_1'(i)$ 
match the pre-views and post-views of the $\tau_2(i)$, which is necessary to show 
that $\tau_1'$ and $\tau_2$ can be recast as a $(\ET_1 \cap \ET_2)$-trace. 
In \cref{sec:et-comp} we present three other basic requirements to be 
satisfied by $\ET_1$ and $\ET_2$, that guarantee that $\tau'_1(i)$ and 
$\tau_2(i)$ agree on the pre-views and post-views for $i=1,\cdots, \lvert \tau_2 \rvert$. 
The first two of these requirements,  \emph{no blind writes} and \emph{minimum footprint}, 
ensure that the pre-views of the reductions $\tau_1'(i)$ and $\tau_2(i)$ match, 
while the third requirement, which we call \emph{monotonic post-views}, 
guarantees that the post-views of the reductions $\tau_1'(i)$ and $\tau_2(i)$ 
match. 
%
%is not sufficient to ensure the compositionality 
%of $\ET_1$ and $\ET_2$; this is because, although we ensure that 
%the re-ordered $\ET_1$-trace and the $\ET_2$ trace agree on the sequence of 
%actions they perform, as well as on the sequence of key-value stores in which 
%such actions are performed, they may still disagree on the 
%is commutative, then the actions of any $\ET_1$-trace terminating in 
%a configuration of the form $(\hh, \_)$ can be permuted so that 
%the fingerprint 
%
%Commutativity is a necessary, but not sufficient condition for recovering
%the desired compositionality result.
%To recover compositionality, we further require that an execution test have \emph{no blind writes}, 
%\emph{minimal footprint} and \emph{monotonic post-view} (\cref{def:et_properties}).
%We refer the reader to \cref{sec:counter-examples-composition} for counter examples demonstrating why these conditions are necessary.
%
%
%\begin{definition}[$\ET$ properties]
%\label{def:et_properties}
%An execution test $\ET$ has \emph{no blind writes} if
%for all $\hh, \hh', \vi, \vi', \opset, \ke$:
%\[
%\begin{array}{@{} r @{\hspace{10pt}} l @{}}
%\text{if} & \ET \vdash (\hh, \vi) \triangleright \opset: (\hh',\vi' ) 
%\text{and} (\otW, \ke, \_) \in \opset \\
%\text{then} & (\otR, \ke, \_) \in \opset
%\end{array} 
%\]
%An execution test $\ET$ has a \emph{minimum footprint} if for all kv-stores $\hh, \hh'$,
%views $\vi, \vi',\vi''$, and fingerprints $\f$: 
%%
%\[
%\begin{array}{@{} r @{\hspace{10pt}} l @{}}
%    \text{if} & \ET \vdash (\hh, \vi) \triangleright \opset : (\hh', \vi'')  \\
%    \text{and} & \fora{(\stub, \ke, \stub) \in \f} \vi(\ke) {=} \vi'(\ke) \\
%    \text{then} & \ET \vdash (\hh, \vi') \triangleright \opset : (\hh', \vi'')
%\end{array} 
%\]
%%
%An execution test $\ET$ has \emph{monotonic post-views} if 
%for all kv-stores $\hh,\hh'$, 
%views $\vi, \vi',\vi''$ and fingerprints $\f$:
%\[
%\begin{array}{@{} r @{\hspace{10pt}} l @{}}
%    \text{if} & \ET \vdash (\hh, \vi) \triangleright \opset : (\hh',\vi' )
%    \text{ and } \vi' \sqsubseteq \vi''  \\
%    \text{then} & \ET \vdash (\hh, \vi) \triangleright \opset : (\hh',\vi'')
%\end{array} 
%\]
%\end{definition}
%The first two requirements ensure that, in an $\ET$-trace 
%terminates in a configuration $(\hh, \stub)$, 
%the set of client views used to commit a transaction can uniquely determined by $\hh$. 
%If $\ET_1, \ET_2$ have monotonic post-views, then there exists at least one common post-view 
%that can be obtained after a client commits $\f$ to $(\hh, \vi)$ using $\ET_1$ and $\ET_2$. 

\begin{theorem}[Compositionality]  
\label{thm:compositional}   
For all $\ET_1, \ET_2$ with no blind writes, minimum footprints and monotonic post-views: 
if $\com{\ET_1}$, 
then $\CMs(\ET_1 \cap \ET_2) {=} \CMs(\ET_1) \cap \CMs(\ET_2)$;
if $\com{\ET_1} \land \com{\ET_2}$, then $\com{\ET_1 \cap \ET_2}$.
\end{theorem}

Most of the execution tests associated with well-known consistency models (introduced shortly)
can be tweaked to satisfy no-blind writes, minimum footprints and monotonic post-views 
without altering their semantics. However, some of these execution tests
are inherently non-commutative.
%\cref{fig:execution_tests} can be minimally adapted to satisfy these 
%properties, without excluding any anomalous (weak) behaviour. However, the definitions 
%of $\ET_{\SI}$ and $\ET_{\CP}$ are inherently non-commutative (counter example in \cref{sec:comm-counter-cp-si}), which also motivates 
%why $\ET_{\UA} \cap \ET_{\CP}$ is not an appropriate execution test for Snapshot Isolation.
%\ac{This paragraph does not make sense anymore, as we did not introduce the examples of execution tests yet. Move somewhere else.}





\subsection{Examples}\label{subsec:cm_examples}
We now give examples of execution tests in~\cref{fig:execution.tests},
where the associated consistency models for kv-stores correspond to
widely adopted consistency guaranteees for distributed databases.
Following \cite{distrprinciples}, we distinguish between
client- and data-centric consistency models: 
the former constrain the client views; 
the latter impose conditions on the structure of the kv-store.  
In \cref{fig:anomalies} we give illustrative
examples of kv-stores allowed/disallowed by our
consistency models.

\mypar{Monotonic Reads ($\MRd$)}
It states that a client cannot lose information from the view and 
hence can only see increasingly more up-to-date versions. 
This prevents \eg the kv-store of \cref{fig:mr-disallowed},
since client $\cl$ first reads the latest version of $\ke$ in $\txid_{\cl}^{1}$, 
and then reads the older, initial version of $\ke$ in $\txid_{\cl}^{2}$.  
The execution test $\ET_{\MRd}$ ensures that clients  can only extend their views. 

\mypar{Monotonic Writes ($\MW$)}
It states that whenever a transaction sees a version written by a client $\cl$,
then it sees all previous versions written by $\cl$. 
This prevents \eg the kv-store of \cref{fig:mw-disallowed}, since 
transaction $\txid'$ reads the second version of $\ke_2$, 
with value $\val_2$ written by client $\cl$, 
but it does not read, hence does not see, the second version of $\ke_1$
with value $\val_1$ and previously written by the same client.
The execution test $\ET_{\MW}$  ensures that, prior to executing a transaction,
the set of versions included in the view of the client are write 
prefix-closed with respect to the relation $\PO^?$.

\mypar{Read Your Writes (\RYW)}
It states that a client must always see the versions previously written by the client itself.
This prevents the kv-store in \cref{fig:ryw-disallowed}, 
as the initial version of $\ke$ holds value $0$ 
and client $\cl$ tries to increment the value of $\ke$ by $1$ twice.  
For its first transaction, it reads the initial value $0$ and then writes a new version with value $1$. 
For its second transaction, since the client need not see its own writes, 
it might read the initial value $0$ again and write a new version with value $1$.
The execution test $\RYW$ ensures that, after committing a transaction, 
the client view includes all the versions it wrote.  
 
\input{\RootPath/specs/anomalies-fig.tex}

\mypar{Write Follows Reads (\WFR)}
It states that, if a transaction sees a version written by a
client $\cl$, then it must also see the versions previously read by $\cl$ (in $\PO^?$ relation).
This prevents the kv-store of \cref{fig:wfr-disallowed},
since transaction $\txid$ reads a version written by $\cl$ but
not a version previously read by $\cl$.
The execution test $\ET_{\WFR}$ ensures
that a view includes all versions previously read by a client 
if the view already includes a write from that client. 


\mypar{Causal Consistency (\CC)}
The causal consistency is defined in the literature~\cite{session2causal} 
as the conjunction (composition) of the four \emph{session guarantees} \(\MRd\), \(\MW\), \(\RYW\) and \(\WFR\):   
$\CMs_{\CC} \eqdef \CMs_{\MRd} \cap \CMs_{\MW} \cap \CMs_{\RYW} \cap \CMs_{\WFR}$. 
Analogously, we have defined $\ET_\CC$ as the conjunction of the execution tests corresponding to the four session guarantees.
As we discuss in \cref{sec:other_formalisms}, we can do this thanks to the \emph{compositionality} of our execution tests:
the composition of several consistency models is equivalent to the consistency model induced by the conjunction of the corresponding execution tests. 
That is, $\CMs(\ET_\CC) = \CMs(\ET_{\MRd}) \cap \CMs(\ET_{\MW}) \cap
\CMs(\ET_{\RYW}) \cap \CMs(\ET_{\WFR}) = \CMs(\ET_{\MRd} \cap
\ET_{\MW} \cap \ET_{\RYW} \cap \ET_{\WFR})$.
As we discuss in \cref{sec:applications} and prove in \ref{sec:cops}, the COPS
implementation~\cite{cops} satisfies $\ET_{\CC}$. 

\mypar{Update Atomic ($\UA$)}
This model has been proposed in~\cite{framework-concur} 
and implemented in \cite{rola}.
%Nevertheless, many implementations meet a
%\emph{strengthening} of $\UA$.
$\UA$ disallows concurrent transactions writing to the same key,
a property known as \emph{write-write conflict freedom}, that is, 
when two transactions want to write to the same key, one must see another.
This prevents the kv-store of \cref{fig:ua-disallowed},
as $\txid, \txid'$ concurrently increment the initial version of $\ke$ by $1$.
Note that $\UA$ generalises $\RYW$: unlike $\RYW$, $\UA$ does not require $\txid, \txid'$ to be executed by the same client.
The $\ET_\UA$ ensures write-write conflict freedom by allowing a client to write to key $\ke$
only if its view includes all versions of $\ke$.

\mypar{Parallel Snapshot Isolation (\PSI)} 
The guarantees of $\PSI$ have been defined as the conjunction of the guarantees provided by $\CC$ and $\UA$~\cite{framework-concur}.
Analogously, we have defined $\ET_\PSI = \ET_\CC \cap \ET_\UA$. 
This definition exploits the \emph{compositionality} of our execution tests (\cref{thm:compositional}).
%as discussed in \cref{sec:other_formalisms}.

\mypar{(Strict) serialisability (\SER)}
Serialisability is the strongest consistency model, requiring that there exists a sequential schedule of transactions. 
The execution test $\ET_{\SER}$ thus allows clients to execute transactions only when 
their view of the kv-store store is complete.
This prevents the kv-store in  \cref{fig:ser-disallowed}: under serialisability either $\txid_1$ or $\txid_2$ commits first.
In the former case when $\txid_1$ commits first, then its write to $\ke_2$ must be included in the view of $\txid_2$, and thus $\txid_2$ should not read the outdated write to $\ke_2$ by $\txid_0$. 
The latter case is analogously prohibited. 
This example is allowed by all the other execution tests in~\cref{fig:execution_tests}.

\mypar{Consistent Prefix ($\CP$)}
\label{para:cp}
When the total order in which transactions commit is known, then 
$\CP$ is described by the following property: 
if a client sees a transaction $\txid$,
then it must also see any transaction that commits before $\txid$. 
Our configurations of kv-stores and views only provides {\em
  partial} information about the order in which transactions commit,
but this information is enough to define the consistency models we
seek. 
Consider the transaction relations $\RF_{\hh}$, $\VO_{\hh}$ and
$\AD_{\hh}$ defined in \ref{fig:execution.tests}, adapted from well-known
transaction relations associated with dependency graphs~\cite{adya-icde,adya}.
In \cite{laws} an alternative definition of $\CP$ is given: if a client sees a transaction $\txid$, 
then it must also see the subset of transactions that committed before $\txid$, that can 
be computed from $\SO, \RF_{\hh}, \VO_{\hh}, \AD_{\hh}$. This property is captured 
by $\dagger$ in \cref{fig:execution.tests}.
The pair $(\txid,\txid') \in \WR_\hh$ means that $\txid$ reads the version of some key $\ke$ 
written by $\txid'$, therefore  it {must} be
the case that $\txid$ commits before $\txid'$ starts, and therefore before $\txid'$ commits,
and similarly for $\SO$.
The pair $(\txid, \txid') \in \AD_{\hh}$ means that $\txid''$ reads one version for some key that 
is later overwritten by $\txid'$; then $\txid$ is prevented from seeing the write of $\txid'$, 
and therefore it {must} be the case that $\txid$ starts before 
$\txid'$ commits. 
As a consequence, if 
$(\txid,\txid'') \in \RF_{\hh}$ (resp. \SO) and $(\txid'',\txid') \in \AD_\hh$, then it {must} also be the case that $\txid$ commits before the commit  of $\txid'$, 
Last, if $(\txid,\txid') \in \WW_\hh$ means that $\txid'$ overwrites a version written by $\txid$ for some 
key, then it {must} be
the case that $\txid$ commits before the commit of $\txid'$.
The relation $((\SO ; \RW_{\hh}^{?}) \cup (\WR_{\hh} ; \RW_{\hh}^{?}) \cup \WW_\hh )^{+} \ni (\txid, \txid')$
captures that, {\em all} the transactions $\txid$ that {must} have already committed to the kv-store before commit of \( \txid' \).
The execution test $\ET_{\CP}$ is the intersection of $\dagger$ with $\ET_\MRd \cap \ET_\RYW$,
where the latter enforces a client sees its own commits.
For the long fork anomaly \cref{fig:cp-disallowed},
if \( \txid_{\cl_2}^2\) is the last transaction, it reads and thus sees \( \txid' \).
Given the kv-store we have:
\(
\txid \toEdge{\WR_\hh} \txid^1_{\cl_1} \toEdge{\SO} \txid^2_{\cl_1} \toEdge{\RW_\hh} \txid'
\),
which means, by \( \dagger \), transactions \( \txid_{\cl_2}^2 \) must see \( \txid \).
However, \(  \txid_{\cl_2}^2 \) reads a older version of \( \ke_1 \) than the one written by \( \txid \).
Symmetrically,
if \( \txid_{\cl_1}^2\) is the last transaction, it sees \( \txid \) and so must see \( \txid' \).

\mypar{Snapshot Isolation (\SI)}
When the total order in which transactions commit is known then 
$\SI$ can be defined compositionally from $\CP$ and $\UA$
When we can rely only on 
a partial order of transaction execution, inferred from 
kv-stores and views, then this compositional result does not 
hold\footnote{This issue arises also if dependency graphs are used in 
place of kv-stores. See \cref{sec:si-not-intersect-cp-ua}}. For example, the kv-store of \cref{fig:si-disallowed} is
included in both $\CMs(\ET_{\CP})$ and $\CMs(\ET_{\UA})$, but is
disallowed by the execution test $\ET_\SI$, introduced presently
In our definition, \( \ET_\SI \) by replacing property dagger in $\ET_{\CP}$ with 
\( \ddagger \) (\cref{fig:execution.tests}) and by intersecting the result with $\ET_{\UA}$.
Similarly as for $\CP$, the $\ddagger$ property captures the 
fact that if transaction $\txid$ sees the writes of another transaction $\txid'$, then 
it must see the subset of transactions committing before $\txid'$ that can be computed 
from $\SO, \RF_{\hh}, \VO_{\hh}, \AD_{\hh}$. However, because snapshot isolation enforces 
write-conflict freedom, the computation of this subset 
differs from the one for $\CP$. 
Under $\UA$ consequently \(\SI\), the pair $(\txid, \txid'') \in \WW_\hh$ means not only the case that $\txid$ commits 
before $\txid''$, but $\txid$ commits before $\txid''$ start. 
Because $(\txid'',\txid') \in \AD_{\hh}$ 
implies that $\txid''$ starts before $\txid'$ commits, then it must be the case that 
when $(\txid,\txid') \in \VO_{\hh} ; \AD_{\hh}$ then $\txid$ commits before $\txid'$ does. 
In \cref{fig:si-disallowed}, transaction \( \txid_4 \) reads 
the last version of \( \ke_2 \) written by \( \txid_3 \) so does not violate \( \UA \).
%Let us consider the read especially for \( \ke_2 \).
From the \( \txid_3 \) backwards we have edges:
\(
\txid_1 \toEdge{\WW_\ww} \txid_2 \toEdge{\RW_\hh} \txid_3
\).
Snapshot isolation \( \SI \) requires that if a transaction sees \( \txid_3 \) it must see \( \txid_1 \) by the \( \ddagger \) (it is not the case in \( \dagger \)).
However in \cref{fig:si-disallowed} transaction \( \txid_4 \) only see the initial version of \( ke_1 \).
As we discuss in \cref{sec:applications} and prove in the \ref{sec:clock-si}, 
the Clock-SI protocol~\cite{clocksi} satisfies $\ET_{\SI}$. 
