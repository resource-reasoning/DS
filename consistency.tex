\section{Consistency Guarantees}
\label{sec:cm}
Consistency guarantees of distributed databases describe
what it means for distributed data to be consistent. 
They have been formally described axiomatically via dependency graphs~\cite{adya-icde,adya}
and abstract execution graphs~\cite{.}. 
We formalise the consistency guarantees of our centralised kv-stores by defining a 
\emph{consistency model}. 
A consistency model is a set of kv-stores capturing the possible outcomes 
obtained when multiple clients commit several transactions each, 
provided that the effects of such transactions comply with the consistency guarantees of the underlying consistency model. 
%That is, the set of such transactions are restricted to those whose effects comply with the consistency guarantees of the underlying consistency model. 
To this end, we define consistency models induced by an \emph{execution test}.
An execution test is a relation which determines whether a client may commit a transaction into a kv-store.  
In \cref{sec:?} we formulate several well-known consistency models over our centralised kv-stores 
by defining their corresponding execution tests. 
In \cref{sec:?} we demonstrate that our definitions over centralised kv-stores are equivalent 
to their existing definitions over distributed databases.




An execution test is a set $\ET$ of tuples of the form $(\mkvs, \vi, \opset, \vi')$,
denoting that a client with view $\vi$ on kv-store $\hh$  may commit an atomic transaction 
with fingerprint $\opset$  and obtain an updated view $\vi'$. 
We often write
$\ET \vdash (\hh, \vi) \triangleright \opset: \vi'$ for
$(\mkvs, \vi, \opset, \vi') \in \ET$.


\begin{definition}
\label{def:execution.test}
An \emph{execution test} is a set of tuples $\ET \subseteq \HisHeaps \times \Views \times \powerset{\Ops} \times \HisHeaps \times \Views$ 
such that for all $(\hh, \vi, \opset, \mkvs', \vi') \in \ET$ and all $\otR, \ke, \val$:
\begin{align}
    & 
	(\otR, \ke, \val) \in \opset \Rightarrow
	\hh(\ke, \max{}_{<}(\vi(\ke))) = \val  
	\tag{Ext} \label{eq:read-external} \\
    & 
    \vi(\ke) \neq \vi'(\ke) 
    \Rightarrow
    \exsts{l} (l, \ke, -) \in \opset
    \tag{ValidViewUpd} \label{eq:valid-view-update}
\end{align}
\end{definition}
%
\noindent 
The first condition enforces the last-write-wins policy~\cite{}: 
a transaction always reads the most recent writes from the initial view.  
The second condition states that a transaction is only allowed to update the view for those keys 
that have been recorded in the fingerprint.  


\pg{I am uncomfortable about u' having a potential index to k due to a 
write in F that is not in K, but is in the updated, but  not
mentioned,  store.

\azalea{This is OK because at commit point this write will be pushed to the store. 
Plus, depending on the consistency model, there may be further constraints on the relationship between u' and K.}
}

\pg{Just thoughts. I find ValidViewUpd very confusing. I understand that if 
  views are different on k then k has to be mentioned in the 
  fingerprint. Apart from this condition, it seems as if anything can happen to the
  view. If fact, what `should' a transaction be able to do. It
  can certainly update the store in two ways: either through reading
  and hence extending a version of  the
  snapshot; or writing at the end of the store. Now what `should'
  happen to the view. At the moment pretty much anything for the ks
mentioned in F. 

\azalea{Well, execution tests by themselves are pretty unrestricted because the framework is very general and there are very few assumptions. 
Further constraints are determined by the underlying consistency model defining more ``reasonable" execution tests. How about below? }
}
Note that at this initial stage \eqref{eq:read-external} and \eqref{eq:valid-view-update} are the only required conditions and execution tests are otherwise unrestricted. 
Further restrictions on execution tests are determined by the underlying consistency model, thus prescribing the consistency guarantees of the model.

Given an execution test  $\ET$, we define the $\ET$-trace as a sequence of $\ET$-reductions on configurations that either 
\begin{enumerate*}
	\item advances the client view to a more up-to-date view; or 
	\item commits a fingerprint of a transaction. 
\end{enumerate*}

\begin{definition}[$\ET$-trace]
\label{def:reduction}
An \emph{action} $\alpha \in \Act$ is either of the form $(\cl, \varepsilon)$ or $(\cl, \opset)$, 
where $\cl$ is a client and $\opset$ is a fingerprint. 
Given an execution test $\ET$, the $\ET$-\emph{reduction relation},
$\xrightarrowtriangle{}_{\ET} \subseteq \Confs \times \Act \times \Confs$, 
is the smallest relation such that for all $\cl, \hh, \hh', \viewFun, \opset, \vi'$ and let \( \vi = \viewFun(\cl) \):
\begin{enumerate}
	\item
%    $
%    \viewFun(\cl) = \vi 
%    \wedge 
%    \vi \sqsubseteq \vi' $
    $\vi \sqsubseteq \vi'
    \Rightarrow
    (\hh, \viewFun) \xrightarrowtriangle{\hspace{-5pt}(\cl, \varepsilon)\hspace{-5pt}}_{\ET} 
    (\hh, \viewFun\rmto{\cl}{\vi'})$; 
	\item 
    $\hh' \in \updateKV(\hh, \vi , \opset, \cl)
     \wedge (\mkvs, \vi, \opset, \mkvs', \vi') \in \ET
	$  \\
	\phantom{a} \hfill $\implies (\hh, \viewFun) \xrightarrowtriangle{\hspace{-5pt}(\cl, \opset)\hspace{-5pt}}_{\ET} (\hh', \viewFun\rmto{\cl}{\vi'})$
\end{enumerate}
Given an execution test $\ET$, an \emph{$\ET$-trace} is a sequence of $\ET$-reductions of the form $\conf_{0} \xrightarrowtriangle{\alpha_{0}}_{\ET} \cdots 
\xrightarrow{\alpha_{n-1}} \conf_{n}$.
\end{definition}


\pg{In 2, how do we know that $\hh'$ and $\vi'$ are compatible?
\azalea{Again, I think this compatibility is determined by the consistency model by further restricting the ET.}}


A \emph{consistency model} induced by $\ET$ is a set of kv-stores
resulting from $\ET$-traces starting in an 
initial configuration. 

\begin{definition}[Consistency Model]
\label{def:cm}
Given an execution test $\ET$ and an initial configuration $\conf_0$ (\cref{def:configuration}),
the set of \emph{configurations induced by $\ET$},  $\Confs(\ET)$, is   given by: 
\[
\Confs(\ET)\defeq 
\Setcon{ \conf}{ 
	\exsts{\conf_0 \in \Confs_0}
	\conf_0 \xrightarrowtriangle{}_{\ET}^{*} \conf
}
\]
The \emph{consistency model} induced by $\ET$ is defined as:
\( 
\CMs(\ET) \defeq \Setcon{ \hh }{ (\hh, \stub) \in \Confs(\ET) }
\)
\end{definition}
\pg{Above  definition of $\Confs(\ET) $ seems a slightly informal definition. Layout needs attention.
\azalea{Fixed.}}


\noindent In~\cref{sec:mono-et}, we prove that consistency models are 
\emph{monotonic}: 
if  $\ET_1 \subseteq \ET_2$ then $\CMs(\ET_1) \subseteq \CMs(\ET_2)$.
In~\cref{sec:et-comm}, we also prove that  $\CMs(\ET_1 \cap \ET_2) = \CMs(\ET_1) \cap
\CMs(\ET_2)$ under certain conditions on the $\ET_i$.


\pg{Theorem  commented out below must be incorrect. I think you will
  need both  $\ET_1$ and $\ET_2$ commutative.
  \sx{It is enough that only one is commutative.
      \( \CMs(\ET_1 \cap \ET_2) \subseteq \CMs(\ET_1) \cap \CMs(\ET_2) \) is easy to see.
      \( \CMs(\ET_1) \cap \CMs(\ET_2) \subseteq  \CMs(\ET_1 \cap \ET_2) \) means to prove:
      given two traces from \( \ET_1 \) and \( \ET_2 \) respectively and assuming that they produce the same final configuration (by the intersection and the definition of \CMs),
      we need to re-order the intermediate steps of one trace, says \( \ET_1 \), so it aligns up with another trace.
      To re-order the intermediate steps, we need the commutative.
  }
  }



%\begin{definition}
%Two triples $(\cl_1, \opset_1)$ and $(\cl_2, \opset_2)$ are 
%conflicting if either $\cl_1 = \cl_2$, or there exists a key $\ke$ such that 
%$(\otW, \ke, \_) \in \opset_1, (\otW, \ke, \_) \in \opset_2$. 

%%An execution test is $\ET$ is \emph{commutative} if, whenever $(\cl_1, \vi_1, \opset_1)$, 
%$(\cl_2, \vi_2, \opset_2)$ are non-conflicting, and $\vi_1, \vi_2 \in \Views(\hh_0)$,  
%then for any $\hh_0, \hh', \viewFun, \viewFun'$ we have that 
%\[
%\begin{array}{lr}
%(\hh_0, \viewFun) \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} 
%\_ \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} (\hh', \viewFun') &\implies \\
% (\hh_0, \viewFun) \xrightarrowtriangle{(\cl_2, \opset_2)}_{\ET} 
%\_ \xrightarrowtriangle{(\cl_1, \opset_1)}_{\ET} (\hh', \viewFun')
%\end{array}
%\]
%%%%%\end{definition}

%\begin{definition}
%An execution test $\ET$ has \emph{no blind writes} if, whenever $\ET \vdash (\hh, \vi) \triangleright \opset \cup \{(\otW, \ke, \_)%\} : \vi'$, 
%then $(\otR, \ke, \_) \in \opset$.
%\end{definition}

%\begin{definition}
%An execution test $\ET$ has \emph{minimum footprints} if for any key-value store \( \hh \)
%views \( \vi, \vi',\vi''\) and fingerprint \( \f \),
%\[
%\begin{array}{@{}l@{}}
 %   ( \fora{ \ke} (\stub, \ke, \stub) \in \f \implies \vi(\ke) = \vi'(\ke) ) \land {} \\
 %   \quad \ET \vdash (\hh, \vi) \triangleright \opset : \vi'' \implies \ET \vdash (\hh, \vi') \triangleright \opset : \vi''
%\end{array}
%\]
%\end{definition}

%\begin{definition}
%An execution test $\ET$ has \emph{continuous post-views} if for any key-value store \( \hh \)
%views \( \vi, \vi',\vi''\) and fingerprint \( \f \), 
%\[
%\begin{array}{@{}l@{}}
 %   \quad \ET \vdash (\hh, \vi) \triangleright \opset : \vi' \land \vi' \sqsubseteq \vi'' \implies \ET \vdash (\hh, \vi) \triangleright \o%pset : \vi''
%\end{array}
%\]
%\end{definition}


%\begin{theorem}                                                                            
%Let $\ET_1, \ET_2$ be two execution tests has no blind writes, minimum footprints and continuous post-views.
%If $\ET_1$ is commutative, 
%then $\CMs(\ET_1 \cap \ET_2) = \CMs(\ET_1) \cap \CMs(\ET_2)$. 
%Furthermore, if $\ET_1, \ET_2$ are commutative, then $\ET_1 \cap \ET_2$ 
%is commutative.
%\end{theorem}
%\begin{proof}
  %  See \cref{sec:et-comm}.
%\end{proof}



\subsection{Examples}\label{subsec:cm_examples}

\pg{Layout of fig. 5 needs lots of attention to make it look less scary.
\azalea{Had a go at tidying it up. }}

\begin{figure*}
\begin{center}
\begin{tabular}{ l @{} r }
\hline
Consistency Model & Execution Test: \((\hh, \vi) \csat \opset : (\mkvs',\vi')\)\\
\hline
\MRd & $\vi \viewleq \vi'$\\
\MW & 
$j \in \vi(\ke) \wedge \WTx(\hh(\ke', i)) \xrightarrow{\PO^?} \WTx(\hh(\ke, j)) 
\implies i \in \vi(\ke')$
\\
\RYW & $ \txid \in \mkvs' \wedge \txid \notin \mkvs \land \WTx(
       \mkvs'(\ke, i) ) \xrightarrow{\PO^?} \txid \implies i \in \vi'(\ke) $\\
\WFR & $j \in \vi(\ke) \wedge \txid \in \RTx(\hh(\ke', i)) \wedge \txid {\xrightarrow{\PO^?}}
\WTx(\mkvs(\ke, j))  \implies i \in \vi(\ke')$\\
\CC & $\ET_{\CC} = \ET_{\MRd} \cap \ET_{\MW} \cap \ET_{\RYW} \cap \ET_{\WFR}$\\
\hline
\hline
\UA & $(\otW, \ke,  \stub) \in \opset \land 0 \leq i < \lvert \hh(\ke)
      \rvert \implies i \in \vi(\ke) $\\
\PSI & $\ET_{\PSI} = \ET_{\CC} \cap \ET_{\UA}$\\
\CP & \( \Setcon{(\mkvs, \vi, \f, \vi')}{\ddagger} \cap \ET_\MRd \cap \ET_\RYW \) \\
$\SI$ & $\Setcon{(\mkvs, \vi, \f, \vi')}{\dagger} \cap \ET_\MRd \cap \ET_\RYW  \cap \ET_\UA $\\
\SER & $ 0 \leq i < \lvert \hh(\ke) \rvert \implies i \in \vi(\ke) $\\
\hline
\end{tabular}
\end{center}
%
with
\[
        \dagger \eqdef 
        \fora{\ke, \ke', i, j}
                i \in \vi(\ke)  \wedge \WTx(\hh(\ke', j)) \toEdge{((\PO \cup \RF_{\hh} \cup \VO_{\hh}) ; \AD_{\hh}^?)^{+}} \WTx(\hh(\ke, i))
          \implies j \in \vi(\ke')    
\]
\[  \ddagger  \eqdef 
        \fora{\ke, \ke', i, j}
             i \in \vi(\ke)  \wedge \WTx(\hh(\ke', j)) \toEdge{(((\PO \cup \RF_{\hh}) ; \AD_{\hh}^?) \cup \VO_{\hh})^{+}} \WTx(\hh(\ke, i))
         \implies j \in \vi(\ke') 
\]
%
\[
    \begin{rclarray}
       \RF_{\hh} &\defeq& \{ (\txid, \txid') \mid \exists \ke, i.\; \txid = \WTx(\hh(\ke, i)) \wedge \txid' \in \RTx(\hh(\ke, i))\}\\
      \VO_{\hh} &\defeq& \{ (\txid, \txid') \mid \exists \ke, i, j.\; \txid = \WTx(\hh(\ke, i)) \wedge \txid' = \WTx(\hh(\ke, j)) \wedge i < j\}\\
        \AD_{\hh}&\defeq& \{ (\txid, \txid') \mid \exists \ke, i,
        j.\; \txid \in \RTx(\hh(\ke, i)) \wedge \txid' = \WTx(\hh(\ke,
        j)) \wedge i < j\}
%\\
 %  \PO &\defeq& \{ (t,t') \mid \exists cl, m, n. t = t^m_{cl} \wedge
  %  t' = t^n_{cl} \wedge m<n\}
\end{rclarray}
\]
\hrule\vspace{5pt}
\captionsetup{width=\linewidth}
\caption{Execution tests of client-centric (above) and data-centric (below) consistency models, 
with $\PO$ as defined in \cref{subsec:kvstores}. 
%$?$ denotes the reflexive closure of a relation.
%  and $+$ denotes the transitive closure.
All free variables are universally quantified.
}
%\pg{Have I got + correct}
\label{fig:execution.tests}
\label{fig:execution_tests}
\end{figure*}

\input{\RootPath/specs/anomalies-fig.tex}

\pg{I am using distributed databases to mean replicated or sharded
  databases. This will be made clear, once and for all, in the
  introduction and ever afterwards we just refer to distributed databases.}

We now give examples of execution tests in~\cref{fig:execution.tests},
where the associated consistency models for kv-stores correspond to
widely adopted consistency guaranteees for distributed databases.
Following \cite{distrprinciples}, we distinguish between
client- and data-centric consistency models: 
the former constrain the client views; 
the latter impose conditions on the structure of the kv-store.  
In \cref{fig:anomalies} we give illustrative
examples of kv-stores allowed/disallowed by our
consistency models.

%\pg{Below is great, got lots of information in short space. There's a bit  of
%  imprecision in the English description of the consistency
%  models, especially the first sentences. I've tried my best and have
%  left the original commented out. I'm sure you can do much
%  better. Please will somebody do this properly, unifying language as
%  much as possible so that there are not many different phrases that
%  say the same thing.}


\mypar{Monotonic Reads ($\MRd$)}
%It ensures that read operations from subsequent transactions always
%return a more up-to-date versions.
It states that a client cannot loose information from the view and 
hence read operations can only read increasingly more up-to-date versions. 
This prevents \eg the kv-store of \cref{fig:mr-disallowed},
since client $\cl$ first observes the latest version of $\ke$ in $\txid_{\cl}^{1}$, 
and then observes the older, initial version of $\ke$ in $\txid_{\cl}^{2}$.  
The execution test $\ET_{\MRd}$ ensures that clients  can only extend their views. 

\mypar{Monotonic Writes ($\MW$)}
It states that whenever a transaction observes a version installed by a client $\cl$,
then it observes all previous versions installed by $\cl$. 
This prevents \eg the kv-store of \cref{fig:mw-disallowed}, since 
transaction $\txid'$ observes the second version of $\ke_2$, 
with value $\val_2$ written by client $\cl$, 
but it does not observe the second version of $\ke_1$, 
with value $\val_1$ and previously written by the same client.
The execution test $\ET_{\MW}$  ensures that, prior to executing a transaction,
the set of versions included in the view of the client are write 
prefix-closed with respect to the relation $\PO^?$.

%\pg{I've rewritten RYW execution test to use SO?.}

\pg{Below uses $\hh'$, makes me wonder more about whether $(\hh',
  \vi') $ should be the result of the execution test?
  \sx{You are right}
  }

\mypar{Read Your Writes (\RYW)}
It states that a client must always be able to read the versions previously written by the client itself.
\pg{Is the above imprecise? It could be that the client reads a
  different version of the key as the view has moved forward? I think
  it should be about views.
  \azalea{No it is not! it says that it \emph{is able to} read, not \emph{must} read, these versions. }
  \sx{maybe at least be able to read the versions previously written by the client itself,
  OR a client must observe the versions previously written by the client itself.}
}
This prevents the kv-store in \cref{fig:ryw-disallowed}, 
as the initial version of $\ke$ holds value $0$ 
and client $\cl$ tries to increment the value of $\ke$ by $1$ twice.  
For its first transaction, it reads the initial value $0$ and then installs  a new version with value $1$. 
For its second transaction, since the client need not read its own writes, 
it might read the initial value $0$ again and install a new version with value $1$.
The execution test $\RYW$ ensures that, after committing a transaction, 
the client view includes all the versions it wrote.  

%\pg{Below, not well explained at all, I  keep thinking I'm saying
%  the same thing again and again.}
\mypar{Write Follows Reads (\WFR)}
%It states that if a client \( \cl \) writes some version $\ver$ in a transaction,
%following  another transaction (or in the same transaction of) who reads of some version $\ver'$, 
%then a transaction may observe version $\ver$ only if it also
%observes $\ver'$. 
It states that, if a transaction observes a version written by a
client $\cl$, then it must also observe the versions previously read by $\cl$ (in $\PO^?$ relation).
This prevents the kv-store of \cref{fig:wfr-disallowed},
since transaction $\txid$ observes a version written by $\cl$ but
not a version previously read by $\cl$.
% the version $\ver_2$ of $\ke_2$ carrying value $\val_2$ written by client $\cl$,
%but the same transaction $\txid$ does not observe the version of $\ke_1$ carrying value $\val_1$, read by $\cl$ prior to writing $\%ver$. 
The execution test $\ET_{\WFR}$  ensures
that a view includes all versions previously read by a client 
if the view already includes a write from that client. 

%\azalea{For \CC, the English and the definition definitely don't match and it is hard to see 
%$\ET_{\MRd} \cap \ET_{\MW} \cap \ET_{\RYW} \cap \ET_{\WFR}$ is indeed the necessary and sufficient condition for the English description. 
%Since we are short on space, I suggest we simply say:
%``The causal consistency guarantee has been defined in the literature~\cite{session2causal} as the conjunction of the four \emph{session guarantees} \MRd, \MW, \RYW\ and \WFR. 
%Analogously, we have defined $\ET_\CC$ as the intersection of the execution tests corresponding to the four session guarantees."
%\sx{Agree}
%}


\mypar{Causal Consistency (\CC)}
%Causal Consistency ensures that if a client observes a version $\ver$, 
%then it also observes the versions on which $\ver$ \emph{depends} \cite{cops} via the
%$\PO^?$  and $\RF_{\hh}$ (defined in \cref{fig:execution_tests}) relations.
%In case of $\PO^?$, this ensures that when a view includes the effects of a transaction by client $\cl$, 
%it also includes the effects of the earlier transactions (in $\PO$ order) of $\cl$. 
%In case of $\RF_{\hh}$, this ensures that when a view includes a transaction,
%it must include all writes that the transaction read from.
%
%
%\pg{Above sentence, I don't know what to write here as I don't understand what it is
%  saying.  For $    \RF_{\hh}$, it means when a view includes a transaction (the versions it write),
%it must include all the writes that the transaction read from.}
%
%A necessary and sufficient condition is to enforce the four session
%guarantees $\MRd, \MW, \RYW$ and $\WFR$ \cite{session2causal}:
%$\ET_{\CC} = \ET_{\MRd} \cap \ET_{\MW} \cap \ET_{\RYW} \cap
%\ET_{\WFR}$.
%
%
The causal consistency guarantee is defined in the literature~\cite{session2causal} as the conjunction (composition) of the four \emph{session guarantees} \MRd, \MW, \RYW\ and \WFR:   
$\CMs_{\CC} \eqdef \CMs_{\MRd} \cap \CMs_{\MW} \cap \CMs_{\RYW} \cap \CMs_{\WFR}$. 
Analogously, we have defined $\ET_\CC$ as the conjunction (composition) of the execution tests corresponding to the four session guarantees.
As we discuss in \cref{sec:other_formalisms}, we can do this thanks to the \emph{compositionality} of our execution tests:
the composition of several consistency models is equivalent to the consistency model induced by the composition (intersection) of the corresponding execution tests. 
That is, $\CMs(\ET_\CC) = \CMs(\ET_{\MRd}) \cap \CMs(\ET_{\MW}) \cap \CMs(\ET_{\RYW}) \cap \CMs(\ET_{\WFR}) = \CMs(\ET_{\MRd} \cap \ET_{\MW} \cap \ET_{\RYW} \cap \ET_{\WFR})$.
Later in \cref{sec:applications} we show that the COPS implementation~\cite{cops} is causally consistent in that it satisfies the $\CC$ guarantees. 

\pg{Above, we should mention that in Section~\ref{.} we show that the
  COPS implementation is CC.
 \azalea{Done.} 
}
  

\mypar{Update Atomic ($\UA$)}
This model has been proposed in~\cite{framework-concur};
however we are not aware of an implementation that exactly meets  this model.
Nevertheless, many implementations meet a
\emph{strengthening} of $\UA$.
$\UA$ disallows concurrent transactions writing to the same key,
a property known as \emph{write-write conflict freedom}.
This prevents the kv-store of \cref{fig:ua-disallowed},
as $\txid, \txid'$ concurrently increment the initial version of $\ke$ by $1$.
Note that $\UA$ generalises $\RYW$: unlike $\RYW$, $\UA$ does not require $\txid, \txid'$ to be executed by the same client.
%The  $\ET_\UA$ execution test allows a client to write to key $\ke$
%only if its view includes all versions of $\ke$, including the latest. 
The  $\ET_\UA$ ensures write-write conflict freedom by allowing a client to write to key $\ke$
only if its view includes all versions of $\ke$.
\pg{Above, this last sentence seems imprecise as the view includes all
  versions of the key.
  \azalea{Sorted.} }

\mypar{Parallel Snapshot Isolation (\PSI)} 
The guarantees of $\PSI$ have been defined as the conjunction of the guarantees provided by $\CC$ and $\UA$. \todo: cite?
Analogously, we have defined $\ET_\PSI$ as the intersection of $\ET_\CC$ and $\ET_\UA$. 
Once again, this compositional definition is due to the \emph{compositionality} of our execution tests, as discussed in \cref{sec:other_formalisms}.

\pg{Above, you should mention that you show that Clock.SI satisfies
  PSI (if it does or SI below, can't remember).
  \azalea{Done.} 
  \sx{I move to \SI since it satisfies \SI }}

%\pg{Now I've totally lost it. I'm making comments to try to help you
%  explain it better.}



\mypar{(Strict) serialisability (\SER)}
Serialisability is the strongest consistency model, requiring that there exist a sequential schedule of transactions. 
The execution test $\ET_{\SER}$ thus allows clients to execute transactions only when 
their view of the kv-store store is complete.
This prevents the kv-store in  \cref{fig:ser-disallowed}: under serialisability either $\txid_1$ or $\txid_2$ commits first.
In the former case when $\txid_1$ commits first, then its write to $\ke_2$ must be included in the view of $\txid_2$, and thus $\txid_2$ should not read the outdated write to $\ke_2$ by $\txid_0$. 
The latter case is analogously prohibited. 
This example is allowed by all the other execution tests in~\cref{fig:execution_tests}.


\azalea{
I have cleaned up the figures and the English of all models except for the last two, $\CP$ and $\SI$. 
As evidenced by  Philippa's comments below, these require quite a bit of work.
I know that these two are basically encoding the definition from dependency graphs. 
I think it'll help if we're upfront about this. 
Here is my suggestion: 
\begin{enumerate}
	\item Add a paragraph saying that we omit the description of these two models for now and will revisit  them in the next section (when we discuss dependency graphs).
	\item In the next section, when we define dependency graphs and define $\WW$, $\WR$ and $\RW$, we can easily define their analogous definitions in our setting, namely  $\WW_\hh$, $\WR_\hh$ and $\RW_\hh$.
	\item We can then point out that our execution tests for these two models are straightforward lifting of their dependency graph definitions to our setting by translating $\WW$, $\WR$ and $\RW$ to $\WW_\hh$, $\WR_\hh$ and $\RW_\hh$.
	We can even cut out the definitions of $\CP$, $\SI$, $\dagger$, $\ddagger$, $\WW_\hh$, $\WR_\hh$ and $\RW_\hh$ from \cref{fig:execution_tests} and add them as a different figure in \cref{sec:other_formalisms}.
	\item To give an intuition of these models, we can revisit the relevant anomalies in \cref{fig:anomalies} and say why they are not allowed. 
\end{enumerate}
}


\mypar{Consistent Prefix ($\CP$)}
\label{para:cp}
In centralised databases where there is a total order in which transactions commit, 
$\CP$ is described by the following property: 
if a client observes the effects of a transaction $\txid$,
then it must also observe the effects of any transaction that commits before
$\txid$ (in the total commit order).
However, in distributed (decentralised) databases, such total commit order is not generally present. 


\pg{Above, I am confused by this sentence. In particular, with SI we
  have WW; RW, which is a write that's definitely happened before $t$.
I understand the difference between CP and SI from looking at the
relations, not from reading the English.}



\pg{Below, I don't understand this example, it does not fit with the
  figure. The figure example is also an example os something that
  doesn't fit RYW, so it is not great. I would have thought an example
  using SO; RW would have been good.}
  
In such cases, the \( \CP \) disallows different transactions to observe updates in different order (\cref{fig:cp-disallowed-1}).
In \cref{fig:cp-disallowed-1}, transactions $\txid_{3}$ and \( \txid_4 \) observes updates in different order.
That is, \( \txid_3 \) observes that the update of $\ke_2$ carrying value $\val_2$ happens before the update of $\ke_1$ carrying value $\val_2$,
yet $\txid_{4}$ observes that the update of $\ke_1$ carrying value
$\val_1$ happens before the update of $\ke_2$ carrying value
$\val_2$. 

\pg{Below, first sentence, comment earlier when you first define kv-store that this
  information is missing.}

\pg{Below paragraph, I have had a go at rewriting the explanation. I have left 
the previous explanation after that, I believe that mine is
better.  I do believe I am not quite accurate and we have to be really
careful to write the English to explain the different between CP and SI.}

\pg{I believe $\RF_{\hh} ; \AD_{\hh} \subseteq \VO_{\hh}$ so I have
  not used it below as it does not add extra writes.}

Inspired by work connecting dependency graphs and abstract execution~\cite{..}, we can formulate the CP property using kv-stores, despite not having
full information about the total order in which transactions commit.
Given key $k$ and transaction $t$ that writes to index $i$, the task
is to identify the writes that occured before $t$. The relations
$\RF_{\hh}$, $\VO_{\hh}$ and $\AD_{\hh} $ in Figure~\ref{.} and the
relation $\PO$ defined in Section~\ref{.}  can be used to identify
the direct writes that have occured before $t$. The interesting
case is the use of the $\AD_{\hh}$ relation: by itself, this relation
only identifies reads happening before writes; however, used in the
relations $\PO ;
\AD_{\hh}$, it identifies further  writes happening
before $t$. The $\dagger$ relation
\[
\WTx(\hh(\ke', j)) \toEdge{((\PO ; \AD_{\hh}? )\cup \RF_{\hh} \cup \VO_{\hh})^{+}} t
\]
identifies all the writes that occur before $t$, where $+$ is the
transitive closure. 
The execution test $\ET_{\CP}$ ensures that the initial view is 
closed with respect to this $\ddagger$  relation, and the updated view 
increases ($ \ET_\MRd $) and 
includes the writes associated with the fingerprint using the
session order ($\ET_\RYW $).

\pg{Above, presumably, with Section 5 you have proved somewhere that \[
\WTx(\hh(\ke', j)) \toEdge{((\PO ; \AD_{\hh}? )\cup \RF_{\hh} \cup \VO_{\hh})^{+}} t
\]
identifies all the writes that occur before $t$? Can you reference
this? All we know from here is that the writes happen before $t$, we
do not know that we have all of them.

We coupld perhaps justify transitivity and $\ET_{\CP}$ more. }


\pg{Do we know that the CM relation commutes with union and ;? I
  presume so and   we should say so in previous section. }

\pg{Below are my old comments when I had lost it.  I like above much
  better than below because it's explained in terms of kv-stores
  alone. Here we are justifying kv-stores, next section we are linking
  to dependency graphs and abstract execution.}

Inspired by dependency graph \cite{.....},
there are minimum observable transactions for each transaction derived from the following:
\[
    \SO  \subseteq  \VIS \qquad
    ( ( ( \SO \cup \WR ) ; \RW? )^* \cup \WW ) ; \VIS \subseteq \VIS
\]

%define earlier so not explained here, get rid of all but essential
%detail as difficult enough, people do not need to be reminded what
%composition is
%where the \( R? \) is the reflexive closure of the relation \( R \) 
%and \( R_1 ; R_2 \defeq \Setcon{(a,b)}{\exsts{c} (a,c) \in R_1 \land
%(c,b) \in R_2 } \) is the composition of the two relation.
\pg{What are the minimum observable transitions?}
Given the minimum observable transactions, we can specify $\CP$. 
\pg{Next sentence, the  English and formal relation $
  \ET_\RYW $ do not match.}
First, \( \SO \subseteq \VIS \) means a transaction observes all previous transactions from the same client,
and it is enforced by \( \ET_\RYW \).
\pg{At this point, I previously gave up.}
Then the combination of \( \ddagger\) (\cref{fig:execution-tests}) and \( \ET_\MRd \) gives us \( ( ( ( \SO \cup \WR ) ; \RW? )^* \cup \WW ) ; \VIS \subseteq \VIS \).
Let consider a client \( \cl \) and the view \( \vi \).
Assume two transactions \( \txid, \txid' \)  such that \( \txid' \) is in the view \( \vi \) and \( \txid \toEdge{( ( ( \SO \cup \WR ) ; \RW? )^* \cup \WW )} \txid' \).
If \( \txid' \) is a transaction already observable by some previous transaction from the client \( \cl \), 
the transaction \( \txid \) must be observable by that time,
therefore by the \( \ET_\MRd \), the transaction \( \txid \) is in the current view \( \vi \).
Otherwise, if \( \txid' \) is a transaction that is first time observed by the client \( \cl \),
the \( \dagger \) predicate enforces \( \txid \) is also in the view
\( \vi \).



\mypar{Snapshot Isolation (\SI)}
When the total order in which transactions commit is known,
then $\SI = \CP \cap \UA$~\cite{gsi,framework-concur}. 
This equality does not hold using kv-stores, since transactions are not totally
ordered. For example, the kv-store of \cref{fig:si-disallowed} is included in both $\CMs(\ET_{\CP})$ and $\CMs(\ET_{\UA})$, 
but is forbidden by snapshot isolation in general.
As briefly mentioned  after Definition~\ref{4.3} and proved in~\cref{sec:et-comp},  the equality \( \CMs(\ET_1
\cap \ET_2) = \CMs(\ET_1) \cap \CMs(\ET_2) \) only holds 
under certain conditions on the \( \ET_1 \) and \( \ET_2 \)\footnote{%
    This issue also arises with dependency graphs~\cite{.}, see  Section~\ref{5}.
} .


Again inspired by~\cite{.}, we can formulate the  $\SI $ property
without having full knowledge of the total order on transactions.
The additional component in the $\dagger$ relation for $\SI$, compared
with the $\ddagger$ relation of $\CP$, is the use of the relation
$\VO_{\hh}; \AD_{\hh} $....
\pg{And now I don't know what to say, because this clearly gives more
  writes than CP before $t$, so I've got the English of CP wrong. This
  needs to be subtly explained.}
The execution test $\ET_{\CP}$ ensures that the initial view is 
closed with respect to this $\dagger$  relation and 
sees all the whole history of keys associated with the fingerprint
($\ET_{\UA}$, and the updated view 
increases ($ \ET_\MRd $) and 
includes the writes associated with the fingerprint using the
session order ($\ET_\RYW $).


\pg{Below, I had previously given  up. I think the above style is
  better. Now definitely out of time.}
We are inspired by the following constraint that has been proven satisfying \( \SI \) \cite{cerone:snapshot}:
\[
    (\SO \cup \WW) \subseteq \VIS \quad  ( (\SO \cup \WW \cup \WR) ; \RW? ) ; \VIS \subseteq \VIS
\]
where write-write relation \( (\txid, \txid') \in \WW \) means the transaction \( \txid \) installs a version for a key \( \ke \) following by \( \txid' \) installing a new version for the key \( \ke \).
The constraint \( \SO \subseteq \VIS \) coincides with \( \ET_\RYW \).
The \( \WW \subseteq \VIS \) means two transactions cannot concurrently write to the same key,
which is enforced by \( \ET_\UA \).
Let consider \( ( (\SO \cup \WW \cup \WR) ; \RW? ) ; \VIS \subseteq \VIS \).
Similar to the argument we made in Consistent Prefix (\pageref{para:cp}), 
let assume a client \( \cl \), its view \( \vi \) and two transactions \( \txid, \txid' \) such that 
\( \txid' \) is in the view \( \vi \)
and \( \txid \toEdge{(\SO \cup \WW \cup \WR) ; \RW?} \txid' \).
If \( \txid' \) is observable by any previous transaction of the client \( \cl \),
then \( \txid \) is also observable before.
By \( \ET_\MRd\), it is the case \( \txid \) is in the view \( \vi \).
If \( \txid' \) is a new transaction observed by the client \( \cl \),
the \( \dagger \) enforces that \( \txid \) should be included \( \vi \).

As we discuss in \cref{sec:applications}, we show that the Clock-SI implementation~\cite{Du:2013:CSI:2553409.2553434} meets the $\SI$ guarantees. 


%\input{\RootPath/model/kvstore-view.tex}
%\input{\RootPath/model/exec-test.tex}
