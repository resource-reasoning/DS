\section{Consistency Models: Kv-stores}
\label{sec:cm}
We define what it means for a kv-store 
to be in a consistent state. Many different consistency models for
distributed transactions have 
been proposed in the literature
\cite{principle-eventual-consistency,rola,cops,redblue,PSI,clocksi},
capturing different trade-offs 
between  performance and application
correctness: examples range from  \emph{serialisability}, a strong
consistency model which only allows kv-stores 
obtained  from a serial execution of transactions
% reading the most up-to-date versions of a key 
with inevitable performance drawbacks, to  \emph{eventual consistency},  a weak consistency model
which imposes few conditions on the structure of a kv-store leading to
good performance but anomalous behaviour.
We define consistency models for our kv-stores,
by introducing the notion of 
\emph{execution tests} which specify whether a client is allowed to commit a transaction in a given 
kv-store. Each execution test induces a consistency model as the set of kv-stores obtained 
by having clients non-deterministically commit transactions so long as  the constraints 
imposed by the execution test are satisfied.
In what follows we explore a range of execution tests  associated with well-known consistency models in the literature. 
Later in \cref{sec:other_formalisms} we demonstrate that our execution test formulation of these consistency models are  equivalent to their established declarative definitions over abstract executions \cite{framework-concur} and dependency graphs \cite{adya}.


%
%
%Actually I dont't think I want any of this
%
%Examples range from \ to 


%For example, the consistency model known as 



%
%this sounds like intro/section 2 material.
%
%\emph{serialisability} which only allows kv-stores 
%obtained  from a serial execution of transactions, where transactions read the most up-to-date 
%versions of a key. Serialisability is a strong consistency model: it prevents 
%anomalous behaviours such as those 
%depicted in \cref{fig:anomalies}, discussed later in this Section. However, it has obvious performance drawbacks due to client 
%having to wait for the most up-to-date version of a key. At the other side of the spectrum, \emph{Eventual Consistency} imposes 
%few conditions on the structure of a kv-store: its implementations achieve very fast transaction processing, at the expenses 
%of allowing all the \emph{anomalies} from \cref{fig:anomalies}.

%Consistency guarantees of distributed databases describe
%what it means for distributed data to be consistent. 
%They have been formally described axiomatically via dependency graphs~\cite{adya-icde,adya}
%and abstract execution graphs~\cite{ev_transactions,framework-concur}. 
%We formalise the consistency guarantees of our centralised kv-stores by defining a 
%\emph{consistency model}. 
%A consistency model is a set of kv-stores capturing the possible outcomes 
%obtained when multiple clients commit several transactions each, 
%provided that the effects of such transactions comply with the consistency guarantees of the underlying consistency model. 
%To this end, we define consistency models induced by an \emph{execution test}.
%An execution test is a relation which determines whether a client may commit a transaction into a kv-store.  
%We formulate several well-known consistency models over our centralised kv-stores 
%by defining their corresponding execution tests. 
%Later in \cref{sec:other_formalisms} we demonstrate that our definitions over centralised kv-stores are equivalent 
%to their existing definitions over distributed databases.




%An execution test is a set $\ET$ of tuples of the form $(\mkvs, \vi, \fp, \mkvs', \vi')$,
%denoting that a client with view $\vi$ on kv-store $\mkvs$  may commit an atomic transaction 
%with fingerprint $\fp$, and obtain an updated kv-store \( \mkvs' \) and an updated view $\vi'$. 
%We often write
%$\ET \vdash (\mkvs, \vi) \csat \fp: ( \mkvs', \vi')$ for
%$(\mkvs, \vi, \fp, \mkvs', \vi') \in \ET$.

\begin{definition}
\label{def:execution.test}
%An \emph{execution test} is a set of tuples $\ET \subseteq \MKVSs \times \Views \times \Fingerprints \times \MKVSs \times \Views$ 
%such that for all $(\mkvs, \vi, \fp, \mkvs', \vi') \in \ET$, 
%$\vi \in \Views(\mkvs)$, $\vi' \in \Views(\mkvs')$, and  
%for any $\key \in
%\mkvs$ and $\val \in \Val$, if $(\otR, \key, \val) \in \fp $ then $	\mkvs(\key, \max{}_{<}(\vi(\key))) = \val   $.
An \emph{execution test} is a set of tuples $\ET \subseteq \MKVSs \times \Views \times \Fingerprints \times \MKVSs \times \Views$ 
such that for all $(\mkvs, \vi, \fp, \mkvs', \vi') \in \ET$: 
\begin{enumerate*}
	\item $\vi \in \Views(\mkvs)$ and $\vi' \in \Views(\mkvs')$; 
	\item $\cancommit \mkvs \vi \fp$; 
	\item $\vshift \mkvs \vi {\mkvs'} {\vi'}$; and 
	\item for all $\key \!\in\! \mkvs$ and $\val \!\in\! \Val$, if $(\otR, \key, \val) \!\in\! \fp $ then $	\mkvs(\key, \max{}_{<}(\vi(\key))) {=} \val   $.
\end{enumerate*}



\end{definition}
%
\noindent 
Intuitively, $(\mkvs, \vi, \fp, \mkvs', \vi') \in \ET$ means that, under the execution test $\ET$,
a client with initial view $\vi$ over a kv-store $\mkvs$ can commit a transaction with 
fingerprint $\fp$ to obtain the resulting kv-store $\mkvs'$ (\cref{def:updatekv} ) while shifting its view
to $\vi'$. We adopt the 
%more suggestive 
notation $\ET \vdash (\mkvs, \vi) \csat \fp: (\mkvs', \vi')$  to
capture this intuition. 
%The condition of 
Note that the last condition in \cref{def:execution.test} enforces the last-write-wins
policy~\cite{vogels:2009:ec:1435417.1435432}: 
a transaction always reads the most recent writes from the initial view \(\vi\).  
%The second condition states that a transaction is only allowed to update the view for those keys 
%that have been recorded in the fingerprint.  

The largest execution test is denoted by $\ET_{\top}$, where for all $\mkvs, \mkvs', \vi, \vi, \fp$: 
\[
	\cancommit[\ET_{\top}] \mkvs \vi \fp \defiff \mathsf{true}
	\qquad  \text{and} \qquad 
	\vshift[\ET_{\top}] \mkvs \vi {\mkvs'} {\vi'} \defiff \mathsf{true}
\] 
In \cref{sec:other_formalisms} we show that the consistency model induced by $\ET_{\top}$ 
corresponds to the \emph{Read Atomic} consistency model \cite{ramp}, a variant of \emph{Eventual 
Consistency} \cite{ev_transactions} for atomic transactions. 
%Later in this section we define several execution tests that induce well-known consistency models.
%%Note that at this initial stage \eqref{eq:read-external} and \eqref{eq:valid-view-update} are the only required conditions and execution tests are otherwise unrestricted. 
%%Further restrictions on execution tests are determined by the underlying consistency model, thus prescribing the consistency guarantees of the model.

We now explain how an execution test induces a consistency model. Given an execution test $\ET$, 
we define $\ET$-reductions which capture how a client $\cl$ may
interact with configurations. 
\begin{definition}[ET-reduction]
An $\ET$-reduction, $(\mkvs, \vienv) \toET{(\cl, \alpha)} (\mkvs', \vienv')$, is defined by
either 
%we define the $\ET$-trace as a sequence of $\ET$-reductions on configurations that a client
\begin{enumerate}
    \item $\alpha = \varepsilon$, $\mkvs' = \mkvs$ and $\vienv' = \vienv\rmto{\cl}{\vi}$ for some $u: \vienv(\cl) \sqsubseteq u$ ---
	client $\cl$ shifts its view to a more up-to-date one, the label $\varepsilon$ denotes that 
	%there was no interaction between the client and the kv-store; or 
	there was no access to the kv-store; or
\item $\alpha = \fp$ for some $\fp$, and $\ET \vdash (\mkvs, \vi ) \csat \fp : (\mkvs', \vi')$, where $\mkvs' \in \updateKV[\mkvs, \vi, \fp, \txid]$ 
   for some $\txid \in \nextTxid(\cl, \mkvs)$, $\vienv' =
   \vienv\rmto{\cl}{\vi'}$ ---  client $\cl$ 
	commits a transaction with fingerprint $\fp$.
\end{enumerate}
\ac{Not changing due to time constraints, but I believe the best thing to do is to change the type of execution tests to have a client identifier 
rather than $\mkvs'$, since this is determined by $\mkvs$ and $\cl$. In fact, I believe that the best we can do is to change execution tests to 
have the form $\ET \vdash (\mkvs, \vienv) {\csat}_{\cl} \fp : \vi'$; then one can lift this to a $\ET$-reduction in a style similar to monadic lifting.}
A finite sequence of $\ET$-reductions starting in an
initial configuration $\conf_{0}$ is called  an \emph{$\ET$-trace}. 
\end{definition}
Each $\ET$-trace  ends in a configuration $(\mkvs, \stub)$ where the 
kv-store $\mkvs$ is obtained as a result of several clients committing transactions under the 
execution test $\ET$. It therefore contributes to the consistency model induced by $\ET$, 
denoted as $\CMs(\ET)$.
%
%\begin{definition}[$\ET$-trace]
%\label{def:reduction}
%An \emph{action} $\alpha \in \Act$ is either of the form $(\cl, \varepsilon)$ or $(\cl, \fp)$, 
%where $\cl$ is a client and $\fp$ is a fingerprint. 
%Given an execution test $\ET$, the $\ET$-\emph{reduction relation},
%$\toET{} \subseteq \Confs \times \Act \times \Confs$, 
%is the smallest relation such that for all $\cl, \mkvs, \mkvs', \vienv, \fp, \vi', \vi''$ and $\vi = \vienv(\cl)$:
%%
%{
%\[
%\small
%\begin{array}{@{}l@{}}
%    \vi \sqsubseteq \vi'' 
%    \land \mkvs' \in \updateKV[\mkvs, \vi'', \fp, \cl]
%    \land (\mkvs, \vi'', \fp, \mkvs', \vi') \in \ET \\
%    \quad \implies
%    (\mkvs, \vienv) \toET{\hspace{-5pt}(\cl, \varepsilon)\hspace{-5pt}} 
%    (\mkvs, \vienv\rmto{\cl}{\vi''}) \toET{\hspace{-5pt}(\cl,\fp)\hspace{-5pt}} (\mkvs', \vienv\rmto{\cl}{\vi'})
%\end{array}
%\]
%}
%%
%Given an execution test $\ET$, an \emph{$\ET$-trace} is a sequence of $\ET$-reductions of the form $\conf_{0} \toET{\alpha_{0}} \cdots \toET{\alpha_{n-1}} \conf_{n}$. $\ET$-traces are ranged over by $\tau, \tau', \cdots$; 
%given a $\ET$-trace $\tau$, $\lvert \tau \rvert$ denotes the number of $\ET$-reductions in $\tau$, and 
%for $i=1,\cdots,n$, $\tau(i)$ denotes the $i$-th reduction of $\tau$.
%\end{definition}
%
%A \emph{consistency model} induced by $\ET$ is a set of kv-stores
%resulting from $\ET$-traces starting in an 
%initial configuration. 

\begin{definition}[Consistency Model]
\label{def:cm}
The \emph{consistency model} induced by an execution test $\ET$ is defined as 
\(
\CMs(\ET) \defeq 
\Set{\mkvs}[ 
\exsts{\conf_0 \in \Confs_0}
\conf_0 \toET{\stub}^{*} (\mkvs, \stub)
]
\).
%Given an execution test $\ET$,  
%the set of \emph{configurations induced by $\ET$},  $\confOf[\ET]$, is   given by: 
%\(
%\confOf[\ET] \defeq 
%\Set{\conf}[ 
%\exsts{\conf_0 \in \Confs_0}
%\conf_0 \toET{\stub}^{*} \conf
%]
%\).
%The \emph{consistency model} induced by $\ET$ is defined as:
%\( 
%\CMs(\ET) \defeq \Set{ \mkvs }[ (\mkvs, \stub) \in \confOf[\ET] ]
%\)
\end{definition}
%
%\noindent In~\cref{sec:mono-et}, we prove that consistency models are 
%\emph{monotonic}: 
%if  $\ET_1 \subseteq \ET_2$ then $\CMs(\ET_1) \subseteq \CMs(\ET_2)$.

Notice that, in the definition of $\ET$-traces, the two operations
performed by client, the view-shift and 
transaction commit, are decoupled. This is in contrast with what
happens in the operational semantics (\cref{sec:model}), 
where view-shifts and transaction commits are joined  together in a single transition of programs. 
The reason for this mismatch is best understood when looking at intended applications of 
$\ET$-traces and the operational semantics. The former are particularly useful when proving that a distributed 
protocol implements a given consistency model: in this case it is convenient to separate the operation of shifting a view from that of committing a transaction, 
as these two operations often take place separately in distributed transactional protocols. The latter is particularly useful when reasoning about transactional 
programs: treating view-shifts and transaction commits as a single transition reduces the number of interleavings in programs.
The $\ET$-traces and operational semantics are equally expressive as
the following theorem states. 
%any kv-store $\mkvs \in \CMs(\ET)$ can be obtained as a result of 
%executing some program $\prog$ under the execution test $\ET$, and vice versa.
\ac{One may wonder whether this difference in approach leads to a difference in expressive power between $\ET$-traces 
and the operational model: that is, if there exists a kv-store $\mkvs \in \CMs(\ET)$ that can never be obtained as a 
result of executing an arbitrary program $\prog$ under the execution test $\ET$. The next result shows that 
this is not the case.}
%We will prove shortly that this is 
%not the case: let us say that a $\ET$-trace  $\conf_{0} \toET{(\cl_{0}, \alpha_{0})} \cdots \toET{(\cl_{n}, \alpha_{n})} \conf_{n+1}$ is in \emph{normal form} if 
%whenever, for any $i=0, \cdots, n-1$, if $\alpha_{i} = \varepsilon$ then either $\cl_{i+1} = \cl_{i}$, and $\alpha_{i+1} = \fp$ 
%for some $\fp$. For any program $\prog$, we let $\interpr{\prog}_{\ET}$ be the set of 
%kv-stores reachable by executing $\prog$ under the execution test $\ET$.
%
%\begin{theorem}
%For any execution test $\ET$, and $\mkvs \in \CMs(\ET)$, there exists a 
%$\ET$-trace $\conf_{0} \toET{\stub}^{\ast} \conf$ in normal form such that 
%$\conf = (\mkvs, \stub)$.
%\end{theorem}

\begin{theorem}
	\label{thm:ettraces2sem}
	Let $\interpr{\prog}_{\ET}$ be the set of kv-stores reachable by executing $\prog$ under the execution test $\ET$. 
    Then for all $\ET$, $\CMs(\ET) = \bigcup_{\prog} \interpr{\prog}_{\ET}$.
	%$\CMs(\ET) = \Set{\mkvs}[\exsts{\mkvs_0, \vienv_0, \thdenv_0, \prog} (\mkvs_0, \vienv_0, \thdenv_0), \prog \toPROG{\stub}^{*} (\mkvs, \stub, \stub), \stub]$.
\end{theorem}

%\mypar{Compositionality}
%We examine the \emph{compositionality} of the consistency models induced by execution tests:  
%\ie given two execution tests $\ET_1, \ET_2$, does 
%$\CMs(\ET_1 \cap \ET_2) = \CMs(\ET_1) \cap \CMs(\ET_2)$ hold? 
%The monotonicity of execution tests guarantees that 
%%It is straightforward to show that the left-to-right direction holds:
% for all $\ET_1, \ET_2$, \( \CMs(\ET_1 \cap \ET_2) \subseteq \CMs(\ET_1) \cap \CMs(\ET_2) \). 
%However, the other direction \( \CMs(\ET_1) \cap \CMs(\ET_2) \subseteq \CMs(\ET_1 \cap \ET_2) \) does not hold for arbitrary consistency models.
%Consider the following:
%%
%\[
%\small
%\begin{array}{@{}l @{\hspace{2pt}} | @{\hspace{2pt}} l@{}}
%    \hline
%    \ET_1 & \ET_2 \\
%%    
%    \hline
%    (\mkvs_{0}, \vi_{0}) \csat\! \Set{(\otW, \key, 1)} {:} ( \mkvs_{\key}, \vi_{0})
%    &
%    (\mkvs_{0}, \vi_{0}) \csat\! \Set{(\otW, \key', 1)} {:} ( \mkvs_{\key'}, \vi_{0}) 
%    \vspace*{-7pt}\\\\
%% %   
%    (\mkvs_{\key}, \vi_{0}) \csat  \!\Set{(\otW, \key', 1)} {:} (\mkvs',\vi_{0}) 
%    &
%    (\mkvs_{\key'}, \vi_{0}) \csat \!\Set{(\otW, \key, 1)} {:} (\mkvs',\vi_{1}) 
%    \\
%\hline
%\end{array}
%\]%
%%
%with%
%%
%{
%\(
%\small
%\begin{array}[t]{l@{} l}
%    \mkvs_{\key} & = \mkvs_{0}[\key \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \_, \emptyset)] \\
%    \mkvs_{\key'} & = \mkvs_{0}[\key' \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \_, \emptyset)] \\
%    \mkvs' & = \mkvs[\key \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \_, \emptyset) 
%                ,\key' \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \_, \emptyset)] \\
%\end{array}
%\)%
%}%
%%
%
%\noindent As both $\ET_1$ and $\ET_2$ allow a version with value $1$ to be written for 
%$\key, \key'$,  we have $\mkvs' \in \CMs(\ET_1) \cap \CMs(\ET_2)$. 
%However, $\ET_1$ and $\ET_2$ enforce a different order in which the writes on $\key, \key'$ must happen; 
%thus $\mkvs' \notin \CMs(\ET_1 \cap \ET_2)$. 
%
%In this example, compositionality fails because execution tests 
%enforced a particular order in which the updates must be committed, even though such updates 
%are non-conflicting: the kv-store obtained after committing such updates is independent of the commit order. 
%This observation is captured in the following definition: 
%
\input{\RootPath/exec-table.tex}
%
%
%\begin{definition}
%\label{def:et-comm}
%Two fingerprints $\fp_1$ and $\fp_2$ are \emph{conflicting} 
%iff there exists $\key$ such that 
%$(\otW, \key, -) \in \fp_1 \land (\otW, \key, -) \in \fp_2$. 
%An execution test $\ET$ is \emph{commutative}, written $\com{\ET}$, if 
%for all \( \mkvs, \mkvs', \vienv, \vienv',\vienv''\), distinct clients \( \cl_1, \cl_2 \), non-conflicting fingerprints \( \fp_1, \fp_2  \) and \( \vi_1, \vi_2 \in \Views(\mkvs) \):% 
%%
%{%
%\[
%\small
%\begin{array}{@{}r @{\hspace{10pt}} l @{}}
%	\text{if} &  
%	(\mkvs, \vienv) \toET{(\cl_1, \fp_1)} 
%	\stub \toET{(\cl_2, \fp_2)} (\mkvs', \vienv') \\
%	\text{then} & (\mkvs, \vienv) \toET{(\cl_2, \fp_2)}
%    \stub \toET{(\cl_1, \fp_1)} (\mkvs', \vienv'') \\
%    & {} \land \vienv''(\cl_2) \viewleq \vienv'(\cl_2)
%\end{array}
%\]%
%}%
%\end{definition}
%
%To guarantee the compositionality of two execution tests $\ET_1, \ET_2$, we 
%require at least one of those to be commutative, say $\ET_1$. The main idea 
%is the following: fix a $\ET_1$-trace $\tau_1$ and a $\ET_2$-trace $\tau_2$, both terminating in a configuration 
%of the form $(\mkvs, \stub)$; then we construct a $(\ET_1 \cap \ET_2)$-trace terminating 
%in a configuration of the same form by re-ordering he sequence of 
%reductions of $\tau_1$ as to match exactly the sequence of 
%reductions of $\tau_2$. 
%In \cref{sec:et-comp}, we show that if $\ET_1$ is commutative, 
%we can indeed re-order the sequence of reductions in the 
%$\ET_1$-trace leading to a trace $\tau_1'$ such that $(\lvert \tau'_1 \rvert = \lvert \tau_2 \rvert)$\footnote{In fact, 
%to ensure that $\lvert \tau_1' \rvert = \lvert \tau_2 \rvert$ we require to further manipulate 
%$\tau_1$ prior to re-ordering its sequence of $\ET_1$-reductions.}, 
%and for any 
%$i=1,\cdots, \lvert \tau_1'\rvert$, the pre and post kv-store of $\tau_1'(i)$,
% coincide with the action, pre and post kv-store 
%of $\tau_2(i)$.
%
%
%Commutativity alone does not ensure that, for $i=1,\cdots,\lvert \tau_2 \rvert$ the 
%pre-views and post-views of $\tau_1'(i)$ 
%match the pre-views and post-views of the $\tau_2(i)$, which is necessary to show 
%that $\tau_1'$ and $\tau_2$ can be recast as a $(\ET_1 \cap \ET_2)$-trace. 
%In \cref{sec:et-comp} we present three other basic requirements to be 
%satisfied by $\ET_1$ and $\ET_2$, that guarantee that $\tau'_1(i)$ and 
%$\tau_2(i)$ agree on the pre-views and post-views for $i=1,\cdots, \lvert \tau_2 \rvert$. 
%The first two of these requirements,  \emph{no blind writes} and \emph{minimum footprint}, 
%ensure that the pre-views of the reductions $\tau_1'(i)$ and $\tau_2(i)$ match, 
%while the third requirement, which we call \emph{monotonic post-views}, 
%guarantees that the post-views of the reductions $\tau_1'(i)$ and $\tau_2(i)$ 
%match. 
% 
%\begin{theorem}[Compositionality]  
%\label{thm:compositional}   
%For all $\ET_1, \ET_2$ with no blind writes, minimum footprints and monotonic post-views: 
%if $\com{\ET_1}$, 
%then $\CMs(\ET_1 \cap \ET_2) {=} \CMs(\ET_1) \cap \CMs(\ET_2)$;
%if $\com{\ET_1} \land \com{\ET_2}$, then $\com{\ET_1 \cap \ET_2}$.
%\end{theorem}
%
%Most of the execution tests associated with well-known consistency models (introduced shortly)
%can be tweaked to satisfy no-blind writes, minimum footprints and monotonic post-views 
%without altering their semantics. However, some of these execution tests
%are inherently non-commutative.


\subsection{Example Execution Tests}
\label{subsec:cm_examples}
We give several examples of execution tests to define well-known consistency models.
Later in \cref{sec:other_formalisms} we show that our definitions  are  equivalent to existing definitions in the literature defined using abstract executions \citep{principle-eventual-consistency,framework-concur,surech-session-guarantee}.
Recall that the snapshot property and the last write wins are hard-wired into our model. 
%Consistency models that we can capture using execution tests ensure that transactions execute atomically, and that they read versions from an atomic  snapshot of the kv-store, determined using the last write wins policy. 
As such, we can only model consistency models that satisfy these two constraints. 
Although this forbids us to express interesting consistency models such as \emph{Read Committed}, we are able to express a large variety of consistency models employed by distributed kv-stores.
%
%
%We now need to say something about
%assumptions:
%\begin{itemize}
%\item atomic transactions, interleaving
%\item last write wins
%\item atomic visibility.
%\end{itemize}
%We need to describe the models we can define  and briefly the models we
%cannot define  but see conclusions for some thoughts. We also highlight a new consistency
%model that seems to sit intriguingly between ... and ... 
%
%---------------

Recall from \cref{def:execution.test} that an execution test $\ET$ includes tuples of the form $(\mkvs,\vi, \fp, \mkvs', \vi')$ such that $\vshift \mkvs \vi {\mkvs'} {\vi'}$ and $\cancommit \mkvs \vi \fp$ hold. 
%For each such tuple, the views $\vi$ and $\vi'$ identify the set 
%of versions that a client must see before and after committing a transaction 
%with fingerprint $\fp$, respectively.
%%%The purpose of
%%%such execution tests is  to constrain the views $\vi$ and $\vi'$ to
%%%those that make sense for a particular consistency model. 
%We study 
%two styles of execution test: those that constrain the resulting view
%$\vi'$ relative to the initial view $\vi$ which are comparatively straightforward; and those that constrain the initial view $\vi$ which
%are less straightforward as they require closure properties on the
%so-called visible transactions of a view. 
%
In what follows we define $\vshiftname$ and $\cancommitname$ for several consistency models. To do this, we first need several auxiliary definitions. 

\mypar{Notation}
Given relations $\mathsf r, \mathsf r' \subseteq \sort A \times \sort A$,
we write $\mathsf r\rflx$, $\mathsf r^+$ and $\mathsf r^*$ for its reflexive, transitive and reflexive-transitive closures of $\mathsf r$, respectively;
write $\mathsf r^{-1}$ for its inverse;
write $a_1 \toEDGE{\mathsf r} a_2$ for $(a_1, a_2) \in \mathsf r$;
and write \( \mathsf r; \mathsf r'\) for \( \Set{(a_1,a_2)}[\exsts{a} (a_1,a) \in \mathsf r\land (a,a_2) \in \mathsf r']\).

\mypar{Prefix Closure}
Given a kv-store $\mkvs$ and a view $\vi$, the {\em set of visible
transactions} is defined as follows, containing those transactions whose updates are known to a
client with view $\vi$:
{%
\displaymathfont
\begin{align*}
\Tx[\mkvs, \vi] & \defeq
\Set{\wtOf[\mkvs(\key, i] }[ i \in \vi(\key)]
\end{align*}
}%
%
%Conversely, given a kv-store $\mkvs$ and set
%of visible transactions $\txidset$, it is possible to recover a view
%of the client by%
%
%\vspace{-7pt}
%{%
%\displaymathfont
%\begin{align*}
%    \getView[\mkvs, \T] & \defeq \lambda \key. \Set{i }[
%\wtOf[\mkvs(\key, i)] \in \T]
%\end{align*}
%}%
%This connection between views and sets of transactions enables us to express concisely 
%the prefix-closure of a view with respect to a dependency relation $\rel$ between 
%transactions: given $R \subseteq \TxID \times \TxID$, the closure of 
%a view $\vi$ with respect to the kv-store $\mkvs$ and the relation $R$
%is defined as%
%
%\vspace{-7pt}
%{%
%\displaymathfont
%\begin{align*}
%\func{closure}[\mkvs, \vi, R] & \defeq \getView[\mkvs, (R^{-1})^{\ast}(\Tx(\mkvs, \vi))]
%\end{align*}
%}%
%If $\vi = \mathsf{closure}(\mkvs, \vi, R)$, then we say that $\vi$ is \emph{closed} with 
%respect to $\mkvs$ and $R$, written \( \closed[\mkvs,\vi,\rel]\).
%%The view $\vi$ is said to be closed with respect to $\mkvs$ and $R$, denoted 
%%$\closed(\mkvs, \vi, R)$, if and only  if $\vi = \mathsf{closure}(\mkvs,\vi,R)$.
%
%
Given relation on transactions, $\rel \subseteq \TxID \times \TxID$, we say that a view $\vi$ is closed with respect to a kv-store $\mkvs$ and $\rel$, written $\closed[\mkvs,\vi,\rel]$, iff:  
{%
\displaymathfont
\begin{align*}
	\closed[\mkvs,\vi,\rel]
	\defiff
	\Tx(\mkvs, \vi) {=} 
	(\rel^*)^{-1} \Tx(\mkvs, \vi)
\end{align*}
}%
That is, if transaction $\txid$ is visible in $\vi$, then all transactions that are $\rel^*$-before $\txid$ are also visible in $\vi$.

\mypar{Dependency Relations}
We define transaction dependency relations for kv-stores inspired by dependency graphs due to Adya \cite{adya}, and  introduced in \ref{sec:other_formalisms}.
Given a kv-store $\mkvs$, a key $\key$ and 
indexes $i,j$ such that  $0 \leq i < j < \abs{ \mkvs(\key) }$, 
if there exists $\txid_i, \T_i, \txid$ such that 
$\mkvs(\key, i)  {=} (\stub, \txid_{i}, \T_{i})$, $\mkvs(\key,j) {=} (\stub, \txid_{j}, \stub)$
and $\txid \in \T_{i}$, 
then we say that there is:
\begin{enumerate} 
\item a \emph{Write-Read} dependency over 
$\key$ from $\txid_{i}$ to $\txid$, written $(\txid_{i},\txid) \in \WR_{\mkvs}(\key)$;
\item a \emph{Write-Write} dependency over $\key$ from $\txid_{i}$ to $\txid_{j}$, 
    written $(\txid_{i},\txid_{j}) \in \WW_{\mkvs}(\key) $; and 
\item a \emph{Read-Write} anti-dependency from $\txid$ to $\txid_{j}$, provided that 
$\txid \neq \txid_{j}$, written $(\txid,\txid_j) \in \RW_{\mkvs}(\key)$.
\end{enumerate}
\noindent \cref{fig:dependencies} illustrates an example kv-store and its dependencies.
%
%
\pg{
------I realise I now don't understand this next bit fully , we need to
discuss-------
\ac{The best way to understand this from a theoretical point of view is 
by induction/coinduction. Adya's specifications may be thought of as 
coinductive specifications: for example, serialisability is THE LARGEST 
set of dependency graphs  SER such that whenever G $\in$ SER, then 
G has no cycles. Execution tests instead correspond to inductive definitions: 
SER is the SMALLEST SET such that the initial kv-store is in SER, and if 
K' is in SER and K can be obtained by committing a transaction in K' using  
a complete view (one with all versions), then K is in SER.}

}
%
    \azalea{I don't think here is the right place for the following and I think this should go in \cref{sec:other_formalisms}:\\
As we will see shortly, we use dependencies in a way fundamentally 
different from Adya's dependency graphs \cite{adya}, 
a well-known mathematical structure used for specifying consistency models that is introduced 
formally in \cref{sec:dep_graphs}.
Adya's specifications are of a declarative nature: dependency models are specified by 
placing constraints on the structure of dependency graphs admitted by a consistency model, using the dependency graph counterpart 
of the relations introduced above. 
In contrast, execution tests define consistency models in a constructive way. Dependencies 
over kv-stores are used by execution tests to restrict the views of clients (i.e the sets of versions that clients must see) before or 
after committing a transaction. The consistency model induced $\ET$ corresponds 
to the set of kv-stores that can be constructed by allowing clients to commit transactions only 
when the conditions on such views are respected. This approach is agnostic of the structure 
of kv-stores contained in $\CMs(\ET)$.}
%is constructed by onl
%introduced in \ref{sec:}
%Although we define transaction dependencies for kv-stores  in a style 
%similar to dependency graphs \cite{adya}, their use  is fundamentally different.  
%Definitions of consistency 
%models on dependency graphs are declarative: 
%we will see in \cref{sec:other_formalisms} 
%they impose 
%constraints on the structure of a kv-store. On the other hand, 
%execution 
%tests use dependencies between transactions to restrict 
%the view of clients before and after committing a transaction.  
%Whereas dependency graphs can be used to define a consistency model 
%in terms of what the permissible structure of kv-stores is, we use execution tests
%to define how such kv-stores can be constructed, in a way that is agnostic of their structure.
%
%-------------

We now proceed by defining \vshiftname and \cancommitname for several well-known consistency models.
%We give example execution tests in
%~\cref{fig:execution.tests}. 
%We start by looking at  execution tests for defining  session
%guarantees, then we move to execution tests which capture stronger
%consistency models. 

\ac{
\pg{

Below you are talking about clients all the time. I think the ETs
should be indexed by clients.

}
I agree, but there is no time for that.
}





\subsubsection{Monotonic Reads $(\MR)$}
%This consistency model states that a client
%cannot lose information from the view. It  
%can only see increasingly more up-to-date versions from a kv-store. 
This consistency model states that when committing, a client
cannot lose information in that it can only see increasingly more up-to-date versions from a kv-store.
This prevents, for example, the kv-store of \cref{fig:mr-disallowed},
since client $\cl$ first reads the latest version of $\key$ in $\txid_{\cl}^{1}$, 
and then reads the older, initial version of $\key$ in $\txid_{\cl}^{2}$.  
As such, the $\vshiftname_{\MR}$ predicate in \cref{fig:execution_tests} ensures that clients  can only extend their views. 
When this is the case, clients can then \emph{always} commit their transactions, and thus $\cancommitname_{\MR}$ is simply defined as $\true$. 
%Note that the execution test $\ET_{\MR}$ can also be expressed as a closure 
%property of the resulting view. 
%Let $\rel_{\MR}(\mkvs, \vi) \defeq \Set{(\wtOf[\mkvs(\key, i), \txid] }[ \key \in \Keys \wedge i \in \vi(\key) \wedge \txid \in \mkvs]$; 
%%given \(\mkvs, \vi\) before committing a transaction and $\mkvs',
%%\vi'$ after.
%The predicate $\closed[\mkvs', \vi', R_{\MR}(\mkvs, \vi)]$ states that all the versions included in $\vi$ on $\mkvs$ 
%must also be included in $\vi'$ on $\mkvs'$: that is,  $\vi
%\sqsubseteq \vi'$ and  hence 
%$\ET_{\MR} \defeq \Set{(\mkvs, \vi, \opset, \mkvs', \vi') }[
%\closed[\mkvs', \vi', \rel_{\MR}(\mkvs, \vi)]]$.
%
%

%\subsubsection{Monotonic Writes $(\MW)$}
%This consistency model states that if a client $\cl$ sees 
%a version \( \key \) that was written by another client $\cl'$, 
%then it must see all versions of \( \key \) that were 
%previously written by $\cl'$: in other words, 
%the view of the client $\cl$  in a kv-store $\mkvs$ must be closed 
%with respect to the relation $\SO \cap \WW_{\mkvs}$, 
%before $\cl$ can commit a transaction.

\subsubsection{Read Your Writes $(\RYW)$}
This consistency model states that a client must always see all the versions written by the client itself. 
The $\vshiftname_{\RYW}$ predicate thus states that after executing a transaction, a client 
%the resulting view 
contains all the versions it wrote in its view. This ensures that such versions will be included in the view of the client 
when committing future transactions.
Note that under $\RYW$ the kv-store in \cref{fig:ryw-disallowed} is prohibited as
the initial version of $\key$ holds value $\val_0$ 
and client $\cl$ tries to increment the value of $\key$ twice.  
For its first transaction \( \txid_{\cl}^1\), it reads the initial value $\val_0$ and then writes a new version with value $\val_1$. 
For its second transaction \( \txid_{\cl}^2\), it reads the initial value $\val_0$ again and write a new version with value $\val_1$.
The $\vshiftname_{\RYW}$ predicate rules out this example by requiring that
the client view, after it commits the transaction  \(\txid_{\cl}^{1}\), includes the version it wrote.  
When this is the case, clients can always commit their transactions, and thus $\cancommitname_{\RYW}$ is simply $\true$.

The $\MR$ and $\RYW$ models together with \emph{monotonic writes} (\MW) and \emph{write follows reads} (\WFR) models  are collectively known as \emph{session guarantees}. 
Due to space constraints, we omit the definitions associated with $\MW$ and $\WFR$, and refer the reader to the accompanying technical appendix. 


\pg{------------------------RYW----------

I always find the words quite difficult. Decide whether you are going
to say the client sees or the client observes a version. I believe
this means that the version is in the client view (seomewhere this
should be stated). But in this case I don't quite know what this
means becuase the client view could be the u or the u', it actually
means the u' but you wouldn't know from the words and actually I would
expect it to be the u from the words.


I have not read the closure bit very much. Just to simplify, can you
use the predicate closed (K', u', SO? (K'/K))? 

Can you reword `the newly committed transaction' as we don't really
have our hands on this for hthis definition although I know it's in
the operational rule?

------------------------



----------------------WFR---------

Ok, now you are talking about transactions seeing, when previously you
were talking about clients seeing. I guess fine you did explain it in
MW (I now realise) but it's all very complicated and I wonder if it
can be simplified. 

----------------------------------
}



\input{\RootPath/anomalies-fig.tex}

%\subsubsection{Write Follows Reads $(\WFR)$}
%This consistency model states that, prior to committing a transaction, 
%if a client $\cl$ sees a version on a key $\key$ written by some
%client $\cl'$ (possibly equal to $\cl$), then it must also see the versions of $\key$ previously read by $\cl'$ (in $\SO\rflx$ relation). 
%The execution test $\ET_{\WFR}$ models exactly this condition.
%The kv-store of \cref{fig:wfr-disallowed} is disallowed by $\ET_{\WFR}$,
%since transaction $\txid$ reads a version written by $\cl$ but
%not a version previously read by $\cl$.
%%The execution test $\ET_{\WFR}$ ensures
%%that a view includes all versions previously read by a client 
%%if the view already includes a write from that client. 
%
%\sx{A cite here \cite{surech-session-guarantee} who mentions composition of 4 session guarantees. 
%    \cite{principle-eventual-consistency} mentions causal consistency is combination of session guarantees,
%    yet they only define 3 types of session guarantees.
%}
%\sx{ Sessions to CC cite \cite{principle-eventual-consistency} }


%{\color{blue} 
%\textbf{Azalea: } This is where I got to}

\subsubsection{Causal Consistency $(\CC)$}
Causal consistency subsumes the  four session guarantees discussed above. 
As such, the $\vshiftname_\CC$ predicate is defined as the \emph{conjunction} of their associated \vshiftname predicates.
However, as shown in  \cref{fig:execution_tests}, it is sufficient to define $\vshiftname_\CC$
as the conjunction of the $\MR$ and $\RYW$ session guarantees alone, where for brevity we 
write $\vshiftname_{\MR \cap \RYW}$ for  $\vshiftname_{\MR} \land \vshiftname_{\RYW}$.
This is because as we demonstrate in the technical appendix, the $\cancommitname_{\CC}$ predicate (described shortly below) implies $\vshiftname_{\MW \cap \WFR}$, allowing us to remove them from $\vshiftname_{\CC}$.

Additionally, $\CC$ strengthens the session guarantees by requiring that if a client sees a version $\ver$ prior to committing a transaction, then it must also see the versions 
on which $\ver$ depends.
If $\txid$ is the writer of $\ver$, then 
$\ver$ clearly depends on all versions that $\txid$ reads. 
Moreover, if $\ver$ is, or it depends on, a version $\ver'$ accessed by 
a client $\cl$, then it also depends on all versions that were previously 
read or written by $\cl$. 
This is captured by the $\cancommitname_{\CC}$ predicate in \cref{fig:execution_tests}, 
defined as $\closed(\mkvs, u, \rel_{\CC})$ with $\rel_\CC \defeq \SO \cup \WR_{\mkvs}$.
\azalea{without the definitions of $\MW$ and $\WFR$ we no longer can explain why this implies $\MW$ and $\WFR$.}
%Note that this condition implies both monotonic writes and write follows reads: 
%given a kv-store $\mkvs$ and view $\vi$ such that 
%$\closed(\mkvs, \vi, \SO \cup \WR_{\mathsf{k}})$,
%then it is immediate to observe that $\closed(\mkvs, \vi, \SO \cap \WW_\mkvs)$, 
%and $\closed(\mkvs, \vi, \WR_{\mkvs};\SO\rflx)$. We let $\ET_{\CC} = 
%\{(\mkvs, \vi, \fp, \_, \_) \mid \closed(\mkvs, \vi, \SO \cup \WR_{\mkvs})\} \cap \ET_{\MR} 
%\cap \ET_{\RYW}$, and we observe that $\ET_{\CC} \subseteq \ET_{\MR} \cap \ET_{\MW} 
%\cap \ET_{\RYW} \cap \ET_{\WFR}$. This is in accordance with the result from 
%\citeN{session2causal}, which states that the four session guarantees are a necessary, but 
%not sufficient, condition for achieving causal consistency.
For example, the kv-store of 
\cref{fig:wr-wfr-allowed-but-cc} 
%is allowed by the four session guarantees, but it 
is disallowed by $\CC$: the version of key $\key_3$ carrying value $\val_3$ depends on the version of key $\key_1$ carrying value $\val_1$. However, transaction $\txid$ must have been committed by a client whose view included $\val_3$, but not $\val_1$.
%We define causal consistency as $\ET_{\CC} = \{(\mkvs, \vi, \_, \_, \_) \mid \closed(\mkvs, \vi \SO \cup \WR_{\mkvs})\} 
%\cap \ET_{\MR} \cap \ET_{\RYW})$: observe that this definition of $\ET_{\CC}$ is included in the execution 
%test for the four consistency guarantees, in accordance with the
%result from \citeN{session2causal}.

%
%The correctness of this definition depends on the fact that  their model of transactions assumed the 
%knowledge of a total order according to which transactions commit. 
%Yet it is \textbf{not} the case \( \ET_\CC = \ET_{\MR} \cap \ET_{\MW} \cap \ET_{\RYW} \cap \ET_{\WFR}\) here.
%%One would expect the execution test for causal consistency to be exactly 
%%the intersection of the execution tests for the individual session guarantees: 
%%$\ET_{\MR} \cap \ET_{\MW} \cap \ET_{\RYW} \cap \ET_{\WFR}$. .
%First, because $\ET_{\MW}$ and $\ET_{\WFR}$ have been 
%defined in terms of closure properties over the view of a client before committing a transaction, with respect 
%to two relations $\rel_{\MW} = \SO \cap \WW_{\mkvs}$ and $\rel_{\WFR}$ respectively, while to build an execution test that composes the two 
%consistency guarantees it requires that the view of a client prior to executing a transaction is 
%closed simultaneously with respect to $\rel_{\MW}$ and $\rel_{\WFR}$, that is, $\closed[\mkvs,\vi,\rel_{\MW} \cup \rel_{\WFR}]$. 
%Second, causal consistency intuitively requires that 
%if a view includes a version hence the writer \( \txid \) of the version, 
%it must include any versions that were written by transactions that \( \txid \) depends on.
%These \emph{dependencies} between transactions are given by \( \SO \) and \( \WR \) relations.
%Note that the closure under \( \SO \cup \WR \) is stronger than under \( \rel_{\MW} \cup \rel_{\WFR} \),
%that is, for any \( \mkvs,\vi \), \( ( \vi = \closed[\mkvs,\vi,\SO\cup\WR_\mkvs] ) \implies ( \vi = \closed[\mkvs,\vi,\rel_{\MW} \cup \rel_{\WFR}] ) \).
%Therefore, the definition of causal consistency is given in \cref{fig:execution-tests}:
%it states that the view before committing a transaction must be closed with respect to 
%causal dependencies of transactions; and the view after committing guarantees \( \MR \) and \( \RYW \). 
%%Let $\ET_{\MR+\WFR} = \Set{(\mkvs, \vi, \fp, \mkvs', \vi')}[ \closed[\mkvs, \vi, \rel_{\MW} \cup \rel_{\WFR}]]$. 
%%\cref{fig:wr-wfr-allowed-but-cc} shows an example for $\CMs[\ET_{\MW} \cap \ET_{\RYW}] \neq \CMs(\ET_{\MW+\WFR})$,
%%where the last transaction \( \txid \), by a client differs from \( \cl \) and \( \cl' \), 
%%is allowed to committed under \( \MW \) and \( \WFR \) but not \( \MW + \WFR \), given that
%%\( \txid_{\cl}^1 \toEDGE{\SO} \txid_{\cl}^2 \toEDGE{\WR_\mkvs} \txid_{\cl'}^1 \toEDGE{\SO} \txid_{\cl'}^2 \).
%Note that the same argument of intersecting execution tests 
%would apply to the session guarantees $\MR$ and $\RYW$,
%however, in this particular case we obtain that $\ET_{\MR+\RYW} = \ET_{\MR} \cap \ET_{\RYW}$.
%%The execution test for causal consistency is therefore 
%%given by $\ET_{\MR+\RYW} \cap \ET_{\MR} \cap \ET_{\RYW}$, which is equivalent to the one in
%%\cref{fig:execution.tests}: 
%
%\ac{
%Causal consistency has been defined in the literature~\cite{session2causal} 
%as the conjunction (composition) of the four \emph{session guarantees} \(\MR\), \(\MW\), \(\RYW\) and \(\WFR\). 
%One would expect the execution test for causal consistency to be exactly 
%the intersection of the execution tests for the individual session guarantees: 
%$\ET_{\MR} \cap \ET_{\MW} \cap \ET_{\RYW} \cap \ET_{\WFR}$. Yet it is not the case.
%Because $\ET_{\MW}$ and $\ET_{\WFR}$ have been 
%defined in terms of closure properties over the view of a client before committing a transaction, with respect 
%to two relations $\rel_{\MW} = \SO$ and $\rel_{\WFR}$ respectively, while to build an execution test that composes the two 
%consistency guarantees it requires that the view of a client prior to executing a transaction is 
%closed simultaneously with respect to $\rel_{\MW}$ and $\rel_{\WFR}$, that is, it is closed with respect to 
%$\rel_{\MW} \cup \rel_{\WFR}$. Let 
%$\ET_{\MR+\WFR} = \Set{(\mkvs, \vi, \fp, \mkvs', \vi')}[ \closed[\mkvs, \vi, \rel_{\MW} \cup \rel_{\WFR}]]$. 
%\cref{fig:wr-wfr-allowed-but-cc} shows an example for $\CMs[\ET_{\MW} \cap \ET_{\RYW}] \neq \CMs(\ET_{\MW+\WFR})$,
%where the last transaction \( \txid \), by a client differs from \( \cl \) and \( \cl' \), 
%is allowed to committed under \( \MW \) and \( \WFR \) but not \( \MW + \WFR \), given that
%\( \txid_{\cl}^1 \toEDGE{\SO} \txid_{\cl}^2 \toEDGE{\WR_\mkvs} \txid_{\cl'}^1 \toEDGE{\SO} \txid_{\cl'}^2 \).
%In theory, the same argument would apply to the session guarantees $\MR$ and $\RYW$
%however, in this particular case we obtain that $\ET_{\MR+\RYW} = \ET_{\MR} \cap \ET_{\RYW}$. 
%The execution test for causal consistency is therefore 
%given by $\ET_{\MR+\RYW} \cap \ET_{\MR} \cap \ET_{\RYW}$, which is equivalent to the one in
%\cref{fig:execution.tests}: it states that the view before committing a transaction must be closed with respect to 
%causal dependencies of transactions; and the view after committing guarantees \( \MR \) and \( \RYW \).
%}

\subsubsection{Update Atomic $(\UA)$}
This consistency model has been proposed by \citet{framework-concur} 
and implemented by \citet{rola}.
$\UA$ disallows concurrent transactions writing to the same key,
a property known as \emph{write-conflict freedom}:  
when two transactions write to the same key, one must see the version 
written by the other.
Write-conflict freedom is enforced by $\cancommitname_{\UA}$ which allows a client to write to key $\key$ only if its view includes all versions of $\key$; 
\ie its view is closed with respect to the $\WW^{-1}(\key)$ relation for all keys $\key$ written in the fingerprint $\fp$.
This prevents the kv-store of \cref{fig:ua-disallowed},
as $\txid$ and $\txid'$ concurrently increment the initial version of $\key$ by $1$.
As client views must include the initial versions, once $\txid$ commits a new version $\ver$ with value $\val_1$ to $\key$, then $\txid'$ must include $\ver$ in its view as there is a $\WW$ edge from the initial version to $\ver$. 
As such, when $\txid'$ subsequently increments $\key$, it must read from $\ver$, and not the initial version as depicted in \cref{fig:ua-disallowed}.



\subsubsection{Parallel Snapshot Isolation $(\PSI)$} 
This consistency model is defined as the conjunction of the guarantees provided by $\CC$ and $\UA$~\cite{framework-concur}. 
As such, the $\vshiftname_{\PSI}$ predicate is defined as the conjunction of the $\vshiftname$ predicates for $\CC$ and $\UA$.
However, we cannot simply define $\cancommitname_{\PSI}$ as the conjunction of the $\cancommitname$ predicates for $\CC$ and $\UA$. 
This is for two reasons. 
First, their conjunction would only mandate that $\vi$ be closed with respect to 
$\rel_{\CC}$ and $\rel_{\UA}$ \emph{individually}, but \emph{not} with respect to their \emph{union} (recall that closure is defined in terms of the transitive closure of a given relation and thus the closure of $\rel_{\CC}$ and $\rel_{\UA}$ is smaller than the closure of $\rel_{\CC} \cup \rel_{\UA}$).
As such, we define $\cancommitname_{\PSI}$ as closure with respect to $\rel_{\PSI}$ which must include $\rel_{\CC} \cup \rel_{\UA}$.
Second, recall that $\cancommitname_{\UA}$ requires that a transaction writing 
to a key $\key$ must be able to see all previous versions of $\key$, \ie all versions of $\key$. 
That is, when write-conflict freedom is enforced, a version $\ver$ of $\key$ depends on all 
previous versions of $\key$. 
This observation leads us to include write-write dependencies ($\WW_{\mkvs}$) in $\rel_{\PSI}$. 
Observe that the kv-store in \cref{fig:cc-ua-allowed-but-psi} shows an example kv-store that satisfies $\cancommitname_{\CC} \land \cancommitname_{\UA}$, 
but not $\cancommitname_{\PSI}$.
%To capture this constraint, 
%we must include write-write dependencies in the relation with respect to which the view of a client before committing 
%a transaction must be closed.
%The definition in \cref{fig:execution.tests} ensures that 
%views of committing transactions are closed simultaneously with respect to both relations.
%Analogously, we have defined $\ET_\PSI = \ET_\CC \cap \ET_\UA$. 
%This definition exploits the \emph{compositionality} of our execution tests (\cref{thm:compositional}).
%as discussed in \cref{sec:other_formalisms}.

\subsubsection{Consistent Prefix $(\CP)$}
\label{para:cp}
If the total order in which transactions commit is known, $\CP$
can be described as a strengthening of $\CC$: 
if a client sees the versions written by a transaction $\txid$,
then it must also see all versions written by transactions that commit before $\txid$. 
Although kv-stores only provide {\em partial} information about the transaction commit order via the dependency relations,
this is sufficient to formalise \emph{Consistent Prefix} \cite{laws}.

In practice, we approximate the order in which transactions 
commit in an $\ET$-trace that terminates in a configuration $(\mkvs, \_)$ via the $\WR_{\mkvs}, \WW_{\mkvs}, \RW_{\mkvs}$ and $\SO$  relations. 
This approximation is best understood in terms of an idealised implementation of $\CP$ on a centralised system,
%fine-grained model 
%where transactions are equipped with start and commit points, and operations 
%between transactions in different sessions may interleave with each other. 
where the snapshot of a transaction is determined at its start point and its effects are made visible to future transactions at its commit point.
With respect to this implementation, if $(\txid,\txid') \in \WR$, then 
%$\txid$ reads the version of some key $\key$ 
%written by $\txid'$, therefore  it {must} be
%the case that 
$\txid$ must commit before $\txid'$ starts, and hence before $\txid'$ commits.
Similarly, if $(\txid,\txid') \in \SO$, then $\txid$ commits before $\txid'$ starts, 
and thus before $\txid'$ commits.
% 
%Consider the transaction relations $\WR_{\mkvs}$, $\WW_{\mkvs}$ and
%$\RW_{\mkvs}$ defined in \ref{fig:execution.tests}, adapted from well-known
%transaction relations associated with dependency graphs~\cite{adya-icde,adya}.
%In \cite{laws} an alternative definition of $\CP$ is given: if a client sees a transaction $\txid$, 
%then it must also see the subset of transactions that committed before $\txid$, that can 
%be computed from $\SO, \WR_{\mkvs}, \WW_{\mkvs}, \RW_{\mkvs}$. This property is captured 
%by $\dagger$ in \cref{fig:execution.tests}.
Recall that $(\txid'', \txid') \in \RW$
%The pair $(\txid,\txid') \in \WR_\mkvs$ means that $\txid$ reads the version of some key $\key$ 
%written by $\txid'$, therefore  it {must} be
%the case that $\txid$ commits before $\txid'$ starts, and therefore before $\txid'$ commits,
%and similarly for $\SO$.
%The pair $(\txid, \txid') \in \RW_{\mkvs}$ 
denotes that $\txid''$ reads a version that is later overwritten by $\txid'$.
That is, $\txid''$ cannot see the write of $\txid'$, and thus $\txid''$ must starts before 
$\txid'$ commits. 
As such, if $\txid$ commits before $\txid''$ starts 
($(\txid, \txid'') \in \WR$ or $(\txid,\txid'') \in \SO$), 
%the two are 
%related by a write-read dependency \(\WR\) or by a session order \(\SO\)), 
and $(\txid'', \txid') \in \RW$, then $\txid$ must commit before 
$\txid'$ commits. 
In other words, if $(\txid,\txid') \in \WR;\RW$ or $(\txid,\txid') \in \SO;\RW$, then $\txid$ commits before $\txid'$.
Finally, if $(\txid,\txid') \in\WW$, then $\txid$ must commit before $\txid'$. 
We therefore define $\rel_{\CP} \defeq (\WR_{\mkvs}; \RW_{\mkvs}\rflx \cup \SO;  \RW_{\mkvs}\rflx \cup \WW)$, approximating the order in which transactions commit. 
%
\citet{laws} show that the set $(\rel_{\CP}^{-1})^{+}(\txid)$ contains all transactions that must be observed by $\txid$ under $\CP$. 
We define $\cancommitname_{\CP}$ by requiring that the client view be 
closed with respect to $\rel_{\CP}$.

%$(\txid,\txid'') \in \WR_{\mkvs}$ (resp. \SO) and $(\txid'',\txid') \in \RW_\mkvs$, then it {must} also be the case that $\txid$ commits before the commit  of $\txid'$, 
%Last, if $(\txid,\txid') \in \WW_\mkvs$ means that $\txid'$ overwrites a version written by $\txid$ for some 
%key, then it {must} be
%the case that $\txid$ commits before the commit of $\txid'$.
%The relation $((\SO ; \RW_{\mkvs}\rflx) \cup (\WR_{\mkvs} ; \RW_{\mkvs\rflx}) \cup \WW_\mkvs )^{+} \ni (\txid, \txid')$
%captures that, {\em all} the transactions $\txid$ that {must} have already committed to the kv-store before commit of \( \txid' \).
%The execution test $\ET_{\CP}$ is the intersection of $\dagger$ with $\ET_\MR \cap \ET_\RYW$,
%where the latter enforces a client sees its own commits.
Consistent prefix disallows the \emph{long fork anomaly} shown in \cref{fig:cp-disallowed}, where clients $\cl_1$ and $\cl_2$ observe the updates to $\key_1$ and $\key_2$ 
in different orders. 
Assuming without loss of generality that \( \txid_{\cl_1}^{2} \) commits 
before \( \txid_{\cl_2}^{2} \), then prior to committing its transaction $\cl_2$ sees 
the version of $\key_1$ with value $\val_0$. 
However, since $\txid \xrightarrow{\WR_{\mkvs}} \txid_{\cl_{1}}^{1} 
\xrightarrow{\SO} \txid_{\cl_{1}}^{2} \xrightarrow{\RW} \txid' \xrightarrow{\WR} \txid_{\cl_{2}}^{1} \xrightarrow{\SO} 
\txid_{\cl_2}^{2}$, then $\cl_2$ should also see the version of $\key_1$ with 
value $\val_2$, leading to a contradiction.
%\txid_{\cl_1}^{2}
%if \( \txid_{\cl_2}^2\) is the last transaction, it reads and thus sees \( \txid' \).
%Given the kv-store we have:
%\(
%\txid \toEDGE{\WR_\mkvs} \txid^1_{\cl_1} \toEDGE{\SO} \txid^2_{\cl_1} \toEDGE{\RW_\mkvs} \txid'
%\),
%which means, transaction \( \txid_{\cl_2}^2 \) must see \( \txid \).
%However, in \cref{fig:cp-disallowed} \( \txid_{\cl_2}^2 \) reads a older version of \( \key_1 \) than the one written by \( \txid \).
%Symmetrically,
%if \( \txid_{\cl_1}^2\) is the last transaction, it sees \( \txid \) and so must see \( \txid' \).
%\sx{A reviewer suggests to show the visibility edges for long fork}


\subsubsection{Snapshot Isolation $(\SI)$}
When the total order in which transactions commit is known,  
$\SI$ can be defined compositionally from $\CP$ and $\UA$. 
As such, $\vshiftname_{\SI}$ is defined as the conjunction of their associated $\vshiftname$ predicates. 
However, as with $\PSI$, we cannot define $\cancommitname_{\SI}$ as the conjunction of their associated $\cancommitname$ predicates. 
Rather, we define $\cancommitname_{\SI}$ as closure with respect to $\rel_{\SI}$, which includes $\rel_\CP \cup \rel_{\UA}$.
Observe that the kv-store in \cref{fig:si-disallowed} shows an example kv-store that satisfies $\cancommitname_{\UA} \land \cancommitname_{\CP}$, 
but not $\cancommitname_{\SI}$.
Additionally, we include $\WW;\RW$ in $\rel_{\SI}$. 
This is because when the centralised $\CP$ implementation (discussed above) is strengthened with write-conflict freedom, then a write-write dependency between two transactions $\txid$ and $\txid'$ 
does not only mandate that $\txid$ commits before $\txid'$ commits but also before $\txid'$ starts. 
Consequently, if $(\txid, \txid') \in \WW ;\RW$, then $\txid$ must commit 
before $\txid'$ commit.
%When we can rely only on 
%a partial order of transaction execution, inferred from 
%kv-stores and views, then this compositional result does not 
%hold\footnote{This issue arises also if dependency graphs are used in 
%place of kv-stores. See \cref{sec:si-not-intersect-cp-ua}}. For example, the kv-store of \cref{fig:si-disallowed} is
%included in both $\CMs(\ET_{\CP})$ and $\CMs(\ET_{\UA})$, but is
%disallowed by the execution test $\ET_\SI$, introduced presently
%In our definition, \( \ET_\SI \) by replacing property dagger in $\ET_{\CP}$ with 
%\( \ddagger \) (\cref{fig:execution.tests}) and by intersecting the result with $\ET_{\UA}$.
%Similarly as for $\CP$, the $\ddagger$ property captures the 
%fact that if transaction $\txid$ sees the writes of another transaction $\txid'$, then 
%it must see the subset of transactions committing before $\txid'$ that can be computed 
%from $\SO, \WR_{\mkvs}, \WW_{\mkvs}, \RW_{\mkvs}$. However, because snapshot isolation enforces 
%write-conflict freedom, the computation of this subset 
%differs from the one for $\CP$. 
%Under $\UA$ consequently \(\SI\), the pair $(\txid, \txid'') \in \WW_\mkvs$ means not only the case that $\txid$ commits 
%before $\txid''$, but $\txid$ commits before $\txid''$ start. 
%Because $(\txid'',\txid') \in \RW_{\mkvs}$ 
%implies that $\txid''$ starts before $\txid'$ commits, then it must be the case that 
%when $(\txid,\txid') \in \WW_{\mkvs} ; \RW_{\mkvs}$ then $\txid$ commits before $\txid'$ does. 
%In \cref{fig:si-disallowed} we show an anomaly that is allowed by $CP$ and $UA$ 
%(and therefore by the intersection of these two consistency models), but is disallowed by $\SI$. In this kv-store \( \txid_4 \) reads 
%the last version of \( \key_2 \) written by \( \txid_3 \), so that this kv-store is allowed by  \( \UA \). 
%We also have that 
%From the \( \txid_3 \) backwards we have edges:
%\(
%\txid_1 \toEDGE{\WW_\mkvs} \txid_2 \toEDGE{\RW_\mkvs} \txid_3
%\).
%Snapshot isolation \( \SI \) requires that if a transaction sees \( \txid_3 \) it must see \( \txid_1 \) by the \( \ddagger \) (it is not the case in \( \dagger \)).
%However in \cref{fig:si-disallowed} transaction \( \txid_4 \) only see the initial version of \( ke_1 \).
%As we discuss in \cref{sec:applications} and prove in the \ref{sec:clock-si}, 
%the Clock-SI protocol~\cite{clocksi} satisfies $\ET_{\SI}$. 

\subsubsection{(Strict) serialisability $(\SER)$}
Serialisability is the strongest consistency model in the literature, requiring that transactions execute in a  total sequential order. 
The $\cancommitname_{\SER}$ thus allows clients to commit transactions only when 
their view of the kv-store store is complete, \ie the client view is closed with respect to $\WW^{-1}$.
This requirement prevents the kv-store in  \cref{fig:ser-disallowed}: 
%under serialisability either $\txid_1$ or $\txid_2$ commits first. 
without loss of generality, suppose that $\txid_1$ commits before $\txid_2$. Then the client committing $\txid_2$ must see the version of $\key_1$ written by $\txid_1$, 
and thus cannot read the outdated value $\val_0$ for $\key_1$. 
%(the other case is analogous), then the write of $\key_2$ 
%must be included in the view of $\txid_2$, and thus $\txid_2$ should not read the outdated write to $\key_2$ by $\txid_0$. 
%The latter case is analogously prohibited. 
This example is allowed by all other execution tests in~\cref{fig:execution_tests}.

\subsubsection{Weak Snapshot Isolation $(\WSI)$: A New Consistency Model} 
\label{sec:new_cm}
Kv-stores and execution tests are useful for investigating new 
consistency models.  
One example is the consistency model induced by combining 
$\CP$ and $\UA$, which we refer to as \emph{Weak Snapshot Isolation} ($\WSI$). 
To justify this consistency model in full, it would be useful to explore its implementations. 
Here we focus on the benefits of implementing $\WSI$.
Because $\WSI$ is stronger than $\CP$ and $\UA$ by definition, 
it forbids all the  anomalies forbidden by these consistency models, \eg
the long fork (\cref{fig:cp-disallowed}) and the lost update (\cref{fig:ua-disallowed}). 
Moreover, $\WSI$ is strictly weaker than $\SI$. 
As such, $\WSI$ allows all $\SI$ anomalies, \eg the write skew (\cref{fig:ser-disallowed}), 
and allows behaviour not allowed under $\SI$ such as that in \cref{fig:si-disallowed}.
We can construct a $(\ET_{\CP} \cap \ET_{\UA})$-trace terminating in $(\mkvs, \_)$ by 
executing transactions $\txid_{1}, \txid_{2}, \txid_{3}$ and $\txid_{4}$ in this order. 
In particular, $\txid_{4}$ is executed using $\vi {=} [\key_{1} \mapsto \{0\}, \key_{2} \mapsto \{0,1\}]$. 
However, the same trace is not a valid $\ET_{\SI}$-trace. % terminating in such a kv-store. 
%If we use the execution test $\ET_{\CP} \cap \ET_{\UA}$, then 
%this kv-store can be obtained by executing  
%transaction $\txid_{1}$ using the initial view $[\key_1 \mapsto \{0\}, \key_2 \mapsto \{0\}]$, 
%transaction $\txid_{2}$ using the view $[\key_1 \mapsto \{0,1\}, \key_2 \mapsto \{0\}]$ 
%transaction $\txid_{3}$ using the view $[\key_1 \mapsto \{0,1\}, \key_2 \mapsto \{0,1\}]$, 
%and transaction $\txid_{4}$ using the view $[\key_1 \mapsto \{0\}, \key_2 \mapsto \{0,1\}]$. 
Under $\SI$ transaction $\txid_{4}$ cannot be executed using $\vi$: 
$\txid_{4}$ reads the version of $\key_2$ written by $\txid_3$, 
meaning that $\vi$ must include the version written by 
$\txid_{3}$. Since $(\txid_{2},\txid_{3}) \in \RW $
%(because $\txid_{2}$ reads a staler version $\key_2$ than the one written by $\txid_{3}$) 
and $(\txid_{1} ,\txid_2) \in \WW$, 
%(because $\txid_{2}$ installs a newer version of $\key_{1}$ than the one written by $\txid_{1})$, 
then $\vi$ should contain the version of $\key_{1}$ written by $\txid_{1}$, 
contradicting the fact that $\txid_{4}$ reads the initial version of $\key_1$.
%We refer to the consistency model induced by $\ET_{\CP} \cap \ET_{\SI}$ as \emph{Weak Snapshot Isolation} ($\WSI$). 

As $\WSI$ is a weaker consistency model than $\SI$, we believe that $\WSI$ implementations would outperform known $\SI$ implementations.
Nevertheless, the two consistency models are very similar in that 
%Because of the similarity between these two consistency models, we believe that 
many applications that 
are correct under $\SI$ are also correct under $\WSI$. We give an example of such an application in \cref{sec:program-analysis}.


