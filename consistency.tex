\section{Consistency Models: Kv-stores}
\label{sec:cm}
We define what it means for a kv-store 
to be in a consistent state. Many different consistency models for
distributed transactions have 
been proposed in the literature
\cite{principle-eventual-consistency,rola,cops,redblue,PSI,clocksi},
capturing different trade-offs 
between  performance and application
correctness: examples range from  \emph{serialisability}, a strong
consistency model which only allows kv-stores 
obtained  from a serial execution of transactions
% reading the most up-to-date versions of a key 
with inevitable performance drawbacks, to  \emph{eventual consistency},  a weak consistency model
which imposes few conditions on the structure of a kv-store leading to
good performance but anomalous behaviour.
We define consistency models for our kv-stores,
by introducing the notion of 
\emph{execution tests} which specify whether a client is allowed to commit a transaction in a given 
kv-store. Each execution test induces a consistency model as the set of kv-stores obtained 
by having clients non-deterministically commit transactions so long as  the constraints 
imposed by the execution test are satisfied.
In what follows we explore a range of execution tests  associated with well-known consistency models in the literature. 
Later in \cref{sec:other_formalisms} we demonstrate that our execution test formulation of these consistency models are  equivalent to their established declarative definitions over abstract executions \cite{framework-concur} and dependency graphs \cite{adya}.


%
%
%Actually I dont't think I want any of this
%
%Examples range from \ to 


%For example, the consistency model known as 



%
%this sounds like intro/section 2 material.
%
%\emph{serialisability} which only allows kv-stores 
%obtained  from a serial execution of transactions, where transactions read the most up-to-date 
%versions of a key. Serialisability is a strong consistency model: it prevents 
%anomalous behaviours such as those 
%depicted in \cref{fig:anomalies}, discussed later in this Section. However, it has obvious performance drawbacks due to client 
%having to wait for the most up-to-date version of a key. At the other side of the spectrum, \emph{Eventual Consistency} imposes 
%few conditions on the structure of a kv-store: its implementations achieve very fast transaction processing, at the expenses 
%of allowing all the \emph{anomalies} from \cref{fig:anomalies}.

%Consistency guarantees of distributed databases describe
%what it means for distributed data to be consistent. 
%They have been formally described axiomatically via dependency graphs~\cite{adya-icde,adya}
%and abstract execution graphs~\cite{ev_transactions,framework-concur}. 
%We formalise the consistency guarantees of our centralised kv-stores by defining a 
%\emph{consistency model}. 
%A consistency model is a set of kv-stores capturing the possible outcomes 
%obtained when multiple clients commit several transactions each, 
%provided that the effects of such transactions comply with the consistency guarantees of the underlying consistency model. 
%To this end, we define consistency models induced by an \emph{execution test}.
%An execution test is a relation which determines whether a client may commit a transaction into a kv-store.  
%We formulate several well-known consistency models over our centralised kv-stores 
%by defining their corresponding execution tests. 
%Later in \cref{sec:other_formalisms} we demonstrate that our definitions over centralised kv-stores are equivalent 
%to their existing definitions over distributed databases.




%An execution test is a set $\ET$ of tuples of the form $(\mkvs, \vi, \fp, \mkvs', \vi')$,
%denoting that a client with view $\vi$ on kv-store $\mkvs$  may commit an atomic transaction 
%with fingerprint $\fp$, and obtain an updated kv-store \( \mkvs' \) and an updated view $\vi'$. 
%We often write
%$\ET \vdash (\mkvs, \vi) \csat \fp: ( \mkvs', \vi')$ for
%$(\mkvs, \vi, \fp, \mkvs', \vi') \in \ET$.

\begin{definition}
\label{def:execution.test}
%An \emph{execution test} is a set of tuples $\ET \subseteq \MKVSs \times \Views \times \Fingerprints \times \MKVSs \times \Views$ 
%such that for all $(\mkvs, \vi, \fp, \mkvs', \vi') \in \ET$, 
%$\vi \in \Views(\mkvs)$, $\vi' \in \Views(\mkvs')$, and  
%for any $\key \in
%\mkvs$ and $\val \in \Val$, if $(\otR, \key, \val) \in \fp $ then $	\mkvs(\key, \max{}_{<}(\vi(\key))) = \val   $.
An \emph{execution test} is a set of tuples $\ET \subseteq \MKVSs \times \Views \times \Fingerprints \times \MKVSs \times \Views$ 
such that for all $(\mkvs, \vi, \fp, \mkvs', \vi') \in \ET$: 
\begin{enumerate*}
	\item $\vi \in \Views(\mkvs)$ and $\vi' \in \Views(\mkvs')$; 
	\item $\cancommit \mkvs \vi \fp$; 
	\item $\vshift \mkvs \vi {\mkvs'} {\vi'}$; and 
	\item for all $\key \!\in\! \mkvs$ and $\val \!\in\! \Val$, if $(\otR, \key, \val) \!\in\! \fp $ then $	\mkvs(\key, \max{}_{<}(\vi(\key))) {=} \val   $.
\end{enumerate*}



\end{definition}
%
\noindent 
Intuitively, $(\mkvs, \vi, \fp, \mkvs', \vi') \in \ET$ means that, under the execution test $\ET$,
a client with initial view $\vi$ over a kv-store $\mkvs$ can commit a transaction with 
fingerprint $\fp$ to obtain the resulting kv-store $\mkvs'$ (\cref{def:updatekv} ) while shifting its view
to $\vi'$. We adopt the 
%more suggestive 
notation $\ET \vdash (\mkvs, \vi) \csat \fp: (\mkvs', \vi')$  to
capture this intuition. 
%The condition of 
Note that the last condition in \cref{def:execution.test} enforces the last-write-wins
policy~\cite{vogels:2009:ec:1435417.1435432}: 
a transaction always reads the most recent writes from the initial view \(\vi\).  
%The second condition states that a transaction is only allowed to update the view for those keys 
%that have been recorded in the fingerprint.  

The largest execution test is denoted by $\ET_{\top}$, where for all $\mkvs, \mkvs', \vi, \vi, \fp$: 
\[
	\cancommit[\ET_{\top}] \mkvs \vi \fp \defiff \mathsf{true}
	\qquad  \text{and} \qquad 
	\vshift[\ET_{\top}] \mkvs \vi {\mkvs'} {\vi'} \defiff \mathsf{true}
\] 
In \cref{sec:other_formalisms} we show that the consistency model induced by $\ET_{\top}$ 
corresponds to the \emph{Read Atomic} consistency model \cite{ramp}, a variant of \emph{Eventual 
Consistency} \cite{ev_transactions} for atomic transactions. 
%Later in this section we define several execution tests that induce well-known consistency models.
%%Note that at this initial stage \eqref{eq:read-external} and \eqref{eq:valid-view-update} are the only required conditions and execution tests are otherwise unrestricted. 
%%Further restrictions on execution tests are determined by the underlying consistency model, thus prescribing the consistency guarantees of the model.

We now explain how an execution test induces a consistency model. Given an execution test $\ET$, 
we define $\ET$-reductions which capture how a client $\cl$ may
interact with configurations. 
\begin{definition}[ET-reduction]
An $\ET$-reduction, $(\mkvs, \vienv) \toET{(\cl, \alpha)} (\mkvs', \vienv')$, is defined by
either 
%we define the $\ET$-trace as a sequence of $\ET$-reductions on configurations that a client
\begin{enumerate}
    \item $\alpha = \varepsilon$, $\mkvs' = \mkvs$ and $\vienv' = \vienv\rmto{\cl}{\vi}$ for some $u: \vienv(\cl) \sqsubseteq u$ --
	client $\cl$ shifts its view to a more up-to-date one, the label $\varepsilon$ denotes that 
	%there was no interaction between the client and the kv-store; or 
	there was no access to the kv-store; or
\item $\alpha = \fp$ for some $\fp$, and $\ET \vdash (\mkvs, \vi ) \csat \fp : (\mkvs', \vi')$, where $\mkvs' \in \updateKV[\mkvs, \vi, \fp, \txid]$ 
   for some $\txid \in \nextTxid(\cl, \mkvs)$, $\vienv' =
   \vienv\rmto{\cl}{\vi'}$ -  client $\cl$ 
	commits a transaction with fingerprint $\fp$.
\end{enumerate}
\ac{Not changing due to time constraints, but I believe the best thing to do is to change the type of execution tests to have a client identifier 
rather than $\mkvs'$, since this is determined by $\mkvs$ and $\cl$. In fact, I believe that the best we can do is to change execution tests to 
have the form $\ET \vdash (\mkvs, \vienv) {\csat}_{\cl} \fp : \vi'$; then one can lift this to a $\ET$-reduction in a style similar to monadic lifting.}
A finite sequence of $\ET$-reductions starting in an
initial configuration $\conf_{0}$ is called  an \emph{$\ET$-trace}. 
\end{definition}
Each $\ET$-trace  ends in a configuration $(\mkvs, \stub)$ where the 
kv-store $\mkvs$ is obtained as a result of several clients committing transactions under the 
execution test $\ET$. It therefore contributes to the consistency model induced by $\ET$, 
denoted as $\CMs(\ET)$.
%
%\begin{definition}[$\ET$-trace]
%\label{def:reduction}
%An \emph{action} $\alpha \in \Act$ is either of the form $(\cl, \varepsilon)$ or $(\cl, \fp)$, 
%where $\cl$ is a client and $\fp$ is a fingerprint. 
%Given an execution test $\ET$, the $\ET$-\emph{reduction relation},
%$\toET{} \subseteq \Confs \times \Act \times \Confs$, 
%is the smallest relation such that for all $\cl, \mkvs, \mkvs', \vienv, \fp, \vi', \vi''$ and $\vi = \vienv(\cl)$:
%%
%{
%\[
%\small
%\begin{array}{@{}l@{}}
%    \vi \sqsubseteq \vi'' 
%    \land \mkvs' \in \updateKV[\mkvs, \vi'', \fp, \cl]
%    \land (\mkvs, \vi'', \fp, \mkvs', \vi') \in \ET \\
%    \quad \implies
%    (\mkvs, \vienv) \toET{\hspace{-5pt}(\cl, \varepsilon)\hspace{-5pt}} 
%    (\mkvs, \vienv\rmto{\cl}{\vi''}) \toET{\hspace{-5pt}(\cl,\fp)\hspace{-5pt}} (\mkvs', \vienv\rmto{\cl}{\vi'})
%\end{array}
%\]
%}
%%
%Given an execution test $\ET$, an \emph{$\ET$-trace} is a sequence of $\ET$-reductions of the form $\conf_{0} \toET{\alpha_{0}} \cdots \toET{\alpha_{n-1}} \conf_{n}$. $\ET$-traces are ranged over by $\tau, \tau', \cdots$; 
%given a $\ET$-trace $\tau$, $\lvert \tau \rvert$ denotes the number of $\ET$-reductions in $\tau$, and 
%for $i=1,\cdots,n$, $\tau(i)$ denotes the $i$-th reduction of $\tau$.
%\end{definition}
%
%A \emph{consistency model} induced by $\ET$ is a set of kv-stores
%resulting from $\ET$-traces starting in an 
%initial configuration. 

\begin{definition}[Consistency Model]
\label{def:cm}
The \emph{consistency model} induced by an execution test $\ET$ is defined as 
\(
\CMs(\ET) \defeq 
\Set{\mkvs}[ 
\exsts{\conf_0 \in \Confs_0}
\conf_0 \toET{\stub}^{*} (\mkvs, \stub)
]
\).
%Given an execution test $\ET$,  
%the set of \emph{configurations induced by $\ET$},  $\confOf[\ET]$, is   given by: 
%\(
%\confOf[\ET] \defeq 
%\Set{\conf}[ 
%\exsts{\conf_0 \in \Confs_0}
%\conf_0 \toET{\stub}^{*} \conf
%]
%\).
%The \emph{consistency model} induced by $\ET$ is defined as:
%\( 
%\CMs(\ET) \defeq \Set{ \mkvs }[ (\mkvs, \stub) \in \confOf[\ET] ]
%\)
\end{definition}
%
%\noindent In~\cref{sec:mono-et}, we prove that consistency models are 
%\emph{monotonic}: 
%if  $\ET_1 \subseteq \ET_2$ then $\CMs(\ET_1) \subseteq \CMs(\ET_2)$.

Notice that, in the definition of $\ET$-traces, the two operations
performed by client, the view-shift and 
transaction commit, are decoupled. This is in contrast with what
happens in the operational semantics (\cref{sec:model}), 
where view-shifts and transaction commits are joined  together in a single transition of programs. 
The reason for this mismatch is best understood when looking at intended applications of 
$\ET$-traces and the operational semantics. The former are particularly useful when proving that a distributed 
protocol implements a given consistency model: in this case it is convenient to separate the operation of shifting a view from that of committing a transaction, 
as these two operations often take place separately in distributed transactional protocols. The latter is particularly useful when reasoning about transactional 
programs: treating view-shifts and transaction commits as a single transition reduces the number of interleavings in programs.
The $\ET$-traces and operational semantics are equally expressive as
the following theorem states. 
%any kv-store $\mkvs \in \CMs(\ET)$ can be obtained as a result of 
%executing some program $\prog$ under the execution test $\ET$, and vice versa.
\ac{One may wonder whether this difference in approach leads to a difference in expressive power between $\ET$-traces 
and the operational model: that is, if there exists a kv-store $\mkvs \in \CMs(\ET)$ that can never be obtained as a 
result of executing an arbitrary program $\prog$ under the execution test $\ET$. The next result shows that 
this is not the case.}
%We will prove shortly that this is 
%not the case: let us say that a $\ET$-trace  $\conf_{0} \toET{(\cl_{0}, \alpha_{0})} \cdots \toET{(\cl_{n}, \alpha_{n})} \conf_{n+1}$ is in \emph{normal form} if 
%whenever, for any $i=0, \cdots, n-1$, if $\alpha_{i} = \varepsilon$ then either $\cl_{i+1} = \cl_{i}$, and $\alpha_{i+1} = \fp$ 
%for some $\fp$. For any program $\prog$, we let $\interpr{\prog}_{\ET}$ be the set of 
%kv-stores reachable by executing $\prog$ under the execution test $\ET$.
%
%\begin{theorem}
%For any execution test $\ET$, and $\mkvs \in \CMs(\ET)$, there exists a 
%$\ET$-trace $\conf_{0} \toET{\stub}^{\ast} \conf$ in normal form such that 
%$\conf = (\mkvs, \stub)$.
%\end{theorem}

\begin{theorem}
	\label{thm:ettraces2sem}
	Let $\interpr{\prog}_{\ET}$ be the set of kv-stores reachable by executing $\prog$ under the execution test $\ET$. 
    Then for all $\ET$, $\CMs(\ET) = \bigcup_{\prog} \interpr{\prog}_{\ET}$.
	%$\CMs(\ET) = \Set{\mkvs}[\exsts{\mkvs_0, \vienv_0, \thdenv_0, \prog} (\mkvs_0, \vienv_0, \thdenv_0), \prog \toPROG{\stub}^{*} (\mkvs, \stub, \stub), \stub]$.
\end{theorem}

%\mypar{Compositionality}
%We examine the \emph{compositionality} of the consistency models induced by execution tests:  
%\ie given two execution tests $\ET_1, \ET_2$, does 
%$\CMs(\ET_1 \cap \ET_2) = \CMs(\ET_1) \cap \CMs(\ET_2)$ hold? 
%The monotonicity of execution tests guarantees that 
%%It is straightforward to show that the left-to-right direction holds:
% for all $\ET_1, \ET_2$, \( \CMs(\ET_1 \cap \ET_2) \subseteq \CMs(\ET_1) \cap \CMs(\ET_2) \). 
%However, the other direction \( \CMs(\ET_1) \cap \CMs(\ET_2) \subseteq \CMs(\ET_1 \cap \ET_2) \) does not hold for arbitrary consistency models.
%Consider the following:
%%
%\[
%\small
%\begin{array}{@{}l @{\hspace{2pt}} | @{\hspace{2pt}} l@{}}
%    \hline
%    \ET_1 & \ET_2 \\
%%    
%    \hline
%    (\mkvs_{0}, \vi_{0}) \csat\! \Set{(\otW, \key, 1)} {:} ( \mkvs_{\key}, \vi_{0})
%    &
%    (\mkvs_{0}, \vi_{0}) \csat\! \Set{(\otW, \key', 1)} {:} ( \mkvs_{\key'}, \vi_{0}) 
%    \vspace*{-7pt}\\\\
%% %   
%    (\mkvs_{\key}, \vi_{0}) \csat  \!\Set{(\otW, \key', 1)} {:} (\mkvs',\vi_{0}) 
%    &
%    (\mkvs_{\key'}, \vi_{0}) \csat \!\Set{(\otW, \key, 1)} {:} (\mkvs',\vi_{1}) 
%    \\
%\hline
%\end{array}
%\]%
%%
%with%
%%
%{
%\(
%\small
%\begin{array}[t]{l@{} l}
%    \mkvs_{\key} & = \mkvs_{0}[\key \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \_, \emptyset)] \\
%    \mkvs_{\key'} & = \mkvs_{0}[\key' \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \_, \emptyset)] \\
%    \mkvs' & = \mkvs[\key \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \_, \emptyset) 
%                ,\key' \mapsto (0, \txid_{0}, \emptyset) \lcat (1, \_, \emptyset)] \\
%\end{array}
%\)%
%}%
%%
%
%\noindent As both $\ET_1$ and $\ET_2$ allow a version with value $1$ to be written for 
%$\key, \key'$,  we have $\mkvs' \in \CMs(\ET_1) \cap \CMs(\ET_2)$. 
%However, $\ET_1$ and $\ET_2$ enforce a different order in which the writes on $\key, \key'$ must happen; 
%thus $\mkvs' \notin \CMs(\ET_1 \cap \ET_2)$. 
%
%In this example, compositionality fails because execution tests 
%enforced a particular order in which the updates must be committed, even though such updates 
%are non-conflicting: the kv-store obtained after committing such updates is independent of the commit order. 
%This observation is captured in the following definition: 
%
\input{\RootPath/exec-table.tex}
%
%
%\begin{definition}
%\label{def:et-comm}
%Two fingerprints $\fp_1$ and $\fp_2$ are \emph{conflicting} 
%iff there exists $\key$ such that 
%$(\otW, \key, -) \in \fp_1 \land (\otW, \key, -) \in \fp_2$. 
%An execution test $\ET$ is \emph{commutative}, written $\com{\ET}$, if 
%for all \( \mkvs, \mkvs', \vienv, \vienv',\vienv''\), distinct clients \( \cl_1, \cl_2 \), non-conflicting fingerprints \( \fp_1, \fp_2  \) and \( \vi_1, \vi_2 \in \Views(\mkvs) \):% 
%%
%{%
%\[
%\small
%\begin{array}{@{}r @{\hspace{10pt}} l @{}}
%	\text{if} &  
%	(\mkvs, \vienv) \toET{(\cl_1, \fp_1)} 
%	\stub \toET{(\cl_2, \fp_2)} (\mkvs', \vienv') \\
%	\text{then} & (\mkvs, \vienv) \toET{(\cl_2, \fp_2)}
%    \stub \toET{(\cl_1, \fp_1)} (\mkvs', \vienv'') \\
%    & {} \land \vienv''(\cl_2) \viewleq \vienv'(\cl_2)
%\end{array}
%\]%
%}%
%\end{definition}
%
%To guarantee the compositionality of two execution tests $\ET_1, \ET_2$, we 
%require at least one of those to be commutative, say $\ET_1$. The main idea 
%is the following: fix a $\ET_1$-trace $\tau_1$ and a $\ET_2$-trace $\tau_2$, both terminating in a configuration 
%of the form $(\mkvs, \stub)$; then we construct a $(\ET_1 \cap \ET_2)$-trace terminating 
%in a configuration of the same form by re-ordering he sequence of 
%reductions of $\tau_1$ as to match exactly the sequence of 
%reductions of $\tau_2$. 
%In \cref{sec:et-comp}, we show that if $\ET_1$ is commutative, 
%we can indeed re-order the sequence of reductions in the 
%$\ET_1$-trace leading to a trace $\tau_1'$ such that $(\lvert \tau'_1 \rvert = \lvert \tau_2 \rvert)$\footnote{In fact, 
%to ensure that $\lvert \tau_1' \rvert = \lvert \tau_2 \rvert$ we require to further manipulate 
%$\tau_1$ prior to re-ordering its sequence of $\ET_1$-reductions.}, 
%and for any 
%$i=1,\cdots, \lvert \tau_1'\rvert$, the pre and post kv-store of $\tau_1'(i)$,
% coincide with the action, pre and post kv-store 
%of $\tau_2(i)$.
%
%
%Commutativity alone does not ensure that, for $i=1,\cdots,\lvert \tau_2 \rvert$ the 
%pre-views and post-views of $\tau_1'(i)$ 
%match the pre-views and post-views of the $\tau_2(i)$, which is necessary to show 
%that $\tau_1'$ and $\tau_2$ can be recast as a $(\ET_1 \cap \ET_2)$-trace. 
%In \cref{sec:et-comp} we present three other basic requirements to be 
%satisfied by $\ET_1$ and $\ET_2$, that guarantee that $\tau'_1(i)$ and 
%$\tau_2(i)$ agree on the pre-views and post-views for $i=1,\cdots, \lvert \tau_2 \rvert$. 
%The first two of these requirements,  \emph{no blind writes} and \emph{minimum footprint}, 
%ensure that the pre-views of the reductions $\tau_1'(i)$ and $\tau_2(i)$ match, 
%while the third requirement, which we call \emph{monotonic post-views}, 
%guarantees that the post-views of the reductions $\tau_1'(i)$ and $\tau_2(i)$ 
%match. 
% 
%\begin{theorem}[Compositionality]  
%\label{thm:compositional}   
%For all $\ET_1, \ET_2$ with no blind writes, minimum footprints and monotonic post-views: 
%if $\com{\ET_1}$, 
%then $\CMs(\ET_1 \cap \ET_2) {=} \CMs(\ET_1) \cap \CMs(\ET_2)$;
%if $\com{\ET_1} \land \com{\ET_2}$, then $\com{\ET_1 \cap \ET_2}$.
%\end{theorem}
%
%Most of the execution tests associated with well-known consistency models (introduced shortly)
%can be tweaked to satisfy no-blind writes, minimum footprints and monotonic post-views 
%without altering their semantics. However, some of these execution tests
%are inherently non-commutative.


\subsection{Example Execution Tests}
\label{subsec:cm_examples}
We give several examples of execution tests to define well-known consistency models.
Later in \cref{sec:other_formalisms} we show that our definitions  are  equivalent to existing definitions in the literature defined using abstract executions \citep{principle-eventual-consistency,framework-concur,surech-session-guarantee}.
Recall that the snapshot property and the last write wins are hard-wired into our model. 
%Consistency models that we can capture using execution tests ensure that transactions execute atomically, and that they read versions from an atomic  snapshot of the kv-store, determined using the last write wins policy. 
As such, we can only model consistency models that satisfy these two constraints. 
Although this forbids us to express interesting consistency models such as \emph{Read Committed}, we are able to express a large variety of consistency models employed by distributed kv-stores.
%
%
%We now need to say something about
%assumptions:
%\begin{itemize}
%\item atomic transactions, interleaving
%\item last write wins
%\item atomic visibility.
%\end{itemize}
%We need to describe the models we can define  and briefly the models we
%cannot define  but see conclusions for some thoughts. We also highlight a new consistency
%model that seems to sit intriguingly between ... and ... 
%
%---------------

Recall from \cref{def:execution.test} that an execution test $\ET$ includes tuples of the form $(\mkvs,\vi, \fp, \mkvs', \vi')$ such that $\vshift \mkvs \vi {\mkvs'} {\vi'}$ and $\cancommit \mkvs \vi \fp$ hold. 
%For each such tuple, the views $\vi$ and $\vi'$ identify the set 
%of versions that a client must see before and after committing a transaction 
%with fingerprint $\fp$, respectively.
%%%The purpose of
%%%such execution tests is  to constrain the views $\vi$ and $\vi'$ to
%%%those that make sense for a particular consistency model. 
%We study 
%two styles of execution test: those that constrain the resulting view
%$\vi'$ relative to the initial view $\vi$ which are comparatively straightforward; and those that constrain the initial view $\vi$ which
%are less straightforward as they require closure properties on the
%so-called visible transactions of a view. 
%
In what follows we define $\vshiftname$ and $\cancommitname$ for several consistency models. To do this, we first need several auxiliary definitions. 

\mypar{Prefix Closure}
Given a kv-store $\mkvs$ and a view $\vi$, the {\em set of visible
transactions} is defined as follows, containing those transactions whose updates are known to a
client with view $\vi$:
{%
\displaymathfont
\begin{align*}
\Tx[\mkvs, \vi] & \defeq
\Set{\wtOf[\mkvs(\key, i] }[ i \in \vi(\key)]
\end{align*}
}%
%
%Conversely, given a kv-store $\mkvs$ and set
%of visible transactions $\txidset$, it is possible to recover a view
%of the client by%
%
%\vspace{-7pt}
%{%
%\displaymathfont
%\begin{align*}
%    \getView[\mkvs, \T] & \defeq \lambda \key. \Set{i }[
%\wtOf[\mkvs(\key, i)] \in \T]
%\end{align*}
%}%
%This connection between views and sets of transactions enables us to express concisely 
%the prefix-closure of a view with respect to a dependency relation $\rel$ between 
%transactions: given $R \subseteq \TxID \times \TxID$, the closure of 
%a view $\vi$ with respect to the kv-store $\mkvs$ and the relation $R$
%is defined as%
%
%\vspace{-7pt}
%{%
%\displaymathfont
%\begin{align*}
%\func{closure}[\mkvs, \vi, R] & \defeq \getView[\mkvs, (R^{-1})^{\ast}(\Tx(\mkvs, \vi))]
%\end{align*}
%}%
%If $\vi = \mathsf{closure}(\mkvs, \vi, R)$, then we say that $\vi$ is \emph{closed} with 
%respect to $\mkvs$ and $R$, written \( \closed[\mkvs,\vi,\rel]\).
%%The view $\vi$ is said to be closed with respect to $\mkvs$ and $R$, denoted 
%%$\closed(\mkvs, \vi, R)$, if and only  if $\vi = \mathsf{closure}(\mkvs,\vi,R)$.
%
%
Given relation on transactions, $\rel \subseteq \TxID \times \TxID$, we say that a view $\vi$ is closed with respect to a kv-store $\mkvs$ and $\rel$, written $\closed[\mkvs,\vi,\rel]$, iff:  
{%
\displaymathfont
\begin{align*}
	\closed[\mkvs,\vi,\rel]
	\defiff
	\Tx(\mkvs, \vi) {=} 
	(\rel^*)^{-1} \Tx(\mkvs, \vi)
\end{align*}
}%
That is, if transaction $\txid$ is visible in $\vi$, then all transactions that are $\rel^*$-before $\txid$ are also visible in $\vi$.

\mypar{Dependency Relations}
We define transaction dependency relations for kv-stores inspired by dependency graphs due to Adya \cite{adya}, and  introduced in \ref{sec:other_formalisms}.
Given a kv-store $\mkvs$, a key $\key$ and 
indexes $i,j$ such that  $0 \leq i < j < \abs{ \mkvs(\key) }$, 
if there exists $\txid_i, \T_i, \txid$ such that 
$\mkvs(\key, i)  {=} (\stub, \txid_{i}, \T_{i})$, $\mkvs(\key,j) {=} (\stub, \txid_{j}, \stub)$
and $\txid \in \T_{i}$, 
then we say that there is:
\begin{enumerate} 
\item a \emph{Write-Read} dependency over 
$\key$ from $\txid_{i}$ to $\txid$, written $(\txid_{i},\txid) \in \WR_{\mkvs}(\key)$;
\item a \emph{Write-Write} dependency over $\key$ from $\txid_{i}$ to $\txid_{j}$, 
    written $(\txid_{i},\txid_{j}) \in \WW_{\mkvs}(\key) $; and 
\item a \emph{Read-Write} anti-dependency from $\txid$ to $\txid_{j}$, provided that 
$\txid \neq \txid_{j}$, written $(\txid,\txid_j) \in \RW_{\mkvs}(\key)$.
\end{enumerate}
\noindent \cref{fig:dependencies} illustrates an example kv-store and its dependencies.
%
\pg{----------

can we squeeze in a diagram showing one ke with WW, WR and RW
illustrated? It would help, it's what we draw all the time. Actually,
these 

------------
\ac{There is one in Section 5}
}
%
\pg{
------I realise I now don't understand this next bit fully , we need to
discuss-------
\ac{The best way to understand this from a theoretical point of view is 
by induction/coinduction. Adya's specifications may be thought of as 
coinductive specifications: for example, serialisability is THE LARGEST 
set of dependency graphs  SER such that whenever G $\in$ SER, then 
G has no cycles. Execution tests instead correspond to inductive definitions: 
SER is the SMALLEST SET such that the initial kv-store is in SER, and if 
K' is in SER and K can be obtained by committing a transaction in K' using  
a complete view (one with all versions), then K is in SER.}

}
%
{\color{blue} 
\textbf{Azalea: }I don't think this is the right place for the following:\\
As we will see shortly, we use dependencies in a way fundamentally 
different from Adya's dependency graphs \cite{adya}, 
a well-known mathematical structure used for specifying consistency models that is introduced 
formally in \cref{sec:dep_graphs}.
Adya's specifications are of a declarative nature: dependency models are specified by 
placing constraints on the structure of dependency graphs admitted by a consistency model, using the dependency graph counterpart 
of the relations introduced above. 
In contrast, execution tests define consistency models in a constructive way. Dependencies 
over kv-stores are used by execution tests to restrict the views of clients (i.e the sets of versions that clients must see) before or 
after committing a transaction. The consistency model induced $\ET$ corresponds 
to the set of kv-stores that can be constructed by allowing clients to commit transactions only 
when the conditions on such views are respected. This approach is agnostic of the structure 
of kv-stores contained in $\CMs(\ET)$.
%is constructed by onl
%introduced in \ref{sec:}
%Although we define transaction dependencies for kv-stores  in a style 
%similar to dependency graphs \cite{adya}, their use  is fundamentally different.  
%Definitions of consistency 
%models on dependency graphs are declarative: 
%we will see in \cref{sec:other_formalisms} 
%they impose 
%constraints on the structure of a kv-store. On the other hand, 
%execution 
%tests use dependencies between transactions to restrict 
%the view of clients before and after committing a transaction.  
%Whereas dependency graphs can be used to define a consistency model 
%in terms of what the permissible structure of kv-stores is, we use execution tests
%to define how such kv-stores can be constructed, in a way that is agnostic of their structure.
%
%-------------
}

We now proceed by defining \vshiftname and \cancommitname for several well-known consistency models.
%We give example execution tests in
%~\cref{fig:execution.tests}. 
%We start by looking at  execution tests for defining  session
%guarantees, then we move to execution tests which capture stronger
%consistency models. 
%%%%In that table we 
%%%%commit an abuse of notation and let $\closed(\mkvs, \vi, R)$ be the execution test 
%%%%$\{(\mkvs, \vi, \fp, \mkvs', \vi') \mid \closed(\mkvs, \vi, R)\}$.
%%%
%%%%Following \cite{distrprinciples}, we distinguish between
%%%%client- and data-centric consistency models.
%%%%Many of the execution tests we present
%%%%We now give examples of execution tests in~\cref{fig:execution.tests},
%%%%where the associated consistency models for kv-stores correspond to
%%%%widely adopted consistency guaranteees for distributed databases.
%%%%Following \cite{distrprinciples}, we distinguish between
%%%%client- and data-centric consistency models: 
%%%%the former constrain the client views; 
%%%%the latter impose conditions on the structure of the kv-store.  
%%%%In \cref{fig:anomalies} we give illustrative
%%%%examples of kv-stores allowed/disallowed by our
%%%%consistency models.
%%%
%%%%\sx{Explain functions used in the table}

\ac{
\pg{
---------------------

Below you are talking about clients all the time. I think the ETs
should be indexed by clients.

--------------------
}
I agree, but there is no time for that.
}





\subsubsection{Monotonic Reads $(\MR)$}
%This consistency model states that a client
%cannot lose information from the view. It  
%can only see increasingly more up-to-date versions from a kv-store. 
This consistency model states that when committing a client
cannot lose information in that it can only see increasingly more up-to-date versions from a kv-store.
This prevents, for example, the kv-store of \cref{fig:mr-disallowed},
since client $\cl$ first reads the latest version of $\key$ in $\txid_{\cl}^{1}$, 
and then reads the older, initial version of $\key$ in $\txid_{\cl}^{2}$.  
As such, the $\vshiftname_{\MR}$ predicate in \cref{fig:execution_tests} ensures that clients  can only extend their views. 
When this is the case, clients can then \emph{always} commit their transactions, and thus $\cancommitname_{\MR}$ is simply defined as $\true$. 
%Note that the execution test $\ET_{\MR}$ can also be expressed as a closure 
%property of the resulting view. 
%Let $\rel_{\MR}(\mkvs, \vi) \defeq \Set{(\wtOf[\mkvs(\key, i), \txid] }[ \key \in \Keys \wedge i \in \vi(\key) \wedge \txid \in \mkvs]$; 
%%given \(\mkvs, \vi\) before committing a transaction and $\mkvs',
%%\vi'$ after.
%The predicate $\closed[\mkvs', \vi', R_{\MR}(\mkvs, \vi)]$ states that all the versions included in $\vi$ on $\mkvs$ 
%must also be included in $\vi'$ on $\mkvs'$: that is,  $\vi
%\sqsubseteq \vi'$ and  hence 
%$\ET_{\MR} \defeq \Set{(\mkvs, \vi, \opset, \mkvs', \vi') }[
%\closed[\mkvs', \vi', \rel_{\MR}(\mkvs, \vi)]]$.
%
\pg{------------------

In above, has  $t \in K$ been defined anywhere? Is it just the writes in K or
is it the reads and writes in K? I think both reads and writes. 
 I have not checked this closure condition.

------------------
\ac{It's defined right after the definition of kv-store, Def 3.1}
}
%

%\subsubsection{Monotonic Writes $(\MW)$}
%This consistency model states that if a client $\cl$ sees 
%a version \( \key \) that was written by another client $\cl'$, 
%then it must see all versions of \( \key \) that were 
%previously written by $\cl'$: in other words, 
%the view of the client $\cl$  in a kv-store $\mkvs$ must be closed 
%with respect to the relation $\SO \cap \WW_{\mkvs}$, 
%before $\cl$ can commit a transaction.
%%
%%whenever a view includes a version for a key \( \key \) 
%%that was written by a client $\cl$,
%%then the view must include all versions for the key \( \key \) that were previously written by $\cl$. 
%This prevents, for example, the kv-store of \cref{fig:mw-disallowed}, as
%transaction $\txid$ reads the third version of $\key_2$ 
%with value $\val_3$ written by client $\cl$, 
%but it does not read, hence does not see, the second version of $\key_1$
%with value $\val_1$ and previously written by the same client via transaction \( \txid^1_{\cl} \)
%who also have written the second version of \( \key_2 \).
%%We can enforce monotonic writes by requiring the view of a client, prior to committing 
%%a transaction, to be closed with respect to the session relation $\SO \cap \WW_{\mkvs}$.
%%\ac{Why the reflexive closure? \sx{New view should include the new transaction.}}
%%The execution test $\ET_{\MW}$  ensures that, prior to executing a transaction,
%%the set of versions included in the view of the client are write 
%%prefix-closed with respect to the relation $\SO\rflx$.

\subsubsection{Read Your Writes $(\RYW)$}
This consistency model states that a client must always see all the versions written by the client itself. 
The $\vshiftname_{\RYW}$ predicate thus states that after executing a transaction, a client 
%the resulting view 
contains all the versions it wrote in its view. This ensures that such versions will be included in the view of the client 
when committing future transactions.
Note that under $\RYW$ the kv-store in \cref{fig:ryw-disallowed} is prohibited as
the initial version of $\key$ holds value $\val_0$ 
and client $\cl$ tries to increment the value of $\key$ twice.  
For its first transaction \( \txid_{\cl}^1\), it reads the initial value $\val_0$ and then writes a new version with value $\val_1$. 
For its second transaction \( \txid_{\cl}^2\), it reads the initial value $\val_0$ again and write a new version with value $\val_1$.
The $\vshiftname_{\RYW}$ predicate rules out this example by requiring that
the client view, after it commits the transaction  \(\txid_{\cl}^{1}\), includes the version it wrote.  
When this is the case, clients can always commit their transactions, and thus $\cancommitname_{\RYW}$ is simply $\true$.

The $\MR$ and $\RYW$ models together with \emph{monotonic writes} (\MW) and \emph{write follows reads} (\WFR) models  are collectively known as \emph{session guarantees}. 
Due to space constraints, we omit the definitions associated with $\MW$ and $\WFR$, and refer the reader to the accompanying technical appendix. 



%The execution test $\ET_{\RYW}$ can also be expressed 
%as a closure property of the resulting view.
%%%%don't say this, it's not in the concepts of the ET:  after the
%%%%transaction commit: 
%Given $\mkvs, \mkvs'$, let $\txid_{\mkvs}^{\mkvs'}$ be a transaction included in $\mkvs'$ 
%but not in $\mkvs$. For our purposes, $\txid_{\mkvs}^{\mkvs'}$ is uniquely determined: 
%in fact, we have that $\mkvs' = \updateKV(\mkvs, \vi, \fp, \txid_{\mkvs}^{\mkvs'})$ for some $\vi$ and $\fp$
%and it represents the last transaction that committed in $\mkvs'$.
%%$\mkvs' \setminus \mkvs$ be the set of transactions appearing 
%%in $\mkvs'$ but not in $\mkvs$; note that 
%%%in tuples of the form 
%%%$(\mkvs, \vi, \fp, \mkvs', \vi')$ taken from execution tests, $\mkvs' \setminus \mkvs$ 
%%in our operational model this set is a singleton set $\Set{\txid}$ where $\txid$ is the 
%%%newly committed transaction.
%%that committed when updating the kv-store from $\mkvs$ to $\mkvs'$; 
%%For a given set of transactions $\txidset$, let 
%Let $\rel_{\RYW}(\txid) \defeq \Set{(\txid', \txid) }[ \txid \in \T \land (\txid', \txid) \in \SO\rflx ]$. 
%Then the predicate $\closed[\mkvs', \vi', \rel_{\RYW}(\txid_{\mkvs}^{\mkvs'})]$ states that a 
%view $\vi'$ includes all the writes performed by the same client that committed the transaction $\txid$ in $\mkvs'$: 
%$\ET_{\RYW} \defeq \Set{(\mkvs, \vi, \fp, \mkvs', \vi') }[ \closed[\mkvs', \vi', R_{\RYW}(\txid_{\mkvs}^{\mkvs'})]]$.
%%The definition for \( \ET_{\RYW} \) given in \cref{fig:execution-tests} is equivalent.
%%Note that if \( \MR \) is assumed \( \RYW \) can be simplified to 
%%\( \fora{\txid \in \mkvs' \setminus \mkvs, \key,i} \wtOf[\mkvs'(\key,i)] \implies i \in \vi'(\key)\):
%%that is, the view \( \vi' \) after \( \txid \) commits should include
%%the new versions written by \( \txid \).

\pg{------------------------RYW----------

I always find the words quite difficult. Decide whether you are going
to say the client sees or the client observes a version. I believe
this means that the version is in the client view (seomewhere this
should be stated). But in this case I don't quite know what this
means becuase the client view could be the u or the u', it actually
means the u' but you wouldn't know from the words and actually I would
expect it to be the u from the words.


I have not read the closure bit very much. Just to simplify, can you
use the predicate closed (K', u', SO? (K'/K))? 

Can you reword `the newly committed transaction' as we don't really
have our hands on this for hthis definition although I know it's in
the operational rule?

------------------------



----------------------WFR---------

Ok, now you are talking about transactions seeing, when previously you
were talking about clients seeing. I guess fine you did explain it in
MW (I now realise) but it's all very complicated and I wonder if it
can be simplified. 

----------------------------------
}



\input{\RootPath/anomalies-fig.tex}

%\subsubsection{Write Follows Reads $(\WFR)$}
%This consistency model states that, prior to committing a transaction, 
%if a client $\cl$ sees a version on a key $\key$ written by some
%client $\cl'$ (possibly equal to $\cl$), then it must also see the versions of $\key$ previously read by $\cl'$ (in $\SO\rflx$ relation). 
%The execution test $\ET_{\WFR}$ models exactly this condition.
%The kv-store of \cref{fig:wfr-disallowed} is disallowed by $\ET_{\WFR}$,
%since transaction $\txid$ reads a version written by $\cl$ but
%not a version previously read by $\cl$.
%%The execution test $\ET_{\WFR}$ ensures
%%that a view includes all versions previously read by a client 
%%if the view already includes a write from that client. 
%
%\sx{A cite here \cite{surech-session-guarantee} who mentions composition of 4 session guarantees. 
%    \cite{principle-eventual-consistency} mentions causal consistency is combination of session guarantees,
%    yet they only define 3 types of session guarantees.
%}
%\sx{ Sessions to CC cite \cite{principle-eventual-consistency} }


{\color{blue} 
\textbf{Azalea: } This is where I got to}

\subsubsection{Causal Consistency $(\CC)$}
Causal consistency strengthens the four session guarantees above by requiring 
that if a client sees a version 
$\ver$ prior to committing a transaction, then it must also see the versions 
from which $\ver$ depends.
If $\txid$ is the writer of $\ver$, then 
$\ver$ clearly depends from any version that $\txid$ reads. 
As for sessions, if $\ver$ is, or it depends from, a version $\ver'$ accessed by 
some client $\cl$, then it also depends from any version that was previously 
either read or written by $\cl$. The condition $\closed(\mkvs, u, \SO \cup \WR_{\mkvs})$ 
in Figure \ref{fig:execution_tests} captures exactly this constraint. 
Note that this condition implies both monotonic writes and write follows reads: 
given a kv-store $\mkvs$ and view $\vi$ such that 
$\closed(\mkvs, \vi, \SO \cup \WR_{\mathsf{k}})$,
then it is immediate to observe that $\closed(\mkvs, \vi, \SO \cap \WW_\mkvs)$, 
and $\closed(\mkvs, \vi, \WR_{\mkvs};\SO\rflx)$. We let $\ET_{\CC} = 
\{(\mkvs, \vi, \fp, \_, \_) \mid \closed(\mkvs, \vi, \SO \cup \WR_{\mkvs})\} \cap \ET_{\MR} 
\cap \ET_{\RYW}$, and we observe that $\ET_{\CC} \subseteq \ET_{\MR} \cap \ET_{\MW} 
\cap \ET_{\RYW} \cap \ET_{\WFR}$. This is in accordance with the result from 
\citeN{session2causal}, which states that the four session guarantees are a necessary, but 
not sufficient, condition for achieving causal consistency.
%Causal consistency is defined by requiring that views of clients, 
%prior to executing a transaction, are closed with respect to the causal dependencies 
%of transactions; we will define causal dependencies of transactions shortly.
%\citeN{session2causal} proved that causal consistency for  dependency graphs
%is the intersection of the four \emph{session guarantees} \(\MR\), \(\MW\), \(\RYW\) and \(\WFR\). 
%However, this result holds in a setting where replicas are not abstracted from the state of the system, and 
%causal consistency is specified in terms of the state of all replicas
%rather than in terms of the client views.
%If causal consistency were to be defined in terms of clients views, as
%in our case, then it is necessary but not sufficient to 
%ensure that the four session guarantees are satisfied: an execution test inducing causal consistency must 
%be included in $\ET_{\MR} \cap \ET_{\MW} \cap \ET_{RYW} \cap
%\ET_{\WFR}$.
%
%-----not touched this para, out of time---------
%
%In practice, causal dependencies of transactions must include the session order ($\RYW$ requires that 
%a transaction potentially depends on previous transactions executed by the same client) and 
%write-read dependencies (a transaction reading a version for some key $\key$ potentially depends from the transaction 
%that wrote such a version); obviously, causal dependencies must also be transitively closed. 
%
%By requiring a view of $\vi$ that is closed with respect to the relation $(\SO \cup \WR_{\mkvs})$ in $\mkvs$, 
%before executing a transaction, we impose that a client must observe all the causal dependencies of the 
%versions it reads. The execution test $\{(\mkvs, \vi, \_, \_, \_) \mid \closed(\mkvs, \vi, \SO \cup \WR_{\mkvs})\}$ is
%included in $\ET_{\MW} \cap \ET_{\WFR}$. 
For example, the kv-store of 
\cref{fig:wr-wfr-allowed-but-cc} is allowed by the four session guarantees, but it is disallowed by 
causal consistency: in there, the version of key $\key_3$ carrying value $\val_3$ depends from the version 
of key $\key_1$ carrying value $\val_1$. However, transaction $\txid$ must have been committed from 
a client whose view included $\val_3$, but not $\val_1$.
%We define causal consistency as $\ET_{\CC} = \{(\mkvs, \vi, \_, \_, \_) \mid \closed(\mkvs, \vi \SO \cup \WR_{\mkvs})\} 
%\cap \ET_{\MR} \cap \ET_{\RYW})$: observe that this definition of $\ET_{\CC}$ is included in the execution 
%test for the four consistency guarantees, in accordance with the
%result from \citeN{session2causal}.

\ac{
----------CC-----------

First sentence incomprehensible.

Comment about intersection of the four sessions is, I assume, about
dependency graphs.


--------------------
}

%
%The correctness of this definition depends on the fact that  their model of transactions assumed the 
%knowledge of a total order according to which transactions commit. 
%Yet it is \textbf{not} the case \( \ET_\CC = \ET_{\MR} \cap \ET_{\MW} \cap \ET_{\RYW} \cap \ET_{\WFR}\) here.
%%One would expect the execution test for causal consistency to be exactly 
%%the intersection of the execution tests for the individual session guarantees: 
%%$\ET_{\MR} \cap \ET_{\MW} \cap \ET_{\RYW} \cap \ET_{\WFR}$. .
%First, because $\ET_{\MW}$ and $\ET_{\WFR}$ have been 
%defined in terms of closure properties over the view of a client before committing a transaction, with respect 
%to two relations $\rel_{\MW} = \SO \cap \WW_{\mkvs}$ and $\rel_{\WFR}$ respectively, while to build an execution test that composes the two 
%consistency guarantees it requires that the view of a client prior to executing a transaction is 
%closed simultaneously with respect to $\rel_{\MW}$ and $\rel_{\WFR}$, that is, $\closed[\mkvs,\vi,\rel_{\MW} \cup \rel_{\WFR}]$. 
%Second, causal consistency intuitively requires that 
%if a view includes a version hence the writer \( \txid \) of the version, 
%it must include any versions that were written by transactions that \( \txid \) depends on.
%These \emph{dependencies} between transactions are given by \( \SO \) and \( \WR \) relations.
%Note that the closure under \( \SO \cup \WR \) is stronger than under \( \rel_{\MW} \cup \rel_{\WFR} \),
%that is, for any \( \mkvs,\vi \), \( ( \vi = \closed[\mkvs,\vi,\SO\cup\WR_\mkvs] ) \implies ( \vi = \closed[\mkvs,\vi,\rel_{\MW} \cup \rel_{\WFR}] ) \).
%Therefore, the definition of causal consistency is given in \cref{fig:execution-tests}:
%it states that the view before committing a transaction must be closed with respect to 
%causal dependencies of transactions; and the view after committing guarantees \( \MR \) and \( \RYW \). 
%%Let $\ET_{\MR+\WFR} = \Set{(\mkvs, \vi, \fp, \mkvs', \vi')}[ \closed[\mkvs, \vi, \rel_{\MW} \cup \rel_{\WFR}]]$. 
%%\cref{fig:wr-wfr-allowed-but-cc} shows an example for $\CMs[\ET_{\MW} \cap \ET_{\RYW}] \neq \CMs(\ET_{\MW+\WFR})$,
%%where the last transaction \( \txid \), by a client differs from \( \cl \) and \( \cl' \), 
%%is allowed to committed under \( \MW \) and \( \WFR \) but not \( \MW + \WFR \), given that
%%\( \txid_{\cl}^1 \toEDGE{\SO} \txid_{\cl}^2 \toEDGE{\WR_\mkvs} \txid_{\cl'}^1 \toEDGE{\SO} \txid_{\cl'}^2 \).
%Note that the same argument of intersecting execution tests 
%would apply to the session guarantees $\MR$ and $\RYW$,
%however, in this particular case we obtain that $\ET_{\MR+\RYW} = \ET_{\MR} \cap \ET_{\RYW}$.
%%The execution test for causal consistency is therefore 
%%given by $\ET_{\MR+\RYW} \cap \ET_{\MR} \cap \ET_{\RYW}$, which is equivalent to the one in
%%\cref{fig:execution.tests}: 
%
%\ac{
%Causal consistency has been defined in the literature~\cite{session2causal} 
%as the conjunction (composition) of the four \emph{session guarantees} \(\MR\), \(\MW\), \(\RYW\) and \(\WFR\). 
%One would expect the execution test for causal consistency to be exactly 
%the intersection of the execution tests for the individual session guarantees: 
%$\ET_{\MR} \cap \ET_{\MW} \cap \ET_{\RYW} \cap \ET_{\WFR}$. Yet it is not the case.
%Because $\ET_{\MW}$ and $\ET_{\WFR}$ have been 
%defined in terms of closure properties over the view of a client before committing a transaction, with respect 
%to two relations $\rel_{\MW} = \SO$ and $\rel_{\WFR}$ respectively, while to build an execution test that composes the two 
%consistency guarantees it requires that the view of a client prior to executing a transaction is 
%closed simultaneously with respect to $\rel_{\MW}$ and $\rel_{\WFR}$, that is, it is closed with respect to 
%$\rel_{\MW} \cup \rel_{\WFR}$. Let 
%$\ET_{\MR+\WFR} = \Set{(\mkvs, \vi, \fp, \mkvs', \vi')}[ \closed[\mkvs, \vi, \rel_{\MW} \cup \rel_{\WFR}]]$. 
%\cref{fig:wr-wfr-allowed-but-cc} shows an example for $\CMs[\ET_{\MW} \cap \ET_{\RYW}] \neq \CMs(\ET_{\MW+\WFR})$,
%where the last transaction \( \txid \), by a client differs from \( \cl \) and \( \cl' \), 
%is allowed to committed under \( \MW \) and \( \WFR \) but not \( \MW + \WFR \), given that
%\( \txid_{\cl}^1 \toEDGE{\SO} \txid_{\cl}^2 \toEDGE{\WR_\mkvs} \txid_{\cl'}^1 \toEDGE{\SO} \txid_{\cl'}^2 \).
%In theory, the same argument would apply to the session guarantees $\MR$ and $\RYW$
%however, in this particular case we obtain that $\ET_{\MR+\RYW} = \ET_{\MR} \cap \ET_{\RYW}$. 
%The execution test for causal consistency is therefore 
%given by $\ET_{\MR+\RYW} \cap \ET_{\MR} \cap \ET_{\RYW}$, which is equivalent to the one in
%\cref{fig:execution.tests}: it states that the view before committing a transaction must be closed with respect to 
%causal dependencies of transactions; and the view after committing guarantees \( \MR \) and \( \RYW \).
%}

\subsubsection{Update Atomic $(\UA)$}
This consistency model has been proposed in~\cite{framework-concur} 
and implemented in \cite{rola}.
$\UA$ disallows concurrent transactions writing to the same key,
a property known as \emph{Write-Conflict Freedom}:  
when two transactions want to write to the same key, one must see the version 
written by the other.
This prevents the kv-store of \cref{fig:ua-disallowed},
as $\txid, \txid'$ concurrently increment the initial version of $\key$ by $1$.
%Note that $\UA$ generalises $\RYW$: unlike $\RYW$, $\UA$ does not require $\txid, \txid'$ to be executed by the same client.
$\ET_\UA$ ensures write-conflict freedom by allowing a client to write to key $\key$
only if its view includes all versions of $\key$. Because a view always includes the 
initial version of a key, this is equivalent to require that the view of a client wanting 
to commit a transaction is \emph{suffix-closed} with respect to the relation $\WW(\key)$, 
or equivalently it is prefix-closed with respect to $\WW^{-1}(\key)$, for any key $\key$ written in the 
fingerprint $\fp$.
\pg{
--------not done from here----------------------
}

\subsubsection{Parallel Snapshot Isolation $(\PSI)$} 
This consistency model has been defined as the conjunction of the guarantees provided by $\CC$ and $\UA$~\cite{framework-concur}. 
%As for the case of causal consistency, we cannot define 
Unfortunately, in our framework it is not the case that $\ET_{\PSI}$ as $\ET_{\CC} \cap \ET_{\UA}$. First,  
this execution test only mandates that views before committing transactions are individually closed with respect to 
the relations $R_{\CC}$ and $R_{\UA}(\fp)$, although we should require that views are closed with respect to 
$R_{\CC} \cup R_{\UA}$. Second, $\ET_{\UA}$ imposes that a transaction writing 
to a key $\key$ must be able to see all previous versions of such a key, \ie any version of a key $\key$. 
That is, when write-conflict detection is enforced, a version $\ver$ for $\key$ depends from all 
previous versions of the same key: this observation leads us to include write-write dependencies 
in the closure relation that defines $\ET_{\PSI}$. The kv-store from Figure
%causally depends from the transactions writing previous versions of such a key (an example is given in 
\cref{fig:cc-ua-allowed-but-psi}) shows an example of kv-store included in $\ET_{\CC} \cap \ET_{\UA}$, 
but not in $\ET_{\PSI}$.
%To capture this constraint, 
%we must include write-write dependencies in the relation with respect to which the view of a client before committing 
%a transaction must be closed.
%The definition in \cref{fig:execution.tests} ensures that 
%views of committing transactions are closed simultaneously with respect to both relations.
%Analogously, we have defined $\ET_\PSI = \ET_\CC \cap \ET_\UA$. 
%This definition exploits the \emph{compositionality} of our execution tests (\cref{thm:compositional}).
%as discussed in \cref{sec:other_formalisms}.

%\subsubsection{Consistent Prefix $(\CP)$}
%\label{para:cp}
%If the total order in which transactions commit is known, this consistency model 
%can be described as a strengthening of causal consistency: 
%if a client sees the versions written by a transaction $\txid$,
%then it must also see any version written by any transaction that commits before $\txid$. 
%Kv-stores only provide {\em partial} information about the order in which transactions commit, 
%given by the dependency relations between transactions; however, 
%this information is sufficient to formalise \emph{Consistent Prefix} \cite{laws}.
%
%In practice, we approximate the order in which transactions 
%commit in a $\ET$-trace that terminates in a configuration $(\mkvs, \_)$ from the relations $\WR_{\mkvs}, \WW_{\mkvs}, 
%RW_{\mkvs}$ and $\SO$. This approximation is best understood in terms of an idealised implementation of 
%$\CP$ on a centralised system,
%%fine-grained model 
%%where transactions are equipped with start and commit points, and operations 
%%between transactions in different sessions may interleave with each other. 
%where the snapshot of a transaction is determined at its start point and its effects are made visible 
%to all future transactions at the moment it commits. 
%With respect to this implementation, a write-read dependency \(\WR\) from transaction $\txid$ to transaction $\txid'$, 
%$(\txid,\txid') \in \WR$, means that 
%%$\txid$ reads the version of some key $\key$ 
%%written by $\txid'$, therefore  it {must} be
%%the case that 
%$\txid$ {must} commit before $\txid'$ starts, and therefore before $\txid'$ commits; 
%similarly, if $(\txid,\txid') \in \SO$ then $\txid$ commits before $\txid'$ starts, 
%and therefore before $\txid'$ commits.
%% 
%%Consider the transaction relations $\WR_{\mkvs}$, $\WW_{\mkvs}$ and
%%$\RW_{\mkvs}$ defined in \ref{fig:execution.tests}, adapted from well-known
%%transaction relations associated with dependency graphs~\cite{adya-icde,adya}.
%%In \cite{laws} an alternative definition of $\CP$ is given: if a client sees a transaction $\txid$, 
%%then it must also see the subset of transactions that committed before $\txid$, that can 
%%be computed from $\SO, \WR_{\mkvs}, \WW_{\mkvs}, \RW_{\mkvs}$. This property is captured 
%%by $\dagger$ in \cref{fig:execution.tests}.
%A read-write anti-dependency \(\RW\) from $\txid''$ to $\txid'$ 
%%The pair $(\txid,\txid') \in \WR_\mkvs$ means that $\txid$ reads the version of some key $\key$ 
%%written by $\txid'$, therefore  it {must} be
%%the case that $\txid$ commits before $\txid'$ starts, and therefore before $\txid'$ commits,
%%and similarly for $\SO$.
%%The pair $(\txid, \txid') \in \RW_{\mkvs}$ 
%means that $\txid''$ reads one version for some key that 
%is later overwritten by $\txid'$; then $\txid''$ is prevented from seeing the write of $\txid'$, 
%hence it {must} be the case that $\txid''$ starts before 
%$\txid'$ commits. 
%As a consequence, if $\txid$ commits before $\txid''$ starts 
%(either $(\txid, \txid'') \in \WR$ or $(\txid,\txid'') \in \SO$), 
%%the two are 
%%related by a write-read dependency \(\WR\) or by a session order \(\SO\)), 
%and there is an anti-dependency 
%from $\txid''$ to $\txid'$, then in {must} also be the case that $\txid$ commits before 
%the commit of $\txid'$. In particular, if $(\txid,\txid') \in \WR;\RW$, 
%or $(\txid,\txid') \in \SO;\RW$, then $\txid$ commits before $\txid'$.
%Finally, a write-write dependency from $\txid$ to $\txid'$, $(\txid,\txid') \in\WW$, means that $\txid$ {must} commit before $\txid'$. 
%In conclusion, the relation $\rel_{\CP} \equiv (\WR_{\mkvs}; \RW_{\mkvs}\rflx \cup \SO;  \RW_{\mkvs}\rflx \cup \WW)$ 
%approximates the order in which transactions are executed. 
%
%It has been shown in \cite{laws} 
%that the set $(\rel_{\CP}^{-1})^{+}(\txid)$ contains all the transactions that {must} be observed by $\txid$ under 
%$\CP$. We define $\ET_{\CP}$ by requiring that the view of a client prior to committing a transaction is 
%closed with respect to $R_{\CP}$, and by enforcing the session guarantees $\MR$ and $\RYW$,
%%$(\txid,\txid'') \in \WR_{\mkvs}$ (resp. \SO) and $(\txid'',\txid') \in \RW_\mkvs$, then it {must} also be the case that $\txid$ commits before the commit  of $\txid'$, 
%%Last, if $(\txid,\txid') \in \WW_\mkvs$ means that $\txid'$ overwrites a version written by $\txid$ for some 
%%key, then it {must} be
%%the case that $\txid$ commits before the commit of $\txid'$.
%%The relation $((\SO ; \RW_{\mkvs}\rflx) \cup (\WR_{\mkvs} ; \RW_{\mkvs\rflx}) \cup \WW_\mkvs )^{+} \ni (\txid, \txid')$
%%captures that, {\em all} the transactions $\txid$ that {must} have already committed to the kv-store before commit of \( \txid' \).
%%The execution test $\ET_{\CP}$ is the intersection of $\dagger$ with $\ET_\MR \cap \ET_\RYW$,
%%where the latter enforces a client sees its own commits.
%Consistent prefix disallows the \emph{long fork anomaly} shown in \cref{fig:cp-disallowed}: 
%in this anomaly, two clients $\cl_1$ and $\cl_2$ observe the updates to $\key_1$ and $\key_2$ 
%in different order. Assuming without loss of generality that \( \txid_{\cl_2}^{2} \) commits 
%after \( \txid_{\cl_1}^{2} \), then prior to committing the transaction $\cl_2$ sees 
%the version of $\key_1$ with value $\val_0$. However, we have that $\txid \xrightarrow{\WR_{\mkvs}} \txid_{\cl_{1}}^{1} 
%\xrightarrow{\SO} \txid_{\cl_{1}}^{2} \xrightarrow{\RW} \txid' \xrightarrow{\WR} \txid_{\cl_{2}}^{1} \xrightarrow{\SO} 
%\txid_{\cl_2}^{2}$, from which it follows that $\cl_2$ should also see the version of $\key_1$ with 
%value $\val_2$, causing a contradiction.
%%\txid_{\cl_1}^{2}
%%if \( \txid_{\cl_2}^2\) is the last transaction, it reads and thus sees \( \txid' \).
%%Given the kv-store we have:
%%\(
%%\txid \toEDGE{\WR_\mkvs} \txid^1_{\cl_1} \toEDGE{\SO} \txid^2_{\cl_1} \toEDGE{\RW_\mkvs} \txid'
%%\),
%%which means, transaction \( \txid_{\cl_2}^2 \) must see \( \txid \).
%%However, in \cref{fig:cp-disallowed} \( \txid_{\cl_2}^2 \) reads a older version of \( \key_1 \) than the one written by \( \txid \).
%%Symmetrically,
%%if \( \txid_{\cl_1}^2\) is the last transaction, it sees \( \txid \) and so must see \( \txid' \).
%%\sx{A reviewer suggests to show the visibility edges for long fork}


\subsubsection{Snapshot Isolation $(\SI)$}
If the total order in which transactions commit is known,  
this consistency model can be defined compositionally from $\CP$ and $\UA$. 
As for the case of $\PSI$, we cannot define the 
execution test for $\SI$ by simply composing the execution
tests of its individual components, this is, $\ET_{\CP} \cap \ET_{\UA}$.
Rather we need to ensure that the view of a client prior to committing a transaction 
with fingerprint $\fp$
is closed with respect to the relation $\rel_\CP \cup \rel_{\UA}(\fp) \cup \WW;\RW\rflx$. 
The addend $\WW;\RW\rflx$ comes from the fact that, when the centralised implementation 
of $\CP$ (discussed above) is strengthened with write-conflict freedom (concurrent transactions 
write to different keys), then a write-write dependency between two transactions $\txid$ and $\txid'$ 
does not only mandate that $\txid$ commits before $\txid'$ commits but also before $\txid'$ starts. 
As a consequence, if $(\txid,\txid') \in \WW ;\RW$, $\txid$ must commit 
before $\txid'$ commit.
%When we can rely only on 
%a partial order of transaction execution, inferred from 
%kv-stores and views, then this compositional result does not 
%hold\footnote{This issue arises also if dependency graphs are used in 
%place of kv-stores. See \cref{sec:si-not-intersect-cp-ua}}. For example, the kv-store of \cref{fig:si-disallowed} is
%included in both $\CMs(\ET_{\CP})$ and $\CMs(\ET_{\UA})$, but is
%disallowed by the execution test $\ET_\SI$, introduced presently
%In our definition, \( \ET_\SI \) by replacing property dagger in $\ET_{\CP}$ with 
%\( \ddagger \) (\cref{fig:execution.tests}) and by intersecting the result with $\ET_{\UA}$.
%Similarly as for $\CP$, the $\ddagger$ property captures the 
%fact that if transaction $\txid$ sees the writes of another transaction $\txid'$, then 
%it must see the subset of transactions committing before $\txid'$ that can be computed 
%from $\SO, \WR_{\mkvs}, \WW_{\mkvs}, \RW_{\mkvs}$. However, because snapshot isolation enforces 
%write-conflict freedom, the computation of this subset 
%differs from the one for $\CP$. 
%Under $\UA$ consequently \(\SI\), the pair $(\txid, \txid'') \in \WW_\mkvs$ means not only the case that $\txid$ commits 
%before $\txid''$, but $\txid$ commits before $\txid''$ start. 
%Because $(\txid'',\txid') \in \RW_{\mkvs}$ 
%implies that $\txid''$ starts before $\txid'$ commits, then it must be the case that 
%when $(\txid,\txid') \in \WW_{\mkvs} ; \RW_{\mkvs}$ then $\txid$ commits before $\txid'$ does. 
%In \cref{fig:si-disallowed} we show an anomaly that is allowed by $CP$ and $UA$ 
%(and therefore by the intersection of these two consistency models), but is disallowed by $\SI$. In this kv-store \( \txid_4 \) reads 
%the last version of \( \key_2 \) written by \( \txid_3 \), so that this kv-store is allowed by  \( \UA \). 
%We also have that 
%From the \( \txid_3 \) backwards we have edges:
%\(
%\txid_1 \toEDGE{\WW_\mkvs} \txid_2 \toEDGE{\RW_\mkvs} \txid_3
%\).
%Snapshot isolation \( \SI \) requires that if a transaction sees \( \txid_3 \) it must see \( \txid_1 \) by the \( \ddagger \) (it is not the case in \( \dagger \)).
%However in \cref{fig:si-disallowed} transaction \( \txid_4 \) only see the initial version of \( ke_1 \).
%As we discuss in \cref{sec:applications} and prove in the \ref{sec:clock-si}, 
%the Clock-SI protocol~\cite{clocksi} satisfies $\ET_{\SI}$. 

\subsubsection{(Strict) serialisability $(\SER)$}
Serialisability is the strongest consistency model, requiring that there exists a sequential schedule of transactions. 
The execution test $\ET_{\SER}$ thus allows clients to execute transactions only when 
their view of the kv-store store is complete; this can be enforced by requiring that the view 
of a client is closed with respect to the relation $\WW^{-1}$.
This requirement prevents the kv-store in  \cref{fig:ser-disallowed}: 
%under serialisability either $\txid_1$ or $\txid_2$ commits first. 
Without loss of generality, suppose that $\txid_2$ commits after $\txid_1$. Then the  client that commits $\txid_2$ must see the version of $\key_1$ written by $\txid_1$, 
and thus cannot read the outdated value $\val_0$ for such a key. 
%(the other case is analogous), then the write of $\key_2$ 
%must be included in the view of $\txid_2$, and thus $\txid_2$ should not read the outdated write to $\key_2$ by $\txid_0$. 
%The latter case is analogously prohibited. 
This example is allowed by all the other execution tests in~\cref{fig:execution_tests}.

\subsubsection{Weak Snapshot Isolation $(\WSI)$: A New Consistency Model} 
\label{sec:new_cm}
Kv-stores and execution tests seem to be useful for  investigating new 
consistency models.  
One example is the consistency model induced by 
$\ET_{\CP} \cap \ET_{\UA}$, which we call \emph{Weak Snapshot Isolation} ($\WSI$). 
To justify this consistency model in full, it would be useful to look at its implementations. 
In this paper we focus on what would be the benefits of implementing $\WSI$.
%Here I stoP!
Because $\WSI$ is stronger than $\CP$ and $\UA$ by definition, 
it forbids all the  anomalies forbidden by these consistency models, e.g. 
the long fork (\cref{fig:cp-disallowed}) and the lost update (\cref{fig:ua-disallowed}). 
$\WSI$ is also weaker than SI: it allows any of the anomalies 
of $\SI$ such as the write skew (\cref{fig:ser-disallowed}). The inclusion between $\WSI$ 
and $\SI$ is strict, with the kv-store from \cref{fig:si-disallowed}  allowed 
in $\WSI$ but  not in  SI. 
Consider the kv-store in $\mkvs$ \cref{fig:si-disallowed}. We can 
construct a $(\ET_{\CP} \cap \ET_{\UA})$-trace terminating in $(\mkvs, \_)$ by 
executing transactions $\txid_{1}, \txid_{2}, \txid_{3}$ and $\txid_{4}$ in this order. 
In particular, $\txid_{4}$ is executed using the view $\vi = [\key_{1} \mapsto \{0\}, \key_{2} \mapsto \{0,1\}]$. 
However, the same trace is not a valid $\ET_{\SI}$-trace. 
terminating in such a kv-store. 
%If we use the execution test $\ET_{\CP} \cap \ET_{\UA}$, then 
%%On the other hand, the inclusion 
%%$\ET_{\CP} \cap \ET_{\UA} \subseteq \ET_{\SI}$ is strict. The kv-store from  
%%\cref{fig:si-disallowed} is allowed by $\ET_{\CP} \cap \ET_{\UA}$: 
%this kv-store can be obtained by executing  
%transaction $\txid_{1}$ using the initial view $[\key_1 \mapsto \{0\}, \key_2 \mapsto \{0\}]$, 
%transaction $\txid_{2}$ using the view $[\key_1 \mapsto \{0,1\}, \key_2 \mapsto \{0\}]$ 
%transaction $\txid_{3}$ using the view $[\key_1 \mapsto \{0,1\}, \key_2 \mapsto \{0,1\}]$, 
%and transaction $\txid_{4}$ using the view $[\key_1 \mapsto \{0\}, \key_2 \mapsto \{0,1\}]$. 
Under $\ET_{\SI}$, transaction $\txid_{4}$ cannot be executed using the view $\vi$: 
$\txid_{4}$ reads the version of $\key_2$ written by $\txid_3$, 
meaning that $\vi$ must include the version written by 
$\txid_{3}$. Since $(\txid_{2},\txid_{3}) \in \RW $
%(because $\txid_{2}$ reads a staler version $\key_2$ than the one written by $\txid_{3}$) 
and $(\txid_{1} ,\txid_2 ) \in \WW$ 
%(because $\txid_{2}$ installs a newer version of $\key_{1}$ than the one written by $\txid_{1})$, 
then the view $\vi$ should contain the version of $\key_{1}$ written by $\txid_{1}$, 
contradicting the fact that $\txid_{4}$ reads the initial version of $\key_1$.
%We refer to the consistency model induced by $\ET_{\CP} \cap \ET_{\SI}$ as \emph{Weak Snapshot Isolation} ($\WSI$). 
We have shown that $\WSI$ is a weaker consistency model than $\SI$, which leads us to believe that $\WSI$ would 
outperform known implementations of $\SI$. The two consistency models are also very similar, 
%Because of the similarity between these two consistency models, we believe that 
many applications that 
are correct under \(\SI\) would still be correctly under $\WSI$. We give an example of such an application in \cref{sec:program-analysis}.


