\section{KV-Stores and Other Formalisms}
\label{sec:other_formalisms}

We demonstrate how our kv-stores and execution 
tests relate to existing declarative semantics for specifying  
consistency models, based on dependency graphs \cite{adya} 
and abstract executions \cite{framework-concur}. 
We give an overview of our results here, and refer the reader to the technical
appendix for more details (\cref{app:depgraphs} and  \cref{sec:abstract-execution}).


\mypar{Dependency Graphs and KV-Stores}
Dependency graphs \cite{adya-icde,adya} are perhaps the most popular 
formalism used for specifying transactional consistency models. 
A dependency graph $\Gr$ is a directed, labelled graph where its
nodes denote transactions and its edges denote certain \emph{dependencies} between transactions.  
Each node is labelled with a transaction identifier and a fingerprint.
Each edges is labelled with metadata describing the information flow in a run of the database: 
\begin{enumerate*}
    \item a \emph{session order} edge, $\txid_1 \xrightarrow{\SO} \txid_2$, 
	\item a \emph{read dependency} edge, $\txid_1 \xrightarrow{\WR} \txid_2$, denotes
that transaction $\txid_2$ reads a version written by $\txid_1$;
	\item a \emph{write dependency} edge, $\txid_1 \xrightarrow{\WW} \txid_2$, denotes that $\txid_2$ overwrites a version written by $\txid_1$; and 
	\item an \emph{anti-dependency} edge, $\txid_1 \xrightarrow{\RW} \txid_2$, denotes that $\txid_2$ overwrites a version read by $\txid_2$. 
\end{enumerate*}
Using dependency graphs, consistency models are specified by constraining the shape of the graph, typically by requiring the absence of certain cycles.  
Observe that we can always \emph{extract} a dependency graph  $\Gr$ from a kv-store $\kvs$:
we choose the transaction identifiers appearing in $\kvs$ as the nodes of $\Gr$, 
and define $\SO$ as in \cref{subsec:kvstores}, and $ \RF, \VO, \AD$ as in \cref{fig:execution_tests}.
In the technical appendix we show that we can reverse this process to construct dependency graphs from our kv-stores, thus giving 
rise to the following result.
\begin{theorem}
\label{thm:kv_graph_isomorph}
Dependency graphs are bijective to kv-stores.
\end{theorem}


\mypar{Abstract Executions and KV-Stores}
\emph{Abstract executions} \cite{ev_transactions,framework-concur} are an alternative formalism for defining consistency models. 
As with dependency graphs, an abstract execution graph $\aexec$
is a directed graph with its nodes representing transactions (with each node labelled with a transaction identifier and a set of read/write operations), 
and its edges representing certain relations between transactions. 
Each edge is labelled by either the \emph{visibility} ($\VIS$) or \emph{arbitration} ($\AR$) relation. 
Visibility is an irreflexive order on transactions such that $\txid_1 \xrightarrow{\VIS} \txid_2$ denotes that the effects (updates) of $\txid_1$ are visible to $\txid_2$. 
Arbitration is a strict total order on transactions such that $\txid_1 \xrightarrow{\AR} \txid_2$ denotes that the updates performed by $\txid_2$ are newer than those of $\txid_1$. 
Moreover, $\AR$ contains $\VIS$ ($\VIS \subseteq \AR$) and agrees with the session order.
Lastly, abstract executions observe the \emph{last-write-wins} policy: 
a transaction reading $\key$ always fetches the latest visible write on $\key$.
As with dependency graphs, consistency models using abstract executions are defined 
by constraining the shape of abstract execution graphs,
\eg by imposing certain conditions on $\VIS$. 
Following \cite{laws}, we can always \emph{extract} a dependency graph from an abstract execution, 
and subsequently a kv-store via \cref{thm:kv_graph_isomorph}.
However, the correspondence to abstract executions is not one-to-one 
because multiple arbitration orders may produce equivalent key-value stores.
In the technical appendix we show that all our definitions of consistency models in \cref{fig:execution_tests} 
are \emph{equivalent} to existing axiomatic definitions using abstract executions.

%We prove our definitions of consistency models using execution tests are sound and complete
%with respect to axiomatic definitions on abstract executions.
%That is, the set of abstract executions allowed by a consistency model, can be obtained by extracting from
%the set of kv-store allowed by the same consistency model, and vice versa.
%We first propose an alternative operational semantics on abstract executions.
%For each trace on kv-stores, 
%we construct a trace on abstract executions obtained by the alternative semantics, and vice versa.
%For technical contribution, 
%we define two general contractors, soundness contractor and completeness contractor,
%that are parametrised 
%by the connection between the conditions of the execution test and the axioms on abstract executions.
%We only need to show the execution tests are sound and complete with
%respect to axioms.
%Then using the two contractors, for each consistency model,
%we have the soundness and completeness result,
%between the set of kv-store and the set of abstract executions.

%}
%
%{ \color{blue}
%-------
%
%Shale: 
%
%-------
%
%}
%
%{\color{red}
%
%----

%Shale: the rest are too technical.
%
%Given a set of axioms $\visaxioms$, we define $\CMs(\visaxioms) \defeq \{\kvs_\aexec \mid \aexec \text{ sats.\ } \visaxioms \}$.
%Our first condition is the \emph{soundness} of an execution test against an axiomatic definition.
%An execution test $\ET$ is sound against an axiomatic definition $\visaxioms$ if:
%for all $n$ and for all \( \ET \)-traces \( \tau \) with \( n \) steps, 
%we can construct $\aexec_0, \cdots, \aexec_n$ and \( \mkvs_i = \mkvs_{\aexec_i} \) such that 
%for each step \( (\mkvs_i, \vi_i) \csat \f_i : (\mkvs_{i+1}, \vi_{i+1}) \) in \( \tau \),
%the new $\VIS$ edges in \( \aexec_{i+1} \) (those not in $\aexec_i$)
%%, which links transactions included in the view \( \vi_i \) to the new transaction \( \txid_i \),
%satisfy \( \visaxioms \).
%The formal definition of execution test soundness is given in \cref{sec:kv2aexec-sound-complete}.
%
%%\azalea{I don't think the intuitive description of soundness above is very clear...}
%
%Our second condition is the \emph{completeness} of an execution test against an axiomatic definition.
%Let $\txid_i$ denote the $i$\textsuperscript{th} transaction of $\aexec$ in its $\AR$ order, and $\aexec^{i}$ denote the restriction of $\aexec$ to $\txid_1 \cdots \txid_i$. 
%An execution test $\ET$ is complete against an axiomatic definition $\visaxioms$ if:
%for all abstract executions \( \aexec \) that satisfy \( \visaxioms \) containing $n$ transactions, 
%all $i \in \{1 \cdots n\}$, views $\vi_i, \vi'_i$, transactions $\txid'$, and fingerprints $\opset_i$,
%whenever
%\begin{enumerate*}
%	\item $\txid'$ is the immediate $\SO$-successor of $\txid_i$;
%	\item \( \vi_i \) includes all visible transactions of \( \txid_i \); 
%	\item $\vi'_i$ includes all visible transactions of $\txid'$; and
%	\item $\opset_i$ is the fingerprint of $\txid_i$, 
%\end{enumerate*} 
%then $\ET \vdash (\mkvs_i, \vi_i) \csat \f_i : (\mkvs_{i+1}, \vi_{i+1})$.
%The formal definition of execution test completeness is given in \cref{sec:kv2aexec-sound-complete}.
%
%\azalea{I don't think the intuitive description of completeness above is very clear...}

%Finally, we state our equivalence theorem below (\cref{thm:main-body-et_soundness_completeness}), with its full proof in \cref{sec:kv2aexec-sound-complete}. 
%This theorem ensures that if an execution test is sound and complete against a set of axioms $\visaxioms$, 
%then the consistency model induced by $\ET$ corresponds to the kv-stores extracted from abstract executions satisfying $\visaxioms$.

%\begin{theorem}
%\label{thm:main-body-et_soundness_completeness}
%For all $\ET, \visaxioms$, if $\ET$ is sound against $\visaxioms$, then:
%\(
%    \CMs(\ET) \subseteq \{ \kvs_\aexec \mid \aexec \in \CMs(\visaxioms)\}
%\).
%For all $\ET, \visaxioms$, if $\ET$ is complete against $\visaxioms$, then:
%\(
%    \{ \kvs_\aexec \mid \aexec \in \CMs(\visaxioms)\}  \subseteq \CMs(\ET)
%\).
%\end{theorem} 
%
%----
%
%} 

%In \cref{sec:spec-proof} we apply \cref{thm:main-body-et_soundness_completeness} and show all our definitions in \cref{fig:execution_tests} 
%are sound and complete against (equivalent to) existing axiomatic definitions on abstract executions.
