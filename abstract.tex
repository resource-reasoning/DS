\ac{Modern NoSQL databases (e.g. key-value stores) achieve scalability and improve 
latency by weakening the guarantees of distributed transaction 
processing. }
Modern NoSQL databases (e.g. key-value stores) achieve scalability and improve 
latency by weakening the consistency guarantees. 
The introduction of weak consistency models in transactional systems 
poses several challenges: giving them a formal specification in terms 
of user-observable behaviour; reasoning about properties of applications 
interacting with weakly consistent databases; and verifying that protocols 
of distributed transactional systems correctly implement a weak consistency model. 
These topics have been addressed independently in the literature, often using 
different formalisms. 
\ac{
In this paper, we propose what we believe is the first general-purpose style 
of specification for transactional consistency models that enjoy atomic visibility. 
We define an operational semantics where clients interact with a centralised, 
multi-version key-value store by requesting to commit transactions atomically. }
In this paper, we propose a operational semantics focusing on the interaction between 
weak consistency databases and client's views on the databases.
Our semantics is parametric in the definition of an execution test, that determines 
when a client is allowed to commit a transaction: different execution tests lead 
to different consistency models, and we show that we can capture the majority 
of consistency models that have been employed by centralised, distributed and replicated 
transactional systems. 
We then develop a program logic over the semantics for proving properties of transactions.
Such logic is also parametrised by execution tests.
\ac{
As an application of our theory, we develop a sound program logic for 
proving properties of clients of weakly consistent key-value stores. 
As for the operational semantics, the rules of the logic are parametric to the execution 
test used to model the key-value store, and therefore our logic can be used 
to prove properties of programs under several weak consistency models.}


%While the problem of giving a formal specification to 
%the consistency models used by such databases has been widely 
%studied, formalising the semantics of clients interacting with 
%such systems has been largely neglected$^\ast$. 
%This paper aims to be a 
%first step towards filling this gap. We present a framework 
%for capturing the semantics of programs interacting with a 
%weakly consistent key-value store whose transactions enjoy atomic visibility. 
%Our semantics enjoys 
%atomic transaction processing, interleaving concurrency, 
%and parameterisation with respect to the consistency model.  
%%The latter is captured using the notion of execution tests, which 
%%determine when a transaction is allowed  to execute. 
%As a main contribution, we prove that our semantics is adequate: 
%for each program and consistency model, the semantics captures 
%precisely the behaviour that the program exhibits under said consistency model; 
%and that specifications of consistency models in our framework 
%coincide with previously proposed, axiomatic ones.
%%via execution 
%%tests are equivalent to the axiomatic specifications which have already 
%%been proved to be correct.
%As another contribution, we develop a variant of the \emph{Concurrent 
%Abstract Predicates} separation logic
%%development 
%%of a separation logic for clients of key-value stores. We propose 
%%a variant of the \emph{Concurrent Abstract Predicates} 
%that is tailored to clients of weakly-consistent key-value stores, 
%and that is parametric in the specification of consistency models.
%%and a multi-version 
%%representation of the key-value store to allow concurrent clients to 
%%observe different states of the system.  
%%We abstract from implementation details of the key-value store, which 
%%is represented as a centralised, multi-version system. This allows 
%%for concurrent clients to observe different version of the same key, 
%%which makes it possible to capture non-serialisable behaviours of 
%%programs while still retaining the atomic execution of transactions and 
%%interleaving concurrency. 
%%Furthermore, our semantics is parameterised by execution tests, which determine 
%%when a transaction is allowed to execute.  By changing the execution 
%%test of transactions, we capture different consistency models.
%
%\textbf{$^\ast$ Suresh is going to be pissed off a lot by this sentence, but 
%let's be honest, his semantics is light years behind ours.}
%\ac{The abstract is wayyyy too long. But at least we have a guideline for the paper.}

%We present a a uniform semantics 
%Contents of this set of notes: 
%History heaps. Semantics of Programs 
%running under weak consistency models using history heaps as states. 
%Simulation technique for comparing weak consistency models defined using 
%history heaps. Verification of implementations.
%\textbf{Points following Dagstuhl: Viktor seemed positive about the 
%history heap work. His question was whether the framework is generic 
%enough to capture the protocols that they are developing with Azalea. 
%Alexey's opinion is that the framework may have some use if we 
%manage to prove implementations of protocols correct. 
%I would also like to have Azalea's opinion on a semantics based 
%on history heaps.}
