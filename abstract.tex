Modern NoSQL databases (e.g. key-value stores) achieve scalability and improve 
latency by weakening the guarantees of distributed transaction 
processing. While the problem of giving a formal specification to 
the consistency models used by such databases has been widely 
studied, formalising the semantics of clients interacting with 
such systems has been largely neglected$^\ast$. 
This paper aims to be a 
first step towards filling this gap. We present a framework 
for capturing the semantics of programs interacting with a 
weakly consistent key-value store whose transactions enjoy atomic visibility. 
Our semantics enjoys 
atomic transaction processing, interleaving concurrency, 
and parameterisation with respect to the consistency model.  
%The latter is captured using the notion of execution tests, which 
%determine when a transaction is allowed  to execute. 
As a main contribution, we prove that our semantics is adequate: 
for each program and consistency model, the semantics captures 
precisely the behaviour that the program exhibits under said consistency model; 
and that specifications of consistency models in our framework 
coincide with previously proposed, axiomatic ones.
%via execution 
%tests are equivalent to the axiomatic specifications which have already 
%been proved to be correct.
As another contribution, we develop a variant of the \emph{Concurrent 
Abstract Predicates} separation logic
%development 
%of a separation logic for clients of key-value stores. We propose 
%a variant of the \emph{Concurrent Abstract Predicates} 
that is tailored to clients of weakly-consistent key-value stores, 
and that is parametric in the specification of consistency models.
%and a multi-version 
%representation of the key-value store to allow concurrent clients to 
%observe different states of the system.  
%We abstract from implementation details of the key-value store, which 
%is represented as a centralised, multi-version system. This allows 
%for concurrent clients to observe different version of the same key, 
%which makes it possible to capture non-serialisable behaviours of 
%programs while still retaining the atomic execution of transactions and 
%interleaving concurrency. 
%Furthermore, our semantics is parameterised by execution tests, which determine 
%when a transaction is allowed to execute.  By changing the execution 
%test of transactions, we capture different consistency models.

\textbf{$^\ast$ Suresh is going to be pissed off a lot by this sentence, but 
let's be honest, his semantics is light years behind ours.}
\ac{The abstract is wayyyy too long. But at least we have a guideline for the paper.}

%We present a a uniform semantics 
%Contents of this set of notes: 
%History heaps. Semantics of Programs 
%running under weak consistency models using history heaps as states. 
%Simulation technique for comparing weak consistency models defined using 
%history heaps. Verification of implementations.
%\textbf{Points following Dagstuhl: Viktor seemed positive about the 
%history heap work. His question was whether the framework is generic 
%enough to capture the protocols that they are developing with Azalea. 
%Alexey's opinion is that the framework may have some use if we 
%manage to prove implementations of protocols correct. 
%I would also like to have Azalea's opinion on a semantics based 
%on history heaps.}
