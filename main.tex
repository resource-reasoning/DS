\documentclass[conference,compsoc]{IEEEtran}

%%%%%%%%%%%%%%%%%%%%%% INCLUDING %%%%%%%%%%%%%%%%%%%%%%%%%
% to switch including packages in env.tex
% all packages
\input{env.tex}
% all macros
\usepackage{hhmacros}
% all tikz setting and macros
\input{tikzsetting.tex}
\newcommand{\RootPath}{.}
%%%%%%%%%%%%%%%%%%%%%% END INCLUDING %%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%% EDIT OPTIONS %%%%%%%%%%%%%%%%%%%%%%%%%
\newif\ifCommentEdits
%\CommentEditstrue
\CommentEditsfalse
\input{comment-box.tex}
%%%%%%%%%%%%%%%%%%%%%% END EDIT OPTIONS %%%%%%%%%%%%%%%%%%%%%


\newif\ifDoubleColumn
\DoubleColumntrue


\ifCLASSOPTIONcompsoc
  \usepackage[nocompress]{cite}
\else
  \usepackage{cite}
\fi

%\renewcommand{\rmdefault}{ptm}
%\renewcommand{\baselinestretch}{0.9}

\begin{document}

%% Title information
\title{
	Data Consistency in Transactional Storage Systems: A Centralised Approach
    } 


\author{
	\IEEEauthorblockN{
		Shale Xiong$^1$
		\qqqquad Andrea Cerone$^1$
		\qqqquad Azalea Raad$^2$
		\qqqquad Philippa Gardner$^1$\vspace{10pt}
	}
	\IEEEauthorblockA{
		$\begin{array}{c @{\hspace{100pt}} c}
			^1\text{Imperial College London}
			& ^2 \text{MPI-SWS}\\
			\href{
				mailto:shale.xiong14@imperial.ac.uk, a.cerone@imperial.ac.uk, p.gardner@imperial.ac.uk
			}{
				\mathtt{\{shale.xiong14, a.cerone, p.gardner\}@imperial.ac.uk}
			}
			& \href{mailto:azalea@mpi-sws.org}{\mathtt{azalea@mpi{-}sws.org}}
		\end{array}
		$	
	}	
}

\maketitle

\begin{abstract}
    \input{\RootPath/abstract.tex}
\end{abstract}

\input{\RootPath/intro.tex}
\input{\RootPath/overview.tex}
\input{\RootPath/model.tex}
\input{\RootPath/consistency.tex}
\input{\RootPath/relation.tex}
\input{\RootPath/applications.tex}
\input{\RootPath/conclusion.tex}

%\ifCLASSOPTIONcompsoc
%  % The Computer Society usually uses the plural form
%  \section*{Acknowledgments}
%\else
%  % regular IEEE prefers the singular form
%  \section*{Acknowledgment}
%\fi
%The authors would like to thank...

\bibliographystyle{IEEEtran}  
\bibliography{bibliography,bibliography2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% appendix for submission
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\onecolumn
\appendices
\section{Operational Semantics on KV-Stores}
\label{sec:full-semantics}
\input{\RootPath/model/kvstore-view.tex}
The full operational semantics is given in \cref{fig:full-semantics}.
\input{\RootPath/semantics/semantics-fig.tex}
% composition of kv
\section{Execution Test and Compositionality}
\label{app:compositionality}
\input{\RootPath/composition-et/et-mono.tex}
\input{\RootPath/composition-et/normal-trace.tex}
\input{\RootPath/composition-et/updatekv-comm.tex}
\input{\RootPath/composition-et/counterexamples-for-composition.tex}
\input{\RootPath/composition-et/et-comm.tex}
\input{\RootPath/composition-et/counter-example-cp-si.tex}
% depenedent graph relates kv
\section{Relations to Dependency Graphs}
\label{app:depgraphs}
\label{sec:dependent-graph}
\input{\RootPath/dgraph/kv2graph.tex}
% abstract execution semantics
\section{Operational Semantics of Abstract Executions}
\input{\RootPath/aexec/aexec-semantics.tex}
\input{\RootPath/aexec/anarchic-model.tex}
% abstract execution relates kv
\section{Relationship between kv-stores and abstract execution}
\input{\RootPath/kv2aexec/aexec2kv.tex}
\input{\RootPath/kv2aexec/kvtrace2aexec.tex}
\input{\RootPath/kv2aexec/aexectrace2kv.tex}
\input{\RootPath/kv2aexec/galois-aexec-kv.tex}
% adequate between kv and abstract execution
\section{The Sound and Complete Constructors of the KV-Store Semantics with Respect to Abstract Executions}
\label{sec:kv-sound-complete-proof}

In this Section we first define the set of $\ET$-traces generated by a program $\prog$. 
Then we prove correctness our semantics on kv-stores,
meaning that if a program $\prog$ executing under the execution 
test $\ET$ terminates in a state $(\hh, \_)$, then $\hh \in \CMs(\ET)$. 

\input{\RootPath/adequate/et-prog-trace.tex}
\input{\RootPath/adequate/adequate.tex}
\input{\RootPath/adequate/sound-complete-judgement.tex}

% proofs of et
\section{The Soundness and Completeness of Execution Tests}
\label{app:et_sound_complete}
We now show using \cref{def:et_sound,def:et_complete} to prove the soundness and completeness of execution tests with respect to axiomatic specification.
It is sufficient to match these two definition, 
then by \cref{cor:et-soundness,cor:et-completeness} we have \( \CMs(\ET) = \Setcon{\mkvs_\aexec}{\aexec \in \CMa(\RP_\LWW,\Ax)} \).

\label{sec:kv-sound-complete-proof}
\label{sec:spec-proof}

\input{\RootPath/et-sound-comp/mr.tex}
\input{\RootPath/et-sound-comp/mw.tex}
\input{\RootPath/et-sound-comp/ryw.tex}
\input{\RootPath/et-sound-comp/wfr.tex}
\input{\RootPath/et-sound-comp/cc.tex}
\input{\RootPath/et-sound-comp/ua.tex}
\input{\RootPath/et-sound-comp/cp.tex}
\input{\RootPath/et-sound-comp/psi.tex}
\input{\RootPath/et-sound-comp/si.tex}
\input{\RootPath/et-sound-comp/ser.tex}
% Program analysis
\input{\RootPath/prog_analysis.tex}
% verify implementation
\section{Verification of implementations}

We verify two protocols, COPS and Closk-SI, that the former is a full replicated implementation for causal consistency and the latter is a shard implementation for snapshot isolation.

\subsection{COPS}
\label{sec:cops}
\input{\RootPath/cops/code.tex}
\input{\RootPath/cops/semantics.tex}
\subsection{Clock-SI}
\label{sec:clock-si}
\input{\RootPath/clock-si/code.tex}
\input{\RootPath/clock-si/semantics.tex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% END OF APPENDIX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
