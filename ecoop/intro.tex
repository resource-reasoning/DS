\section{Introduction}
\label{sec:intro}

Transactions are the \emph{de facto} synchronisation mechanism in
modern distributed databases. To achieve scalability and performance,
distributed databases often use weak transactional consistency
guarantees known as \emph{consistency models}.  Many consistency
models were originally invented by engineers using (some quite
informal) definitions specific to particular real-world reference
implementations: for example,
\cite{gdur,ramp,CORFU,tango,si,distrsi,clocksi,redblue,rola,cops,PSI-RA,NMSI,PSI,wren}.
More recently, general definitions of consistency model have been
defined independently of particular implementations, either
declaratively using execution graphs \cite{adya,ev_transactions} or
operationally using abstract 
states or execution graphs
\cite{seebelieve,alonetogether,sureshConcur}. 
Our challenge  is to define a general semantics for weak consistency
models  with which to both 
verify  reference  implementations {and} analyse 
the behaviour of client programs with respect to a particular consistency
model. 






The declarative approach for defining 
consistency models using execution graphs has been substantially
studied \cite{adya,ev_transactions,framework-concur,SIanalysis,laws}. 
In such graphs,  nodes  describe the read-write sets of  atomic transactions and edges describe the
known dependencies between transactions.
They capture different consistency models by:
\begin{enumerate*}
\item constructing  \emph{candidate executions} of the whole program comprising
transactions in which reads may contain arbitrary values; and 
\item applying  \emph{axioms}  on such executions to
  rule out the invalid executions of 
a consistency model described  by
  these axioms. 
Such axioms may state, for example, that every read is
validated by a write that has written the read value. 
\end{enumerate*}
The most well-known execution graphs are dependency graphs \cite{adya} and abstract
executions \cite{ev_transactions,framework-concur}. 
Dependency graphs tend to be used to analyse  client programs: for
example, 
Fekete et al. \citet{fekete-tods} derived 
a static analysis checker for a particular weak consistency model called
snapshot isolation;  Bernardi and Gotsman \citet{giovanni_concur16}
developed a static analysis checker for several weak consistency
models assuming the so-called snapshot property\footnote{The \emph{snapshot property}, 
also known as \emph{atomic visibility}, states that
the client observes that a transaction reads from an atomic snapshot
of the database and commits atomically;  intermediate states are not observable to other clients, 
even if the underlying distributed protocol has a more fine-grained behaviour.}; and 
Beillahi et al. \citep{snapshot-isolation-robust-tool} developed a tool based on Lipton's reduction \cite{Lipton-reduction}
for checking robustness properties against snapshot isolation: 
that is, a  particular program (or set of programs) behaves as if the consistency model is strong consistency. 
Abstract executions, on the other hand, tend to be used to verify  implementation protocols: for example,
abstract executions are the  standard by which many system engineers
demonstrate that their protocols satisfies  certain
consistency models \cite{cops,NMSI,PSI}. 
Execution graphs provide little information about how the 
state evolves throughout the execution of a program, and 
therefore seem  unsuitable for invariant-based program analysis 
of client programs. 


The operational approach for defining weak consistency models has been
much less studied.  Crooks {\em et al.}~\citet{seebelieve} introduced
a {state-based} trace semantics over an abstract centralised store for
capturing consistency models associated with ANSI/SQL isolation levels.
They demonstrated the equivalence of several implementation-specific
definitions of consistency model in the literature, but their reliance
on the total order of transactions suggests that it will be difficult
to adapt their work to reason about client programs. 
Kaki et al. \citet{alonetogether} provided an operational semantics
over an abstract centralised store, again focusing on ANSI/SQL
isolation levels. They developed a program logic and prototype tool for
reasoning about client programs,
but cannot express fundamental weak consistency models.
Nagar and Jagannathan \cite{sureshConcur} introduced an operational
semantics based on  
abstract-execution graphs, focussing on consistency models for
distributed transactions. They  provide
robustness results for  client programs using model checking, 
but their analysis is indirect in that they move back and forth
between abstract executions and dependency graphs. All these approaches have their merits. However, none of them provide a direct
state-based operational semantics for distributed atomic transactions
with which to verify  distributed
implementations and analyse  client programs using   the
usual 
weak
consistency models. 
Further details are given in \cref{sec:newrelated}.



We introduce an interleaving operational semantics for directly describing the
client-observable behaviour of atomic transactions 
updating distributed key-value stores  (\cref{sec:model}). Our semantics is
based on a notion of abstract state 
comprising  a {centralised key-value store (kv-store) with
{multi-versioning}, which is {\em global} in the sense that it
records all the versions of a key, and
{client views}, which are {\em partial} in the sense that  clients see only a subset of the
versions. Our client views are partly inspired by the views in the specific C11
operational semantics in~\cite{promises}, and are analogous to   the 
read states of~\cite{seebelieve}. An execution step depends
simply on the abstract state, the read-write set of the atomic transaction, and an \emph{execution test} which
determines if a client with a given view is allowed to do the
transaction commit. Different execution tests give rise to different
consistency models, 
which we show to be equivalent to well-known
declarative definitions of consistency model on abstract executions 
(reported here and proved in \cite{shale-phd}) and hence dependency graphs~\cite{laws}. 
Our execution tests are analogous to the commit tests used in \cite{seebelieve},
except that \cite{seebelieve}  requires an analysis of the whole
trace rather than just the  current abstract state. 

As in~\cite{seebelieve,alonetogether,sureshConcur}, we make the assumption that our transactions satisfy the
\emph{last-write-wins} resolution policy, a widely-used policy used in many
real-world distributed kv-stores.  This means that when a transaction
observes several updates to a key, the atomic snapshot contains the
value written by the last
update. We also make the assumption that our
transactions satisfy the \emph{snapshot property}.  This assumption is
common in distributed transactional databases: for example, with on-line shopping
application, a client only sees one snapshot of the database and only
has knowledge that their transaction has successfully
committed. The paper~\cite{sureshConcur} also assumes the snapshot
policy,
whereas~\cite{seebelieve} and~\cite{ alonetogether} do not  as their focus is on ANSI/SQL isolation
levels.
Our execution tests  uniformly capture  many well-known consistency
models (\cref{sec:cm}) including 
\emph{causal consistency} \((\CC)\) \citep{ev_transactions,cops,causal-def}, 
\emph{parallel snapshot isolation} \( (\PSI) \) \citep{NMSI,PSI},
\emph{snapshot isolation} \((\SI)\) \citep{si} 
and \emph{serialisability} \((\SER)\) \citep{Papadimitriou-ser}.
%Given these assumptions, we do not know of a consistency model that
%we cannot represent. 
The paper~\cite{sureshConcur} has the same expressivity. In contrast,~\cite{seebelieve}  is more expressive,  capturing for example the 
{\em read committed} consistency model~\cite{.}, 
and 
~\cite{ alonetogether}  is less expressive, capturing SI but not 
PSI. 

Using our operational semantics, we verify 
that database protocols satisfy their expected consistency models and
prove that invariant properties of client programs hold with respect to such
consistency models (\cref{sec:applications}).
We establish the correctness of two database
protocols: the COPS protocol for  fully replicated kv-stores \cite{cops} 
which satisfies CC (reported in \cref{sec:verify-impl}
and proven in  detail in \cite{shale-phd}); 
and the Clock-SI protocol for partitioned kv-stores \cite{clocksi} 
which satisfies SI  (given in \cite{shale-phd}). These results had previously been shown for
definitions specific to the reference implementations in~\cite{cops}
and~\cite{clocksi} respectively.
We also prove invariant properties of client programs calling
transactional libraries (\cref{sec:invariant-client-programs}): the robustness of the single-counter library
against PSI;  the robustness of the multi-counter library and the
well-known banking library \cite{bank-example-wsi} against SI; and the
correctness of a program pattern using locks against PSI. 
We believe our robustness results are the first to take into account client
sessions: with sessions, we show that multiple counters {\em are not} robust against \(\PSI\);
interestingly, without sessions, Bernardi and Gotsman~\citet{giovanni_concur16} show that multiple counters \emph{are}
robust against \(\PSI\) using static-analysis techniques which are
known not to be applicable to sessions.  
These results indicate that  our operational semantics provides an interesting  abstract interface
between distributed databases and clients.
This was an important goal for us, resonating with recent work
that does just this for standard shared-memory concurrency \cite{tada,cap,iris,fcsl}. 



\subsection{Related Work} 
\label{sec:newrelated}

Operational semantics for defining weak consistency models for
distributed atomic transactions have  hardly been
studied. As far as we are aware, the key papers
are~\cite{seebelieve,sureshConcur,alonetogether}. 
We also mention the log-based semantics of Koskinen and Parkinson~\citet{push-pull},
which only focusses on serialisability but has some resonance with our
work. 



%We first describe this work in
%some detail, and then briefly mention additional work.



Crooks et al. \citet{seebelieve} proposed a state-based trace
semantics for describing weak consistency models that employs concepts
similar to our client views and execution tests, called read states and
commit tests respectively.  In their semantics, a one-step trace
reduction is determined by the whole previous history of the trace.
In contrast, our reduction step only depends on the current kv-store
and view.  They capture more consistency models than us, such as {\em
  read committed}, due to their focus on isolation levels which do not
have the snapshot property. They use their semantics to 
demonstrate that 
several definitions of snapshot isolation  given in the
literature~\cite{citations} in fact collapse into one.  They do not verify
protocol implementations and do not prove invariant properties of
client programs.  We believe~\cite{seebelieve} can be used to verify
implementations. We believe it is difficult to use~\cite{seebelieve}
to prove invariant properties of client programs.  Their notion of
trace includes a large amount of information (for example, the total
order on transactions) that just would not be observable by a
client (for example, a client on one replica does not necessarily see
a transaction on another replica).
In contrast, our  approach focusses on the client-observable history
which is not total. 


%where each
%step involves adding the next transaction node by: \begin{enumerate*}
%\item constructing \emph{candidate executions};  and 
%\item ruling out executions using {axioms}. 
%\end{enumerate*}
%They capture a wide range of
%consistency model, and demonstrate the equivalence of several
%mplementation-specific definitions.  However, their approach does not
%lend itself to analysing client programs, since observations made by
%clients require the total order in which transactions commit which the
%clients do not have.



% incuding snapshot isolation,
%rather than the 
%weaker consistency
%models such as parallel snapshot isolation. 
%They develop a program logic and
%prototype tool for reasoning about client programs, and so can capture
%invariant properties of the state. They can express snapshot isolation
%\cite{si}, but the consensus is that they cannot capture the weaker
%consistency models such as parallel snapshot isolation \cite{PSI}
%which is an important consistency model for distributed databases.
%Nagar and Jagannathan \citet{sureshConcur} introduced an
%operational semantics for abstract execution graphs to 
%provide the robustness of client programs using model checking. 
%Each
%execution step adds a new transaction node to the graph by first
%constructing candidate steps and then applying axioms to rule out
%invalid candidate steps.  They focus on consistency models with the
%snapshot property, but confusingly work with the fine-grained
%interleaving of primitive operations.  This results in an unnecessary
%explosion of the space of traces obtained by the program.  This
%approach is unlikely to be suitable for invariant-based analysis
%associated with the state.  
%Finally, it is worth mentioning that
%Koskinen and Parkinson \citet{push-pull}  provided a \emph{log-based}
%abstract operational semantics for verifying several implementations
%of serilisability but does not provide unified semantics for
%defining weaker consistency models.

Nagar and Jagannathan \cite{sureshConcur} proposed a fine-grained 
interleaving operational semantics on abstract executions, and provide
robustness results for client programs using 
a prototype 
model-checking tool. 
They do this by converting abstract executions to
dependency graphs and checking the violation of robustness on the
dependency graphs. We have two concerns with this approach.  First, despite 
assuming atomic visibility of transactions, they present a fine-grained
semantics at the level of the individual transactional operations
rather than whole transactions, introducing unnecessary interleavings
which complicates the client reasoning and increases  the
search space of model-checking tools. 
In contrast, our semantics is coarse-grained in that the  interleaving is at the level of whole
transactions. 
Second, all the literature that performs client analysis
on abstract executions achieves this indirectly by over-approximating
the consistency-model specifications using dependency graphs
\cite{giovanni_concur16,SIanalysis,psi-chopping,laws,sureshConcur}. 
It is  unknown how to do this precisely \cite{laws}. 
In contrast, we prove robustness results directly by
analysing the structure of kv-stores, without over-approximation. 
We also give precise reasoning about the mutual exclusion of locks,
which we believe will be difficult to prove using abstract executions.


Kaki et al.~\citet{alonetogether} proposed an operational
semantics for SQL transaction programs over an abstract centralised
single-version 
store, with consistency models given by the standard ANSI/SQL
isolation levels \cite{si}. They develop a program logic and prototype
tool for reasoning about client programs, and so can capture invariant
properties of the state. They can express SI, but the consensus is that they cannot capture the weaker
consistency models such as PSI~\cite{PSI}
which is an important consistency model for distributed databases.




Finally,  Koskinen and Parkinson
\citet{push-pull} proposed a log-based semantics for verifying
implementations that satisfy serialisability, based not only on
kv-stores but also on other ADTs. Their work comprises a centralised
global log and partial client-local logs, similar to
our kv-stores and views. Their model focusses on serialisability.
There is no evidence that it can be easily extended to tackle
weaker consistency models.  