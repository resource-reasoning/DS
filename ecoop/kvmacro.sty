\ProvidesPackage{kvmacro}[2019/02/09 Macros for kv-store semantics, proofs, applications]
%**********************************************************************************************************************************
% Note: this file is shared between several documents, please do not delete any macros.
% Maintained by Shale Xiong <sx14@ic.ac.uk>
%**********************************************************************************************************************************

\RequirePackage{meta-macro}

% for xspace comment used in macro
\RequirePackage{xspace}

% xparse for more powerful macro definition
\RequirePackage{xparse}
\RequirePackage{xstring}
\RequirePackage{listofitems}
% for more powerful new environments
\RequirePackage{environ}
\usepackage[inline]{enumitem}
\setlist[enumerate,1]{nosep,label=\arabic*)}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% kv-store and view
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\NewDocumentCommand\Clients{}{\TypeFont{ClientID}\xspace}
\NewDocumentCommand\cl{}{{\MathVar{cl}}\xspace}
\NewDocumentCommand\clset{}{{\SetOf{c\!l}}\xspace}
\NewDocumentCommand\TxIDs{}{\TypeFont{TxID}\xspace}
\NewDocumentCommand\TxIDZs{}{\ensuremath{\TxIDs_0}\xspace}
\NewDocumentCommand\txid{od()}{%
\ensuremath{t%
\IfNoValueTF{#1}{}{_{#1}}%
\IfNoValueTF{#2}{}{^{#2}}%
}\xspace}
\NewDocumentCommand\txidrd{}{\txid[\text{rd}]}
\NewDocumentCommand\txidinit{}{\ensuremath{\txid_0}\xspace}
\NewDocumentCommand\txidset{o}{\IfNoValueTF{#1}{\SetOf{t}}{\SetOf{t}_{#1}}}
\NewDocumentCommand\txidsetrd{}{\txidset[\text{rd}]}
\NewDocumentCommand\Values{}{\TypeFont{Value}\xspace}
\NewDocumentCommand\Val{}{\Values}
\NewDocumentCommand\val{}{\MathVar{v}}
\NewDocumentCommand\valset{}{\MathVar{\SetOf{v}}}
\NewDocumentCommand\valinit{}{\ensuremath{\val_0}\xspace}
\NewDocumentCommand\Keys{}{\TypeFont{Key}\xspace}
\NewDocumentCommand\key{}{\MathVar{k}}
\NewDocumentCommand\keyset{}{\MathVar{\SetOf{k}}}
\NewDocumentCommand\Versions{}{\TypeFont{Version}\xspace}
\NewDocumentCommand\ver{}{\MathVar{\nu}}
\NewDocumentCommand\verlist{}{\MathVar{\mathcal{V}}}
\NewDocumentCommand\KVSs{}{\TypeFont{KVS}\xspace}
\NewDocumentCommand\MKVSs{}{\KVSs}
\NewDocumentCommand\kvs{d()}{\Func*{\mathcal{K}}(#1)}
\NewDocumentCommand\mkvs{d()}{\kvs(#1)}
\NewDocumentCommand\kvsinit{d()}{\Func*{\mathcal{K}_0}(#1)}
\NewDocumentCommand\Indexs{}{\Nat\xspace}
\NewDocumentCommand\idx{}{\MathVar{i}}
\NewDocumentCommand\Views{d()}{\Func{\TypeFont{Views}}(#1)}
\NewDocumentCommand\ViewEnvs{d()}{\Func*{\TypeFont{ViewEnv}}(#1)\xspace}
\NewDocumentCommand\vi{d()}{\Func*{u}(#1)}
\NewDocumentCommand\vilist{}{\ensuremath{\mathcal{V}}}
\NewDocumentCommand\viinit{d()}{\Func*{\vi_0}(#1)}
\NewDocumentCommand\vienv{d()}{\Func{\mathcal{U}}(#1)}
\NewDocumentCommand\vienvinit{d()}{\Func*{\vienv_0}(#1)}
\NewDocumentCommand\Confs{}{\TypeFont{Conf}\xspace}
\NewDocumentCommand\ConfInits{}{\ensuremath{\TypeFont{Conf}_0}\xspace}
\NewDocumentCommand\conf{}{\ensuremath{\Gamma}\xspace}
\NewDocumentCommand\confinit{}{\ensuremath{\Gamma_0}\xspace}
\NewDocumentCommand\Snapshots{}{\TypeFont{Snapshot}\xspace}
\NewDocumentCommand\snap{d()}{\Func*{\sigma}(#1)}
\NewDocumentCommand\sn{d()}{\snap(#1)}
\NewDocumentCommand\Stacks{}{\TypeFont{Stack}\xspace}
\NewDocumentCommand\stk{}{\MathVar{s}}
\NewDocumentCommand\Operations{}{\TypeFont{Op}\xspace}
\NewDocumentCommand\Ops{}{\Operations}
\NewDocumentCommand\op{}{\MathVar{o}}
\NewDocumentCommand\opS{d()}{%
\IfNoValueTF{#1}{%
\MathVar{\PredicateFont{S}}%
}{%
\Tuple{\PredicateFont{S},#1}
}}
\NewDocumentCommand\opR{d()}{%
\IfNoValueTF{#1}{%
\MathVar{\PredicateFont{R}}%
}{%
\Tuple{\PredicateFont{R},#1}
}}
\NewDocumentCommand\opW{d()}{%
\IfNoValueTF{#1}{%
\MathVar{\PredicateFont{W}}%
}{%
\Tuple{\PredicateFont{W},#1}
}}
\NewDocumentCommand\otR{}{\opR}
\NewDocumentCommand\otW{}{\opW}
\NewDocumentCommand\opP{d()}{%
\IfNoValueTF{#1}{%
\MathVar{\PredicateFont{P}}%
}{%
\Tuple{\PredicateFont{P},#1}
}}
\NewDocumentCommand\opE{d()}{%
\IfNoValueTF{#1}{%
\MathVar{\PredicateFont{E}}%
}{%
\Tuple{\PredicateFont{E},#1}
}}
\NewDocumentCommand\opEmp{}{\ensuremath{\epsilon}}
\NewDocumentCommand\emptyop{}{\opEmp}
\NewDocumentCommand\Fingerprints{}{\TypeFont{Fp}\xspace}
\NewDocumentCommand\fp{}{\MathVar{\mathcal{F}}}
\NewDocumentCommand\lib{}{\SetOf{l}}
\NewDocumentCommand\ClientEnvs{}{\TypeFont{ClientEnvs}\xspace}
\NewDocumentCommand\ThdEnv{}{\TypeFont{CEnv}\xspace}
\NewDocumentCommand\clenv{d()}{\Func{\mathcal{E}}(#1)}
\NewDocumentCommand\thdenv{d()}{\clenv(#1)}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% semantics label
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\NewDocumentCommand\Labels{}{\TypeFont{Labels}\xspace}
\NewDocumentCommand\PLabels{}{\TypeFont{PLabels}\xspace}
\NewDocumentCommand\COPSLabels{}{\TypeFont{COPSLabels}\xspace}
\NewDocumentCommand\ETLabels{}{\TypeFont{ETLabels}\xspace}
\NewDocumentCommand\AexecLabels{}{\TypeFont{ALabels}\xspace}
\NewDocumentCommand\lb{}{\MathVar{\iota}}
\NewDocumentCommand\lbCl{O{\cl}m}{\MathVar{\Tuple{#1,#2}}}
\NewDocumentCommand\lbPri{O{\cl}}{\MathVar{\Tuple{#1,\bullet}}}
\NewDocumentCommand\lbView{O{\cl}m}{\MathVar{\Tuple{#1,#2}}}
\NewDocumentCommand\lbTrans{O{\cl}m}{\Tuple{#1,#2}}
\NewDocumentCommand\lbFp{O{\cl}m}{\Tuple{#1,#2}}
\NewDocumentCommand\lbCOPSWrite{O{\cl}D(){\repl}m}{\Tuple{#1,#2,#3}}
\NewDocumentCommand\lbCOPSOptRead{O{\cl}D(){\repl}m}{\Tuple{#1,#2,#3,\CodeFont{Opt}}}
\NewDocumentCommand\lbCOPSPri{O{\cl}D(){\repl}}{\MathVar{\Tuple{#1,#2,\opS}}}
\NewDocumentCommand\lbCOPSBound{O{\cl}D(){\repl}}{\MathVar{\Tuple{#1,#2,\CodeFont{P}}}}
\NewDocumentCommand\lbCOPSRefetch{O{\cl}D(){\repl}m}{\MathVar{\Tuple{#1,#2,#3,\CodeFont{Ref}}}}
\NewDocumentCommand\lbCOPSFinishRead{O{\cl}D(){\repl}m}{\MathVar{\Tuple{#1,#2,#3,\opE}}}
\NewDocumentCommand\lbCOPSSync{D(){\repl}m}{\MathVar{\Tuple{#1,#2}}}
\NewDocumentCommand\lbCLOCKStart{O{\cl}D(){\clockshard}m}{\MathVar{\Tuple{#1,#2,#3,\opS}}}
\NewDocumentCommand\lbCLOCKOp{O{\cl}D(){\clockshard}m}{\MathVar{\Tuple{#1,#2,#3}}}
\NewDocumentCommand\lbCLOCKEnd{O{\cl}D(){\clockshard}m}{\MathVar{\Tuple{#1,#2,#3,\opE}}}
\NewDocumentCommand\lbCLOCKTick{D(){\clockshard}m}{\MathVar{\Tuple{#1,#2}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ET relation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\NewDocumentCommand\ExTests{}{\TypeFont{ExecutionTest}\xspace}
\NewDocumentCommand\ETs{}{\TypeFont{ET}\xspace}
\NewDocumentCommand\et{O{}}{\ensuremath{\PredicateFont{ET}_{#1}}}
\NewDocumentCommand\ET{O{}}{\et[#1]}
\NewDocumentCommand\ETTraces{d()}{\Func*{\TypeFont{ETTraces}}(#1)}
\NewDocumentCommand\ETTracesN{d()}{\Func{ETTracesN}(#1)}
\NewDocumentCommand\ettrc{}{\MathVar{\tau}}
\NewDocumentCommand\TransactionRelations{}{\TypeFont{TransRels}\xspace}
\NewDocumentCommand\rel{O{}d()}{\Func*{R_{#1}}(#2)}
\NewDocumentCommand\TOP{}{\ensuremath{\top}\xspace}
\NewDocumentCommand\RA{}{\PredicateFont{RA}\xspace}
\NewDocumentCommand\MR{}{\PredicateFont{MR}\xspace}
\NewDocumentCommand\RYW{}{\PredicateFont{RYW}\xspace}
\NewDocumentCommand\MW{}{\PredicateFont{MW}\xspace}
\NewDocumentCommand\WFR{}{\PredicateFont{WFR}\xspace}
\NewDocumentCommand\CC{}{\PredicateFont{CC}\xspace}
\NewDocumentCommand\UA{}{\PredicateFont{UA}\xspace}
\NewDocumentCommand\PSI{}{\PredicateFont{PSI}\xspace}
\NewDocumentCommand\CP{}{\PredicateFont{CP}\xspace}
\NewDocumentCommand\WSI{}{\PredicateFont{WSI}\xspace}
\NewDocumentCommand\SI{}{\PredicateFont{SI}\xspace}
\NewDocumentCommand\SER{}{\PredicateFont{SER}\xspace}

\NewDocumentCommand\SO{}{\MathVar{\RelationFont{SO}}}
\NewDocumentCommand\WW{O{}d()}{\Func*{\RelationFont{WW}_{#1}}(#2)}
\NewDocumentCommand\WWInv{O{}d()}{\Func*{\RelationFont{WW}^{-1}_{#1}}(#2)}
\NewDocumentCommand\WR{O{}d()}{\Func*{\RelationFont{WR}_{#1}}(#2)}
\NewDocumentCommand\RW{O{}d()}{\Func*{\RelationFont{RW}_{#1}}(#2)}
\NewDocumentCommand\RWInv{O{}d()}{\Func*{\RelationFont{RW}^{-1}_{#1}}(#2)}
\NewDocumentCommand\RWRelf{O{}d()}{\Func*{\RelationFont{RW}^{?}_{#1}}(#2)}
\NewDocumentCommand\VIS{O{}d()}{\Func*{\RelationFont{VIS}_{#1}}(#2)}
\NewDocumentCommand\VISInv{O{}d()}{\Func*{\RelationFont{VIS}^{-1}_{#1}}(#2)}
\NewDocumentCommand\AR{O{}d()}{\Func*{\RelationFont{AR}_{#1}}(#2)}
\NewDocumentCommand\ARInv{O{}d()}{\Func*{\RelationFont{AR}^{-1}_{#1}}(#2)}
\NewDocumentCommand\DEP{O{}d()}{\Func*{\RelationFont{DEP}_{#1}}(#2)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% graph
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\NewDocumentCommand\DependencyGraphs{}{\TypeFont{DGraphs}\xspace}
\NewDocumentCommand\dgraph{}{\MathVar{\mathcal{G}}\xspace}
\NewDocumentCommand\txidop{O{}d()}{\Func*{\mathcal{T}_{#1}}(#2)}
\NewDocumentCommand\AbstractExecutions{}{\TypeFont{AExects}\xspace}
\NewDocumentCommand\aexec{}{\MathVar{\mathcal{X}}\xspace}
\NewDocumentCommand\aexecinit{}{\MathVar{\mathcal{X}_0}\xspace}
\NewDocumentCommand\VisAxioms{}{\TypeFont{VisAxioms}\xspace}
\NewDocumentCommand\visaxiom{}{\SetOf{a}\xspace}
\NewDocumentCommand\visaxioms{O{}}{\ensuremath{\SetSetOf{a}_{#1}}\xspace}
\NewDocumentCommand\aexectrc{}{\MathVar{\pi}\xspace}
\NewDocumentCommand\AexecInv{}{\TypeFont{AExectInvs}\xspace}
\NewDocumentCommand\aexecinv{od()}{
\IfNoValueTF{#1}{\Func*{I}(#2)}{\Func*{I_{#1}}(#2)}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% cops
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\NewDocumentCommand\COPSReplicas{}{\TypeFont{COPSRepl}\xspace}
\NewDocumentCommand\Repls{}{\TypeFont{Repls}\xspace}
\NewDocumentCommand\repl{}{\MathVar{r}}
\NewDocumentCommand\COPSVerIDs{}{\TypeFont{COPSVerID}\xspace}
\NewDocumentCommand\COPSTxIDs{}{\TypeFont{COPSTxID}\xspace}
\NewDocumentCommand\copsverid{}{\MathVar{id}}
\NewDocumentCommand\copstxid{oO{\repl}d()}{%
\MathVar{\hat{t}%
\IfNoValueTF{#1}{}{_{#1}}%
\IfNoValueTF{#3}{}{%
\setsepchar{,}
\readlist*\numberElems{#3}%
\ifnum\numberElemslen<2%
^{\Tuple{#3,#2,0}}
\else
^{\Tuple{\numberElems[1],#2,\numberElems[2]}}
\fi}}}
\NewDocumentCommand\COPSVersions{}{\TypeFont{COPSVer}\xspace}
\NewDocumentCommand\copsver{}{\MathVar{\hat{\nu}}}
\NewDocumentCommand\copsverlist{}{\MathVar{\hat{\mathcal{V}}}}
\NewDocumentCommand\COPSDependencies{}{\TypeFont{COPSDep}\xspace}
\NewDocumentCommand\copsdep{}{\MathVar{d}}
\NewDocumentCommand\dep{}{\MathVar{d}}
\NewDocumentCommand\copsdepset{}{\MathVar{\hat{\SetOf{d}}}}
\NewDocumentCommand\COPSKVSs{}{\TypeFont{COPSKVS}\xspace}
\NewDocumentCommand\copskvs{d()}{\Func*{\hat{\mathcal{K}}}(#1)}
\NewDocumentCommand\COPSs{}{\TypeFont{COPSs}\xspace}
\NewDocumentCommand\cops{d()}{\Func*{\hat{\mathcal{R}}}(#1)}
\NewDocumentCommand\COPSContexts{d()}{\Func*{\TypeFont{COPSCtx}}(#1)}
\NewDocumentCommand\copsctx{d()}{\Func*{\hat{u}}(#1)}
\NewDocumentCommand\COPSContextEnvs{d()}{\Func*{\TypeFont{COPSCtxEnv}}(#1)}
\NewDocumentCommand\copsctxenv{d()}{\Func*{\hat{\mathcal{U}}}(#1)}
\NewDocumentCommand\COPSConfs{d()}{\Func*{\TypeFont{COPSConf}}(#1)}
\NewDocumentCommand\copsconf{d()}{\MathVar{\Theta}}
\NewDocumentCommand\COPSConfInits{d()}{\Func*{\TypeFont{COPSConf}_0}(#1)}
\NewDocumentCommand\copsconfinit{d()}{\MathVar{\Theta}_0}
\NewDocumentCommand\Times{}{\TypeFont{Time}\xspace}
\NewDocumentCommand\ts{}{\MathVar{n}}
\NewDocumentCommand\COPSCommands{}{\TypeFont{COPSCmd}\xspace}
\NewDocumentCommand\copscmd{}{\MathVar{\hat{\cmd}}}
\NewDocumentCommand\COPSRunCommands{}{\TypeFont{COPSRuntimeCmd}\xspace}
\NewDocumentCommand\copsruncmd{}{\MathVar{\hat{\CodeFont{R}}}}
\NewDocumentCommand\COPSTraces{}{\TypeFont{COPSTrace}\xspace}
\NewDocumentCommand\COPSTraceN{d()}{\Func{COPSTraceN}(#1)\xspace}
\NewDocumentCommand\copstrc{}{\MathVar{\zeta}}
\NewDocumentCommand\COPSPrograms{}{\TypeFont{COPSProg}\xspace}
\NewDocumentCommand\copsprog{}{\MathVar{\hat{\prog}}}
\NewDocumentCommand\COPSRunPrograms{}{\TypeFont{COPSRuntimeProg}\xspace}
\NewDocumentCommand\copsrunprog{}{\MathVar{\hat{\CodeFont{I}}}}
\NewDocumentCommand\ExtCOPSTraces{}{\TypeFont{ANCOPSTrace}\xspace}
\NewDocumentCommand\copsexttrc{}{\MathVar{\hat{\zeta}}}
\NewDocumentCommand\copsclenv{d()}{\Func*{\hat{\mathcal{C}}}(#1)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% clock-si
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\NewDocumentCommand\CLOCKTimes{}{\TypeFont{ClockTime}\xspace}
\NewDocumentCommand\CLOCKtimes{}{\CLOCKTimes}
\NewDocumentCommand\clocktime{}{\MathVar{n}\xspace}
\NewDocumentCommand\clocktimeinit{}{\MathVar{\tilde{t_0}}\xspace}
\NewDocumentCommand\CLOCKVersions{}{\TypeFont{ClockVersions}\xspace}
\NewDocumentCommand\clockver{}{\MathVar{\tilde{\nu}}\xspace}
\NewDocumentCommand\CLOCKKVS{}{\TypeFont{ClockKVS}\xspace}
\NewDocumentCommand\clockkvs{d()}{\Func*{\tilde{\mathcal{K}}}(#1)\xspace}
\NewDocumentCommand\CLOCKKVSInit{}{\ensuremath{\TypeFont{ClockKVS}_0}\xspace}
\NewDocumentCommand\clockkvsinit{d()}{\Func*{\tilde{\mathcal{K}_0}}(#1)\xspace}
\NewDocumentCommand\CLOCKSI{}{\TypeFont{ClockSI}\xspace}
\NewDocumentCommand\CLOCKSIInit{}{\ensuremath{\TypeFont{ClockSI}_0}\xspace}
\NewDocumentCommand\clocksi{d()}{\Func*{\tilde{\mathcal{R}}}(#1)\xspace}
\NewDocumentCommand\clocksiinit{d()}{\Func*{\tilde{\mathcal{R}_0}}(#1)\xspace}
\NewDocumentCommand\CLOCKClientEnvs{}{\TypeFont{ClockClientEnv}\xspace}
\NewDocumentCommand\clockclientenv{d()}{\Func*{\tilde{\mathcal{U}}}(#1)\xspace}
\NewDocumentCommand\CLOCKClientEnvInits{}{\ensuremath{\TypeFont{ClockClientEnv}_0}\xspace}
\NewDocumentCommand\clockclientenvinit{d()}{\Func*{\tilde{\mathcal{C}_0}}(#1)\xspace}
\NewDocumentCommand\CLOCKConfs{}{\TypeFont{ClockConf}\xspace}
\NewDocumentCommand\clockconf{d()}{\Func*{\tilde{\Gamma}}(#1)\xspace}
\NewDocumentCommand\CLOCKConfInits{}{\ensuremath{\TypeFont{ClockConf}_0}\xspace}
\NewDocumentCommand\clockconfinit{d()}{\Func*{\tilde{\Gamma_0}}(#1)\xspace}
\NewDocumentCommand\CLOCKCommands{}{\TypeFont{ClockRunCommands}\xspace}
\NewDocumentCommand\clockruncmd{}{\MathVar{\tilde{\CodeFont{R}}}}
\NewDocumentCommand\CLOCKProgs{}{\TypeFont{ClockRunProgs}\xspace}
\NewDocumentCommand\clockrunprog{}{\MathVar{\tilde{\CodeFont{I}}}}
\NewDocumentCommand\pruntrans{mmm}{\MathVar{%
\begin{Transaction}%
#1%
\end{Transaction}^{#2}_{#3}%
}}
\NewDocumentCommand\CLOCKStates{}{\TypeFont{ClockState}\xspace}
\NewDocumentCommand\clockstate{}{\MathVar{\tilde{s}}}
\NewDocumentCommand\clocksiactive{}{\CodeFont{active}}
\NewDocumentCommand\clocksiprepared{}{\CodeFont{prepared}}
\NewDocumentCommand\clocksicommitting{}{\CodeFont{committing}}
\NewDocumentCommand\clocksicommitted{}{\CodeFont{committed}}
\NewDocumentCommand\CLOCKShards{}{\TypeFont{ClockShard}\xspace}
\NewDocumentCommand\clockshard{}{\MathVar{r}\xspace}
\NewDocumentCommand\clockshardset{}{\MathVar{R}\xspace}
\NewDocumentCommand\clockverlist{}{\MathVar{\tilde{\mathcal{V}}}}
\NewDocumentCommand\CLOCKBuffers{}{\TypeFont{ClockBuffer}\xspace}
\NewDocumentCommand\clockbuffer{}{\MathVar{\mathcal{B}}}
\NewDocumentCommand\CLOCKTraces{}{\TypeFont{ClockTrace}\xspace}
\NewDocumentCommand\CLOCKExtTraces{}{\TypeFont{AClockTrace}\xspace}
\NewDocumentCommand\clocktrc{}{\MathVar{\phi}}
\NewDocumentCommand\clockexttrc{}{\MathVar{\tilde{\phi}}}
\NewDocumentCommand\clocktrcstate{}{\MathVar{\tilde{\alpha}}}
\NewDocumentCommand\ClockTxIDs{}{\TypeFont{ClockTxID}\xspace}
\NewDocumentCommand\clocktxid{od()}{%
\ensuremath{\tilde{t}%
\IfNoValueTF{#1}{}{_{#1}}%
\IfNoValueTF{#2}{}{^{(#2)}}%
}\xspace}
\NewDocumentCommand\CLOCKLabels{}{\TypeFont{ClockLabels}\xspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% program syntax 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\NewDocumentCommand\pskip{}{\MathVar{\CodeFont{skip}}}
%XXXXXXXXXXXXXX
\NewDocumentEnvironment{Transaction}{}{%
\left[ 
\noexpandarg%
% check if there are multiple lines
\begin{array}{@{}l@{}}%
}{%
\end{array}%
\right]%
}
\NewDocumentCommand\ptrans{m}{\MathVar{%
\begin{Transaction}%
#1%
\end{Transaction}%
}}
\NewEnviron{transaction}{%
\setsepchar{\\}%
\readlist*\TEMPFORCHECKARRAY{\BODY}%
\left\lbrack%
\IfEq{\TEMPFORCHECKARRAYlen}{1}{}{
\begin{array}{@{}l@{}}%
}
\BODY
\IfEq{\TEMPFORCHECKARRAYlen}{1}{}{
\end{array}%
}
\right\rbrack%
}
\NewDocumentCommand\pseq{}{\MathVar{\mathbin{;}}}
\NewDocumentCommand\pchoice{}{\MathVar{\mathbin{+}}}
\NewDocumentCommand\ppar{}{\MathVar{\mathbin{\|}}}
\NewDocumentCommand\prepeat{d()}{%
\IfNoValueTF{#1}{%
\MathVar{\mathop{{}^*}}%
}{%
\MathVar{\mathop{{#1}^*}}%
}%
}
\NewDocumentCommand\AssignSymbol{}{\MathVar{\mathrel{:=}}}
\NewDocumentCommand\passign{mm}{\MathVar{#1 \AssignSymbol #2}}
\NewDocumentCommand\passume{d()}{\Func*{\CodeFont{assume}}(#1)}
\NewDocumentCommand\pmutate{mm}{\MathVar{\left[ #1\right] \AssignSymbol #2}}
\NewDocumentCommand\plookup{mm}{\MathVar{#1 \AssignSymbol \left[ #2 \right]}}
\NewDocumentCommand\pif{d()}{\MathVar{%
\CodeFont{if}%
\IfNoValueTF{#1}{}{\begin{Bracketed} #1\end{Bracketed}}\xspace%
}}
\NewDocumentCommand\pelse{}{\MathVar{\CodeFont{else}}}
\NewDocumentCommand\pwhile{d()}{\MathVar{%
\CodeFont{while}%
\IfNoValueTF{#1}{}{\begin{Bracketed} #1\end{Bracketed}}\xspace%
}}
\newcommand{\palloc}[2]{#1\mathbin{:=}\CodeFont{alloc}(#2)}
\newcommand{\preturn}[1]{\CodeFont{return}(#1)}
\newcommand{\pifs}[1]{\CodeFont{if} \, (#1) \{}
\newcommand{\pifm}{\} \CodeFont{else}\{ }
\newcommand{\pife}{\}}
\newcommand{\ploops}[1]{\CodeFont{while} \, (#1) \{ }
\newcommand{\ploope}[1]{\}}
\newcommand{\ploop}[2]{\ploops{#1} #2 \ploope}
\NewDocumentCommand\Expressions{}{\TypeFont{Expressions}}
\NewDocumentCommand\Expr{}{\TypeFont{Expr}}
\NewDocumentCommand\expr{}{\MathVar{\CodeFont{E}}}
\NewDocumentCommand\Booleans{}{\TypeFont{Booleans}}
\NewDocumentCommand\bool{}{\MathVar{\CodeFont{B}}}
\NewDocumentCommand\true{}{\MathVar{\CodeFont{true}}}
\NewDocumentCommand\false{}{\MathVar{\CodeFont{false}}}
\NewDocumentCommand\Programs{}{\TypeFont{Progs}}
\NewDocumentCommand\prog{d()}{\Func*{\CodeFont{P}}(#1)}
\NewDocumentCommand\ProgTraces{d()}{\Func*{\TypeFont{PTraces}}(#1)}
\NewDocumentCommand\progtrc{}{\MathVar{\eta}}
\NewDocumentCommand\Vars{}{\TypeFont{Var}}
\NewDocumentCommand\var{D(){x}}{\MathVar{\CodeFont{#1}}}
\NewDocumentCommand\pvar{m}{\var(#1)}
\NewDocumentCommand\pv{m}{\var(#1)}
\NewDocumentCommand\Commands{}{\TypeFont{Commands}}
\NewDocumentCommand\cmd{}{\MathVar{\CodeFont{C}}}
\NewDocumentCommand\cmdpri{}{\MathVar{\CodeFont{C}_p}}
\NewDocumentCommand\Transactions{}{\TypeFont{Transactions}}
\NewDocumentCommand\trans{}{\MathVar{\CodeFont{T}}}
\NewDocumentCommand\transpri{}{\MathVar{\CodeFont{T}_p}}
\NewDocumentCommand\pcopsput{d()}{\Func*{\CodeFont{put}}(#1)}
\NewDocumentCommand\pcopsread{d()}{\Func*{\CodeFont{read}}(#1)}
\NewDocumentCommand\pclockstart{d()}{\Func*{\CodeFont{transSnapshot}}(#1)}
\NewDocumentCommand\pclockwrite{d()}{\Func*{\CodeFont{transWrite}}(#1)}
\NewDocumentCommand\pclockread{d()}{\Func*{\CodeFont{transRead}}(#1)}
\NewDocumentCommand\pclockcommit{d()}{\Func*{\CodeFont{commitTrans}}(#1)}
\NewDocumentCommand\pk{d()}{\CodeFont{k}\xspace}
\NewDocumentCommand\pks{d()}{\CodeFont{ks}\xspace}
\NewDocumentCommand\pctx{d()}{\CodeFont{ctx}\xspace}
\NewDocumentCommand\prepl{d()}{\CodeFont{repl}\xspace}
\NewDocumentCommand\ret{}{\CodeFont{ret}}
\NewDocumentCommand\plock{d()}{\Func*{\CodeFont{lock}}(#1)}
\NewDocumentCommand\ptrylock{d()}{\Func*{\CodeFont{tryLock}}(#1)}
\NewDocumentCommand\punlock{d()}{\Func*{\CodeFont{unlock}}(#1)}

\NewDocumentCommand\plockpara{d()}{\Func*{\CodeFont{lockPara}}(#1)}

\NewDocumentCommand\pcounter{sd()}{
\IfNoValueTF{#2}{\CodeFont{Counter}}{%
\IfBooleanTF{#1}{\CodeFont{Counter}\left(#2\right)}{
\CodeFont{Counter\left(#2\right)}}%
}\xspace}
\NewDocumentCommand\pcounters{sd()}{
\IfNoValueTF{#2}{\CodeFont{Counters}}{%
\IfBooleanTF{#1}{\CodeFont{Counters}\left(#2\right)}{
\CodeFont{Counter\left(#2\right)}}%
}\xspace}
\NewDocumentCommand\Counter{}{\pcounter}
\NewDocumentCommand\pread{sd()}{
\IfNoValueTF{#2}{\CodeFont{Read}}{%
\IfBooleanTF{#1}{\CodeFont{Read}\left(#2\right)}{
\CodeFont{Read\left(#2\right)}}%
}\xspace}
\NewDocumentCommand\ctrread{}{\pread}
\NewDocumentCommand\pinc{sd()}{
\IfNoValueTF{#2}{\CodeFont{Inc}}{%
\IfBooleanTF{#1}{\CodeFont{Inc}\left(#2\right)}{
\CodeFont{Inc\left(#2\right)}}%
}\xspace}
\NewDocumentCommand\ctrinc{}{\pinc}

\NewDocumentCommand\pbank{sd()}{
\IfNoValueTF{#2}{\CodeFont{Bank}}{%
\IfBooleanTF{#1}{\Func{\CodeFont{Bank}}(#2)}{
\Func{\CodeFont{Bank}}(#2)}}}
\NewDocumentCommand\pbalance{sd()}{
\IfNoValueTF{#2}{\CodeFont{Counter}}{%
\IfBooleanTF{#1}{\Func{\CodeFont{Balance}}(#2)}{
\Func{\CodeFont{Balance}}(#2)}}}
\NewDocumentCommand\pcheck{sd()}{
\IfNoValueTF{#2}{\CodeFont{DepositChecking}}{%
\IfBooleanTF{#1}{\Func{\CodeFont{DepositChecking}}(#2)}{
\Func{\CodeFont{DepositChecking}}(#2)}}}
\NewDocumentCommand\psave{sd()}{
\IfNoValueTF{#2}{\CodeFont{TransactSaving}}{%
\IfBooleanTF{#1}{\Func{\CodeFont{TransactSaving}}(#2)}{
\Func{\CodeFont{TransactSaving}}(#2)}}}
\NewDocumentCommand\pamal{sd()}{
\IfNoValueTF{#2}{\CodeFont{Amalgamate}}{%
\IfBooleanTF{#1}{\Func{\CodeFont{Amalgamate}}(#2)}{
\Func{\CodeFont{Amalgamate}}(#2)}}}
\NewDocumentCommand\pwritecheck{sd()}{
\IfNoValueTF{#2}{\CodeFont{WriteCheck}}{%
\IfBooleanTF{#1}{\Func{\CodeFont{WriteCheck}}(#2)}{
\Func{\CodeFont{WriteCheck}}(#2)}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% rule name 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\NewDocumentCommand\rTPrimitive{}{\RuleFont{TPrimitive}\xspace}
\NewDocumentCommand\rTChoice{}{\RuleFont{TChoice}\xspace}
\NewDocumentCommand\rTIter{}{\RuleFont{TIter}\xspace}
\NewDocumentCommand\rTSeqSkip{}{\RuleFont{TSeqSkip}\xspace}
\NewDocumentCommand\rTSeq{}{\RuleFont{TSeq}\xspace}
\NewDocumentCommand\rCAtomicTrans{}{\RuleFont{CAtomicTrans}\xspace}
\NewDocumentCommand\rCPrimitive{}{\RuleFont{CPrimitive}\xspace}
\NewDocumentCommand\rCChoice{}{\RuleFont{CChoice}\xspace}
\NewDocumentCommand\rCIter{}{\RuleFont{CIter}\xspace}
\NewDocumentCommand\rCSeqSkip{}{\RuleFont{CSeqSkip}\xspace}
\NewDocumentCommand\rCSeq{}{\RuleFont{CSeq}\xspace}
\NewDocumentCommand\rProg{}{\RuleFont{Prog}\xspace}
\NewDocumentCommand\rAAtomicTrans{}{\RuleFont{AAtomicTrans}\xspace}
\NewDocumentCommand\rAPrimitive{}{\RuleFont{APrimitive}\xspace}
\NewDocumentCommand\rAChoice{}{\RuleFont{AChoice}\xspace}
\NewDocumentCommand\rAIter{}{\RuleFont{AIter}\xspace}
\NewDocumentCommand\rASeqSkip{}{\RuleFont{ASeqSkip}\xspace}
\NewDocumentCommand\rASeq{}{\RuleFont{ASeq}\xspace}
\NewDocumentCommand\rAProg{}{\RuleFont{AProg}\xspace}
\NewDocumentCommand\rCOPSWrite{}{\RuleFont{COPSWrite}\xspace}
\NewDocumentCommand\rCOPSStartRead{}{\RuleFont{COPSStartRead}\xspace}
\NewDocumentCommand\rCOPSOptRead{}{\RuleFont{COPSOptRead}\xspace}
\NewDocumentCommand\rCOPSLowerBound{}{\RuleFont{COPSRefetchSet}\xspace}
\NewDocumentCommand\rCOPSRefetch{}{\RuleFont{COPSRefetch}\xspace}
\NewDocumentCommand\rCOPSFinishRead{}{\RuleFont{COPSFinishRead}\xspace}
\NewDocumentCommand\rCOPSClient{}{\RuleFont{COPSClient}\xspace}
\NewDocumentCommand\rCOPSSync{}{\RuleFont{COPSSync}\xspace}
\NewDocumentCommand\rCLOCKStart{}{\RuleFont{CLOCKSISnapshot}\xspace}
\NewDocumentCommand\rCLOCKWrite{}{\RuleFont{CLOCKSIWrite}\xspace}
\NewDocumentCommand\rCLOCKReadLocal{}{\RuleFont{CLOCKSIReadLocal}\xspace}
\NewDocumentCommand\rCLOCKReadShard{}{\RuleFont{CLOCKSIReadShard}\xspace}
\NewDocumentCommand\rCLOCKPrepare{}{\RuleFont{CLOCKSIPrepare}\xspace}
\NewDocumentCommand\rCLOCKCommit{}{\RuleFont{CLOCKSICommit}\xspace}
\NewDocumentCommand\rCLOCKTrans{}{\RuleFont{CLOCKSITrans}\xspace}
\NewDocumentCommand\rCLOCKShardTick{}{\RuleFont{CLOCKSIShardTick}\xspace}
 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% operator function and predicate
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\RequirePackage{stmaryrd}
\NewDocumentCommand\Evaluation{mO{}}{\MathVar{\llbracket #1 \rrbracket_{#2}}}
\NewDocumentCommand\EvalE{mO{\stk}}{\Evaluation{#1}[#2]}
\NewDocumentCommand\evalE{O{\stk}m}{\Evaluation{#2}[#1]}
\NewDocumentCommand\EvalB{mO{\stk}}{\Evaluation{#1}[#2]}
\NewDocumentCommand\EvalET{mO{\et}}{\Evaluation{#1}[#2]}
\NewDocumentCommand\AProgTraces{d()}{\Func{ATracesN}(#1)}
\NewDocumentCommand\EvalAExec{mO{\visaxioms}}{\Evaluation{#1}[#2]}

\NewDocumentCommand\vileq{}{\ensuremath{\sqsubseteq}\xspace}
\NewDocumentCommand\viewleq{}{\vileq}
\NewDocumentCommand\copstxidle{}{\ensuremath{\sqsubset}\xspace}
\NewDocumentCommand\copsveridleq{}{\ensuremath{\sqsubseteq}\xspace}
\NewDocumentCommand\copstxidleq{}{\ensuremath{\sqsubseteq}\xspace}
\NewDocumentCommand\replleq{}{\ensuremath{\leq}\xspace}
\NewDocumentCommand\copskvsleq{}{\ensuremath{\sqsubseteq}\xspace}
\NewDocumentCommand\ettrceq{}{\ensuremath{\simeq}\xspace}
\NewDocumentCommand\AddOp{}{\ensuremath{\mathbin{<\!\!\!\vartriangleleft}}\xspace}
\NewDocumentCommand\addO{}{\AddOp}
\NewDocumentCommand\csat{O{}}{\ensuremath{\triangleright_{#1}}}
\NewDocumentCommand\copstrceq{}{\ensuremath{\simeq}\xspace}
\NewDocumentCommand\aexeceq{o}{\ensuremath{\IfNoValueTF{#1}{\simeq}{\simeq_{#1}}}}
\NewDocumentCommand\AKcomp{}{\ensuremath{\sim}\xspace}
\NewDocumentCommand\clockkvsleq{}{\ensuremath{\sqsubseteq}\xspace}
\NewDocumentCommand\clocksileq{}{\ensuremath{\sqsubseteq}\xspace}
\NewDocumentCommand\clocktrceq{}{\ensuremath{\simeq}\xspace}
\NewDocumentCommand\clockclientenvleq{}{\ensuremath{\sqsubseteq}\xspace}
\NewDocumentCommand\clocktxidleq{}{\ensuremath{\sqsubseteq}\xspace}
\NewDocumentCommand\clockverleq{}{\ensuremath{\sqsubseteq}\xspace}

\NewDocumentCommand\InitVal{d()}{\Func{InitialValue}(#1)}
\NewDocumentCommand\ValOf{d()}{\Func{ValueOf}(#1)}
\NewDocumentCommand\TimeOf{d()}{\Func{TimeOf}(#1)}
\NewDocumentCommand\StateOf{d()}{\Func{StateOf}(#1)}
\NewDocumentCommand\ShardOf{d()}{\Func{ShardOf}(#1)}
\NewDocumentCommand\WtOf{d()}{\Func{WriterOf}(#1)}
\NewDocumentCommand\RsOf{d()}{\Func{ReadersOf}(#1)}
\NewDocumentCommand\wtOf{ o }{\Func{w}(#1)}
\NewDocumentCommand\rsOf{ o }{\Func{rs}(#1)}
\NewDocumentCommand\valueOf{ o }{\Func{val}(#1)}
\NewDocumentCommand\Snapshot{d()}{\Func{Snapshot}(#1)}
\NewDocumentCommand\snapshot{ o }{\Func{snapshot}(#1)}
\NewDocumentCommand\GetOp{d()}{\Func{GetOp}(#1)}
\NewDocumentCommand\NextTxid{d()}{\Func{NextTxID}(#1)}
\NewDocumentCommand\nextTxid{ o }{\Func{NextTxID}(#1)}
\NewDocumentCommand\UpdateKV{d()}{\Func{UpdateKV}(#1)}
\NewDocumentCommand\updateKV{ o }{\Func{UpdateKV}(#1)}
\NewDocumentCommand\CMET{d()}{\Func{ConsisModel}(#1)}
\NewDocumentCommand\CMs{ o }{\Func{CM}(#1)}
\NewDocumentCommand\Last{d()}{\Func{Last}(#1)}
\NewDocumentCommand\First{d()}{\Func{First}(#1)}
\NewDocumentCommand\LastConf{d()}{\Last(#1)}
\NewDocumentCommand\FirstConf{d()}{\First(#1)}
\NewDocumentCommand\ExtendProgram{d()}{\Func{ExtendProgram}(#1)}
\NewDocumentCommand\TransFp{d()}{\Func{TransFp}(#1)}
\NewDocumentCommand\VisTrans{d()}{\Func{VisTrans}(#1)}
\NewDocumentCommand\Tx{ d() }{\Func{visTx}(#1)}
\NewDocumentCommand\DepOf{d()}{\Func{DepSetOf}(#1)}
\NewDocumentCommand\depOf{ o }{\Func{deps}(#1)}
\NewDocumentCommand\IdOf{d()}{\Func{IdOf}(#1)}
\NewDocumentCommand\COPSMerge{d()}{\Func{COPSMerge}(#1)}
\NewDocumentCommand\VerOf{d()}{\Func{VerOf}(#1)}
\NewDocumentCommand\VerListOf{d()}{\Func{VerListOf}(#1)}
\NewDocumentCommand\VerListOfN{d()}{\Func{VerListOfN}(#1)}
\NewDocumentCommand\KToD{d()}{\Func{KToD}(#1)}
\NewDocumentCommand\KToT{d()}{\Func{KToT}(#1)}
\NewDocumentCommand\DToK{d()}{\Func{DToK}(#1)}
\NewDocumentCommand\CMA{d()}{\Func{ConsisModelAxioms}(#1)}
\NewDocumentCommand\CMa{ o }{\Func{CM}(#1)}
\NewDocumentCommand\AexecSnapshot{d()}{\Func{AExecSnapshot}(#1)}
\NewDocumentCommand\MaxVisTrans{d()}{\Func{MaxVisTrans}(#1)}
\NewDocumentCommand\Sort{O{}d()}{\Func{Sort_{#1}}(#2)}
\NewDocumentCommand\NextAExecTxid{d()}{\Func{NextAExecTxID}(#1)}
\NewDocumentCommand\UpdateAExec{d()}{\Func{UpdateAExec}(#1)}
\NewDocumentCommand\XToD{d()}{\Func{XToD}(#1)}
\NewDocumentCommand\XToK{d()}{\Func{XToK}(#1)}
\NewDocumentCommand\GetView{d()}{\Func{GetView}(#1)}
\NewDocumentCommand\TraceToX{d()}{\Func{TraceToX}(#1)}
\NewDocumentCommand\AexecCut{d()}{\Func{AExectCut}(#1)}
\NewDocumentCommand\ARClose{d()}{\Func{ARClose}(#1)}
\NewDocumentCommand\XToTrace{d()}{\Func{XToTrace}(#1)}
\NewDocumentCommand\XToTraceN{d()}{\Func{XToTraceN}(#1)}
\NewDocumentCommand\ApproxView{d()}{\Func{ApproxView}(#1)}
\NewDocumentCommand\VerLower{d()}{\Func{VerLower}(#1)}
\NewDocumentCommand\VerLowerN{d()}{\Func{VerLowerN}(#1)}
\NewDocumentCommand\ClockToExd{d()}{\Func{AnnoClock}(#1)}
\NewDocumentCommand\ClockFirstCommit{d()}{\Func{FirstCommit}(#1)}
\NewDocumentCommand\ClockToKVStore{d()}{\Func{ClockToKVStore}(#1)}
\NewDocumentCommand\FirstTrans{d()}{\Func{FirstTransaction}(#1)}
\NewDocumentCommand\ReadOnlyTrans{d()}{\Func{ReadOnlyTrans}(#1)}

\NewDocumentCommand\COPSInsert{d()}{\Func{COPSInsert}(#1)}
\NewDocumentCommand\COPSViews{d()}{\Func{COPSViews}(#1)}
\NewDocumentCommand\COPSVisTrans{d()}{\Func{COPSVisTrans}(#1)}
\NewDocumentCommand\COPSToKVCmd{d()}{\Func{COPSToKVCmd}(#1)}
\NewDocumentCommand\COPSToKVProg{d()}{\Func{COPSToKVProg}(#1)}
\NewDocumentCommand\COPSToExt{d()}{\Func{COPSToExt}(#1)}
\NewDocumentCommand\COPSToExtW{d()}{\Func{COPSToExtW}(#1)}
\NewDocumentCommand\COPSToKVS{d()}{\Func{COPSToKVS}(#1)}
\NewDocumentCommand\COPSToKVTrace{d()}{\Func{COPSToKVTrace}(#1)}

\NewDocumentCommand\CLOCKTimeTick{d()}{\Func{CLOCKTick}(#1)}
\NewDocumentCommand\CLOCKMaxTime{d()}{\Func{MaxTime}(#1)}
\NewDocumentCommand\CLOCKUpdate{d()}{\Func{CLOCKUpdate}(#1)}
\NewDocumentCommand\CLOCKUpdateKVS{d()}{\Func{CLOCKUpdateKVS}(#1)}
\NewDocumentCommand\ClockStaticProg{d()}{\Func{ClockStaticProg}(#1)}
\NewDocumentCommand\ClockStaticCmd{d()}{\Func{ClockStaticCmd}(#1)}
\NewDocumentCommand\ClockFp{d()}{\Func{ClockFp}(#1)}
\NewDocumentCommand\ClockView{d()}{\Func{ClockView}(#1)}
\NewDocumentCommand\ClockToKVTrace{d()}{\Func{ClockToKVTrace}(#1)}
\NewDocumentCommand\NormalTrace{d()}{\Pred{NormalisedTrace}(#1)}

\NewDocumentCommand\WfView{d()}{\Pred{WfView}(#1)}
\NewDocumentCommand\WfET{d()}{\Pred{WfET}(#1)}
\NewDocumentCommand\WfKvs{d()}{\Pred{WfKvs}(#1)}
\NewDocumentCommand\CanCommit{O{}d()}{\Pred{CanCommit_{#1}}(#2)}
\NewDocumentCommand\cancommitname{}{\Pred{canCommit}}
\NewDocumentCommand\cancommit{O{\ET}mmm}{\Pred{canCommit_{#1}}(#2, #3, #4)}
\NewDocumentCommand\ViewShift{O{}d()}{\Pred{ViewShift_{#1}}(#2)}
\NewDocumentCommand\vshiftname{}{\Pred{vShift}}
\NewDocumentCommand\vshift{O{\ET}mmmm}{\Pred{vShift_{#1}}(#2, #3, #4, #5)}
\NewDocumentCommand\PreClosed{d()}{\Pred{PreClosed}(#1)}
\NewDocumentCommand\closed{ o }{\Pred{closed}(#1)}
\NewDocumentCommand\Unique{d()}{\Pred{Unique}(#1)}
\NewDocumentCommand\WfCOPSKvs{d()}{\Pred{WfCOPSKvs}(#1)}
\NewDocumentCommand\COPSNormalTrace{d()}{\Pred{NCOPSTrace}(#1)}
\NewDocumentCommand\WfDGraph{d()}{\Pred{WfDGraph}(#1)}
\NewDocumentCommand\WfAExec{d()}{\Pred{WfAExec}(#1)}
\NewDocumentCommand\TotalRelation{d()}{\Pred{TotalRelation}(#1)}
\NewDocumentCommand\WfVIS{d()}{\Pred{WfVIS}(#1)}
\NewDocumentCommand\AExecSat{d()}{\Pred{AExecSat}(#1)}
\NewDocumentCommand\WSISafe{d()}{\Pred{WSISafe}(#1)}
\NewDocumentCommand\WfCLOCKKvs{d()}{\Pred{WfClockSIKvs}(#1)}
\NewDocumentCommand\CLOCKNormalTrace{d()}{\Pred{ANCLOCKTrace}(#1)}
\NewDocumentCommand\CLOCKTimeTickSeg{d()}{\Pred{CLOCKTickAndStartSeg}(#1)}
\NewDocumentCommand\CLOCKAtomic{d()}{\Pred{CLOCKAtomic}(#1)}
\NewDocumentCommand\ClockReadFromShard{d()}{\Pred{ReadFromShard}(#1)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% arrow
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\NewDocumentCommand\toTRANS{}{\ensuremath{\rightsquigarrow}}
\NewDocumentCommand\ToTrans{sm}{
\ensuremath{%
\IfBooleanTF{#1}{\rightsquigarrow}{%
% split into segments
\setsepchar{->}%
\readlist*\stepElems{#2}%
\foreachitem\stepElem\in\stepElems{%
% split a segment
\setsepchar{{|}}%
\readlist*\segElems{\stepElem}%
% the base for each segment
\Tuple{\segElems[1],\segElems[2],\segElems[3]}, \segElems[4]%
\ifnum\stepElemcnt<\stepElemslen%
% need an arrow
\ifnum\segElemslen<5%
\ArrowPadding{\rightsquigarrow}%
\else%
\ArrowPadding{\rightsquigarrow^{\segElems[5]}}%
\fi\fi%
}}}\xspace}
\RequirePackage{tikz}
\usetikzlibrary{calc,decorations.pathmorphing,shapes,arrows,positioning}
\NewDocumentCommand\xrightsquigarrow{moO{}}{%
\IfNoValueTF{#2}{%
\begin{tikzpicture}[baseline={([yshift=-2pt]current bounding box.south)}]%
\node[inner sep=.44ex,align=center] (tmp) {$\scriptstyle #1$};
\path[draw,<-,decorate,
decoration={zigzag,amplitude=0.7pt,segment length=1.2mm,pre length=3.5pt}] 
(tmp.south east) -- (tmp.south west);
\end{tikzpicture}
}{%
\begin{tikzpicture}[baseline={([yshift=4pt]current bounding box.south)}]%
\node[inner sep=.44ex,align=center] (tmp) {$\scriptstyle #1$};
\path[draw,<-,decorate,
decoration={zigzag,amplitude=0.7pt,segment length=1.2mm,pre length=3.5pt}] 
(tmp.south east) -- (tmp.south west);
\node[inner sep=0pt, outer sep=0pt, below right = 2pt and 0pt of tmp.south east] (sub) {\scriptsize \(#2\)};
\node[inner sep=0pt, outer sep=0pt, above right = 2pt and 0pt of tmp.south east] (sub) {\scriptsize \(#3\)};
\end{tikzpicture}
}\xspace}
\NewDocumentCommand\ToTransPri{m}{\xrightsquigarrow{#1}}
\NewDocumentCommand\toLTS{m}{\ToTransPri{#1}}
%\NewDocumentCommand\xRightsquigarrow{m}{%
%\mathrel{%
%\begin{tikzpicture}[baseline= {( $ (current bounding box.south) + (0,-0.5ex) $ )}]
  %\node[inner sep=.5ex] (a) {$\scriptstyle #1$};
  %\path[draw,implies-,double distance between line centers=1.5pt,decorate,
    %decoration={zigzag,amplitude=0.7pt,segment length=1.2mm,pre=lineto,
    %pre   length=4pt}] 
    %(a.south east) -- (a.south west);
%\end{tikzpicture}}}

\NewDocumentCommand\toCMD{m}{\ensuremath{\xrightarrow{#1}}}
\NewDocumentCommand\ToCmd{sO{\et}m}{
\ensuremath{%
\IfBooleanTF{#1}{\xrightarrow{#3}_{#2}}{%
% split into segments
\setsepchar{->}%
\readlist*\stepElems{#3}%
\foreachitem\stepElem\in\stepElems{%
% split a segment
\setsepchar{{|}}%
\readlist*\segElems{\stepElem}%
% the base for each segment
% possible pattern $1
% possible pattern $1->$2
% possible pattern $1->$2$3
% possible pattern $1$2$3$4
% possible pattern $1$2$3$4->$5
% possible pattern $1$2$3$4->$5$6
\ifnum\segElemslen<4%
\segElems[1]%
\else%
\Tuple{\segElems[1],\segElems[2],\segElems[3]}, \segElems[4]%
\fi%
\ifnum\stepElemcnt<\stepElemslen%
% need an arrow
\ifnum\segElemslen<3%
\ArrowPadding{\xrightarrow{\segElems[2]}_{#2}}%
\else
\ifnum\segElemslen<4%
\ArrowPadding{\xrightarrow{\segElems[2]}_{#2}^{\segElems[3]}}%
\else
\ifnum\segElemslen<6%
\ArrowPadding{\xrightarrow{\segElems[5]}_{#2}}%
\else%
\ArrowPadding{\xrightarrow{\segElems[5]}_{#2}^{\segElems[6]}}%
\fi\fi\fi\fi%
}}}\xspace}
\NewDocumentCommand\ToCOPSCmd{sm}{
\ensuremath{%
\IfBooleanTF{#1}{\xrightsquigarrow{#2}}{%
% split into segments
\setsepchar{->}%
\readlist*\stepElems{#2}%
\foreachitem\stepElem\in\stepElems{%
% split a segment
\setsepchar{{|}}%
\readlist*\segElems{\stepElem}%
% the base for each segment
% possible pattern $1
% possible pattern $1->$2
% possible pattern $1->$2$3
% possible pattern $1$2$3$4
% possible pattern $1$2$3$4->$5
% possible pattern $1$2$3$4->$5$6
\ifnum\segElemslen<4%
\segElems[1]%
\else%
\Tuple{\segElems[1],\segElems[2],\segElems[3]}, \segElems[4]%
\fi%
\ifnum\stepElemcnt<\stepElemslen%
% need an arrow
\ifnum\segElemslen<3%
\ArrowPadding{\xrightarrow{\segElems[2]}}%
\else
\ifnum\segElemslen<4%
\ArrowPadding{\xrightarrow{\segElems[2]}^{\segElems[3]}}%
\else
\ifnum\segElemslen<6%
\ArrowPadding{\xrightarrow{\segElems[5]}}%
\else%
\ArrowPadding{\xrightarrow{\segElems[5]}^{\segElems[6]}}%
\fi\fi\fi\fi%
}}}\xspace}
\NewDocumentCommand\ToCOPSProg{sm}{
\ensuremath{%
\IfBooleanTF{#1}{\ArrowPadding{\xrightarrow{#2}}}{%
% split into segments
\setsepchar{->}%
\readlist*\stepElems{#2}%
\foreachitem\stepElem\in\stepElems{%
% split a segment
\setsepchar{{|}}%
\readlist*\segElems{\stepElem}%
% the base for each segment
% possible pattern $1
% possible pattern $1$2
% possible pattern $1->$2
% possible pattern $1->$2$3
% possible pattern $1$2$3
% possible pattern $1$2$3->$4
% possible pattern $1$2$3->$4$5
\ifnum\stepElemcnt<\stepElemslen%
% need an arrow
{\ifnum\segElemslen<3%
\segElems[1]\ArrowPadding{\xrightarrow{\segElems[2]}}%
\else
\ifnum\segElemslen<4%
\segElems[1]
\ArrowPadding{\xrightarrow{\segElems[2]}^{\segElems[3]}}%
\else
\ifnum\segElemslen<5%
\Tuple{\segElems[1],\segElems[2]},\segElems[3]
\ArrowPadding{\xrightarrow{\segElems[4]}}%
\else
\Tuple{\segElems[1],\segElems[2]},\segElems[3]
\ArrowPadding{\xrightarrow{\segElems[4]}^{\segElems[5]}}%
\fi\fi\fi}
\else
{\ifnum\segElemslen<2%
\segElems[1]%
\else%
\ifnum\segElemslen<3%
\segElems[1],\segElems[2]%
\else%
\Tuple{\segElems[1],\segElems[2]},\segElems[3]%
\fi\fi}\fi%
}}}\xspace}
\NewDocumentCommand\ToClockCmd{sm}{
\ensuremath{%
\IfBooleanTF{#1}{\xrightarrow{#2}}{%
% split into segments
\setsepchar{->}%
\readlist*\stepElems{#2}%
\foreachitem\stepElem\in\stepElems{%
% split a segment
\setsepchar{{|}}%
\readlist*\segElems{\stepElem}%
% the base for each segment
% possible pattern $1
% possible pattern $1$2
% possible pattern $1$2$3$4
% possible pattern $1->$2
% possible pattern $1->$2$3
% possible pattern $1$2$3$4->$5
% possible pattern $1$2$3$4->$5$6
\ifnum\stepElemcnt<\stepElemslen%
{% need an arrow
\ifnum\segElemslen<3%
\segElems[1]%
\ArrowPadding{\xrightarrow{\segElems[2]}}%
\else
\ifnum\segElemslen<4%
\segElems[1]%
\ArrowPadding{\xrightarrow{\segElems[2]}^{\segElems[3]}}%
\else
\ifnum\segElemslen<6%
\Tuple{\segElems[1],\segElems[2],\segElems[3]},\segElems[4]%
\ArrowPadding{\xrightarrow{\segElems[5]}}%
\else%
\Tuple{\segElems[1],\segElems[2],\segElems[3]},\segElems[4]%
\ArrowPadding{\xrightarrow{\segElems[5]}^{\segElems[6]}}%
\fi\fi\fi}
\else
{\ifnum\segElemslen<4%
\segElems[1]%
\else%
\Tuple{\segElems[1],\segElems[2],\segElems[3]}, \segElems[4]%
\fi}\fi%
}}}\xspace}
\NewDocumentCommand\ToCmdPri{m}{\xrightsquigarrow{#1}}
\newcommand{\toPROG}[1]{\ensuremath{\xrightarrow{#1}}}
\NewDocumentCommand\ToProg{sO{\et}m}{
\ensuremath{%
\IfBooleanTF{#1}{\xrightarrow{#3}_{#2}}{%
% split into segments
\setsepchar{->}%
\readlist*\stepElems{#3}%
\foreachitem\stepElem\in\stepElems{%
% split a segment
\setsepchar{{|}}%
\readlist*\segElems{\stepElem}%
% the base for each segment
% possible pattern $1
% possible pattern $1$2
% possible pattern $1->$2
% possible pattern $1$2->$3
% possible pattern $1$2->$3$4
% possible pattern $1$2$3$4
% possible pattern $1$2$3$4->$5
% possible pattern $1$2$3$4->$5$6
\ifnum\stepElemcnt<\stepElemslen%
{\ifnum\segElemslen<3%
\segElems[1]%
\else%
\ifnum\segElemslen<5%
\segElems[1],\segElems[2]%
\else%
\Tuple{\segElems[1] , \segElems[2], \segElems[3]}, \segElems[4]%
\fi\fi}%
% need an arrow
{\ifnum\segElemslen<3%
\ArrowPadding{\xrightarrow{\segElems[2]}_{#2}}%
\else%
\ifnum\segElemslen<4%
\ArrowPadding{\xrightarrow{\segElems[3]}_{#2}}%
\else%
\ifnum\segElemslen<5%
\ArrowPadding{\xrightarrow{\segElems[3]}_{#2}^{\segElems[4]}}%
\else%
\ifnum\segElemslen<6%
\ArrowPadding{\xrightarrow{\segElems[5]}_{#2}}%
\else%
\ArrowPadding{\xrightarrow{\segElems[5]}_{#2}^{\segElems[6]}}%
\fi\fi\fi\fi}
\else
{\ifnum\segElemslen<2%
\segElems[1]%
\else%
\ifnum\segElemslen<3%
\segElems[1],\segElems[2]%
\else%
\Tuple{\segElems[1] , \segElems[2], \segElems[3]}, \segElems[4]%
\fi\fi}%
\fi%
}}}\xspace}
\NewDocumentCommand\TOET{mmmmmm}{%
\ensuremath{(#2,#3)\ArrowPadding{\xrightarrow{#4}_{#1}}(#5,#6)}\xspace}
\NewDocumentCommand\ToET{O{\et} >{\SplitArgument{4}{|}} m}{\TOET #1 #2}
\NewDocumentCommand\ToRed{sO{\et}m}{
\ensuremath{%
\IfBooleanTF{#1}{\xrightarrow{#3}_{#2}}{%
% split into segments
\setsepchar{->}%
\readlist*\stepElems{#3}%
\foreachitem\stepElem\in\stepElems{%
% split a segment
\setsepchar{{|}}%
\readlist*\segElems{\stepElem}%
% the base for each segment
% possible pattern $1
% possible pattern $1$2
% possible pattern $1->$2
% possible pattern $1$2->$3
% possible pattern $1$2->$3$4
\ifnum\stepElemcnt<\stepElemslen%
{\ifnum\segElemslen<3%
\segElems[1]%
\else%
\Tuple{\segElems[1] , \segElems[2]}%
\fi}%
% need an arrow
{\ifnum\segElemslen<3%
\ArrowPadding{\xrightarrow{\segElems[2]}_{#2}}%
\else%
\ifnum\segElemslen<4%
\ArrowPadding{\xrightarrow{\segElems[3]}_{#2}}%
\else%
\ArrowPadding{\xrightarrow{\segElems[3]}_{#2}^{\segElems[4]}}%
\fi\fi}
\else
{\ifnum\segElemslen<2%
\segElems[1]%
\else%
\Tuple{\segElems[1] , \segElems[2]}%
\fi}%
\fi%
}}}\xspace}
\newcommand{\toEDGE}[1]{\ensuremath{\xrightarrow{#1}}}
\NewDocumentCommand\ToEdge{sm}{
\ensuremath{%
\IfBooleanTF{#1}{\rightsquigarrow}{%
% split into segments
\setsepchar{->}%
\readlist*\stepElems{#2}%
\foreachitem\stepElem\in\stepElems{%
% split a segment
\setsepchar{{|}}%
\readlist*\segElems{\stepElem}%
% the base for each segment
\segElems[1]%
\ifnum\stepElemcnt<\stepElemslen%
% need an arrow
\ifnum\segElemslen<2%
\ArrowPadding{\xrightarrow{}}%
\else%
\ArrowPadding{\xrightarrow{\segElems[2]}}%
\fi\fi%
}}}\xspace}
\NewDocumentCommand\ToAexecCmd{sO{\visaxioms}m}{
\ensuremath{%
\IfBooleanTF{#1}{\ArrowPadding{\xrightarrow{#3}_{#2}}}{%
% split into segments
\setsepchar{->}%
\readlist*\stepElems{#3}%
\foreachitem\stepElem\in\stepElems{%
% split a segment
\setsepchar{{|}}%
\readlist*\segElems{\stepElem}%
% the base for each segment
% possible pattern $1
% possible pattern $1$2
% possible pattern $1->$2
% possible pattern $1->$2$3
% possible pattern $1$2$3
% possible pattern $1$2$3->$4
% possible pattern $1$2$3->$4$5
\ifnum\stepElemcnt<\stepElemslen%
% need an arrow
{\ifnum\segElemslen<3%
\segElems[1]\ArrowPadding{\xrightarrow{\segElems[2]}_{#2}}%
\else
\ifnum\segElemslen<4%
\segElems[1]
\ArrowPadding{\xrightarrow{\segElems[2]}_{#2}^{\segElems[3]}}%
\else
\ifnum\segElemslen<5%
\Tuple{\segElems[1],\segElems[2]},\segElems[3]
\ArrowPadding{\xrightarrow{\segElems[4]}_{#2}}%
\else
\Tuple{\segElems[1],\segElems[2]},\segElems[3]
\ArrowPadding{\xrightarrow{\segElems[4]}_{#2}^{\segElems[5]}}%
\fi\fi\fi}
\else
{\ifnum\segElemslen<2%
\segElems[1]%
\else%
\ifnum\segElemslen<3%
\segElems[1],\segElems[2]%
\else%
\Tuple{\segElems[1],\segElems[2]},\segElems[3]%
\fi\fi}\fi%
}}}\xspace}
\NewDocumentCommand\ToAexecProg{sO{\visaxioms}m}{
\ensuremath{%
\IfBooleanTF{#1}{\ArrowPadding{\xrightarrow{#3}_{#2}}}{%
% split into segments
\setsepchar{->}%
\readlist*\stepElems{#3}%
\foreachitem\stepElem\in\stepElems{%
% split a segment
\setsepchar{{|}}%
\readlist*\segElems{\stepElem}%
% the base for each segment
% possible pattern $1
% possible pattern $1$2
% possible pattern $1->$2
% possible pattern $1->$2$3
% possible pattern $1$2$3
% possible pattern $1$2$3->$4
% possible pattern $1$2$3->$4$5
\ifnum\stepElemcnt<\stepElemslen%
% need an arrow
{\ifnum\segElemslen<3%
\segElems[1]\ArrowPadding{\xrightarrow{\segElems[2]}_{#2}}%
\else
\ifnum\segElemslen<4%
\segElems[1]
\ArrowPadding{\xrightarrow{\segElems[2]}_{#2}^{\segElems[3]}}%
\else
\ifnum\segElemslen<5%
\Tuple{\segElems[1],\segElems[2]},\segElems[3]
\ArrowPadding{\xrightarrow{\segElems[4]}_{#2}}%
\else
\Tuple{\segElems[1],\segElems[2]},\segElems[3]
\ArrowPadding{\xrightarrow{\segElems[4]}_{#2}^{\segElems[5]}}%
\fi\fi\fi}
\else
{\ifnum\segElemslen<2%
\segElems[1]%
\else%
\ifnum\segElemslen<3%
\segElems[1],\segElems[2]%
\else%
\Tuple{\segElems[1],\segElems[2]},\segElems[3]%
\fi\fi}\fi%
}}}\xspace}
\NewDocumentCommand\ToClockProg{sm}{
\ensuremath{%
\IfBooleanTF{#1}{\xrightarrow{#2}}{%
% split into segments
\setsepchar{->}%
\readlist*\stepElems{#2}%
\foreachitem\stepElem\in\stepElems{%
% split a segment
\setsepchar{{|}}%
\readlist*\segElems{\stepElem}%
% the base for each segment
% possible pattern $1
% possible pattern $1$2
% possible pattern $1->$2
% possible pattern $1$2->$3
% possible pattern $1$2->$3$4
% possible pattern $1$2$3$4
% possible pattern $1$2$3$4->$5
% possible pattern $1$2$3$4->$5$6
\ifnum\stepElemcnt<\stepElemslen%
{\ifnum\segElemslen<3%
\segElems[1]%
\else%
\ifnum\segElemslen<5%
\segElems[1],\segElems[2]%
\else%
\Tuple{\segElems[1] , \segElems[2], \segElems[3]}, \segElems[4]%
\fi\fi}%
% need an arrow
{\ifnum\segElemslen<3%
\ArrowPadding{\xrightarrow{\segElems[2]}}%
\else%
\ifnum\segElemslen<4%
\ArrowPadding{\xrightarrow{\segElems[3]}}%
\else%
\ifnum\segElemslen<5%
\ArrowPadding{\xrightarrow{\segElems[3]}^{\segElems[4]}}%
\else%
\ifnum\segElemslen<6%
\ArrowPadding{\xrightarrow{\segElems[5]}}%
\else%
\ArrowPadding{\xrightarrow{\segElems[5]}^{\segElems[6]}}%
\fi\fi\fi\fi}
\else
{\ifnum\segElemslen<2%
\segElems[1]%
\else%
\ifnum\segElemslen<3%
\segElems[1],\segElems[2]%
\else%
\Tuple{\segElems[1] , \segElems[2], \segElems[3]}, \segElems[4]%
\fi\fi}%
\fi%
}}}\xspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Short-hand for programs
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\va}{\var(a)}
\newcommand{\vb}{\var(b)}
\newcommand{\vx}{\var(x)}
\newcommand{\vw}{\var(w)}
\newcommand{\vvx}{\var(vx)}
\newcommand{\vy}{\var(y)}
\newcommand{\vvy}{\var(vy)}
\newcommand{\vz}{\var(z)}
\newcommand{\vtmp}{\var(tmp)}
\renewcommand{\defeq}{\triangleq}
