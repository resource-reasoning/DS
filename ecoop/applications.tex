\section{Applications}
\label{sec:applications}

To show the applications of our operational semantics, 
we use it to verify several distributed protocols (\cref{sec:verify-impl}) and
prove the invariants of transactional libraries (\cref{sec:robustness}).

\subsection{Application: Verifying Database Protocols}
\label{sec:verify-impl}
Kv-stores and views faithfully abstract the state of geo-replicated and partitioned
databases, and execution tests provide a powerful abstraction of the synchronisation mechanisms 
enforced by these databases when committing a transaction. 
This makes it possible to use our 
semantics to verify the correctness of distributed database protocols. 
We demonstrate this by showing that the replicated database,
COPS \cite{cops}, satisfies causal consistency.
We refer the reader to \cref{sec:cops} for the full details.
\ifTechRepEdits%
In the technical report,
\else%
In \cref{sec:clock-si}, 
\fi
we apply the same method to verify that 
Clock-SI \cite{clocksi}, a partitioned database, satisfies snapshot isolation.

\input{cops-graph.tex}

\mypar{COPS Protocol} 
COPS is a fully replicated database, with each replica storing multiple versions of each key as shown in \cref{fig:cops-after-write-transaction}. 
Each COPS version \( \ver \)
such as \( (\key_1,\val_1,(\txid_1,\repl_1), \emptyset) \) in \cref{fig:cops-after-write-transaction},
contains a key ($\key_1$), a value ($\val_1$), a \emph{unique} time-stamp ($\txid_1, \repl_1$) denoting
when a client first wrote the version to the replica, 
and a set of dependencies ($\emptyset$), written $\depOf[\ver]$. 
The time-stamp associated with a version $\ver$ has the form $(\txid, \repl)$, where $\repl$ identifies the replica that committed $\ver$, 
and $\txid$ denotes the local time when $\repl$ committed $\ver$. 
Each dependency in $\depOf[\ver]$ comprises a key and the time-stamp of the versions on which $\ver$ directly depends.  
We define the \( \DEP \) relation, \( (\txid,\repl) {\xrightarrow{\DEP}} (\txid',\repl') \),
to denote that the version with time-stamp \( (\txid,\repl) \) is included in the dependency set of the version with time-stamp \( (\txid',\repl')\).
COPS assumes a total order over replica identifiers. 
As such, versions can be totally ordered lexicographically. 

The COPS API provides two operations: \begin{enumerate*}
\item \( \pcopsput(\key,\val) \) for writing to a \emph{single}
key $\key$; and \item  \( \pcopsread(\keyset) \) for atomically reading from \emph{a set} of keys  $\keyset$.  
\end{enumerate*}
Operations from a client is processed by a single replica. 
Each client maintains a \emph{context}, which is a set of dependencies
tracking the versions the client observes.  

We demonstrate how a COPS client \( \cl \) interacts with a replica through the following example:
\(
    \prog_\CodeFont{cops-cl} \defeq \cl: \pcopsput(\key_1,\val_1) ; \ 
    \pcopsread(\List{\key_1,\key_2})
\).
For brevity, we assume that there are two keys, $\key_1$ and $\key_2$, 
and two replicas, $\repl_1$ and $\repl_2$, where $\repl_1 < \repl_2$ (\cref{fig:initial-cops}).
Initially, client \( \cl \) connects to replica \( \repl_1 \) and initialises its local context as $ctx {=} \emptyset$.
To execute its first single-write transaction, $\cl$ requests to write $\val_1$ to $\key_1$
by sending the message $(\key_1, \val_1, ctx)$ to its associated replica $\repl_1$
and awaits a reply.
Upon receiving the message, $\repl_1$ produces a monotonically increasing local time $\txid_1$, 
and uses it to install  a new version $\ver {=} (\key_1,\val_1, (\txid_1,\repl_1), ctx)$, as shown in \cref{fig:cops-after-write-transaction}.
Note that the dependency set of $\ver$ is the $\cl$ context ($ctx {=} \emptyset$).
Replica $\repl_1$ then sends the time-stamp $(\txid_1,\repl_1)$ back to $\cl_1$, and $\cl_1$ in turn  incorporates $(\key_1, \txid_1,\repl_1)$ in its local context,
\ie $\cl$ observes its own write. 
Finally, $\repl_1$ propagates the written version to other replicas \emph{asynchronously} by sending a \emph{synchronisation message} 
using \emph{causal delivery}:
when a replica $\repl'$ receives a version $\ver'$ from another replica $\repl$, 
it waits for all $\ver'$ dependencies to arrive at $\repl'$, and then accepts $\ver'$.
As such, the set of versions contained in each replica is closed with respect to the \( \DEP \) relation.
In the example above, when other replicas receive $\ver$ from $\repl_1$, they can immediately accept $\ver$ as \( \depOf[\ver]{=}\emptyset\). 
Note that replicas may accept new versions from different clients in parallel.

To execute its second multi-read transaction,
client  \( cl \) requests to read from the $\key_1, \key_2$ keys by sending the message 
\( \Set{\key_1, \key_2} \) to replica $\repl_1$ and awaits a reply.
Upon receiving this message, $\repl_1$ builds a \emph{\( \DEP \)-closed snapshot} (a mapping from $\Set{\key_1, \key_2}$ to values) in two phases as follows. 
First, $\repl_1$ \emph{optimistically reads} the most recent versions for $\key_1$ and $\key_2$,
\emph{one at a time}. 
This process may be interleaved with other writes and synchronisation messages. 
For instance, \cref{fig:cops-request-values} depicts a scenario where \( \repl_1 \):
\begin{enumerate*}
	\item first reads \( (\key_1,\val_1,(\txid_1,\repl_1), \emptyset) \) for $\key_1$ (highlighted); %(highlighted in \cref{fig:cops-request-values})
	\item then receives two synchronisation messages from \( \repl_2 \), 
containing versions \( ( \key_1, \val'_1, (\txid_1,\repl_2),\emptyset ) \) and \( ( \key_2, \val'_2, (t_2,\repl_2),\Set{(\key_1,\txid_1,\repl_2)} ) \); and
	\item finally reads \( ( \key_2, \val'_2, (t_2,\repl_2),\Set{(\key_1,\txid_1,\repl_2)} ) \) for $\key_2$ (highlighted).
\end{enumerate*}
As such, the current snapshot for \( \Set{\key_1,\key_2}\) are not \( \DEP \)-closed: 
\( ( \key_2, \val'_2, (t_2,\repl_2),\Set{(\key_1,\txid_1,\repl_2)} ) \) depends on 
a $\key_1$ version with time-stamp $(\txid_1, \repl_2)$ which is bigger than $(\txid_1, \repl_1)$ for $\key_1$.
To remedy this, after the first phase of optimistic reads,
$\repl_1$ combines (unions) all dependency sets of the versions from the first phase as a \emph{re-fetch set},
and uses it to \emph{re-fetch}
the most recent version of each key with the biggest time-stamp 
from the union of the re-fetch set and the versions from the first phase.
For instance, in \cref{fig:cops-re-read-values}, replica $\repl_1$ re-fetches 
the newer version \( ( \key_1, \val'_1, (\txid_1,\repl_2),\emptyset ) \) for \( \key_1 \).
Finally, the snapshot obtained after the second phase 
are sent to the client, and then added to the client context.
For their specific setting, Lloyd et al. \citet{cops} \emph{informally} argue that the snapshot sent to the client is causally consistent.
By contrast, in what follows we \emph{verify} the COPS protocol with our general definition of causal consistency.


\mypar{COPS Verification} 
We define an operational semantics for the COPS protocol, which allows fine-grained single reads and writes of a key.
Using our semantics, we then show that COPS traces can be refined to traces in our semantics using \( \ET[\CC] \) in three steps:
\begin{enumerate*}
\item every COPS trace can be transferred to a normalised COPS trace, 
in which multiple reads of a transaction are not interleaved by other transactions; and
\item the normalised COPS trace can be refined to traces in our semantics, in which \item each step satisfies \( \ET[\CC] \).
\end{enumerate*}

The COPS Operational semantics
describes transitions over abstract states \( \copsconf \) comprising a set of replicas,
a set of client contexts and a program.
For instance, the COPS trace that produces \cref{fig:cops-request-values,fig:cops-re-read-values} is depicted in \cref{fig:cops-trace}, stating that
given client \(\cl\) and replica \( \repl_1 \),
\begin{enumerate*}
\item \( \cl \) writes version \( (\opW,\key_1, (\txid_1,\repl_1)) \) to $\repl_1$;
\item \( \cl \) starts a multi-read transaction (\( \mathtt{s} \));
\item \( \cl \) reads \( (\opR,\key_1, (\txid_1,\repl_1)) \) from $\repl_1$;
\item \( \repl_1 \) receives synchronisation messages (\(\mathtt{sync}\));
\item \( \cl \) reads \( (\opR,\key_2, (\txid_2,\repl_2)) \) from $\repl_1$;
\item \( \cl \) enters the second phase of the multi-read transaction (\(\mathtt{p}\));
\item an arbitrary step \( \lb \) interferes;
\item \( \cl \) re-fetches the version \( (\opR,\key_1, (\txid_1,\repl_2)) \) from \( \repl_2 \) and puts the version in the snapshot;
\item an arbitrary step \( \lb' \) interferes;
\item \( \cl \) puts the version \( (\opR,\key_2, (\txid_2,\repl_2)) \) in the snapshot;
\item \( \cl \) reads the values in the snapshot and commits the transaction (\(\mathtt{e}\)).
\end{enumerate*}

\input{cops-trace.tex}

Recall that a multi-read transaction does not execute atomically in the replica,
which is captured by multiple read transitions in the trace.
For example, the \( \lb\) and \( \lb' \) steps in \cref{fig:cops-trace}
interleave the multi-read transaction from \( \cl \).
Note that the optimistic reads are not observable to the client and
thus it suffices to show that the reads from the second re-fetch phase are atomic.
To show this, we \emph{normalise} the trace as follows. 
For any multi-read transaction, 
we move all reads from the re-fetch phase to the right towards the return step \( \mathtt{e}\),
so that these reads are no longer interleaved by others.
An example of a normalised trace is given in \cref{fig:cops-normalise}.
For any multi-read transaction,
the re-fetch phase can only read a version committed before the \( \mathtt{p}\) step.
For example, in \cref{fig:cops-trace} (top)
the multi-read transaction from \( \cl \) can only read versions in \( \copsconf_5 \) and before.
As such, normalising traces does not alter the returned versions of transactions.
After normalisation, transactions in the resulting trace can be seen as if executed atomically. 

We next show that normalised COPS traces can be refined to traces in our semantics.
To do this, we encode the abstract COPS states \(\copsconf \) as configurations
in our operational semantics (\cref{fig:encode-mkvs}). 
We map all COPS replicas to a single kv-store.
The writer of a mapped version is uniquely
determined by the time-stamp of the corresponding COPS version, 
while its reader set 
can be recovered by annotating read-only transactions in the traces such as \( \txidrd \) in \cref{fig:encode-mkvs}.
For example, the COPS state in \cref{fig:cops-after-write-transaction}
can be encoded as the kv-store depicted in \cref{fig:encode-mkvs}.
Similarly, as the context of a client $\cl$ identifies the set of COPS versions that $\cl$ sees, 
we can project COPS client contexts to our client views over kv-stores. 
For example, the contexts of \( \cl \) 
before and after committing its second multi-read transaction in \( \prog_{\CodeFont{COPS}} \) 
is encoded as the client view depicted in \cref{fig:encode-view}.

We finally show that every step in the kv-store trace satisfies \( \et[\CC] \).
Note that existing verification techniques \cite{framework-concur,seebelieve} require examining 
the \emph{entire} sequence of operations of a protocol to show that it implements a consistency model.
By contrast, we only need to look at how the state evolves after a \emph{single} transaction is executed.
In particular, we check the client views over the kv-store.
Intuitively, we observe that when a COPS client $\cl$ executes a transaction then:
\begin{enumerate*} 
\item the $\cl$ context grows, and thus we obtain a more up-to-date view of the associated kv-store; \ie $\vshiftname_{\MR}$ holds;
\item the $\cl$ context always includes the time-stamp of the versions written by itself, and thus the 
corresponding client view always includes the versions $\cl$ has written; \ie $\vshiftname_{\RYW}$ holds; and
\item the $\cl$ context is always closed to the relation \( \DEP \), 
which contains the relation $\SO \cup \WR[\mkvs]$; \ie $\closed[\mkvs, \vi, \rel[\CC]]$ holds.
\end{enumerate*}
We have thus demonstrated that COPS satisfies causal consistency (see \cref{sec:cops} for the full details).

\subsection{Application: Invariant Properties of Transactional Libraries}
\label{sec:program-analysis}
\label{sec:robustness}
\label{sec:invariant-client-programs}

A transactional library provides 
a set of transactional operations which can be used by its clients to access the underlying kv-store.
For instance, the counter library on key $\key$ in \cref{sec:overview} is defined as
$\Counter(\key) \defeq \Set{\ctrinc(\key), \ctrread(\key)}$.
Our operational semantics enables us to prove invariant properties of kv-stores, such as:
\begin{enumerate*}
\item the robustness of the single
counter library discussed above against \(\PSI\);
\item the robustness of a multi-counter library and the well-known  banking library \citet{bank-example-wsi} against \( \SI \); and
\item the correctness of a program pattern using locks against \( \UA \), even though it is not robust.
\end{enumerate*}
We prove the second by identifying a general  transaction pattern that
guarantees robustness against $\WSI$, and hence $\SI$. 


\mypar{Robustness of a Single Counter against $\PSI$}

A library $L$ is \emph{robust} against an execution test $\ET$
if, for all client programs \( \prog \) of $L$, 
the kv-stores \( \kvs \) obtained under $\ET$ can also be obtained under $\SER$ (serialisability):
that is, for any reachable kv-store \( \kvs \) such that
\( \ToProg{\kvs_0 | \vienv_0 | \clenv | \prog | \stub | * -> \kvs | \stub | \stub | \stub }\),
for the initial kv-store \( \kvs_0 \), view environment \( \vienv_0 \) and an arbitrary client environment \( \clenv \),
then \( \kvs {\in} \CMs(\SER) \).
We proceed with the definition of $\CMs(\SER)$. %serialisability.

 \SpaceAboveDef
\begin{definition}
\label{thm:serialisable_nocycle}
A kv-store $\mkvs {\in} \CMs(\SER)$ iff $(\SO {\cup} \WR[\mkvs] 
{\cup} \WW[\mkvs] {\cup} \RW[\mkvs])^{+} \cap \CodeFont{Id} = \emptyset$.
\end{definition}
\SpaceBelowDef

\Cref{thm:serialisable_nocycle} states that a kv-stores obtained under a trace satisfies serialisability iff it contains no cycles. %, and vice versa.
While previous static analysis techniques for checking robustness \citep{giovanni_concur16,SIanalysis,laws,sureshConcur}
did not support client sessions, 
we give the first robustness proof that has client sessions.

In the single-counter library, $\Counter(\key)$, 
a client reads from $\key$ by calling $\ctrread(\key)$, and writes to $\key$ by calling $\ctrinc(\key)$ 
which first reads the value of $k$ and subsequently increments it by one.
As $\PSI$ enforces write-conflict freedom (\(\UA\)),
we know that if a transaction $\txid$ updates $\key$ (by calling $\ctrinc(\key)$) and writes version $\ver$ to $\key$, 
then it must have read the version of $\key$ immediately preceding $\ver$:
$\fora{\txid, i > 0} \txid {=} \wtOf(\mkvs(\key, i)) \implies \txid \in \rsOf(\mkvs(\key, i{-}1))$. 
Moreover, as $\PSI$ enforces monotonic reads ($\MR$),
the order in which clients observe the versions of $\key$ (by calling $\ctrread(\key)$)
is consistent with the order of versions in $\mkvs(\key)$. 
As such, the invariant illustrated below always holds (\ie the kv-store is always has the depicted shape), where  
$\{\txid^{\CodeFont{}}_{i}\}_{i=1}^{n}$ and $\bigcup_{i=0}^{n} \txidset^{\CodeFont{}}_{i}$ 
denote disjoint sets of transactions calling $\ctrinc(\key)$ and $\ctrread(\key)$, respectively:
%
\begin{center}
\begin{tabular}{@{} c @{\qquad}| c @{} }
{%
\displaymathfont
\(%
\begin{multlined}
    \\[-40pt]
    (0, \txid_{0}, \txidset_{0} \cup \Set{\txid_1}) 
	\lcat (1, \txid_{1}, \txidset_{1} \cup \Set{\txid_2}) \lcat \cdots 
    \\ \lcat (n{-}1, \txid_{n{-}1}, \txidset_{n{-}1} \cup \Set{\txid_n})
	\lcat (n, \txid_n, \txidset_{n}) 
\end{multlined}
\)%
\normalsize
}%
%
& 
%
\scalebox{.6}{%
\begin{tikzpicture}%
\KVMapping{x}{ \key }{ %
     /0/\txidinit/\txidset_0 \uplus \Set{\txid_1} 
    , /1/\txid_1/\txidset_1 \uplus \Set{\txid_2} 
    , /\cdots/\cdots/\cdots
	, /n-1/\txid_{n-1}/\txidset_{n-1} \uplus \Set{\txid_{n}} 
	, /n/\txid_{n}/\txidset_{n}
};




\path[->,dashed,thick]  (Writerx1) edge[bend left=30] (Readersx1)
                        (Readersx1) edge[bend left=30] (Writerx2)
                        (Writerx2) edge[bend left=30] (Readersx2)
                        (Readersx2) edge[bend left=30] (Writerx3) 
                        (Writerx3.east) edge[bend left=30] (Readersx3.east)
                        (Readersx3.east) edge[bend left=30] (Writerx4) 
                        (Writerx4) edge[bend left=30] (Readersx4)
                        (Readersx4) edge[bend left=30] (Writerx5) 
                        (Writerx5.east) edge[bend left=30] (Readersx5.east);
\draw[->,dashed,thick]  ([xshift=-3pt]Readersx1.south) to[out=270, in=180] ([yshift=-15pt]Readersx1.south) 
                    to[out=0, in=270] ([xshift=3pt]Readersx1.south);
\draw[->,dashed,thick]  ([xshift=-3pt]Readersx2.south) to[out=270, in=180] ([yshift=-15pt]Readersx2.south) 
                    to[out=0, in=270] ([xshift=3pt]Readersx2.south);
\draw[->,dashed,thick]  ([xshift=-3pt]Readersx3.south) to[out=270, in=180] ([yshift=-15pt]Readersx3.south) 
                    to[out=0, in=270] ([xshift=3pt]Readersx3.south);
\draw[->,dashed,thick]  ([xshift=-3pt]Readersx4.south) to[out=270, in=180] ([yshift=-15pt]Readersx4.south) 
                    to[out=0, in=270] ([xshift=3pt]Readersx4.south);
\draw[->,dashed,thick]  ([xshift=-3pt]Readersx5.south) to[out=270, in=180] ([yshift=-15pt]Readersx5.south) 
                    to[out=0, in=270] ([xshift=3pt]Readersx5.south);
\end{tikzpicture}%
}

\end{tabular}
\end{center}

%\pg{Above: consistency of ordering of {t} u T.}

%\pg{Where you can, change `i.e.' to `that is,'. Most of the time there
  %is not a space issue, use `i.e.' and e.g.' only when there's no
  %other way of fitting on a line. In thesis, never use unless in
  %tables or something like that.}

\noindent
We define the $\dashrightarrow$ relation depicted above by extending the relation
$ \rel \defeq \SO \cup 
\{
	(\txid, \txid') 
	\mid 
    \Exists{i}
    \left( 
        \txid = \txid_i
        \allowbreak \land  (\txid' = \txid_{i+1} \lor \txid' \in \txidset_i)
    \right)
    \allowbreak \lor 
    \left(
	\txid \in \txidset_i 
    \allowbreak \land
    \txid' = \txid_{i+1}
    \right)
\}$
to a strict total order (\ie an irreflexive and transitive relation that is total). 
Note that $\dashrightarrow$ contains $\SO \cup \WR[\mkvs] \cup \WW[\mkvs] \cup \RW[\mkvs]$ and thus
$(\SO \cup \WR[\mkvs] \cup \WW[\mkvs] \cup \RW[\mkvs])^+$ is irreflexive;
that is,  $\Counter(\key)$ is robust against $\PSI$.
By contrast, a multi-counter library is not robust against $\PSI$. A multi-counter library 
on a set of keys \( \keyset \) is
\( \mathsf{Counters}(\keyset) \defeq \bigcup_{\key \in \keyset} \Counter(\key) \).
Recall from \cref{sec:overview} that unlike in $\SER$ and $\SI$, clients of the multi-counter library under
$\PSI$  can observe 
the increments on different keys in different orders (see \cref{fig:cp-disallowed}).
Hence, the multi-counter library is not robust against $\PSI$. 

The next results demonstrate that 
the multi-counter library and the banking library from
\citet{bank-example-wsi} are robust against \( \SI \).
To prove these results, we identify a general pattern for
transactions, called \emph{\( \WSI \)-safe}; 
and then prove a general robustness result
against $\WSI$ for transactional libraries that satisfy this pattern. 
The proof of this general robustness result  uses the following two 
acyclic properties of kv-stores. 



\mypar{Acyclicity Invariants of Kv-stores}
We prove two general acyclicity properties on kv-stores as invariants: 
\begin{enumerate*}
	\item a kv-store \( \kvs\) reachable under \( \et[\top] \) contains no \( (\SO {\cup} \WR[\mkvs]) \) cycles (\cref{thm:acyclic-cc}), where \( \et[\top] \) is the most permissive execution test defined in
\cref{def:cm}; and 
	\item a kv-store \( \kvs\) reachable under \( \et[\CP] \) contains no \( ((\SO {\cup} \WR[\mkvs]); \RW[\mkvs]^{-1})\) cycles (\cref{thm:acyclic-cp}).
\end{enumerate*}

%\SpaceAboveDef
\begin{theorem}
\label{thm:acyclic-cc}
Any kv-store \( \kvs \in \CMs(\et[\top]) \) satisfies \( (\SO {\cup} \WR[\mkvs])^{+} \cap \CodeFont{Id} = \emptyset \).
\end{theorem}
%\SpaceBelowDef

\begin{proof}[Proof (sketch)]
From the definition of \( \CMs \) (\cref{def:cm})
we know a kv-store \( \kvs \in \CMs(\et[\top]) \) must be reachable with a given program.
This means that \cref{thm:acyclic-cc} can be seen as an invariant property.
We prove it by induction on the length of a trace.
For the base case, the initial kv-store \( \kvs_0 \) trivially contains no cycles.
For the inductive case, since local computation steps do not rely on the kv-store,
let us focus on the case where the last transaction step has the form:
\( \ToProg{\kvs | \vienv | \clenv | \prog | \lbTrans{\vi,\fp} -> \kvs' | \vienv' | \clenv' | \prog' } \),
where \( \kvs \) contains no \(\rel \defeq (\SO {\cup} \WR[\mkvs]) \) cycles by the inductive hypothesis.
Let \( \txid \) be the new transaction in \( \kvs' \).
We then proceed by contradiction and assume that \( \kvs' \) has a $\rel$ cycle.
As $\kvs$ contains no $\rel$ cycles, this cycle must involve  \( \txid \), \ie
\(
\ToEdge{\txid | \rel -> \txid_1 | \rel -> \cdots | \rel -> \txid_n | \rel -> \txid}, 
\)
where  \( \txid_1, \cdots,  \txid_n \) are distinct.
%Consider \( \ToEdge{\txid | R -> \txid_1} \).
As \( \txid \) is the last transaction and \( \txid \notin \kvs\),
we cannot have \( \ToEdge{\txid | \SO -> \txid_1} \).
Similarly, all versions written by \( \txid \) have empty reader sets, and .
thus we cannot have \( \ToEdge{\txid | \WR[\mkvs'] -> \txid_1} \).
This then leads to a contradiction as \( \ToEdge{\txid | {\SO {\cup} \WR[\mkvs']} -> \txid_1} \).
Therefore, the new kv-store \( \kvs' \) satisfies \( (\SO {\cup} \WR[\mkvs'])^{+} \cap \CodeFont{Id} = \emptyset \).
\renewcommand{\qed}{}
\end{proof}
\SpaceAboveDef
\begin{theorem}
\label{thm:acyclic-cp}
Any kv-store \( \kvs \in \CMs(\et[\CP]) \) satisfies \( ((\SO {\cup} \WR[\mkvs]) ; \RW[\kvs]^? )^{+}  \cap \CodeFont{Id} = \emptyset \).
\end{theorem}
%\SpaceBelowDef
\begin{proof}[Proof (sketch)]
We proceed as in the proof of \cref{thm:acyclic-cc}.
For the inductive case, consider 
\( \ToProg{\kvs | \vienv | \clenv | \prog | \lbTrans{\vi,\fp} -> \kvs' | \vienv' | \clenv' | \prog' } \),
where \( \kvs \) contains no \(\rel \defeq ((\SO {\cup} \WR[\mkvs]) ; \RW[\kvs]^? )\) cycles by the inductive hypothesis.
Let us then assume $\kvs'$ has a $\rel$ cycle which must include the new transaction \( \txid \).
There are then two cases as follows where \( \txid_1, \cdots, \txid_n \) are distinct: 
\begin{enumerate}
\item
\(
\ToEdge{\txid | \rel -> \txid_1 | \rel -> \cdots | \rel -> \txid_n | \rel -> \txid}
\)\\
This cycle cannot exist as $\txid$ is the last transaction in $\kvs'$. 
More concretely, as in \cref{thm:acyclic-cc} we know we cannot have \( \ToEdge{\txid | \SO -> \txid_1} \) or  \( \ToEdge{\txid | \WR[\mkvs'] -> \txid_1} \).
For analogous reasons, we cannot have \( \ToEdge{\txid | \SO -> \txid' | \RW[\kvs'] -> \txid_1 } \) or \( \ToEdge{\txid | \WR[\kvs'] -> \txid' | \RW[\kvs'] -> \txid_1 } \),
for some transaction \( \txid' \in \kvs \).

\item 
\(
\ToEdge{ \txid_1 | \rel -> \cdots | \rel -> \txid_n | (\SO {\cup} \WR[\mkvs']) -> \txid | \RW[\kvs'] -> \txid_1}
\)\\
From \( \et[\CP] \) the view \( \vi \) of \( \txid \) must contains all versions written by \( \txid_1, \cdots, \txid_n \).
As such, we cannot have \(\ToEdge{ \txid | \RW[\kvs'] -> \txid_1 } \) 
as by \( \RW[\kvs'] \) we know \( \vi \) is behind the versions written by \( \txid_1 \).
\end{enumerate}
\renewcommand{\qed}{}
\end{proof}
%\pg{Again I'm not sure about lots to do with the cycle bit.} 

\mypar{Robustness Conditions against $\WSI$}

Many libraries \citep{snapshot-isolation-robust-tool,giovanni_concur16,bank-example-wsi} 
yield kv-stores with a particular pattern that guarantees 
robustness against \( \WSI \).
These libraries are often shown to be robust against \( \SI \) by individually checking all final results of all their client programs.
By contrast, we prove robustness \emph{more systematically} by identifying a pattern, \emph{$\WSI$-safety}, and showing that the invariant satisfies $\WSI$-safety at each step.

%\pg{Above: para can be made stronger.}

%\pg{I'm confused. The WSI-safe condition is really about transactions
  %of e.g. a library. I don't know why theorem 15 isn't: Any WSI-safe
  %transaction libray is rocust against WSI. It does mean that any
  %reachable kv-store is WSI-safe, but 14 and 15 seem a little off.}

\SpaceAboveDef
\begin{definition}[\(\WSI\)-safe]
\label{def:main-body-wsi-safe}
A library is \emph{\(\WSI\)-safe}
iff for all its client programs $\prog$ and all kv-stores \( \kvs \), 
if $\kvs$ is  obtained by executing \( \prog \) under $\WSI$ 
(\ie \( \ToProg[{\ET[\WSI]}]{\kvs_0 | \vienv_0 | \clenv | \prog | \stub | * -> \kvs | \stub | \stub | \stub }\)),
then $\kvs$ satisfies the following for all $\txid, \key, i,i'$:
%
%\SpaceAboveMath
\begin{align}
     & \txid \in \rsOf[\mkvs(\key,i)] \land \txid \neq \wtOf[\mkvs(\key,i')]  \implies \fora{\key',j} \txid \neq \wtOf[\mkvs(\key',j)] , \label{equ:main-wsi-safe-read-only} \\
     & \txid \neq \txid_0 \land \txid = \wtOf[\mkvs(\key,i)] \implies \exsts{j} \txid \in \rsOf[\mkvs(\key,j)] , \label{equ:main-wsi-safe-write-must-read} \\
     & \txid \neq \txid_0 \land \txid = \wtOf[\mkvs(\key,i)] \land \exsts{k',j,j'} \txid \in \rsOf[\mkvs(\key',j)] \implies \txid = \wtOf[\mkvs(\key',j')] . \label{equ:main-wsi-safe-all-write}
\end{align}
%\SpaceBelowMath
%
\end{definition}
%\SpaceBelowDef

%\pg{Above: I believe Gamma0 is (K0, U0, E) for arb E. I could not find
  %it on quick look.}

That is, %a kv-store $\mkvs$ is \(\WSI\)-safe if for each transaction $\txid$: 
\begin{enumerate*} 
\item if a transaction $\txid$ reads from $\key$ but does not write to it, 
then $\txid$ must be a read-only transaction \eqref{equ:main-wsi-safe-read-only}; 
\item if \( \txid \) writes to $\key$, then it must also read from it \eqref{equ:main-wsi-safe-write-must-read}, a property known as \emph{no-blind writes}; and
\item if \( \txid \) writes to $\key$, then it must also write to all keys it reads from \eqref{equ:main-wsi-safe-all-write}.
\end{enumerate*}
It is straightforward to see (from $\UA$) that the version $j$ read by \(
\txid \) in \eqref{equ:main-wsi-safe-write-must-read} must be written
immediately before the version $i$ written by \( \txid \), \ie \( i
= j {+} 1 \). 

%\SpaceAboveDef
\begin{theorem}[\( \WSI \) robustness]
 \label{thm:main-wsi-robust}
    A \(\WSI\)-safe library \( L \) is robust against \(\WSI\).   
\end{theorem}
\SpaceBelowDef
%
\input{acyclic-fig}
%
\begin{proof}[Proof (sketch)]
Pick a library \( L \), a client program \( \prog \) of  $L$ and a kv-store \( \kvs \) obtained from executing \( \prog \) under $\WSI$;
\ie \( \ToProg[{\ET[\WSI]}]{\kvs_0 | \vienv_0 | \clenv | \prog | \stub | * -> \kvs | \stub | \stub | \stub }\).
From \cref{thm:serialisable_nocycle} it suffices to prove that $(\SO \cup \WR[\mkvs] \cup \WW[\mkvs] \cup \RW[\mkvs])^{+}$ is acyclic.
We proceed by contradiction.
Let us assume there exists $\txid_1$ such that $\txid_1 \toEDGE{\!\!(\SO \cup \WR[\mkvs] \cup \WW[\mkvs] \cup \RW[\mkvs])^{+}\!\!} \txid_1$. 
From \cref{thm:acyclic-cc} we know \( (\SO \cup \WR[\mkvs])^{+} \) is acyclic.
Moreover, thanks to no-blind-writes in \eqref{equ:main-wsi-safe-write-must-read} and \( \UA \),
any \( \WW[\mkvs](\key)\) edge on a key \( \key \) can be replaced by \( \WR[\mkvs]^{+}(\key) ) \), 
as illustrated in \cref{fig:wr-replace-ww}.
As such, \( (\SO \cup \WR[\mkvs])^{+} \cup \WW[\kvs]\) is acyclic and thus this cycle is of the form:
\(
    \txid_1 \toEDGE{\!\!\rel^*\!\!} \,\toEDGE{\!\!\RW\!\!}\, \toEDGE{\!\!\rel^*\!\!} \cdots \,\toEDGE{\!\!\rel^*\!\!}\, \toEDGE{\!\!\RW\!\!}\, \toEDGE{\!\!\rel^*\!\!}\, \txid_1
\),
where \( \rel \defeq \SO \cup \WR \cup \WW \).
From \eqref{equ:main-wsi-safe-all-write} we know 
an \( \RW[\mkvs](\key_1) \) edge on a key \( \key_1 \) starting from 
a writing transaction \( \txid \) can be replaced by a \( \WW \) edge,
as illustrated in \cref{fig:ww-replace-rw}.
%Note that \( \txid \) might not write to a different key \( \key_2 \).
%However, by the \( \RW[\mkvs](\key_1) \) edge, \( \txid \) reads \( \key_1 \),
%and by \eqref{equ:main-wsi-safe-all-write}, it must also write to \( \key_1 \).
Moreover, from \eqref{equ:main-wsi-safe-write-must-read} we know we can replace \( \WW \) edges by \( \WR^+ \).
We thus have:
\(
    \txid_1 \toEDGE{\!\!{\rel'}^*\!\!} \,\toEDGE{\!\!\RW\!\!}\, \toEDGE{\!\!{\rel'}^+\!\!} \cdots \toEDGE{\!\!{\rel'}^+\!\!} \,\toEDGE{\!\!\RW\!\!} \,\toEDGE{\!\!{\rel'}^*\!\!} \txid_1
\),
where \( \rel' \defeq \SO \cup \WR  \);
\ie \( \txid_1 \toEDGE{( \rel'; \RW^? )^* } \txid_1 \).
This, however, leads to a contradiction by \cref{thm:acyclic-cp}.
\renewcommand{\qed}{}
\end{proof}
%\pg{Above: do you mean  (SO U WR)+ u 
  %WW or   (SO u WR u WW)+.}

\mypar{Robustness of a Banking Library against $\WSI$}

%\pg{Say why this banking example is interesting.}

Using \cref{thm:main-wsi-robust}, we can prove the robustness of the banking library in
\citet{bank-example-wsi} against \( \WSI \), and hence  \( \SI \).
Alomari et al. \citet{bank-example-wsi} informally argued this example is robust:
\begin{enumerate*}
\item they identified a notion of dangerous dependency between transactions,
which, they argued, can lead to violation of robustness of \( \SI \); and
\item they argued this banking example contains no such dangerous dependencies.
\end{enumerate*}
The banking example is based on relational databases and has three tables: \emph{account}, \emph{saving} and \emph{checking}.
The account table maps customer names to customer IDs (\( \codeFont{Account(\underline{Name}, CID )} \)).
The saving table maps customer IDs to their saving balances (\( \codeFont{Saving(\underline{CID}, Balance )} \)), and
the checking table maps customer IDs to their checking balances (\( \codeFont{Checking(\underline{CID}, Balance )} \)).
The balance of a saving account must be non-negative; a checking account may have a negative balance.

For simplicity, we encode the saving and checking tables as a single kv-store,
and forgo the account table as it is an immutable lookup table.
We model a customer ID as an integer \( n \in \mathbb{N}\), and assume
that the balances are integer values. 
We then define the key associated with customer $n$ in the checking table as 
$n_c \defeq 2 n$,
and define the key associated with $n$ in the saving table as 
$n_s \defeq 2n {+} 1$. 
That is, \( \Keys \defeq \bigcup_{n \in \Nat} \Set{n_c, n_s} \).
Moreover, if \( n \) identifies a customer (\ie $(\stub, n) \!\in\! \codeFont{Account(\underline{Name}, CID )}$),
then
\( (n, \valueOf[\mkvs(n_s, \abs{\mkvs(n_s)} {-} 1)]) \!\in\! \codeFont{Saving(\underline{CID}, Balance )} \)
and \( (n, \valueOf[\mkvs(n_c, \abs{\mkvs(n_c)} {-} 1)]) \in \codeFont{Checking(\underline{CID}, Balance )} \).

The banking library provides five transactional operations:
%
%\SpaceAboveMath
\begin{align*}
    \codeFont{balance(n)} & \defeq
    \begin{transaction}
    \plookup{\pv{x}}{\pv{n}_c}; \ 
    \plookup{\pv{y}}{\pv{n}_s}; 
    \\ \passign{\ret}{\pv{x}+\pv{y}}
    \end{transaction} 
    & 
    \codeFont{depositCheck(n,v)} & \defeq
    \begin{transaction}
    \pifs{\pv{v} \geq 0} 
    \\ \plookup{\pv{x}}{\pv{n}_c}; \ 
    \pmutate{\pv{n}_c}{\pv{x} + \pv{v}} \ 
    \pife
    \end{transaction}
\end{align*}
%
\SpaceBelowMath
%
%\SpaceAboveMath
\begin{align*}
    \codeFont{transactSaving(n,v)} & \defeq
    \begin{transaction}
    \plookup{\pv{x}}{\pv{n}_s}; \
    \pifs{\pv{v} + \pv{x} \geq 0} \ 
    \pmutate{\pv{n}_s}{\pv{x} + \pv{v}} \ 
    \pife
    \end{transaction} 
    \\
	\codeFont{amalgamate(n,n')} & \defeq
    \begin{transaction}
    \plookup{\pv{x}}{\pv{n}_s}; \ 
    \plookup{\pv{y}}{\pv{n}_c}; \ 
    \plookup{\pv{z}}{\pv{n'}_c}; \\
    \pmutate{\pv{n}_s}{0}; \ 
    \pmutate{\pv{n}_c}{0}; \ 
    \pmutate{\pv{n'}_c}{\pv{x} + \pv{y} + \pv{z}} 
    \end{transaction} 
    \\
    \codeFont{writeCheck(n,v)} & \defeq
    \begin{transaction}
    \plookup{\pv{x}}{\pv{n}_s}; \ 
    \plookup{\pv{y}}{\pv{n}_c};\\
    \pifs{\pv{v} > 0 \  \&\& \ \pv{x} + \pv{y} < \pv{v} }\\
    		\quad \pmutate{\pv{n}_c}{\pv{y} - \pv{v} - 1 } \ \}
    \CodeFont{else\{} 
        \pmutate{\pv{n}_c}{\pv{y} - \pv{v} }  
    \pife \\
    \pmutate{\pv{n}_s}{\pv{x}}
    \end{transaction}     
\end{align*}
%
%\SpaceBelowMath
%
%\pg{Above: in trasactSaving, should it be x-v, you have inconsistency
  %ebtween the maths and th English.}
%
%\pg{I don't understand where the ; should be. In this theory work,
  %normally you would ahve e.g. in writeCheck, no ; after the primitive
  %commands and a ; before [ns] := x. Throught paper and thesis, be
  %consistent with the stype of our language, not what's written in 
%the examples in the literature.}
%
The \( \codeFont{balance(n)} \) operation returns the total balance of customer \codeFont{n} in  \( \ret \).
The \codeFont{depositCheck} \codeFont{(n,v)} deposits \codeFont{v} to the checking account of customer \codeFont{n} when \codeFont{v} is non-negative,
otherwise it leaves the checking account unchanged.
When $\codeFont{v} \geq 0$,  \( \codeFont{transactSaving(n,v)} \) deposits \codeFont{v} to the saving account of \codeFont{n}.
When $\codeFont{v} < 0$, \( \codeFont{transactSaving(n,v)} \) withdraws \codeFont{v} from the saving account of \codeFont{n} only if the resulting balance is non-negative,
otherwise the saving account remains unchanged.
The \( \codeFont{amalgamate(n,n')} \) operation moves the combined checking and saving balance of costumer \codeFont{n} to the checking account of customer $\codeFont{n}'$.
Lastly, \( \codeFont{writeCheck(n,v)} \) cashes a cheque of customer \codeFont{n} in the amount  \codeFont{v} by deducting \codeFont{v} from its checking account.
If \codeFont{n} does not hold sufficient funds (\ie the combined checking and saving balance is less than \codeFont{v}), customer \codeFont{n} is penalised by deducting one additional pound. 
%
In \citet{bank-example-wsi}, the authors argue that to make this library robust against \( \SI \), the \( \codeFont{writeCheck(n,v)} \) operation must be strengthened by writing back the saving account balance
(via \(\pmutate{\pv{n}_s}{\pv{x}} \)),
even though this is unchanged.


The banking library is more complex than the multi-counter library.
Nevertheless, all banking transactions are either read-only or
satisfy the no-blind writes property; \ie the banking library is \(\WSI\)-safe.
As such, we can prove its robustness against $\WSI$ and hence \( \SI
\).

%\pg{Above: now this can be strengthened. It should be pointed out that
%  adding [ns] := x  makes the banking library safe because of 5.3. No
%  what happens when [ns]= x is not there. Can we prove that the
%  library is not safe, maybe transferring an example they discovered in
%  [3] to here or maybe having to find our own example....}
%
%\azalea{According to Shale: I donâ€™t think we can say more. We cannot prove negative results. We can give the same counter example as in the paper but it is not very interesting.}


\mypar{Lock Invariant}

Finally, we demonstrate that, although a distributed lock library is
not robust against \( \UA \), we can nevertheless prove an invariant property 
stating that only one client can hold the lock at a given time, thus establishing a mutual exclusion guarantee. 
The distributed lock library provides the following operations
% \(\plock(k)\), \(\ptrylock(k)\) and \(\punlock(k)\) 
on a key \( \key \):
%
%\SpaceAboveMath
\begin{align*}
    \ptrylock(k) & \defeq \begin{transaction}
    \plookup{\pv{x}}{k}; \ \pifs{\pv{x} {=} 0} \;
    \pmutate{k}{ \var(ClientID) }; \; \passign{\var(m)}{\true} \; \} 
    \CodeFont{else} \{ \; \passign{\var(m)}{\false} \; \pife 
    \end{transaction}     
    \\ \plock(k) & \defeq  \;
    \codeFont{do}  \{\; \ptrylock(\key) \; \} \codeFont{until}(\var(m) {=} \false)
    \qquad \punlock(k) \defeq \begin{transaction}
        \pmutate{k}{ 0 }
    \end{transaction}     
\end{align*}
\SpaceBelowMath

\noindent 
The \( \ptrylock \) operation reads the \( \key \) value;
if the value is zero (\ie the lock is available), 
then it sets it to the client ID and returns \( \true \);
otherwise it leaves it unchanged and returns \( \false \).
The \( \plock \) operation calls \( \ptrylock \) until it successfully acquires the lock.
The \( \punlock \) operation simply set the $\key$ value to zero.

Consider the program pattern \( \prog_{\CodeFont{LK}} \) where clients \( \cl\) and \( \cl'\) compete to acquire the lock \( \key \):
%
%\SpaceAboveMath
\begin{align*}
    \prog_{\CodeFont{LK}} & \defeq ( \cl: (\plock(\key); \ \codeFont{...} ; \ \punlock(\key))^*
    \ \| \ 
    \cl': (\plock(\key); \ \codeFont{...} ; \ \punlock(\key))^* )
\end{align*}
%\SpaceBelowMath
%
%\noindent
The locking pattern in \( \prog_{\CodeFont{LK}} \) is correct, in that
only one client can hold the lock at a time,
when executed under serialisability.
Since all the operations are trivially \( \WSI \)-safe,
\( \prog_{\CodeFont{LK}} \) is robust and hence correct under \( \WSI \) 
as well as stronger models such as \( \SI \).
However, \( \prog_{\CodeFont{LK}} \) is not robust under \( \UA \) or \( \PSI \):
\( \plock \) may read an old value of key \( \key \)
until it reads its most up-to-date value and acquires it.
Nevertheless, we show that \( \prog_{\CodeFont{LK}} \) is correct under \( \UA \) (and hence \( \PSI \)) in that it satisfies a mutual exclusion guarantee where 
only one client can hold the lock at a time. 
We capture this guarantee by the following invariant, stating that for all positive \( i \) (\( i > 0\)): 
%
%\SpaceAboveMath
\begin{align}
& \valueOf(\kvs(\key,i)) \neq 0 \iff \valueOf(\kvs(\key,i-1)) = 0
\label{equ:lock-unique-hold}
\\ & \valueOf(\kvs(\key,i)) = 0 \implies \wtOf(\kvs(\key,i)) = \wtOf(\kvs(\key,i-1))
\label{equ:lock-release}
\end{align}
%\SpaceBelowMath
%
%\noindent
It is straightforward to show that, under \( \UA \), 
only one client can hold the lock \eqref{equ:lock-unique-hold},
and the same client releases the lock \eqref{equ:lock-release}.
Assume a kv-store \( \kvs \) satisfies this invariant.
Given the lock pattern in \( \prog_{\CodeFont{LK}} \),
if the latest value of \( \key \) is 0, 
then all clients are competing to acquire $\key$, and thanks to \( \UA \)
only a client \( \cl \) with full view of \( \key \)
can install a new version with its unique client ID.
This will stop other clients from acquiring $\key$ as the latest value is now non-zero.
Subsequently, when $\cl$ executes its next transaction, \ie \( \punlock(\key) \),
it releases the lock and installs a new version with value zero.

\mypar{Invariants vs. Execution Graphs}
We demonstrated how invariant properties of transactional libraries can be used to prove their robustness, as well as  library-specific guarantees such as mutual exclusion. 
Although the existing literature can establish the robustness of a library using execution graphs (\eg dependency graphs of~\cite{adya}), they typically do this by checking the \emph{final} results of all its client programs.
By contrast, thanks to our operational model, we achieve this by establishing an invariant property at each execution step, thus allowing a simpler, more compositional proof. 
Moreover, whilst it is straightforward for us to prove library-specific guarantees (\eg mutual exclusion for locks) by simply encoding them as an invariant of the library, 
establishing such properties using execution graphs is much more difficult. 
This is because execution graphs do not directly record the library \emph{state} and merely record the execution shape, thus making it harder to reason about such guarantees.

%\pg{Above, last sentence: I haven't checked is this enough. You have
  %not said anything about how this would be proved.}

%\pg{I haven't understood when the lock library is robust and when it
  %is not from what you've written. Is it not robust under SI for
  %example? With UA, we have this result, do I think that means the
  %invariant holds for PSI and SI. I don't know about CC and CP. Can 
%you compelte the story?}
